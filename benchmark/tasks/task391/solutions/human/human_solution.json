[
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2298\n// ?????????????????§?????????????£????????????????????????????\n// ???????????????1????£?????????¨T?§??????????????????¢?????????????????§???????????????\n// ??????????????? 1/T ???/?§? ??????????????§?£?????????????????????????????????¢??????????????¨????????????\n\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst double eps = 1e-10;\n\nint main() {\n  int N;\n  double K;\n  double T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  K = K+1;\n  double D[210];\n  for (auto i=0; i<N; i++) {\n    cin >> D[i];\n  }\n  double nowlength = 0;\n  int nown = 0;\n  double nowcar = 0;\n  double ans = 0;\n  double next = 0;\n  double nowvel = 0;\n  while (nowlength + eps < L) {\n    if (nown < N) {\n      next = D[nown] - nowlength;\n    } else {\n      next = L - nowlength;\n    }\n    if (nowcar < eps) {\n      // cerr << \"does not eat\" << endl;\n      nowvel = U;\n      ans += next/nowvel;\n      nowlength += next;\n      if (nown < N) {\n        nowcar = min(nowcar+1, K);\n      }\n      nown++;\n    } else {\n      // cerr << \"eat\" << endl;\n      nowvel = V;\n      double ablelength = V * T * nowcar;\n      if (ablelength < next - eps) {\n        // cerr << \"does not reach\" << endl;\n        nowlength += ablelength;\n        ans += ablelength/nowvel;\n        nowcar = 0;\n      } else {\n        // cerr << \"reach\" << endl;\n        nowlength += next;\n        ans += next/nowvel;\n        nowcar -= next/(V * T);\n        if (nown < N) {\n          nowcar = min(nowcar+1, K);\n        }\n        nown++;\n      }\n    }\n    /*\n    cerr << \"nowlength = \" << nowlength\n         << \", nown = \" << nown\n         << \", nowcar = \" << nowcar\n         << \", ans = \" << ans \n         << \", nowvel = \" << nowvel\n         << \", next = \" << next\n         << endl;\n    */\n  }\n  printf(\"%0.7lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-12\n\nstruct Node {\n\tdouble t;\n\tdouble rest;\n\tint x;\n};\n\nbool operator >(Node& n1, Node& n2) {\n\treturn n1.t > n2.t;\n}\n\ntypedef long long ll;\n\nint main() {\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<int> d(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> d[i];\n\t}\n\td.push_back(L);\n\n\tll rest = 0;\n\tint x = 0;\n\tll vl = 0, ul = 0;\n\tfor (int i = 0; i < N+1; ++i) {\n\t\tint dx = d[i]-x;\n\t\tif (rest >= dx) {\n\t\t\tvl += dx;\n\t\t\trest -= dx;\n\t\t}\n\t\telse {\n\t\t\tvl += rest;\n\t\t\tul += dx-rest;\n\t\t\trest = 0;\n\t\t}\n\n\t\trest += (ll)T * V;\n\t\tif (rest >= (ll)(K+1) * T * V) rest = (ll)(K+1) * T * V;\n\n\t\tx = d[i];\n\t}\n\tprintf(\"%.10f\\n\", (double)((long double)vl/V + (long double)ul/U));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n int main(void){\n\t int n,k,t,u,v,l;\n\t cin>>n>>k>>t>>u>>v>>l;\n\t vector<int> d(n);\n\t vector<bool> x(l,false);\n\t vector<bool> a(l,false);\n\t for(int i=0;i<n;i++){\n\t\t cin>>d[i];\n\t\t x[d[i]]= true;\n\t } \n\t int rest=0;\n\t int a1=t*v;\n\t int amax=a1*(k+1);\n\t// cout<<amax<<endl;\n\t for(int i=0;i<l;i++){\n\t\t if(x[i])rest+=a1;\n\t\t if(rest>amax)rest=amax;\n\t\t if(rest!=0) {\n\t//\t\t cout<<rest<<\" \";\n\t\t\t rest--;\n\t\t\t a[i]=true;\n\t//\t\t cout<<i<<\" \";\n\t\t }\n\t }\n\t\tint nl=0,al=0;\n\t\tfor(int i=0;i<l;i++){\n\t\t\tif(a[i])al++;\n\t\t\telse nl++;\n\t\t}\n\t//\tcout<<al<<\" \"<<nl<<endl;\n\tprintf(\"%f\\n\",(double)al/v+(double)nl/u);\n\n\t//cout<<(double)al/v+(double)nl/u;\n\n\t return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n, k, t, u, v, l;\n\tdouble second;\n\tdouble length;\n\n\tcin >> n >> k >> t >> u >> v >> l;\n\tint *d;\n\td = (int *)calloc(n, sizeof(int));\n\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> d[i];\n\n\t//d[0]までは速さuで走る\n\tsecond = (double)d[0] / u;\n\tlength = (double)d[0];\n\n\tcout << second << endl << length << endl;\n\n\t//d[0]からt秒間速さvで加速して走る\n\tsecond += t;\n\tlength += v*t;\n\n\tcout << second << endl << length << endl;\n\n\tif(l - length < 0)\t\t//lengthがlを超えた場合\n\t\t{\n\t\t\tsecond -= t;\n\t\t\tlength -= v*t;\n\t\t\tsecond += (l-length) / v;\n\t\t\tlength = l;\n\t\t}\n\n\tint counter = 0;\t//counter(持っている人参の数)\n\tint j = 1;\n\n\twhile(length - d[j] >= 0 && j < n &&length != l) //d地点を何個抜かしたか\n\t{\n\t\tif(counter < k)\n\t\t\tcounter++;\n\t\t\n\t\tj++;\n\t}\n\n\twhile(length != l)\t//counterの個数だけ加速 ちなみにcounterがマイナスになることはない\n\t{\n\t\tif(counter > 0)\n\t\t{\n\t\t\tsecond += t;\n\t\t\tlength += v*t;\n\t\t\tcounter--;\t\t//加速したらcounterを1減らす\n\t\t\tcout << second << endl << length << endl << counter << endl;\n\n\t\t\tif(length - l > 0)\t\t//lengthがlを超えた場合\n\t\t\t{\n\t\t\t\tsecond -= t;\n\t\t\t\tlength -= v*t;\n\t\t\t\tsecond += (l-length) / v;\n\t\t\t\tlength = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(length - d[j] >= 0 && j < n) //d地点を何個抜かしたか\n\t\t\t{\n\t\t\t\tif(counter < k)\n\t\t\t\t\tcounter++;\n\t\t\t\tj++;\n\t\t\t}\t\t\n\t\t}\n\t\telse\t\t//counterが0のとき\n\t\t{\n\t\t\tif(j < n)\t\t//まだ先に人参がある場合\n\t\t\t{\n\t\t\t\tsecond += (double)(d[j] - length) / u;\t\t//普通の速度で\n\t\t\t\tlength = d[j];\n\t\t\t\tj++;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\telse if(j == n)\t//加速していない状態で先にあるのはゴールだけ\n\t\t\t{\n\t\t\t\tsecond += (double)(l - length) / u;\t\t//普通の速度で\n\t\t\t\tlength = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(length == l)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"%.9f\\n\", second);\n\n\tfree(d);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N,K,T,U,V,L;\nbool mp[10010];\n\nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  int cnt=0;\n  for(int i=0,a,A;i<N;i++){\n    cin>>a;\n    A=a;\n    while(mp[a])a++;\n    while((1.0*a-A)/V>K)a--;\n    for(int j=a;j<=L&&j<a+T*V;j++) cnt+=!mp[j],mp[j]=1;\n  }\n  printf(\"%.8f\\n\",(1.0*cnt/V)+(1.0*(L-cnt)/U));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int n, k, l;\n    double t, u, v, d[200];\n    \n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i, n){\n        cin >> d[i];\n    }\n    \n    double ans = 0.0;\n    int boost_time = 0, ninjin_p = 0, boost_cnt = 0;\n    for(int i = 1; i <= l; i++){\n        if(boost_time){\n            ans += 1.0 / v + 1e-12;\n            boost_time--;\n        }\n        else{\n            ans += 1.0 / u + 1e-12;\n        }\n        \n        if(i == d[ninjin_p]){\n            if(boost_time >= k * v){\n                boost_time = (k + 1) * v;\n            }\n            else{\n                boost_time += v;\n            }\n            if(ninjin_p < n - 1)ninjin_p++;\n        }\n    }\n    \n    printf(\"%.11lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tdouble n, k, t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tqueue<int> d;\n\tREP(i, n)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\td.push(a);\n\t}\n\tint car = 0;\n\tint run = 0;\n\tint walk = 0, running = 0;\n\n\tREP(i, l)\n\t{\n\t\tif (!d.empty() && d.front() == i)\n\t\t{\n\t\t\td.pop();\n\t\t\tif (run == 0) run += t*v;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (car < k) car++;\n\t\t\t\telse run = t*v;\n\t\t\t}\n\t\t}\n\n\t\tif (run == 0 && car>0)\n\t\t{\n\t\t\tcar--;\n\t\t\trun = t*v;\n\t\t}\n\n\t\tif (run > 0)\n\t\t{\n\t\t\trunning++;\n\t\t\trun--;\n\t\t}\n\t\telse walk++;\n\n\n\t}\n\n\tcout << D10 << running / v + walk / u << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main(void)\n{\n\tint N, K, T, V, U, L;\n\tdouble eat_d, distance;\n\tdouble result = 0.0;\n\tint c_num = 0, eat_num;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(N);\n\trep(i, N){\n\t\tcin >> D[i];\n\t}\n\trep(i, N){\n\t\tif (i == 0){\n\t\t\teat_d = (double)D[i];\n\t\t\tresult += eat_d / U;\n\t\t}else{\n\t\t\teat_num = 0;\n\t\t\tdistance = (double)D[i] - eat_d;\n\t\t\twhile(c_num > 0 && distance > (double)V*T*(eat_num+1)){\n\t\t\t\tc_num--;\n\t\t\t\teat_num++;\n\t\t\t}\n\t\t\tresult += (double)T*eat_num;\n\t\t\teat_d += (double)V*T*eat_num;\n\n\t\t\tdistance = (double)D[i] - eat_d;\n\t\t\tif (distance > (double)V*T){\n\t\t\t\tresult += (double)T + (distance-(double)V*T) / U;\n\t\t\t\teat_d = (double)D[i];\n\t\t\t}else if(c_num == K){\n\t\t\t\tresult += distance / V;\n\t\t\t\teat_d = (double)D[i];\n\t\t\t}else{\n\t\t\t\tc_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\teat_num = 0;\n\tdistance = (double)L - eat_d;\n\twhile(c_num > 0 && distance > (double)V*T*(eat_num+1)){\n\t\tc_num--;\n\t\teat_num++;\n\t}\n\tresult += (double)T*eat_num;\n\teat_d += (double)V*T*eat_num;\n\n\tdistance = (double)L - eat_d;\n\tif (distance > (double)V*T){\n\t\tresult += (double)T + (distance-(double)V*T) / U;\n\t}else{\n\t\tresult += distance / V;\n\t}\n\n\tcout << fixed << setprecision(9) << result << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#define F(n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(void){\nint n,k,t,u,v,l;\ncin>>n>>k>>t>>u>>v>>l;\nint ma=t*v*(k+1);\nint a=t*v;\nint rest=0;\nint temp,acc=0;\nvector<bool> d(l,false);\nF(n){\n\tcin>>temp;\n\td[temp]=true;\n}\nF(l){\n\tif(d[i]){\n\t\trest+=a;\n\t}\n\tif(rest>ma){\n\t\trest=ma;\n\t}\n\tif(rest!=0){\nacc++;\nrest--;\n\t}\n\t\n}\ndouble time=(double)acc/v+(double)(l-acc)/u;\nprintf(\"%0.7f\\n\",time);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/numeric/interval.hpp>\n#include <boost/numeric/interval/io.hpp>\nusing namespace::std;\nnamespace mp = boost::multiprecision;\ntypedef mp::number<mp::cpp_dec_float<32,int64_t>> cfloat;\ntypedef mp::cpp_int cint;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define sl(c) (('a')<=(c)&&(c)<=('z'))\n#define ll(c) (('A')<=(c)&&(c)<=('Z'))\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define PI 3.141592653589793\n#define cout (cout<<fixed<<setprecision(15))\n#define makeupper(t) (transform(all(t),t.begin(),::toupper))\n#define makelower(t) (transform(all(t),t.begin(),::tolower))\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define NEXT_LINE string junk; getline(cin, junk);\n#define output(v) do{rep(i,v.size())cout<<(i?\" \":\"\")<<v[i];cout<<\"\\n\";}while(0)\n#define output2(v) rep(i,v.size()){rep(j,v[i].size()){cout<<(j?\" \":\"\")<<v[i][j];}cout<<\"\\n\";}\n#define INF 1LL<<40\n#define IINF 1<<30\n#define LINF 9223372036854775807\n#define MOD 1000000007\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\nvector<lint> operator+(const vector<lint>& v1,const vector<lint>& v2){\n    vector<lint> v(v1.size()+v2.size(),0);\n    rep(i,v1.size())v[i]=v1[i];\n    rep(i,v2.size())v[i+v1.size()]=v2[i];\n    return v;\n}\ninline lint sum(vector<lint> v){\n    lint sum=0;\n    rep(i,v.size())sum+=v[i];\n    return sum;\n}\ninline string replace(string str, string before, std::string after) {\n\tstring::size_type  Pos(str.find(before));\n\twhile (Pos != std::string::npos) {\n\t\tstr.replace(Pos, before.length(), after);\n\t\tPos = str.find(before, Pos + after.length());\n\t}\n\treturn str;\n}\ninline vector<string> split(string s, string delim) {\n\tvector<string> elems;\n\ts=replace(s, \"#\", \"HASH\");\n\ts=replace(s, delim,\"#\");\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, '#')) {\n\t\telems.push_back(replace(item, \"HASH\", \"#\"));\n\t}\n\treturn elems;\n}\ninline vector<int> cross(vector<int> a, vector<int> b) {\n    return { a[1] * b[2] - a[2] * b[1],a[2] * b[0] - a[0] * b[2],a[0] * b[1] - a[1] * b[0] };\n}\ninline lint GCD(lint a,lint b){return b?GCD(b,a%b):a;}\ninline vector<lint> primeList(lint n) {\n    vector<bool> p(n+1);\n    vector<lint> list;\n    repi(i,1, n+1)p[i] = true;\n    repi(i,2,sqrt(n)+1) {\n        if (p[i]) {\n            repi(j,2,n/i+1) {\n                p[i*j] = false;\n            }\n        }\n    }\n    repi(i, 2, n+1)if (p[i])list.push_back(i);\n    return list;\n}\ninline set<lint> primeSet(lint n) {\n    vector<bool> p(n+1);\n    set<lint> set;\n    repi(i,1, n+1)p[i] = true;\n    repi(i,2,sqrt(n)+1) {\n        if (p[i]) {\n            repi(j,2,n/i+1) {\n                p[i*j] = false;\n            }\n        }\n    }\n    repi(i, 2, n+1)if (p[i])set.insert(i);\n    return set;\n}\ninline bool isPrime(int num){\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false;\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0)return false;\n    }\n    return true;\n}\ninline lint max(vector<lint> num){\n    lint M=num[0];\n    rep(i,num.size())M=max(M,num[i]);\n    return M;\n}\ninline lint min(vector<lint> num){\n    lint M=num[0];\n    rep(i,num.size())M=min(M,num[i]);\n    return M;\n}\ninline cint cmax(vector<cint> num){\n    cint M=num[0];\n    rep(i,num.size())if(M<num[i])M=num[i];\n    return M;\n}\ninline cint cmin(vector<cint> num){\n    cint M=num[0];\n    rep(i,num.size())if(M>num[i])M=num[i];\n    return M;\n}\ninline lint signal(lint val){\n    if(val==0)return 0;\n    else return val/abs(val);\n}\nstruct IVector2{\n    lint x,y;\n};\nbool operator< (const IVector2 &s, const IVector2 &t){\n        return s.x==t.x?s.y<t.y:s.x<t.x;\n};\nbool operator> (const IVector2 &s, const IVector2 &t){\n        return s.x==t.x?s.y>t.y:s.x>t.x;\n};\nstruct IVector3{\n    lint x,y,z;\n};\nstruct IVector4{\n    lint x,y,z,w;\n};\nlint mul(lint a,lint b){\n    lint ans=0;\n    rep(i,b){\n        ans+=a;\n        ans%=MOD;\n    }\n    return ans;\n}\nlint add(lint a,lint b){\n    a%=MOD;\n    b%=MOD;\n    return (a+b)%MOD;\n}\nint main(){\n    lint n,k,t,u,v,l;\n    cin>>n>>k>>t>>u>>v>>l;\n    vec d(n);\n    rep(i,n)cin>>d[i];\n    rep(i,n)d[i]++;\n    double time=0;\n    lint index=0;\n    lint slowDown=0;\n    vec dp(l+1,0);\n    repi(i,1,l+1){\n        dp[i]=dp[i-1];\n        lint tmp=0;\n        if(d[index]==i){\n            tmp++;\n            if(dp[i-1]==k){\n                slowDown=i+v*t;\n            }else{\n                dp[i]++;\n            }\n        }\n        if(index<n&&i==max(slowDown,d[index])&&dp[i]!=0){\n            slowDown=i+t*v;\n            dp[i]--;\n        }else if(i==slowDown&&dp[i]!=0){\n            slowDown=i+t*v;\n            dp[i]--;\n        }\n        index+=tmp;\n        if(i<slowDown){\n            time+=1./v;\n        }else{\n            time+=1./u;\n        }\n    }\n    //output(dp);\n    cout<<time;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <set>\n#include <sstream>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)x)<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define EREP(i,a,b) for(int i=a;i<=b;i++)\n#define erep(i,n) EREP(i,0,n)\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nint main(void){\n  int n,k,t,u,v,l;\n  int d[202];\n  bool flg[10002];\n\n  while(cin>>n>>k>>t>>u>>v>>l){\n    memset(flg,0,sizeof(flg));\n    rep(i,n){\n      cin>>d[i];\n      flg[d[i]] = true;\n    }\n\n    int pos = 0;\n    int rem = 0;\n    int hav = 0;\n    double ans = 0;\n\n    while(pos < l){\n      if(flg[pos]){\n        if(hav == k){\n          rem = t * v;\n        }\n        else{\n          hav++;\n          if(rem == 0){\n            rem = t * v;\n            hav--;\n          }\n        }\n\n        ans += 1.0 / v;\n        rem--;\n        if(rem == 0 && hav > 0){\n          rem = t * v;\n          hav--;\n        }\n      }\n      else{\n        if(rem > 0){\n          ans += 1.0 / v;\n          rem--;\n          if(rem == 0 && hav > 0){\n            rem = t * v;\n            hav--;\n          }\n        }\n        else{\n          ans += 1.0 / u;\n        }\n      }\n\n      pos++;\n    }\n\n    printf(\"%.7f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 201\nusing namespace std;\nint N,K;\ndouble T,U,V,L;\ndouble D[MAX];\n\nint main()\n{\n  while(cin >> N >> K >> T >> U >> V >> L)\n    {\n      rep(i,N)cin >> D[i];\n      int cnt = 0;\n      double boost = 0;\n      double tm = 0;\n      int index = 0;\n\n      rep(t,L)\n\t{\n\t  if(index < N && D[index] == t)\n\t    {\n\t      if(cnt < K)\n\t\t{\n\t\t  cnt++;\n\t\t}\n\t      else \n\t\t{\n\t\t  boost = V*T;\n\t\t}\t  \n\t      index++;    \n\t    }\n\n\t  if(boost == 0 && cnt > 0)\n\t    {\n\t      cnt--;\n\t      boost = V*T;\n\t    }\n\n\n\t  if(boost == 0)tm += 1.0/U;\n\t  else\n\t    {\n\t      tm += 1.0/V;\n\t      boost--;\n\t    }\n\n\n\n\t}      \n      cout << setiosflags(ios::fixed) << setprecision(9) << tm << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(a)<(b))\n#define F first\n#define S second\nusing namespace std;\nint D[210];\nint main(){\n\tint N,K,T,U,V,L;\n\tcin>>N>>K>>T>>U>>V>>L;\n\tREP(i,0,N) cin>>D[i];\n\tint d=0,cnt=0,t=0,have=0;\n\tREP(i,1,L+1){\n\t\tt=max(t-1,0);\n\t\tif(i==D[d]){\n\t\t\td++;\n\t\t\tif(t==0||have==K){\n\t\t\t\tt=T*V;\n\t\t\t}else if(have<K){\n\t\t\t\thave++;\n\t\t\t}\n\t\t}else{\n\t\t\tif(t==0&&have>0){\n\t\t\t\tt=T*V;\n\t\t\t\thave--;\n\t\t\t}\n\t\t}\n\t\tif(t>0) cnt++;\n\t}\n\tdouble ans=1.0*cnt/V + 1.0*(L-cnt)/U;\n\tprintf(\"%.7lf\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint N, K, T, U, V, L, D[500];\n\nint main() {\n    scanf(\"%d%d%d%d%d%d\", &N, &K, &T, &U, &V, &L);\n    rep(i, N) scanf(\"%d\", D+i);\n    D[N++] = L;\n    const int Z = T*V;\n    int uL=0, vL=0, h=0, e=0, p=0;\n    rep(i, N) {\n        if(e>=D[i]) vL += D[i]-p;\n        else {\n            vL += e-p;\n            uL += D[i]-e;\n        }\n        p = D[i];\n        if(i==N-1) break;\n        if(h<K) h++;\n        else e = D[i]+Z;\n        if(e<D[i]) e = D[i];\n        while(h && e<D[i+1]) {\n            e += Z;\n            h--;\n        }\n    }\n    printf(\"%.9f\\n\", (double)uL/U+(double)vL/V);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n, k, t, u, v, l;\n    cin >> n;\n    cin >> k;\n    cin >> t;\n    cin >> u;\n    cin >> v;\n    cin >> l;\n    int d[n];\n    for(int i = 0; i < n; i++){\n        cin >> d[i];\n    }\n\n    const int boost_length = v * t;\n\n    int distance = 0;\n    int slow_distance = 0;\n    int carot_num = 0;\n    int reached_point;\n\n    /*1本目の人参まで*/\n    distance += d[0];\n    slow_distance += d[0];\n    carot_num++;\n    reached_point = 0;\n\n    /*2本目以降*/\n    while(distance < l){\n        if(carot_num == 0){\n            if(reached_point == (n-1)){\n                slow_distance += l - distance;            \n                distance = l;\n            } else {\n                reached_point++;\n                slow_distance += d[reached_point] - distance;\n                distance = d[reached_point];\n                carot_num++;\n            }\n        } else {\n            int old_distance = distance;\n            distance += boost_length;\n            int old_point = reached_point;\n            for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n            }\n            reached_point--;\n            carot_num += reached_point - old_point - 1;\n            while(1){\n                if(carot_num <= k){\n                    break;\n                }\n                distance += d[reached_point] - old_distance;\n                old_point = reached_point;\n                for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n                }\n                reached_point--;\n                carot_num += reached_point - old_point - 1;\n                if(distance >= l){\n                    break;\n                }\n            }\n        }\n    }\n    double time = 0;\n    cout << slow_distance << endl;\n    int rest1 = slow_distance % u;\n    int rest2 = (l - slow_distance) % v;\n    time += rest1  *1.0 / u;\n    time += rest2 *1.0 / v;\n    time += slow_distance / u;\n    time += (l - slow_distance) / v;\n    cout << time << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  double lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k>0&&l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  double ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=0;i<L;i++){\n    ans+=1.00/lv[i];\n  }\n  printf(\"%.10lf\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nint main(void) {\n  int N,K;\n  double T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  vector<double> D(N);\n  double crt = 0.0;\n  double time = 0.0;\n  REP(i,N){\n    cin>>D[i];\n    if(i) {\n      int dist = D[i] - D[i-1];\n      if(crt > 0.0) {\n        if(dist < T*V*crt) {\n          crt -= dist/(T*V);\n          time += dist / V;\n        } else {\n          time += T*crt;\n          time += (dist-T*V*crt)/U;\n          crt = 0.0;\n        }\n      } else {\n        time += dist / U;\n      }\n    } else {\n      time += D[0] / U;\n    }\n    if(crt < K)\n      crt += 1.0;\n    else\n      crt = K + 1.0;\n  }\n  int dist = L - D[N-1];\n  if(crt > 0.0) {\n    if(dist < T*V*crt) {\n      crt -= dist/(T*V);\n      time += dist / V;\n    } else {\n      time += T*crt;\n      time += (dist-T*V*crt)/U;\n      crt = 0.0;\n    }\n  } else {\n    time += dist / U;\n  }\n  cout << fixed << setprecision(10) << time << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main()\n{\n    int N, K, T, U, V, L;\n    std::cin >> N >> K >> T >> U >> V >> L;\n    std::vector<long double> D(N);\n    for (auto& e: D) std::cin >> e;\n    D.push_back(L);\n    for (int i{N}; i > 0; i--)\n        D[i] -= D[i - 1];\n    \n    long double rest{}, time{};\n    for (int i{}; i <= N; i++)\n    {\n        if (rest * V <= D[i])\n        {\n            time += rest + (D[i] - rest * V) / U;\n            rest = 0;\n        }\n        else\n        {\n            time += D[i] / V;\n            rest -= D[i] / V;\n        }\n        rest = std::min(rest + T, (long double)T * (K + 1));\n    }\n    printf(\"%.10Lf\\n\", time);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve() {\n\tint n, k, t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tvector<int> inputs;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\tinputs.push_back(a);\n\t}\n\tinputs.push_back(0);\n\tinputs.push_back(l);\n\tsort(ALL(inputs));\n\tlong double ans = 0;\n\tint stock = 0;\n\tlong double now_time = 0;\n\tfor (int i = 1; i < inputs.size();++i) {\n\t\tlong double distance = inputs[i] - inputs[i - 1];\n\t\twhile (distance > 0.00000000L + eps) {\n\t\t\tif (now_time > eps) {\n\t\t\t\tif (distance > now_time* (long double)v) {\n\t\t\t\t\tdistance -= now_time * (long double)v;\n\t\t\t\t\tans += now_time;\n\t\t\t\t\tnow_time = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong double used = distance / (long double)v;\n\t\t\t\t\tnow_time -= used;\n\t\t\t\t\tans += used;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (stock > 0) {\n\t\t\t\t\tstock--;\n\t\t\t\t\tnow_time = t;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans += distance / (long double)u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstock++;\n\t\tif (stock - 1 == k) {\n\t\t\tnow_time = t;\n\t\t\tstock = min(stock, k);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N,K,T,U,V,L;\n\tcout.setf(ios::fixed);\n\tcout.precision(8);\n\n\tcin >> N >> K >> T >> U >> V >> L;\n\tint a[N+1], c=0, udist=0, vdist=0, vend;\n\tfor (int i=0; i<N; i++)\n\t\tcin >> a[i];\n\ta[N] = L;\n\n\tudist = a[0];\n\tvend = a[0]+V*T;\n\tfor (int i=0; i<N; i++)\n\t{\n\t\twhile (c>0 && vend<a[i+1])\n\t\t{\n\t\t\tc--; vend += V*T;\n\t\t}\n\n\t\tif (c == 0 && vend<a[i+1])\n\t\t{\n\t\t\tvdist += vend - a[i];\n\t\t\tudist += a[i+1] - vend;\n\t\t\tvend = a[i+1] + V*T;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvdist += a[i+1] - a[i];\n\t\t\tif (c == K)\n\t\t\t\tvend = a[i+1] + V*T;\n\t\t\telse\n\t\t\t\tc++;\n\t\t}\n\t}\n\tcout << double(udist)/double(U) + double(vdist)/double(V) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n \n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n \ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n \nint main(){\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N);\n  REP(i, N) cin >> D[i];\n \n \n  double res = 0;\n  double pos = 0;\n  int carrot = 0;\n  int i = 0;\n  while(i < N){\n    // move to a next carrot\n    res += (D[i] - pos) / U;\n    pos = D[i++];\n    carrot++;\n \n    while(carrot > 0){\n      // eat carrot\n      // cout << pos << \" \" << res << endl;      \n      carrot--;\n      double next = min(pos + T * V, (double)L);;\n \n      while(i < N && D[i] < next){\n        carrot++;\n        i++;\n      }\n \n      if(carrot > K){\n        carrot = K + 1;\n        res += (D[i-1] - pos) / V;\n        pos =  D[i-1];\n      }else{\n        res += (next - pos) / V;\n        pos = next;\n      }\n    }\n    assert(carrot == 0);\n  }\n  cout << fixed << setprecision(20) << res + (L - pos) / U << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,k,t,u,v,m;\n  cin >> n >> k >> t >> u >> v >> m;\n  int d[m+1];\n  mem(d);\n  rep(i,n) {\n    int x;\n    R x;\n    d[x]++;\n  }\n  double ans=0,x=0;\n  rep(i,m) {\n    if(d[i]&&x<t*(k+1)) x+=t;\n    x=min(x,(double)t*(k+1));\n    if(!x) ans+=1.0/u;\n    else {\n      ans+=1.0/v;\n      x-=1.0/v;\n      if(fabs(x)<1e-9) x=0;\n      x=max(x,0.0);\n    }\n  }\n  pd(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint a, b, c, d, e, f, g;\nint remain;\nint speed;\nint x[10000000];\ndouble res;\nint main() {\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor (int i = 0; i < a; i++) {\n\t\tcin >> g;\n\t\tx[g] = 1;\n\t}\n\tfor (int i = 0; i < f; i++) {\n\t\tif (x[i] == 1) {\n\t\t\tif (remain / (c * e) < b) {\n\t\t\t\tremain += c * e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg = ((c * e) - (remain % (c * e)));\n\t\t\t\tif (g == c * e) { g = 0; }\n\t\t\t\tremain += g;\n\t\t\t}\n\t\t}\n\t\tif (remain > 0) {\n\t\t\tres += 1.0 / e;\n\t\t\tremain--;\n\t\t}\n\t\telse {\n\t\t\tres += 1.0 / d;\n\t\t}\n\t}\n\tcout << setprecision(15) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, k, t, u, v, l;\nint d[210];\ndouble dp[210][210];\n\nint main(){\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) cin >> d[i];\n\td[n++] = l;\n\trep(i, n) rep(j, n) dp[i][j] = INF;\n\tdp[0][1] = d[0] * 1.0 / u;\n\t\n\tdouble res = INF;\n\trep(i, n) rep(j, k + 1) if(dp[i][j] < INF){\n\t\tint ni = i + 1, nj = j;\n\t\tdouble dist = d[i], next = dp[i][j];\n\t\t\n\t\tif(dist < d[ni] + EPS) dp[ni][nj] = min(dp[ni][nj], next + (d[ni] - dist) / u);\n\t\t\n\t\twhile(ni < n){\n\t\t\twhile(nj > 0 && dist + EPS < d[ni]){\n\t\t\t\tnj--;\n\t\t\t\tdist += t * v;\n\t\t\t\tnext += t;\n\t\t\t}\n\t\t\tif(dist + EPS > d[n - 1]){\n\t\t\t\tres = min(res, next - (dist - d[n - 1]) / v);\n\t\t\t}\n\t\t\tif(dist < d[ni] + EPS){\n\t\t\t\tdp[ni][nj] = min(dp[ni][nj], next + (d[ni] - dist) / u);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(nj == k){\n\t\t\t\tnext = next - (dist - d[ni]) / v + t;\n\t\t\t\tdist = d[ni] + t * v;\n\t\t\t}\n\t\t\tni++;\n\t\t\tnj = min(nj + 1, k);\n\t\t}\n\t}\n\trep(i, k + 1) res = min(res, dp[n - 1][i]);\n\tprintf(\"%.9f\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\nint N,K,T,v1,v2,L;\nint D[220];\ndouble ans;\nint now;\ndouble up;\nint yorn;\nint have;\n\n\nint main(){\n\tcin >> N >> K >> T >> v1 >> v2 >> L;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> D[i];\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(yorn==0){\n\t\t\tans += 1.0*(D[i]-now)/v1;\n\t\t\tup = D[i] + T*v2;\n\t\t\tnow = D[i];\n\t\t\tyorn = 1;\n\t\t}\n\t\telse if(yorn==1){\n\t\t\tif(D[i]>up){\n\t\t\t\twhile(D[i]>up && have>0){\n\t\t\t\t\thave --;\n\t\t\t\t\tup += T*v2;\n\t\t\t\t}\n\t\t\t\tif(D[i]>up){\n\t\t\t\t\tans += 1.0*(up-now)/v2;\n\t\t\t\t\tans += 1.0*(D[i]-up)/v1;\n\t\t\t\t\tup = D[i]+T*v2;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\thave ++;\n\t\t\t\t\thave = min(have,K);\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(D[i]<up){\n\t\t\t\tif(have==K){\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\tup = D[i] + T*v2;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\thave++;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\tup = D[i] + T*v2;\n\t\t\t\tnow = D[i];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\n\t}\n\twhile(have>0){\n\t\thave --;\n\t\tup += T*v2;\n\t}\n\tif(L > up){\n\t\tans += 1.0*(up-now)/v2;\n\t\tans += 1.0*(L-up)/v1;\n\t}\n\telse{\n\t\tans += 1.0*(L-now)/v2;\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tll N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<ll> D(N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> D[i];\n\t}\n\tD[N] = L;\n\tdouble res = (double)D[0] / U, pos = D[0];\n\tll cnt = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (D[i] <= pos + T * V * cnt) {\n\t\t\tint tmp = cnt - (D[i] - pos) / (T * V);\n\t\t\tif (tmp < K) {\n\t\t\t\tcnt++;\n\t\t\t\tif (i == N) {\n\t\t\t\t\tres += (double)(D[i] - pos) / V;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += (double)(D[i] - pos) / V;\n\t\t\t\tcnt = K + 1;\n\t\t\t\tpos = D[i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tres += T * cnt + (double)(D[i] - pos - T * V * cnt) / U;\n\t\t\tcnt = 1;\n\t\t\tpos = D[i];\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#define EPS 1e-7\nusing namespace std;\n\nint main(){\n  int n,k,t,u,v,l;\n  int a;\n  queue<int> q;\n\n  cin >>n>>k>>t>>u>>v>>l;\n  while( n-- ){\n    cin >> a; q.push( a );\n  }\n\n  double time=0.0, now=0.0;\n  double disV = v*t;\n  int have=0;\n  while( now<l ){\n    if( have==0 ){\n      if( q.empty() ){\n\ttime += (l-now)/(double)u;\n\tbreak;\n      }else{\n\ta=q.front(); q.pop(); have++;\n\ttime += (a-now)/(double)u;\n\tnow=a;\n      }\n    }else{\n      have--;\n      if( l-now < disV || fabs(l-now-disV)<EPS ){\n\ttime += (l-now)/(double)v;\n\tbreak;\n      }else{\n       double move = t*v;\n       while( !q.empty() &&\n\t   ( now+move>q.front() || fabs(now+move-q.front())<EPS ) ){\n\t have++;\n\t if( have>k ){\n\t   move = q.front()-now; q.pop();\n\t   break;\n\t }\n\t q.pop();\n       }\n       now += move;\n       time += move/(double)v;\n      }\n    }\n  }\n  printf(\"%.10lf\\n\",time);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rev(i,n) for(int i=(int)n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? n==1 ? x: b_pow(x,n>>1)*b_pow(x,(n>>1)+(n&1)) : 1;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n//long longÉ«ðÂ¯Ä\n\nint N,K;\ndouble T,U,V,L;\nvector<int> D;\n\n\nint main(){\n\tcin >> N >> K >> T >> U >> V >> L;\n\trep(i,N){\n\t\tint t; cin >> t;\n\t\tD.push_back(t);\n\t}\n\tD.push_back(L);\n\tdouble R = 0;\n\tint C = 0;\n\tdouble time = 0;\n\tint cur = 0;\n\tfor(int i = 0 ; i < N+1 ; i++){\n\t\tdouble Di = (D[i]-cur);\n\t\twhile(Di > EPS){\n\t\t\tdouble use = min(Di / V , R);\n\t\t\ttime += use;\n\t\t\tR -= use;\n\t\t\tDi -= use * V;\n\t\t\tif(R < EPS && C) C -= 1  , R = T;\n\t\t\telse{\n\t\t\t\ttime += (Di / U);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(C==K) R=T , C-=1;\n\t\tC += 1;\n\t\tcur = D[i];\n\t}\n\tprintf(\"%.7f\\n\",time);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,K,L;\ndouble T,U,V;\nbool getca[10500];\nconst int INF=1e9;\ntemplate<typename A,size_t N,typename T>\nvoid Fill(A (&array)[N],const T &val)\n{\n    std::fill( (T*)array,(T*)(array+N),val );\n}\nint main()\n{\n  cin >> N >> K >> T >> U >> V >> L;\n  memset(getca,false,sizeof(getca));\n  for (int i = 0; i <N; i++)\n  {\n      int c;\n      cin >> c;\n      getca[c]=true;\n  }\n  int pos=0;\n  int carrot=0;\n  double time=0.0;\n  double speedup=0;\n  while(pos<L)\n  {\n      pos++;\n      if(speedup>1e-9) time+=1.0/V;\n      else time+=1.0/U;\n      if(speedup>1e-9) speedup-=(1.0/V);\n      if(carrot>0 && speedup<1e-9) \n      {\n          carrot--;\n          speedup=T;\n      }\n      if(getca[pos])\n      {\n          if(speedup<1e-9 || carrot==K) speedup=T;\n          else carrot++;\n      }\n      //cout << pos << ' ' << time << ' ' << speedup << endl;\n  }\n  cout << fixed << setprecision(9) << time << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, k, t; cin >> n >> k >> t;\n  int u, v, l; cin >> u >> v >> l;\n  t *= v;\n  bitset<10000> bs;\n  while (n--) {\n    int d; cin >> d;\n    bs[d] = true;\n  }\n  double res = 0;\n  int c = 0, r = 0;\n  for (int x = 0; x < l; ++x) {\n    if (bs[x]) {\n      if (c < k and r) ++c;\n      else r = t;\n    }\n    res += 1.0 / (r ? v : u);\n    if (r) {\n      if (!--r and c) {\n        --c;\n        r = t;\n      }\n    }\n  }\n  cout << fixed << setprecision(15) << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct state\n{\n\tint idx;\n\tdouble time;\n\tint have;\n\tdouble limit;\n\tbool operator<(const state& right) const{\n\t\treturn time != right.time ? time > right.time : idx != right.idx ? idx < right.idx : have < right.have;\n\t}\n};\n\nint main() {\n\tint n, m;\n\tdouble effect, u, v, len;\n\tcin>> n>> m>> effect>> u>> v>> len;\n\tvector<double> boost(n);\n\tREP(i, n)\n\t\tcin>>boost[i];\n\tpriority_queue<state> Q;\n\tQ.push({ 0, boost[0] / u, 0, 0.0 });\n\tvector<vector<double>> G(n,vector<double>(m+1,1e9));\n\tdouble ans = 0.0;\n\twhile (!Q.empty())\n\t{\n\t\tstate q = Q.top();Q.pop();\n\t\tq.have = min(q.have + 1, m+1);\n\t\tif (q.have == m + 1)\n\t\t\tq.limit = 0;\n\t\tif (q.idx == n - 1) {\n\t\t\tif (len - boost[n - 1] - (q.have*effect+q.limit)*v <= 0.0)\n\t\t\t\tQ.push({n,q.time+ (len - boost[n - 1] )/v,0,0.0});\n\t\t\telse\n\n\t\t\t\tQ.push({ n,q.time+ q.have*effect+q.limit+ (len - boost[n - 1] - (q.have*effect + q.limit)*v)/u,0,0.0 });\n\t\t\tcontinue;\n\t\t}\n\t\tif (q.idx == n) {\n\t\t\tans=q.time;\n\t\t\tbreak;\n\t\t}\n\t\t\tREP(i, q.have + 1) {//???????????°\n\t\t\t\tif (q.have - i > m)continue;\n\t\t\t\tdouble kasoku_load = (q.limit + effect*i)*v;\n\t\t\t\tif (boost[q.idx + 1] - boost[q.idx] <= kasoku_load) {\n\t\t\t\t\tif (G[q.idx + 1][q.have - i] > q.time + (boost[q.idx + 1] - boost[q.idx]) / v) {\n\t\t\t\t\t\tQ.push({ q.idx + 1,q.time + (boost[q.idx + 1] - boost[q.idx]) / v,q.have - i,max(0.0,q.limit + effect*i - (boost[q.idx + 1] - boost[q.idx]) / v) });\n\t\t\t\t\t\tG[q.idx + 1][q.have - i] = q.time + (boost[q.idx + 1] - boost[q.idx]) / v;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (G[q.idx + 1][q.have - i] > q.time + q.limit + effect*i + (boost[q.idx + 1] - boost[q.idx] - kasoku_load) / u) {\n\t\t\t\t\t\tQ.push({ q.idx + 1,q.time + q.limit + effect*i + (boost[q.idx + 1] - boost[q.idx] - kasoku_load) / u,q.have - i,0.0 });\n\t\t\t\t\t\tG[q.idx + 1][q.have - i] = q.time + q.limit + effect*i + (boost[q.idx + 1] - boost[q.idx] - kasoku_load) / u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t}\n\n\tprintf(\"%.9lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nint main(){\n    int n;\n    double k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n\n    double c[205];\n    rep(i,n) cin >> c[i];\n    c[n] = l;\n\n    double m, h, s; //?????¨???????????????????????°????????????????????????\n    double time = 0;\n    int i = 0;\n    while(m < l){\n        double next = c[i] - m;\n        if((h > 0 && s < EPS) || h > k){\n            h--;\n            s = t;\n        }else if(h == 0 && s < EPS){\n            time += next / u;\n            m += next;\n            i++;\n            h++;\n        }else if(s > EPS){\n            if(next / v <= s){\n                s -= next / v;\n                time += next / v;\n                m += next;\n                i++;\n                h++;\n            }else{\n                m += s * v;\n                time += s;\n                s = 0;\n            }\n        }\n    }\n    cout <<fixed << setprecision(8) <<  time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint N,K,T,U,V,L,D[10010];\n\nint main() {\n  cin>>N>>K>>T>>U>>V>>L;\n  REP(i,0,N) cin>>D[i];\n\n  int pos=D[0], vdist=0, di=1, keep=0;\n  int diEnd = D[0]+V*T;\n  queue<int> dq;\n\n  while(1){\n    REP(nowPos,pos,diEnd+1){\n      if(nowPos!=pos)vdist++;\n      //cout<<\"nowPos: \"<<nowPos<<\", keep: \"<<keep<<\", nextDi: \"<<di<<endl;\n      if(nowPos == L)break;\n      if(di < N && nowPos == D[di]){\n        if(keep < K) keep++, dq.push(di);\n        else{\n          diEnd = max(nowPos,D[dq.front()]) + V*T;\n          dq.pop();\n          //cout<<\"--UseDi -> diEnd: \"<<diEnd<<endl;\n        }\n        di++; //uodate next_Di_candidate\n      }\n      if(nowPos==diEnd && keep>0){\n        diEnd = max(nowPos,D[dq.front()]) + V*T;\n        dq.pop();\n        keep--;\n        //cout<<\"--UseDi(finish) -> diEnd: \"<<diEnd<<endl;\n      }\n    }\n    pos = diEnd+1;\n    if(pos >= L) break;\n\n    bool flag = true;\n    /*always leep is 0 here*/\n    REP(nowPos,pos,L+1){\n      if(di < N && D[di] == nowPos){\n        pos = D[di];\n        diEnd = D[di] + V*T;\n        di++;\n        //use immediately\n        flag = false;\n        break;\n      }\n    }\n    if(flag) break;\n  }\n\n  double ans = (double)(L-vdist)/(double)U + (double)vdist/(double)V;\n  printf(\"%.8lf\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n , k , t , u , v , l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tint* d = new int [n+1];\n\tfor(int i=0;i<n;++i){\n\t\tcin >> d[i];\n\t}\n\td[n]=l;\n\tint pos=0,m=0,stock=0;\n\tdouble ans=0;\n\twhile(pos<l){\n\t\tif(pos<d[m]){ //?¬?????????????????????§????????????????????¨???\n\t\t\tif(stock>0){  //??????????????????????????????????????°?§?????????¢???t*v;\n\t\t\t\t--stock;\n\t\t\t\tint tmp = min( l , pos+t*v); \n\t\t\t\tans+=(tmp-pos+0.) /v; //???????????????  =  ????????????+t \n\t\t\t\tpos=tmp;\n\t\t\t} else { //?????????????????????????????????????????°?¬?????????????????????§ u m/s  ??§?????????;\n\t\t\t\tans+=(d[m]-pos+0.)/u;  \n\t\t\t\tpos = d[m];\n\t\t\t}\n\t\t} else {  //?¬?????????????????????§?????????????????????????¶???????????????¨??????m++\n\t\t\tif(stock==0){  \n\t\t\t\tif(d[m]==pos){  \n\t\t\t\t\tint tmp = min( l , pos+t*v);\n\t\t\t\t\tans+=(tmp-pos+0.)/v;\n\t\t\t\t\tpos=tmp;\n\t\t\t\t\t++m;  \n\t\t\t\t} else {\n\t\t\t\t\t++stock;\n\t\t\t\t\t++m;\n\t\t\t\t}\n\t\t\t} else if(stock==k){  \n\t\t\t\tint tmp = min( l , d[m]+t*v);\n\t\t\t\tans+=(tmp-pos+0.)/v;\n\t\t\t\tpos = tmp;\n\t\t\t\t++m;\n\t\t\t} else { \n\t\t\t\t++stock;\n\t\t\t\t++m;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(9) << ans <<endl;\n\tdelete [] d;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Stat{\n\tint x;\n\tint id; // 0: pick a carrot, 1: speed down, 2: other\n\tbool operator<(const Stat &S)const{ return x>S.x; }\n};\n\nint main(){\n\tint n,k,t,u,v,l; scanf(\"%d%d%d%d%d%d\",&n,&k,&t,&u,&v,&l);\n\n\tpriority_queue<Stat> pq;\n\trep(i,n){\n\t\tint d; scanf(\"%d\",&d);\n\t\tpq.push((Stat){d,0});\n\t}\n\tpq.push((Stat){l,0});\n\n\tdouble time=0;\n\tint x=0,x_slow=-1,n_carrot=0; // »ÝÌÊu, x­ÈéÊu, ÁÄ¢éjWÌ{\n\twhile(!pq.empty()){\n\t\tStat S=pq.top(); pq.pop();\n\n\t\ttime+=(double)(S.x-x)/(S.x<=x_slow?v:u);\n\t\tx=S.x;\n\t\tif(x==l) break;\n\n\t\tif(S.id==0){\n\t\t\tif(x<=x_slow && n_carrot<k) n_carrot++;\n\t\t\telse{ // immediately eat\n\t\t\t\tx_slow=x+v*t;\n\t\t\t\tpq.push((Stat){x_slow,1});\n\t\t\t}\n\t\t}\n\t\telse{ // S.id==1\n\t\t\tif(x!=x_slow) continue;\n\t\t\tif(n_carrot>0){\n\t\t\t\tx_slow=x+v*t;\n\t\t\t\tpq.push((Stat){x_slow,1});\n\t\t\t\tn_carrot--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\",time);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <ostream>\n#include <bitset>\n#include <list>\n#include <deque>\n#include <complex>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n#include <cfloat>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <climits>\n\nusing namespace std;\n\n#define MAX_N 201\n#define MAX_L 10001\n#define INF 1e9\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n#define FOR(i,a,b) for(int i = a ; i < b ; i++)\n#define all(p) (p).begin(),(p).end() \n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nint N,K,T,U,V,L;\nbool road[MAX_L];\n\ndouble getTime(double v){\n  return (double)L / v;\n}\n\ndouble solve(){\n  int speed = 0, carr = 0;\n  double res = 0;\n\n  rep(i,L){\n    if(road[i]){\n      carr++;\n    }\n    if(speed == 0 && carr > 0){\n      carr--;\n      speed = V*T;\n    }\n    if(carr > K){\n      carr--;\n      speed = V*T;\n    }\n    if(speed > 0){\n      speed--;\n      res += 1./ V;\n    }else{\n      res += 1./ U;\n    }\n  }  \n  return res;\n}\n\nint main(){\n  int D;\n  memset(road,false,sizeof(road));\n  cin >> N >> K >> T >> U >> V >> L;\n  rep(i,N){\n    cin >> D;\n    road[D] = true;\n  }\n  printf(\"%.8f\\n\",solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, k, t, u, v, l;\nint d[210];\ndouble dp[210][210];\n\nint main(){\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) cin >> d[i];\n\td[n++] = l;\n\trep(i, n) rep(j, n) dp[i][j] = INF;\n\tdp[0][1] = d[0] * 1.0 / u;\n\t\n\tdouble res = INF;\n\trep(i, n) rep(j, k + 1) if(dp[i][j] < INF){\n\t\tint ni = i + 1, nj = j;\n\t\tdouble dist = d[i], next = dp[i][j];\n\t\t\n\t\tif(dist < d[ni] + EPS) dp[ni][nj] = min(dp[ni][nj], next + (d[ni] - dist) / u);\n\t\t\n\t\twhile(ni < n){\n\t\t\twhile(nj > 0 && dist - EPS < d[ni]){\n\t\t\t\tnj--;\n\t\t\t\tdist += t * v;\n\t\t\t\tnext += t;\n\t\t\t}\n\t\t\tif(dist + EPS > d[n - 1]){\n\t\t\t\tres = min(res, next - (dist - d[n - 1]) / v);\n\t\t\t}\n\t\t\tif(dist < d[ni] - EPS){\n\t\t\t\tdp[ni][nj] = min(dp[ni][nj], next + (d[ni] - dist) / u);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(nj == k){\n\t\t\t\tnext = next - (dist - d[ni]) / v + t;\n\t\t\t\tdist = d[ni] + t * v;\n\t\t\t}\n\t\t\tni++;\n\t\t\tnj = min(nj + 1, k);\n\t\t}\n\t}\n\trep(i, k + 1) res = min(res, dp[n - 1][i]);\n\tprintf(\"%.9f\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i;\n    long long j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            if(j + t*v > l - i + 1){\n                dd += l - i;\n                break;\n            }\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n        //cout << i << \" \" << dd << \" \" << j << endl;\n    }\n    //cout << dd <<endl;\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double time = 0.0;\n\n    int speed = U;\n    double accelTime = 0.0;\n    int d_sub = 0;\n    int nowStock = 0;\n\n    int acceledDistance = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    //*\n    for(int i = 0; i < L; i++)\n    {\n        bool isEat = false;\n        bool walk = false;\n\n        if(accelTime > 0.00001)\n        {\n            accelTime -= 1.0 / (double)speed;\n            if(accelTime < 0.000001)\n            {\n                walk = true;\n            }\n        \n        }\n        else\n        {\n            accelTime = 0.0;\n            speed = U;            \n        }\n\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n\n            if(speed == U)isEat = true;\n            else\n            {\n                if(nowStock < K)nowStock++;\n                else isEat = true;\n            }\n        }\n\n        if(speed == U)\n        {\n            if(nowStock > 0)\n            {\n                --nowStock;\n                isEat = true;\n            }\n        }\n\n        if(isEat)\n        {\n            accelTime = T;\n            speed = V;\n        }\n\n        if(walk & !isEat)--acceledDistance;\n        if(speed == V)++acceledDistance;\n\n        time += 1.0 / speed;\n        //if(speed == V)cout << i << \" \" << nowStock << \" \" << accelTime << endl;\n    }\n    //*/\n\n    //cout << time << endl;\n    //cout << acceledDistance << endl;\n\n    double ans = (acceledDistance / (double)V + (L - acceledDistance) / (double)U);\n    //cout << ans * 1000000 / 1000000.0 << endl;\n    printf(\"%.6lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n  int N,K,T,L;\n  double U,V;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N+1,0);\n  D[N+1]=0;\n  for(int i=0;i<N;++i){\n    cin >> D[i];\n  }\n  double Time=0;\n  int pos=0;\n  int Npos=0;\n  int until=0;\n  while(pos < L){\n    if(pos==D[Npos]){\n      ++Npos;\n      until+=T*V;\n      if(until>(K+1)*T*V){\n\tuntil=(K+1)*T*V;\n      }\n    }\n    //cout << \"proceed\" << endl;\n\n    if(until==0){\n      Time+=1/U;\n    }else{\n      Time+=1/V;\n      --until;   \n    }\n    pos+=1;\n  }\n  cout << setiosflags(ios::fixed) << setprecision(15) << Time << endl;"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    int d[N + 1];\n    rep(i, N)\n    {\n        cin >> d[i];\n    }\n    d[N] = L;\n    int hav = 0;\n    int nextDist = 0;\n    double m = 0;\n    rep(c, N + 1)\n    {\n        // cerr << nextDist << “,” << c << “,” << m << endl;\n        if (nextDist <= d[c])\n        {\n            if (hav >= 1)\n            {\n                nextDist = nextDist + V * T;\n                c--;\n                hav--;\n            }\n            else\n            {\n                if (c != N)\n                    nextDist = d[c] + V * T;\n            }\n        }\n        else\n        {\n            if (hav + 1 <= K)\n            {\n                if (c != N)\n                    hav++;\n                else\n                    m += nextDist - d[c];\n            }\n            else\n            {\n                m += nextDist - d[c];\n                if (c != N)\n                    nextDist = d[c] + V * T;\n            }\n        }\n        // cout << m << endl;\n        // cout << (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U << endl;\n    }\n\n    m += hav * V * T;\n    // cout << 1 << “+” << (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U << endl;\n    // cout << 1 << “+” << (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U << endl;\n    double ans = (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U;\n    printf(\"% 0.10lf\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\n\nnamespace solution {\n   using namespace std;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n   typedef pair <II, int> State;\n   typedef pair <double, State> Node;\n   typedef queue <Node> Queue;\n   Queue Q;\n\n   void dijkstra_init() {\n      Q = Queue();\n   }\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   double dijkstra( int start, int goal ) {\n      dijkstra_init();\n\n      Node start_node( 0.0, State( II( start, 0 ), 0 ) );\n      Q.push( start_node );\n\n      double base = 1.0 / U;\n      double fast = 1.0 / V;\n\n      while ( ! Q.empty() ) {\n         Node node = Q.front();\n         Q.pop();\n\n         double cost = node.first;\n         int id = node.second.first.first;\n         int remains = node.second.first.second;\n         int carrots = node.second.second;\n\n         if ( id == goal ) {\n            return cost;\n         }\n\n\n         if ( D[id] ) {\n            if ( carrots == K ) {\n               remains = T * V;\n            } else {\n               carrots ++;\n               if ( remains == 0 ) {\n                  remains = T * V;\n                  carrots --;\n               }\n            }\n         }\n\n         double t = base;\n         if ( remains ) {\n            t = min( t, fast );\n            remains --;\n         }\n         if ( remains == 0 && carrots ) {\n            remains = T * V;\n            carrots --;\n         }\n         Q.push( Node( cost + t, State( II( id + 1, remains ), carrots ) ) );\n      }\n      return NONE;\n   }\n\n   class Solution {\n   private:\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         return dijkstra( 0, L );\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint N, K, T, U, V, L, D;\nint p[10000];\n\nint main(void) {\n  cin >> N >> K >> T >> U >> V >> L;\n  REP(i, 0, L + 1) p[i] = 0;\n  REP(i, 0, N) {\n    cin >> D;\n    p[D] = 1;\n  }\n\n  int d = 0;\n  int cnt = 0;\n  int s = 0;\n\n  REP(i, 0, L) {\n    if(p[i] == 1) {\n      if(cnt != 0 && s < K) s++;\n      else cnt = T * V;\n    } else if(cnt == 0 && s > 0) s--, cnt = T * V;\n    if(cnt > 0) d++, cnt--;\n  }\n\n  printf(\"%.8lf\\n\", (double) d / V + (double) (L - d) / U);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint n, k, t, u, v, l;\n\tscanf(\"%d %d %d %d %d %d\", &n, &k, &t, &u, &v, &l);\n\n\tvector<bool> carrot(l, false);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint d;\n\t\tscanf(\"%d\", &d);\n\t\tcarrot[d] = true;\n\t}\n\n\tint cnt = 0, num = 0, rest = 0;\n\tfor(int i = 0; i < l; ++i) {\n\t\tif(carrot[i])\n\t\t\t++num;\n\n\t\tif((num && !rest) || num > k) {\n\t\t\trest = t * v;\n\t\t\t--num;\n\t\t}\n\n\t\tif(rest) {\n\t\t\t--rest;\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tprintf(\"%.15lf\\n\", (double)cnt / v + (double)(l - cnt) / u);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint main() {\n\tint n, k, t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tvector<int> d(n);\n\trep(i,n) {\n\t\tcin >> d[i];\n\t}\n\tint id = 0;\n\n\tdouble res = 0;\n\tdouble T = 0.0;\n\tint hold = 0;\n\tfor(int i=1; i<=l; i++) {\n\t\tif( T < 1.0/v && hold>0 ) {\n\t\t\thold--;\n\t\t\tT += t;\n\t\t}\n\n\t\tif( T >= 1.0/v ) {\n\t\t\tres += 1.0/v;\n\t\t\tT -= 1.0/v;\n\t\t} else if(T > 0.0) {\n\t\t\tdouble dist = 1.0 * T * v;\n\t\t\tres += dist / v;\n\t\t\tres += (1.0-dist) / u;\n\t\t\tT = 0.0;\n\t\t} else {\n\t\t\tres += 1.0 / u;\n\t\t}\n\n\t\tif(d[id] == i) {\n\t\t\tid++;\n\t\t\tif( hold == k || T == 0.0 ) {\n\t\t\t\tT = t;\n\t\t\t} else {\n\t\t\t\thold++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(10) << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#if 0\nusing namespace std;\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define int ll\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n#endif\nsigned main() {\n    int N, K, T, U, V, L;\n    scanf(\"%d %d %d %d %d %d\", &N, &K, &T, &U, &V, &L);\n\n    std::vector<int>  C(L+1);\n    for (int i=0; i<N; ++i) {\n        int D;\n        scanf(\"%d\", &D);\n        ++C[D];\n    }\n\n    int num_carrot=0;\n    int remain=0;\n    std::vector<int> F(L+1);\n    for (int i=0; i<=L; ++i) {\n        if (remain-- > 0)\n            F[i] = 1;\n\n        if (C[i])\n            ++num_carrot;\n\n        if (num_carrot) {\n            if (remain <= 0 || num_carrot > K) {\n                --num_carrot;\n                remain = V*T;\n            }\n        }\n    }\n\n    int dist[2]={};\n    for (int i=0; i<L; ++i)\n        ++dist[F[i]];\n\n    printf(\"%.16f\\n\", (dist[0]*1.0/U)+(dist[1]*1.0/V));\n    return 0;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\nsigned main(){\n    i64 N,K,T,U,V,L;\n    cin >> N >> K >> T >> U >>V >> L;\n    priority_queue<pair<i64, int>, vector<pair<i64,int>>, greater<pair<i64, int>>> que;\n    que.push({L, 0}); //goal\n    for(int i = 0;i < N;i++){\n        i64 a;cin >> a;\n        que.push({a, 1});\n    }\n    int now_nizinn = 0;\n    bool is_burst = false;\n    i64 prev = 0;\n    i64 kireru = 1e9;\n    long double ans = 0.0;\n    while(!que.empty()){\n        pair<i64, int> q = que.top();\n        que.pop();\n        if(q.second == 0){\n            //G\n            ans += 1.0*(q.first - prev) / (is_burst ? V : U);\n            break;\n        }else if(q.second == 1){\n            //ninnzinn\n            ans += 1.0*(q.first - prev) / (is_burst ? V : U);\n            if(now_nizinn == K){\n                kireru = q.first + V * T;\n                is_burst = true;\n            }else{\n                now_nizinn++;\n            }\n            if(now_nizinn && !is_burst){\n                now_nizinn--;\n                is_burst = true;\n                kireru = q.first + V * T;\n            }\n            prev = q.first;\n        }else{\n            //kireru\n            ans += 1.0*(q.first - prev) / (is_burst ? V : U);\n            if(now_nizinn){\n                now_nizinn--;\n                kireru = q.first + V * T;\n            }else{\n                kireru = 1e9;\n                is_burst = false;\n            }\n            prev = q.first;\n        }\n        if(is_burst){\n            if(que.top().first > kireru){\n                que.push({kireru, 2});\n            }\n        }\n    }\n    cout<<setprecision(20)<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n,k,now;\n  double u,v,t,l,d[200],ans;\n  while(cin >> n >> k >> t >> u >> v >> l){\n    for(int i=0;i<n;i++) cin >> d[i];\n    ans = d[0] / u;\n    for(int i=0;i<n;i++){\n      int j = i + 1;\n      double cnt;\n      now = 0;\n      for(cnt=1;now>=0;cnt++){\n\tdouble cntn = cnt - 1;\n\tfor(;j<n;j++){\n\t  if(d[i] + t * v * cnt <= d[j]) break;\n\t  if(now < k) now++;\n\t  else cnt += (d[j] - (d[i] + t * v * cntn)) / (t * v);\n\t}\n\tnow--;\n      }\n      cnt--;\n\n      if(j >= n){\n\tif(d[i] + t * v * cnt >= l) ans += (l - d[i]) / v;\n\telse ans += t * cnt + (l - (d[i] + t * v * cnt)) / u;\n      } else ans += t * cnt + (d[j] - (d[i] + t * v * cnt)) / u;\n      i = j;\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nint32_t main() {\n    int n,k,t,u,v,L; cin >> n >> k >> t >> u >> v >> L;\n    vector<int> x(n); cin >> x;\n\n    double time = 0;\n    int cnt = 0, d = 0, now = u;\n    vector<int> a(L);\n    rep (i,n) a[x[i]] = 1;\n\n    rep (i,L) {\n        if (cnt == 0 && d == 0) now = u;\n        if (a[i]) cnt++;\n        if (cnt > k || (cnt > 0 && d == 0)) {\n            now = v;\n            cnt--;\n            d = v*t;\n        }\n\n        time += double(1)/now;\n\n        if (now == v) d--;\n    }\n\n    cout << time << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n,k,now;\n  double u,v,t,l,d[200],ans;\n  while(cin >> n >> k >> t >> u >> v >> l){\n    for(int i=0;i<n;i++) cin >> d[i];\n    ans = d[0] / u;\n    for(int i=0;i<n;i++){\n      int j = i + 1;\n      double cnt;\n      now = 0;\n      for(cnt=1;now>=0;cnt++){\n\tdouble cntn = cnt - 1;\n\tfor(;j<n;j++){\n\t  if(d[i] + t * v * cnt <= d[j]) break;\n\t  else if(now < k) now++;\n\t  else cnt += (d[j] - (d[i] + t * v * cntn)) / (t * v);\n\t}\n\tnow--;\n      }\n      cnt--;\n\n      if(j >= n){\n\tif(d[i] + t * v * cnt >= l) ans += (l - d[i]) / v;\n\telse ans += t * cnt + (l - (d[i] + t * v * cnt)) / u;\n      } else ans += t * cnt + (d[j] - (d[i] + t * v * cnt)) / u;\n      i = j - 1;\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum{CARROT,BATERU,GOAL};\nstruct Event{\n    int type;\n    double pos;\n};\n\nbool operator<(const Event &lhs,const Event &rhs){\n    return lhs.pos==rhs.pos ? lhs.type>rhs.type : lhs.pos>rhs.pos;\n}\n\n\nint main(){\n    int n,k,t,u,v,l;\n    cin>>n>>k>>t>>u>>v>>l;\n        vector<int> d(n);\n        for(int i=0;i<n;i++) cin>>d[i];\n        priority_queue<Event> que;\n        for(int i=0;i<n;i++){\n            que.push(Event{CARROT,d[i]});\n        }\n        que.push(Event{GOAL,l});\n        double ver=u;\n        double pos=0;\n        int cnt=0;\n        int charge=0;\n        double res=0;\n        while(true){\n            Event eve=que.top(); que.pop();\n            res+=(eve.pos-pos)/ver;\n            pos=eve.pos;\n            \n            if(eve.type==CARROT){\n                \n                if(cnt==k){\n                    charge++;\n                    que.push({Event{BATERU,pos+v*t}});\n                }\n                else{\n                    \n                    cnt=cnt+1;\n                    if(ver==u){\n                        assert(charge==0);\n                        cnt--;\n                        charge++;\n                        ver=v;\n                        que.push({Event{BATERU,pos+v*t}});\n                    }\n                }\n            }\n            else if(eve.type==GOAL){\n                break;\n            }\n            else if(eve.type==BATERU){\n                \n                charge--;\n                if(charge==0){     \n                    if(cnt>0){\n                        cnt--;\n                        charge++;\n                        que.push(Event{BATERU,pos+t*v});\n                    }\n                    else{\n                        ver=u;\n                    }\n                }\n                \n            }\n        }\n        cout<<setprecision(10)<<fixed;\n        cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint main() {\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\t\n\tvector< int > D(N+1, L);\n\tfor_(i,0,N) cin >> D[i];\n\t\n\tint p = 0, cnt = 0, dst = 0;\n\tdouble ans = 0;\n\tbool boost = false;\n\t\n\twhile (dst < L) {\n\t\tif (boost) {\n\t\t\tint nxt = dst + T * V;\n\t\t\t\n\t\t\tbool reboost = false;\n\t\t\twhile (D[p] <= nxt) {\n\t\t\t\t++p;\n\t\t\t\t++cnt;\n\t\t\t\tif (cnt > K) {\n\t\t\t\t\treboost = true;\n\t\t\t\t\tcnt = K;\n\t\t\t\t\tans += (double)(D[p-1] - dst) / V;\n\t\t\t\t\tdst = D[p-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!reboost) {\n\t\t\t\tif (nxt <= L) dst = nxt, ans += T;\n\t\t\t\telse dst = L, ans += (double)(L - dst) / V;\n\t\t\t\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tboost = true;\n\t\t\t\t\t--cnt;\n\t\t\t\t} else {\n\t\t\t\t\tboost = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tans += (double)(D[p] - dst) / U;\n\t\t\tdst = D[p];\n\t\t\t++p;\n\t\t\tboost = true;\n\t\t}\n\t}\n\t\n\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   private:\n      queue <TNode> Q;\n      virtual void init() = 0;\n      virtual TNode get_start() = 0;\n      virtual bool is_goal( TNode ) = 0;\n      virtual void find_next( TNode ) = 0;\n   public:\n      IBFS() {\n         Q = queue <TNode>();\n      }\n      TNode run() {\n         init();\n         Q.push( get_start() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal( node ) ) {\n               return node;\n            }\n            find_next( node );\n         }\n         return TNode();\n      }\n      void push_next( TNode node ) {\n         Q.push(node);\n      }\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Solution {\n   private:\n\n      class Node {\n      public:\n         double cost;\n         int id;\n         int remains;\n         int carrots;\n         Node(): cost(NONE){}\n         Node( double cost, int id, int remains, int carrots ):\n            cost(cost), id(id), remains(remains), carrots(carrots) {}\n         friend ostream& operator << ( ostream& os, Node node ) {\n            return os << node.cost << \", \" << node.id << \", \"\n                      << node.remains << \", \" << node.carrots << \" / \";\n         }\n      };\n\n      class BFS: public IBFS<Node> {\n      private:\n         double base;\n         double fast;\n\n         void init() {\n            base = 1.0 / U;\n            fast = 1.0 / V;\n         }\n\n         Node get_start() {\n            return Node( 0.0, 0, 0, 0 );\n         }\n\n         bool is_goal( Node node ) {\n            return node.id == L;\n         }\n\n      public:\n         void find_next( Node node ) {\n            Node next_node = node;\n\n            if ( D[next_node.id] ) {\n               if ( next_node.carrots == K ) {\n                  next_node.remains = T * V;\n               } else {\n                  next_node.carrots ++;\n                  if ( next_node.remains == 0 ) {\n                     next_node.remains = T * V;\n                     next_node.carrots --;\n                  }\n               }\n            }\n\n            double t = base;\n            if ( next_node.remains ) {\n               t = min( t, fast );\n               next_node.remains --;\n            }\n            if ( next_node.remains == 0 && next_node.carrots ) {\n               next_node.remains = T * V;\n               next_node.carrots --;\n            }\n            next_node.cost += t;\n            next_node.id += 1;\n\n            push_next( next_node );\n         }\n      };\n\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         static BFS bfs;\n         bfs = BFS();\n         return bfs.run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define EPS 1e-10\nint n,k;\ndouble t,u,v,l;\ndouble d[201];\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nint main(void){\n\tscanf(\"%d %d %lf %lf %lf %lf\",&n,&k,&t,&u,&v,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf\",&d[i]);\n\t}\n\td[n+1]=l;\n\tint now=0;\n\tdouble tim=0.0,rest=0.0;\n\tfor(int i=1;i<=n+1;i++){\n\t\tif(rest==0.0 && now==0){\n\t\t\ttim+=(d[i]-d[i-1])/u;\n\t\t\tif(now<k)now++;\n\t\t\telse if(now==k)rest=l;\n\t\t}else{\n\t\t\tdouble dist=d[i-1];\n\t\t\twhile(add(dist,-d[i])!=0.0){\n\t\t\t\tif(rest>0.0){\n\t\t\t\t\tdouble cost=(d[i]-dist)/v;\n\t\t\t\t\tif(cost>rest){\n\t\t\t\t\t\tdist+=v*rest;\n\t\t\t\t\t\ttim+=rest;\n\t\t\t\t\t\trest=0.0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdist=d[i];\n\t\t\t\t\t\ttim+=cost;\n\t\t\t\t\t\trest-=cost;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(now>0){\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t\trest=t;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttim+=(d[i]-dist)/u;\n\t\t\t\t\t\tdist=d[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now<k)now++;\n\t\t\telse if(now==k)rest=t;\n\t\t}\n\t\t//printf(\"%f %f %d %lf\\n\",tim,d[i],now,rest);\n\t}\n\tprintf(\"%.10f\\n\",tim);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n , k , t , u , v , l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tint* d = new int [n+1];\n\tfor(int i=0;i<n;++i){\n\t\tcin >> d[i];\n\t}\n\td[n]=l;\n\tint pos=0,m=0,stock=0;\n\tdouble ans=0;\n\twhile(pos<l){\n\t\tif(pos<d[m]){ //?¬?????????????????????§????????????????????¨???\n\t\t\tif(stock>0){  //??????????????????????????????????????°?§?????????¢???t*v;\n\t\t\t\t--stock;\n\t\t\t\tint tmp = min( l , pos+t*v); \n\t\t\t\tans+=(tmp-pos+0.) /v; //???????????????  =  ????????????+t \n\t\t\t\tpos=tmp;\n\t\t\t} else { //?????????????????????????????????????????°?¬?????????????????????§ u m/s  ??§?????????;\n\t\t\t\tans+=(d[m]-pos+0.)/u;  \n\t\t\t\tpos = d[m];\n\t\t\t}\n\t\t} else {  //?¬?????????????????????§?????????????????????????¶???????????????¨??????m++\n\t\t\tif(stock==0){  \n\t\t\t\tif(d[m]==pos){  \n\t\t\t\t\tint tmp = min( l , pos+t*v);\n\t\t\t\t\tans+=(tmp-pos+0.)/v;\n\t\t\t\t\tpos=tmp;\n\t\t\t\t\t++m;  \n\t\t\t\t} else {\n\t\t\t\t\t++stock;\n\t\t\t\t\t++m;\n\t\t\t\t}\n\t\t\t} else if(stock==k){  \n\t\t\t\tint tmp = min( l , d[m]+t*v);\n\t\t\t\tans+=(tmp-pos+0.)/v;\n\t\t\t\tpos = tmp;\n\t\t\t\t++m;\n\t\t\t} else { \n\t\t\t\t++stock;\n\t\t\t\t++m;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(9) << ans <<endl;\n\tdelete [] d;\n\tansurn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N,K,U,L,V,T;\ndouble cnt;\nbool mp[10010];\n\nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  for(int i=0,a,A;i<N;i++){\n    cin>>a;A=a;\n    while(mp[a]&&(1.0*a-A)/V/T<K)a++;\n    for(int j=a;j<L&&j<a+T*V;j++)cnt+=!mp[j],mp[j]=1;\n  }\n\n  printf(\"%.8f\\n\",cnt/V+(L-cnt)/U);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint main() {\n    int n, k, t, u, v, l; cin >> n >> k >> t >> u >> v >> l;\n    int d[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> d[i];\n    }\n    int h[11000] = {0};\n    for (int i = 0; i < n; ++i) {\n        h[d[i]] = 1;\n    }\n    int last = 0; //加速状態のlast\n    double ret = 0; //答え 何秒\n    int now = 0; //今加速状態か and 人参何本持ってる\n    for (int i = 1; i <= l; ++i) {\n        if (now) ret += 1.0 / v;\n        else ret += 1.0 / u;\n        if (now && last + t * v == i) { //今加速状態で効果切れる\n            now--;\n            last = i;\n        }\n        if (h[i]) {\n            now++;\n            if (now == 1) last = i; //人参なしの加速状態なら\n            if (now > k + 1) { //now = 1 は人参なし\n                now--;\n                last = i;\n            }\n        }\n    }\n    cout << setprecision(10) << ret << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l,d[210]={0};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  int a=0,p=0;\n  for(int i=1;i<=n+1;i++){\n    if(a>d[i]-d[i-1]){\n      a-=d[i]-d[i-1];\n      if(a/(v*t)<k)a+=v*t;\n      else a=v*t*(k+1);\n    }\n    else p+=d[i]-d[i-1]-a,a=v*t;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > pq;\n\tpq.push(i_i(L, 0));\n\twhile (N--) {\n\t\tint D; cin >> D;\n\t\tpq.push(i_i(D, 1));\n\t}\n\tbool accel = false;\n\tint d = 0, _d = 0;\n\tdouble t = 0;\n\tfor (;;) {\n\t\ti_i p = pq.top(); pq.pop();\n\t\tint x = p.first, y = p.second;\n\t\tt += (double)(x - d) / (accel ? V : U);\n\t\td = x;\n\t\tif (y == 0) break;\n\t\tif (y == 1) {\n\t\t\taccel = true;\n\t\t\t_d = max(d, _d);\n\t\t\t_d = min(d + K * (T + 1) * V, _d + T * V);\n\t\t\tpq.push(i_i(_d, -1));\n\t\t}\n\t\tif (y == -1 && x == _d) accel = false;\n\t}\n\tprintf(\"%.10f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main()\n{\n    int N, K, T, U, V, L;\n    std::cin >> N >> K >> T >> U >> V >> L;\n    std::vector<long double> D(N);\n    for (auto& e: D) std::cin >> e;\n    D.push_back(L);\n    for (int i{N}; i > 0; i--)\n        D[i] -= D[i - 1];\n    \n    long double rest{}, time{};\n    for (int i{}; i <= N; i++)\n    {\n        if (rest * V <= D[i])\n        {\n            time += rest + (D[i] - rest * V) / U;\n            rest = 0;\n        }\n        else\n        {\n            time += D[i] / V;\n            rest -= D[i] / V;\n        }\n        rest = std::min(rest + T, (long double)T * (K + 1));\n    }\n    printf(\"%.10Lf\\n\", time);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <iomanip>\n\nconstexpr double E = 1e-8;\nconstexpr int INF = 99999999;\n\nint main() {\n    int n, k, t, u, v, l;\n    std::vector<int> d;\n    std::cin >> n >> k >> t >> u >> v >> l;\n    for (int i = 0; i < n; i++) {\n        int a; std::cin >> a;\n        d.push_back(a);\n    }\n\n    double numTime = 0.0;\n    int numOfCarrot = 0;\n    double remaindSpeedUpTime = 0.0;\n    int carrotIndex = -1;\n    double pos = 0.0;\n    while (1) {\n        double nowSpeed = u;\n        if (remaindSpeedUpTime > 0.0) nowSpeed = v;\n\n        // 次の区切りを探す\n        double nextCarrotTime = INF;\n        double goalTime = (l - pos) / nowSpeed; // ゴールまでの時間\n\n        // 次の人参までの時間\n        if (carrotIndex < (int)(d.size()) - 1) {\n            int remaindNextCarrotLen = (d[carrotIndex + 1] - pos);\n            nextCarrotTime = remaindNextCarrotLen / nowSpeed;\n        }\n\n        // 区切りに合わせて\n        // 次の人参取得イベが最も早い\n        if (nextCarrotTime < goalTime && ((nextCarrotTime < remaindSpeedUpTime && remaindSpeedUpTime > 0.0) || remaindSpeedUpTime <= 0.0)) {\n            pos = d[++carrotIndex];\n            numTime += nextCarrotTime;\n            remaindSpeedUpTime -= nextCarrotTime;\n            // 人参取得\n            numOfCarrot++;\n            // もう持てないか人参切れなら食べる\n            if (numOfCarrot > k || remaindSpeedUpTime <= 0.0) {\n                numOfCarrot--;\n                remaindSpeedUpTime = t;\n            }\n        }\n        else if (remaindSpeedUpTime > 0.0 && remaindSpeedUpTime < goalTime) { // 人参切れを起こす\n            pos += remaindSpeedUpTime * nowSpeed;\n            numTime += remaindSpeedUpTime;\n            remaindSpeedUpTime = 0;\n            // 人参あるなら食べる\n            if (numOfCarrot > 0) {\n                numOfCarrot--;\n                remaindSpeedUpTime = t;\n            }\n        }\n        else { // ゴール\n            pos = l;\n            numTime += goalTime;\n            break;\n        }\n    }\n    std::cout << std::fixed << std::setprecision(9) << numTime << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// l:距離, v:速さ, かかる時間を返す.\ndouble f(double l, double v){\n\treturn l / v;\n}\n\ntypedef pair<double,int> P;\nconst int CARROT = 1;\nconst int SLOW = 2;\nconst int GOAL = 3;\n\nint main(){\n\tint N, K, T, U, V, L;\n\t//cin >> N >> K >> T >> U >> V >> L;\n\tscanf(\"%d %d %d %d %d %d\", &N, &K, &T, &U, &V, &L);\n\t\n\tvector<int> D(N);\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push( P(L,GOAL) );\n\tfor(int i=0 ; i < N ; i++ ){\n\t\t//cin >> D[i];\n\t\tscanf(\"%d\", &D[i]);\n\t\tq.push( P(D[i],CARROT) );\n\t}\n\t\n\tdouble x=0.0, v = U, t=0.0, k=0, carrot=0;\n\twhile( !q.empty() ){\n\t\tif( q.top().second == CARROT ){ // 次の位置がニンジンのとき\n\t\t\t/*cout << \"x:\" << x << \" -> \" << q.top().first ;\n\t\t\tcout << \" t:\" << t << \" -> \" << t+f(q.top().first - x,v);\n\t\t\tcout << \" speed:\" << (v==U? \"normal\" : \"quick\") << endl;\n\t\t\t */\n\t\t\tdouble l = q.top().first - x; // 移動する距離\n\t\t\tx = q.top().first; // 次の位置\n\t\t\tt += f(l,v); // 時間経過\n\t\t\tq.pop();\n\t\t\t\n\t\t\t\n\t\t\tif( v == U ){ // 通常の速さのとき(ニンジンを食べる)\n\t\t\t\tv = V; // 速度変化\n\t\t\t\t//cout << \"speed up!\" << endl;\n\t\t\t\tq.push( P(x + V*T, SLOW) ); // ニンジンの効果が切れる位置\n\t\t\t}else{ // 速いとき\n\t\t\t\tif( k < K ){ // ニンジンを持てるとき(持つ)\n\t\t\t\t\t//cout << \"carrot get!\" << endl;\n\t\t\t\t\tk++;\n\t\t\t\t}else{ // ニンジンを持てないとき(食べる)\n\t\t\t\t\t//cout << \"eat carrot!\" << endl;\n\t\t\t\t\tcarrot++;\n\t\t\t\t\tq.push( P(x + V*T, SLOW) ); // ニンジンの効果が切れる位置\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( q.top().second == SLOW ){ // ニンジンの効果が切れるとき\n\t\t\t/*cout << \"x:\" << x << \" -> \" << q.top().first ;\n\t\t\tcout << \" t:\" << t << \" -> \" << t+f(q.top().first - x,v);\n\t\t\tcout << \" speed:\" << (v==U? \"normal\" : \"quick\") << endl;\n\t\t\t*/\n\t\t\tdouble l = q.top().first - x; // 移動する距離\n\t\t\tx = q.top().first; // 次の位置\n\t\t\tt += f(l,v); // 時間経過\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif( carrot > 0 ){ // ニンジンを効果が切れる前に食べたときは遅くならない\n\t\t\t\t//cout << \"not speed down!\" << endl;\n\t\t\t\tcarrot--;\n\t\t\t}else if( k > 0 ){ // ニンジンを持っているときは即座に食べる\n\t\t\t\tk--;\n\t\t\t\t//cout << \"speed up!\" << endl;\n\t\t\t\tq.push( P(x + V*T, SLOW) ); // ニンジンの効果が切れる位置\n\t\t\t}else{ // 通常の速さに戻る\n\t\t\t\t//cout << \"speed down!\" << endl;\n\t\t\t\tv = U;\n\t\t\t}\n\t\t}else if( q.top().second == GOAL ){ // ゴールのとき\n\t\t\t/*cout << \"x:\" << x << \" -> \" << q.top().first ;\n\t\t\tcout << \" t:\" << t << \" -> \" << t+f(q.top().first - x,v);\n\t\t\tcout << \" speed:\" << (v==U? \"normal\" : \"quick\") << endl;\n\t\t\tcout << \"goal!\" << endl;\n\t\t\t*/\n\t\t\tdouble l = q.top().first - x; // 移動する距離\n\t\t\tx = q.top().first; // 次の位置\n\t\t\tt += f(l,v); // 時間経過\n\t\t\tq.pop();\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << t << endl;\n\tprintf(\"%.9f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int n, k, l;\n    double t, u, v, d[200];\n    \n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i, n){\n        cin >> d[i];\n    }\n    \n    double ans = 0.0;\n    int boost_time = 0, ninjin_p = 0, boost_cnt = 0;\n    for(int i = 1; i <= l; i++){\n        if(boost_time){\n            ans += 1.0 / v + 1e-13;\n            boost_time--;\n        }\n        else{\n            ans += 1.0 / u + 1e-13;\n        }\n        \n        if(i == d[ninjin_p]){\n            if(boost_time >= k * v){\n                boost_time = (k + 1) * v;\n            }\n            else{\n                boost_time += v;\n            }\n            if(ninjin_p < n - 1)ninjin_p++;\n        }\n    }\n    \n    printf(\"%.11lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n    vi carrot(L);\n    REP(i, N) {\n        int d; cin >> d; carrot[d] = 1;\n    }\n\n    double ans = 0;\n    int carrots = 0;\n    int rem = 0;\n    REP(i, L) {\n        if (carrot[i]) {\n            if (carrots < K) ++carrots;\n            else {\n                rem = T * V;\n            }\n        }\n        if (rem == 0 and carrots > 0) {\n            --carrots;\n            rem = T * V;\n        }\n\n        if (rem == 0) {\n            ans += 1.0 / U;\n        } else {\n            --rem;\n            ans += 1.0 / V;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nint N, K, T, U, V, L;\nvector<int> D;\n\nldouble calc(int x, int k) {\n    if (x == L) return 0;\n    if (k == 0) {\n        int nx = *lower_bound(D.begin(), D.end(), x);\n        return ldouble(nx - x) / U + calc(nx, 1);\n    }\n\n    int nx = min(L, x + T * V);\n    int got = upper_bound(D.begin(), D.end(), nx) - upper_bound(D.begin(), D.end(), x);\n    return ldouble(nx - x) / V + calc(nx, min(K, k - 1 + got));\n}\n\nint main() {\n    cin >> N >> K >> T >> U >> V >> L;\n\n    D.resize(N);\n    for (auto& d : D) cin >> d;\n    D.push_back(L);\n\n    cout << fixed << setprecision(9) << calc(0, 0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n int main(void){\n\t int n,k,t,u,v,l;\n\t cin>>n>>k>>t>>u>>v>>l;\n\t vector<int> d(n);\n\t vector<bool> x(l,false);\n\t vector<bool> a(l,false);\n\t for(int i=0;i<n;i++){\n\t\t cin>>d[i];\n\t\t x[d[i]]= true;\n\t } \n\t int rest=0;\n\t int a1=t*v;\n\t int amax=a1*(k+1);\n\t// cout<<amax<<endl;\n\t for(int i=0;i<l;i++){\n\t\t if(x[i])rest+=a1;\n\t\t if(rest>amax)rest=amax;\n\t\t if(rest!=0) {\n\t//\t\t cout<<rest<<\" \";\n\t\t\t rest--;\n\t\t\t a[i]=true;\n\t//\t\t cout<<i<<\" \";\n\t\t }\n\t }\n\t\tint nl=0,al=0;\n\t\tfor(int i=0;i<l;i++){\n\t\t\tif(a[i])al++;\n\t\t\telse nl++;\n\t\t}\n\t//\tcout<<al<<\" \"<<nl<<endl;\n\tprintf(\"%f\\n\",(double)al/v+(double)nl/u);\n\n\t return 0;\n }"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <memory>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   private:\n      queue <TNode> Q;\n      virtual void init() = 0;\n      virtual TNode get_start() = 0;\n      virtual bool is_goal( TNode ) = 0;\n      virtual void find_next( TNode ) = 0;\n\n   public:\n      IBFS() {\n         Q = queue <TNode>();\n      }\n\n      TNode run() {\n         init();\n         Q.push( get_start() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal( node ) ) {\n               return node;\n            }\n            find_next( node );\n         }\n         return TNode();\n      }\n\n      void push_next( TNode node ) {\n         Q.push(node);\n      }\n\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Solution {\n   private:\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      class Node {\n      public:\n         double cost;\n         int id;\n         int remains;\n         int carrots;\n         Node(): cost(NONE){}\n         Node( double cost, int id, int remains, int carrots ):\n            cost(cost), id(id), remains(remains), carrots(carrots) {}\n         friend ostream& operator << ( ostream& os, Node node ) {\n            return os << node.cost << \", \" << node.id << \", \"\n                      << node.remains << \", \" << node.carrots << \" / \";\n         }\n      };\n\n      class BFS: public IBFS<Node> {\n      private:\n         double base;\n         double fast;\n\n         void init() {\n            base = 1.0 / U;\n            fast = 1.0 / V;\n         }\n\n         Node get_start() {\n            return Node( 0.0, 0, 0, 0 );\n         }\n\n         bool is_goal( Node node ) {\n            return node.id == L;\n         }\n\n      public:\n         void find_next( Node node ) {\n            Node next_node = node;\n\n            if ( D[next_node.id] ) {\n               if ( next_node.carrots == K ) {\n                  next_node.remains = T * V;\n               } else {\n                  next_node.carrots ++;\n                  if ( next_node.remains == 0 ) {\n                     next_node.remains = T * V;\n                     next_node.carrots --;\n                  }\n               }\n            }\n\n            double t = base;\n            if ( next_node.remains ) {\n               t = min( t, fast );\n               next_node.remains --;\n            }\n            if ( next_node.remains == 0 && next_node.carrots ) {\n               next_node.remains = T * V;\n               next_node.carrots --;\n            }\n            next_node.cost += t;\n            next_node.id += 1;\n\n            push_next( next_node );\n         }\n      };\n\n      double solve() {\n         static BFS bfs;\n         bfs = BFS();\n         return bfs.run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  double lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  double ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=1;i<=L;i++){\n    ans+=1.00/lv[i];\n  }\n  printf(\"%.10lf\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nenum State{Carrot, End};\n\ntypedef struct Event{\n    int x;\n    State state;\n    \n    bool operator<( const Event& right ) const {\n        return x>right.x;\n    }\n}Event;\n\nint N, K, T, U, V, L;\nvector<int> D;\n\nint main(){\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    cin >> N >> K >> T >> U >> V >> L;\n    D.resize(N);\n    for(auto &v: D) cin >> v;\n    \n    priority_queue<Event> que;\n    for(auto v: D)\n        que.push(Event({v, Carrot}));\n    \n    vector<bool> zone(L);\n    int count = 0;\n    while(!que.empty()){\n        auto event = que.top(); que.pop();\n        if(event.state == Carrot){\n            if(zone[event.x]){\n                if(count < K){\n                    count++;\n                }else{\n                    que.push({event.x + T*V, End});\n                    for(int x=min(L, event.x+T*V)-1; event.x<=x && !zone[x]; x--)\n                        zone[x] = true;\n                }\n            }else{\n                que.push({event.x + T*V, End});\n                for(int x=min(L, event.x+T*V)-1; event.x<=x && !zone[x]; x--)\n                    zone[x] = true;\n            }\n        }else{\n            if(count && event.x<L && !zone[event.x]){\n                count--;\n                que.push({event.x + T*V, End});\n                for(int x=min(L, event.x+T*V)-1; event.x<=x && !zone[x]; x--)\n                    zone[x] = true;\n            }\n        }\n    }\n    \n    double span = 0;\n    for(int i=0; i<L; i++)\n        span += zone[i];\n    \n    cout << (L-span)/U + span/V << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tCarrot_Num =Carrot_Time_Rest = 0;\n\t\tTotal_Time = 0.0;\n\t}\n\n\tvoid set(int arg_Carrot_Num,double arg_Carrot_Time_Rest,double arg_Total_Time){\n\t\tCarrot_Num = arg_Carrot_Num;\n\t\tCarrot_Time_Rest = arg_Carrot_Time_Rest;\n\t\tTotal_Time = arg_Total_Time;\n\t}\n\n\tint Carrot_Num;\n\tdouble Total_Time,Carrot_Time_Rest;\n};\n\nint main(){\n\n\tInfo first;\n\tint N,Have_Limit;\n\tdouble Normal_Speed,Carrot_Speed,Carrot_Time_Length,L;\n\tscanf(\"%d %d %lf %lf %lf %lf\",&N,&Have_Limit,&Carrot_Time_Length,&Normal_Speed,&Carrot_Speed,&L);\n\n\tdouble Location[N+2];\n\tLocation[0] = 0.0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lf\",&Location[i]);\n\t}\n\tLocation[N+1] = L;\n\n\tfirst.set(0,0.0,0.0);\n\n\tdouble Dist;\n\tint use_num;\n\n\tfor(int i = 1; i <= N+1;i++){\n\n\t\tDist = Location[i] - Location[i-1];\n\t\tif(Dist <= Carrot_Speed*first.Carrot_Time_Rest){\n\t\t\tfirst.Carrot_Time_Rest -= Dist/Carrot_Speed;\n\t\t\tfirst.Total_Time += Dist/Carrot_Speed;\n\n\t\t}else{\n\t\t\tif(first.Carrot_Time_Rest > 0){\n\t\t\t\tDist -= Carrot_Speed*first.Carrot_Time_Rest;\n\t\t\t\tfirst.Total_Time += first.Carrot_Time_Rest;\n\t\t\t\tfirst.Carrot_Time_Rest = 0;\n\t\t\t}\n\n\t\t\tuse_num = 0;\n\t\t\tfor(int k = 1; k <= first.Carrot_Num;){\n\t\t\t\tif(Dist <= Carrot_Speed*Carrot_Time_Length){\n\t\t\t\t\tfirst.Carrot_Time_Rest = Carrot_Time_Length-Dist/Carrot_Speed;\n\t\t\t\t\tfirst.Total_Time += Dist/Carrot_Speed;\n\t\t\t\t\tDist = 0.0;\n\t\t\t\t\tuse_num = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tDist -= Carrot_Speed*Carrot_Time_Length;\n\t\t\t\t\tfirst.Total_Time += Carrot_Time_Length;\n\t\t\t\t\tk++;\n\t\t\t\t\tif(k > first.Carrot_Num){\n\t\t\t\t\t\tuse_num = first.Carrot_Num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfirst.Carrot_Num -= use_num;\n\n\t\t\tif(Dist > 0){\n\t\t\t\tfirst.Total_Time += Dist/Normal_Speed;\n\t\t\t}\n\t\t}\n\t\tif(first.Carrot_Num <= Have_Limit){\n\t\t\tfirst.Carrot_Num++;\n\t\t\tif(first.Carrot_Num > Have_Limit){\n\t\t\t\tfirst.Carrot_Num--;\n\t\t\t\tfirst.Carrot_Time_Rest = Carrot_Time_Length;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.8lf\\n\",first.Total_Time);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  double lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k>0&&l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  double ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=0;i<L;i++){\n    ans+=1.00/lv[i];\n  }\n  printf(\"%.10lf\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K >> L >> R >> H;\n\tlong double ans = 0;\n\tvector<int>v(H + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W;\n\t\tv[W]++;\n\t}\n\tint index = 0;\n\tint num = 0;\n\tint dush = 0;\n\tfor (int i = 1; i <= H; i++) {\n\t\tif (dush >= i) {\n\t\t\tans += (long double)1 / R;\n\t\t}\n\t\telse ans += (long double)1 / L;\n\t\tif (v[i]) {\n\t\t\tif (dush <= i)dush = i + R * K;\n\t\t\telse if (num < M)num++;\n\t\t\telse dush = i + R * K;\n\t\t}\n\t\tif (dush <= i && num) {\n\t\t\tnum--;\n\t\t\tdush = i + R * K;\n\t\t}\n\t\t//cout << i << \" \" << ans << endl;\n\t}\n\tcout << setprecision(20) << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, k, t, u, v, l;\n\tscanf(\"%d %d %d %d %d %d\", &n, &k, &t, &u, &v, &l);\n\n\tvector<bool> carrot(l, false);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint d;\n\t\tscanf(\"%d\", &d);\n\t\tcarrot[d] = true;\n\t}\n\n\tint cnt = 0, num = 0, rest = 0;\n\tfor(int i = 0; i < l; ++i) {\n\t\tif(carrot[i])\n\t\t\t++num;\n\n\t\tif((num && !rest) || num > k) {\n\t\t\trest = t * v;\n\t\t\t--num;\n\t\t}\n\n\t\tif(rest) {\n\t\t\t--rest;\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tprintf(\"%.15lf\\n\", (double)cnt / v + (double)(l - cnt) / u);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n    int N,K;\n    double T,U,V,L;\n    cin >> N >> K >> T >> U >> V >> L;\n    int have=0;\n    double time;\n    double next,now=0,prev=0;\n    double nokori=0;\n    cin >> next;\n    time += (next/U);\n\n    now = T*V + next;\n    prev = next;\n    for(int i= 1; i < N ; i++){\n        cin >> next;\n        if(next <= now){\n            if(have < K){\n                have++;\n                time +=(next - prev)/V;\n                prev = next;\n            }else{\n                now = next +T*V;\n                time +=(next - prev)/V;\n                prev = next;\n            }\n        }else{\n            for(;now<next && have>0;){\n                now+=(T*V);\n                have--;\n            }\n            if(now >= next){\n                time += (next-prev)/V;\n                prev = next;\n            }else{\n                time += (now - prev)/V;\n                time += (next-now)/U;\n                now = T*V + next;\n                prev = next;\n            }\n        }\n    }\n    next = L;\n    if(next <= now){\n        if(have < K){\n            have++;\n            time +=(next - prev)/V;\n            prev = next;\n        }else{\n            now = next +T*V;\n            time +=(next - prev)/V;\n            prev = next;\n        }\n    }else{\n        for(;now<next && have>0;){\n            now+=(T*V);\n            have--;\n        }\n        if(now >= next){\n            time += (next-prev)/V;\n            prev =next;\n        }else{\n            time += (now - prev)/V;\n            time += (next-now)/U;\n            now = T*V + next;\n            prev = next;\n        }\n    }\n    cout << fixed << setprecision(7) << time << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint a, b, c, d, e, f, g;\nlong long remain;\nint speed;\nint x[10000000];\ndouble res;\nint main() {\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor (int i = 0; i < a; i++) {\n\t\tcin >> g;\n\t\tx[g] = 1;\n\t}\n\tfor (int i = 0; i < f; i++) {\n\t\tif (x[i] == 1) {\n\t\t\tif ((remain - 1) / (c * e) < b) {\n\t\t\t\tremain += c * e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg = ((c * e) - (remain % (c * e)));\n\t\t\t\tif (g == c * e) { g = 0; }\n\t\t\t\tremain += g;\n\t\t\t}\n\t\t}\n\t\tif (remain > 0) {\n\t\t\tres += 1.0 / e;\n\t\t\tremain--;\n\t\t}\n\t\telse {\n\t\t\tres += 1.0 / d;\n\t\t}\n\t}\n\tcout << setprecision(15) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint n, k, t, u, v, l, d[201];\n\ndouble greedy()\n{\n    double time = 0;\n    int carrot = 0;\n    int next_carrot = 0;\n    int place = 0;\n    int dash_length = v * t;\n    while (place < l) {\n        if (carrot == 0) {\n            int distance = d[next_carrot] - place;\n            time += (double)distance / u;\n            place = d[next_carrot];\n            next_carrot++;\n            carrot++;\n        }\n        else {\n            if (place + dash_length < l) {\n                carrot--;\n                while (1) {\n                    if (place + dash_length < d[next_carrot]) {\n                        time += t;\n                        place += dash_length;\n                        break;\n                    }\n                    if (next_carrot == n) {\n                        time += (double)(l - place) / v;\n                        place = l;\n                        break;\n                    }\n                    if (carrot < k) {\n                        next_carrot++;\n                        carrot++;\n                    }\n                    else {\n                        time += (double)(d[next_carrot] - place) / v;\n                        place = d[next_carrot];\n                        next_carrot++;\n                    }\n                }\n            }\n            else {\n                time += (double)(l - place) / v;\n                place = l;\n            }\n        }\n//        cout << \"place\" << place << endl;\n//        cout << \"carrot\" << carrot << endl << endl;\n    }\n    return time;\n}\n\nint main()\n{\n    cin >> n >> k >> t >> u >> v >> l;\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n    d[n] = l; // goal\n    double ans = greedy();\n    cout << fixed << setprecision(8) <<  ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#define eps 1e-9\n\nusing namespace std;\n\nint n, k, t, u, v, l;\nint d[205];\n\nint main(void)\n{\n\tcin >> n >> k >> t >> u >> v >> l;\n\tfor(int i = 0; i < n; i++) cin >> d[i];\n\td[n] = l;\n\t\n\tdouble ans = 0, rem = 0, pos = 0; int nx = 0, stk = 0;\n\twhile(1){\n\t\tif(stk > 0 && rem < eps){\n\t\t\trem = t;\n\t\t\tstk--;\n\t\t}\n\t\tif(rem < eps){\n\t\t\tdouble tm = (d[nx] - pos) / u;\n\t\t\tans += tm;\n\t\t\tpos = d[nx];\n\t\t\tnx++;\n\t\t\tif(stk < k) stk++;\n\t\t\telse rem = t;\n\t\t}\n\t\telse{\n\t\t\tif(pos + rem * v < d[nx]){\n\t\t\t\tans += rem;\n\t\t\t\tpos += rem * v;\n\t\t\t\trem = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble tm = (d[nx] - pos) / v;\n\t\t\t\tans += tm;\n\t\t\t\tpos = d[nx];\n\t\t\t\tnx++;\n\t\t\t\trem -= tm;\n\t\t\t\tif(stk < k) stk++;\n\t\t\t\telse rem = t;\n\t\t\t}\n\t\t}\n\t\tif(pos >= l - eps) break;\n\t}\n\tprintf(\"%.11f\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l;\n  cin>>n>>k>>t>>u>>v>>l;\n  int i,j;\n  set<int> s;\n  for(i=0;i<n;i++){\n    cin >> j;\n    s.insert(j);\n  }\n  int p=0,h=0,x=0;\n  double ans=0;\n  for(i=1;i<=l;i++){\n    if(x==0){\n      if(h>0){\n\tx=v*t-1;h--;\n\tans+=1.0/v;\n      }else ans+=1.0/u;\n    }else{\n      ans+=1.0/v;\n      x--;\n    }\n    if(s.find(i)!=s.end())\n      if(h<k) h++;\n      else x=v*t;\n  }\n  printf(\"%.9lf\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int N,K,T,U,V,L;\n    cin>>N>>K>>T>>U>>V>>L;\n    vector<int> D(N);\n    for(auto &d:D) cin>>d;\n    int ite=0;\n    double boost=0;\n    double ans=0;\n    int k=0;\n    for(int x=1;x<=L;x++){\n        ans+=(boost>1e-3?1.0/V:1.0/U);\n        if(fabs(boost)<1e-3)boost=0;\n        if(boost>0) boost-=1.0/V;\n        if(D[ite]==x){\n            if(boost>0&&k==K||boost==0){\n                boost=T;\n            }else{\n                k++;\n            }\n            ite++;\n        }else if(boost<=0&&k>0){\n            boost=T;\n            k--;\n        }\n    }\n    cout<<fixed;\n    cout.precision(9);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  float lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  float ans=0.0;\n\n  for(int i=1;i<=L;i++){\n    ans+=(1.0/lv[i]);\n  }\n  printf(\"%f\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n int main(void){\n\t int n,k,t,u,v,l;\n\t cin>>n>>k>>t>>u>>v>>l;\n\t vector<int> d(n);\n\t vector<bool> x(l,false);\n\t vector<bool> a(l,false);\n\t for(int i=0;i<n;i++){\n\t\t cin>>d[i];\n\t\t x[d[i]]= true;\n\t } \n\t int rest=0;\n\t int a1=t*v;\n\t int amax=a1*(k+1);\n\t// cout<<amax<<endl;\n\t for(int i=0;i<l;i++){\n\t\t if(x[i])rest+=a1;\n\t\t if(rest>amax)rest=amax;\n\t\t if(rest!=0) {\n\t//\t\t cout<<rest<<\" \";\n\t\t\t rest--;\n\t\t\t a[i]=true;\n\t//\t\t cout<<i<<\" \";\n\t\t }\n\t }\n\t\tint nl=0,al=0;\n\t\tfor(int i=0;i<l;i++){\n\t\t\tif(a[i])al++;\n\t\t\telse nl++;\n\t\t}\n\t//\tcout<<al<<\" \"<<nl<<endl;\n\tprintf(\"%f\\n\",(double)al/v+(double)nl/u);\n\n\t//cout<<(double)al/v+(double)nl/u;\n\n\t return 0;\n }"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   public:\n      queue <TNode> Q;\n      IBFS() {\n         Q = queue <TNode>();\n      }\n      virtual void init() = 0;\n      virtual TNode get_start_node() = 0;\n      virtual bool is_goal( TNode node ) = 0;\n      TNode run() {\n         init();\n         Q.push( get_start_node() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal( node ) ) {\n               return node;\n            }\n            find(node);\n         }\n         return TNode();\n      }\n      virtual void find( TNode node ) = 0;\n      void push_next_node( TNode node ) {\n         Q.push(node);\n      }\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Node {\n   public:\n      double cost;\n      int id;\n      int remains;\n      int carrots;\n      Node(): cost(NONE){}\n      Node( double cost, int id, int remains, int carrots ):\n         cost(cost), id(id), remains(remains), carrots(carrots) {}\n      friend ostream& operator << ( ostream& os, Node node ) {\n         return os << node.cost << \", \" << node.id << \", \"\n                   << node.remains << \", \" << node.carrots << \" / \";\n      }\n   };\n\n   class BFS: public IBFS<Node> {\n   private:\n      double base;\n      double fast;\n   public:\n      void init() {\n         base = 1.0 / U;\n         fast = 1.0 / V;\n      }\n\n      Node get_start_node() {\n         return Node( 0.0, 0, 0, 0 );\n      }\n\n      bool is_goal( Node node ) {\n         return node.id == L;\n      }\n\n      void find( Node node ) {\n         int id = node.id;\n         int carrots = node.carrots;\n         int remains = node.remains;\n         double cost = node.cost;\n\n\n         if ( D[id] ) {\n            if ( carrots == K ) {\n               remains = T * V;\n            } else {\n               carrots ++;\n               if ( remains == 0 ) {\n                  remains = T * V;\n                  carrots --;\n               }\n            }\n         }\n\n         double t = base;\n         if ( remains ) {\n            t = min( t, fast );\n            remains --;\n         }\n         if ( remains == 0 && carrots ) {\n            remains = T * V;\n            carrots --;\n         }\n\n         push_next_node( Node( cost + t, id + 1, remains, carrots ) );\n      }\n   };\n\n   class Solution {\n   private:\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         return BFS().run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate <class T=int> inline T in() { T x; cin >> x; return x; }\n\n#include <iomanip>\nint main() {\n    cout << fixed << setprecision(12);\n    int N = in();\n    int K = in();\n    int T = in();\n    int U = in();\n    int V = in();\n    int L = in();\n    vector<bool> carrot(L + 1, false);\n    for (int i = 0; i < N; i++) carrot[in()] = true;\n\n    double ans = 0;\n    int hav = 0;\n    int dur = 0;\n    for (int pos = 1; pos <= L; pos++) {\n        if (dur) {\n            dur--;\n            ans += 1.0 / V;\n        } else {\n            ans += 1.0 / U;\n        }\n        if (carrot[pos]) {\n            if (!dur or hav == K) {\n                carrot[pos] = false;\n                dur = V * T;\n            } else {\n                hav++;\n            }\n        } else {\n            if (!dur && hav) {\n                hav--;\n                dur = V * T;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint N, K, T, U, V, L;\n\tdouble D[201];\n\twhile(cin >> N >> K >> T >> U >> V >> L){\n\t\tfor(int i=0;i<N;i++) cin >> D[i];\n\t\tD[N] = L;\n\t\tdouble res = (double)D[0]/U;\n\t\tdouble lest = T;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tdouble len = D[i]-D[i-1];\n\t\t\tif(len > lest*V){\n\t\t\t\tres += lest + (len-lest*V)/U;\n\t\t\t\tlest = 0;\n\t\t\t} else {\n\t\t\t\tres += len/V;\n\t\t\t\tlest -= len/V;\n\t\t\t}\n\t\t\tlest = min(lest+T, T*(K+1.0));\n\t\t}\n\t\tprintf(\"%.8lf\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll N, K, T, L;\ndouble U, V;\nbool A[105000];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> K >> T >> U >> V >> L;\n    for(int i = 0; i < N; i++) {\n        int d;\n        cin >> d;\n        A[d] = true;\n    }\n    double ans = 0;\n    int Last = -1e9;\n    int num = 0;\n    for(int i = 0; i < L; i++) {\n        if(A[i]) {\n            if(num < K) {\n                num++;\n            } else {\n                Last = i;\n            }\n        }\n        if(Last + V * T <= i and num) {\n            num--;\n            Last = i;\n        }\n        if(Last + V * T <= i) ans += 1 / U;\n        else {\n            ans += 1 / V;\n        }\n    }\n    cout << fixed << setprecision(30) << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n    double N,K,T,U,V,L,D[201];\n    double k=0, boost = 0, tm = 0;\n    int index = 1;\n    cin >> N >> K >> T >> U >> V >> L;\n    for(int i=1; i<=N; i++){\n        cin >> D[i];\n    }\n    for(int i=1; i<=L; i++){\n        if(index<=N && i==D[index]){\n            if(k < K)   k++;\n            else        boost = V*T;\n            index++;\n        }\n        if(boost == 0 && k > 0){\n            k--;\n            boost = V*T;\n        }\n        if(boost == 0)  tm +=1.0/U;\n        else{\n            tm += 1.0/V;\n            boost--;\n        }\n    }\n    cout << fixed;\n    cout << setprecision(8) << tm << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n\tint ncarrot, max_have_carrot, accel_time, standard_speed, accel_speed, length;\n\tint carrot[201], suffix = 0;\n\n\tcin >> ncarrot >> max_have_carrot >> accel_time >> standard_speed >> accel_speed >> length;\n\n\tfor (int i = 0; i < ncarrot; i++) {\n\t\tcin >> carrot[i];\n\t}\n\n\tint have = 0;\n\tdouble time = 0.0, after_time = 0.0;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (carrot[suffix] == i) {\n\t\t\tif (have == 0 && after_time == 0) { //何も持っていない&加速していない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\telse if (have < max_have_carrot) { //まだ持てる\n\t\t\t\thave++;\n\t\t\t}\n\t\t\telse { //もう持てない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\tsuffix++;\n\t\t}\n\n\t\tif (after_time > 0.0) {\n\t\t\tif (after_time - (double)(1.0 / accel_speed) < 0.00000001) { //近似\n\t\t\t\tafter_time = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tafter_time -= (double)(1.0 / accel_speed);\n\t\t\t}\n\t\t\ttime += (double)(1.0 / accel_speed);\n\n\t\t\tif (after_time <= 0.0) {\n\t\t\t\tif (have > 0) {\n\t\t\t\t\thave--;\n\t\t\t\t\tafter_time = (double)accel_time;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thave = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttime += (double)(1.0 / standard_speed);\n\t\t}\n\t}\n\n\tprintf(\"%.100f\", time);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum{CARROT,BATERU,GOAL};\nstruct Event{\n    int type;\n    double pos;\n};\n\nbool operator<(const Event &lhs,const Event &rhs){\n    return lhs.pos==rhs.pos ? lhs.type>rhs.type : lhs.pos>rhs.pos;\n}\n\n\nint main(){\n    int n,k,t,u,v,l;\n    cin>>n>>k>>t>>u>>v>>l;\n        vector<int> d(n);\n        for(int i=0;i<n;i++) cin>>d[i];\n        priority_queue<Event> que;\n        for(int i=0;i<n;i++){\n            que.push(Event{CARROT,double(d[i])});\n        }\n        que.push(Event{GOAL,double(l)});\n        double ver=u;\n        double pos=0;\n        int cnt=0;\n        int charge=0;\n        double res=0;\n        while(true){\n            Event eve=que.top(); que.pop();\n            res+=(eve.pos-pos)/ver;\n            pos=eve.pos;\n            \n            if(eve.type==CARROT){\n                \n                if(cnt==k){\n                    charge++;\n                    que.push({Event{BATERU,pos+v*t}});\n                }\n                else{\n                    \n                    cnt=cnt+1;\n                    if(ver==u){\n                        assert(charge==0);\n                        cnt--;\n                        charge++;\n                        ver=v;\n                        que.push({Event{BATERU,pos+v*t}});\n                    }\n                }\n            }\n            else if(eve.type==GOAL){\n                break;\n            }\n            else if(eve.type==BATERU){\n                \n                charge--;\n                if(charge==0){     \n                    if(cnt>0){\n                        cnt--;\n                        charge++;\n                        que.push(Event{BATERU,pos+t*v});\n                    }\n                    else{\n                        ver=u;\n                    }\n                }\n                \n            }\n        }\n        cout<<setprecision(10)<<fixed;\n        cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <queue>\n\n#include <iomanip>\n\n#define LINE() cerr << \"L:\"<<__LINE __ <<endl;\n\n\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\n\n\nclass Task{\n\tpublic:\n\tdouble pos;\n\tint isC;\n\tTask(double pos,int isC):pos(pos),isC(isC){\n\n\t}\n\n\tbool operator < (const Task& r) const{\n\t\treturn pos < r.pos;\n\t}\n\tbool operator > (const Task& r) const{\n\t\treturn pos > r.pos;\n\t}\n};\n\nint N,K,T,U,V,L;\nint main() {\n\tcin >> N >> K >> T >> U >> V >> L ;\n\n\tvector<int> ds(N);\n\tfor(int i =0 ; i < N ; i++){\n\t\tcin >> ds[i];\n\t}\n\n\tpriority_queue<Task,vector<Task>,greater<Task>> que;\n\tque.push(Task(0,0));\n\tque.push(Task(L,0));\n\tfor(int i =0 ; i < N ; i++){\n\t\tque.push(Task(ds[i],1));\n\t}\n\n\tdouble res=0,pos=0,VT=0;int kc=0;\n\twhile(!que.empty()){\n\t\tTask t=que.top();que.pop();\n\t\t// cout <<\";\" <<t.pos<<\":\"<< pos <<\":\"<<kc<<endl;\n\t\tdouble vt=min(VT,(t.pos-pos)/V);\n\n\t\t// cout <<VT<< \"vt:\"<<vt <<endl;\n\t\tres+=vt;\n\t\tVT-=vt;\n\t\tpos+=vt*V;\n\t\t\n\t\tdouble ut=(t.pos-pos)/U;\n\t\tres+=ut;\n\t\tpos=t.pos;\n\n\t\t//next\n\t\tif(t.isC)kc++;\n\n\t\t// cout <<\"vt:\"<<VT<<endl;\n\t\tif(kc>K || (VT<1e-9 && kc>0)){\n\t\t\tVT=T;\n\t\t\tkc--;\n\t\t\tif(pos+T*V<=L)que.push(Task(pos+T*V,0));\n\n\t\t\t// cout << pos<<\"!\"<<pos+T*V << \":\"<<kc<<endl;\n\t\t\t\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(15);\n\tcout <<res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int LEN = 10001;\nconst double EPS = 1e-8;\n\nmain(){\n  int N, K, T, U, V, L;\n  bool D[LEN];\n  fill(D, D+LEN, false);\n  cin >> N >> K >> T >> U >> V >> L;\n  for(int i=0;i<N;i++){\n    int in;\n    cin >> in;\n    D[in] = true;\n  }\n  double ans = 0.0, rem;\n  bool f = false;\n  int c = 0;\n  for(int i=0;i<L;i++){\n    if(D[i]) c++;\n    if(c > K || !f && c){\n      c--;\n      f = true;\n      rem = T;\n    }\n    if(f){\n      if(rem - 1.0 / V < 0.0 + EPS){\n        ans += rem + (1.0 - rem * V) / U;\n        f = false;\n        rem = 0.0;\n      }else{\n        rem -= 1.0 / V;\n        ans += 1.0 / V;\n      }\n    }else ans += 1.0 / U;\n  }\n  printf(\"%.9f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <set>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main(void)\n{\n\tint N, K, T, U, V, L;\n\tint time = 0;\n\tint carrot = 0;\n\tint v_run = 0;\n\tdouble result;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tset<int> D;\n\trep(i, N){\n\t\tint d;\n\t\tcin >> d;\n\t\tD.insert(d);\n\t}\n\t//毎ループ地点iにおいて振る舞いを考える\n\trep(i, L){\n\t\tif (time > 0){\n\t\t\tv_run++;\n\t\t\ttime--;\n\t\t}else if(time == 0 && carrot > 0){\n\t\t\tcarrot--;\n\t\t\tv_run++;\n\t\t\ttime = V*T - 1;\n\t\t}\n\t\tif (D.find(i) != D.end()){\n\t\t\tif (carrot == K || time == 0){\n\t\t\t\ttime = V*T;\n\t\t\t}else{\n\t\t\t\tcarrot++;\n\t\t\t}\n\t\t}\n\t}\n\tresult = (double)v_run / V + (double)(L - v_run) / U;\n\tcout << fixed << setprecision(9) << result << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <iomanip>\n\nconstexpr double E = 1e-8;\nconstexpr int INF = 99999999;\n\nint main() {\n    int n, k, t, u, v, l;\n    std::vector<int> d;\n    std::cin >> n >> k >> t >> u >> v >> l;\n    for (int i = 0; i < n; i++) {\n        int a; std::cin >> a;\n        d.push_back(a);\n    }\n\n    double numTime = 0.0;\n    int numOfCarrot = 0;\n    double remaindSpeedUpTime = 0.0;\n    int carrotIndex = -1;\n    double pos = 0.0;\n    while (1) {\n        double nowSpeed = 0;\n        if (remaindSpeedUpTime > 0.0) nowSpeed = v;\n        else nowSpeed = u;\n\n        // 次の区切りを探す\n        double nextCarrotTime = INF;\n        double goalTime = (l - pos) / nowSpeed; // ゴールまでの時間\n\n        // 次の人参までの時間\n        if (carrotIndex < (int)(d.size()) - 1) {\n            int remaindNextCarrotLen = (d[carrotIndex + 1] - pos);\n            nextCarrotTime = remaindNextCarrotLen / nowSpeed;\n        }\n\n        // 区切りに合わせて\n        // 次の人参イベが最も早い\n        if (nextCarrotTime < goalTime && ((nextCarrotTime < remaindSpeedUpTime && remaindSpeedUpTime > 0.0) || remaindSpeedUpTime <= 0.0)) {\n            pos = d[++carrotIndex];\n            numTime += nextCarrotTime;\n\n            // 人参取得\n            numOfCarrot++;\n            // もう持てないか人参切れなら食べる\n            if (numOfCarrot > k || remaindSpeedUpTime <= 0.0) {\n                remaindSpeedUpTime = t;\n                numOfCarrot--;\n            }\n        }\n        else if (remaindSpeedUpTime > 0.0 && remaindSpeedUpTime < goalTime) { // 人参切れを起こす\n            pos += remaindSpeedUpTime * nowSpeed;\n            numTime += remaindSpeedUpTime;\n            remaindSpeedUpTime = 0;\n            // 人参あるなら食べる\n            if (numOfCarrot > 0) {\n                numOfCarrot--;\n                remaindSpeedUpTime = t;\n            }\n        }\n        else { // ゴール\n            pos = l;\n            numTime += goalTime;\n            break;\n        }\n    }\n    std::cout << std::fixed << std::setprecision(9) << numTime << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i;\n    long long j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n        //cout << i << \" \" << dd << \" \" << endl;\n    }\n    //cout << dd <<endl;\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, k, t, u, v, l;\n\tscanf(\"%d %d %d %d %d %d\", &n, &k, &t, &u, &v, &l);\n\n\tvector<bool> carrot(l, false);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint d;\n\t\tscanf(\"%d\", &d);\n\t\tcarrot[d] = true;\n\t}\n\n\tint cnt = 0, num = 0, rest = 0;\n\tfor(int i = 0; i < l; ++i) {\n\t\tif(carrot[i])\n\t\t\t++num;\n\n\t\tif((num && !rest) || num > k) {\n\t\t\trest = v;\n\t\t\t--num;\n\t\t}\n\n\t\tif(rest) {\n\t\t\t--rest;\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tprintf(\"%.15lf\\n\", (double)cnt / v + (double)(l - cnt) / u);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n int main(void){\n\t int n,k,t,u,v,l;\n\t cin>>n>>k>>t>>u>>v>>l;\n\t vector<int> d(n);\n\t vector<bool> x(l,false);\n\t vector<bool> a(l,false);\n\t for(int i=0;i<n;i++){\n\t\t cin>>d[i];\n\t\t x[d[i]]= true;\n\t } \n\t int rest=0;\n\t int a1=t*v;\n\t int amax=a1*(k+1);\n\t// cout<<amax<<endl;\n\t for(int i=0;i<l;i++){\n\t\t if(x[i])rest+=a1;\n\t\t if(rest>amax)rest=amax;\n\t\t if(rest!=0) {\n\t//\t\t cout<<rest<<\" \";\n\t\t\t rest--;\n\t\t\t a[i]=true;\n\t//\t\t cout<<i<<\" \";\n\t\t }\n\t }\n\t\tint nl=0,al=0;\n\t\tfor(int i=0;i<l;i++){\n\t\t\tif(a[i])al++;\n\t\t\telse nl++;\n\t\t}\n\t//\tcout<<al<<\" \"<<nl<<endl;\n\tprintf(\"%f\\n\",(double)al/v+(double)nl/u);\n\n\t//cout<<(double)al/v+(double)nl/u;\n\n\t return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#if 0\nusing namespace std;\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define int ll\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n#endif\nsigned main() {\n    int N, K, T, U, V, L;\n    scanf(\"%d %d %d %d %d %d\", &N, &K, &T, &U, &V, &L);\n\n    std::vector<int>  C(L+1);\n    for (int i=0; i<N; ++i) {\n        int D;\n        scanf(\"%d\", &D);\n        ++C[D];\n    }\n\n    int num_carrot=0;\n    int remain=0;\n    std::vector<int> F(L+1);\n    for (int i=0; i<=L; ++i) {\n        if (remain-- > 0)\n            F[i] = 1;\n\n        if (C[i])\n            ++num_carrot;\n\n        if (num_carrot) {\n            if (remain < 0 || num_carrot > K) {\n                --num_carrot;\n                remain = V*T;\n            }\n        }\n    }\n\n    int dist[2]={};\n    for (int i=0; i<L; ++i)\n        ++dist[F[i]];\n\n    printf(\"%.16f\\n\", (dist[0]*1.0/U)+(dist[1]*1.0/V));\n    return 0;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\ndouble const EPS = 1e-6;\n\nint main() {\n\n  int N, K, T, U, V; double L;\n  cin >> N >> K >> T >> U >> V >> L;\n  set<int> D;\n  rep(i, N) {\n    int d; cin >> d;\n    D.insert(d);\n  }\n\n  int ninjin = 0;\n  double stime = 0.0;\n  int zizoku = 0;\n\n  // ティツキツ敕ゥツ崢「テ」ツつ?テ」ツ?堙」ツ?、テゥツ?イテ」ツつ?」ツつ?\n\n  rep(len, L) {\n\n    if(D.count(len)) {\n      if(ninjin + 1 > K) {\n        zizoku = V * T;\n      } else {\n        ninjin ++;\n      }\n    }\n\n    if(!zizoku && ninjin > 0) {\n      ninjin --;\n      zizoku = V * T;\n    }\n\n    if(zizoku) {\n      zizoku --;\n      stime += 1.0 / V;\n    } else {\n      stime += 1.0 / U;\n    }\n\n  }\n\n  printf(\"%.10f\\n\", stime);\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\n\n\nint main(){\n\n  int n,k,t,u,v,l;\n  cin >> n >> k >> t >> u >> v >> l;\n  vector<int> d(n+1);\n  rep(i,n)cin>>d[i];\n  d[n] = l;\n\n  int h = 0;\n  double time = 0.0;\n  int pos = 0;\n  int dind = -1;\n  while (pos<l){\n    if (h==0){\n      dind++;\n      time += (double)(d[dind]-pos)/u;\n      pos = d[dind];\n      // cout << dind << \" \" << pos << \" \" << time << endl;\n      h = 1;\n    } else {\n      h--;\n      auto itr=upper_bound(d.begin(),d.end(),pos+v*t)-1;\n      int c = distance(d.begin(),itr)-dind;\n      // cout << c << endl;\n      if(h+c<=k){\n        if (pos+v*t<l){\n          pos += v*t;\n          time += t;\n          dind += c;\n          h += c;\n          // cout << dind << \" \" << pos << \" \" << time << \" \" << h << endl;\n        } else {\n          time += (double)(l-pos)/v;\n          pos = l;\n        }\n      } else {\n        h = k;\n        dind += c;\n        int pos_d = d[dind]+v*t;\n        if(pos_d>l){\n          time += (double)(l-pos)/v;\n          pos = l;\n        } else {\n          time += (double)(pos_d-pos)/v;\n          // cout << dind << \" \" << pos << \" \" << time << \" \" << h << endl;\n          pos = pos_d;\n        }\n      }\n    }\n  }\n  cout << setprecision(10) << time << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint N, K, T, U, V, L;\nint A[10010];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  cin >> N >> K >> T >> U >> V >> L;\n  for (int i = 0; i < N; i++) {\n    int D;\n    cin >> D;\n    A[D]++;\n  }\n\n  int car = 0, bst = 0;\n  double ans = 0;\n  for (int i = 1; i <= L; i++) {\n    ans += 1.0 / (bst ? V : U);\n    bst = max(0, bst - 1);\n    if (A[i]) {\n      if (bst == 0) bst = T * V;\n      else if (car < K) car++;\n      else bst = T * V;\n    } else {\n      if (bst == 0 && car) car--, bst = T * V;\n    }\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tint n,K,T,U,V,L;\n\tcin>>n>>K>>T>>U>>V>>L;\n\tvint v(L+1,0);\n\trep(i,n){\n\t\tint t;\n\t\tcin>>t;\n\t\tv[t]++;\n\t}\n\tint cnt=0;\n\tint a=0;\n\tint b=0;\n\tint boost;\n\tbool f=false;\n\treep(i,1,L+1){\n\t\tif(f) a++;\n\t\telse b++;\n\t\tif(boost==i){\n\t\t\tf=false;\n\t\t}\n\t\tif(v[i]){\n\t\t\tif(f){\n\t\t\t\tif(cnt==K){\n\t\t\t\t\tboost=i+V*T;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboost=i+V*T;\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!f&&cnt){\n\t\t\t\tcnt--;\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(double)b/U+(double)a/V<<endl;\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(10);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i, j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n        //cout << i << \" \" << dd << \" \" << endl;\n    }\n    //cout << dd <<endl;\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> P3;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e4 + 5);\nconst double EPS = 1e-11;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint main() {\n    int n;\n    double k, t, u, v, l, d[205], r=0.0, ans=0.0;\n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i,n) cin >> d[i+1];\n    d[0] = 0;\n    d[n+1] = l;\n    REP(i,n+1){\n        double di = d[i+1]-d[i];\n        ans += min(r,di/v) + max(0.0,di-r*v)/u;\n        r -= min(r,di/v);\n        r = min((k+1.0)*t, r+t);\n    }\n    printf(\"%.8lf\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,k,t,u,v,L;\n  int d;\n  int vm=0,nm,nk=0,lk;\n  cin>>n>>k>>t>>u>>v>>L;\n  cin>>d;\n  nm=d;\n  lk=d;\n  for(int i=1;i<n;i++) {\n    cin>>d;\n    while(lk+v<d && nk!=0){\n      vm+=v;\n      lk+=v;\n      nk--;\n    }\n    if(nk<k) nk++;\n    else if(lk+v > d){\n      vm+=d-lk;\n      lk=d;\n    }\n    nm=d;\n  }\n  if(L-lk<nk*v+v) vm+=L-d;\n  else vm+= nk*v+v;\n  //cout<<vm<<endl;\n  printf(\"%.10f\\n\",(double)vm/v+(double)(L-vm)/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,K,T,U,V,L;\nqueue<int>C;\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tC.push(t);\n\t}\n\tC.push(L);//goal\n\n\tint c=0,f=0,p=0;\n\tdouble t=0,tmp=0;\n\twhile(!C.empty()||tmp>p)\n\t{\n\t\tif(tmp<=p)\n\t\t{\n\t\t\ttmp=C.front();C.pop();\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tp+=T*V;\n\t\t\tt+=T;\n\t\t\twhile(!C.empty())\n\t\t\t{\n\t\t\t\tc++;\n\t\t\t\tif(c>K)\n\t\t\t\t{\n\t\t\t\t\tint nr=T*V-(p-tmp);\n\t\t\t\t\tc=K;\n\t\t\t\t\tp+=nr;\n\t\t\t\t\tt+=1.0*nr/V;\n\t\t\t\t}\n\t\t\t\ttmp=C.front();\n\t\t\t\tC.pop();\n\t\t\t\tif(tmp>p)break;\n\t\t\t}\n\t\t\tif(c==0)f=0;\n\t\t\telse c--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt+=(1.0*tmp-p)/U;\n\t\t\tp=tmp;\n\t\t\tf=1;\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,k,t,u,v,l;\n\tint flg[10005]={0};\n\tcin>>n>>k>>t>>u>>v>>l;\n\tfor(int i=0,j;i<n;i++){\n\t\tcin>>j;\n\t\tflg[j]=1;\n\t}\n\tint pos=0;\n\tint rem=0;\n\tint hav=0;\n\tdouble ans=0;\n\twhile(pos<l){\n\t\tif(flg[pos]){\n\t\t\tif(hav==k)rem=t*v;\n\t\t\telse{\n\t\t\t\thav++;\n\t\t\t\tif(rem==0){\n\t\t\t\t\trem=t*v;\n\t\t\t\t\thav--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=1.0/v;\n\t\t\trem--;\n\t\t\tif(rem==0 && hav>0){\n\t\t\t\trem=t*v;\n\t\t\t\thav--;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(rem>0){\n\t\t\t\tans+=1.0/v;\n\t\t\t\trem--;\n\t\t\t\tif(rem==0 && hav>0){\n\t\t\t\t\trem=t*v;\n\t\t\t\t\thav--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans+=1.0/u;\n\t\t\t}\n\t\t}\n\t\tpos++;\n\t}\n\tprintf(\"%.7f\\n\",ans);\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, K, T, U, V, L;\nbool point[10010];\n\nsigned main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    rep(i,0,N) {\n        int p; cin >> p;\n        point[p] = true;\n    }\n\n    int stock = 0, prev = -1, da = 0, db = 0;\n    rep(i,0,L) {\n        if((prev < 0 || prev + T*V < i) && stock) prev = i-1, stock--;\n        // printf(\"point = %lld, prev = %lld\\n\", i, prev);\n\n        (prev < 0 || prev + T*V < i ? da : db)++;\n        if(point[i]) {\n            if(stock == K) prev = i;\n            else stock++;\n        }\n    }\n    // printf(\"da = %lld, db = %lld\\n\", da, db);\n    double ans = 1.0 * da / U + 1.0 * db / V;\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main(){\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  int D[N];\n  for(int i = 0; i < N; ++i)\n    cin >> D[i];\n  int t = 0, s = 0, r = 0, f = 0;\n  for(int i = 0; i <= L; ++i){\n    if(r > 0){\n      ++f;\n      --r;\n    }\n    if(t < N && D[t] == i){\n      ++t;\n      ++s;\n    }\n    if((r == 0 && s > 0) || s > K){\n      r = T*V;\n      --s;\n    }\n  }\n  printf(\"%.10f\\n\",(double)f/V + (double)(L-f)/U);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, K, T, U, V, L, x;\nint main() {\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<bool> v(L);\n\tfor (int i = 0; i < N; i++) cin >> x, v[x] = true;\n\tdouble ret = 0.0, car = 0.0;\n\tfor (int i = 0; i < L; i++) {\n\t\tif (v[i]) car = min(car + 1.0, 1.0 * K + 1);\n\t\tif (car > 1.0e-8) ret += 1.0 / V, car -= 1.0 / (V * T);\n\t\telse ret += 1.0 / U;\n\t}\n\tcout << fixed << setprecision(15) << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, K, T, U, V, L;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> K >> T >> U >> V >> L;\n  VI D(N); REP(i,N) cin >> D[i];\n  \n  int prv = 0, num = 0;\n  double ans = 0;\n  for(int i=0;i<N;++i){\n\tif(num > 0){\n\t  if(prv + T * V < D[i]){\n\t\tans += T;\n\t\tprv += T*V;\n\t\t--num;\n\t  }\n\t  else{\n\t\t--num;\n\t\tint to = prv + T * V;\n\t\tfor(;i<N;++i){\n\t\t  if(to < D[i]){\n\t\t\t--i;\n\t\t\tans += T;\n\t\t\tprv = to;\n\t\t\tbreak;\n\t\t  }\n\t\t  if(++num > K){\n\t\t\tans += (D[i] - prv)*1. / V;\n\t\t\tprv = D[i];\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif(i == N){\n\t\t  if(prv + T*V < L){\n\t\t\tans += T;\n\t\t\tprv = to;\n\t\t  }\n\t\t  else{\n\t\t\tans += (L - prv)*1. / V;\n\t\t\tprv = L;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\telse{\n\t  ans += (D[i] - prv)*1. / U;\n\t  prv = D[i];\n\t  ++num;\n\t}\n  }\n  if(prv != L){\n\twhile(num > 0){\n\t  if(prv + T*V < L){\n\t\tans += T;\n\t\tprv += T*V;\n\t  }\n\t  else{\n\t\tans += (L - prv)*1. / V;\n\t\tprv = L;\n\t\tnum = 0;\n\t  }\n\t  --num;\n\t}\n\tans += (L - prv)*1. / U;\n  }\n\n  cout << fixed << setprecision(9) << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(N + 1);\n\tD[0] = 0;\n\tfor(int i = 1; i <= N; ++i){ cin >> D[i]; }\n\tsort(D.begin(), D.end());\n\tD.push_back(L);\n\tint stock = 0;\n\tdouble answer = 0.0, remains = 0.0;\n\tfor(int i = 1; i < D.size(); ++i){\n//cerr << i << \" : \" << answer << \", \" << remains << \", \" << stock << endl;\n\t\tdouble len = D[i] - D[i - 1];\n\t\tif(stock == 0){\n\t\t\tanswer += remains / V;\n\t\t\tanswer += (len - remains) / U;\n\t\t\t++stock;\n\t\t}else{\n\t\t\tdouble d = remains;\n\t\t\tanswer += remains / V;\n\t\t\twhile(stock > 0 && d < len){\n\t\t\t\td += V * T;\n\t\t\t\tanswer += T;\n\t\t\t\t--stock;\n\t\t\t}\n\t\t\tif(d < len){\n\t\t\t\tremains = 0.0;\n\t\t\t\tanswer += (len - d) / U;\n\t\t\t\t++stock;\n\t\t\t}else{\n\t\t\t\tremains = d - len;\n\t\t\t\tanswer -= remains / V;\n\t\t\t\tif(stock == K){\n\t\t\t\t\tremains = V * T;\n\t\t\t\t}else{\n\t\t\t\t\t++stock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(9) << setiosflags(ios::fixed) << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nconstexpr double eps = 1e-8;\n\nint main() {\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    vector<double> D(n);\n    for(int i=0; i<n; ++i) {\n        cin >> D[i];\n    }\n    double pos = 0;\n    double res = 0;\n    int cnt = 0;\n    double rest = 0;\n    for(int i=0; i<n; ++i) {\n        if(rest == 0 && cnt == 0) {\n            res += (D[i] - pos) / u;\n            pos = D[i];\n            rest = v*t;\n        } else if(rest + pos >= D[i]) {\n            if(cnt == k) {\n                res += (D[i] - pos) / v;\n                pos = D[i];\n                rest = v*t;\n            } else {\n                cnt++;\n            }\n        } else {\n            while(cnt > 0 && rest + eps < D[i] - pos) {\n                res += t;\n                pos += v*t;\n                cnt--;\n            }\n            if(D[i] - pos > rest + eps) {\n                res += rest / v + (D[i] - pos - rest) / u;\n                pos = D[i];\n                rest = v*t;\n            } else {\n                rest -= D[i] - pos;\n                res += (D[i] - pos) / v;\n                pos = D[i];\n                cnt++;\n            }\n        }\n    }\n    if(rest + (double)cnt*v*t >= l - pos) {\n        res += (l - pos) / v;\n    } else {\n        res += rest / v + cnt * t + (l - (pos + rest + cnt*v*t)) / u;\n    }\n    cout << fixed << setprecision(10) << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst double inf = 1e9;\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(L+1, 0);\n\tfor (int i = 0;i < N;i++) {\n\t\tint d; cin >> d;\n\t\tD[d] = 1;\n\t}\n\tlong double ans = 0;\n\n\tint have_carrot = 0;\n\tint limit_l = -1;\n\tbool boost = false;\n\tfor (int l = 0; l < L;l++) {\n\t\t//cout << l << \" \" << \" \" << boost <<\" \" << limit_l << \" \"<< ans << endl;\n\t\t// no boost\n\t\tif (!boost) {\n\t\t\tif (D[l] == 1) {\n\t\t\t\tans += 1 / (double)V;\n\t\t\t\tboost = true;\n\t\t\t\tlimit_l = l + T*V;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += 1 / (double)U;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (l == limit_l) {\n\t\t\tif (D[l] == 1) have_carrot++;\n\t\t\tif (have_carrot > 0) {\n\t\t\t\thave_carrot--;\n\t\t\t\tlimit_l = l + T*V;\n\t\t\t\tans += 1 / (double)V;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboost = false;\n\t\t\t\tans += 1 / (double)U;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tans += 1 / (double)V;\n\t\tif (D[l] == 1) {\n\t\t\thave_carrot++;\n\t\t\tif (have_carrot <= K) continue;\n\t\t\tlimit_l = l + T*V;\n\t\t\thave_carrot--;\n\t\t}\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int N, K, T, U, V, L, D;\n    int pre_D, old_D;\n    double t;\n    int ac_l, ac_dis, no_l, s;\n    cin >> N >> K >> T >> U >> V >> L;\n    ac_l = ac_dis = V * T;\n    cin >> D;\n    no_l = pre_D = D;\n    for(int i = 1; i < N; i++){\n        cin >> D;\n        if(pre_D - D > 0 && (pre_D - D) / ac_dis >= K-1){\n            no_l += (D - old_D);\n            ac_l -= (D - old_D);\n        }\n        old_D = D;\n        if((s = D - pre_D - ac_dis) > 0)\n            no_l += s;\n        else\n            D -= s;\n        ac_l += ac_dis;\n        pre_D = D;\n    }\n    if((s = L - no_l - ac_l) > 0)\n        no_l += s;\n    t = (double)no_l / U + ((double)L - no_l) / V;\n    cout << t << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nint N,K,T,U,V,L;\nint carrot[100010];\nint down[100010];\n\nint main(){\n    while(cin >> N >> K >> T >> U >> V >> L){\n        rep(i,L+1) carrot[i] = down[i] = 0;\n        rep(i,N){\n            int D; cin >> D;\n            carrot[D] = 1;\n        }\n        int have = 0;\n        double ans = 0;\n        int rem = 0;\n        rep(i,L){\n            if(rem) ans += 1./V;\n            else ans += 1./U;\n            if(rem) rem--;\n            if(have && !rem){\n                have--;\n                rem = V*T;\n            }\n            if(carrot[i]){\n                if(!rem){\n                    carrot[i]--;\n                    rem = V*T;\n                }\n                if(have + carrot[i] > K){\n                    carrot[i]--;\n                    rem = V*T;\n                    have = K;\n                } else {\n                    have+=carrot[i];\n                }\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\n\nint main(){\n    int n,k,t,u,v,l;cin >> n >> k >> t >> u >> v >> l;\n    vector<int> d(n);\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n    d.pb(l);\n    double T=0;\n    int L=0,K=0,s=0;\n    while(L<l){\n        if(K*v+L>=l){\n            T+=1.*(l-L)/v;\n            break;\n        }\n        if(K==0){\n            T+=1.*(d[s]-L)/u;\n            L=d[s];\n            s++;\n            K++;\n        }\n        else{\n            K--;\n            while(1){\n                if(d[s]>L+v*t){\n                    if(L+v*t>=l){\n                        L=l;\n                        T+=1.*(l-L)/v;\n                        break;\n                    }\n                    else{\n                        T+=t;\n                        L+=v*t;\n                        break;\n                    }\n                }\n                if(s==n){\n                    T+=1.*(l-L)/v;\n                    cout <<setprecision(10)<<fixed<< T << endl;\n                    return 0;\n                }\n                if(K==k){\n                    T+=1.*(d[s]-L)/v;\n                    L=d[s];\n                    break;\n                }\n                s++;\n                K++;\n            }\n        }\n    }\n    cout <<setprecision(10) << fixed << T << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,K,T,U,V,L;\nqueue<int>C;\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tC.push(t);\n\t}\n\tC.push(L);//goal\n\n\tint c=0,f=0,p=0;\n\tdouble t=0,tmp=0;\n\twhile(!C.empty()||tmp>p)\n\t{\n\t\tif(tmp<=p)\n\t\t{\n\t\t\ttmp=C.front();C.pop();\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tp+=T*V;\n\t\t\tt+=T;\n\t\t\twhile(!C.empty())\n\t\t\t{\n\t\t\t\tc++;\n\t\t\t\tif(c>K)\n\t\t\t\t{\n\t\t\t\t\tint nr=T*V-(p-tmp);\n\t\t\t\t\tc=K;\n\t\t\t\t\tp+=nr;\n\t\t\t\t\tt+=1.0*nr/V;\n\t\t\t\t}\n\t\t\t\ttmp=C.front();\n\t\t\t\tC.pop();\n\t\t\t\tif(tmp>p)break;\n\t\t\t}\n\t\t\tif(c==0)f=0;\n\t\t\telse c--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt+=(1.0*tmp-p)/U;\n\t\t\tp=tmp;\n\t\t\tf=1;\n\t\t}\n\t}\n\tif(p>L)t-=(1.0*p-L)/V;\n\tprintf(\"%.10f\\n\",t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-12\n\nstruct Node {\n\tdouble t;\n\tdouble rest;\n\tint x;\n};\n\nbool operator >(Node& n1, Node& n2) {\n\treturn n1.t > n2.t;\n}\n\ntypedef long long ll;\n\nint main() {\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<int> d(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> d[i];\n\t}\n\td.push_back(L);\n\n\tll rest = 0;\n\tint x = 0;\n\tll vl = 0, ul = 0;\n\tfor (int i = 0; i < N+1; ++i) {\n\t\tint dx = d[i]-x;\n\t\tif (rest >= dx) {\n\t\t\tvl += dx;\n\t\t\trest -= dx;\n\t\t}\n\t\telse {\n\t\t\tvl += rest;\n\t\t\tul += dx-rest;\n\t\t\trest = 0;\n\t\t}\n\n\t\trest += (ll)T * V;\n\t\tif (rest >= (ll)K * (T + 1) * V) rest = (ll)K * (T + 1) * V;\n\n\t\tx = d[i];\n\t}\n\tprintf(\"%.10f\\n\", (double)vl/V + (double)ul/U);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\nint main(void){\n    int N, K, T, U, V, L, D;\n    int pre_D, old_D;\n    double t;\n    int ac_l, ac_dis, no_l, s;\n    cin >> N >> K >> T >> U >> V >> L;\n    ac_l = ac_dis = V * T;\n    cin >> D;\n    no_l = pre_D = D;\n    for(int i = 1; i < N; i++){\n        cin >> D;\n        if(pre_D - D > 0 && (pre_D - D) / ac_dis >= K-1){\n            no_l += (D - old_D);\n            ac_l -= (D - old_D);\n        }\n        old_D = D;\n        if((s = D - pre_D - ac_dis) > 0)\n            no_l += s;\n        else\n            D -= s;\n        ac_l += ac_dis;\n        pre_D = D;\n    }\n    if((s = L - no_l - ac_l) > 0)\n        no_l += s;\n    t = (double)no_l / U + ((double)L - no_l) / V;\n    cout << fixed << setprecision(10) << t << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nint main(){\n    int n;\n    double k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n\n    double c[205];\n    rep(i,n) cin >> c[i];\n    c[n] = l;\n\n    double m, h, s; //?????¨???????????????????????°????????????????????????\n    double time = 0;\n    int i = 0;\n    while(m < l){\n        double next = c[i] - m;\n        if((h > 0 && s < EPS) || h > k){\n            h--;\n            s = t;\n        }else if(h == 0 && s < EPS){\n            time += next / u;\n            m += next;\n            i++;\n            h++;\n        }else if(s > EPS){\n            if(next / v <= s){\n                s -= next / v;\n                time += next / v;\n                m += next;\n                i++;\n                h++;\n            }else{\n                m += s * v;\n                time += s;\n                s = 0;\n            }\n        }\n    }\n    cout <<fixed << setprecision(8) <<  time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define INF 1<<30\n#define EPS 1e-8\n#define mp make_pair\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<pair<int, double>, pair<double, int> > state;\n\nint main() {\n\tint n, k, l;\n\tdouble t, u, v;\n\tcin >> n >> k >> t >> u >> v >> l;\n\n\tbool d[100005];\n\tmemset(d, 0, sizeof(d));\n\n\trep(i, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\td[x] = true;\n\t}\n\n\t// ??????i, ????????§?????????t, ????????????T, ?????£???????????????\n\tqueue<state> que;\n\tque.push(mp(mp(0, 0), mp(0, 0)));\n\n\tmap<state, bool> memo;\n\n\tdouble ans = INF;\n\n\twhile(que.size()) {\n\t\tstate s = que.front(); que.pop();\n\t\tint cur = s.first.first;\n\t\tdouble res = s.first.second;\n\t\tdouble time = s.second.first;\n\t\tint cnt = s.second.second;\n\n\t\tif(cur >= l) {\n\t\t\tans = min(ans, res);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(d[cur]) {\n\t\t\tcnt = min(k, cnt + 1);\n\t\t}\n\n\t\tif(equals(time, 0.0)) {\n\t\t\tif(cnt > 0) {\n\t\t\t\tcnt--;\n\t\t\t\ttime = t;\n\t\t\t}\n\t\t}\n\n\t\tif(time > EPS) {\n\t\t\tstate next = mp( mp(cur + 1, res + (1.0 / v) ), mp(time - (1.0 / v), cnt) );\n\n\t\t\tif(!memo[next]) {\n\t\t\t\tmemo[next] = true;\n\t\t\t\tque.push(next);\n\t\t\t}\n\n\t\t\tif(cnt > 0) {\n\t\t\t\tstate next2 = mp( mp(cur + 1, res + (1.0 / v)), mp(t, cnt - 1) );\n\t\t\t\tif(!memo[next2]) {\n\t\t\t\t\tmemo[next2] = true;\n\t\t\t\t\tque.push(next2);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstate next = mp( mp(cur + 1, res + (1.0 / u)), mp(0.0, cnt));\n\n\t\t\tif(!memo[next]) {\n\t\t\t\tmemo[next] = true;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << fixed;\n\tcout.precision(10);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,K,T,U,V,L;\nint D[222];\nsigned main(){\n    cin>>N>>K>>T>>U>>V>>L;\n    rep(i,N)cin>>D[i];\n\n    int cur=0;\n    double en=0.0,ans=0.0;\n    rep(i,L){\n        if(D[cur]==i){\n            cur++;\n            en+=T;\n            chmin(en,1.0*(K+1)*T);\n        }\n        if(en*V>=1){\n            en-=1.0/V;\n            ans+=1.0/V;\n        }\n        else{\n            ans+=en+(1.0-en*V)/U;\n            en=0.0;\n        }\n    }\n    printf(\"%.20f\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int N, K, T, U, V, L, D;\n    int pre_D, old_D;\n    double t;\n    int ac_l, ac_dis, no_l, s;\n    cin >> N >> K >> T >> U >> V >> L;\n    ac_l = ac_dis = V * T;\n    cin >> D;\n    no_l = pre_D = D;\n    for(int i = 1; i < N; i++){\n        cin >> D;\n        if(pre_D - D > 0 && (pre_D - D) / ac_dis >= K-1){\n            no_l += (D - old_D);\n            ac_l -= (D - old_D);\n        }\n        old_D = D;\n        if((s = D - pre_D - ac_dis) > 0)\n            no_l += s;\n        else\n            D -= s;\n        ac_l += ac_dis;\n        pre_D = D;\n    }\n    if((s = L - no_l - ac_l) > 0)\n        no_l += s;\n    t = (double)no_l / U + ((double)L - no_l) / V;\n    cout << t << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\nint n,k,t,u,v,l,d[222];\nmain()\n{\n\tcin>>n>>k>>t>>u>>v>>l;\n\tfor(int i=0;i<n;i++)cin>>d[i];\n\tint id=0;\n\tdouble ans=0,p=0;\n\tfor(int i=0;i<l;i++)\n\t{\n\t\tif(d[id]==i)\n\t\t{\n\t\t\tid++;\n\t\t\tp=min(p+t,(k+1.)*t);\n\t\t}\n\t\tif(p*v<1.0)\n\t\t{\n\t\t\tans+=p+(1.0-p*v)/u;\n\t\t\tp=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=1.0/v;\n\t\t\tp-=1.0/v;\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(9)<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i, j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n        cout << i << \" \" << dd << \" \" << endl;\n    }\n    cout << dd <<endl;\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint main() {\n\tcout << fixed << setprecision(9);\n\tint n, k; ld t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tld d[202];\n\td[0] = 0;\n\trep1(i, n) {\n\t\tcin >> d[i];\n\t}\n\td[n+1] = l;\n\tld time = 0; int poss = 0; ld restime = 0;\n\trep(i, n+1) {\n\t\tld dis = d[i + 1] - d[i];\n\t\tif (dis < v*restime) {\n\t\t\trestime -= dis / v;\n\t\t\ttime += dis / v;\n\t\t}\n\t\telse {\n\t\t\tdis -= v * restime; time += restime;\n\t\t\tint cnt = (int)(dis / v * t);\n\t\t\tif (cnt + 1 <= poss) {\n\t\t\t\tposs -= cnt+1;\n\t\t\t\tdis -= (double)cnt*v*t;\n\t\t\t\trestime = t - dis / v;\n\t\t\t\ttime += (double)cnt*t;\n\t\t\t\ttime += dis / v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdis -= (double)poss*v*t;\n\t\t\t\trestime = 0;\n\t\t\t\ttime += (double)poss*t;\n\t\t\t\ttime += dis / u; poss = 0;\n\t\t\t}\n\t\t}\n\t\tif (poss +1 <= k) {\n\t\t\tposs++;\n\t\t}\n\t\telse {\n\t\t\trestime = t;\n\t\t}\n\t\tif (restime == 0) {\n\t\t\trestime = t; poss--;\n\t\t}\n\t}\n\tcout << time << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\nint N, K, T, U, V, L;\nint D[200], DL[10001];\n\nint main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    for (int i = 0; i < N; i++) {\n        cin >> D[i];\n        DL[D[i]]++;\n    }\n    double su = 1. / U;\n    double sv = 1. / V;\n\n    vector<bool> used(L+1, false);\n    int count = 0;\n    bool flag = false;\n    int start;\n    for (int i = 0; i < L; i++) {\n        if (DL[i] > 0) count++;\n        if (flag) {\n            if (count > K) start = i, count = K;\n            used[i] = true;\n        } else {\n            if (count > 0) {\n                used[i] = true;\n                flag = true;\n                start = i;\n                count--;\n            }\n        }\n\n        if (flag && start + V * T == i + 1) {\n            flag = false;\n        }\n    }\n\n    double ans = 0;\n    for (int i = 0; i < L; i++) {\n        ans += used[i] ? sv : su;\n    }\n    printf(\"%.10f\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nint main() {\n    cout << fixed << setprecision(8);\n    ll N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    double ans = 0;\n    int num = 0;\n    double rem = 0;\n    double prev = 0;\n    int D;\n    for (int i = 0; i < N; i++) {\n        cin >> D;\n        double dash = T * V * num + rem;\n        //cout << dash << endl;\n        if (dash <= D - prev + eps) {\n            ans += dash / V;\n            ans += ((D - prev) - dash) / U;\n            num = 0;\n            rem = T * V;\n            //cout << \"aaa\" << endl;\n        } else {\n            ans += (D - prev) / V;\n            if (D - prev <= rem + eps) {\n                rem -= D - prev;\n                num++;\n                if (num > K) {\n                    num = K;\n                    rem = T * V;\n                }\n                //cout << \"bbb\" << endl;\n            } else {\n                double diff = D - prev - rem;\n                int usenum = 0;\n                for (int j = 1; j <= num; j++) {\n                    double d = j * T * V;\n                    if (d >= diff + eps) {\n                        usenum = j;\n                        break;\n                    }\n                }\n                rem = usenum * T * V - diff;\n                num -= usenum;\n                num++;\n                if (num > K) {\n                    num = K;\n                    rem = T * V;\n                }\n                //cout << \"ccc\" << endl;\n            }\n        }\n        prev = D;\n        //cout << ans << \" \" << num << \" \" << rem << endl;\n    }\n    double last = L - prev;\n    double lastdash = T * V * num + rem;\n    if (lastdash <= last + eps) {\n        ans += lastdash / V;\n        ans += (last - lastdash) / U;\n    } else {\n        ans += last / V;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <math.h>\n#include <utility>\n#include <queue>\n#include <stdio.h>\n#define INF 1000000007\nusing namespace std;\n\n\nint main(){\n    int N,K,T,U,V,L;\n    vector<int> d(N);\n    cin >> N >> K >> T >> U >> V >> L;\n    for (int i=0; i<N ;i++) {\n        cin >> d[i];\n    }\n    int k=0;\n    long double len=0;\n    long double time=0;\n    int flag=0;\n    while (1) {\n        if (k>0) {\n            //cout << 1 << endl;\n            k--;\n            if (len + T*V >= L) {\n                time += (L-len)/V;\n                break;\n            }else{\n              //  cout <<2<<endl;\n                time+=T;\n                len+=T*V;\n                for (int i=flag; i<N && d[i]< len; i++) {\n                    k++;\n                    flag=i+1;\n                    if(k>K){\n                        len -=T*V;\n                        time = time -T + static_cast<double>(d[i]-len)/V;\n                        len  = d[i];\n                        break;\n                    }\n                //    cout << 3 <<endl;\n                }\n            }\n        }\n        if (k==0) {\n            //cout << \"(\"<<len<<\",\"<<time<<\")\" << endl;\n            if (flag<N){\n                long double ll = static_cast<long double>(d[flag]-len);\n                time += ll / static_cast<long double>(U);\n                len = d[flag];\n                flag++;\n            }else{\n                time += static_cast<long double>(L-len)/U;\n                break;\n            }\n            if (len + T*V >= L) {\n                time += (L-len)/V;\n                break;\n            }else{\n              //  cout << 5 << endl;\n                time+=T;\n                len+=T*V;\n                //cout << \"(\"<<len<<\",\"<<time<<\")\" << endl;\n                for (int i=flag; i<N&&d[i]<len; i++) {\n                  //  cout << 6<< endl;\n                    k++;\n                    flag=i+1;\n                    if(k>K){\n                        len -= T*V;\n                        time = time -T + static_cast<double>(d[i]-len)/V;\n                        len = d[i];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%.9Lf\\n\",time);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nint N, K, T, U, V, L, D[200];\n\nint main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    for (int j = 0; j < N; ++j) cin >> D[j];\n\n    int boosts = 0;\n    int r = L;\n    for (int j = N-1; j >= 0; --j) {\n        int nr = max(D[j], r-V*T);\n        if (j+K < N && D[j+K] < nr) {\n            boosts -= nr - D[j+K];\n            nr = D[j+K];\n        }\n        r = nr;\n    }\n    boosts += L - r;\n\n    printf(\"%.12f\\n\", (double)boosts / V + (double)(L - boosts) / U);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\nusing namespace std;\n\nint N, K;\ndouble T, U, V, L;\ndouble pos[200];\n\nint main() {\n\tcin >> N >> K >> T >> U >> V >> L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pos[i];\n\t}\n\n\tdouble now = 0;\n\tdouble ans = 0;\n\t//まずは最初のニンジンまで進める。\n\tans = pos[0] / U;\n\tnow = pos[0];\n\tdouble nokori = T;\n\tint ninjinstock = 0;\n\tint ninjinidx = 1;\n\t//にんじんが二つある前提で、以下の実装を行ってる。\n\tif (N >= 2) {\n\t\twhile (1) {\n\t\t\twhile (ninjinidx < N && nokori >= (pos[ninjinidx] - now) / V) {\n\t\t\t\t//最後のニンジンまで到達しておらず、次のニンジンまで行ってもブーストが切れないとき\n\n\t\t\t\tif (ninjinstock < K) {\n\t\t\t\t\t//ニンジンが貯蔵できる場合は、貯蔵する。\n\t\t\t\t\tninjinstock++;\n\t\t\t\t\tnokori -= (pos[ninjinidx] - now) / V;\n\t\t\t\t\tans += (pos[ninjinidx] - now) / V;\n\t\t\t\t\tnow = pos[ninjinidx];\n\t\t\t\t\tninjinidx++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//ニンジンがもうこれ以上持てない場合は、即使用して残りブースト時間をTに戻す。\n\t\t\t\t\tans += (pos[ninjinidx] - now) / V;\n\t\t\t\t\tnokori = T;\n\t\t\t\t\tnow = pos[ninjinidx];\n\t\t\t\t\tninjinidx++;\n\t\t\t\t};\n\t\t\t}\n\t\t\t//ニンジンがもう残ってないときは、ゴールまで走るだけ\n\t\t\tif (ninjinidx == N) {\n\t\t\t\tif ((nokori + T * (double)ninjinstock)>= (L - now) / V) {\n\t\t\t\t\t//残りの持ってるすべてのストックを使って、ブースト中にゴールできる場合\n\t\t\t\t\tans += (L - now) / V;\n\t\t\t\t\tnow = L;;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//上の条件で、ゴールできない場合\n\t\t\t\t\tans += ((nokori + T * (double)ninjinstock) + \n\t\t\t\t\t\t(L - now - (nokori + (double)ninjinstock * T) * V) / U);\n\t\t\t\t\tnow = L;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t//ここまで残ってるというのは、次のニンジンに到達するにはブースト時間が足りない時なので、そこを処理する。\n\t\t\tans += nokori;\n\t\t\tnow += nokori * V;\n\t\t\tnokori = 0;\n\t\t\t//次のニンジンんまで走らせておく\n\t\t\t//持ってるニンジンがあるのなら、そこで使ってブーストをする\n\t\t\tif (ninjinstock == 0) {\n\t\t\t\t//一本もニンジンのストックがない場合\n\t\t\t\tans += (pos[ninjinidx] - now) / U;\n\t\t\t\tnow = pos[ninjinidx];\n\t\t\t\tninjinidx++;\n\t\t\t\tnokori = T;\n\t\t\t\t\n\t\t\t}else {\n\t\t\t\t//ストックがあるときは使う\n\t\t\t\tnokori = T;\n\t\t\t\tninjinstock--;\n\t\t\t}\n\n\t\t}\n\tend:;\n\t\tcout << setprecision(12) << ans << endl;\n\t}\n\telse {\n\t\t//にんじんが一本しかない。\n\t\tif (nokori >= (L - now) / V) {\n\t\t\t//ブースト中にゴールできる場合\n\t\t\tans += (L - pos[N - 1]) / V;\n\t\t\tnow = L;\n\t\t}\n\t\telse {\n\t\t\t//ブースト中にゴールできない場合\n\t\t\tans += nokori + ((L - now - nokori * V) / U);\n\t\t\tnow = L;\n\t\t}\n\t\tcout << setprecision(12) << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\nint N,K,T,v1,v2,L;\nint D[220];\ndouble ans;\nint now;\ndouble up;\nint yorn;\nint have;\n\n\nint main(){\n\tcin >> N >> K >> T >> v1 >> v2 >> L;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> D[i];\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(yorn==0){\n\t\t\tans += 1.0*(D[i]-now)/v1;\n\t\t\tup = D[i] + T*v2;\n\t\t\tnow = D[i];\n\t\t\tyorn = 1;\n\t\t}\n\t\telse if(yorn==1){\n\t\t\tif(D[i]>up){\n\t\t\t\twhile(D[i]>up && have>0){\n\t\t\t\t\thave --;\n\t\t\t\t\tup += T*v2;\n\t\t\t\t}\n\t\t\t\tif(D[i]>up){\n\t\t\t\t\tans += 1.0*(up-now)/v2;\n\t\t\t\t\tans += 1.0*(D[i]-up)/v1;\n\t\t\t\t\tyorn = 0;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(D[i]<up){\n\t\t\t\tif(have==K){\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\tup = D[i] + T*v2;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\thave++;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\tup = D[i] + T*v2;\n\t\t\t\tnow = D[i];\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\twhile(have>0){\n\t\thave --;\n\t\tup += T*v2;\n\t}\n\tif(L > up){\n\t\tans += 1.0*(up-now)/v2;\n\t\tans += 1.0*(L-up)/v1;\n\t}\n\telse{\n\t\tans += 1.0*(L-now)/v2;\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_carrots;\n  int carrot_store_ability;\n  int power_up_duration;\n  int normal_speed;\n  int power_up_speed;\n  int goal_distance;\n  while(~scanf(\"%d %d %d %d %d %d\",\n\t       &total_carrots,\n\t       &carrot_store_ability,\n\t       &power_up_duration,\n\t       &normal_speed,\n\t       &power_up_speed,\n\t       &goal_distance)){\n\n    bool carrots[201];\n    memset(carrots,false,sizeof(carrots));\n\n    for(int carrot_idx=0;carrot_idx< total_carrots; carrot_idx++){\n      int distance;\n      scanf(\"%d\",&distance);\n      carrots[distance] = true;\n    }\n\n    int current_pos = 0;\n\n    int current_carrots = 0;\n    int life = 0;\n\n    int high_speed_interval =0;\n    for(int pos=0;pos< goal_distance; pos++,life--){\n      if(carrots[pos]){\n\tcurrent_carrots++;\n      }\n\n      if((life <= 0 && current_carrots > 0)\n\t || (current_carrots > carrot_store_ability)){\n\tcurrent_carrots--;\n\tlife = power_up_duration * power_up_speed;\n      }\n\n      if(life > 0){\n\thigh_speed_interval++;\n      }\n    }\n\n    printf(\"%.9lf\\n\",(double)high_speed_interval/(double)power_up_speed\n\t   + (double)(goal_distance - high_speed_interval)/(double)normal_speed);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tdouble n, k, t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tqueue<int> d;\n\tREP(i, n)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\td.push(a);\n\t}\n\tint car = 0;\n\tint run = 0;\n\tint walk = 0, running = 0;\n\n\tFOR(i, 1, l + 1)\n\t{\n\t\tif (!d.empty() && d.front() == i)\n\t\t{\n\t\t\td.pop();\n\t\t\tif (run == 0) run += t*v;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (car < k) car++;\n\t\t\t\telse run = t*v;\n\t\t\t}\n\t\t}\n\n\t\tif (run == 0 && car>0)\n\t\t{\n\t\t\tcar--;\n\t\t\trun = t*v;\n\t\t}\n\n\t\tif (run > 0)\n\t\t{\n\t\t\trunning++;\n\t\t\trun--;\n\t\t}\n\t\telse walk++;\n\n\n\t}\n\n\tcout << D10 << running / v + walk / u << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  double lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k>0&&l>vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  double ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=0;i<L;i++){\n    ans+=1.00/lv[i];\n  }\n  printf(\"%.10lf\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  double lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  double ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=0;i<L;i++){\n    ans+=1.00/lv[i];\n  }\n  printf(\"%.10lf\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint D[300];\n\nsigned main()\n{\n    int N, K, T, U, V, L;\n\n    scanf(\"%d%d%d%d%d%d\", &N, &K, &T, &U, &V, &L);\n\n    for (int i = 0; i < N; ++i) scanf(\"%d\", D + i);\n\n    double t = 0.0, d = 0;\n    int idx = 0, carrot = 0;\n\n    D[N] = L;\n\n    while (idx <= N) {\n        if (carrot == 0) {\n            t += 1. * (D[idx] - d) / U;\n            d = D[idx];\n            carrot += 1;\n        } else {\n            if (d + T * V * carrot < D[idx]) {\n                t += T * carrot;\n                d += T * V * carrot;\n                t += 1. * (D[idx] - d) / U;\n                d = D[idx];\n                carrot = 1;\n            } else {\n                if (carrot == K + 1) {\n                    t += 1. * (D[idx] - d) / V;\n                    d = D[idx];\n                } else {\n                    int nxidx = (upper_bound(D, D + N + 1, d + T * V) - 1) - D;\n                    carrot = max(carrot + (nxidx - idx), K);\n                    t += 1. * (D[nxidx] - d) / V;\n                    d = D[nxidx];\n                    idx = nxidx;\n                }\n            }\n        }\n\n        idx++;\n    }\n\n    printf(\"%.10f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\ntypedef vector<int> vi;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\n\nint main()\n{\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\t//vi D(N); rep(i, 0, N) cin >> D[i];\n\tvi D(L + 1, 0);\n\trep(i, 0, N) { int d; cin >> d; D[d]++; }\n\n\tdouble ans = 0;\n\tint have = 0;\n\tint speedup = -1;\n\trep(i, 1, L+1)\n\t{\n\t\tif (i < speedup)\n\t\t\tans += 1.0 / V;\n\t\telse if (i == speedup)\n\t\t{\n\t\t\tspeedup = -1;\n\t\t\tans += 1.0 / V;\n\t\t}\n\t\telse\n\t\t\tans += 1.0 / U;\n\n\t\tif (D[i] == 1)\n\t\t{\n\t\t\tif (have == K)\n\t\t\t{\n\t\t\t\tspeedup = i + T*V;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thave++;\n\t\t\t}\n\t\t}\n\n\t\tif (speedup < 0 && 0 < have)\n\t\t{\n\t\t\thave--;\n\t\t\tspeedup = i + T*V;\n\t\t}\n\t}\n\n\tprintf(\"%.10f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_L 10005\nint N,K,T,L;\nint A[MAX_L];\ndouble U,V;\n\nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    A[a]=1;\n  }\n\n  \n  int p=0,cnt=0,cost=0,costb=0;\n  for(int i=0;i<L;i++){\n    \n    cnt+=A[i];\n    \n    if(i>=p){\n      if(cnt>0){\n        cnt--;\n        int d=T*V;\n        d=min(d,L-i);\n        p=i+d;\n        costb++;\n      }else{\n        cost++;\n      }\n    }else{\n      costb++;\n    }\n    \n    if(cnt>K){\n      int d=T*V;\n      d=min(d,L-i);\n      p=i+d;\n    }\n    \n    cnt=min(cnt,K);\n  }\n  \n\n  printf(\"%.8f\\n\",cost/U+costb/V);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\t\n\tqueue<int> q;\n\tfor(int i=0; i<N; i++){\n\t\tint pos;\n\t\tcin >> pos;\n\t\tq.push(pos);\n\t}\n\t\n\tint stock = 0;\n\tint nowpos = 0;\n\tdouble time = 0;\n\twhile(1){\n\t\tif(stock==0){\n\t\t\tif(!q.empty() && nowpos+U >= q.front()){\n\t\t\t\ttime += (q.front()-nowpos)/(double)U;\n\t\t\t\tnowpos = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tstock++;\n\t\t\t}else if(nowpos+U >= L){\n\t\t\t\ttime += (L-nowpos)/(double)U;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime +=\t1;\n\t\t\t\tnowpos += U;\n\t\t\t}\n\t\t}else{\n\t\t\tstock--;\n\t\t\tif(nowpos+T*V >= L){\n\t\t\t\ttime += (L-nowpos)/(double)V;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime += T;\n\t\t\t\tnowpos += T*V;\n\t\t\t\tint last;\n\t\t\t\twhile(!q.empty() && nowpos >= q.front()){\n\t\t\t\t\tstock++;\n\t\t\t\t\tlast = q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t\tif(stock > K){\n\t\t\t\t\tstock = K+1;\n\t\t\t\t\ttime -= (nowpos-last)/(double)V;\n\t\t\t\t\tnowpos = last;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << fixed;\n\tcout << setprecision(10);\n\tcout << time << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint main(){\n\tint n,k,t,u,v,l;\n\tbool is[10000]={};\n\tdouble eps=1e-9;\n\tcin>>n>>k>>t>>u>>v>>l;\n\trep(i,n){\n\t\tint d;\n\t\tcin>>d;\n\t\tis[d]=1;\n\t}\n\tdouble ans=0;\n\tint now=0;\n\tdouble lt=0;\n\trep(i,l){\n\t\tif(lt<eps && now>0) now--,lt=t;\n\t\tif(is[i]){\n\t\t\tif(now<k) now++;\n\t\t\telse lt=t;\n\t\t}\n\t\tif(lt<eps && now>0) now--,lt=t;\n\t\tif(lt>eps*100) lt-=1.0/v,ans+=1.0/v;\n\t\telse ans+=1.0/u;\n\t}\n\tprintf(\"%.9f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nint main() {\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<ld>diss;\n\tdiss.push_back(0);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint D; cin >> D;\n\t\tdiss.push_back(D);\n\t}\n\tdiss.push_back(L);\n\n\tld resttime = 0;\n\tint restcarrot = 0;\n\tld ans = 0;\n\t\n\tfor (int i = 0; i < diss.size()-1; ++i) {\n\t\tld dis = diss[i + 1] - diss[i];\n\t\tif (dis > (resttime+restcarrot*T)*V) {\n\t\t\tld needtime = (resttime + restcarrot*T)+(dis- (resttime + restcarrot*T)*V)/U;\n\t\t\tans += needtime;\n\t\t\tresttime = T;\n\t\t\trestcarrot = 0;\n\t\t}\n\t\telse {\n\t\t\tld needtime = dis / V;\n\t\t\tresttime = resttime + restcarrot*T - needtime;\n\t\t\trestcarrot = resttime / K;\n\t\t\tresttime -= restcarrot*T;\n\t\t\tans += needtime;\n\t\t\tif (restcarrot == K) {\n\t\t\t\tresttime = T;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trestcarrot++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(22) << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l,d[210]={};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  long long a=0,p=0;\n  for(int i=1;i<=n+1;i++){\n    if(a>d[i]-d[i-1]){\n      a-=d[i]-d[i-1];\n      a=(a+v*t,v*t*(k+1));\n    }\n    else p+=d[i]-d[i-1]-a,a=v*t;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T & a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, k, t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tvi d(n);\n\tREP(i, n)cin >> d[i];\n\tvl b(l, 0);\n\tREP(i, n)b[d[i]] = 1;\n\tint time = 0, cnt = 0;\n\tdouble ans = 0;\n\tREP(i, l) {\n\t\tif (time == 0) {\n\t\t\tif (cnt > 0) {\n\t\t\t\tcnt--;\n\t\t\t\ttime = t * v;\n\t\t\t\tif (b[i])cnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[i])time = t * v;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (b[i]) {\n\t\t\t\tif (cnt == k)time = t * v;\n\t\t\t\telse cnt++;\n\t\t\t}\n\t\t}\n\t\tif (time > 0) {\n\t\t\tans += 1.0 / v;\n\t\t\ttime--;\n\t\t}\n\t\telse {\n\t\t\tans += 1.0 / u;\n\t\t}\n\t}\n\tcout << setprecision(12) << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k, l;\ndouble t, u, v;\nbool f[10010];\n\nint main()\n{\n\tcin >> n >> k >> t >> u >> v >> l;\n\tfor (int i = 0; i < n; i++){\n\t\tint d;\n\t\tcin >> d;\n\t\tf[d] = true;\n\t}\n\t\n\tdouble res = 0.0;\n\tdouble r = 0.0;\n\tfor (int i = 0; i < l; i++){\n\t\tif (f[i]) r = min(r + t, t * (k + 1));\n\t\tif (r <= 1.0 / v){\n\t\t\tres += r;\n\t\t\tres += (1.0 - r * v) / u;\n\t\t\tr = 0.0;\n\t\t}\n\t\telse {\n\t\t\tres += 1.0 / v;\n\t\t\tr -= 1.0 / v;\n\t\t}\n\t}\n\n\tprintf(\"%.20f\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int MAX_L = 10000;\n\nint N, K, T, U, V, L;\nbool carrots[MAX_L + 1];\n\ndouble solve(){\n\tint cs = 0, boost_stop = 0;\n\tdouble time = 0;\n\n\tfor(int p=0; p<L; p++){\n\t\tif(carrots[p]){\n\t\t\tcs++;\n\t\t}\n\t\tif(cs == K + 1 || (cs > 0 && boost_stop <= p) ){\n\t\t\tcs--;\n\t\t\tboost_stop = p + T * V;\n\t\t}\n\n\t\ttime += 1.0 / (p < boost_stop ? V : U);\n\t}\n\n\treturn time;\n}\n\nint main(){\n\tscanf(\"%d%d%d%d%d%d\",&N, &K, &T, &U, &V, &L);\n\tfor(int i=0; i<N; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tcarrots[x] = true;\n\t}\n\n\tprintf(\"%.10f\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n,k,t,u,v,l;\n  cin >> n >> k >> t >> u >> v >> l;\n  k=(k+1)*v*t;\n  vector<int> d;\n  d.assign(l+10,0);\n  REP(i,n){\n    int tmp;\n    cin >> tmp;\n    d[tmp]++;\n  }\n  vector<int> dp;\n  dp.resize(l+10);\n  dp[0]=0;\n  int speed;\n  REP(i,l){\n    dp[i]+=d[i]*v*t;\n    dp[i]=min(dp[i],k);\n    dp[i+1]=max(0,dp[i]-1);\n    if(dp[i]) speed++;\n  }\n  cout << fixed << 1.0*speed/v + 1.0*(l-speed)/u << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() \n{\n\tint N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tint d[202];\n\t\n\td[0] = 0;\n\tfor(int i=1;i<N+1;i++){\tcin >> d[i];}\n\td[N+1] = L;\n\t\n\tint dis(0); //速度Uで走らなければいけない距離\n\tint l(0); //速度Vで走れる残距離\n\tint k(0); //ニンジンを持っている個数\n\t\n\tfor(int i=0 ; i < N+1 ; i++)\n\t{\n\t\t//地点i~i+1までの走りかたを判定\n\t\tif((d[i+1]-d[i]) >= (l + k*T*V)){\n\t\t\tdis += (d[i+1]-d[i]) - l - k*T*V;\n\t\t\tl = 0;\n\t\t\tk = 0;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tk = (-(d[i+1]-d[i]) + (l + k*T*V))/(T*V);\n\t\t\tl = (-(d[i+1]-d[i]) + (l + k*T*V))%(T*V);\n\t\t}\n\t\t\n\t\t//地点i+1でのニンジンで初期化\n\t\tif(l==0){\n\t\t\tl = T*V;\n\t\t}else if(k==K){\n\t\t\tl = T*V;\n\t\t}else{\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tdouble ans = (double)dis/(double)U + (double)(L - dis)/(double)V;\n\tcout << fixed << setprecision(6) << ans << endl;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,c,x,a;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=true;\n  for(int i=0;i<l;i++){\n    if(s[i])\n      if(!x||k==c)x=v*t;\n      else c++;\n    else if(!x&&c>0)c--,x=v*t;\n    if(x>0)a++,x--;\n  }\n  printf(\"%.10f\\n\",a*1.0/v+(l-a)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nvector<int> carot(10010,0);\nint n,k,t,u,v,l,d;\n\n\nint main(){\n\tcin>>n>>k>>t>>u>>v>>l;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>d;\n\t\tcarot.at(d)+=1;\n\t}\n\tdouble ans=0;\n\tint boost_l=0;\n\tint normal_l=0;\n\tint haveNum=0;\n\tbool flag=false;\n\tint eat_num=0;\n\tint end_l=0;\n\tfor(int i=1; i<=l; i++){\n\t\tif(i==end_l)flag=false;\n\t\tif(carot.at(i)>0){\n\t\t\tif(!flag){\n\t\t\t\teat_num++;\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(haveNum<k)haveNum++;\n\t\t\t\telse {\n\t\t\t\t\teat_num++;\n\t\t\t\t\tend_l=i+v*t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!flag&&haveNum>0){\n\t\t\t\thaveNum--;\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t}\n\t\t}\n\t\tif(flag)boost_l++;\n\t\telse normal_l++;\n\t}\n\tprintf(\"%.9lf\\n\",(double)boost_l/v+(double)normal_l/u);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint main() {\n\tcout << fixed << setprecision(9);\n\tint n, k; ld t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tld d[202];\n\td[0] = 0;\n\trep1(i, n) {\n\t\tcin >> d[i];\n\t}\n\td[n+1] = l;\n\tld time = 0; int poss = 0; ld restime = 0;\n\trep(i, n+1) {\n\t\tld dis = d[i + 1] - d[i];\n\t\tif (dis < v*restime) {\n\t\t\trestime -= dis / v;\n\t\t\ttime += dis / v;\n\t\t}\n\t\telse {\n\t\t\tdis -= v * restime; time += restime;\n\t\t\tint cnt = (int)(eps+dis / (v * t));\n\t\t\tif (cnt + 1 <= poss) {\n\t\t\t\tposs -= cnt+1;\n\t\t\t\tdis -= (double)cnt*v*t;\n\t\t\t\trestime = t - dis / v;\n\t\t\t\ttime += (double)cnt*t;\n\t\t\t\ttime += dis / v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdis -= (double)poss*v*t;\n\t\t\t\trestime = 0;\n\t\t\t\ttime += (double)poss*t;\n\t\t\t\ttime += dis / u; poss = 0;\n\t\t\t}\n\t\t}\n\t\tif (poss +1 <= k) {\n\t\t\tposs++;\n\t\t}\n\t\telse {\n\t\t\trestime = t;\n\t\t}\n\t\tif (restime == 0) {\n\t\t\trestime = t; poss--;\n\t\t}\n\t}\n\tcout << time << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nint main() {\n  int N, K, T, U, V, L;\n  scanf(\"%d %d %d %d %d %d\", &N, &K, &T, &U, &V, &L);\n\n  std::vector<int> D(N+1, -1);\n  for (int i=0; i<N; ++i)\n    scanf(\"%d\", &D[i]);\n\n  std::vector<int> C(L+1);\n  int num_carrot=0, carrot_index=0, turbo=0;\n  for (int i=1; i<=L; ++i) {\n    if (i == D[carrot_index]) {\n      ++num_carrot;\n      ++carrot_index;\n      if (num_carrot > K) {\n        --num_carrot;\n        turbo = T * V;\n      }\n    }\n\n    if (num_carrot && !turbo) {\n      --num_carrot;\n      turbo = T * V;\n    }\n\n    if (turbo) {\n      --turbo;\n      C[i] = 1;\n    }\n  }\n\n  int v=std::count(C.begin(), C.end()-1, 1), u=L-v;\n  printf(\"%.12f\\n\", u*1.0/U+v*1.0/V);\n  return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  float lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  float ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=1;i<=L;i++){\n    if(lv[i]==v) continue;\n    else{\n      y=i-1;\n      if(v==V){ans+=(float)(y-x)/v;\n      h+=y-x;}\n      v=lv[i];\n      x=y;\n    }\n  }\n  ans+=(float)(L-h)/v;\n  printf(\"%f\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<set>\n#include<map>\n#define INF 999999\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint n, K, t, u, v, l;\n\nint d[210];\n\n//memo[i][j]:i番目(1オリジン)の人参置き場までj個の人参を持ったままたどり着く時間\ndouble memo[210][210];\n\nint main()\n{\n\tcin >> n >> K>> t >> u >> v >> l;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i];\n\t}\n\td[n + 1] = l;\n\n\tfor (int i = 0; i <= n+1; i++) {\n\t\tfor (int j = 0; j <= n+1; j++) {\n\t\t\tmemo[i][j] = INF;\n\t\t}\n\t}\n\tmemo[0][0] = 0;\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tint dist = d[i + 1] - d[i];\n\t\tint l;\n\t\tif (dist % (t*v) == 0)l = dist / (t*v);\n\t\telse l = dist / (t*v) + 1;\n\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tfor (int k = 0; k <= min(j + 1, l); k++) {\n\t\t\t\tif (j < K) {\n\t\t\t\t\tif (k < l)memo[i + 1][j + 1 - k] = min(memo[i + 1][j + 1 - k], memo[i][j] + k*t + (double)(dist - k*t*v) / (double)u);\n\t\t\t\t\telse memo[i + 1][j + 1 - k] = min(memo[i + 1][j + 1 - k], memo[i][j] + (double)dist / (double)v);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (k < l)memo[i + 1][j - k] = min(memo[i + 1][j - k], memo[i][j] + k*t + (double)(dist - k*t*v) / (double)u);\n\t\t\t\t\telse memo[i + 1][j - k] = min(memo[i + 1][j - k], memo[i][j] + (double)dist / (double)v);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = INF;\n\tfor (int i = 0; i <= K; i++) {\n\t\tans = min(ans, memo[n+1][i]);\n\t}\n\n\t/*\n\tfor (int i = 0; i <= n+1; i++) {\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tcout << memo[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tprintf(\"%.10f\\n\", ans);\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int N,K,T,U,V,L;\n    cin>>N>>K>>T>>U>>V>>L;\n    vector<int> D(N);\n    for(auto &d:D) cin>>d;\n    int ite=0;\n    int boost=0;\n    double ans=0;\n    int k=0;\n    for(int x=1;x<=L;x++){\n        ans+=(boost>0?1.0/V:1.0/U);\n        if(boost>0) boost-=1;\n        if(ite<N&&D[ite]==x){\n            if(boost>0&&k==K||boost==0){\n                boost=V*T;\n            }else{\n                k++;\n            }\n            ite++;\n        }else if(boost==0&&k>0){\n            boost=V*T;\n            k--;\n        }\n    }\n    cout<<fixed;\n    cout.precision(9);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint n, k, t, u, v, l;\nint d[10000];\nint c[10000];\nint s[10000];\n\nint main(){\n    cin >> n >> k >> t >> u >> v >> l;\n\n    REP(i, l){\n        c[i] = 0; \n        d[i] = 0;\n    }\n    REP(i, n){\n        int di;\n        cin >> di;\n        d[di] = 1;\n    }\n\n    REP(i, l){\n        int g = min(i+v*t, l);\n        if(d[i]==1 && s[i]==1){\n            if(c[i]+1<=k){\n                for(int j=i; j<l; j++){\n                    c[j] = c[j] + 1;\n                }\n            } else {\n                for(int j=i; j<g; j++){\n                    s[j] = 1;\n                }\n            }\n        } else if(d[i]==1 && s[i]==0){\n            for(int j=i; j<g; j++){\n                s[j] = 1;\n            }\n        } else if(d[i]==0 && s[i]==1){\n            continue;\n        } else {\n            if(c[i]>0){\n                for(int j=i; j<g; j++){\n                    s[j] = 1;\n                }\n                for(int j=i; j<l; j++){\n                    c[j] = c[j] - 1;\n                }\n            }\n        }\n    }\n\n    int normal = 0;\n    int accel = 0;\n    REP(i, l){\n        if(s[i] == 0){\n            normal += 1;\n        } else {\n            accel += 1;\n        }\n    }\n\n    double output = (double)normal/u + (double)accel/v;\n    cout << fixed << setprecision(7) << output << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint a, b, c, d, e, f, g;\nint remain;\nint speed;\nint x[10000000];\ndouble res;\nint main() {\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor (int i = 0; i < a; i++) {\n\t\tcin >> g;\n\t\tx[g] = 1;\n\t}\n\tfor (int i = 0; i < f; i++) {\n\t\tif (x[g] == true) {\n\t\t\tif ((remain + c - 1) / c < b) {\n\t\t\t\tremain++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg = (c - (remain%c));\n\t\t\t\tif (g == c) { g = 0; }\n\t\t\t\tremain += g;\n\t\t\t}\n\t\t}\n\t\tif (remain > 0) {\n\t\t\tspeed++;\n\t\t\tremain--;\n\t\t}\n\t}\n\tres = (1.0*f / d) + (1.0*speed / (e - d));\n\tcout << setprecision(15) << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,k,t,u,v,l;\n  cin >> n >> k >> t >> u >> v >> l;\n  int d[n+1];\n  REP(i,n)\n    cin >> d[i];\n  d[n] = l;\n  int have = 0;\n  int now = 0;\n  double acctime = 0;\n  double res = 0;\n  REP(i,n+1) {\n    double dis = d[i] - now;\n    while(1) {\n//      printf(\"%d, %f %f\\n\", have, dis, acctime);\n      if (dis < v*acctime) {\n//        cout << \"hoge\" << endl;\n        acctime -= dis / v;\n        res += dis / v;\n        dis = 0;\n//        cout << acctime << endl;\n        break;\n      } else {\n        res += acctime;\n        dis -= acctime*v;\n//        cout << \"dis = \" << dis << endl;\n        if (have) {\n          have--;\n          acctime = t;\n        } else {\n          break;\n        }\n//        cout << res << \" \" << acctime << endl;\n      }\n    }\n    res += dis / u;\n    have++;\n    if (have == k+1) {\n      acctime = t;\n      have--;\n    }\n    now = d[i];\n//    cout << \"res = \"<< res << endl;\n  }\n  printf(\"%.12f\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <set>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main(void)\n{\n\tint N, K, T, U, V, L;\n\tint time = 0;\n\tint carrot = 0;\n\tint v_run = 0;\n\tdouble result;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tset<int> D;\n\trep(i, N){\n\t\tint d;\n\t\tcin >> d;\n\t\tD.insert(d);\n\t}\n\t//毎ループ地点iにおいて振る舞いを考える\n\trep(i, L){\n\t\tif (time > 0){\n\t\t\tif (D.find(i) != D.end()){\n\t\t\t\tif (carrot == K){\n\t\t\t\t\ttime = V*T;\n\t\t\t\t}else{\n\t\t\t\t\tcarrot++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv_run++;\n\t\t\ttime--;\n\t\t}else if(time == 0){\n\t\t\tif (D.find(i) != D.end()){\n\t\t\t\tv_run++;\n\t\t\t\ttime = V*T - 1;\n\t\t\t}else if(carrot > 0){\n\t\t\t\tcarrot--;\n\t\t\t\tv_run++;\n\t\t\t\ttime = V*T - 1;\n\t\t\t}\n\t\t}\n\t}\n\tresult = (double)v_run / V + (double)(L - v_run) / U;\n\tcout << fixed << setprecision(9) << result << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n\nbool solve() {\n    int N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n    vector<int> D(N); cin >> D;\n    sort(all(D));\n    int carrot = 0;\n    int left_time = 0;\n    int high_speed_range = 0;\n    int di = 0;\n    rep(l, L) {\n        if(di < N and D[di] == l) {\n            if(carrot == K) left_time = T * V;\n            else carrot++;\n            di++;\n        }\n        if(carrot > 0 and left_time == 0) {\n            carrot--;\n            left_time = T * V;\n        }\n\n        high_speed_range += (left_time > 0);\n        left_time = max(0, left_time - 1);\n    }\n    printf(\"%.10f\\n\", (double)(L - high_speed_range) / U + (double)(high_speed_range) / V);\n    \n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tCarrot_Num =Carrot_Time_Rest = 0;\n\t\tTotal_Time = 0.0;\n\t}\n\n\tvoid set(int arg_Carrot_Num,double arg_Carrot_Time_Rest,double arg_Total_Time){\n\t\tCarrot_Num = arg_Carrot_Num;\n\t\tCarrot_Time_Rest = arg_Carrot_Time_Rest;\n\t\tTotal_Time = arg_Total_Time;\n\t}\n\n\tint Carrot_Num;\n\tdouble Total_Time,Carrot_Time_Rest;\n};\n\nint main(){\n\n\tInfo first;\n\tint N,Have_Limit;\n\tdouble Normal_Speed,Carrot_Speed,Carrot_Time_Length,L;\n\tscanf(\"%d %d %lf %lf %lf %lf\",&N,&Have_Limit,&Carrot_Time_Length,&Normal_Speed,&Carrot_Speed,&L);\n\n\tdouble Location[N+2];\n\tLocation[0] = 0.0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lf\",&Location[i]);\n\t}\n\tLocation[N+1] = L;\n\n\tfirst.set(0,0.0,0.0);\n\n\tdouble Dist;\n\tint use_num;\n\n\tfor(int i = 1; i <= N+1;i++){\n\n\t\tDist = Location[i] - Location[i-1];\n\t\tif(Dist <= Carrot_Speed*first.Carrot_Time_Rest){\n\t\t\tfirst.Carrot_Time_Rest -= Dist/Carrot_Speed;\n\t\t\tfirst.Total_Time += Dist/Carrot_Speed;\n\n\t\t}else{\n\t\t\tDist -= Carrot_Speed*first.Carrot_Time_Rest;\n\n\t\t\tuse_num = 0;\n\t\t\tfor(int k = 1; k <= first.Carrot_Num;){\n\t\t\t\tif(Dist <= Carrot_Speed*Carrot_Time_Length){\n\t\t\t\t\tfirst.Carrot_Time_Rest = Carrot_Time_Length-Dist/Carrot_Speed;\n\t\t\t\t\tfirst.Total_Time += Dist/Carrot_Speed;\n\t\t\t\t\tDist = 0.0;\n\t\t\t\t\tuse_num = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tDist -= Carrot_Speed*Carrot_Time_Length;\n\t\t\t\t\tfirst.Total_Time += Carrot_Time_Length;\n\t\t\t\t\tk++;\n\t\t\t\t\tif(k > first.Carrot_Num){\n\t\t\t\t\t\tuse_num = first.Carrot_Num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfirst.Carrot_Num -= use_num;\n\t\t\tif(Dist > 0){\n\t\t\t\tfirst.Total_Time += Dist/Normal_Speed;\n\t\t\t}\n\t\t}\n\t\tif(first.Carrot_Num < Have_Limit)first.Carrot_Num++;\n\t}\n\n\tprintf(\"%.8lf\\n\",first.Total_Time);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n    int n,k,t,u,v,l,tmp;\n    bool car[10002];\n    cin >> n >> k >> t >> u >> v >> l;\n\n    memset(car,false,sizeof(car));\n\n    for(int i=0;i<n;i++){\n        cin >> tmp;\n        car[tmp] = true;\n    }\n\n    int stock = 0,fast = 0, slow = 0, rem = 0;\n    for(int i=0;i<l;i++){\n        if(rem == 0 && stock > 0){\n            rem = v*t;\n            stock--;\n        }\n        if(car[i]){\n            if(rem == 0){\n                rem = v*t;\n            }else{\n                if(stock == k){\n                    rem = v*t;\n                }else{\n                    stock++;\n                }\n            }\n        }\n        if(rem > 0){\n            fast++;\n            rem--;\n        }else{\n            slow++;\n        }\n    }\n    printf(\"%.10f\\n\", (double)fast/v + (double)slow/u);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, k, t, u, v, l;\nvector<bool> road;\nvector<long long> d;\n\nlong double solve();\n\nint main() {\n  cout << fixed << setprecision(10);\n  cin >> n >> k >> t >> u >> v >> l;\n  d.resize(n);\n  for(int i = 0; i < n; ++i) cin >> d[i];\n  cout << solve() << endl;\n  return 0;\n}\n\nlong double solve() {\n  long long now = 0, cnt = 0, ud = 0, vd = 0;\n  road.assign(l + 1, 0);\n  for(int i = 0; i < n; ++i) road[d[i]] = 1;\n  for(int i = 1; i <= l; ++i) {\n    if(now < i)\n      ++ud;\n    else\n      ++vd;\n    if(road[i]) {\n      if(now < i)\n        now = i + t * v;\n      else\n        ++cnt;\n    }\n    if(cnt > k || (cnt != 0 && now <= i)) {\n      now = i + t * v;\n      --cnt;\n    }\n  }\n  return (long double)ud / u + (long double)vd / v;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n\nint dy[] = { 0, 0, 1, -1 };\nint dx[] = { 1, -1, 0, 0 };\n\nll A, B, C, D, E, F, G, H, I, J, K, L, M,\nN, O, P, Q, R, S, T, U, V, W, X, Y, Z;\n\nstruct Card {\n\tll number;\n\tchar color;\n} Card_t;\n\nnamespace aojStartingLine { void aojStartingLine(); }\nint main()\n{\n\taojStartingLine::aojStartingLine();\n\treturn 0;\n}\n\n//* ?????????n??????????????\\??????????????????????????????????????????\ntemplate <typename T>\nvector<T> INP(ll n)\n{\n\tvector<T> x;\n\tREP(i, n) {\n\t\tT tmp; cin >> tmp;\n\t\tx.push_back(tmp);\n\t}\n\treturn x;\n}\n//* n??????1????????????????????\\?????????????????????????????¨??????????????????\nvector<char> SPRIT_STRING(ll n)\n{\n\tstring str; cin >> str;\n\tvector<char> cs(n);\n\tREP(i, n) cs[i] = str[i];\n\treturn cs;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2298\nnamespace aojStartingLine {\n\tvoid aojStartingLine()\n\t{\n\t\tcin >> N >> K >> T >> U >> V >> L;\n\t\tvector<int> ds = INP<int>(N);\n\n\t\tdouble ans;\n\t\tdouble time = 0.0;\n\t\tll distance = 0;\n\t\tint restBoostL = 0;\n\t\tint restCarrot = 0;\n\t\tint currentIndex = -1;\n\t\tREP(i, L) {\n\t\t\tif (restBoostL > 0) {\n\t\t\t\ttime += 1.0 / (double)V;\n\t\t\t\trestBoostL--;\n\t\t\t}\n\t\t\telse\n\t\t\t\ttime += 1.0 / (double)U;\n\n\t\t\tif (currentIndex == -1 and ds[0] == i + 1) {\n\t\t\t\tcurrentIndex = 0;\n\t\t\t\trestBoostL = T * V;\n\t\t\t}\n\t\t\telse if (currentIndex >= 0 and currentIndex < (N-1) and ds[currentIndex+1] == (i + 1)) {\n\t\t\t\tif (restBoostL == 0) {\n\t\t\t\t\trestBoostL = T*V;\n\t\t\t\t}\n\t\t\t\telse if (restCarrot < K) {\n\t\t\t\t\trestCarrot++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trestBoostL = T*V;\n\t\t\t\t}\n\t\t\t\tcurrentIndex++;\n\t\t\t}\n\n\t\t\tif (restBoostL == 0 and restCarrot > 0) {\n\t\t\t\trestBoostL = T * V;\n\t\t\t\trestCarrot--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << fixed << setprecision(10) << time << endl;\n\t}\n}\n\n\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2424\nnamespace aojKakezan {\n\tvoid aojKakezan() {\n\t\tcin >> Q;\n\t\tREP(i, Q) {\n\t\t\tstring current; cin >> current;\n\t\t\tll cnt = 0;\n\t\t\twhile (current.size() > 1) {\n\t\t\t\tll maxNext = 0;\n\t\t\t\tREP(p, current.size() - 1) {\n\t\t\t\t\tll a = stoi(current.substr(0, p+1));\n\t\t\t\t\tll b = stoi(current.substr(1 + p, current.size() - (p+1)));\n\t\t\t\t\tmaxNext = max(maxNext, a * b);\n\t\t\t\t}\n\t\t\t\tcurrent = to_string(maxNext);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tcout << cnt << endl;\n\t\t}\n\t}\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2102&lang=jp\nnamespace aojRummy {\n\tbool comp(const Card& a, const Card& b)\n\t{\n\t\treturn a.number < b.number;\n\t}\n\n\tbool rummyCheck(vector<Card> cards)\n\t{\n\t\tif (cards.size() == 0) return true;\n\t\tif (cards.size() % 3 != 0) return false;\n\t\tsort(cards.begin(), cards.end(), comp);\n\t\tbool okay = false;\n\t\tdo {\n\t\t\tint repNum = cards.size() / 3;\n\t\t\tbool localOkay = true;\n\t\t\tREP(i, repNum) {\n\t\t\t\tll zero = cards[i * 3].number;\n\t\t\t\tll one = cards[i * 3 + 1].number;\n\t\t\t\tll two = cards[i * 3 + 2].number;\n\t\t\t\tif (not((zero == one and one == two) or ((zero + 1) == one and (one + 1) == two)))\n\t\t\t\t\tlocalOkay = false;\n\t\t\t}\n\t\t\tif (localOkay)\n\t\t\t\tokay = true;\n\t\t} while (next_permutation(cards.begin(), cards.end(), comp));\n\t\treturn okay;\n\t}\n\n\tvoid aojRummy()\n\t{\n\t\tcin >> T;\n\n\t\tN = 9;\n\t\tREP(t, T) {\n\t\t\tvector<Card> cards(N);\n\t\t\tREP(i, 9) cin >> cards[i].number;\n\t\t\tREP(i, 9) cin >> cards[i].color;\n\n\t\t\tvector<Card> red, green, blue;\n\t\t\tREP(i, N) {\n\t\t\t\tCard c = cards[i];\n\t\t\t\tif (c.color == 'R') red.push_back(c);\n\t\t\t\telse if (c.color == 'G') green.push_back(c);\n\t\t\t\telse blue.push_back(c);\n\t\t\t}\n\n\t\t\tif (rummyCheck(red) and rummyCheck(blue) and rummyCheck(green))\n\t\t\t\tcout << 1 << endl;\n\t\t\telse\n\t\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}\n\n//* http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1129\nvoid aojHanafudaShuffle()\n{\n\tN = R = 1;\n\twhile (true) {\n\t\tcin >> N >> R;\n\t\tif (N == 0 and R == 0) break;\n\n\t\tvector<ll> cards(N);\n\t\tREP(i, N) cards[i] = i + 1;\n\n\t\tREP(i, R) {\n\t\t\tcin >> P >> C;\n\t\t\trotate(cards.begin() + (N - (C + P - 1)), cards.begin() + (N - (P - 1)), cards.end());\n\t\t\t//vector<ll> tmp(C);\n\t\t\t//copy(cards.begin() + (N - (C + P - 1)), cards.begin() + N - (P - 1), tmp.begin());\n\t\t\t//copy(cards.begin() + (N - (P - 1)), cards.end(), cards.begin() + (N - (C + P - 1)));\n\t\t\t//copy(tmp.begin(), tmp.end(), cards.begin() + (N - C));\n\t\t}\n\n\t\tcout << cards[cards.size() - 1] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  float lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  float ans=0.0;\n  int x=0,y,v=lv[1];\n  for(int i=1;i<=L;i++){\n    if(lv[i]==v) continue;\n    else{\n      y=i-1;\n      ans+=(float)(y-x)/v;\n      v=lv[i];\n      x=y;\n    }\n  }\n  ans+=(float)(L-x)/v;\n  printf(\"%f\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main(){\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  int D[N];\n  for(int i = 0; i < N; ++i)\n    cin >> D[i];\n  int C[L];\n  fill(C,C+L,0);\n  int t = 0, s = 0, r = 0, f = 0;\n  for(int i = 0; i < L; ++i){\n    if(r > 0){\n      ++f;\n      --r;\n    }\n    if(t < N && D[t] == i){\n      ++t;\n      ++s;\n    }\n    if((r == 0 && s > 0) || s > K){\n      r = T*V;\n      --s;\n    }\n  }\n  printf(\"%.10f\\n\",(double)f/V + (double)(L-f)/U);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\nsigned main() {\n\tcout << fixed << setprecision(10);\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(N);\n\tvector<bool> c(L + 1);\n\trep(i, 0, N) {\n\t\tcin >> D[i];\n\t\tc[D[i]] = true;\n\t}\n\n\tdouble ans = 0;\n\tint k = 0;\n\tint life = 0;\n\trep(i, 1, L + 1) {\n\t\tif (life) {\n\t\t\tans += 1.0 / V;\n\t\t\tlife--;\n\t\t}\n\t\telse {\n\t\t\tans += 1.0 / U;\n\t\t}\n\n\t\tif (c[i]) {\n\t\t\tif (k == K) {\n\t\t\t\tlife = V * T;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\n\t\tif (life == 0 && k) {\n\t\t\tk--;\n\t\t\tlife += V * T;\n\t\t}\n\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=505,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,K,T;\n    double U,V,L;cin>>N>>K>>T>>U>>V>>L;\n    \n    vector<int> can(L+1);\n    for(int i=0;i<N;i++){\n        int a;cin>>a;\n        can[a]++;\n    }\n    \n    double ans=0;\n    \n    int have=0;\n    double rem=0.0;\n    \n    for(int i=1;i<=L;i++){\n        if(rem==0.0){\n            if(have){\n                have--;\n                rem=T;\n                \n                ans+=1.0/V;\n                rem-=1.0/V;\n            }else{\n                ans+=1.0/U;\n            }\n        }else if(rem*V>=1.0){\n            ans+=1.0/V;\n            rem-=1.0/V;\n        }else{\n            double d=1.0-rem*V;\n            ans+=rem;\n            rem=0.0;\n            \n            if(have){\n                have--;\n                rem=T;\n                \n                ans+=d/V;\n                rem-=d/V;\n            }else{\n                ans+=d/U;\n            }\n        }\n        \n        if(can[i]){\n            if(rem==0.0){\n                rem=T;\n            }else{\n                have++;\n                if(have==K+1){\n                    have--;\n                    rem=T;\n                }\n            }\n        }\n    }\n    \n    cout<<setprecision(25)<<ans<<endl;\n    \n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nvoid solve(){\n    int n,k,t,u,v,l;\n    cin>>n>>k>>t>>u>>v>>l;\n    int d[1000];\n    for(int i = 0; i < n; i++)\n        cin>>d[i];\n    d[n]=l;\n    double sumS=0;\n    int prvP=0;\n    double left=0;\n    for(int i = 0; i <= n; i++){\n        int move=-prvP+d[i];\n        // ±Ì£ðÅ«éÀèÁ¬µÄÊß·é\n        double s=(double)move/v;\n        if(s>left){\n            sumS+=left;\n            double leftDis=move-v*left;\n            sumS+=(double)leftDis/u;\n            left=0;\n        }\n        else{\n            left-=s;\n            sumS+=s;\n        }\n        if(i==n)\n            break;\n        // ¡Éñ¶ñðÇÁÅ«éÈç\n        if(left<=k*t)\n            left+=t;\n        else{\n            left=(k+1)*t;\n        }\n        prvP=d[i];\n    }\n    printf(\"%.8f\\n\",sumS);\n}\nint main(){\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\n\nint main(void){\n    ll n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    \n    ll d[205];\n    for (int i = 0; i < n; i++) cin >> d[i];\n    \n    ll vel[10010], fast = 0, idx = 0;\n    for (int i = 0; i < l; i++) {\n        if (idx < n && d[idx] == i) {\n            fast = min((k + 1) * v * t, fast + v * t);\n            idx++;\n        }\n        \n        if (fast > 0) vel[i] = v;\n        else vel[i] = u;\n        fast = max(fast - 1, 0ll);\n    }\n    \n    double ans = 0.0;\n    for (int i = 0; i < l; i++) {\n        ans += double(1) / double(vel[i]);\n        //cout << i << \" \" << vel[i] << endl;\n    }\n    \n    cout << setprecision(12) << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,k,t,u,v,l;\n\tcin>>n>>k>>t>>u>>v>>l;\n\tvector<bool>d(10010,false);\n\trep(i,n){\n\t\tint a;\n\t\tcin>>a;\n\t\td[a]=true;\n\t}\n\tdouble sum=0;\n\tint T=0;\n\tint hav=0;\n\trep(i,l){\n\t\tif(d[i]){\n\t\t\tsum+=1./v;\n\t\t\tif(hav==k){\n\t\t\t\tT=t*v-1;\n\t\t\t}else if(T){\n\t\t\t\tT--;\n\t\t\t\thav++;\n\t\t\t}else{\n\t\t\t\tT=t*v-1;\n\t\t\t}\n\t\t}else{\n\t\t\tif(T){\n\t\t\t\tT--;\n\t\t\t\tsum+=1./v;\n\t\t\t}else if(hav){\n\t\t\t\thav--;\n\t\t\t\tT+=t*v-1;\n\t\t\t\tsum+=1./v;\n\t\t\t}else sum+=1./u;\n\t\t\t\n\t\t}\n\t}\n\tprintf(\"%.8f\\n\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nvector<int> carrot(10010,0);\nint n,k,t,u,v,l,d;\n\n\nint main(){\n\tcin>>n>>k>>t>>u>>v>>l;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>d;\n\t\tcarrot.at(d)+=1;\n\t}\n\tint boost_l=0;\n\tint normal_l=0;\n\tint haveNum=0;\n\tbool flag=false;\n\tint end_l=0;\n\tfor(int i=1; i<=l; i++){\n\t\tif(i==end_l)flag=false;\n\t\tif(carrot.at(i)>0){\n\t\t\tif(!flag){\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(haveNum<k)haveNum++;\n\t\t\t\telse {\n\t\t\t\t\tend_l=i+v*t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!flag&&haveNum>0){\n\t\t\t\thaveNum--;\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t}\n\t\t}\n\t\tif(flag)boost_l++;\n\t\telse normal_l++;\n\t}\n\tprintf(\"%.9lf\\n\",(double)boost_l/v+(double)normal_l/u);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n  int N,K,T,L;\n  double U,V;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N+1,0);\n  D[N+1]=0;\n  for(int i=0;i<N;++i){\n    cin >> D[i];\n  }\n  double Time=0;\n  int pos=0;\n  int Npos=0;\n  int until=0;\n  while(pos < L){\n    if(pos==D[Npos]){\n      ++Npos;\n      until+=T*V;\n      if(until+T*V>(K+1)*T*V){\n\tuntil=(K+1)*T*V;\n      }\n    }\n    //cout << \"proceed\" << endl;\n\n    if(until==0){\n      Time+=1/U;\n    }else{\n      Time+=1/V;\n      --until;      \n    }\n    pos+=1;\n  }\n  cout << setiosflags(ios::fixed) << setprecision(15) << Time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin >> N >> K >> T >> U >> V >> L;\n  queue<int> caro;\n  for(int i=0; i<N; i++){\n    int tmp;\n    cin >> tmp;\n    caro.push(tmp);\n  }\n\n  double time = 0;\n  int now = 0;\n  int stock = 0;\n  while(1){\n    //printf(\"now %d, time: %f, stock:%d\\n\", now, time, stock);\n    if(stock==0){\n      if(!caro.empty() && now+U >= caro.front()){\n        time += (caro.front()-now)/(double)U;\n        now = caro.front();\n        caro.pop();\n        stock++;\n      }else if(now+U >= L){\n        time += (L-now)/(double)U;\n        now = L;\n        break;\n      }else{\n        time += 1;\n        now += U;\n      }\n    }else{\n      stock--;\n      if(now + T*V >= L){\n        time += (L-now)/(double)V;\n        now = L;\n        break;\n      }\n      else{\n        time += T;\n        now += T*V;\n        int last;\n        bool over=false;\n        while(!caro.empty() && caro.front()<=now){\n          stock++;\n          if(stock>K){\n            stock=K;\n            over=true;\n            last = caro.front();\n          }\n          caro.pop();\n        }\n        if(over){\n          time -= (now-last)/(double)V;\n          now = last;\n          stock++;\n        }\n      }\n    }\n  }\n\n  cout << fixed;\n  cout << setprecision(10);\n  cout << time << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\nint N,K;\nbool is_ca[10010] = {};\ndouble T,U,V,L,D[210],dp[10010][210] = {};\n\nint main(){\n    cin >> N >> K >> T >> U >> V >> L;\n    for(int i=1;i<=N;i++){\n        cin >> D[i];\n    }\n    double ti = 0;\n    bool ca = false;\n    int next_ca = 1,cnt = 0,off_pos = 0;\n    for(int i=0;i<L;i++){\n        if(D[next_ca]==i){\n            cnt++; next_ca++;\n        }\n        if(!ca && cnt>0){\n            ca = true;\n            cnt--;\n            off_pos = i+T*V;\n        }\n        if(cnt==K+1){\n            off_pos = i+T*V;\n            cnt--;\n        }else if(off_pos==i){\n            if(cnt>0){\n                cnt--; off_pos = i+T*V;\n            }else ca = false;\n        }\n        if(!ca) ti += 1.0/U;\n        else ti += 1.0/V;\n    }\n    cout << fixed;\n    cout << setprecision(10) << ti << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint main(){\n    int n,k,t,u,v,l,tmp;\n    bool car[10001];\n    cin >> n >> k >> t >> u >> v >> l;\n\n    memset(car,false,sizeof(car));\n\n    for(int i=0;i<n;i++){\n        cin >> tmp;\n        car[tmp] = true;\n    }\n\n    int stock = 0;\n    double ret = 0;\n    int rem = 0;\n    for(int i=0;i<l;i++){\n        //走り出す前チェック\n        if(rem == 0 && stock > 0){\n            rem = v*k;\n            stock--;\n        }\n\n        //にんじんチェック\n        if(car[i]){\n            if(rem == 0){\n                rem = v * k;\n            }else{\n                if(stock == k){\n                    rem = v*k;\n                }else{\n                    stock++;\n                }\n            }\n        }\n\n        if(rem > 0){\n            ret += 1.0/v;\n            rem--;\n        }else{\n            ret += 1.0/u;\n        }\n    }\n    printf(\"%.8lf\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2298\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long double real;\n\nconst int NMAX = 300, LMAX = 100000;\nconst int KMAX = NMAX;\nint N, K, T, U, V, L;\nbool D[LMAX], accel[LMAX];\n\nreal solve() {\n  int bag = 0, limit = 0;\n  for (int x = 0; x < L; x++) {\n    if (limit > 0) {\n      limit--;\n      accel[x] = true;\n    } \n    if (D[x]) {\n      if (limit == 0) {\n        limit = V * T;\n      } else if (bag == K) {\n        limit = V * T;\n      } else {\n        bag++;\n      }\n    }\n\n    if (limit == 0 and bag > 0) {\n      bag--;\n      limit = V * T;\n    }\n  }\n\n  int u = 0, v = 0;\n  REP(x, L) {\n    if (accel[x]) {\n      v++;\n    } else {\n      u++;\n    }\n  }\n  cout << endl;\n\n  return ((real) u) / U + ((real) v) / V;\n}\n\nint main() {\n  cin >> N >> K >> T >> U >> V >> L;\n  REP(x, N) {\n    int d; cin >> d;\n    D[d] = true;\n  }\n\n  cout << setprecision(10) << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n,k;\n  double u,v,t,l,d[201],ans,remain,limit;\n  while(cin >> n >> k >> t >> u >> v >> l){\n    for(int i=0;i<n;i++) cin >> d[i];\n    d[n] = l;\n    \n    ans = d[0] / u;\n    limit = t * v * (k + 1);\n    remain = 0;\n    for(int i=0;i<n;i++){\n      remain = min(remain + t * v, limit);\n      double dis = d[i+1] - d[i];\n      if(dis > remain){\n        ans += remain / v + (dis - remain) / u;\n        remain = 0;\n      } else{\n        ans += dis / v;\n        remain -= dis;\n      }\n      \n    }\n    \n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct state\n{\n\tint idx;\n\tdouble time;\n\tint have;\n\tdouble limit;\n\tbool operator<(const state& right) const{\n\t\treturn time != right.time ? time > right.time : idx != right.idx ? idx < right.idx : have < right.have;\n\t}\n};\n\nint main() {\n\tint n, m;\n\tdouble effect, u, v, len;\n\tcin>> n>> m>> effect>> u>> v>> len;\n\tvector<double> boost(n);\n\tREP(i, n)\n\t\tcin>>boost[i];\n\tpriority_queue<state> Q;\n\tQ.push({ 0, boost[0] / u, 0, 0.0 });\n\tvector<vector<double>> G(n,vector<double>(m+1,1e9));\n\tdouble ans = 0.0;\n\twhile (!Q.empty())\n\t{\n\t\tstate q = Q.top();Q.pop();\n\t\tq.have = min(q.have + 1, m+1);\n\t\tif (q.idx == n - 1) {\n\t\t\tif (q.have == m + 1)\n\t\t\t\tq.limit = 0;\n\t\t\tif (len - boost[n - 1] - (q.have*effect+q.limit)*v <= 0.0)\n\t\t\t\tQ.push({n,q.time+ (len - boost[n - 1] )/v,0,0.0});\n\t\t\telse\n\n\t\t\t\tQ.push({ n,q.time+ q.have*effect+q.limit+ (len - boost[n - 1] - (q.have*effect + q.limit)*v)/u,0,0.0 });\n\t\t\tcontinue;\n\t\t}\n\t\tif (q.idx == n) {\n\t\t\tans=q.time;\n\t\t\tbreak;\n\t\t}\n\t\t\tREP(i, q.have + 1) {//???????????°\n\t\t\t\tif (q.have - i > m)continue;\n\t\t\t\tdouble kasoku_load = (q.limit + effect*i)*v;\n\t\t\t\tif (boost[q.idx + 1] - boost[q.idx] <= kasoku_load) {\n\t\t\t\t\tif (G[q.idx + 1][q.have - i] > q.time + (boost[q.idx + 1] - boost[q.idx]) / v) {\n\t\t\t\t\t\tQ.push({ q.idx + 1,q.time + (boost[q.idx + 1] - boost[q.idx]) / v,q.have - i,max(0.0,q.limit + effect*i - (boost[q.idx + 1] - boost[q.idx]) / v) });\n\t\t\t\t\t\tG[q.idx + 1][q.have - i] = q.time + (boost[q.idx + 1] - boost[q.idx]) / v;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (G[q.idx + 1][q.have - i] > q.time + q.limit + effect*i + (boost[q.idx + 1] - boost[q.idx] - kasoku_load) / u) {\n\t\t\t\t\t\tQ.push({ q.idx + 1,q.time + q.limit + effect*i + (boost[q.idx + 1] - boost[q.idx] - kasoku_load) / u,q.have - i,0.0 });\n\t\t\t\t\t\tG[q.idx + 1][q.have - i] = q.time + q.limit + effect*i + (boost[q.idx + 1] - boost[q.idx] - kasoku_load) / u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t}\n\n\tprintf(\"%.9lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N,K,T,L; double U,V;\n\tcin>>N>>K>>T>>U>>V>>L;\n\n\tint pos[202]; pos[0]=0; pos[N+1]=L;\n\tfor(int i=1; i<=N; i++) cin>>pos[i];\n\n\tint stock=0;\n\tint a_pos=0;\n\tdouble ans=0;\n\n\tfor(int i=1; i<=N+1; i++,stock++)\n\t{\n\t\twhile(a_pos<pos[i] && stock)\n\t\t{\n\t\t\ta_pos += V*T;\n\t\t\tstock--;\n\t\t}\n\n\t\tif(a_pos<pos[i])\n\t\t{\n\t\t\tans += (a_pos-pos[i-1])/V + (pos[i]-a_pos)/U;\n\t\t\ta_pos = pos[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans += (pos[i]-pos[i-1])/V;\n\t\t\tif(stock>=K)\n\t\t\t{\n\t\t\t\ta_pos = pos[i] + V*T;\n\t\t\t\tstock=K-1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout.precision(9);\n\tcout << fixed << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   private:\n      queue <TNode> Q;\n      virtual void init() = 0;\n      virtual TNode get_start_node() = 0;\n      virtual bool is_goal_node( TNode node ) = 0;\n      virtual void find_next_node( TNode node ) = 0;\n   public:\n      IBFS() {\n         Q = queue <TNode>();\n      }\n      TNode run() {\n         init();\n         Q.push( get_start_node() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal( node ) ) {\n               return node;\n            }\n            find_next_node( node );\n         }\n         return TNode();\n      }\n      void push_next_node( TNode node ) {\n         Q.push(node);\n      }\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Solution {\n   private:\n\n      class Node {\n      public:\n         double cost;\n         int id;\n         int remains;\n         int carrots;\n         Node(): cost(NONE){}\n         Node( double cost, int id, int remains, int carrots ):\n            cost(cost), id(id), remains(remains), carrots(carrots) {}\n         friend ostream& operator << ( ostream& os, Node node ) {\n            return os << node.cost << \", \" << node.id << \", \"\n                      << node.remains << \", \" << node.carrots << \" / \";\n         }\n      };\n\n      class BFS: public IBFS<Node> {\n      private:\n         double base;\n         double fast;\n\n         void init() {\n            base = 1.0 / U;\n            fast = 1.0 / V;\n         }\n\n         Node get_start_node() {\n            return Node( 0.0, 0, 0, 0 );\n         }\n\n         bool is_goal_node( Node node ) {\n            return node.id == L;\n         }\n\n      public:\n\n         void find_next_node( Node node ) {\n            Node next_node = node;\n\n            if ( D[next_node.id] ) {\n               if ( next_node.carrots == K ) {\n                  next_node.remains = T * V;\n               } else {\n                  next_node.carrots ++;\n                  if ( next_node.remains == 0 ) {\n                     next_node.remains = T * V;\n                     next_node.carrots --;\n                  }\n               }\n            }\n\n            double t = base;\n            if ( next_node.remains ) {\n               t = min( t, fast );\n               next_node.remains --;\n            }\n            if ( next_node.remains == 0 && next_node.carrots ) {\n               next_node.remains = T * V;\n               next_node.carrots --;\n            }\n            next_node.cost += t;\n            next_node.id += 1;\n\n            push_next_node( next_node );\n         }\n      };\n\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         static BFS bfs;\n         bfs = BFS();\n         return bfs.run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   private:\n      queue <TNode> Q;\n      virtual void init() = 0;\n      virtual TNode get_start_node() = 0;\n      virtual bool is_goal_node( TNode node ) = 0;\n      virtual void find_next_node( TNode node ) = 0;\n   public:\n      IBFS() {\n         Q = queue <TNode>();\n      }\n      TNode run() {\n         init();\n         Q.push( get_start_node() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal_node( node ) ) {\n               return node;\n            }\n            find_next_node( node );\n         }\n         return TNode();\n      }\n      void push_next_node( TNode node ) {\n         Q.push(node);\n      }\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Solution {\n   private:\n\n      class Node {\n      public:\n         double cost;\n         int id;\n         int remains;\n         int carrots;\n         Node(): cost(NONE){}\n         Node( double cost, int id, int remains, int carrots ):\n            cost(cost), id(id), remains(remains), carrots(carrots) {}\n         friend ostream& operator << ( ostream& os, Node node ) {\n            return os << node.cost << \", \" << node.id << \", \"\n                      << node.remains << \", \" << node.carrots << \" / \";\n         }\n      };\n\n      class BFS: public IBFS<Node> {\n      private:\n         double base;\n         double fast;\n\n         void init() {\n            base = 1.0 / U;\n            fast = 1.0 / V;\n         }\n\n         Node get_start_node() {\n            return Node( 0.0, 0, 0, 0 );\n         }\n\n         bool is_goal_node( Node node ) {\n            return node.id == L;\n         }\n\n      public:\n\n         void find_next_node( Node node ) {\n            Node next_node = node;\n\n            if ( D[next_node.id] ) {\n               if ( next_node.carrots == K ) {\n                  next_node.remains = T * V;\n               } else {\n                  next_node.carrots ++;\n                  if ( next_node.remains == 0 ) {\n                     next_node.remains = T * V;\n                     next_node.carrots --;\n                  }\n               }\n            }\n\n            double t = base;\n            if ( next_node.remains ) {\n               t = min( t, fast );\n               next_node.remains --;\n            }\n            if ( next_node.remains == 0 && next_node.carrots ) {\n               next_node.remains = T * V;\n               next_node.carrots --;\n            }\n            next_node.cost += t;\n            next_node.id += 1;\n\n            push_next_node( next_node );\n         }\n      };\n\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         static BFS bfs;\n         bfs = BFS();\n         return bfs.run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tll N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<ll> D(N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> D[i];\n\t}\n\tD[N] = L;\n\tdouble res = (double)D[0] / U, pos = D[0];\n\tll cnt = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (D[i] <= pos + T * V * cnt) {\n\t\t\tint tmp = cnt - (D[i] - pos) / (T * V);\n\t\t\tif (tmp < K) {\n\t\t\t\tcnt++;\n\t\t\t\tif (i == N) {\n\t\t\t\t\tres += (double)(D[i] - pos) / V;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += (double)(D[i] - pos) / V;\n\t\t\t\tcnt = K + 1;\n\t\t\t\tpos = D[i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tres += T * cnt + (double)(D[i] - pos - T * V * cnt) / U;\n\t\t\tcnt = 1;\n\t\t\tpos = D[i];\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N,K,T,U,V,L;\nbool mp[10010];\n\nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  int cnt=0;\n  for(int i=0,a,A;i<N;i++){\n    cin>>a;\n    A=a;\n    while(mp[a])a++;\n    while((1.0*a-A)/V>K)a--;\n    for(int j=a;j<L&&j<a+T*V;j++) cnt+=!mp[j],mp[j]=1;\n  }\n  printf(\"%.8f\\n\",(1.0*cnt/V)+(1.0*(L-cnt)/U));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l,d[210]={0};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  int a=0,p=0,st=0;\n  for(int i=1;i<=n+1;i++){\n    if(a+st*v*t>d[i]-d[i-1]){\n      if(a>=d[i]-d[i-1])a-=d[i]-d[i-1];\n      else st-=(d[i]-d[i-1]-a)/(v*t),a=(d[i]-d[i-1]-a)%(v*t);\n      if(st<k)st++;\n      else if(st==k)a=v*t;\n    }\n    else p+=d[i]-d[i-1]-a-st*v*t,a=v*t,st=0;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n, k, t, u, v, l;\n\tdouble second;\n\tdouble length;\n\n\tcin >> n >> k >> t >> u >> v >> l;\n\tint *d;\n\td = (int *)calloc(n, sizeof(int));\n\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> d[i];\n\n\t//d[0]までは速さuで走る\n\tsecond = (double)d[0] / u;\n\tlength = (double)d[0];\n\n\t//d[0]からt秒間速さvで加速して走る\n\tsecond += t;\n\tlength += v*t;\n\n\tif(l - length < 0)\t\t//lengthがlを超えた場合\n\t\t{\n\t\t\tsecond -= t;\n\t\t\tlength -= v*t;\n\t\t\tsecond += (l-length) / v;\n\t\t\tlength = l;\n\t\t}\n\n\tint counter = 0;\t//counter(持っている人参の数)\n\tint j = 1;\n\n\twhile(length - d[j] >= 0 && j < n && length != l) //d地点を何個抜かしたか\n\t{\n\t\tif(counter < k)\n\t\t\tcounter++;\n\t\t\n\t\tj++;\n\t}\n\n\twhile(length != l)\t//counterの個数だけ加速 ちなみにcounterがマイナスになることはない\n\t{\n\t\tif(counter > 0)\n\t\t{\n\t\t\tsecond += t;\n\t\t\tlength += v*t;\n\t\t\tcounter--;\t\t//加速したらcounterを1減らす\n\n\t\t\tif(length - l > 0)\t\t//lengthがlを超えた場合\n\t\t\t{\n\t\t\t\tsecond -= t;\n\t\t\t\tlength -= v*t;\n\t\t\t\tsecond += (l-length) / v;\n\t\t\t\tlength = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(length - d[j] >= 0 && j < n) //d地点を何個抜かしたか\n\t\t\t{\n\t\t\t\tif(counter < k)\n\t\t\t\t\tcounter++;\n\t\t\t\tj++;\n\t\t\t}\t\t\n\t\t}\n\t\telse\t\t//counterが0のとき\n\t\t{\n\t\t\tif(j < n)\t\t//まだ先に人参がある場合\n\t\t\t{\n\t\t\t\tsecond += (double)(d[j] - length) / u;\t\t//普通の速度で\n\t\t\t\tlength = d[j];\n\t\t\t\tj++;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\telse if(j == n)\t//加速していない状態で先にあるのはゴールだけ\n\t\t\t{\n\t\t\t\tsecond += (double)(l - length) / u;\t\t//普通の速度で\n\t\t\t\tlength = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(length == l)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"%.9f\\n\", second);\n\n\tfree(d);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    double k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n\n    double c[205];\n    rep(i,n) cin >> c[i];\n    c[n] = l;\n\n    double m, h, s; //?????¨???????????????????????°????????????????????????\n    double time = 0;\n    int i = 0;\n    while(m < l){\n        double next = c[i] - m;\n        if((h > 0 && s == 0) || h > k){\n            h--;\n            s = t;\n        }\n\n\n        if(h == 0 && s == 0){\n            time += next / u;\n            m += next;\n            i++;\n            h++;\n        }else if(s > 0){\n            if(next / v <= s){\n                s -= next / v;\n                time += next / v;\n                m += next;\n                i++;\n                h++;\n            }else{\n                m += s * v;\n                time += s;\n                s = 0;\n            }\n        }\n    }\n    cout <<fixed << setprecision(8) <<  time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint a, b, c, d, e, f, g;\nint remain;\nint speed;\nint x[10000000];\ndouble res;\nint main() {\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor (int i = 0; i < a; i++) {\n\t\tcin >> g;\n\t\tx[g] = 1;\n\t}\n\tfor (int i = 0; i < f; i++) {\n\t\tif (x[i] == 1) {\n\t\t\tif ((remain + c - 1) / c < b) {\n\t\t\t\tremain += c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg = (c - (remain%c));\n\t\t\t\tif (g == c) { g = 0; }\n\t\t\t\tremain += g;\n\t\t\t}\n\t\t}\n\t\tif (remain > 0) {\n\t\t\tres += 1.0 / e;\n\t\t\tremain--;\n\t\t}\n\t\telse {\n\t\t\tres += 1.0 / d;\n\t\t}\n\t}\n\tcout << setprecision(15) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n, k, t, u, v, l;\n    cin >> n;\n    cin >> k;\n    cin >> t;\n    cin >> u;\n    cin >> v;\n    cin >> l;\n    int d[n];\n    for(int i = 0; i < n; i++){\n        cin >> d[i];\n    }\n\n    const int boost_length = v * t;\n\n    int distance = 0;\n    int slow_distance = 0;\n    int carot_num = 0;\n    int reached_point;\n\n    /*1本目の人参まで*/\n    distance += d[0];\n    slow_distance += d[0];\n    carot_num++;\n    reached_point = 0;\n\n    /*2本目以降*/\n    while(distance < l){\n        if(carot_num == 0){\n            if(reached_point == (n-1)){\n                slow_distance += l - distance;            \n                distance = l;\n            } else {\n                reached_point++;\n                slow_distance += d[reached_point] - distance;\n                distance = d[reached_point];\n                carot_num++;\n            }\n        } else {\n            int old_distance = distance;\n            distance += boost_length;\n            int old_point = reached_point;\n            for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n            }\n            reached_point--;\n            carot_num += reached_point - old_point - 1;\n            while(1){\n                if(carot_num <= k){\n                    break;\n                }\n                distance += d[reached_point] - old_distance;\n                old_point = reached_point;\n                for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n                }\n                reached_point--;\n                carot_num += reached_point - old_point - 1;\n                if(distance >= l){\n                    break;\n                }\n            }\n        }\n    }\n    double time = 0;\n    int rest1 = slow_distance % u;\n    int rest2 = (l - slow_distance) % v;\n    time += rest1  *1.0 / u;\n    time += rest2 *1.0 / v;\n    time += slow_distance / u;\n    time += (l - slow_distance) / v;\n    cout << time << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main(void) {\n    int n,k,t,u,v,l;\n    char d[100000]={};\n    scanf(\"%d%d%d%d%d%d\",&n,&k,&t,&u,&v,&l);\n    for(int i=0; i<n; i++) {\n        int t;\n        scanf(\"%d\",&t);\n        d[t]=1;\n    }\n\n    double res=0.0,rem=0.0;\n    int carrot=0;\n    for(int i=0; i<l; i++) {\n        if(d[i]) carrot++;\n        if(carrot>k) carrot=k, rem = 1.0*t;\n\n        double now=0.0;\n        while(now<1.0) {\n            if(rem==0.0) {\n                if(carrot) {\n                    carrot--;\n                    rem = 1.0*t;\n                } else {\n                    res+= (1.0-now)/u;\n                    now = 1.0;\n                }\n            }\n\n            if(rem > (1.0-now)/v) {\n                res+= (1.0-now)/v;\n                rem-= (1.0-now)/v;\n                now = 1.0;\n            } else {\n                res+= rem;\n                now+= rem*v;\n                rem = 0.0;\n            }\n        }\n    }\n    printf(\"%f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint main() {\n\tcout << fixed << setprecision(9);\n\tint n, k; ld t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tld d[202];\n\td[0] = 0;\n\trep1(i, n) {\n\t\tcin >> d[i];\n\t}\n\td[n+1] = l;\n\tld time = 0; int poss = 0; ld restime = 0;\n\trep(i, n+1) {\n\t\tld dis = d[i + 1] - d[i];\n\t\tif (dis < v*restime) {\n\t\t\trestime -= dis / v;\n\t\t\ttime += dis / v;\n\t\t}\n\t\telse {\n\t\t\tdis -= v * restime; time += restime;\n\t\t\tint cnt = (int)(eps+dis / v * t);\n\t\t\tif (cnt + 1 <= poss) {\n\t\t\t\tposs -= cnt+1;\n\t\t\t\tdis -= (double)cnt*v*t;\n\t\t\t\trestime = t - dis / v;\n\t\t\t\ttime += (double)cnt*t;\n\t\t\t\ttime += dis / v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdis -= (double)poss*v*t;\n\t\t\t\trestime = 0;\n\t\t\t\ttime += (double)poss*t;\n\t\t\t\ttime += dis / u; poss = 0;\n\t\t\t}\n\t\t}\n\t\tif (poss +1 <= k) {\n\t\t\tposs++;\n\t\t}\n\t\telse {\n\t\t\trestime = t;\n\t\t}\n\t\tif (restime == 0) {\n\t\t\trestime = t; poss--;\n\t\t}\n\t}\n\tcout << time << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\n\nnamespace solution {\n   using namespace std;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n   typedef pair <II, int> State;\n   typedef pair <double, State> Node;\n   typedef queue <Node> Queue;\n   Queue Q;\n\n   void BFS_init() {\n      Q = Queue();\n   }\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   double BFS( int start, int goal ) {\n      BFS_init();\n\n      Node start_node( 0.0, State( II( start, 0 ), 0 ) );\n      Q.push( start_node );\n\n      double base = 1.0 / U;\n      double fast = 1.0 / V;\n\n      while ( ! Q.empty() ) {\n         Node node = Q.front();\n         Q.pop();\n\n         double cost = node.first;\n         int id = node.second.first.first;\n         int remains = node.second.first.second;\n         int carrots = node.second.second;\n\n         if ( id == goal ) {\n            return cost;\n         }\n\n\n         if ( D[id] ) {\n            if ( carrots == K ) {\n               remains = T * V;\n            } else {\n               carrots ++;\n               if ( remains == 0 ) {\n                  remains = T * V;\n                  carrots --;\n               }\n            }\n         }\n\n         double t = base;\n         if ( remains ) {\n            t = min( t, fast );\n            remains --;\n         }\n         if ( remains == 0 && carrots ) {\n            remains = T * V;\n            carrots --;\n         }\n         Q.push( Node( cost + t, State( II( id + 1, remains ), carrots ) ) );\n      }\n      return NONE;\n   }\n\n   class Solution {\n   private:\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         return BFS( 0, L );\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\tint N, K, T, U, V, L;\n\tcin>>N>>K>>T>>U>>V>>L;\n\tvector<int> D(N);\n\tREP(i, N) cin>>D[i];\n\tdouble ans = 0;\n\tint roc = 0;\n\tint stock = 0;\n\tint rem = T;\n\twhile(roc < L) {\n\t\tint nroc;\n\t\tif(stock >= 1) {\n\t\t\tnroc = min(roc + V, L);\n\t\t\t--rem;\n\t\t\tstock = min(stock + (int)(upper_bound(ALL(D), nroc) - lower_bound(ALL(D), roc + 0.0000001)), K + 1);\n\t\t\tif(stock + (int)(upper_bound(ALL(D), nroc) - lower_bound(ALL(D), roc + 0.0000001)) > K + 1) {\n\t\t\t\trem = T;\n\t\t\t\tnroc = *(lower_bound(ALL(D), roc + 0.0000001) + (K + 1 - stock));\n\t\t\t}\n\t\t\tans += (nroc - roc) / (double)V;\n\t\t\tif(rem == 0) {\n\t\t\t\t--stock;\n\t\t\t\trem = T;\n\t\t\t}\n\t\t} else {\n\t\t\tnroc = min(roc + U, L);\n\t\t\tif(0 < (upper_bound(ALL(D), nroc) - lower_bound(ALL(D), roc))) {\n\t\t\t\tnroc = *lower_bound(ALL(D), roc);\n\t\t\t\t++stock;\n\t\t\t}\n\t\t\tans += (nroc - roc) / (double)U;\n\t\t}\n\t\troc = nroc;\n\t}\n\tcout<<fixed<<showpoint<<setprecision(39)<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\n\nvoid Main() {\n\tint N, K, T, U, V, L; \n\tbitset<10005> flag;\n\n\tcin >> N >> K >> T >> U >> V >> L;\n\tfor (int i = 0; i < N; i++) {\n\t\tint D; cin >> D;\n\t\tflag[D] = true;\n\t}\n\n\tint prev = -INF;\t\n\tint cnt = 0;\n\tbool f = false;\n\tdouble times = 0;\n\tfor (int i = 0; i < L; i++) {\n\t\tif (flag[i]) cnt++;\n\t\tif (cnt > 0 && (i - prev >= V*T || cnt == K+1)) {\n\t\t\tcnt--;\n\t\t\tf = true;\n\t\t\tprev = i;\n\t\t}\n\t\tif (i - prev >= V*T) f = false;\t\n\t\tif (f) times += 1.0 / (double)V;\n\t\telse times += 1.0 / (double)U;\n\t}\n\tcout << times << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tCarrot_Num =Carrot_Time_Rest = 0;\n\t\tTotal_Time = 0.0;\n\t}\n\n\tvoid set(int arg_Carrot_Num,double arg_Carrot_Time_Rest,double arg_Total_Time){\n\t\tCarrot_Num = arg_Carrot_Num;\n\t\tCarrot_Time_Rest = arg_Carrot_Time_Rest;\n\t\tTotal_Time = arg_Total_Time;\n\t}\n\n\tint Carrot_Num;\n\tdouble Total_Time,Carrot_Time_Rest;\n};\n\nint main(){\n\n\tInfo first;\n\tint N,Have_Limit;\n\tdouble Normal_Speed,Carrot_Speed,Carrot_Time_Length,L;\n\tscanf(\"%d %d %lf %lf %lf %lf\",&N,&Have_Limit,&Carrot_Time_Length,&Normal_Speed,&Carrot_Speed,&L);\n\n\tdouble Location[N+2];\n\tLocation[0] = 0.0;\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lf\",&Location[i]);\n\t}\n\tLocation[N+1] = L;\n\n\tfirst.set(0,0.0,0.0);\n\n\tdouble Dist;\n\tint use_num;\n\n\tfor(int i = 1; i <= N+1;i++){\n\n\t\tDist = Location[i] - Location[i-1];\n\t\tif(Dist <= Carrot_Speed*first.Carrot_Time_Rest){\n\t\t\tfirst.Carrot_Time_Rest -= Dist/Carrot_Speed;\n\t\t\tfirst.Total_Time += Dist/Carrot_Speed;\n\n\t\t}else{\n\t\t\tDist -= Carrot_Speed*first.Carrot_Time_Rest;\n\n\t\t\tuse_num = 0;\n\t\t\tfor(int k = 1; k <= first.Carrot_Num;){\n\t\t\t\tif(Dist <= Carrot_Speed*Carrot_Time_Length){\n\t\t\t\t\tfirst.Carrot_Time_Rest = Carrot_Time_Length-Dist/Carrot_Speed;\n\t\t\t\t\tfirst.Total_Time += Dist/Carrot_Speed;\n\t\t\t\t\tuse_num = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tDist -= Carrot_Speed*Carrot_Time_Length;\n\t\t\t\t\tfirst.Total_Time += Carrot_Time_Length;\n\t\t\t\t\tk++;\n\t\t\t\t\tif(k > first.Carrot_Num){\n\t\t\t\t\t\tuse_num = first.Carrot_Num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfirst.Carrot_Num -= use_num;\n\n\t\t\tif(Dist > 0){\n\t\t\t\tfirst.Total_Time += Dist/Normal_Speed;\n\t\t\t}\n\t\t}\n\t\tif(first.Carrot_Num <= Have_Limit)first.Carrot_Num++;\n\t}\n\n\tprintf(\"%.8lf\\n\",first.Total_Time);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\n\n#define SUPL 10002\n\nint main(){\n\tint cl,maxg,T,U,V,L;\n\tcin>>cl>>maxg>>T>>U>>V>>L;\n\tint cs[cl+1];\n\tREP(ci,cl) cin>>cs[ci];\n\tcs[cl]=-1;\n\n\tdouble t=0;\n\tint x=0;\n\tint ci=0;\n\tdouble boostingX=0;\n\tint g=0;\n\n\twhile(x<L){\t\t//x tuuka tyokugo no joutai\n\t\tx++;\n\t\tif(boostingX>1){\n\t\t\tboostingX-=1;\n\t\t\tt+=1.0/V;\n\t\t}else{\n\t\t\tif(g==0){\n\t\t\t\tt+=boostingX/V+(1-boostingX)/U;\n\t\t\t\tboostingX=0;\n\t\t\t}else{\n\t\t\t\tg--;\n\t\t\t\tt+=1.0/V;\n\t\t\t\tboostingX+=T*V-1;\n\t\t\t}\n\t\t}\n\n\t\tif(x==cs[ci]){\n\t\t\tci++;\n\t\t\tif(g==maxg){\n\t\t\t\tboostingX=T*V;\n\t\t\t}else{\n\t\t\t\tg++;\n\t\t\t}\n\t\t}\n\n\t\t//cout<<x<<\" \"<<t<<\" \"<<ci<<\" \"<<g<<\" \"<<boostingX<<endl;\n\n\t}\n\n\tcout.precision(20);\n\tcout<<t<<endl;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint main(){\n    int n,k,t,u,v,l,tmp;\n    bool car[10001];\n    cin >> n >> k >> t >> u >> v >> l;\n\n    memset(car,false,sizeof(car));\n\n    for(int i=0;i<n;i++){\n        cin >> tmp;\n        car[tmp] = true;\n    }\n\n    int stock = 0;\n    double ret = 0;\n    double rem = 0;\n    for(int i=0;i<l;i++){\n        if(rem > 0){\n            //食べている状態で\n            if(car[i]){\n                if(stock == k){ //ストックがいっぱい\n                    rem = t; //たべる\n                }else{\n                    stock++; //ためる\n                }\n            }\n\n            if(rem*v > 1){ //次の1mは切れない\n                rem -= 1.0 / v;\n                ret += 1.0 / v;\n            }else if(abs(1 - rem*v) < EPS ){//1m丁度もつ\n                ret += 1.0 / v;\n                if(stock > 0){\n                    stock--;\n                    rem = k;\n                }else{\n                    rem = 0;\n                }\n            }else{ //途中で切れる\n                if(stock > 0){//stockがある\n                    stock--;\n                    rem = k - (1.0 / v - rem);\n                    ret += 1.0 / v;\n                }else{\n                    ret += rem + (1 - rem * v) / u;\n                    rem = 0;\n                }\n            }            \n        }else{\n            //食べていなく、\n            if(car[i]){//にんじんがある\n                rem = t; //たべる\n                rem -= 1.0/v; //1m走る\n                ret += 1.0/v; //結果+\n            }else{\n                ret += 1.0/u; //普通に走る\n            }\n        }\n        if(abs(rem) < EPS) rem = 0;\n    }\n    printf(\"%.8lf\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n    int N,K;\n    double T,U,V,L;\n    cin >> N >> K >> T >> U >> V >> L;\n    int have=0;\n    double time=0;\n    double next,now=0,prev=0;\n    double nokori=0;\n    cin >> next;\n    time += (next/U);\n\n    now = T*V + next;\n    prev = next;\n    for(int i= 1; i < N ; i++){\n        cin >> next;\n        if(next <= now){\n            if(have < K){\n                have++;\n                time += (next - prev)/V;\n                prev = next;\n            }else{\n                now = next +T*V;\n                time +=(next - prev)/V;\n                prev = next;\n            }\n        }else{\n            for(;now<next && have>0;have--){\n                now+=(T*V);\n            }\n            if(now >= next){\n                time += (next-prev)/V;\n                prev = next;\n            }else{\n                time += (now - prev)/V;\n                time += (next-now)/U;\n                now = T*V + next;\n                prev = next;\n            }\n        }\n    }\n    next = L;\n    if(next <= now){\n        if(have < K){\n            have++;\n            time +=(next - prev)/V;\n            prev = next;\n        }else{\n            now = next +T*V;\n            time +=(next - prev)/V;\n            prev = next;\n        }\n    }else{\n        for(;now<next && have>0;have--){\n            now+=(T*V);\n        }\n        if(now >= next){\n            time += (next-prev)/V;\n            prev =next;\n        }else{\n            time += (now - prev)/V;\n            time += (next-now)/U;\n            now = T*V + next;\n            prev = next;\n        }\n    }\n    cout << fixed << setprecision(7) << time << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nint n,k,t,u,v,l,stock=0,p=0,c=0;\nbool carrot[10000];\nint main(){\n    scanf(\"%d %d %d %d %d %d\",&n,&k,&t,&u,&v,&l);\n    for(int i=0;i<n;i++){\n        int d;\n        scanf(\"%d\",&d);\n        carrot[d]=true;\n    }\n    for(int i=0;i<l;i++){\n        if(carrot[i]&&stock==k){\n            p=v*t;\n        }\n        if(carrot[i]&&stock<k){\n            stock++;\n        }\n        if(!p&&stock){\n            p=v*t;\n            stock--;\n        }\n        if(p){\n            c++;\n            p--;\n        }\n    }\n    printf(\"%.9f\\n\",(double)c/v+(double)(l-c)/u);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint a, b, c, d, e, f, g;\nlong long remain;\nint speed;\nint x[10000000];\ndouble res;\nint main() {\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor (int i = 0; i < a; i++) {\n\t\tcin >> g;\n\t\tx[g] = 1;\n\t}\n\tfor (int i = 0; i < f; i++) {\n\t\tif (x[i] == 1) {\n\t\t\tif ((remain + 1) / (c * e) < b) {\n\t\t\t\tremain += c * e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg = ((c * e) - (remain % (c * e)));\n\t\t\t\tif (g == c * e) { g = 0; }\n\t\t\t\tremain += g;\n\t\t\t}\n\t\t}\n\t\tif (remain > 0) {\n\t\t\tres += 1.0 / e;\n\t\t\tremain--;\n\t\t}\n\t\telse {\n\t\t\tres += 1.0 / d;\n\t\t}\n\t}\n\tcout << setprecision(15) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n  int N,K,T,L;\n  double U,V;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N+1,0);\n  D[N+1]=0;\n  for(int i=0;i<N;++i){\n    cin >> D[i];\n  }\n  double Time=0;\n  int pos=0;\n  int Npos=0;\n  int until=0;\n  while(pos < L){\n    if(pos==D[Npos]){\n      ++Npos;\n      until+=T*V;\n      if(until>(K+1)*T*V){\n\tuntil=(K+1)*T*V;\n      }\n    }\n    //cout << \"proceed\" << endl;\n\n    if(until==0){\n      Time+=1/U;\n    }else{\n      Time+=1/V;\n      --until;   \n    }\n    pos+=1;\n  }\n  cout << setiosflags(ios::fixed) << setprecision(15) << Time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\nconst int MAX_D = 100005;\n\nint a[MAX_N];\nint n,k,t,u,v,l;\nint flag[MAX_D];\n\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&n,&k,&t,&u,&v,&l);\n\trep(i,n){\n\t\tscanf(\"%d\",&a[i]);\n        flag[a[i]] = 1;\n\t}\n    double res = 0;\n    double rem_t = 0;\n    int cnt = 0;\n    rep(i,l){\n        if(flag[i] == 1){\n            if(rem_t < EPS){\n                rem_t = t - 1.0 / v;\n                res += 1.0 / v;\n            }else{\n                if(cnt == k){\n                    rem_t = t - 1.0 / v;\n                    res += 1.0 / v;\n                }else{\n                    cnt++;\n                    rem_t -= 1.0 / v;\n                    res += 1.0 / v;\n                }\n            }\n        }else{\n            if(rem_t > EPS){\n                res += 1.0 / v;\n                rem_t -= 1.0 / v;\n            }else{\n                if(cnt > 0){\n                    rem_t = t - 1.0 / v;\n                    res += 1.0 / v;\n                    cnt--;\n                }else{\n                    res += 1.0 / u;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    int n, k, t, u, v, l;\n    int d[ten(4) + 100];\n    cin >> n >> k >> t >> u >> v >> l;\n    input(d, n);\n\n    typedef pair<double, bool> P; // (pos, carrot?)\n    priority_queue<P, vector<P>, greater<P> > event;\n    rep(i, n)\n        event.push(P(d[i], true));\n\n    event.push(P(0, false)); // start\n    event.push(P(l, false)); // goal\n\n    const double eps = 1e-8;\n\n    double elapsed = 0;\n    double tl = -1; // time limit of carrot effect\n    int car = 0;\n    for (;;)\n    {\n        double x = event.top().first;\n        bool is_car = event.top().second;\n        event.pop();\n        if (x + eps > l)\n            break;\n\n        if (is_car)\n            ++car;\n\n        if (car > k || (car > 0 && elapsed + eps > tl))\n        {\n            --car;\n            tl = elapsed + t;\n            event.push(P(x + v * t, false));\n        }\n\n        double speed = elapsed < tl ? v : u;\n        double len = event.top().first - x;\n        elapsed += len / speed;\n    }\n    printf(\"%.10f\\n\", elapsed);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cfloat>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nusing llong = long long;\n\nllong n, k, t, u, v, l;\nllong d[205];\n\nint main() {\n    cin >> n >> k >> t >> u >> v >> l;\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n\n    long double ans = 0; //time\n    llong ptr = 0; // d[ptr]\n    llong speed = u; // (m/s)\n    long double time = 0; // 加速していられる残り時間\n    llong stock = 0;\n    for (int i = 1; i <= l; i++) {\n        \n        ans += 1.0 / speed;\n        if (time > DBL_EPSILON) {\n            time -= 1.0 / speed;\n            if (time < DBL_EPSILON) {\n                speed = u;\n                time = 0;\n            }\n\n            if (time < DBL_EPSILON && stock > 0) {\n                stock--;\n                speed = v;\n                time = t;\n            }\n        }\n\n        if (i == d[ptr]) {\n            if (time > DBL_EPSILON && stock < k) {\n                stock++;\n            }\n            else if (time < DBL_EPSILON || stock >= k) {\n                time = t;\n                speed = v;\n            }\n\n            ptr++;\n        }\n    }\n\n    cout << fixed << setprecision(15) << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, K, T, U, V, L;\nint DL[10001];\n\nint main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    for (int i = 0; i < N; i++) {\n        int D; cin >> D;\n        DL[D]++;\n    }\n\n    vector<bool> used(L+1, false);\n    int count = 0, s;\n    bool flag = false;\n    for (int i = 0; i < L; i++) {\n        if (DL[i] > 0) count++;\n        if (flag) {\n            if (count > K) s = i, count = K;\n            used[i] = true;\n        } else if (count > 0) {\n            used[i] = true;\n            flag = true;\n            s = i;\n            count--;\n        }\n        if (flag && s + V * T == i + 1) flag = false;\n    }\n\n    double ans = 0;\n    for (int i = 0; i < L; i++)\n        ans += used[i] ? 1./V : 1./U;\n    printf(\"%.10f\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i, j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n    }\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<int> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<int> course(l + 2, 0);\n  for (int i = 0; i < n; i++) {\n    course[d[i]]++;\n    course[min(d[i] + t*v, l + 1)]--;\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    course[i + 1] += course[i];\n  }\n  for (int i = 0; i < l; i++) {\n    course[i + 1] = min(course[i + 1], k + 1);\n  }\n\n  for (int i = 0; i < l; i++) {\n    if(course[i] == 0 and sum > 0)sum--, course[i]++;\n    sum += max(course[i] - 1, 0);\n    course[i] = (course[i] > 0);\n  }\n  sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n  }\n  std::cout << setprecision(15) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<int> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<int> course(l, 0);\n  for (int i = 0; i < n; i++) {\n    for (int j = d[i]; j < d[i] + t*v; j++) {\n      if(j >= l)continue;\n      course[j] = min(course[j] + 1, k + 1);\n    }\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n    std::cout << course[i];\n  }\n  std::cout << setprecision(12) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tint n,K,T,U,V,L;\n\tcin>>n>>K>>T>>U>>V>>L;\n\tvint v(L+1,0);\n\trep(i,n){\n\t\tint t;\n\t\tcin>>t;\n\t\tv[t]++;\n\t}\n\tint cnt=0;\n\tint a=0;\n\tint b=0;\n\tint boost;\n\tbool f=false;\n\treep(i,1,L+1){\n\t\tif(f) a++;\n\t\telse b++;\n\t\t// cout<<boost<<endl;\n\t\tif(boost==i){\n\t\t\t// cout<<i<<endl;\n\t\t\tf=false;\n\t\t}\n\t\tif(v[i]){\n\t\t\tif(f){\n\t\t\t\tif(cnt==K){\n\t\t\t\t\tboost=i+V*T;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboost=i+V*T;\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!f&&cnt){\n\t\t\t\tcnt--;\n\t\t\t\tboost=i+V*T;\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t}\n\t// cout<<a<<\" \"<<b<<endl;\n\tcout<<(double)b/U+(double)a/V<<endl;\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(10);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct state\n{\n\tint idx;\n\tdouble time;\n\tint have;\n\tdouble limit;\n\tbool operator<(const state& right) const{\n\t\treturn time != right.time ? time > right.time : idx != right.idx ? idx > right.idx : have < right.have;\n\t}\n};\n\nint main() {\n\tint n, m;\n\tdouble effect, u, v, len;\n\tcin>> n>> m>> effect>> u>> v>> len;\n\tvector<double> boost(n);\n\tREP(i, n)\n\t\tcin>>boost[i];\n\tpriority_queue<state> Q;\n\tQ.push({ 0, boost[0] / u, 0, 0.0 });\n\tdouble ans = 0.0;\n\twhile (!Q.empty())\n\t{\n\t\tstate q = Q.top();Q.pop();\n\t\tq.have = min(q.have + 1, m+1);\n\t\tif (q.idx == n - 1) {\n\t\t\tif (q.have == m + 1)\n\t\t\t\tq.limit = 0;\n\t\t\tif (len - boost[n - 1] - (q.have*effect+q.limit)*v <= 0.0)\n\t\t\t\tQ.push({n,q.time+ (len - boost[n - 1] )/v,0,0.0});\n\t\t\telse\n\n\t\t\t\tQ.push({ n,q.time+ q.have*effect+q.limit+ (len - boost[n - 1] - (q.have*effect + q.limit)*v)/u,0,0.0 });\n\t\t\tcontinue;\n\t\t}\n\t\tif (q.idx == n) {\n\t\t\tans=q.time;\n\t\t\tbreak;\n\t\t}\n\t\t\tREP(i, q.have + 1) {//???????????°\n\t\t\t\tif (q.have - i > m)continue;\n\t\t\t\tdouble kasoku_load = (q.limit + effect*i)*v;\n\t\t\t\tif (boost[q.idx + 1] - boost[q.idx] <= kasoku_load) {\n\t\t\t\t\tQ.push({ q.idx + 1,q.time + (boost[q.idx + 1] - boost[q.idx]) / v,q.have - i,max(0.0,q.limit+effect*i - (boost[q.idx + 1] - boost[q.idx]) / v) });\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ.push({ q.idx + 1,q.time + q.limit + effect*i + (boost[q.idx + 1] - boost[q.idx] - kasoku_load) / u,q.have-i,0.0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t}\n\n\tprintf(\"%.9lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i;\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  int a[201];\n  for(i=0;i<N;++i)\n    cin>>a[i];\n  a[i]=L;\n  double rt=0,di=0,it;\n  int rf=0,cc=0,ai=0;\n  for(;ai<N+1;){\n    if(rf){\n      if(0){\n      }else if((a[ai]-di)/V+it<T){\n\trt+=(a[ai]-di)/V;\n\tif(cc==K){\n\t  it=0;\n\t}else{\n\t  it+=(a[ai]-di)/V;\n\t  ++cc;\n\t}\n\tdi=a[ai];\n\t++ai;\n      }else if((a[ai]-di)/V+it>T){\n\trt+=T-it;\n\tdi+=(T-it)*V;\n\tit=0;\n\tif(cc){\n\t  --cc;\n\t}else{\n\t  rf=0;\n\t}\n      }else{\n\trt+=T-it;\n\tdi=a[ai];\n\tit=0;\n\t++ai;\n      }\n    }else{\n      rt+=(a[ai]-di)/U;\n      di=a[ai];\n      it=0;\n      rf=-1;\n      ++ai;\n    }\n  }\n  printf(\"%.9f\\n\",rt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<bool> carrot(L+1, false);  \n  while(N--) {\n    int D; cin >> D;\n    carrot[D] = true;\n  }\n  double ans = 0.0;\n  int hold = 0, fast = 0;\n  for(int i = 1; i <= L; i++) {\n    if(fast) fast--, ans += 1.0 / V;\n    else ans += 1.0 / U;    \n    if(carrot[i]) hold++;\n    if(hold > K) hold = K, fast = T*V;\n    else if(!fast && hold > 0) hold--, fast = T*V;\n  }\n  printf(\"%.10f\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint main() {\n\tint N, K, T, U, V, L;\n\tvector<int> D;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tD.resize(N);\n\tfor(int i = 0; i < N; i++)\n\t\tcin >> D[i];\n\tsort(D.begin(), D.end());\n\tdouble res = 0;\n\tint x = 0;\n\tint g = 0;\n\tint i = 0;\n\twhile(x < L) {\n\t\tif(g) {\n\t\t\tg--;\n\t\t\tint x_ = x;\n\t\t\tx += T * V;\n\t\t\tfor(; i < D.size() && D[i] < x; i++) {\n\t\t\t\tg++;\n\t\t\t\tif(g > K) {\n\t\t\t\t\tg = K;\n\t\t\t\t\tx = D[i] + T * V;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += (double)(min(x,L) - x_) / V;\n\t\t}\n\t\telse {\n\t\t\tif(i < D.size()) {\n\t\t\t\tres += (D[i] - x) / (double)U;\n\t\t\t\tx = D[i];\n\t\t\t\tg++; i++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += (L - x) / (double)U;\n\t\t\t\tx = L;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n// #define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nvoid run(){\n    int n,k,t,u,v,l;\n    cin>>n>>k>>t>>u>>v>>l;\n    int a[l+1]={};\n    rep(i,n){\n        int d;\n        cin>>d;\n        a[d]++;\n    }\n    int s=0,q=0,w=0,c=0,tt=0;\n    REP(i,1,l){\n        (c?w:q)++;\n        if(c)c--;\n        if(!c&&tt)c=v,tt--;\n        if(!c&&!tt&&s)s--,c=v,tt=t-1;\n        if(a[i]){\n            s++;\n            if(!c)s--,c=v,tt=t-1;\n            else if(s>k)s--,c=v,tt=t-1;\n        }\n    }\n    cout<<(1.0*q/u+1.0*w/v)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,K,T,U,V,L;\nqueue<int>C;\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tC.push(t);\n\t}\n\tC.push(L);//goal\n\n\tint c=0,f=0,p=0;\n\tdouble t=0,tmp=0;\n\twhile(!C.empty()||tmp>p)\n\t{\n\t\tif(tmp<=p)\n\t\t{\n\t\t\ttmp=C.front();C.pop();\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tp+=T*V;\n\t\t\tt+=T;\n\t\t\twhile(!C.empty()&&tmp<=p)\n\t\t\t{\n\t\t\t\tc++;\n\t\t\t\tif(c>K)\n\t\t\t\t{\n\t\t\t\t\tint nr=T*V-(p-tmp);\n\t\t\t\t\tc=K;\n\t\t\t\t\tp+=nr;\n\t\t\t\t\tt+=1.0*nr/V;\n\t\t\t\t}\n\t\t\t\ttmp=C.front();\n\t\t\t\tC.pop();\n\t\t\t\tif(tmp>p)break;\n\t\t\t}\n\t\t\tif(c==0)f=0;\n\t\t\telse c--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt+=(1.0*tmp-p)/U;\n\t\t\tp=tmp;\n\t\t\tf=1;\n\t\t}\n\t}\n\tif(p>L)t-=(1.0*p-L)/V;\n\tprintf(\"%.10f\\n\",t);\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, K, T, U, V, L;\nint D[210];\n\nsigned main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    rep(i,0,N) cin >> D[i];\n    D[N] = L; N++;\n\n    int stock = 0, prev = 0, last = 0;\n    bool turbo = false;\n    double ans = 0;\n    rep(i,0,N) {\n        int d = D[i] - prev;\n        if(!turbo) {\n            ans += 1.0 * d / U;\n            last = D[i];\n        }\n        else {\n            int part = D[i] - last;\n            // printf(\"part = %lld\\n\", part);\n            if(T * V < part) {\n                // テゥツ?氾、ツクツュテ」ツ?ァテ・ツ按?」ツつ古」ツ??(テ」ツつケテ」ツδ暗」ツδε」ツつッテ」ツ?づ」ツつ凝・ツ?エテ・ツ青暗」ツ?ィテ」ツ?ェテ」ツ??・ツ?エテ・ツ青?\n                int part = last + T * V - prev;\n                int rest = d - part;\n                int need = (rest - 1) / T * V + 1;\n                int dsta = min(d, part + T * V * min(need, stock));\n                int dstb = d - dsta;\n\n                // printf(\"stock = %lld\\n\", stock);\n                // printf(\"dsta = %lld, dstb = %lld\\n\", dsta, dstb);\n\n                ans += 1.0 * dsta / V + 1.0 * dstb / U;\n                last += min(need, stock) * T * V;\n                stock -= min(need, stock);\n                // printf(\"change: last = %lld\\n\", last);\n            }\n            else {\n                ans += 1.0 * d / V;\n                if(stock == K) last = D[i];\n                else stock++;\n            }\n        }\n        // printf(\"debug: ans = %.12f\\n\", ans);\n        prev = D[i];\n        turbo = true;\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, K, T, U, V, L;\n  int carrot[10001] = {};\n\n  cin >> N >> K >> T >> U >> V >> L;\n  while(N--) {\n    int D;\n    cin >> D;\n    carrot[D]++;\n  }\n\n  double time = 0;\n  int mod = 0, hav = 0;\n  for(int i = 1; i <= L; ++i) {\n    if(mod > 0) {\n      --mod;\n      time += 1.0 / V;\n    } else {\n      time += 1.0 / U;\n    }\n\n    if(hav && mod == 0) {\n      --hav;\n      mod = V * T;\n    }\n\n    if(carrot[i]) {\n      if(mod == 0) {\n        --carrot[i];\n        mod = V * T;\n      }\n      if(hav + carrot[i] > K) {\n        --carrot[i];\n        mod = V * T;\n        hav = K;\n      } else {\n        hav += carrot[i];\n      }\n    }\n  }\n\n  cout << fixed << setprecision(10) << time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i;\n    long long j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n            if(j > l - i + 1){\n                dd += l - i;\n                break;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n        //cout << i << \" \" << dd << \" \" << j << endl;\n    }\n    //cout << dd <<endl;\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l,d[210]={0};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  int a=0,p=0,st=0;\n  for(int i=1;i<=n+1;i++){\n    if(a+st*v*t>d[i]-d[i-1]){\n      if(a>=d[i]-d[i-1])a-=d[i]-d[i-1];\n      else st-=(d[i]-d[i-1]-a)/(v*t),a=0;\n      if(st<k)st++;\n      else if(st==k)a=v*t;\n    }\n    else p+=d[i]-d[i-1]-a-st*v*t,a=v*t,st=0;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint nr,canhave,time,normal,special,distance;\n\tqueue<int> que;\n\tcin>>nr>>canhave>>time>>normal>>special>>distance;\n\tint x;\n\tfor(int i=0;i<nr;i++){\n\t\tcin>>x;\n\t\tque.push(x);\n\t}\n\tint sum=0;\n\tbool dont=false;\n\tint nowtime=0;\n\tdouble now=0;\n\tint nowhave=0,count=0;\n\tfor(int i=1;i<distance;i++){\n\t\tif(!que.empty()){\n\t\t\tint q=que.front();\n\t\t\tif(q==i){\n\t\t\t\tif(canhave>nowhave){\n\t\t\t\t\tnowhave++;\n\t\t\t\t}else{\n\t\t\t\t\tnowtime=time*special+1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(!nowtime)\n\t\t\tnow+=(double)1/normal;\n\t\telse{\n\t\t\tnow+=(double)1/special;\n\t\t\tcount++;\n\t\t\tnowtime--;\n\t\t}\n\t\tif(!nowtime&&nowhave){\n\t\t\tnowtime=time*special;\n\t\t\tnowhave--;\n\t\t}\n\t\t/*cout<<i<<\"-----\"<<nowtime<<endl;\n\t\tcout<<(double)1/normal<<endl;\n\t\t*/\n\t\tif(nowtime)\n\t\t\tsum++;\n\t}\n\t//cout<<sum<<endl;\n\t//int ans=now;\n\t//cout<<n/normal+s/special<<endl;\n\t//distance++;\n\tprintf(\"%lf\\n\",(double)(distance-sum)/normal+(double)sum/special);\n\t/*printf(\"%lf\\n\",(double)(distance-sum)/normal);\n\tprintf(\"%lf\\n\",(double)sum/special);\n\tcout<<(double)(distance-sum)/normal+(double)sum/special<<endl;\n\tcout<<(double)(distance-sum)/normal<<endl;\n\tcout<<(double)sum/special<<endl;\n\tcout<<now<<endl;\n\t//cout<<now<<endl;\n\tcout<<count<<endl;\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint main(){\n    int n,k,t,u,v,l,tmp;\n    bool car[10001];\n    cin >> n >> k >> t >> u >> v >> l;\n\n    memset(car,false,sizeof(car));\n\n    for(int i=0;i<n;i++){\n        cin >> tmp;\n        car[tmp] = true;\n    }\n\n    int stock = 0;\n    double ret = 0;\n    int rem = 0;\n    for(int i=0;i<l;i++){\n        //走り出す前チェック\n        if(rem == 0 && stock > 0){\n            rem = v*k;\n            stock--;\n        }\n\n        //にんじんチェック\n        if(car[i]){\n            if(rem == 0){\n                rem = v * k;\n            }else{\n                if(stock == k){\n                    rem = v*k;\n                }else{\n                    stock++;\n                }\n            }\n        }\n\n        if(rem > 0){\n            ret += 1.0/v;\n            rem--;\n        }else{\n            ret += 1.0/u;\n        }\n    }\n    printf(\"%.8f\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n, k, t, u, v, l;\nbool pos[100100];\ndouble dv[100100];\n\nint main() {\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) {\n\t\tint num;\n\t\tcin >> num;\n\t\tpos[num] = 1;\n\t}\n\tint w = 0;\n\tint cnt = 0;\n\tbool f = 0;\n\trep(i, l) {\n\t\tif (!f) {\n\t\t\tif (pos[i]) {\n\t\t\t\tf = 1;\n\t\t\t\tw = t*v - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (pos[i]) {\n\t\t\t\tif (cnt < k)cnt++;\n\t\t\t\telse w = t*v - 1;\n\t\t\t}\n\t\t\tif (w > 0)w--;\n\t\t\telse {\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tw += t*v;\n\t\t\t\t}\n\t\t\t\telse f = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)dv[i] = v;\n\t\telse dv[i] = u;\n\t}\n\tdouble ans = 0;\n\trep(i, l) {\n\t\tcout << i << \" \" << dv[i] << endl;\n\t\tans += (1 / dv[i]);\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, k, t, u, v, l;\n  cin >> n >> k >> t >> u >> v >> l;\n  VI d(n);\n  VI car(l+5, 0);\n  REP(i, n) cin >> d[i], d[i]--, car[d[i]] = 1;\n\n  int pos = -1, c = 0;\n  double res = 0;\n  REP(i, l) {\n    // cout << i << \" \" << res << \" \" << pos << \" \" << c << endl;\n    // にんじんがある場所なら\n    if(car[i]) {\n      // 使ってる\n      if(i <= pos) {\n        // 使う\n        if(c == k) {\n          pos = i + v*t - 1;\n        }\n        // 使わない\n        else {\n          c++;\n        }\n      }\n      // 使ってない\n      else {\n        // 使う\n        pos = i + v*t - 1;\n      }\n    }\n\n    if(i > pos && c > 0) {\n      pos = i + v*t - 1;\n      c--;\n    }\n\n    // 使ってるなら\n    if(i <= pos) {\n      // cout << \"used\" << endl;\n      res += 1.0/v;\n    }\n    // 使ってないなら\n    else {\n      res += 1.0/u;\n    }\n  }\n\n  cout << fixed << setprecision(9) << res << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<bool> carrot(L+1, false);  \n  while(N--) {\n    int D; cin >> D;\n    carrot[D] = true;\n  }\n  double ans = 0.0;\n  int hold = 0, fast = 0;\n  for(int i = 1; i <= L; i++) {\n    if(carrot[i]) hold++;\n    if(hold > K) hold = K, fast = T*V;\n    else if(!fast && hold > 0) hold--, fast = T*V;\n    if(fast) fast--, ans += 1.0 / V;\n    else ans += 1.0 / U;\n  }\n  printf(\"%.10f\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nint main()\n{\n   int N, K, T, U, V, L;\n   cin >> N >> K >> T >> U >> V >> L;\n   int d[N + 1];\n   rep(i, N)\n   {\n       cin >> d[i];\n   }\n   d[N] = L;\n   int hav = 0;\n   int nextDist = 0;\n   double m = 0;\n   rep(c, N + 1)\n   {\n       // cerr << nextDist << \",\" << c << \",\" << m << endl;\n       if (nextDist <= d[c])\n       {\n           if (hav >= 1)\n           {\n               nextDist = nextDist + V * T;\n               c--;\n               hav--;\n           }\n           else\n           {\n               if (c != N)\n                   nextDist = d[c] + V * T;\n           }\n       }\n       else\n       {\n           if (hav + 1 <= K)\n           {\n               if (c != N) hav++;\n               else m += nextDist - d[c];\n           }\n           else\n           {\n               m += nextDist - d[c];\n               if (c != N)\n                   nextDist = d[c] + V * T;\n           }\n       }\n      // cout << m << endl;\n      // cout << (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U << endl;\n   }\n\n   m += hav * V * T;\n   // cout << 1 << \"+\" << (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U << endl;\n   // cout << 1 << \"+\" << (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U << endl;\n   double ans = (double)(N * V * T - m) / (double)V + (double)(L - (N * V * T - m)) / (double)U;\n   printf(\"%0.10lf\\n\", ans);\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \n#define MAX_N 201\n#define MAX_L 10001\n#define INF 1e9\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n#define FOR(i,a,b) for(int i = a ; i < b ; i++)\n#define all(p) (p).begin(),(p).end() \n \ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n \nint N,K,T,U,V,L;\nbool road[MAX_L];\n \ndouble getTime(double v){\n    return (double)L / v;\n}\n \ndouble solve(){\n    int speed = 0, carr = 0;\n    double res = 0;\n \n    rep(i,L){\n\tif(road[i]){\n\t    carr++;\n\t}\n\tif(speed == 0 && carr > 0){\n\t    carr--;\n\t    speed = V*T;\n\t}\n\tif(carr > K){\n\t    carr--;\n\t    speed = V*T;\n\t}\n\tif(speed > 0){\n\t    speed--;\n\t    res += 1./ V;\n\t}else{\n\t    res += 1./ U;\n\t}\n    }  \n    return res;\n}\n \nint main(){\n    int D;\n    memset(road,false,sizeof(road));\n    cin >> N >> K >> T >> U >> V >> L;\n    rep(i,N){\n\tcin >> D;\n\troad[D] = true;\n    }\n    printf(\"%.8f\\n\",solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main()\n{\n    int n, k, t, u, v, l;\n    cin >> n;\n    cin >> k;\n    cin >> t;\n    cin >> u;\n    cin >> v;\n    cin >> l;\n    int d[n];\n    for(int i = 0; i < n; i++){\n        cin >> d[i];\n    }\n\n    const int boost_length = v * t;\n\n    int distance = 0;\n    int slow_distance = 0;\n    int carot_num = 0;\n    int reached_point;\n\n    /*1本目の人参まで*/\n    distance += d[0];\n    slow_distance += d[0];\n    carot_num++;\n    reached_point = 0;\n\n    /*2本目以降*/\n    while(distance < l){\n        if(carot_num == 0){\n            if(reached_point == (n-1)){\n                slow_distance += l - distance;            \n                distance = l;\n            } else {\n                reached_point++;\n                slow_distance += d[reached_point] - distance;\n                distance = d[reached_point];\n                carot_num++;\n            }\n        } else {\n            int old_distance = distance;\n            distance += boost_length;\n            int old_point = reached_point;\n            for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n            }\n            reached_point--;\n            carot_num += reached_point - old_point - 1;\n            while(1){\n                if(carot_num <= k){\n                    break;\n                }\n                distance += d[reached_point] - old_distance;\n                old_point = reached_point;\n                for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n                }\n                reached_point--;\n                carot_num += reached_point - old_point - 1;\n                if(distance >= l){\n                    break;\n                }\n            }\n        }\n    }\n    double time = 0;\n    int rest1 = slow_distance % u;\n    int rest2 = (l - slow_distance) % v;\n    time += rest1  *1.0 / u;\n    time += rest2 *1.0 / v;\n    time += slow_distance / u;\n    time += (l - slow_distance) / v;\n    cout << fixed << setprecision(9) << time << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,K,T,U,V,L;\nqueue<int>C;\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tC.push(t);\n\t}\n\tC.push(L);//goal\n\n\tint c=0,f=0,p=0;\n\tdouble t=0,tmp=0;\n\twhile(!C.empty()||tmp>p)\n\t{\n\t\tif(tmp<=p)\n\t\t{\n\t\t\ttmp=C.front();C.pop();\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tp+=T*V;\n\t\t\tt+=T;\n\t\t\twhile(!C.empty()&&tmp<p)\n\t\t\t{\n\t\t\t\tc++;\n\t\t\t\tif(c>K)\n\t\t\t\t{\n\t\t\t\t\tint nr=T*V-(p-tmp);\n\t\t\t\t\tc=K;\n\t\t\t\t\tp+=nr;\n\t\t\t\t\tt+=1.0*nr/V;\n\t\t\t\t}\n\t\t\t\ttmp=C.front();\n\t\t\t\tC.pop();\n\t\t\t\tif(tmp>p)break;\n\t\t\t}\n\t\t\tif(c==0)f=0;\n\t\t\telse c--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt+=(1.0*tmp-p)/U;\n\t\t\tp=tmp;\n\t\t\tf=1;\n\t\t}\n\t}\n\tif(p>L)t-=(1.0*p-L)/V;\n\tprintf(\"%.10f\\n\",t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n\n    vector<int> d(n);\n    for(int i=0; i<n; ++i)\n        cin >> d[i];\n    d.push_back(l);\n\n    double ret = 0.0;\n    int carrot = 0;\n    int pos = 0;\n    int i = 0;\n    for(;;){\n        if(carrot == 0){\n            int len = d[i] - pos;\n            ret += len / (double) u;\n            pos = d[i];\n\t\t\t++ i;\n            ++ carrot;\n        }\n\n\t\t-- carrot;\n        int nextPos = pos + v * t;\n        if(nextPos >= l){\n            int len = l - pos;\n            ret += len / (double) v;\n            break;\n        }\n\t\tpos = nextPos;\n\n        ret += t;\n        while(i < n && d[i] < pos){\n            if(carrot < k)\n                ++ carrot;\n\t\t\telse{\n\t\t\t\tint newPos = d[i] + t * v;\n\t\t\t\tif(newPos > pos){\n\t\t\t\t\tret += (newPos - pos) / (double) v;\n\t\t\t\t\tpos = newPos;\n\t\t\t\t}\n\t\t\t}\n            ++ i;\n        }\n    }\n\n    printf(\"%.10f\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int n,k,t,u,v,L;\n    scanf(\" %d %d %d %d %d %d\", &n, &k, &t, &u, &v, &L);\n    vector<int> d(n);\n    rep(i,n) scanf(\" %d\", &d[i]);\n\n    int idx=0;\n    int st=-1;\n    int stock=0;\n    double ans=0;\n\n    bool boost=false;\n\n    rep(i,L)\n    {\n        // printf(\"i=%d , boost? %d\\n\", i,(int)boost);\n\n        if(boost) ans+=1.0/v;\n        else ans+=1.0/u;\n\n        if(idx<n && d[idx]==i)\n        {\n            if(stock<k) ++stock;\n            else st=i;\n\n            ++idx;\n        }\n\n        if(!boost && stock>0)\n        {\n            boost=true;\n            --stock;\n            st=i;\n        }\n\n        if(st+t*v==i)\n        {\n            st=false;\n            boost=false;\n        }\n    }\n\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2298\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long double real;\n\nconst int NMAX = 300, LMAX = 100000;\nconst int KMAX = NMAX;\nint N, K, T, U, V, L;\nbool D[LMAX], accel[LMAX];\n\nreal solve() {\n  int bag = 0, limit = 0;\n  for (int x = 0; x < L; x++) {\n    if (D[x]) {\n      if (limit == 0) {\n        limit = V * T;\n      } else if (bag == K) {\n        limit = V * T;\n      } else {\n        bag++;\n      }\n    }\n\n    if (limit == 0 and bag > 0) {\n      bag--;\n      limit = V * T;\n    }\n    \n    if (limit > 0) {\n      limit--;\n      accel[x] = true;\n    } \n  }\n\n  int u = 0, v = 0;\n  REP(x, L) {\n    if (accel[x]) {\n      v++;\n    } else {\n      u++;\n    }\n  }\n\n  return ((real) u) / U + ((real) v) / V;\n}\n\nint main() {\n  cin >> N >> K >> T >> U >> V >> L;\n  REP(x, N) {\n    int d; cin >> d;\n    D[d] = true;\n  }\n\n  cout << fixed <<  setprecision(20) << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, K, T, U, V, L;\nbool point[10010];\n\nsigned main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    rep(i,0,N) {\n        int p; cin >> p;\n        point[p] = true;\n    }\n\n    int stock = 0, prev = -1, da = 0, db = 0;\n    repq(i,1,L) {\n        if((prev < 0 || prev + T*V < i) && stock) prev = i-1, stock--;\n        // printf(\"point = %lld, prev = %lld\", i, prev);\n\n        (prev < 0 || prev + T*V < i ? da : db)++;\n        // cout << \" \" << (prev < 0 || prev + T*V < i ? \"x\" : \"o\") << endl;\n        if(point[i]) {\n            if(stock == K) prev = i;\n            else stock++;\n        }\n    }\n    // printf(\"da = %lld, db = %lld\\n\", da, db);\n    double ans = 1.0 * da / U + 1.0 * db / V;\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N,K,T,L;\n  double U,V;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N+1,0);\n  D[N+1]=0;\n  for(int i=0;i<N;++i){\n    cin >> D[i];\n  }\n  double Time=0;\n  int pos=0;\n  int Npos=0;\n  int until=0;\n  while(pos < L){\n    if(pos==D[Npos]){\n      ++Npos;\n      until+=T*V;\n      if(until+T*V>(K+1)*T*V){\n\tuntil=(K+1)*T*V;\n      }\n    }\n    //cout << \"proceed\" << endl;\n\n    if(until==0){\n      Time+=1/U;\n    }else{\n      Time+=1/V;\n      --until;      \n    }\n    pos+=1;\n  }\n  cout << Time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n,k,now;\n  double u,v,t,l,d[200],ans;\n  while(cin >> n >> k >> t >> u >> v >> l){\n    for(int i=0;i<n;i++) cin >> d[i];\n    ans = d[0] / u;\n    for(int i=0;i<n;i++){\n      int j = i + 1;\n      double cnt;\n      now = 0;\n      for(cnt=1;now>=0;cnt++){\n\tfor(;j<n;j++){\n\t  if(d[i] + t * v * cnt <= d[j]) break;\n\t  if(now < k) now++;\n\t  else cnt += 1.0 - (d[j] - d[j-1]) / (t * v);\n\t}\n\tnow--;\n      }\n      cnt--;\n\n      if(j >= n){\n\tif(d[i] + t * v * cnt >= l) ans += (l - d[i]) / v;\n\telse ans += t * cnt + (l - (d[i] + t * v * cnt)) / u;\n      } else ans += t * cnt + (d[j] - (d[i] + t * v * cnt)) / u;\n      i = j;\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\tint N, K, T, U, V, L;\n\tcin>>N>>K>>T>>U>>V>>L;\n\tvector<int> D(N);\n\tREP(i, N) cin>>D[i];\n\tdouble ans = 0;\n\tint roc = 0;\n\tint stock = 0;\n\tint rem = T;\n\twhile(roc < L) {\n\t\tint nroc;\n\t\tif(stock >= 1) {\n\t\t\tnroc = min(roc + V, L);\n\t\t\t--rem;\n\t\t\tint nstock = min(stock + (int)(upper_bound(ALL(D), nroc) - lower_bound(ALL(D), roc + 0.0000001)), K + 1);\n\t\t\tif(stock + (int)(upper_bound(ALL(D), nroc) - lower_bound(ALL(D), roc + 0.0000001)) > K + 1) {\n\t\t\t\trem = T;\n\t\t\t\tnroc = *(upper_bound(ALL(D), nroc) - 1);\n\t\t\t}\n\t\t\tstock = nstock;\n\t\t\tans += (nroc - roc) / (double)V;\n\t\t\tif(rem == 0) {\n\t\t\t\t--stock;\n\t\t\t\trem = T;\n\t\t\t}\n\t\t} else {\n\t\t\tnroc = min(roc + U, L);\n\t\t\tif(0 < (upper_bound(ALL(D), nroc) - lower_bound(ALL(D), roc + 0.0000001))) {\n\t\t\t\tnroc = *lower_bound(ALL(D), roc + 0.0000001);\n\t\t\t\t++stock;\n\t\t\t\trem = T;\n\t\t\t}\n\t\t\tans += (nroc - roc) / (double)U;\n\t\t}\n\t\t//cout<<ans<<\" \"<<nroc<<endl;\n\t\troc = nroc;\n\t}\n\tcout<<fixed<<showpoint<<setprecision(10)<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int n, k, l;\n    double t, u, v, d[200];\n    \n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i, n){\n        cin >> d[i];\n    }\n    \n    double ans = 0.0;\n    int boost_time = 0, ninjin_p = 0, boost_cnt = 0;\n    for(int i = 1; i <= l; i++){\n        if(boost_time){\n            ans += 1.0 / v + 1e-10;\n            boost_time--;\n        }\n        else{\n            ans += 1.0 / u + 1e-10;\n        }\n        \n        if(i == d[ninjin_p]){\n            if(boost_time >= k * v){\n                boost_time = (k + 1) * v;\n            }\n            else{\n                boost_time += v;\n            }\n            if(ninjin_p < n - 1)ninjin_p++;\n        }\n    }\n    \n    printf(\"%.11lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    double k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n\n    double c[205];\n    rep(i,n) cin >> c[i];\n    c[n] = l;\n\n    double m, h, s; //?????¨???????????????????????°????????????????????????\n    double time = 0;\n    int i = 0;\n    while(m < l){\n        double next = c[i] - m;\n        if((h > 0 && s == 0) || h > k){\n            h--;\n            s = t;\n        }\n\n\n        if(h == 0 && s == 0){\n            time += next / u;\n            m += next;\n            i++;\n            h++;\n        }else if(s > 0){\n            if(next / v <= s){\n                s -= next / v;\n                time += next / v;\n                m += next;\n                i++;\n                h++;\n            }else{\n                m += s * v;\n                time += s;\n                s = 0;\n            }\n        }\n    }\n    cout <<fixed << setprecision(8) <<  time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double ans = 0.0;\n\n    int speed = U;\n    int acceledDistance = 0;\n    int d_sub = 0;\n    int nowStock = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    for(int i = 1; i <= L; i++)\n    {\n        bool isEat = false;\n        bool walk = false;\n\n        if(acceledDistance > 0)\n        {\n            --acceledDistance;\n            speed = V;\n        }\n        else\n        {\n            speed= U;\n        }\n\n\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n\n            if(speed == U)isEat = true;\n            else\n            {\n                if(nowStock < K)nowStock++;\n                else isEat = true;\n            }\n        }\n        else if(speed == U)\n        {\n            if(nowStock > 0)\n            {\n                --nowStock;\n                isEat = true;\n            }\n        }\n\n        if(isEat)\n        {\n            acceledDistance = T * V;\n        }\n\n        ans += 1.0 / speed;\n    }\n    printf(\"%.6lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <iostream>\n \n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n//#include <tuple>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <complex>\n#include <cassert>\n \nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n//typedef tuple<int, int, int> T;\ntypedef pair<ll, ll> Pl;\n//typedef tuple<ll, ll, ll> Tl;\n \n \n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n \n//config\n//#define NDEBUG\n \n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n \ntemplate<class T> inline string toString(const vector<T>& x) {\n    stringstream ss;\n    REP(i,x.size()){\n        if(i!=0)ss<<\" \";\n        ss<< x[i];\n    }\n    return ss.str();\n}\n \ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n    stringstream ss;\n    REP(i,map.size()){\n        if(i!=0)ss<<BR;\n        ss<< toString(map[i]);\n    }\n    return ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n    string res;stringstream ss;\n    for(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n    return ss.str();\n}\n \n \n \nnamespace Ps{\n    const double EPS=1e-8,INF=1e12;\n#define X real()\n#define Y imag()\n    typedef complex<double> P;\n}\nusing namespace Ps;\nnamespace Ls{\n    struct L:public vector<P>{\n        L(const P&a,const P&b){\n            push_back(a);push_back(b);\n        }\n    };\n}\nusing namespace Ls;\n \n \nclass Seg{\npublic:\n    double l,r;\n    Seg(double l,double r):l(l),r(r){\n    }\n \n    bool operator < (const Seg& rt) const{\n        return l<rt.l;\n    }\n};\n \nint main() {\n    int H,W;cin >> H >> W;\n    vector<string> board(H+2);\n\n    board[0]=string(W+2,'.');\n     \n    for(int y=1;y<=H;y++){\n    \tboard[y]=string(W+2,'.');\n    \tstring s;cin >> s;\n    \tfor(int i=1;i<=W;i++)board[y][i]=s[i-1];\n    }\n    board[H+1]=string(W+2,'.');\n   \n    vector<L> ls;\n \n    // -\n    for(int y=1;y<=H+1;y++){\n        int x=1;\n        for(;x<=W;x++){\n            if(board[y-1][x]=='.' && board[y][x]=='#'){\n                P p1(H-(y-1),x-1);\n                x++;\n                while(board[y-1][x]=='.' && board[y][x]=='#'){\n                    x++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                x--;\n            }\n            if(board[y-1][x]=='#' && board[y][x]=='.'){\n                P p1(H-(y-1),x-1);\n                x++;\n                while(board[y-1][x]=='#' && board[y][x]=='.'){\n                    x++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                x--;\n            }\n        }\n    }\n \n    // |\n    for(int x=1;x<=W+1;x++){\n        int y=0;\n        for(;y<=H;y++){\n            if(board[y][x]=='.' && board[y][x+1]=='#'){\n                P p1(H-(y-1),x-1);\n                y++;\n                while(board[y][x]=='.' && board[y][x+1]=='#'){\n                    y++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                y--;\n            }\n            if(board[y][x]=='#' && board[y][x+1]=='.'){\n                P p1(H-(y-1),x-1);\n                y++;\n                while(board[y][x]=='#' && board[y][x+1]=='.'){\n                    y++;\n                }\n                P p2(H-(y-1),x-1);\n                ls.push_back(L(p1,p2));\n                y--;\n            } \n        }\n    }\n \n    // for(int i=0;i<ls.size();i++){\n    //  cout << ls[i][0]<<\" \" <<ls[i][1]<<endl;\n    // }\n \n    // DUMP(ls.size());\n    // //DUMP(toString())\n \n    vector<Seg> ss;\n    for(int i=0;i<ls.size();i++){\n        ss.push_back(Seg(min(arg(ls[i][0]),arg(ls[i][1])+EPS),1));\n        ss.push_back(Seg(max(arg(ls[i][0]),arg(ls[i][1])-EPS),-1));     \n    } \n    sort(ss.begin(),ss.end());\n \n \n    int Mv=0,v=0;\n    for(int i=0;i<ss.size();i++){\n        v+=ss[i].r;\n        Mv=max(Mv,v);\n    }\n \n    cout << (Mv/2 + 1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main(void)\n{\n\tint N, K, T, V, U, L;\n\tdouble eat_d, distance;\n\tdouble result = 0.0;\n\tint c_num = 0, eat_num;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(N);\n\trep(i, N){\n\t\tcin >> D[i];\n\t}\n\trep(i, N){\n\t\tif (i == 0){\n\t\t\teat_d = (double)D[i];\n\t\t\tresult += eat_d / U;\n\t\t}else{\n\t\t\teat_num = 0;\n\t\t\tdistance = (double)D[i] - eat_d;\n\t\t\twhile(c_num > 0 && distance > (double)V*T*(eat_num+1)){\n\t\t\t\tc_num--;\n\t\t\t\teat_num++;\n\t\t\t}\n\t\t\tresult += (double)T*eat_num;\n\t\t\teat_d += (double)V*T*eat_num;\n\n\t\t\tdistance = (double)D[i] - eat_d;\n\t\t\tif (distance > (double)V*T){\n\t\t\t\tresult += (double)T + (distance-(double)V*T) / U;\n\t\t\t\teat_d = (double)D[i];\n\t\t\t}else if(c_num == K){\n\t\t\t\tresult += distance / V;\n\t\t\t\teat_d = (double)D[i];\n\t\t\t}else{\n\t\t\t\tc_num++;\n\t\t\t}\n\t\t}\n\t}\n\n\teat_num = 0;\n\tdistance = (double)L - eat_d;\n\tcout << eat_d << endl;\n\twhile(c_num > 0 && distance > (double)V*T*(eat_num+1)){\n\t\tc_num--;\n\t\teat_num++;\n\t}\n\tresult += (double)T*eat_num;\n\teat_d += (double)V*T*eat_num;\n\n\tdistance = (double)L - eat_d;\n\tif (distance > (double)V*T){\n\t\tresult += (double)T + (distance-(double)V*T) / U;\n\t}else{\n\t\tresult += distance / V;\n\t}\n\n\tcout << fixed << setprecision(9) << result << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,cnt,x,ans;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++){\n    cin>>d;\n    s[d]=true;\n  }\n  for(int i=0;i<=l;i++){\n    if(s[i]){\n      if(!x||k==cnt)x=v*t;\n      else if(k>cnt)cnt++;\n    }\n    else if(!x&&cnt>0)cnt--,x=v*t;\n    if(x>0)ans++,x--;\n  }\n  printf(\"%.8f\\n\",ans*1.0/v+(l-ans)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(6);\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    vector<int> D(N);\n    for(int i = 0; i < N; i++) cin >> D[i];\n    double ans = 0;\n    double ut = 1.0 / U, vt = 1.0 / V;\n    int carrot = 0, pos = 0, dist;\n    bool accel = false;\n    for(int now = 0; now < L; now++)\n    {\n        if(pos < N && now == D[pos])\n        {\n            carrot++; \n            pos++;\n        }\n        if(carrot > K)\n        {\n            accel = true;\n            carrot--;\n            dist = V * T;\n        }\n        else if(not accel && carrot > 0)\n        {\n            accel = true;\n            carrot--;\n            dist = V * T;\n        }\n        if(accel)\n        {\n            ans += vt;\n            dist--;\n            if(dist == 0) accel = false;\n        }\n        else ans += ut;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,k,t,u,v,l;\n  cin >> n >> k >> t >> u >> v >> l;\n  int d[n+1];\n  REP(i,n)\n    cin >> d[i];\n  d[n] = l;\n  int have = 0;\n  int now = 0;\n  double acctime = 0;\n  double res = 0;\n  REP(i,n+1) {\n    double dis = d[i] - now;\n    while(1) {\n//      printf(\"%d, %f %f\\n\", have, dis, acctime);\n      if (dis < v*acctime) {\n//        cout << \"hoge\" << endl;\n        acctime -= dis / v;\n        res += dis / v;\n        dis = 0;\n//        cout << acctime << endl;\n        break;\n      } else {\n        res += acctime;\n        dis -= acctime*v;\n//        cout << \"dis = \" << dis << endl;\n        if (have) {\n          have--;\n          acctime = t;\n        } else {\n          break;\n        }\n//        cout << res << \" \" << acctime << endl;\n      }\n    }\n    res += dis / u;\n    have++;\n    if (have == k+1) {\n      acctime = t;\n      have--;\n    }\n    now = d[i];\n//    cout << \"res = \"<< res << endl;\n  }\n  printf(\"%.12f\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int n,k,t,u,v,L;\n    scanf(\" %d %d %d %d %d %d\", &n, &k, &t, &u, &v, &L);\n    vector<int> d(n);\n    rep(i,n) scanf(\" %d\", &d[i]);\n\n    int idx=0;\n    int st=-1;\n    int stock=0;\n    double ans=0;\n\n    bool boost=false;\n\n    rep(i,L)\n    {\n        if(idx<n && d[idx]==i)\n        {\n            if(stock<k) ++stock;\n            else st=i;\n\n            ++idx;\n        }\n\n        if(!boost && stock>0)\n        {\n            boost=true;\n            --stock;\n            st=i;\n        }\n\n        if(st+t*v==i)\n        {\n            st=false;\n            boost=false;\n        }\n\n        if(boost) ans+=1.0/v;\n        else ans+=1.0/u;\n    }\n\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-12\n\nstruct Node {\n\tdouble t;\n\tdouble rest;\n\tint x;\n};\n\nbool operator >(Node& n1, Node& n2) {\n\treturn n1.t > n2.t;\n}\n\ntypedef long long ll;\n\nint main() {\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<int> d(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> d[i];\n\t}\n\td.push_back(L);\n\n\tll rest = 0;\n\tint x = 0;\n\tdouble t = 0;\n\tfor (int i = 0; i < N+1; ++i) {\n\t\tint dx = d[i]-x;\n\t\tif (rest >= dx) {\n\t\t\tt += (double)dx/V;\n\t\t\trest -= dx;\n\t\t}\n\t\telse {\n\t\t\tt += (double)rest/V;\n\t\t\tt += (double)(dx - rest)/U;\n\t\t\trest = 0;\n\t\t}\n\n\t\trest += (ll)T * V;\n\t\tif (rest >= (ll)K * (T + 1) * V) rest = (ll)K * (T + 1) * V;\n\n\t\tx = d[i];\n\t}\n\tprintf(\"%.10f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nconst int INF = 100000000;\n\nstruct Edge {\n    int to, from;\n    ll cost;\n    Edge(int from, int to, ll cost): from(from), to(to), cost(cost) {}\n};\n\nclass UnionFind {\npublic:\n    vector <ll> par; \n    vector <ll> siz; \n\n    UnionFind(ll sz_): par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n\n    ll root(ll x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) { \n        return root(x) == root(y);\n    }\n\n    ll size(ll x) { \n        return siz[root(x)];\n    }\n};\n\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    bool c = false;\n    while(n){\n        if(n&1) res = res * x;\n\n        if(res > mod){\n            c = true;\n            res %= mod;\n        }\n        x = x * x %mod;\n        n >>= 1;\n    }\n    if(c) return mod;\n    return res;\n}\n\n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid make_sieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n\nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n\ntemplate<typename T>\nvector<T> gauss_jordan(const vector<vector<T>>& A, const vector<T>& b){\n    int n = A.size();\n    vector<vector<T>> B(n, vector<T>(n+1));\n\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            B[i][j] = A[i][j];\n        }\n    }\n\n    for(int i=0; i<n; ++i) B[i][n] = b[i];\n\n    for(int i=0; i<n; ++i){\n        int pivot = i;\n        for(int j=i; j<n; ++j){\n            if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n        }\n        swap(B[i], B[pivot]);\n\n        if(abs(B[i][i]) < EPS) return vector<T>(); //解なし\n\n        for(int j=i+1; j<=n; ++j) B[i][j] /= B[i][i];\n        for(int j=0; j<n; ++j){\n            if(i != j){\n                for(int k=i+1; k<=n; ++k) B[j][k] -= B[i][j] * B[i][k];\n            }\n        }\n    }\n\n    vector<T> x(n);\n\n    for(int i=0; i<n; ++i) x[i] = B[i][n];\n    return x;\n    \n}\n\nll GCD(ll a, ll b){\n    if(a<b) swap(a,b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat mat_pow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n\n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n\n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nbool operator<(const pii& a, const pii& b){\n    if(a.first == b.first) return a.second < b.second;\n    return a.first < b.first;\n}\n\nconst int MAX = 510000;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint bit[1000010];\nint sum(int i){\n    int s = 0;\n    while(i > 0){\n        s += bit[i];\n        i -= i & -i;\n    }\n    return s;\n}\nvoid add(int i, int x){\n    while(i <= 1000010){\n        bit[i] += x;\n        i += i & -i;\n    }\n}\nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n\nint road[10010];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    \n    int n,k,t,u,v,l; cin>>n>>k>>t>>u>>v>>l;\n\n    REP(i, n){\n        int d; cin >> d;\n        road[d]++;\n    }\n\n    int have = 0;\n    double ans = 0;\n    int res = 0, prev = 0, npos = 0;\n\n    for(int i=1; i<=l; i++){\n        if(res){\n            res--;\n            ans += (double)1/v;\n        }else ans += (double)1/u;\n\n        if(have && !res) {\n            have--;\n            res = v*t;\n        }\n\n        if(road[i]){\n            if(!res){\n                road[i]--;\n                res = v*t;\n            }\n            if(have + road[i] > k){\n                road[i]--;\n                res = v*t;\n                have = k;\n            }else have += road[i];\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\nint n,k,t,v1,v2,l;\nbool ari[11111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>k>>t>>v1>>v2>>l;\n\trep(i,n){\n\t\tint d;\n\t\tcin>>d;\n\t\tari[d]=true;\n\t}\n\tint dista=0,distb=0;\n\tint cnt=0;\n\tint restd=0;\n\trep(a,l){\n\t\tif(ari[a]){\n\t\t\tcnt++;\n\t\t\tif(cnt>k){\n\t\t\t\tcnt=k;\n\t\t\t\trestd=t*v2;\n\t\t\t}\n\t\t}\n\t\tif(restd==0&&cnt>0){\n\t\t\tcnt--;\n\t\t\trestd=t*v2;\n\t\t}\n\t\tif(restd>0){\n\t\t\trestd--;\n\t\t\tdistb++;\n\t\t}else{\n\t\t\tdista++;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", (double)dista/v1+(double)distb/v2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main(void)\n{\n\tint N, K, T, U, V, L;\n\tint eat_d;\n\tint distance;\n\tint carrot = 0;\n\tdouble result = 0.0;\n\tcin >> N >> K >>T >> U >> V >> L;\n\trep(i, N){\n\t\tint D;\n\t\tcin >> D;\n\t\tif (i == 0){\n\t\t\tresult += (double)D / U;\n\t\t\teat_d = D;\n\t\t}else{\n\t\t\tdistance = D - eat_d;\n\t\t\twhile(distance > V*T && carrot >= 1){\n\t\t\t\tcarrot--;\n\t\t\t\tresult += (double)T;\n\t\t\t\teat_d += V*T;\n\t\t\t\tdistance = D - eat_d;\n\t\t\t}\n\t\t\t\n\t\t\tif (distance > V*T){\n\t\t\t\tresult += (double)T + (double)(distance - V*T) / U;\n\t\t\t\teat_d = D;\n\t\t\t}else if(carrot == K){\n\t\t\t\tresult += (double)distance / V; \n\t\t\t\teat_d = D;\n\t\t\t}else{\n\t\t\t\tcarrot++;\n\t\t\t}\n\t\t}\n\t}\n\n\tdistance = L - eat_d;\n\twhile(distance > V*T && carrot >= 1){\n\t\tcarrot--;\n\t\tresult += (double)T;\n\t\teat_d += V*T;\n\t\tdistance = L - eat_d;\n\t}\n\n\tif (distance > V*T){\n\t\tresult += (double)T + (double)(distance - V*T) / U;\n\t}else{\n\t\tresult += (double)distance / V;\n\t}\n\tcout << fixed << setprecision(9) << result << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//06\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nenum E{\n  cr,gl,dc\n};\n\nstruct DE{\n  int d;\n  E e;\n  bool operator<(DE a)const{\n    if(d!=a.d){\n      return d>a.d;\n    }else{\n      e<a.e;\n    }\n  }\n};\n\nint main(){\n  int n,k,t,u,v,l;\n  cin>>n>>k>>t>>u>>v>>l;\n  priority_queue<DE> que;\n  while(n--){\n    DE d={0,cr};\n    cin>>d.d;\n    que.push(d);\n  }\n  DE g={l,gl};\n  que.push(g);\n  int cc=0;\n  double ct=0;\n  int cp=0;\n  bool ac=false;\n  int dcc=0;\n  for(;;){\n    DE c=que.top();\n    que.pop();\n    ct+=(c.d-cp)*1./(ac?v:u);\n    cp=c.d;\n    if(c.e==gl){\n      break;\n    }else if(c.e==cr){\n      if(cc<k){\n\tcc++;\n      }else{\n\tDE nd={cp+v*t,dc};\n\tque.push(nd);\n\tdcc++;\n      }\n    }else{\n      dcc--;\n      ac=dcc;\n    }\n    if(!ac&&cc){\n      cc--;\n      ac=true;\n      DE nd={cp+v*t,dc};\n      que.push(nd);\n      dcc++;\n    }\n  }\n  cout<<fixed<<ct<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int N,K,T,U,V,L;\n  while(cin>>N>>K>>T>>U>>V>>L){\n    vector<double> D(N);\n    REP(i, N) cin>>D[i];\n    int cur_idx = 0;\n    double now_d = 0;\n    double ans = 0;\n    int have = 0;\n    while(true){\n      //printf(\"distance:%f time:%f\\n\", now_d, ans);\n      if(now_d >= L) break;\n      if(have > 0){\n        have--;\n        double to = now_d + (double)V * T;\n        if(to < L){\n          double arrive = to;\n          while(cur_idx < N && D[cur_idx] <= to){\n            have++;\n            if(have == K + 1){\n              arrive = D[cur_idx];\n              cur_idx++;\n              break;\n            }\n            cur_idx++;\n          }\n          ans += (arrive-now_d)/V;\n          now_d = arrive;\n        }else{\n          double d = L - now_d;\n          ans += d/V;\n          now_d = L;\n        }\n      }else{\n        if(cur_idx < N){\n          //printf(\"go to D[%d](%f)\\n\", cur_idx, D[cur_idx]);\n          double d = D[cur_idx] - now_d;\n          ans += d/U;\n          have = 1;\n          now_d = D[cur_idx];\n          cur_idx++;\n        }else{\n          double d = L - now_d;\n          ans += d/U;\n          now_d = L;\n        }\n      }\n    }\n    printf(\"%.9f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,k,t,u,v,L;\n  int d;\n  int vm=0,nm,nk=0,lk;\n  cin>>n>>k>>t>>u>>v>>L;\n  cin>>d;\n  nm=d;\n  lk=d;\n  for(int i=1;i<n;i++) {\n    cin>>d;\n    if(nk<k) nk++;\n    else if(lk+v > d){\n      vm+=d-lk;\n      lk=d;\n    }\n    else {\n      while(lk+v<d && nk!=0){\n\tvm+=v;\n\tlk+=v;\n\tnk--;\n      }\n      nk++;\n    }\n    nm=d;\n  }\n  if(L-d<nk*v+v) vm+=L-d;\n  else vm+= nk*v+v;\n  //cout<<vm<<endl;\n  printf(\"%.10f\\n\",(double)vm/v+(double)(L-vm)/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<int> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<int> course(l, 0);\n  for (int i = 0; i < n; i++) {\n    for (int j = d[i]; j < d[i] + t*v; j++) {\n      if(j >= l)continue;\n      course[j] = min(course[j] + 1, k + 1);\n    }\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n  }\n  std::cout << setprecision(12) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// l:距離, v:速さ, かかる時間を返す.\ndouble f(double l, double v){\n\treturn l / v;\n}\n\ntypedef pair<double,int> P;\nconst int CARROT = 1;\nconst int SLOW = 2;\nconst int GOAL = 3;\n\nint main(){\n\tint N, K, T, U, V, L;\n\tscanf(\"%d %d %d %d %d %d\", &N, &K, &T, &U, &V, &L);\n\t\n\tvector<int> D(N);\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push( P(L,GOAL) );\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tscanf(\"%d\", &D[i]);\n\t\tq.push( P(D[i],CARROT) );\n\t}\n\t\n\tdouble x=0.0, v = U, t=0.0, k=0, carrot=0;\n\twhile( !q.empty() ){\n\t\tif( q.top().second == CARROT ){ // 次の位置がニンジンのとき\n\t\t\tdouble l = q.top().first - x; // 移動する距離\n\t\t\tx = q.top().first; // 次の位置\n\t\t\tt += f(l,v); // 時間経過\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif( v == U ){ // 通常の速さのとき(ニンジンを食べる)\n\t\t\t\tv = V; // 速度変化\n\t\t\t\tq.push( P(x + V*T, SLOW) ); // ニンジンの効果が切れる位置\n\t\t\t}else{ // 速いとき\n\t\t\t\tif( k < K ){ // ニンジンを持てるとき(持つ)\n\t\t\t\t\tk++;\n\t\t\t\t}else{ // ニンジンを持てないとき(食べる)\n\t\t\t\t\tcarrot++;\n\t\t\t\t\tq.push( P(x + V*T, SLOW) ); // ニンジンの効果が切れる位置\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( q.top().second == SLOW ){ // ニンジンの効果が切れるとき\n\t\t\tdouble l = q.top().first - x; // 移動する距離\n\t\t\tx = q.top().first; // 次の位置\n\t\t\tt += f(l,v); // 時間経過\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif( carrot > 0 ){ // ニンジンを効果が切れる前に食べたときは遅くならない\n\t\t\t\tcarrot--;\n\t\t\t}else if( k > 0 ){ // ニンジンを持っているときは即座に食べる\n\t\t\t\tk--;\n\t\t\t\tq.push( P(x + V*T, SLOW) ); // ニンジンの効果が切れる位置\n\t\t\t}else{ // 通常の速さに戻る\n\t\t\t\tv = U;\n\t\t\t}\n\t\t}else if( q.top().second == GOAL ){ // ゴールのとき\n\t\t\tdouble l = q.top().first - x; // 移動する距離\n\t\t\tx = q.top().first; // 次の位置\n\t\t\tt += f(l,v); // 時間経過\n\t\t\tq.pop();\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint N,K,T,U,V,L;\nconst int MAX_N = 200;\nint d[MAX_N];\n\nconst double EPS = 1e-8;\nbool eq(double a,double b){return abs(a-b) < EPS;}\n\nint main(){\n  cin >> N >> K >> T >> U >> V >> L;\n  for(int i = 0 ; i < N ; i++)cin >> d[i];\n\n  int buf = 0;\n  double t = 0.0;\n  double res = 0.0;\n  int cnt = 0;\n\n  for(int i = 0 ; i < L ; i++){\n\n    if(!eq(t,0.0)){\n      if(i == d[cnt]){\n\tif(buf == K)t = T;\n\telse buf++;\n\tcnt++;\n      }\n    }\n    else {\n      if(i == d[cnt]){t = T,cnt++;} \n      else if(buf){\n\tbuf--;\n\tt = T;\n      }\n    }\n\n    if(!eq(t,0.0)){\n      res += 1.0/V;\n      t -= 1.0/V;\n      if(t < 0.0){\n\tres -= V*(-t);\n\tres += U*(-t);\n\tt = 0.0;\n      }\n    }      \n    else{\n      res += 1.0/U;\n    }\n  }\n  printf(\"%.8f\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n,k,item,begin;\n  double u,v,t,l,d[201],ans,remain,limit;\n  while(cin >> n >> k >> t >> u >> v >> l){\n    for(int i=0;i<n;i++) cin >> d[i];\n    d[n] = l;\n\n    ans = d[0] / u;\n    limit = t * v * (k + 1);\n    begin = remain = 0;\n    for(int i=0;i<n;i++){\n      remain = min(remain + t * v, limit);\n      double dis = d[i+1] - d[i];\n      if(dis > remain){\n\tans += remain / v + (dis - remain) / u;\n\tremain = 0;\n      } else{\n\tans += dis / v;\n\tremain -= dis;\n      }\n\n    }\n\n\n    printf(\"%.9f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nint main(){\n  lli n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<lli> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<lli> course(l + 2, 0);\n  for (int i = 0; i < n; i++) {\n    course[d[i]]++;\n    course[min(d[i] + t*v, l + 1)]--;\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    course[i + 1] += course[i];\n  }\n  for (int i = 0; i < l; i++) {\n    course[i] = min(course[i], k + 1);\n  }\n  for (int i = 0; i < l; i++) {\n    if(course[i] == 0 and sum > 0)sum--, course[i]++;\n    sum += (course[i] > 0);\n    course[i] = (course[i] > 0);\n  }\n  sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n  }\n  std::cout << setprecision(15) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint main(){\n    int n,k,t,u,v,l,tmp;\n    bool car[10001];\n    cin >> n >> k >> t >> u >> v >> l;\n\n    memset(car,false,sizeof(car));\n\n    for(int i=0;i<n;i++){\n        cin >> tmp;\n        car[tmp] = true;\n    }\n\n    int stock = 0;\n    double ret = 0;\n    double rem = 0;\n    for(int i=0;i<l;i++){\n        if(rem > 0){\n            //食べている状態で\n            if(car[i]){\n                if(stock == k){ //ストックがいっぱい\n                    rem = t; //たべる\n                }else{\n                    stock++; //ためる\n                }\n            }\n\n            if(rem*v > 1){ //次の1mは切れない\n                rem -= 1.0 / v;\n                ret += 1.0 / v;\n            }else if(abs(1 - rem*v) < EPS ){//1m丁度もつ\n                ret += 1.0 / v;\n                if(stock > 0){\n                    stock--;\n                    rem = k;\n                }else{\n                    rem = 0;\n                }\n            }else{ //途中で切れる\n                if(stock > 0){//stockがある\n                    stock--;\n                    rem = 1.0 / v - rem;\n                    ret += 1.0 / v;\n                }else{\n                    ret += rem + (1 - rem * v) / u;\n                    rem = 0;\n                }\n            }            \n        }else{\n            //食べていなく、\n            if(car[i] || stock > 0){//にんじんがある\n                if(stock > 0) stock--;\n                rem = t; //たべる\n                rem -= 1.0/v; //1m走る\n                ret += 1.0/v; //結果+\n            }else{\n                ret += 1.0/u; //普通に走る\n            }\n        }\n        if(abs(rem) < EPS) rem = 0;\n    }\n    printf(\"%.8lf\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint n, k, t, u, v, l;\nint d[202];\n\nint main(){\n    cin >> n >> k >> t >> u >> v >> l;\n    d[0] = 0;\n    rep(i, n) cin >> d[i + 1];\n    d[n + 1] = l;\n\n    double time = 0, boost = 0;\n    int carrot = 0;\n    repl(i, 1, n + 2) {\n        double a = d[i] - d[i - 1];\n        double b = (carrot * t + boost) * v;\n        if (a > b) {\n            a -= b;\n            time += (carrot * t + boost) + a / u;\n            boost = 0;\n            carrot = 0;\n        } else {\n            b -= a;\n            time += a / v;\n            carrot = (int)(b / v) / t;\n            boost = (b / v) - (carrot * t);\n        }\n        if (carrot < k) carrot++;\n        else boost = t;\n    }\n\n    printf(\"%.10f\\n\", time);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double ans = 0.0;\n\n    int speed = 0;\n    int acceledDistance = 0;\n    int d_sub = 0;\n    int nowStock = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    for(int i = 0; i < L; i++)\n    {\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n            speed = V;\n            \n            if(nowStock == K)acceledDistance = T * V;\n            else\n            {\n                ++nowStock;\n                if(acceledDistance == 0)\n                {\n                    acceledDistance = T * V;\n                    --nowStock;\n                }\n            }\n\n            --acceledDistance;\n            if(acceledDistance == 0 && nowStock > 0)\n            {\n                --nowStock;\n                acceledDistance = T * V;\n            }\n        }\n        else\n        {\n            speed = U;\n            if(acceledDistance > 0)\n            {\n                speed = V;\n                --acceledDistance;\n                if(acceledDistance == 0 && nowStock > 0)\n                {\n                    --nowStock;\n                    acceledDistance = T * V;\n                }\n            }\n        }\n\n        ans += 1.0 / speed;//((acceledDistance > 0) ? V : U);\n    }\n    printf(\"%.6lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid solve()\n{\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> Vec(N);\n\tfor(int i = 0; i < N; ++i)\n\t{\n\t\tcin >> Vec[i];\n\t}\n\n\tint pos = 0;\n\tdouble time = 0;\n\tint carrot_time = 0;\n\tint point = 0;\n\tint carrot = 0;\n\twhile(true)\n\t{\n\t\tpos++;\n\t\tif(carrot_time)\n\t\t{\n\t\t\t--carrot_time;\n\t\t\ttime += 1.0 / V;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttime += 1.0 / U;\n\t\t}\n\t\tif(carrot > 0 && carrot_time == 0)\n\t\t{\n\t\t\t--carrot;\n\t\t\tcarrot_time = T * V;\n\t\t}\n\t\tif(pos == Vec[point])\n\t\t{\n\t\t\tif(point != Vec.size() - 1)\n\t\t\t{\n\t\t\t\t++point;\n\t\t\t}\n\t\t\tif(carrot < K)\n\t\t\t{\n\t\t\t\tif(carrot_time == 0)\n\t\t\t\t{\n\t\t\t\t\tcarrot_time = T * V;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++carrot;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(carrot == K)\n\t\t\t{\n\t\t\t\tcarrot_time = T * V;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pos == L)\n\t\t{\n\t\t\tprintf(\"%.9f\\n\", time);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n    double N,K,T,U,V,L,D[201];\n    double k=0, boost = 0, tm = 0;\n    int index = 1;\n    cin >> N >> K >> T >> U >> V >> L;\n    for(int i=1; i<=N; i++){\n        cin >> D[i];\n    }\n    for(int i=0; i<L; i++){\n        if(index<=N && i==D[index]){\n            if(k < K)   k++;\n            else        boost = V*T;\n            index++;\n        }\n        if(boost == 0 && k > 0){\n            k--;\n            boost = V*T;\n        }\n        if(boost == 0)  tm +=1.0/U;\n        else{\n            tm += 1.0/V;\n            boost--;\n        }\n    }\n    cout << fixed;\n    cout << setprecision(8) << tm << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    int N,K,T,U,V,L;\n    cin>>N>>K>>T>>U>>V>>L;\n    vector<int> D(N);\n    for(auto &d:D) cin>>d;\n    int ite=0;\n    double boost=0;\n    double ans=0;\n    int k=0;\n    for(int x=1;x<=L;x++){\n        ans+=(boost>1e-3?1.0/V:1.0/U);\n        if(boost>0) boost-=1.0/V;\n        if(D[ite]==x){\n            if(boost>0&&k==K||boost<=0){\n                boost=T;\n            }else{\n                k++;\n            }\n            ite++;\n        }else if(boost<=0&&k){\n            boost=T;\n            k--;\n        }\n    }\n    cout<<fixed;\n    cout.precision(9);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\nconst int MAX_D = 100005;\n\nint a[MAX_N];\nint n,k,t,u,v,l;\nint flag[MAX_D];\n\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&n,&k,&t,&u,&v,&l);\n\trep(i,n){\n\t\tscanf(\"%d\",&a[i]);\n        flag[a[i]] = 1;\n\t}\n    double res = 0;\n    double rem_t = 0;\n    int cnt = 0;\n    rep(i,l){\n        if(flag[i] == 1){\n            if(rem_t < EPS){\n                rem_t = t - 1.0 / v;\n                res += 1.0 / v;\n            }else{\n                if(cnt == k){\n                    rem_t = t - 1.0 / v;\n                    res += 1.0 / v;\n                }else{\n                    cnt++;\n                    rem_t -= 1.0 / v;\n                    res += 1.0 / v;\n                }\n            }\n        }else{\n            if(rem_t > EPS){\n                res += 1.0 / v;\n                rem_t -= 1.0 / v;\n            }else{\n                if(cnt > 0){\n                    rem_t = t - 1.0 / v;\n                    res += 1.0 / v;\n                    cnt--;\n                }else{\n                    res += 1.0 / u;\n                }\n            }\n        }\n        printf(\"%.2f\\n\",res);\n    }\n    printf(\"%.10f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nint N,K,T,U,V,L;\nint carrot[100010];\nint down[100010];\n\nint main(){\n    while(cin >> N >> K >> T >> U >> V >> L){\n        rep(i,L+1) carrot[i] = down[i] = 0;\n        rep(i,N){\n            int D; cin >> D;\n            carrot[D] = 1;\n        }\n        int have = 0;\n        double ans = 0;\n        int rem = 0;\n        rep(i,L){\n            dump(i,rem);\n            if(rem) ans += 1./V;\n            else ans += 1./U;\n            if(rem) rem--;\n            if(have && !rem){\n                have--;\n                rem = V*T;\n            }\n            if(carrot[i]){\n                if(!rem){\n                    carrot[i]--;\n                    rem = V*T;\n                }\n                if(have + carrot[i] > K){\n                    carrot[i]--;\n                    rem = V*T;\n                    have = K;\n                } else {\n                    have++;\n                }\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, K, T, U, V, L;\nbool point[10010];\n\nsigned main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    rep(i,0,N) {\n        int p; cin >> p;\n        point[p] = true;\n    }\n\n    int stock = 0, prev = -1, da = 0, db = 0;\n    rep(i,0,L) {\n        if((prev < 0 || prev + T*V < i) && stock) prev = i-1, stock--;\n        // printf(\"point = %lld, prev = %lld\\n\", i, prev);\n\n        (prev < 0 || prev + T*V < i ? da : db)++;\n        if(point[i]) {\n            if(stock == K || prev < 0 || prev + T*V < i) prev = i;\n            else stock++;\n        }\n    }\n    // printf(\"da = %lld, db = %lld\\n\", da, db);\n    double ans = 1.0 * da / U + 1.0 * db / V;\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iomanip>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nint main(void) {\n  int N,K;\n  double T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  vector<double> D(N);\n  double crt = 0.0;\n  double time = 0.0;\n  REP(i,N){\n    cin>>D[i];\n    if(i) {\n      int dist = D[i] - D[i-1];\n      if(crt > 0.0) {\n        if(dist < T*V*crt) {\n          crt -= dist/(T*V);\n          time += dist / V;\n        } else {\n          time += T*crt;\n          time += (dist-T*V*crt)/U;\n          crt = 0.0;\n        }\n      } else {\n        time += dist / U;\n      }\n    } else {\n      time += D[0] / U;\n    }\n    if(crt < K)\n      crt += 1.0;\n    else\n      crt = K + 1.0;\n  }\n  int dist = L - D[N-1];\n  if(crt > 0.0) {\n    if(dist < T*V*crt) {\n      crt -= dist/(T*V);\n      time += dist / V;\n    } else {\n      time += T*crt;\n      time += (dist-T*V*crt)/U;\n      crt = 0.0;\n    }\n  } else {\n    time += dist / U;\n  }\n  cout << fixed << setprecision(10) << time << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<bool> a(L + 1);\n\twhile (N--) {\n\t\tint D; cin >> D;\n\t\ta[D] = true;\n\t}\n\tdouble ans = 0;\n\tint car = 0, rest = 0;\n\tfor (int l = 1; l <= L; l++) {\n\t\tif (rest > 0) {\n\t\t\tans += 1.0 / V;\n\t\t\trest--;\n\t\t}\n\t\telse ans += 1.0 / U;\n\t\tif (a[l]) car++;\n\t\tif (car > K) {\n\t\t\tcar = K;\n\t\t\trest = T * V;\n\t\t} else if (car > 0 && rest == 0) {\n\t\t\tcar--;\n\t\t\trest = T * V;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int n,k,t,u,v,l;cin>>n>>k>>t>>u>>v>>l;){\n\t\tvector<int> ds(n+2); ds[n+1]=l;\n\t\tfor(int i=1;i<=n;i++) cin>>ds[i];\n\t\t\n\t\tdouble res=0,pos=0,rest=0;\n\t\tfor(int carrot=0;pos<l;){\n\t\t\tint i=upper_bound(begin(ds),end(ds),pos)-ds.begin();\n\t\t\tdouble dist=ds[i]-pos;\n\t\t\tif(rest>=dist/v){\n\t\t\t\tres+=dist/v;\n\t\t\t\tpos=ds[i];\n\t\t\t\trest-=dist/v;\n\t\t\t\tcarrot++;\n\t\t\t\tif(carrot>k){\n\t\t\t\t\tcarrot--;\n\t\t\t\t\trest=t;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(rest>0){\n\t\t\t\tres+=rest;\n\t\t\t\tpos+=v*rest;\n\t\t\t\trest=0;\n\t\t\t}\n\t\t\telse if(carrot>0){\n\t\t\t\tcarrot--;\n\t\t\t\trest=t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres+=dist/u;\n\t\t\t\tpos=ds[i];\n\t\t\t\tcarrot++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n\nusing namespace std;\n\n\nint main() {\n    int N,K;\n    double T,U,V,L;\n    cin >> N >> K >> T >> U >> V >> L;\n    int have=0;\n    double time=0;\n    double next,now=0,prev=0;\n    double nokori=0;\n    cin >> next;\n    time += (next/U);\n\n    now = T*V + next;\n    prev = next;\n    for(int i= 1; i < N ; i++){\n        cin >> next;\n        if(next <= now){\n            if(have < K){\n                have++;\n                time += (next - prev)/V;\n                prev = next;\n            }else{\n                now = next +T*V;\n                time +=(next - prev)/V;\n                prev = next;\n            }\n        }else{\n            for(;now<next && have>0;have--){\n                now+=(T*V);\n            }\n            if(now >= next){\n                time += (next-prev)/V;\n                prev = next;\n                have++;\n            }else{\n                time += (now - prev)/V;\n                time += (next-now)/U;\n                now = T*V + next;\n                prev = next;\n            }\n        }\n    }\n    next = L;\n    if(next <= now){\n        if(have < K){\n            have++;\n            time +=(next - prev)/V;\n            prev = next;\n        }else{\n            now = next +T*V;\n            time +=(next - prev)/V;\n            prev = next;\n        }\n    }else{\n        for(;now<next && have>0;have--){\n            now+=(T*V);\n        }\n        if(now >= next){\n            time += (next-prev)/V;\n            prev =next;\n        }else{\n            time += (now - prev)/V;\n            time += (next-now)/U;\n            now = T*V + next;\n            prev = next;\n        }\n    }\n    cout << fixed << setprecision(7) << time << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int n, k, l;\n    double t, u, v, d[200];\n    \n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i, n){\n        cin >> d[i];\n    }\n    \n    double ans = 0.0;\n    int boost_time = 0, ninjin_p = 0, boost_cnt = 0;\n    for(int i = 1; i <= l; i++){\n        if(boost_time){\n            ans += 1.0 / v + 1e-15;\n            boost_time--;\n        }\n        else{\n            ans += 1.0 / u + 1e-15;\n        }\n        \n        if(i == d[ninjin_p]){\n            if(boost_time >= k * v){\n                boost_time = (k + 1) * v;\n            }\n            else{\n                boost_time += v;\n            }\n            if(ninjin_p < n - 1)ninjin_p++;\n        }\n    }\n    \n    printf(\"%.11lf\\n\",\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nvector<int> carot(10010,0);\nint n,k,t,u,v,l,d;\n\n\nint main(){\n\tcin>>n>>k>>t>>u>>v>>l;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>d;\n\t\tcarot.at(d)+=1;\n\t}\n\tdouble ans=0;\n\tint boost_l=0;\n\tint normal_l=0;\n\tint haveNum=0;\n\tbool flag=false;\n\tint eat_num=0;\n\tint end_l=0;\n\tfor(int i=1; i<=l; i++){\n\t\tif(i==end_l)flag=false;\n\t\tif(carot.at(i)>0){\n\t\t\tif(!flag){\n\t\t\t\teat_num++;\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(haveNum<k)haveNum++;\n\t\t\t\telse {\n\t\t\t\t\teat_num++;\n\t\t\t\t\tend_l=i+v*t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!flag&&haveNum>0){\n\t\t\t\thaveNum--;\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t}\n\t\t}\n\t\tif(flag)boost_l++;\n\t\telse normal_l++;\n\t}\n\tcout<<(double)boost_l/v+(double)normal_l/u<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(a)<(b))\n#define F first\n#define S second\nusing namespace std;\nint D[210];\nint main(){\n\tint N,K,T,U,V,L;\n\tcin>>N>>K>>T>>U>>V>>L;\n\tREP(i,0,N) cin>>D[i];\n\tint d=0,cnt=0,t=0,have=0;\n\tREP(i,0,L){\n\t\tt=max(t-1,0);\n\t\tif(i==D[d]){\n\t\t\td++;\n\t\t\tif(t==0||have==K){\n\t\t\t\tt=T*V;\n\t\t\t}else if(have<K){\n\t\t\t\thave++;\n\t\t\t}\n\t\t}else{\n\t\t\tif(t==0&&have>0){\n\t\t\t\tt=T*V;\n\t\t\t\thave--;\n\t\t\t}\n\t\t}\n\t\tif(t>0) cnt++;\n\t}\n\tdouble ans=1.0*cnt/V + 1.0*(L-cnt)/U;\n\tprintf(\"%.7lf\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <memory>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   private:\n      queue <TNode> Q;\n      virtual void init() = 0;\n      virtual TNode get_start() = 0;\n      virtual bool is_goal( TNode ) = 0;\n      virtual void find_next( TNode ) = 0;\n\n   public:\n      IBFS() {\n         Q = queue <TNode>();\n      }\n\n      TNode run() {\n         init();\n         Q.push( get_start() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal( node ) ) {\n               return node;\n            }\n            find_next( node );\n         }\n         return TNode();\n      }\n\n      void push_next( TNode node ) {\n         Q.push(node);\n      }\n\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Solution {\n   private:\n\n      class Node {\n      public:\n         double cost;\n         int id;\n         int remains;\n         int carrots;\n         Node(): cost(NONE){}\n         Node( double cost, int id, int remains, int carrots ):\n            cost(cost), id(id), remains(remains), carrots(carrots) {}\n         friend ostream& operator << ( ostream& os, Node node ) {\n            return os << node.cost << \", \" << node.id << \", \"\n                      << node.remains << \", \" << node.carrots << \" / \";\n         }\n      };\n\n      class BFS: public IBFS<Node> {\n      private:\n         double base;\n         double fast;\n\n         void init() {\n            base = 1.0 / U;\n            fast = 1.0 / V;\n         }\n\n         Node get_start() {\n            return Node( 0.0, 0, 0, 0 );\n         }\n\n         bool is_goal( Node node ) {\n            return node.id == L;\n         }\n\n      public:\n         void find_next( Node node ) {\n            Node next_node = node;\n\n            if ( D[next_node.id] ) {\n               if ( next_node.carrots == K ) {\n                  next_node.remains = T * V;\n               } else {\n                  next_node.carrots ++;\n                  if ( next_node.remains == 0 ) {\n                     next_node.remains = T * V;\n                     next_node.carrots --;\n                  }\n               }\n            }\n\n            double t = base;\n            if ( next_node.remains ) {\n               t = min( t, fast );\n               next_node.remains --;\n            }\n            if ( next_node.remains == 0 && next_node.carrots ) {\n               next_node.remains = T * V;\n               next_node.carrots --;\n            }\n            next_node.cost += t;\n            next_node.id += 1;\n\n            push_next( next_node );\n         }\n      };\n\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         static BFS bfs;\n         bfs = BFS();\n         return bfs.run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst double EPS = 1e-10;\n\nint main(){\n\tint n, k, l;\n\tdouble t, u, v;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tVI d(l);\n\tREP(i,n){\n\t\tint x;\n\t\tcin >> x;\n\t\td[x] = 1;\n\t}\n\tdouble ans = 0.0, res = 0.0;\n\tint x = 0;\n\tREP(i,l){\n\t\tx += d[i];\n\t\tif (x > k){\n\t\t\tx = k;\n\t\t\tres = t;\n\t\t}\n\t\tif (res < EPS && x > 0){\n\t\t\tx--;\n\t\t\tres = t;\n\t\t}\n\t\tif (res > EPS){\n\t\t\tans += 1.0/v;\n\t\t\tres -= 1.0/v;\n\t\t}else{\n\t\t\tans += 1.0/u;\n\t\t}\n\t}\n\n\tprintf(\"%.10f\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint ncarrot, max_have_carrot, accel_time, standard_speed, accel_speed, length;\n\tint carrot[201], suffix = 0;\n\n\tcin >> ncarrot >> max_have_carrot >> accel_time >> standard_speed >> accel_speed >> length;\n\n\tfor (int i = 0; i < ncarrot; i++) {\n\t\tcin >> carrot[i];\n\t}\n\n\tint have = 0;\n\tdouble time = 0.0, after_time = 0.0;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (carrot[suffix] == i) {\n\t\t\tif (have == 0 && after_time == 0) { //何も持っていない&加速していない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\telse if (have < max_have_carrot) { //まだ持てる\n\t\t\t\thave++;\n\t\t\t}\n\t\t\telse { //もう持てない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\tsuffix++;\n\t\t}\n\n\t\tif (after_time > 0.0) {\n\t\t\tif (after_time - (double)(1.0 / accel_speed) < 0.00000001) { //近似\n\t\t\t\tafter_time = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tafter_time -= (double)(1.0 / accel_speed);\n\t\t\t}\n\t\t\ttime += (double)(1.0 / accel_speed);\n\n\t\t\tif (after_time <= 0.0) {\n\t\t\t\tif (have > 0) {\n\t\t\t\t\thave--;\n\t\t\t\t\tafter_time = (double)accel_time;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thave = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttime += (double)(1.0 / standard_speed);\n\t\t}\n\t}\n\n\tcout << time << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\nint N,K,T,v1,v2,L;\nint D[220];\ndouble ans;\nint now;\ndouble up;\nint yorn;\nint have;\n\n\nint main(){\n\tcin >> N >> K >> T >> v1 >> v2 >> L;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> D[i];\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(yorn==0){\n\t\t\tans += 1.0*(D[i]-now)/v1;\n\t\t\tup = D[i] + T*v2;\n\t\t\tnow = D[i];\n\t\t\tyorn = 1;\n\t\t}\n\t\telse if(yorn==1){\n\t\t\tif(D[i]>up){\n\t\t\t\twhile(D[i]>up && have>0){\n\t\t\t\t\thave --;\n\t\t\t\t\tup += T*v2;\n\t\t\t\t}\n\t\t\t\tif(D[i]>up){\n\t\t\t\t\tans += 1.0*(up-now)/v2;\n\t\t\t\t\tans += 1.0*(D[i]-up)/v1;\n\t\t\t\t\tyorn = 0;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\thave ++;\n\t\t\t\t\thave = min(have,K);\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(D[i]<up){\n\t\t\t\tif(have==K){\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\tup = D[i] + T*v2;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\t\thave++;\n\t\t\t\t\tnow = D[i];\n\t\t\t\t}\n\t\t\t}\t\n\t\t\telse{\n\t\t\t\tans += 1.0*(D[i]-now)/v2;\n\t\t\t\tup = D[i] + T*v2;\n\t\t\t\tnow = D[i];\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\twhile(have>0){\n\t\thave --;\n\t\tup += T*v2;\n\t}\n\tif(L > up){\n\t\tans += 1.0*(up-now)/v2;\n\t\tans += 1.0*(L-up)/v1;\n\t}\n\telse{\n\t\tans += 1.0*(L-now)/v2;\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<algorithm>\n#include <iomanip>\nusing namespace std;\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n#define N_MAX 201\n#define L_MAX 10001\n#define ll long long\n\n\n//??????????????¨??????\nint N,K,T,U,V,L;\nint D[N_MAX];\n\n//????§???????index(m)?????¨???????????°??£???????????????\nbool run[L_MAX];\n\n//?????¨???????????????????????£????????????\nint carrot=0;\n\n//???????????????????????°???????????¨???m?¶??????§?????????\nint lestRun=0;\n\n//?¬???????????????????D???????????????\nint nextCarrot=0;\n\n//????§??????????????????????????????§??????\nint meter=0;\n\nint main() {\n\t//??\\?????¨?????????\n\tcin>>N>>K>>T>>U>>V>>L;\n\trep(i,N)cin>>D[i];\n\trep(i,L)run[i]=false;\n\n\t//??????????????????????????????\n\twhile(meter<L){\n\t\tif(D[nextCarrot]==meter){\n\t\t\t//???????????????\n\t\t\tcarrot++;nextCarrot++;\n\t\t\t\n\t\t\t//??¢?????????????????????????£????\n\t\t\tif(carrot>K){lestRun=T*V;carrot--;}\n\t\t}\n\n\t\t//??????????¶????????????£???????£???????????????????\n\t\tif(lestRun==0 && carrot>0){carrot--;lestRun+=T*V;}\n\n\t\t//????±???°????????¶????????£???????????°??£?????????????????????\n\t\tif(lestRun>0){run[meter]=true;lestRun--;}\n\n\t\t//??????\n\t\tmeter++;\n\t}\n\t//????±???°??£????????¢\n\tint runDist=0;\n\trep(i,L)if(run[i])runDist++;\n\n\t//??????\n\tcout<< setprecision(10)<< (double)runDist/V + (double)(L-runDist)/U <<endl;\n\n\t//???????????°\n\t//rep(i,L)cout<<i<<\" : \"<<run[i]<<endl;\n\n\t//cin>>N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint d[210];\n\nint main() {\n\tint n,k,t,u,v,l;\n\tcin>>n>>k>>t>>u>>v>>l;\n\trepn(i,1,n)cin>>d[i];\n\td[n+1]=l;\n\tdouble res=0;\n\tint have=0,f=0;\n\trepn(i,0,n){\n\t\tdouble tm;\n\t\tint use,dis;\n\t\tif(d[i+1]-d[i]<v*t*have+f){\n\t\t\tdis=d[i+1]-d[i];\n\t\t\ttm=dis/(double)v;\n\t\t\tuse=(dis<=f)?0:(dis-f-1)/(v*t)+1;\n\t\t\tres+=tm;\n\t\t\thave-=use;\n\t\t\tf=(v*t-(dis-f)%(v*t))%v*t;\n\t\t}else{\n\t\t\tres+=t*have+f/(double)v+(d[i+1]-d[i]-v*t*have-f)/(double)u;\n\t\t\thave=0;\n\t\t\tf=0;\n\t\t}\ndebug<<res<<\" \"<<have<<\" \"<<f<<endl;\n\t\t++have;\n\t\tif(have>k){\n\t\t\tf=v*t;\n\t\t\thave=k;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nvector<int> carrot(10010,0);\nint n,k,t,u,v,l,d;\n\n\nint main(){\n\tcin>>n>>k>>t>>u>>v>>l;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>d;\n\t\tcarrot.at(d)+=1;\n\t}\n\tint boost_l=0;\n\tint normal_l=0;\n\tint haveNum=0;\n\tbool flag=false;\n\tint end_l=0;\n\tfor(int i=0; i<l; i++){\n\t\tif(i==end_l)flag=false;\n\t\tif(carrot.at(i)>0){\n\t\t\tif(!flag){\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t\t//cout<<\"d:\"<<d<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(haveNum<k)haveNum++;\n\t\t\t\telse {\n\t\t\t\t\tend_l=i+v*t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!flag&&haveNum>0){\n\t\t\t\thaveNum--;\n\t\t\t\tflag=true;\n\t\t\t\tend_l=i+v*t;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\t//cout<<\"boost:\"<<i<<endl;\n\t\t\tboost_l++;\n\t\t}\n\t\telse normal_l++;\n\t}\n\tprintf(\"%.9lf\\n\",(double)boost_l/v+(double)normal_l/u);\n\t//cout<<\"bl:\"<<boost_l<<\" nl:\"<<normal_l<<endl;\n\t//cout<<\"bt:\"<<(double)boost_l/v<<\" nt:\"<<(double)normal_l/u<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() \n{\n\tlong N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tlong d[202];\n\t\n\td[0] = 0;\n\tfor(int i=1;i<N+1;i++){\tcin >> d[i];}\n\td[N+1] = L;\n\t\n\tlong dis(0); //速度Uで走らなければいけない距離\n\tlong l(0); //速度Vで走れる残距離\n\tlong k(0); //ニンジンを持っている個数\n\t\n\tfor(int i=0 ; i < N+1 ; i++)\n\t{\n\t\t//地点i~i+1までの走りかたを判定\n\t\tif((d[i+1]-d[i]) >= (l + k*T*V)){\n\t\t\tdis += (d[i+1]-d[i]) - l - k*T*V;\n\t\t\tl = 0;\n\t\t\tk = 0;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tk = (-(d[i+1]-d[i]) + (l + k*T*V))/(T*V);\n\t\t\tl = (-(d[i+1]-d[i]) + (l + k*T*V))%(T*V);\n\t\t}\n\t\t\n\t\t//地点i+1でのニンジンで初期化\n\t\tif(l==0){\n\t\t\tl = T*V;\n\t\t}else if(k==K){\n\t\t\tl = T*V;\n\t\t}else{\n\t\t\tk++;\n\t\t}\n\t}\n\tdouble ans = (double)dis/(double)U + (double)(L - dis)/(double)V;\n\t\n\tcout << fixed << setprecision(6) << ans << endl;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint d[201];\n\nconst double EPS = 1e-10;\n\nint main(){\n  int n, k, t, u, v, l;\n\n  scanf(\"%d%d%d%d%d%d\", &n, &k, &t, &u, &v, &l);\n  REP(i,n) scanf(\"%d\", d + i);\n  sort(d, d + n);\n  d[n] = l;\n  n = n + 1;\n\n  int have = 0;\n  int pos  = 0;\n  double remain = 0.0;\n  double ans = 0.0;\n\n  REP(i,n){\n    double dist = d[i] - pos;\n    // printf(\"pos:%d remain:%.2f have:%d ans: %.4f\\n\", pos, remain, have, ans);\n\n    pos = d[i];\n\n    while(dist > 0.0 + EPS){\n      if(remain == 0.0 && have > 0){\n\thave--;\n\tremain = t;\n      }\n\n      if(remain > 0.0){\n\tif(remain > 0.0){\n\t  if(dist > remain * v){\n\t    dist -= remain * v;\n\t    ans += remain;\n\t    remain = 0.0;\n\t  }else{\n\t    ans += dist / v;\n\t    remain -= dist / v;\n\t    dist = 0.0;\n\t  }\n\t}\n      }\n\n      if(have == 0 && dist > 0.0){\n\tans += dist / u;\n\tdist = 0.0;\n      }\n    }\n\n    if(have == k){\n      remain = t;\n    }else{\n      have++;\n    }\n  }\n\n  printf(\"%.7f\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,cnt,x,ans;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=true;\n  for(int i=0;i<=l;i++){\n    if(s[i])\n      if(!x||k==cnt)x=v*t;\n      else cnt++;\n    else if(!x&&cnt>0)cnt--,x=v*t;\n    if(x>0)ans++,x--;\n  }\n  printf(\"%.10f\\n\",ans*1.0/v+(l-ans)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N,K,T,U,V,L,D[205];\n\ndouble solve()\n{\n\tdouble res = 0, rem = 0;\n\tint stock = 0;\n\n\tfor(int i=1; i<=N+1; i++)\n\t{\n\t\tint dist = D[i] - D[i-1];\n\t\twhile( (dist > rem * V) && stock) { rem += T; stock--; }\n\n\n\t\tif(rem* V < dist)\n\t\t{\n\t\t\tres += rem;\n\t\t\tdist -= rem * V;\n\n\t\t\tres += 1.0*dist / U;\n\t\t\trem = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += 1.0*dist / V;\n\t\t\trem -= 1.0*dist / V;\n\t\t}\n\n\n\t\tif(stock == K) rem = T;\n\t\telse stock++;\n\n\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\n\tcin >> N >> K >> T >> U >> V >> L;\n\n\tD[0] = 0, D[N+1] = L;\n\tfor(int i=0; i<N; i++)\n\t\tcin >> D[i+1];\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tcout << solve() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2298.cc: Starting Line\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200;\nconst int MAX_L = 10000;\n\n/* typedef */\n\n/* global variables */\n\nbool crts[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, k, t, u, v, l;\n  cin >> n >> k >> t >> u >> v >> l;\n\n  for (int i = 0; i < n; i++) {\n    int cr;\n    cin >> cr;\n    crts[cr] = true;\n  }\n\n  int cn = 0;\n  double vtl = (double)t * v;\n  double ans = 0.0, r0 = 0.0, r1 = 0.0;\n\n  for (int i = 0; i <= l; i++) {\n    if (r0 < r1 && r1 <= i) {\n      ans += (r1 - r0) / v;\n      r0 = r1;\n      if (cn > 0) {\n\tcn--;\n\tr1 = min(r1 + vtl, (double)l);\n      }\n    }\n\n    if (crts[i]) {\n      if (r0 == r1) {\n\tans += ((double)i - r1) / u;\n\tr0 = i, r1 = min((double)i + vtl, (double)l);\n      }\n      else if (++cn > k) {\n\tcn--;\n\tans += ((double)i - r0) / v;\n\tr0 = i, r1 = min((double)i + vtl, (double)l);\n      }\n    }\n  }\n\n  ans += (l - r1) / u;\n  \n  printf(\"%.9lf\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nint n;\nint l;\nint d[200];\nint k;\nint t;\nint v;\nint u;\ndouble ushi;\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++){\n    cin>>d[i];}\n  ushi=(l-n*t*v)/((double) u)+n*t;\n  cout<<ushi<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i;\n    long long j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n            if(j > l - i + 1 || j < 0){\n                dd += l - i;\n                break;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n        //cout << i << \" \" << dd << \" \" << j << endl;\n    }\n    //cout << dd <<endl;\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n, k, t, u, v, l;\n\tdouble second;\n\tdouble length;\n\n\tcin >> n >> k >> t >> u >> v >> l;\n\tint *d;\n\td = (int *)calloc(n, sizeof(int));\n\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> d[i];\n\n\t//d[0]までは速さuで走る\n\tsecond = (double)d[0] / u;\n\tlength = (double)d[0];\n\n\t//d[0]からt秒間速さvで加速して走る\n\tsecond += t;\n\tlength += v*t;\n\n\tif(l - length < 0)\t\t//lengthがlを超えた場合\n\t\t{\n\t\t\tsecond -= t;\n\t\t\tlength -= v*t;\n\t\t\tsecond += (l-length) / v;\n\t\t\tlength = l;\n\t\t}\n\n\tint counter = 0;\t//counter(持っている人参の数)\n\tint j = 1;\n\n\twhile(length - d[j] >= 0 && j < n &&length != l) //d地点を何個抜かしたか\n\t{\n\t\tif(counter < k)\n\t\t\tcounter++;\n\t\t\n\t\tj++;\n\t}\n\n\twhile(length != l)\t//counterの個数だけ加速 ちなみにcounterがマイナスになることはない\n\t{\n\t\tif(counter > 0)\n\t\t{\n\t\t\tsecond += t;\n\t\t\tlength += v*t;\n\t\t\tcounter--;\t\t//加速したらcounterを1減らす\n\n\t\t\tif(length - l > 0)\t\t//lengthがlを超えた場合\n\t\t\t{\n\t\t\t\tsecond -= t;\n\t\t\t\tlength -= v*t;\n\t\t\t\tsecond += (l-length) / v;\n\t\t\t\tlength = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(length - d[j] >= 0 && j < n) //d地点を何個抜かしたか\n\t\t\t{\n\t\t\t\tif(counter < k)\n\t\t\t\t\tcounter++;\n\t\t\t\tj++;\n\t\t\t}\t\t\n\t\t}\n\t\telse\t\t//counterが0のとき\n\t\t{\n\t\t\tif(j < n)\t\t//まだ先に人参がある場合\n\t\t\t{\n\t\t\t\tsecond += (double)(d[j] - length) / u;\t\t//普通の速度で\n\t\t\t\tlength = d[j];\n\t\t\t\tj++;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\telse if(j == n)\t//加速していない状態で先にあるのはゴールだけ\n\t\t\t{\n\t\t\t\tsecond += (double)(l - length) / u;\t\t//普通の速度で\n\t\t\t\tlength = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(length == l)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"%.9f\\n\", second);\n\n\tfree(d);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,cnt,x,ans;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++){\n    cin>>d;\n    s[d]=true;\n  }\n  for(int i=0;i<=l;i++){\n    if(s[i]){\n      if(!x)x=v*t;\n      else if(k>cnt)cnt++;\n      else x=v*t;\n    }\n    else if(!x&&cnt>0)cnt--,x=v*t;\n    if(x>0)ans++;\n    if(x>0)x--;\n  }\n  printf(\"%.8f\\n\",ans*1.0/v+(l-ans)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint main(){\n    int n,k,t,u,v,l,tmp;\n    bool car[10001];\n    cin >> n >> k >> t >> u >> v >> l;\n\n    memset(car,false,sizeof(car));\n\n    for(int i=0;i<n;i++){\n        cin >> tmp;\n        car[tmp] = true;\n    }\n\n    int stock = 0;\n    double ret = 0;\n    double rem = 0;\n    for(int i=0;i<l;i++){\n        if(rem > 0){\n            //食べている状態で\n            if(car[i]){\n                if(stock == k){ //ストックがいっぱい\n                    rem = t; //たべる\n                }else{\n                    stock++; //ためる\n                }\n            }\n\n            if(rem*v > 1){ //次の1mは切れない\n                rem -= 1.0 / v;\n                ret += 1.0 / v;\n            }else if(abs(1 - rem*v) < EPS ){//1m丁度もつ\n                ret += 1.0 / v;\n                if(stock > 0){\n                    stock--;\n                    rem = k;\n                }else{\n                    rem = 0;\n                }\n            }else{ //途中で切れる\n                if(stock > 0){//stockがある\n                    stock--;\n                    rem = 1.0 / v - rem;\n                    ret += 1.0 / v;\n                }else{\n                    ret += rem + (1 - rem * v) / u;\n                    rem = 0;\n                }\n            }            \n        }else{\n            //食べていなく、\n            if(car[i]){//にんじんがある\n                rem = t; //たべる\n                rem -= 1.0/v; //1m走る\n                ret += 1.0/v; //結果+\n            }else{\n                ret += 1.0/u; //普通に走る\n            }\n        }\n        if(abs(rem) < EPS) rem = 0;\n    }\n    printf(\"%.8lf\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double time = 0.0;\n\n    int speed = U;\n    double accelTime = 0.0;\n    int d_sub = 0;\n    int nowStock = 0;\n\n    int acceledDistance = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    //*\n    for(int i = 1; i <= L; i++)\n    {\n        bool isEat = false;\n\n        if(accelTime > 0.00001)\n        {\n            accelTime -= 1.0 / (double)speed;\n            if(accelTime < 0.000001)--acceledDistance;\n        }\n        else\n        {\n            accelTime = 0.0;\n            speed = U;            \n        }\n\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n\n            if(speed == U)isEat = true;\n            else\n            {\n                if(nowStock < K)nowStock++;\n                else isEat = true;\n            }\n        }\n\n        if(speed == U)\n        {\n            if(nowStock > 0)\n            {\n                --nowStock;\n                isEat = true;\n            }\n        }\n\n        if(isEat)\n        {\n            accelTime = T;\n            speed = V;\n        }\n\n        if(speed == V)++acceledDistance;\n\n        time += 1.0 / speed;\n        //if(speed == V)cout << i << \" \" << nowStock << \" \" << accelTime << endl;\n    }\n    //*/\n\n    //cout << time << endl;\n    //cout << acceledDistance << endl;\n\n    cout << (acceledDistance / (double)V + (L - acceledDistance) / (double)U) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i>> pq;\n\tpq.push(i_i(L, 0));\n\twhile (N--) {\n\t\tint D; cin >> D;\n\t\tpq.push(i_i(D, 1));\n\t}\n\tbool accel = false;\n\tint d = 0, _d = 0;\n\tdouble t = 0;\n\tfor (;;) {\n\t\ti_i p = pq.top(); pq.pop();\n\t\tint x = p.first, y = p.second;\n\t\tt += (double)(x - d) / (accel ? V : U);\n\t\td = x;\n\t\tif (y == 0) break;\n\t\tif (y == 1) {\n\t\t\taccel = true;\n\t\t\t_d = max(d, _d);\n\t\t\t_d = min(d + (K + 1) * T * V, _d + T * V);\n\t\t\tpq.push(i_i(_d, -1));\n\t\t}\n\t\tif (y == -1 && x == _d) accel = false;\n\t}\n\tprintf(\"%.10f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   private:\n      queue <TNode> Q;\n      virtual void init() = 0;\n      virtual TNode get_start() = 0;\n      virtual bool is_goal( TNode ) = 0;\n      virtual void find_next( TNode ) = 0;\n   public:\n      IBFS() {\n         Q = queue <TNode>();\n      }\n      TNode run() {\n         init();\n         Q.push( get_start() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal( node ) ) {\n               return node;\n            }\n            find_next( node );\n         }\n         return TNode();\n      }\n      void push_next_node( TNode node ) {\n         Q.push(node);\n      }\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Solution {\n   private:\n\n      class Node {\n      public:\n         double cost;\n         int id;\n         int remains;\n         int carrots;\n         Node(): cost(NONE){}\n         Node( double cost, int id, int remains, int carrots ):\n            cost(cost), id(id), remains(remains), carrots(carrots) {}\n         friend ostream& operator << ( ostream& os, Node node ) {\n            return os << node.cost << \", \" << node.id << \", \"\n                      << node.remains << \", \" << node.carrots << \" / \";\n         }\n      };\n\n      class BFS: public IBFS<Node> {\n      private:\n         double base;\n         double fast;\n\n         void init() {\n            base = 1.0 / U;\n            fast = 1.0 / V;\n         }\n\n         Node get_start() {\n            return Node( 0.0, 0, 0, 0 );\n         }\n\n         bool is_goal( Node node ) {\n            return node.id == L;\n         }\n\n      public:\n         void find_next( Node node ) {\n            Node next_node = node;\n\n            if ( D[next_node.id] ) {\n               if ( next_node.carrots == K ) {\n                  next_node.remains = T * V;\n               } else {\n                  next_node.carrots ++;\n                  if ( next_node.remains == 0 ) {\n                     next_node.remains = T * V;\n                     next_node.carrots --;\n                  }\n               }\n            }\n\n            double t = base;\n            if ( next_node.remains ) {\n               t = min( t, fast );\n               next_node.remains --;\n            }\n            if ( next_node.remains == 0 && next_node.carrots ) {\n               next_node.remains = T * V;\n               next_node.carrots --;\n            }\n            next_node.cost += t;\n            next_node.id += 1;\n\n            push_next_node( next_node );\n         }\n      };\n\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      double solve() {\n         static BFS bfs;\n         bfs = BFS();\n         return bfs.run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\tll n, k, t, u, v, l; scanf(\"%lld %lld %lld %lld %lld %lld\", &n, &k, &t, &u, &v, &l);\n\tvector<ll> d(n); for (int i = 0; i < n; i++) scanf(\"%lld\", &d[i]);\n\tdouble curx = 0;\n\tdouble curt = 0;\n\tint curc = 0;\n\tint right = 0;\n\td.push_back(l);\n\tn += 1;\n\twhile (curx + 1e-14 < l) {\n\t\tif (curc == 0) {\n\t\t\tcurt += (double)(d[right] - curx) / u;\n\t\t\tcurx = d[right];\n\t\t\tcurc = 1;\n\t\t\tright++;\n\t\t}\n\t\telse {\n\t\t\tcurc -= 1;\n\t\t\tdouble nx = curx + v * t;\n\t\t\tchmin(nx, (double)l);\n\t\t\twhile (right < n and d[right] <= nx) {\n\t\t\t\tcurc++;\n\t\t\t\tif (curc > k) {\n\t\t\t\t\tnx = d[right] + v * t;\n\t\t\t\t\tchmin(nx, (double)l);\n\t\t\t\t\tcurc = k;\n\t\t\t\t}\n\t\t\t\tright++;\n\t\t\t}\n\t\t\tcurt += (double)(nx - curx) / v;\n\t\t\tcurx = nx;\n\t\t}\n\t}\n\tcout << fixed << setprecision(12) << curt << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 2298\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long double real;\n\nconst int NMAX = 300, LMAX = 20000;\nconst int KMAX = NMAX;\nint N, K, T, U, V, L;\nbool D[NMAX], accel[LMAX];\n\nreal solve() {\n  int bag = 0, limit = 0;\n  for (int x = 0; x < L; x++) {\n    if (limit > 0) {\n      limit--;\n      accel[x] = true;\n    } \n    if (D[x]) {\n      if (limit == 0) {\n        limit = V * T;\n      } else if (bag == K) {\n        limit = V * T;\n      } else {\n        bag++;\n      }\n    }\n\n    if (limit == 0 and bag > 0) {\n      bag--;\n      limit = V * T;\n    }\n  }\n\n  int u = 0, v = 0;\n  REP(x, L) {\n    if (accel[x]) {\n      v++;\n    } else {\n      u++;\n    }\n  }\n  cout << endl;\n\n  return ((real) u) / U + ((real) v) / V;\n}\n\nint main() {\n  cin >> N >> K >> T >> U >> V >> L;\n  REP(x, N) {\n    int d; cin >> d;\n    D[d] = true;\n  }\n\n  cout << setprecision(10) << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n  int N,K,T,L;\n  double U,V;\n  cin >> N >> K >> T >> U >> V >> L;\n  cout << setiosflags(ios::fixed) << setprecision(15);\n  vector<int> D(N+1,0);\n  for(int i=0;i<N;++i){\n    cin >> D[i];\n  }\n  double Time=0;\n  int pos=0;\n  int Npos=0;\n  int until=0;\n  while(pos < L){\n    if(pos==D[Npos]){\n      ++Npos;\n      until+=T*V;\n      if(until>(K+1)*T*V){\n\tuntil=(K+1)*T*V;\n      }\n    }\n    if(until==0){\n      Time+=1/U;\n    }else{\n      Time+=1/V;\n      --until;   \n    }\n    pos+=1;\n  }\n  cout << setiosflags(ios::fixed) << setprecision(15) << Time << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_carrots;\n  int carrot_store_ability;\n  int power_up_duration;\n  int normal_speed;\n  int power_up_speed;\n  int goal_distance;\n  while(~scanf(\"%d %d %d %d %d %d\",\n\t       &total_carrots,\n\t       &carrot_store_ability,\n\t       &power_up_duration,\n\t       &normal_speed,\n\t       &power_up_speed,\n\t       &goal_distance)){\n\n    bool carrots[201];\n    memset(carrots,false,sizeof(carrots));\n\n    for(int carrot_idx=0;carrot_idx< total_carrots; carrot_idx++){\n      int distance;\n      scanf(\"%d\",&distance);\n      carrots[distance] = true;\n    }\n\n    int current_pos = 0;\n\n    int current_carrots = 0;\n    int life = 0;\n\n    int high_speed_interval =0;\n    for(int pos=0;pos< goal_distance; pos++,life--){\n      if(carrots[pos]){\n\tcurrent_carrots++;\n\tif(carrot_store_ability < current_carrots){\n\t  life = power_up_duration * power_up_speed;\n\t  current_carrots--;\n\t}\n      }\n\n      if(life <= 0 && current_carrots > 0){\n\tcurrent_carrots--;\n\tlife = power_up_duration * power_up_speed;\n      }\n\n      if(life > 0){\n\thigh_speed_interval++;\n      }\n    }\n\n    printf(\"%.9lf\\n\",(double)high_speed_interval/(double)power_up_speed\n\t   + (double)(goal_distance - high_speed_interval)/(double)normal_speed);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-8;\n\nint main()\n{\n\tdouble N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvi D(N+1);\n\tREP(i, N) {\n\t\tcin >> D[i];\n\t}\n\tD[N] = L+1;\n\t\n\tbool boost = false;\n\tdouble ans = 0, rest = 0; \n\tint carrot = 0, pos = 0;\n\n\tFOR(d, 1, L+1) {\n\t\tif(!boost && carrot > 0) {\n\t\t\tboost = true;\n\t\t\trest = T;\n\t\t\tcarrot--;\n\t\t}\n\n\t\tif(boost) {\n\t\t\tans += 1/V;\n\t\t\trest -= 1/V;\n\t\t\tif(abs(rest) < EPS) {\n\t\t\t\tboost = false;\n\t\t\t}\n\t\t} else {\n\t\t\tans += 1/U;\n\t\t}\n\n\t\tif(D[pos] == d) {\n\t\t\tpos++;\n\t\t\tcarrot++;\n\t\t\tif(carrot > K) {\n\t\t\t\tcarrot--;\n\t\t\t\trest = T;\n\t\t\t\tboost = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <vector> \n\nusing namespace std;\ntypedef vector<int> VI;\n\nint main(void) {\n    int n;\n    int k;\n    int t;\n    int u;\n    int v;\n    int l;\n    cin >> n >> k >> t >> u >> v >> l;\n    VI d(n);\n    vector<bool> x(l, false);\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n    int number_carot = 0;\n    bool boost = false;\n    int dist = v * t;\n\n    for (int i = 0; i < n; i++) {\n        int carot = d[i];\n        if (x[carot] == false && boost == false) {\n            for (int j = 0; j < dist; j++) {\n                x[carot + j] = true;\n            }\n            boost = true;\n        } else if (x[carot] == true && boost == true && number_carot < k) {\n            number_carot++; \n        } else if (x[carot] == true && boost == true && number_carot == k) {\n            for (int j = 0; j < dist; j++) {\n                x[carot + j] = true;\n            }\n            number_carot = 0; \n        }\n    }\n    int u_dist = 0;\n    int v_dist = 0;\n    for (int i = 0; i < l; i++) {\n        if (x[i] == true) {\n            v_dist++;\n        } else {\n            u_dist++;\n        }\n    }\n    printf(\"%.7f\\n\", (double)((double)v_dist / v + (double)u_dist / u));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n\n    priority_queue<pair<int, int> > q;\n    vector<int> v(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> v[i];\n        q.push(make_pair(-v[i], 1));\n    }\n\n    bool boost = false;\n    int boost_dist = 0;\n    int ignore = 0;\n    int prev = 0;\n    int carrots = 0;\n    q.push(make_pair(-L, 2));\n    while(!q.empty()) {\n        int pos = -q.top().first;\n        int type = q.top().second;\n        q.pop();\n\n        if(boost) {\n            boost_dist += pos - prev;\n        }\n        prev = pos;\n\n        if(type == 0) {\n            if(ignore) {\n                --ignore;\n                continue;\n            }\n\n            if(carrots) {\n                --carrots;\n                q.push(make_pair(-(pos+V*T), 0));\n            }\n            else {\n                boost = false;\n            }\n        }\n        else if(type == 1) {\n            if(boost) {\n                if(carrots == K) {\n                    q.push(make_pair(-(pos+V*T), 0));\n                    ++ignore;\n                }\n                else {\n                    ++carrots;\n                }\n            }\n            else {\n                q.push(make_pair(-(pos+V*T), 0));\n                boost = true;\n            }\n        }\n        else if(type == 2) {\n            break;\n        }\n\n    }\n\n    printf(\"%.7f\\n\", (double)boost_dist / V + (double)(L-boost_dist) / U);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint n, k, t, u, v, l, d[201];\n\ndouble greedy()\n{\n    double time = 0;\n    int carrot = 0;\n    int next_carrot = 0;\n    int place = 0;\n    int dash_length = v * t;\n    while (place < l) {\n        if (carrot == 0) {\n            int distance = d[next_carrot] - place;\n            time += (double)distance / u;\n            place = d[next_carrot];\n            next_carrot++;\n            carrot++;\n        }\n        else {\n            if (place + dash_length < l) {\n                carrot--;\n                while (1) {\n                    if (place + dash_length < d[next_carrot]) {\n                        time += t;\n                        place += dash_length;\n                        break;\n                    }\n                    if (carrot < k) {\n                        next_carrot++;\n                        carrot++;\n                    }\n                    else {\n                        time += (double)(d[next_carrot] - place) / v;\n                        place = d[next_carrot];\n                        next_carrot++;\n                    }\n                }\n            }\n            else {\n                time += (double)(place - l) / v;\n                place = l;\n            }\n        }\n//        cout << \"place\" << place << endl;\n//        cout << \"carrot\" << carrot << endl << endl;\n    }\n    return time;\n}\n\nint main()\n{\n    cin >> n >> k >> t >> u >> v >> l;\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n    d[n] = l; // goal\n    double ans = greedy();\n    cout << fixed << setprecision(8) <<  ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-12\n\nstruct Node {\n\tdouble t;\n\tdouble rest;\n\tint x;\n};\n\nbool operator >(Node& n1, Node& n2) {\n\treturn n1.t > n2.t;\n}\n\nint main() {\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<int> d(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> d[i];\n\t}\n\td.push_back(L);\n\n\tint x = 0;\n\tdouble t = 0, rest = 0;\n\tfor (int i = 0; i < N+1; ++i) {\n\t\tint dx = d[i]-x;\n\t\tif (V*rest >= dx - EPS) {\n\t\t\tdouble dt = (double)dx/V;\n\t\t\trest -= dt;\n\t\t\tt += dt;\n\t\t\tif ( abs(rest) < EPS ) rest = 0;\n\t\t}\n\t\telse {\n\t\t\tt += rest;\n\t\t\tt += (double)(dx - V*rest)/U;\n\t\t\trest = 0;\n\t\t}\n\n\t\trest += T;\n\t\tif (rest >= K * (T + 1) - EPS) rest = K * (T + 1);\n\n\t\tx = d[i];\n\t}\n\tprintf(\"%.10f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,k,t,u,v,l;\n  cin >> n >> k >> t >> u >> v >> l;\n  int d[n+1];\n  REP(i,n)\n    cin >> d[i];\n  d[n] = l;\n  int have = 0;\n  int now = 0;\n  double acctime = 0;\n  double res = 0;\n  REP(i,n+1) {\n    double dis = d[i] - now;\n    while(dis > 0) {\n      if (acctime > 0) {\n        if (acctime * v > dis) {\n          acctime -= dis / v;\n          res += dis / v;\n          dis = 0;\n        } else {\n          dis -= acctime * v;\n          res += acctime;\n          acctime = 0;\n        }\n      } else {\n        if (have) {\n          have--;\n          acctime = t;\n        } else {\n          res += dis / u;\n          dis = 0;\n        }\n      }\n    }\n    now = d[i];\n    have++;\n    if (have == k + 1) {\n      have = k;\n      acctime = t;\n    }\n//    cout << res << endl;\n  }\n  printf(\"%.12f\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n, k, t, u, v, l;\nbool pos[100100];\ndouble dv[100100];\n\nint main() {\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) {\n\t\tint num;\n\t\tcin >> num;\n\t\tpos[num] = 1;\n\t}\n\tint w = 0;\n\tint cnt = 0;\n\tbool f = 0;\n\trep(i, l) {\n\t\tif (!f) {\n\t\t\tif (pos[i]) {\n\t\t\t\tf = 1;\n\t\t\t\tw = t*v - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (pos[i]) {\n\t\t\t\tif (cnt < k)cnt++;\n\t\t\t\telse w = t*v - 1;\n\t\t\t}\n\t\t\tif (w > 0)w--;\n\t\t\telse {\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tw += t*v;\n\t\t\t\t}\n\t\t\t\telse f = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)dv[i] = v;\n\t\telse dv[i] = u;\n\t}\n\tdouble ans = 0;\n\trep(i, l) {\n\t\tcout << i << \" \" << dv[i] << endl;\n\t\tans += (1 / dv[i]);\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N,K,T,U,V,L;\nbool mp[10010];\n\nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  int cnt=0;\n  for(int i=0,a,A;i<N;i++){\n    cin>>a;\n    A=a;\n    while(mp[a])a++;\n    while((1.0*a-A)/V/T>K)a--;\n    for(int j=a;j<L&&j<a+T*V;j++)cnt+=!mp[j],mp[j]=1;\n  }\n\n  printf(\"%.8f\\n\",(1.0*cnt/V)+(1.0*(L-cnt)/U));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i>> pq;\n\tpq.push(i_i(L, 0));\n\twhile (N--) {\n\t\tint D; cin >> D;\n\t\tpq.push(i_i(D, 1));\n\t}\n\tbool accel = false;\n\tint d = 0, _d = 0;\n\tdouble t = 0;\n\tfor (;;) {\n\t\ti_i p = pq.top(); pq.pop();\n\t\tint x = p.first, y = p.second;\n\t\tt += (double)(x - d) / (accel ? V : U);\n\t\td = x;\n\t\tif (y == 0) break;\n\t\tif (y == 1) {\n\t\t\taccel = true;\n\t\t\t_d = max(d, _d);\n\t\t\t_d = min(d + K * (T + 1) * V, _d + T * V);\n\t\t\tpq.push(i_i(_d, -1));\n\t\t}\n\t\tif (y == -1 && x == _d) accel = false;\n\t}\n\tprintf(\"%.10f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int n, k, l;\n    double t, u, v, d[200];\n    \n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i, n){\n        cin >> d[i];\n    }\n    \n    double ans = 0.0;\n    int boost_time = 0, ninjin_p = 0, boost_cnt = 0;\n    for(int i = 1; i <= l; i++){\n        if(boost_time){\n            ans += 1.0 / v;\n            boost_time--;\n        }\n        else{\n            ans += 1.0 / u;\n        }\n        \n        if(i == d[ninjin_p]){\n            if(boost_time >= k * v){\n                boost_time = (k + 1) * v;\n            }\n            else{\n                boost_time += v;\n            }\n            if(ninjin_p < n - 1)ninjin_p++;\n        }\n    }\n    \n    printf(\"%.11lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\nconst int MAX = 100010;\nbool cal[MAX];\nll N,K,T,U,V,L;\n\nvoid input(){\n  cin >> N >> K >> T >> U >> V >> L;\n  for(int i = 0; i < N; i++){\n    int pos;\n    cin >> pos;\n    cal[pos] = true;\n  }\n}\n\nvoid solve(){\n  ld ans = 0;\n  ll boost = 0;\n\n  for(int i = 0; i < L; i++){\n    if(cal[i]) boost = min((K+1)*T*V,boost+T*V); \n    //cout << boost << endl;\n    if(boost > 0){\n      boost--;\n      ans += 1.0/(ld)V;\n    }else{\n      ans += 1.0/(ld)U;\n    }\n \n  }\n  printf(\"%.8Lf\\n\",ans);\n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 201\nusing namespace std;\nint N,K;\ndouble T,U,V,L;\ndouble D[MAX];\n\nint main()\n{\n  while(cin >> N >> K >> T >> U >> V >> L)\n    {\n      rep(i,N)cin >> D[i];\n      int cnt = 0;\n      double boost = 0;\n      double tm = 0;\n      int index = 0;\n      rep(t,L)\n\t{\n\t  if(boost == 0)tm += 1.0/U;\n\t  else\n\t    {\n\t      tm += 1.0/V;\n\t      boost--;\n\t    }\n\n\t  if(D[index] == t)\n\t    {\n\t      if(cnt < K)\n\t\t{\n\t\t  cnt++;\n\t\t}\n\t      else \n\t\t{\n\t\t  boost = V*T;\n\t\t}\t  \n\t      index++;    \n\t    }\n\n\t  if(boost == 0 && cnt > 0)\n\t    {\n\t      cnt--;\n\t      boost = V*T;\n\t    }\n\n\t}      \n      cout << setiosflags(ios::fixed) << setprecision(10) << tm << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int n, k, l;\n    double t, u, v, d[200];\n    \n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i, n){\n        cin >> d[i];\n    }\n    \n    double ans = 0.0;\n    int boost_time = 0, ninjin_p = 0, boost_cnt = 0;\n    for(int i = 1; i <= l; i++){\n        if(boost_time){\n            ans += 1.0 / v + 1e-15;\n            boost_time--;\n        }\n        else{\n            ans += 1.0 / u + 1e-15;\n        }\n        \n        if(i == d[ninjin_p]){\n            if(boost_time >= k * v){\n                boost_time = (k + 1) * v;\n            }\n            else{\n                boost_time += v;\n            }\n            if(ninjin_p < n - 1)ninjin_p++;\n        }\n    }\n    \n    printf(\"%.11lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2298.cc: Starting Line\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200;\nconst int MAX_L = 10000;\n\n/* typedef */\n\n/* global variables */\n\nbool crts[MAX_L + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, k, t, u, v, l;\n  cin >> n >> k >> t >> u >> v >> l;\n\n  for (int i = 0; i < n; i++) {\n    int cr;\n    cin >> cr;\n    crts[cr] = true;\n  }\n\n  int cn = 0;\n  double vtl = (double)t * v;\n  double ans = 0.0, r0 = 0.0, r1 = 0.0;\n\n  for (int i = 1; i <= l; i++) {\n    if (r0 < r1 && r1 <= i) {\n      ans += (r1 - r0) / v;\n      r0 = r1;\n      if (cn > 0) {\n\tcn--;\n\tr1 = min(r1 + vtl, (double)l);\n      }\n    }\n\n    if (crts[i]) {\n      if (r0 == r1) {\n\tans += ((double)i - r1) / u;\n\tr0 = i, r1 = min((double)i + vtl, (double)l);\n      }\n      else if (++cn > k) {\n\tcn--;\n\tans += ((double)i - r0) / v;\n\tr0 = i, r1 = min((double)i + vtl, (double)l);\n      }\n    }\n  }\n\n  ans += (l - r1) / u;\n  \n  printf(\"%.9lf\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n\nconstexpr double Eps = 1e-7;\n\nint main() {\n\tint N, K, T, U, V, L;\n\tstd::cin >> N >> K >> T >> U >> V >> L;\n\n\tstd::vector<int> D(N);\n\tfor (auto&& e : D)\n\t\tstd::cin >> e;\n\n\tD.push_back(L + 1);\n\n\tdouble time = 0;\n\tint boost = 0, carrot = 0, area = 0;\n\tfor (int cur = 1; cur <= L; ++cur) {\n\t\tif (boost > 0) {\n\t\t\t--boost;\n\t\t\ttime += 1.0 / V;\n\t\t}\n\t\telse\n\t\t\ttime += 1.0 / U;\n\n\t\tif (boost == 0 && carrot > 0) {\n\t\t\t--carrot;\n\t\t\tboost = V * T;\n\t\t}\n\n\t\tif (cur == D[area]) {\n\t\t\tif (carrot >= K)\n\t\t\t\tboost = V * T;\n\t\t\telse if (boost == 0)\n\t\t\t\tboost = V * T;\n\t\t\telse\n\t\t\t\t++carrot;\n\n\t\t\t++area;\n\t\t}\n\t}\n\n\tstd::cout << std::fixed << std::setprecision(8);\n\tstd::cout << time << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() \n{\n\tint N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tint d[202];\n\t\n\td[0] = 0;\n\tfor(int i=1;i<N+1;i++){\tcin >> d[i];}\n\td[N+1] = L;\n\t\n\tint dis(0); //速度Uで走らなければいけない距離\n\tint l(0); //速度Vで走れる残距離\n\tint k(0); //ニンジンを持っている個数\n\t\n\tfor(int i=0 ; i < N+1 ; i++)\n\t{\n\t\t//地点i~i+1までの走りかたを判定\n\t\tif((d[i+1]-d[i]) >= (l + k*T*V)){\n\t\t\tdis += (d[i+1]-d[i]) - l - k*T*V;\n\t\t\tl = 0;\n\t\t\tk = 0;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tk = (-(d[i+1]-d[i]) + (l + k*T*V))/(T*V);\n\t\t\tl = (-(d[i+1]-d[i]) + (l + k*T*V))%(T*V);\n\t\t}\n\t\t\n\t\t//地点i+1でのニンジンで初期化\n\t\tif(l==0){\n\t\t\tl = T*V;\n\t\t}else if(k==K){\n\t\t\tl = T*V;\n\t\t}else{\n\t\t\tk++;\n\t\t}\n\t}\n\t\n\tdouble ans = (double)dis/(double)U + (double)(L - dis)/(double)V;\n\tcout << ans << endl;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint d[210];\n\nint main() {\n\tint n,k,t,u,v,l;\n\tcin>>n>>k>>t>>u>>v>>l;\n\trepn(i,1,n)cin>>d[i];\n\td[n+1]=l;\n\tdouble res=0;\n\tint have=0,f=0;\n\trepn(i,0,n){\n\t\tdouble tm;\n\t\tint use,dis;\n\t\tif(d[i+1]-d[i]<v*t*have+f){\n\t\t\tdis=d[i+1]-d[i];\n\t\t\ttm=dis/(double)v;\n\t\t\tuse=(dis<=f)?0:(dis-f-1)/(v*t)+1;\n\t\t\tres+=tm;\n\t\t\thave-=use;\n\t\t\tf=(v*t-(dis-f)%(v*t))%v*t;\n\t\t}else{\n\t\t\tres+=t*have+f/(double)v+(d[i+1]-d[i]-v*t*have-f)/(double)u;\n\t\t\thave=0;\n\t\t\tf=0;\n\t\t}\n//debug<<res<<\" \"<<have<<\" \"<<f<<endl;\n\t\t++have;\n\t\tif(have>k){\n\t\t\tf=v*t;\n\t\t\thave=k;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N);\n  REP(i, N) cin >> D[i];\n\n\n  double res = 0;\n  double pos = 0;\n  int carrot = 0;\n  int i = 0;\n  while(i < N){\n    // move to a next carrot\n    res += (D[i] - pos) / U;\n    pos = D[i++];\n    carrot++;\n\n    while(carrot > 0 && pos < L - EPS){\n      // eat carrot\n      // cout << pos << \" \" << res << endl;      \n      carrot--;\n      double next = min(pos + T * V, (double)L);;\n\n      while(i < N && D[i] < next){\n        carrot++;\n        i++;\n      }\n\n      if(carrot > K){\n        carrot = K + 1;\n        res += (D[i-1] - pos) / V;\n        pos =  D[i-1];\n      }else{\n        res += (next - pos) / V;\n        pos = next;\n      }\n    }\n    assert(carrot == 0);\n  }\n  cout << res + (L - pos) / U << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n#define rep(i, a) for (int (i) = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int (i) = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int (i) = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int (i) = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define TRUE__ \"Yes\"\n#define FALSE__ \"No\"\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n\n#ifdef LOCAL\n\t#define lcout(a) cout << a;\n\t#define lcoutln(a) cout << a << endl;\n\t#define lcerr(a) cerr << a;\n\t#define lcerrln(a) cerr << a << endl;\n#else\n\t#define lcout(a) \n\t#define lcoutln(a) \n\t#define lcerr(a) \n\t#define lcerrln(a) \n#endif\n\nbool nin[10010];\n\nint main()\n{\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tint Pend = 0;\n\tint ninjin = 0;\n\tint Vnow = U;\n\tdouble Tnow = 0;\n\trep(i, N) {\n\t\tCIN(int, t);\n\t\tnin[t] = true;\n\t}\n\trep(i, L) {\n\t\tif (Pend <= i) {\n\t\t\tVnow = U;\n\t\t}\n\t\tif (nin[i]) {\n\t\t\tif (Vnow == U) {\n\t\t\t\tVnow = V;\n\t\t\t\tPend = i + V * T;\n\t\t\t} else if (ninjin < K) {\n\t\t\t\tninjin++;\n\t\t\t} else {\n\t\t\t\tPend = i + V * T;\n\t\t\t}\n\t\t} else if (ninjin && Vnow == U) {\n\t\t\tninjin--;\n\t\t\tVnow = V;\n\t\t\tPend = i + V * T;\n\t\t}\n\t\tTnow += (double) 1 / Vnow;\n\t}\n\tcout << fixed << setprecision(15) << Tnow << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N, K, T, U, V, L;\nbool point[10010];\n\nsigned main() {\n    cin >> N >> K >> T >> U >> V >> L;\n    rep(i,0,N) {\n        int p; cin >> p;\n        point[p] = true;\n    }\n\n    int stock = 0, prev = -1, da = 0, db = 0;\n    repq(i,1,L) {\n        if((prev < 0 || prev + T*V < i) && stock) prev = i-1, stock--;\n        (prev < 0 || prev + T*V < i ? da : db)++;\n        if(point[i]) {\n            if(stock == K) prev = i;\n            else stock++;\n        }\n    }\n    double ans = 1.0 * da / U + 1.0 * db / V;\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nInt d[210];\n\nint main() {\n\tInt n,k,t,u,v,l;\n\tcin>>n>>k>>t>>u>>v>>l;\n\trepn(i,1,n)cin>>d[i];\n\td[n+1]=l;\n\tdouble res=0;\n\tInt have=0,f=0;\n\trepn(i,0,n){\n\t\tInt use,dis;\n\t\tif(d[i+1]-d[i]<v*t*have+f){\n\t\t\tdis=d[i+1]-d[i];\n\t\t\tuse=(dis<=f)?0:(dis-f-1)/(v*t)+1;\n\t\t\tres+=dis/(double)v;\n\t\t\thave-=use;\n\t\t\tf=(v*t-(dis-f)%(v*t))%v*t;\n\t\t}else{\n\t\t\tres+=t*have+f/(double)v+(d[i+1]-d[i]-v*t*have-f)/(double)u;\n\t\t\thave=0;\n\t\t\tf=0;\n\t\t}\ndebug<<i<<\" \"<<d[i]<<\" \"<<d[i+1]<<\" \"<<res<<\" \"<<have<<\" \"<<f<<endl;\n\t\t++have;\n\t\tif(have>k){\n\t\t\tf=v*t;\n\t\t\thave=k;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n\tint ncarrot, max_have_carrot, accel_time, standard_speed, accel_speed, length;\n\tint carrot[201], suffix = 0;\n\n\tcin >> ncarrot >> max_have_carrot >> accel_time >> standard_speed >> accel_speed >> length;\n\n\tfor (int i = 0; i < ncarrot; i++) {\n\t\tcin >> carrot[i];\n\t}\n\n\tint have = 0;\n\tdouble time = 0.0, after_time = 0.0;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (carrot[suffix] == i) {\n\t\t\tif (have == 0 && after_time == 0) { //何も持っていない&加速していない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\telse if (have < max_have_carrot) { //まだ持てる\n\t\t\t\thave++;\n\t\t\t}\n\t\t\telse { //もう持てない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\tsuffix++;\n\t\t}\n\n\t\tif (after_time > 0.0) {\n\t\t\tif (after_time - (double)(1.0 / accel_speed) < 0.00000001) { //近似\n\t\t\t\tafter_time = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tafter_time -= (double)(1.0 / accel_speed);\n\t\t\t}\n\t\t\ttime += (double)(1.0 / accel_speed);\n\n\t\t\tif (after_time <= 0.0) {\n\t\t\t\tif (have > 0) {\n\t\t\t\t\thave--;\n\t\t\t\t\tafter_time = (double)accel_time;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thave = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttime += (double)(1.0 / standard_speed);\n\t\t}\n\t}\n\n\tprintf(\"%.20f\\n\", time);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\n#define N 200\nusing namespace std;\nlong long n,k,t,u,v,l,d,cnt,x,ans;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++){\n    cin>>d;\n    s[d]=true;\n  }\n  for(int i=0;i<=l;i++){\n    if(s[i]){\n      if(!x)x=v*t;\n      else if(k>cnt)cnt++;\n      else x=v*t;\n    }\n    else{\n      if(!x&&cnt>0)cnt--,x=v*t;\n    }\n    if(x)ans++;\n    if(x>0)x--;\n  }\n  printf(\"%.8f\\n\",ans*1.0/v+(l-ans)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double time = 0.0;\n\n    int speed = U;\n    double accelTime = 0.0;\n    int d_sub = 0;\n    int nowStock = 0;\n\n    int acceledDistance = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    //*\n    for(int i = 1; i <= L; i++)\n    {\n        bool isEat = false;\n\n        if(accelTime > 0.00001)\n        {\n            accelTime -= 1.0 / (double)speed;\n            if(accelTime < 0.000001)--acceledDistance;\n        }\n        else\n        {\n            accelTime = 0.0;\n            speed = U;            \n        }\n\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n\n            if(speed == U)isEat = true;\n            else\n            {\n                if(nowStock < K)nowStock++;\n                else isEat = true;\n            }\n        }\n\n        if(speed == U)\n        {\n            if(nowStock > 0)\n            {\n                --nowStock;\n                isEat = true;\n            }\n        }\n\n        if(isEat)\n        {\n            accelTime = T;\n            speed = V;\n        }\n\n        if(speed == V)++acceledDistance;\n\n        time += 1.0 / speed;\n        //if(speed == V)cout << i << \" \" << nowStock << \" \" << accelTime << endl;\n    }\n    //*/\n\n    //cout << time << endl;\n    //cout << acceledDistance << endl;\n\n    double ans = (acceledDistance / (double)V + (L - acceledDistance) / (double)U);\n    //cout << ans * 1000000 / 1000000.0 << endl;\n    printf(\"%.6lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  float lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  float ans=0.0;\n  int x=0,y,v=lv[1];\n  for(int i=1;i<=L;i++){\n    if(lv[i]==v) continue;\n    else{\n      y=i-1;\n      ans+=(float)(y-x)/v;\n      v=lv[i];\n      x=y;\n    }\n  }\n  ans+=(L-x)/v;\n  printf(\"%f\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 10e-9;\n\nint main()\n{\n  int N, K, T, U, V, L;\n  while (~scanf(\"%d %d %d %d %d %d\", &N, &K, &T, &U, &V, &L)) {\n    vector<int> D(N);\n    for (int i = 0; i < N; ++i)\n      scanf(\"%d\", &D[i]);\n\n    int carrot = 0, D_index = 0;\n    double ans = 0.0, Us = 1.0 / U, Vs = 1.0 / V, ksk_time = 0.0;\n    for (int i = 0; i < L; ++i) {\n      if (i == D[D_index]) {\n\tif ((ksk_time <= EPS && carrot == 0) || carrot == K)\n\t  ksk_time = T;\n\telse\n\t  ++carrot;\n\t++D_index;\n      }\n\n      if (ksk_time <= EPS && carrot > 0) {\n\t--carrot;\n\tksk_time = T;\n      }\n\n      if (ksk_time > EPS) {\n\tans += Vs;\n\tksk_time -= Vs;\n      } else {\n\tans += Us;\n      }\n    }\n    printf(\"%.9f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double ans = 0.0;\n\n    int speed = U;\n    int acceledDistance = 0;\n    int d_sub = 0;\n    int nowStock = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    //*\n    for(int i = 0; i < L; i++)\n    {\n        bool isEat = false;\n        bool walk = false;\n\n        if(acceledDistance > 0)\n        {\n            --acceledDistance;\n            speed = V;\n        }\n        else\n        {\n            speed= U;\n        }\n\n\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n\n            if(speed == U)isEat = true;\n            else\n            {\n                if(nowStock < K)nowStock++;\n                else isEat = true;\n            }\n        }\n        else if(speed == U)\n        {\n            if(nowStock > 0)\n            {\n                --nowStock;\n                isEat = true;\n            }\n        }\n\n        if(isEat)\n        {\n            acceledDistance = T * V;\n        }\n\n        ans += 1.0 / speed;\n        //if(speed == V)cout << i << \" \" << nowStock << \" \" << accelTime << endl;\n    }\n    //*/\n\n    //cout << time << endl;\n    //cout << acceledDistance << endl;\n    \n    //cout << ans * 1000000 / 1000000.0 << endl;\n    printf(\"%.6lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double time = 0.0;\n\n    int speed = U;\n    double accelTime = 0.0;\n    int d_sub = 0;\n    int nowStock = 0;\n\n    int acceledDistance = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    //*\n    for(int i = 0; i < L; i++)\n    {\n        bool isEat = false;\n        bool walk = false;\n\n        if(accelTime > 0.00001)\n        {\n            accelTime -= 1.0 / (double)speed;\n            if(accelTime < 0.000001)\n            {\n                walk = true;\n            }\n        \n        }\n        else\n        {\n            accelTime = 0.0;\n            speed = U;            \n        }\n\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n\n            if(speed == U)isEat = true;\n            else\n            {\n                if(nowStock < K)nowStock++;\n                else isEat = true;\n            }\n        }\n\n        if(speed == U && !isEat)\n        {\n            if(nowStock > 0)\n            {\n                --nowStock;\n                isEat = true;\n            }\n        }\n\n        if(isEat)\n        {\n            accelTime = T;\n            speed = V;\n        }\n\n        if(walk & !isEat)--acceledDistance;\n        if(speed == V)++acceledDistance;\n\n        time += 1.0 / speed;\n        //if(speed == V)cout << i << \" \" << nowStock << \" \" << accelTime << endl;\n    }\n    //*/\n\n    //cout << time << endl;\n    //cout << acceledDistance << endl;\n\n    double ans = (acceledDistance / (double)V + (L - acceledDistance) / (double)U);\n    //cout << ans * 1000000 / 1000000.0 << endl;\n    printf(\"%.6lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint main()\n{\n  int N,K,T,U,V,L,a;\n  bool nin[100001]={};\n  double ans=0;\n  pair<int,int> S;\n\n  cin>>N>>K>>T>>U>>V>>L;\n  for(int i=0;i<N;i++){\n    cin>>a;\n    nin[a]=true;\n  }\n\n  S.first=0;\n  S.second=0;\n  for(int k=0;k<L;k++){\n\n    if(nin[k]){\n      if(S.second<K){\n\tS.second++;\n\tif(S.first==0){\n\t  S.second--;\n\t  S.first=T*V;\n\t}\n      }\n      else if(S.second==K){\n\tS.first=T*V;\n      }\n    }\n\n    if(S.first==0)ans+=1/(double)U;\n    else {\n      ans+=1/(double)V;\n      S.first--;\n      if(S.first==0){\n\tif(S.second!=0){\n\t  S.second--;\n\t  S.first=T*V;\n\t}\n      }\n    }\n  }\n  \n  printf(\"%.8f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint i;\ndouble n, k, t, u, v, l, d, p = 0, tmp, rd = 0, wd = 0;\nint main(){\n        map<int, int> mp;\n        cin >> n >> k >> t >> u >> v >> l;\n        for (i = 0; i < n; i++){\n                cin >> d;\n                mp[d]++;\n        }\n        d = 0;\n        while(d < l){\n                if (mp[d] == 0){\n                        wd++;\n                        d++;\n                        continue;\n                }\n                tmp = v * t;\n                while (tmp > 0 && d < l){\n                        d++;\n                        tmp--;\n                        rd++;\n                        if (mp[d] > 0 && p < k) p++;\n                        else if(mp[d] > 0 && p == k){\n                                tmp = v * t;\n                        }\n                        if (p > 0 && tmp == 0){\n                                p--;\n                                tmp = v * t;\n                        }\n                }\n        }\n        //cout << wd << \" \" << rd << endl;//歩いた距離と走った距離をみる\n        cout << fixed << setprecision(9) << (wd / u) + (rd / v) << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n\nusing namespace std;\n\n\nint main()\n{\n    int N, K, T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    \n    vector<int> D(N);\n    for(auto &d : D)\n    {\n        cin >> d;\n    }\n\n    double time = 0.0;\n\n    int speed = U;\n    double accelTime = 0.0;\n    int d_sub = 0;\n    int nowStock = 0;\n\n    int acceledDistance = 0;\n    \n    /*\n    ?????????????????? -> ?£???????\n    ?????????????????? -> ????????????\n        ??????????????§????????? -> ?£???????\n    */\n\n    //*\n    for(int i = 0; i < L; i++)\n    {\n        bool isEat = false;\n\n        if(accelTime > 0.00001)\n        {\n            accelTime -= 1.0 / (double)speed;\n            if(accelTime < 0.000001)--acceledDistance;\n        }\n        else\n        {\n            accelTime = 0.0;\n            speed = U;            \n        }\n\n        //?????????????????????\n        if(D[d_sub] == i)\n        {\n            d_sub = min(d_sub + 1, (int)(D.size() - 1));\n\n            if(speed == U)isEat = true;\n            else\n            {\n                if(nowStock < K)nowStock++;\n                else isEat = true;\n            }\n        }\n\n        if(speed == U)\n        {\n            if(nowStock > 0)\n            {\n                --nowStock;\n                isEat = true;\n            }\n        }\n\n        if(isEat)\n        {\n            accelTime = T;\n            speed = V;\n        }\n\n        if(speed == V)++acceledDistance;\n\n        time += 1.0 / speed;\n        //if(speed == V)cout << i << \" \" << nowStock << \" \" << accelTime << endl;\n    }\n    //*/\n\n    //cout << time << endl;\n    //cout << acceledDistance << endl;\n\n    double ans = (acceledDistance / (double)V + (L - acceledDistance) / (double)U);\n    //cout << ans * 1000000 / 1000000.0 << endl;\n    printf(\"%.6lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint a, b, c, d, e, f, g;\nlong long remain;\nint speed;\nint x[10000000];\ndouble res;\nint main() {\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor (int i = 0; i < a; i++) {\n\t\tcin >> g;\n\t\tx[g] = 1;\n\t}\n\tfor (int i = 0; i < f; i++) {\n\t\tif (x[i] == 1) {\n\t\t\tif (remain / (c * e) < b) {\n\t\t\t\tremain += c * e;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg = ((c * e) - (remain % (c * e)));\n\t\t\t\tif (g == c * e) { g = 0; }\n\t\t\t\tremain += g;\n\t\t\t}\n\t\t}\n\t\tif (remain > 0) {\n\t\t\tres += 1.0 / e;\n\t\t\tremain--;\n\t\t}\n\t\telse {\n\t\t\tres += 1.0 / d;\n\t\t}\n\t}\n\tcout << setprecision(15) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n, k, t, u, v, l;\n    cin >> n;\n    cin >> k;\n    cin >> t;\n    cin >> u;\n    cin >> v;\n    cin >> l;\n    int d[n];\n    for(int i = 0; i < n; i++){\n        cin >> d[i];\n    }\n\n    const int boost_length = v * t;\n\n    int distance = 0;\n    int slow_distance = 0;\n    int carot_num = 0;\n    int reached_point;\n\n    /*1本目の人参まで*/\n    distance += d[0];\n    slow_distance += d[0];\n    carot_num++;\n    reached_point = 0;\n\n    /*2本目以降*/\n    while(distance < l){\n        if(carot_num == 0){\n            if(reached_point == (n-1)){\n                slow_distance += l - distance;            \n                distance = l;\n            } else {\n                reached_point++;\n                slow_distance += d[reached_point] - distance;\n                distance = d[reached_point];\n                carot_num++;\n            }\n        } else {\n            int old_distance = distance;\n            distance += boost_length;\n            int old_point = reached_point;\n            for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n            }\n            reached_point--;\n            carot_num += reached_point - old_point - 1;\n            while(1){\n                if(carot_num <= k){\n                    break;\n                }\n                distance += d[reached_point] - old_distance;\n                old_point = reached_point;\n                for(; d[reached_point] <= distance && reached_point < n; reached_point++){\n                }\n                reached_point--;\n                carot_num += reached_point - old_point - 1;\n                if(distance >= l){\n                    break;\n                }\n            }\n        }\n    }\n    double time = 0;\n    cout << slow_distance << endl;\n    int rest1 = slow_distance % u;\n    int rest2 = (l - slow_distance) % v;\n    time += rest1  *1.0 / u;\n    time += rest2 *1.0 / v;\n    time += slow_distance / u;\n    time += (l - slow_distance) / v;\n    cout << time << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, k;\ndouble t, u, v, l;\ndouble d[1000];\n\nint main() {\n  while (scanf(\"%d %d %lf %lf %lf %lf\", &n, &k, &t, &u, &v, &l) > 0) {\n    REP(i, n) {\n      scanf(\"%lf\", &d[i]);\n    }\n    d[n++] = l;\n    d[n++] = 1e+100;\n    double x = 0.0;\n    int have = 0;\n    double rest = 0.0;\n    double ans = 0.0;\n    int head = 0;\n\n    while (x < l) {\n      if (rest == 0.0) {\n        double nx = d[head++];\n        ans += (nx - x) / u;\n        x = nx;\n        rest = t;\n      } else {\n        double nx1 = d[head];\n        double nt1 = (nx1 - x) / v;\n        double nt = -1e+10;\n        if (nt1 < rest) {\n          head++;\n          nt = nt1;\n          if (have == k) {\n            rest = t;\n          } else {\n            rest -= nt1;\n            have++;\n          }\n        } else {\n          nt = rest;\n          if (have == 0) {\n            rest = 0.0;\n          } else {\n            rest = t;\n            have--;\n          }\n        }\n        x += nt * v;\n        ans += nt;\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,k,t,u,v,L;\n  int d;\n  int vm=0,nm,nk=0,lk;\n  cin>>n>>k>>t>>u>>v>>L;\n  cin>>d;\n  nm=d;\n  lk=d;\n  for(int i=1;i<n;i++) {\n    cin>>d;\n    if(nk<k) nk++;\n    else if(lk+v > d){\n      vm+=d-lk;\n      lk=d;\n    }\n    else {\n      while(lk+v<d && nk!=0){\n\tvm+=v;\n\tlk+=v;\n\tnk--;\n      }\n      if(nk<k) nk++;\n    }\n    nm=d;\n  }\n  if(L-lk<nk*v+v) vm+=L-d;\n  else vm+= nk*v+v;\n  //cout<<vm<<endl;\n  printf(\"%.10f\\n\",(double)vm/v+(double)(L-vm)/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > pq;\n\tpq.push(i_i(L, 0));\n\twhile (N--) {\n\t\tint D; cin >> D;\n\t\tpq.push(i_i(D, 1));\n\t}\n\tbool accel = false;\n\tint d = 0, _d = 0;\n\tdouble t = 0;\n\tfor (;;) {\n\t\ti_i p = pq.top(); pq.pop();\n\t\tint x = p.first, y = p.second;\n\t\tt += (double)(x - d) / (accel ? V : U);\n\t\td = x;\n\t\tif (y == 0) break;\n\t\tif (y == 1) {\n\t\t\taccel = true;\n\t\t\t_d = max(d, _d);\n\t\t\t_d = min(d + (K + 1) * T * V, _d + T * V);\n\t\t\tpq.push(i_i(_d, -1));\n\t\t}\n\t\tif (y == -1 && x == _d) accel = false;\n\t}\n\tprintf(\"%.10f\\n\", t);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nvector<int> cal;\nint n,k,t,u,v,l;\n\nbool input(){\t\n\tif(!(cin>>n>>k>>t>>u>>v>>l))return 0;\n\t\n\tcal = vector<int>(l+1);\n\trep(i,n){\n\t\tint a;\n\t\tcin>>a;\n\t\tcal[a] = 1;\n\t}\n\treturn 1;\n}\n\ndouble solve(){\n\t\n\tbool dush = 0;\n\tint stop = 0;\n\tint stock = 0;\n\t\n\tdouble time = 0;\n\t\n\tfor(int i=1;i<l+1;i++){\n\t\t\n\t\ttime += (dush) ? 1.0/v : 1.0/u;\n\t\t\n\t\t//printf(\"dush %d   stop %d  stock %d   time  %lf  i=%d\\n\",dush,stop,stock,time,i);\n\t\t\n\t\t\n\t\tif(stop==i){\n\t\t\tdush = 0;\n\t\t}\n\t\t\n\t\tif(!dush && stock){\n\t\t\tdush = 1;\n\t\t\tstop = i+v*t;\n\t\t\tstock--;\n\t\t}\n\t\t\n\t\tif(cal[i]==1){\n\t\t\tif(!dush){\n\t\t\t\tdush = 1;\n\t\t\t\tstop = i+v*t;\n\t\t\t}else{\n\t\t\t\tif(stock!=k)stock++;\n\t\t\t\telse{\n\t\t\t\t\tstop = i+v*t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\treturn time;\n\t\n}\n\nvoid call_solve(){\n\tprintf(\"%.9lf\\n\",solve());\n}\n\n\nint main(){\n\twhile(input()){\n\t\tcall_solve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nint N,K,T,U,V,L;\nint carrot[100010];\nint down[100010];\n\nint main(){\n    while(cin >> N >> K >> T >> U >> V >> L){\n        rep(i,L+1) carrot[i] = down[i] = 0;\n        rep(i,N){\n            int D; cin >> D;\n            carrot[D] = 1;\n        }\n        int have = 0;\n        double ans = 0;\n        int rem = 0;\n        loop(i,1,L+1){\n            if(rem) ans += 1./V;\n            else ans += 1./U;\n            if(rem) rem--;\n            if(have && !rem){\n                have--;\n                rem = V*T;\n            }\n            if(carrot[i]){\n                if(!rem){\n                    carrot[i]--;\n                    rem = V*T;\n                }\n                if(have + carrot[i] > K){\n                    carrot[i]--;\n                    rem = V*T;\n                    have = K;\n                } else {\n                    have+=carrot[i];\n                }\n            }\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l;\n  cin>>n>>k>>t>>u>>v>>l;\n  int i,j;\n  set<int> s;\n  for(i=0;i<n;i++){\n    cin >> j;\n    s.insert(j);\n  }\n  int p=0,h=0,x=0;\n  double ans=0;\n  for(i=1;i<=l;i++){\n    \n    if(x==0){\n      if(h>0){\n\tx=v*t-1;h--;\n\tans+=1.0/v;\n      }else ans+=1.0/u;\n    }else{\n      ans+=1.0/v;\n      x--;\n    }\n    if(s.find(i)!=s.end()){\n      if(h<k) h++;\n      else{\n\tx=v*t;\n      }\n    }\n    \n    cout << i << \":\" << h << \"/\";\n    printf(\"%.9lf\\n\",ans);\n  }\n\n  printf(\"%.9lf\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint cal[20000];\n\nint main() {\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    for (int i = 0; i < n; i++) {\n        int d;\n        cin >> d;\n        cal[d]++;\n    }\n    int h = 0, rem = 0;\n    double ans = 0;\n    for (int cur = 1; cur <= l; cur++) {\n        if (rem > 0) {\n            rem--;\n            ans += 1.0 / v;\n        } else {\n            ans += 1.0 / u;\n        }\n        if (h > 0 && rem == 0) {\n            h--;\n            rem = v * t;\n        }\n        if (cal[cur]) {\n            if (rem == 0) {\n                rem = v * t;\n            } else {\n                if (h + cal[cur] > k) {\n                    h = k;\n                    rem = v * t;\n                } else {\n                    h += cal[cur];\n                }\n            }\n        }\n    }\n    cout << fixed << setprecision(10) << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n\tint ncarrot, max_have_carrot, accel_time, standard_speed, accel_speed, length;\n\tint carrot[201], suffix = 0;\n\n\tcin >> ncarrot >> max_have_carrot >> accel_time >> standard_speed >> accel_speed >> length;\n\n\tfor (int i = 0; i < ncarrot; i++) {\n\t\tcin >> carrot[i];\n\t}\n\n\tint have = 0;\n\tdouble time = 0.0, after_time = 0.0;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (carrot[suffix] == i) {\n\t\t\tif (have == 0 && after_time == 0) { //何も持っていない&加速していない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\telse if (have < max_have_carrot) { //まだ持てる\n\t\t\t\thave++;\n\t\t\t}\n\t\t\telse { //もう持てない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\tsuffix++;\n\t\t}\n\n\t\tif (after_time > 0.0) {\n\t\t\tif (after_time - (double)(1.0 / accel_speed) < 0.00000001) { //近似\n\t\t\t\tafter_time = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tafter_time -= (double)(1.0 / accel_speed);\n\t\t\t}\n\t\t\ttime += (double)(1.0 / accel_speed);\n\n\t\t\tif (after_time <= 0.0) {\n\t\t\t\tif (have > 0) {\n\t\t\t\t\thave--;\n\t\t\t\t\tafter_time = (double)accel_time;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thave = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttime += (double)(1.0 / standard_speed);\n\t\t}\n\t}\n\n\tprintf(\"%.100f\\n\", time);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define RREP(i, a, n) for(int i=n-1; i<=a; i--)\n#define INF 1e9\n\nint main()\n{\n\tint N, K, T, U, V, L;\n\tint D[201];\n\tcin >> N >> K >> T >> U >> V >> L;\n\tREP(i, 0, N) cin >> D[i];\n\tD[N] = L;\n\t\n\tint cnt = 0;\n\tdouble ans = 0.0, res = 0.0;\n\tREP(i, 0, N + 1) {\n\t\tdouble dist = D[i];\n\t\tif (i - 1 >= 0) dist -= D[i - 1];\n\n\t\twhile (dist > 0.0) {\n\t\t\tif (res > 0.0) {\n\t\t\t\tans += min(dist / V, res);\n\n\t\t\t\tdouble ndist = dist - min(dist, res*V);\n\t\t\t\tdouble nres = res - min(dist / V, res);\n\t\t\t\tdist = ndist;\n\t\t\t\tres = nres;\n\t\t\t}\n\n\t\t\tif (cnt > 0 && res == 0.0) {\n\t\t\t\tres = T;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\tif (res == 0.0) {\n\t\t\t\tans += 1.0*dist / U;\n\t\t\t\tdist = 0.0;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt == K) res = T;\n\t\telse cnt++;\n\t}\n\n\tprintf(\"%.6lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n\nbool solve() {\n    int N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n    vector<int> D(N); cin >> D;\n    sort(all(D));\n    int carrot = 0;\n    int left_time = 0;\n    int high_speed_range = 0;\n    int di = 0;\n    rep(l, L) {\n        if(di < N and D[di] == l) {\n            if(carrot == K) left_time = T * V;\n            else carrot++;\n            di++;\n        }\n        if(carrot > 0 and left_time == 0) {\n            carrot--;\n            left_time = T * V;\n        }\n\n        high_speed_range += (left_time > 0);\n        left_time = max(0, left_time - 1);\n    }\n    printf(\"%.10f\\n\", (double)(L - high_speed_range) / U + (double)(high_speed_range) / V);\n    \n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main()\n{\n\tdouble ans=0.0;\n\tint n,k,t,u,v,l, time=0, carrot=0;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tset<int> d;\n\trep(i, n){\n\t\tint temp;\n\t\tcin >> temp;\n\t\td.insert(temp);\n\t}\n\trep(i, l){\n\t\tif (d.count(i)){\n\t\t\tif (carrot < k){\n\t\t\t\tcarrot++;\n\t\t\t}else{\n\t\t\t\ttime = v*t;\n\t\t\t}\n\t\t}\n\t\tif (time == 0 && carrot > 0){\n\t\t\tcarrot--;\n\t\t\ttime = v*t;\n\t\t}\n\t\tif (time > 0){\n\t\t\ttime--;\n\t\t\tans += 1.0/v;\n\t\t}else{\n\t\t\tans += 1.0/u;\n\t\t}\n\t}\n\tcout << setprecision(9) << fixed << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-12\n\nstruct Node {\n\tdouble t;\n\tdouble rest;\n\tint x;\n};\n\nbool operator >(Node& n1, Node& n2) {\n\treturn n1.t > n2.t;\n}\n\ntypedef long long ll;\n\nint main() {\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<int> d(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> d[i];\n\t}\n\td.push_back(L);\n\n\tll rest = 0;\n\tint x = 0;\n\tll vl = 0, ul = 0;\n\tfor (int i = 0; i < N+1; ++i) {\n\t\tint dx = d[i]-x;\n\t\tif (rest >= dx) {\n\t\t\tvl += dx;\n\t\t\trest -= dx;\n\t\t}\n\t\telse {\n\t\t\tvl += rest;\n\t\t\tul += dx-rest;\n\t\t\trest = 0;\n\t\t}\n\n\t\trest += (ll)T * V;\n\t\tif (rest >= (ll)K * (T + 1) * V) rest = (ll)K * (T + 1) * V;\n\n\t\tx = d[i];\n\t}\n\tprintf(\"%.10f\\n\", (double)((long double)vl/V + (long double)ul/U));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nint main(){\n  lli n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<lli> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<int> course(l + 2, 0);\n  for (int i = 0; i < n; i++) {\n    course[d[i]]++;\n    course[min(d[i] + t*v, l + 1)]--;\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    course[i + 1] = min(course[i + 1] + course[i], k + 1);\n  }\n\n  for (int i = 0; i < l; i++) {\n    if(course[i] == 0 and sum > 0)sum--, course[i]++;\n    sum += max(course[i] - 1, 0);\n    course[i] = (course[i] > 0);\n  }\n  sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n  }\n  std::cout << setprecision(15) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    vector<int> carrot(l+1);\n    for (int i = 0; i < n; ++i) {\n        int d;\n        scanf(\"%d\", &d);\n        carrot[d]++;\n    }\n    int boost = 0, cnt = 0;\n    double ans = 0;\n    for (int cur = 0; cur < l; ++cur) {\n        if(carrot[cur]) {\n            if(cnt == k) boost = t*v;\n            else {\n                cnt++;\n                if(boost == 0){\n                    boost = t*v;\n                    cnt--;\n                }\n            }\n        }\n        if(boost){\n            ans += 1.0 / v;\n            boost--;\n            if(boost == 0 && cnt){\n                boost = t*v;\n                cnt--;\n            }\n        }else {\n            ans += 1.0 / u;\n        }\n    }\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n#define MOD (1000000007)\n#define ALL(v) (v).begin(), (v).end()\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    vector<int> d(n);\n    vector<bool> isNinjin(100001, false);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> d[i];\n        isNinjin[d[i]] = true;\n    }\n\n    int kasokukyori = 0;\n    int stock = 0;\n    long double ans = 0.0;\n\n    for (int np = 0; np < l; np++)\n    {\n        if (isNinjin[np])\n        {\n            if (stock == k)\n            {\n                kasokukyori = t * v;\n            }\n            else\n            {\n                stock++;\n                if (kasokukyori == 0)\n                {\n                    kasokukyori = t * v;\n                    stock--;\n                }\n            }\n            ans += 1.0 / v;\n            kasokukyori--;\n\n            if (kasokukyori == 0 && stock > 0)\n            {\n                kasokukyori = t * v;\n                stock--;\n            }\n        }\n        else\n        {\n            if (kasokukyori > 0)\n            {\n                ans += 1.0 / v;\n                kasokukyori--;\n                if (kasokukyori == 0 && stock > 0)\n                {\n                    kasokukyori = t * v;\n                    stock--;\n                }\n            }\n            else\n            {\n                ans += 1.0 / u;\n            }\n        }\n    }\n    cout << fixed;\n    cout << setprecision(10) << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<iomanip>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<lli, lli> pii;\n\nint main(){\n  lli n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<lli> d(n);\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n    que.push(pii(d[i], 0));\n  }\n  que.push(pii(l, 1));\n  double ans = 0, prev, pos = 0, end = 0;\n  bool fast = false;\n  lli carrot = 0;\n  while(not que.empty()){\n    prev = pos;\n    pos = que.top().first;\n    ans += (pos - prev)/((fast)?v:u);\n    int event = que.top().second;\n    que.pop();\n    if(event == 0){\n      if(fast == false){\n        fast = true;\n        end = min((double)l, pos + v*t);\n        que.push(pii(min((double)l, pos + v*t), 1));\n      }else if(carrot == k){\n        end = min((double)l, pos + v*t);\n        que.push(pii(min((double)l, pos + v*t), 1));\n      }else{\n        carrot = min(k, carrot + 1);\n      }\n    }else if(end <= pos + 1e-9){\n      if(carrot > 0){\n        carrot--;\n        end = min((double)l, pos + v*t);\n        que.push(pii(min((double)l, pos + v*t), 1));\n      }else{\n        fast = false;\n      } \n      \n    }\n  }\n  printf(\"%.12lf\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N, K, T, U, V, L;\nint main() {\n  cin >> N >> K >> T >> U >> V >> L;\n  //  int D[N];\n  //  for (int i = 0; i < N; i++) cin >> D[i];\n\n  int V_time = N * T;\n  L = L - V * V_time;\n\n  double sec;\n  sec = L / (double)U;\n  sec += V_time;\n\n  cout.precision(6); cout << showpoint << sec << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\n\nint main(int argc, char *argv[])\n{\n  int n,k,t,u,v,l;\n  cin >> n >> k >> t >> u >> v >> l;\n  priority_queue<pair<double,int> > q;  \n  rep(i,n){\n    int d;\n    cin >> d;\n    q.push(mp(-d,0));\n  }\n\n  int ha=0;\n  int sp=u;\n  double be=0;\n  double ans=0;\n  double mint=0;\n  q.push(mp(-l,2));\n  while(!q.empty()){\n    double di=-q.top().F;\n    int fl=q.top().S;\n    q.pop();\n    if(fl==1 && mint>di+EPS) continue;\n    //cout << di << ' ' << fl << endl;\n    ans += (di-be)/sp;\n    if(fl==2) break;\n    be=di;\n    if(fl){\n      if(ha){\n        --ha;\n        mint=di+v*t;\n        q.push(mp(-mint,1));\n      }else sp=u;\n    }else{\n      if(ha==k || sp==u) mint=di+v*t,q.push(mp(-mint,1));\n      else ++ha;\n      sp=v;\n    }\n  }\n  \n  printf(\"%.8f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\tint N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\n\tvector<int> D(N);\n\tREP(i,0,N) cin >> D[i];\n\n\tdouble time=0;\n\tint carot=0,limit=0;\n\tREP(i,0,L){\n\t\tdump(i);\n\t\tbool flag=false;\n\t\tREP(j,0,N) if(D[j]==i){\n\t\t\tflag=true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(flag&&carot+1>K){\n\t\t\tlimit=T*V;\n\t\t\tflag=false;\n\t\t}\n\t\tif(flag) ++carot;\n\t\tif(limit==0&&carot>0){\n\t\t\tlimit=T*V;\n\t\t\t--carot;\n\t\t}\n\t\t\n\t\tif(limit>0) time+=1./V;\n\t\telse time+=1./U;\n\n\t\tif(limit>0) --limit;\n\t}\n\n\tcout << fixed << setprecision(9) << time << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n, k, t, u, v, l;\nbool pos[100100];\ndouble dv[100100];\n\nint main() {\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) {\n\t\tint num;\n\t\tcin >> num;\n\t\tpos[num] = 1;\n\t}\n\tint w = 0;\n\tint cnt = 0;\n\tbool f = 0;\n\trep(i, l) {\n\t\tif (!f) {\n\t\t\tif (pos[i]) {\n\t\t\t\tf = 1;\n\t\t\t\tw = t*v - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (pos[i]) {\n\t\t\t\tif (cnt < k)cnt++;\n\t\t\t\telse w = t*v - 1;\n\t\t\t}\n\t\t\tif (w > 0)w--;\n\t\t\telse {\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tw += t*v;\n\t\t\t\t}\n\t\t\t\telse f = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)dv[i] = v;\n\t\telse dv[i] = u;\n\t}\n\tdouble ans = 0;\n\trep(i, l) {\n\t\tcout << i << \" \" << dv[i] << endl;\n\t\tans += (1 / dv[i]);\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint N,K,T,U,V,L;\n\tcin >>N>>K>>T>>U>>V>>L;\n\t\n\tqueue<int> q;\n\tfor(int i=0; i<N; i++){\n\t\tint pos;\n\t\tcin >> pos;\n\t\tq.push(pos);\n\t}\n\t\n\tint stock=0;\n\tint nowpos;\n\tdouble time=0;\n\twhile(1){\n\t\tif(stock==0){\n\t\t\tif(!q.empty() && nowpos+U >= q.front()){\n\t\t\t\ttime += (q.front()-nowpos)/(double)U;\n\t\t\t\tnowpos = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tstock++;\n\t\t\t}else if(nowpos+U >= L){\n\t\t\t\ttime += (L-nowpos)/(double)U;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime +=\t1;\n\t\t\t\tnowpos += U;\n\t\t\t}\n\t\t}else{\n\t\t\tstock--;\n\t\t\tif(nowpos+T*V >= L){\n\t\t\t\ttime += (L-nowpos)/(double)V;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime += T;\n\t\t\t\tnowpos += T*V;\n\t\t\t\tint last;\n\t\t\t\twhile(!q.empty() && nowpos >= q.front()){\n\t\t\t\t\tstock++;\n\t\t\t\t\tlast = q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t\tif(stock > K){\n\t\t\t\t\tstock = K+1;\n\t\t\t\t\ttime -= (nowpos-last)/(double)V;\n\t\t\t\t\tnowpos = last;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << fixed;\n\tcout << setprecision(8);\n\tcout << time << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nlong long D[210];\n\nint main() {\n  long long N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  for (int i = 0; i < N; ++i) {\n    cin >> D[i+1];\n  }\n  D[0] = 0;\n  D[N+1] = L;\n  long long ninjin = 0;\n  double ret = 0;\n  double boostDist = 0;\n  for (int i = 0; i < N + 1; ++i) {\n    double dist = D[i+1] - D[i];\n    if (boostDist >= dist) {\n      ret += dist / V;\n      boostDist -= dist;\n    } else {\n      double restDist = dist - boostDist;\n      ret += boostDist / V;\n      long long use = min(ninjin, (long long)ceil(restDist / (V * T)));\n      ninjin -= use;\n      boostDist = V * T * use;\n      if (boostDist > restDist) {\n        ret += restDist / V;\n        boostDist -= restDist;\n      } else {\n        ret += boostDist / V;\n        ret += (restDist - boostDist) / U;\n        boostDist = 0;\n      }\n    }\n    ++ninjin;\n    if (ninjin > K) {\n      ninjin = K;\n      boostDist = V * T;\n    }\n  }\n  printf(\"%.9f\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,cnt,x,ans;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++){\n    cin>>d;\n    s[d]=true;\n  }\n  for(int i=0;i<=l;i++){\n    if(s[i]){\n      if(!x||k==cnt)x=v*t;\n      else cnt++;\n    }\n    else if(!x&&cnt>0)cnt--,x=v*t;\n    if(x>0)ans++,x--;\n  }\n  printf(\"%.8f\\n\",ans*1.0/v+(l-ans)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum{CARROT,BATERU,GOAL};\nstruct Event{\n    int type;\n    double pos;\n};\n\nbool operator<(const Event &lhs,const Event &rhs){\n    return lhs.pos==rhs.pos ? lhs.type>rhs.type : lhs.pos>rhs.pos;\n}\n\n\nint main(){\n    int n,k,t,u,v,l;\n    cin>>n>>k>>t>>u>>v>>l;\n        vector<int> d(n);\n        for(int i=0;i<n;i++) cin>>d[i];\n        priority_queue<Event> que;\n        for(int i=0;i<n;i++){\n            que.push(Event{CARROT,d[i]});\n        }\n        que.push(Event{GOAL,l});\n        double ver=u;\n        double pos=0;\n        int cnt=0;\n        int charge=0;\n        double res=0;\n        while(true){\n            Event eve=que.top(); que.pop();\n            res+=(eve.pos-pos)/ver;\n            pos=eve.pos;\n            \n            if(eve.type==CARROT){\n                \n                if(cnt==k){\n                    charge++;\n                    que.push({Event{BATERU,pos+v*t}});\n                }\n                else{\n                    \n                    cnt=cnt+1;\n                    if(ver==u){\n                        assert(charge==0);\n                        cnt--;\n                        charge++;\n                        ver=v;\n                        que.push({Event{BATERU,pos+v*t}});\n                    }\n                }\n            }\n            else if(eve.type==GOAL){\n                break;\n            }\n            else if(eve.type==BATERU){\n                \n                charge--;\n                if(charge==0){     \n                    if(cnt>0){\n                        cnt--;\n                        charge++;\n                        que.push(Event{BATERU,pos+t*v});\n                    }\n                    else{\n                        ver=u;\n                    }\n                }\n                \n            }\n        }\n        cout<<setprecision(10)<<fixed;\n        cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,t,u,v,l,d[210],a,p,q;\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  for(int i=1;i<=n+1;i++){\n    q=d[i]-d[i-1];\n    if(a>q){\n      a-=q;\n      a=min(a+v*t,v*t*(k+1));\n    }\n    else p+=q-a,a=v*t;\n  }\n  printf(\"%.8f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,k,t,u,v,l;\n\nint d[210];\n\nint main(void){\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i,n) cin >> d[i];d[n]=l;\n\tdouble ans=0.0,res=0.0,num=0;\n\trep(i,n+1){\n\t\tdouble dist=d[i];\n\t\tif(i-1>=0) dist-=d[i-1];\n\t\twhile(dist>0.0){\n\t\t\tif(res>0.0) ans+=min(dist/v,res),dist-=min(dist,res*v),res-=min(dist/v,res);\n\t\t\tif(num>0) res=t,num--;\n\t\t\tif(res==0.0) ans+=1.0*dist/u,dist=0.0;\n\t\t}\n\t\tif(num==k)\n\t\t\tres=t;\n\t\telse\n\t\t\tnum++;\n\t}\n\tcout.precision(10);\n\tcout << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() \n{\n\tlong N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tlong d[202];\n\t\n\td[0] = 0;\n\tfor(int i=1;i<N+1;i++){\tcin >> d[i];}\n\td[N+1] = L;\n\t\n\tlong dis(0); //速度Uで走らなければいけない距離\n\tlong l(0); //速度Vで走れる残距離\n\tlong k(0); //ニンジンを持っている個数\n\t\n\tfor(int i=0 ; i < N+1 ; i++)\n\t{\n\t\t//地点i~i+1までの走りかたを判定\n\t\tif((d[i+1]-d[i]) >= (l + k*T*V)){\n\t\t\tdis += (d[i+1]-d[i]) - l - k*T*V;\n\t\t\tl = 0;\n\t\t\tk = 0;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tk = (-(d[i+1]-d[i]) + (l + k*T*V))/(T*V);\n\t\t\tl = (-(d[i+1]-d[i]) + (l + k*T*V)+T*V/*ナゾ*/)%(T*V);\n\t\t}\n\t\t\n\t\t//地点i+1でのニンジンで初期化\n\t\tif(l==0){\n\t\t\tl = T*V;\n\t\t}else if(k==K){\n\t\t\tl = T*V;\n\t\t}else{\n\t\t\tk++;\n\t\t}\n\t\t\n\t}\n\tdouble ans = (double)dis/(double)U + (double)(L - dis)/(double)V;\n\t\n\tcout << fixed << setprecision(6) << ans << endl;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n, k, t, u, v, l;\nbool pos[100100];\ndouble dv[100100];\n\nint main() {\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) {\n\t\tint num;\n\t\tcin >> num;\n\t\tpos[num] = 1;\n\t}\n\tint w = 0;\n\tint cnt = 0;\n\tbool f = 0;\n\trep(i, l) {\n\t\tif (!f) {\n\t\t\tif (pos[i]) {\n\t\t\t\tf = 1;\n\t\t\t\tw = t*v - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (pos[i]) {\n\t\t\t\tif (cnt < k)cnt++;\n\t\t\t\telse w = t*v - 1;\n\t\t\t}\n\t\t\tif (w > 0)w--;\n\t\t\telse {\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tw += t*v;\n\t\t\t\t}\n\t\t\t\telse f = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)dv[i] = v;\n\t\telse dv[i] = u;\n\t}\n\tdouble ans = 0;\n\trep(i, l) {\n\t\tcout << i << \" \" << dv[i] << endl;\n\t\tans += (1 / dv[i]);\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint main(){\n    int n,k,t,u,v,l,tmp;\n    bool car[10001];\n    cin >> n >> k >> t >> u >> v >> l;\n\n    memset(car,false,sizeof(car));\n\n    for(int i=0;i<n;i++){\n        cin >> tmp;\n        car[tmp] = true;\n    }\n\n    int stock = 0;\n    double ret = 0;\n    double rem = 0;\n    for(int i=0;i<l;i++){\n        if(rem > 0){\n            //食べている状態で\n            if(car[i]){\n                if(stock == k){ //ストックがいっぱい\n                    rem = t; //たべる\n                }else{\n                    stock++; //ためる\n                }\n            }\n\n            if(rem*v >= 1-EPS){ //次の1mは切れない\n                rem -= 1.0 / v;\n                ret += 1.0 / v;\n            }else{ //途中で切れる\n                if(stock > 0){//stockがある\n                    printf(\"%d--%d eat carrot\\n\",i,i+1);\n                    stock--;\n                    rem = 1.0 / v - rem;\n                    ret += 1.0 / v;\n                }else{\n                    ret += rem + (1 - rem * v) / u;\n                    rem = 0;\n                }\n            }\n            \n        }else{\n            //食べていなく、\n            if(car[i] || stock > 0){//にんじんがある\n                if(stock > 0) stock--;\n                rem = t; //たべる\n                rem -= 1.0/v; //1m走る\n                ret += 1.0/v; //結果+\n            }else{\n                ret += 1.0/u; //普通に走る\n            }\n        }\n        if(abs(rem) < EPS) rem = 0;\n    }\n    printf(\"%.8lf\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N,K,T,U,V,L;\nbool mp[10010];\n \nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  int cnt=0;\n  for(int i=0,a,A;i<N;i++){\n    cin>>a;\n    A=a;\n    while(mp[a])a++;\n    while((1.0*a-A)/V/T>K)a--;\n    for(int j=a;j<L&&j<a+T*V;j++)cnt+=!mp[j],mp[j]=1;\n  }\n \n  printf(\"%.8f\\n\",(1.0*cnt/V)+(1.0*(L-cnt)/U));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 1000000000;\nint main(){\n  cout << fixed << setprecision(6);\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N);\n  for (int i = 0; i < N; i++){\n    cin >> D[i];\n  }\n  vector<bool> d(L, false);\n  for (int i = 0; i < N; i++){\n    d[D[i]] = true;\n  }\n  vector<int> speed(L, U);\n  int last = - INF;\n  int cnt = 0;\n  for (int i = 0; i < L; i++){\n    if (d[i]){\n      if (cnt < K){\n        cnt++;\n      } else {\n        last = i;\n        for (int j = i; j < min(i + T * V, L); j++){\n          speed[j] = V;\n        }\n      }\n    }\n    if (i >= last + T * V){\n      if (cnt > 0){\n        cnt--;\n        for (int j = i; j < min(i + T * V, L); j++){\n          speed[j] = V;\n        }\n        last = i;\n      }\n    }\n  }\n  double ans = 0;\n  for (int i = 0; i < L; i++){\n    ans += (double) 1 / speed[i];\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nint n,k,t,u,v,l,d,c,x,a,s[M];\n \nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=1;\n  for(int i=0;i<l;i++){\n    if(s[i])\n      if(!x||k==c)x=v*t;\n      else c++;\n    else if(!x&&c)c--,x=v*t;\n    if(x)a++,x--;\n  }\n  printf(\"%.8f\\n\",a*1.0/v+(l-a)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    int N,K,T,U,V,L; cin >> N >> K >> T >> U >> V >> L;\n    vector<int> D(N);\n    for (int i=0;i<N;++i) cin >> D[i];\n    int rest=0,carrot=0,now=0;\n    double ans=0;\n    for (int i=1;i<=L;++i){\n        if (rest>0) ans+=(double)1.0/V,--rest;\n        else ans+=(double)1.0/U;\n        if (now<N&&D[now]==i){\n            ++now;\n            if (carrot==K) rest=T*V;\n            else ++carrot;\n        }\n        if (rest==0&&carrot>0) rest=T*V,--carrot;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#if 0\nusing namespace std;\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define int ll\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n#endif\nsigned main() {\n    int N, K, T, U, V, L;\n    scanf(\"%d %d %d %d %d %d\", &N, &K, &T, &U, &V, &L);\n\n    std::vector<int>  C(L+1);\n    for (int i=0; i<N; ++i) {\n        int D;\n        scanf(\"%d\", &D);\n        ++C[D];\n    }\n\n    int num_carrot=0;\n    int remain=0;\n    std::vector<int> F(L+1);\n    for (int i=0; i<=L; ++i) {\n        if (remain-- > 0)\n            F[i] = 1;\n\n        if (C[i])\n            ++num_carrot;\n\n        if (num_carrot) {\n            if (remain <= 0 || num_carrot > K) {\n                --num_carrot;\n                remain = V*T;\n            }\n        }\n    }\n\n    int dist[2]={};\n    for (int i=0; i<L; ++i)\n        ++dist[F[i+1]];\n\n    printf(\"%.16f\\n\", (dist[0]*1.0/U)+(dist[1]*1.0/V));\n    return 0;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    double tt = 0;\n    int len = 0;\n    int nc = 0;\n    for (int i = 0; i < n; ++i) {\n        int d;\n        cin >> d;\n        while (len <= d && nc) {\n            len += t * v;\n            tt += t;\n            --nc;\n        }\n        if (len < d) {\n            tt += (d - len) / (u * 1.0);\n            len = d;\n        }\n        if (nc == k) {\n            tt += t - (len - d) / (v * 1.0);\n            len = d + t * v;\n            --nc;\n        }\n        ++nc;\n    }\n    {\n        int d = l;\n        while (len <= d && nc) {\n            len += t * v;\n            tt += t;\n            --nc;\n        }\n        if (len < d) {\n            tt += (d - len) / (u * 1.0);\n            len = d;\n        }\n    }\n    printf(\"%.9lf\\n\", tt - (len - l) / (v * 1.0));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> D[i];\n\t}\n\tdouble res = 0;\n\tbool boost = false;\n\tint ind,rem,car;\n\tind = rem = car = 0;\n\tfor (int l = 1; l < L+1; ++l) {\n\t\tif (boost) {\n\t\t\tres += (double)1/V;\n\t\t}\n\t\telse {\n\t\t\tres += (double)1/U;\n\t\t}\n\n\t\tif (l == D[ind]) {\n\t\t\tif (car == K || (!boost)) {\n\t\t\t\trem = (V * T) + 1;\n\t\t\t\tboost = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++car;\n\t\t\t}\n\t\t\t++ind;\n\t\t}\n\n\t\tif (rem > 0) {\n\t\t\t--rem;\n\t\t\tif (rem == 0) {\n\t\t\t\tif (car > 0) {\n\t\t\t\t\trem = V * T;\n\t\t\t\t\t--car;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tboost = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(30) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\t\n\tqueue<int> q;\n\tfor(int i=0; i<N; i++){\n\t\tint pos;\n\t\tcin >> pos;\n\t\tq.push(pos);\n\t}\n\t\n\tint stock=0;\n\tint nowpos;\n\tdouble time=0;\n\twhile(1){\n\t\tif(stock==0){\n\t\t\tif(!q.empty() && nowpos+U >= q.front()){\n\t\t\t\ttime += (q.front()-nowpos)/(double)U;\n\t\t\t\tnowpos = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tstock++;\n\t\t\t}else if(nowpos+U >= L){\n\t\t\t\ttime += (L-nowpos)/(double)U;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime +=\t1;\n\t\t\t\tnowpos += U;\n\t\t\t}\n\t\t}else{\n\t\t\tstock--;\n\t\t\tif(nowpos+T*V >= L){\n\t\t\t\ttime += (L-nowpos)/(double)V;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime += T;\n\t\t\t\tnowpos += T*V;\n\t\t\t\tint last;\n\t\t\t\twhile(!q.empty() && nowpos >= q.front()){\n\t\t\t\t\tstock++;\n\t\t\t\t\tlast = q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t\tif(stock > K){\n\t\t\t\t\tstock = K+1;\n\t\t\t\t\ttime -= (nowpos-last)/(double)V;\n\t\t\t\t\tnowpos = last;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << fixed;\n\tcout << setprecision(10);\n\tcout << time << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n#define N_MAX 201\n#define L_MAX 10001\n#define ll long long\n\n\n//??????????????¨??????\nint N,K,T,U,V,L;\nint D[N_MAX];\n\n//????§???????index(m)?????¨???????????°??£???????????????\nbool run[L_MAX];\n\n//?????¨???????????????????????£????????????\nint carrot=0;\n\n//???????????????????????°???????????¨???m?¶??????§?????????\nint lestRun=0;\n\n//?¬???????????????????D???????????????\nint nextCarrot=0;\n\n//????§??????????????????????????????§??????\nint meter=0;\n\nint main() {\n\t//??\\?????¨?????????\n\tcin>>N>>K>>T>>U>>V>>L;\n\trep(i,N)cin>>D[i];\n\trep(i,L)run[i]=false;\n\n\t//??????????????????????????????\n\twhile(meter<L){\n\t\tif(D[nextCarrot]==meter){\n\t\t\t//???????????????\n\t\t\tcarrot++;nextCarrot++;\n\t\t\t\n\t\t\t//??¢?????????????????????????£????\n\t\t\tif(carrot>K){lestRun=T*V;carrot--;}\n\t\t}\n\n\t\t//??????????¶????????????£???????£???????????????????\n\t\tif(lestRun==0 && carrot>0){carrot--;lestRun+=T*V;}\n\n\t\t//????±???°????????¶????????£???????????°??£?????????????????????\n\t\tif(lestRun>0){run[meter]=true;lestRun--;}\n\n\t\t//??????\n\t\tmeter++;\n\t}\n\t//????±???°??£????????¢\n\tint runDist=0;\n\trep(i,L)if(run[i])runDist++;\n\n\t//??????\n\tcout<< (double)runDist/V + (double)(L-runDist)/U <<endl;\n\n\t//???????????°\n\t//rep(i,L)cout<<i<<\" : \"<<run[i]<<endl;\n\n\t//cin>>N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nInt d[210];\n\nint main() {\n\tInt n,k,t,u,v,l;\n\tcin>>n>>k>>t>>u>>v>>l;\n\trepn(i,1,n)cin>>d[i];\n\td[n+1]=l;\n\tdouble res=0;\n\tInt have=0,f=0;\n\trepn(i,0,n){\n\t\tInt use,dis;\n\t\tif(d[i+1]-d[i]<v*t*have+f){\n\t\t\tdis=d[i+1]-d[i];\n\t\t\tuse=(dis<=f)?0:(dis-f-1)/(v*t)+1;\n\t\t\tres+=dis/(double)v;\n\t\t\thave-=use;\n\t\t\tf=(v*t-(dis-f)%(v*t))%(v*t);\n\t\t}else{\n\t\t\tres+=t*have+f/(double)v+(d[i+1]-d[i]-v*t*have-f)/(double)u;\n\t\t\thave=0;\n\t\t\tf=0;\n\t\t}\ndebug<<i<<\" \"<<res<<\" \"<<have<<\" \"<<f<<endl;\n\t\t++have;\n\t\tif(have>k){\n\t\t\tf=v*t;\n\t\t\thave=k;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nenum State{Carrot, End};\n\ntypedef struct Event{\n    int x;\n    State state;\n    \n    bool operator<( const Event& right ) const {\n        return x>right.x;\n    }\n}Event;\n\nint N, K, T, U, V, L;\nvector<int> D;\n\nint main(){\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    cin >> N >> K >> T >> U >> V >> L;\n    D.resize(N);\n    for(auto &v: D) cin >> v;\n    \n    priority_queue<Event> que;\n    for(auto v: D)\n        que.push(Event({v, Carrot}));\n    \n    vector<bool> zone(L);\n    int count = 0;\n    while(!que.empty()){\n        auto event = que.top(); que.pop();\n        if(event.state == Carrot){\n            if(zone[event.x]){\n                if(count < K){\n                    count++;\n                }else{\n                    que.push({event.x + T*V, End});\n                    for(int x=min(L, event.x+T*V)-1; event.x<=x && !zone[x]; x--)\n                        zone[x] = true;\n                }\n            }else{\n                que.push({event.x + T*V, End});\n                for(int x=min(L, event.x+T*V)-1; event.x<=x && !zone[x]; x--)\n                    zone[x] = true;\n            }\n        }else{\n            if(count && !zone[event.x]){\n                count--;\n                que.push({event.x + T*V, End});\n                for(int x=min(L, event.x+T*V)-1; event.x<=x && !zone[x]; x--)\n                    zone[x] = true;\n            }\n        }\n    }\n    \n    double span = 0;\n    for(int i=0; i<L; i++)\n        span += zone[i];\n    \n    cout << (L-span)/U + span/V << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint main(){\n    int n, K, T, U, V, L;\n    scanf(\"%d%d%d%d%d%d\", &n, &K, &T, &U, &V, &L);\n    bool exist[L];\n    memset(exist, false, sizeof(exist));\n    rep(i, n){\n        int d;\n        scanf(\"%d\", &d);\n        exist[d] = true;\n    }\n\n    int have = 0, rest = 0;\n    double ans = 0;\n    rep(i, L){\n        if(rest == i) rest = 0;\n        have += exist[i];\n        if(have > K || (rest == 0 && have > 0)){\n            --have;\n            rest = i + T * V;\n            ans += 1.0 / V;\n        }\n        else{\n            if(rest == i) rest = 0;\n            ans += 1.0 / (rest ? V : U);\n        }\n    }\n    printf(\"%.10lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// k個まで持てる 速度は普段はuで食べるとt秒間v ゴールはl\n// 基本拾ったら/効果が切れたらすぐ食ってk個持ってる状態で拾うなら拾う直前に食う\n// 持ってる個数がm、ブーストの残り時間がb\nint n, k, t, u, v, l, d, m;\ndouble b, s;\nbool g[10010];\n\nsigned main() {\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i,n) {\n\t\tcin >> d;\n\t\tg[d] = 1;\n\t}\n\trepst(i,1,l) {\n\t\tif (!deq(b,0) && b>0) {\n\t\t\tb -= 1./v;\n\t\t\ts += 1./v;\n\t\t} else {\n\t\t\tif (m) m--, b = t-1./v, s += 1./v;\n\t\t\telse s += 1./u;\n\t\t}\n\t\tif (g[i]) {\n\t\t\tif (deq(b,0) || m==k) b = t;\n\t\t\telse m++;\n\t\t}\n\t}\n\tprintf(\"%.14lf\\n\",s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N,K,U,L;\ndouble cnt,V,T;\nbool mp[10010];\n\nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  for(int i=0,a,A;i<N;i++){\n    cin>>a;A=a;\n    while(mp[a]&&(a-A)/V/T<K)a++;\n    for(int j=a;j<L&&j<a+T*V;j++)cnt+=!mp[j],mp[j]=1;\n  }\n\n  printf(\"%.8f\\n\",cnt/V+(L-cnt)/U);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main(){\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  int D[N];\n  for(int i = 0; i < N; ++i)\n    cin >> D[i];\n  int t = 0, s = 0, r = 0, f = 0;\n  for(int i = 0; i <= L; ++i){\n    if(r > 0){\n      ++f;\n      --r;\n    }\n    if(t < N && D[t] == i){\n      ++t;\n      ++s;\n    }\n    if((r == 0 && s > 0) || s > K){\n      r = T*V;\n      --s;\n    }\n  }\n  printf(\"%.10f\\n\",(double)f/V + (double)(L-f)/U);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-7;\n\nint n, k;\ndouble d[210], t, u, v, l;\ndouble dp[210][210];\n\nint main(){\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) cin >> d[i];\n\td[n++] = l;\n\t\n\trep(i, n) rep(j, n) dp[i][j] = INF;\n\tdp[0][1] = d[0] / u;\n\t\n\tdouble res = INF;\n\trep(i, n) rep(j, k + 1) if(dp[i][j] < INF){\n\t\tint ni = i + 1, nj = j;\n\t\tdouble dist = d[i], next = dp[i][j];\n\t\t\n\t\tdp[ni][nj] = min(dp[ni][nj], next + (d[ni] - dist) / u);\n\t\t\n\t\twhile(ni < n){\n\t\t\twhile(nj > 0 && dist + EPS < d[ni]){\n\t\t\t\tnj--;\n\t\t\t\tdist += t * v;\n\t\t\t\tnext += t;\n\t\t\t}\n\t\t\tif(dist + EPS > d[n - 1]){\n\t\t\t\tres = min(res, next - (dist - d[n - 1]) / v);\n\t\t\t}\n\t\t\tif(dist + EPS < d[ni]){\n\t\t\t\tnj++;\n\t\t\t\tdp[ni][nj] = min(dp[ni][nj], next + (d[ni] - dist) / u);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(nj == k){\n\t\t\t\tnext = next - (dist - d[ni]) / v + t;\n\t\t\t\tdist = d[ni] + t * v;\n\t\t\t}\n\t\t\tni++;\n\t\t\tnj = min(nj + 1, k);\n\t\t}\n\t}\n\trep(i, k + 1) res = min(res, dp[n - 1][i]);\n\tprintf(\"%.9f\\n\", res);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <vector> \n\nusing namespace std;\ntypedef vector<int> VI;\n\nint main(void) {\n    int n;\n    int k;\n    int t;\n    int u;\n    int v;\n    int l;\n    cin >> n >> k >> t >> u >> v >> l;\n    VI d(n);\n    vector<bool> x(l, false);\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n    int number_carot = 0;\n    bool boost = false;\n    int dist = v * t;\n\n    for (int i = 0; i < n; i++) {\n        int carot = d[i];\n        if (x[carot] == false && boost == false) {\n            for (int j = 0; j < dist; j++) {\n                x[carot + j] = true;\n            }\n            boost = true;\n        } else if (x[carot] == true && boost == true && number_carot < k) {\n            number_carot++; \n        } else if (x[carot] == true && boost == true && number_carot == k) {\n            for (int j = 0; j < dist; j++) {\n                x[carot + j] = true;\n            }\n            number_carot = 0; \n        }\n    }\n    int u_dist = 0;\n    int v_dist = 0;\n    for (int i = 0; i < l; i++) {\n        if (x[i] == true) {\n            v_dist++;\n        } else {\n            u_dist++;\n        }\n    }\n    cout << v_dist / v + u_dist / u << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define EQ(a,b)\t(abs(a - b) <= EPS)\n\nint main() {\n\n\tint n, k;\n\tdouble t, u, v, l;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tvector<double> d(n);\n\n\trep(i, n) {\n\t\tcin >> d[i];\n\t}\n\td.push_back(l);\n\n\tdouble time = 0.0;\n\tint cnt = 0, i = 0;\n\tdouble now = 0.0;\n\tdouble rest = 0.0;\n\n\twhile (i < d.size()) {\n\t\twhile (!EQ(now, d[i])) {\n\t\t\tdouble move = min(rest * v, d[i] - now);\n\t\t\ttime += move / v;\n\t\t\tnow += move;\n\t\t\trest -= move / v;\n\t\t\tif (EQ(rest, 0)) {\n\t\t\t\tif (cnt == 0)break;\n\t\t\t\tcnt--;\n\t\t\t\trest = t;\n\t\t\t}\n\t\t}\n\t\tif (!EQ(now, d[i])) {\n\t\t\ttime += (d[i] - now) / u;\n\t\t\tnow = d[i];\n\t\t}\n\t\ti++;\n\t\tcnt++;\n\t\tif (cnt == k + 1) {\n\t\t\tcnt--;\n\t\t\trest = t;\n\t\t}\n\t}\n\tcout << fixed << setprecision(30) << time << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,k,t,u,v,L;\n  int d;\n  int vm=0,nm,nk=0,lk;\n  cin>>n>>k>>t>>u>>v>>L;\n  cin>>d;\n  nm=d;\n  lk=d;\n  for(int i=1;i<n;i++) {\n    cin>>d;\n    if(nk<k) nk++;\n    else if(lk+v > d){\n      vm+=d-lk;\n      lk=d;\n    }\n    else {\n      while(lk+v<d && nk!=0){\n\tvm+=v;\n\tlk+=v;\n\tnk--;\n      }\n    }\n    nm=d;\n  }\n  if(L-d<nk*v+v) vm+=L-d;\n  else vm+= nk*v+v;\n  //cout<<vm<<endl;\n  printf(\"%.10f\\n\",(double)vm/v+(double)(L-vm)/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define INF 999999999\n\nint main(){\n\tint n, k, t, u, v, l, d[200], cal[10000], have=0, run=0;\n\tdouble ans = 0;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tfor(int i=0; i<l; i++){\n\t\tcal[i] = 0;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tcin >> d[i];\n\t\tcal[ d[i]-1 ] = 1;\n\t}\n\t\n\tint running = 0, walking =0;\n\t\n\tfor(int i=0; i<l; i++){\n\t\tif(have > 0 && run == 0){\n\t\t\trunning++;\n\t\t\thave--;\n\t\t\trun = v * t - 1;\n\t\t}\n\t\telse if(run > 0){\n\t\t\trunning++;\n\t\t\trun--;\n\t\t}\n\t\telse{\n\t\t\twalking++;\n\t\t}\n\t\t\n\t\tif(cal[i] == 1 && have < k){\n\t\t\thave++;\n\t\t}\n\t\telse if(cal[i] == 1 && have == k){\n\t\t\trun = v * t;\n\t\t}\n\t}\n\t\n\tans = (double)running / (double)v + (double)walking / (double)u;\n\t\n\tprintf(\"%.7f\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  int n, k, t, u, v, l;\n  cin >> n >> k >> t >> u >> v >> l;\n  map<int, bool> mp;\n  for(int i=0;i<n;++i) {\n    int tmp; cin >> tmp;\n    mp[tmp] = true;\n  }\n  double tmpu = 1.0 / u, tmpv = 1.0 / v;\n  int cnt = 0;\n  double time = 0.0;\n  double ans = 0.0;\n  for(int i=0;i<l;++i) {\n    if(cnt > 0 && time < eps) {\n      time = t;\n      cnt--;\n    }\n    if(mp[i] && (time < eps || cnt == k)) {\n      time = t;\n    } else if(mp[i]) {\n      cnt ++;\n    }\n    if(time > eps) {\n      ans += tmpv;\n      time -= tmpv;\n    } else {\n      ans += tmpu;\n      time -= tmpu;\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# 2 \"2298.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <memory>\n\nnamespace algorithm {\n   using namespace std;\n\n   template <class TNode>\n   class IBFS {\n   private:\n      queue <TNode> Q;\n      virtual void init() = 0;\n      virtual TNode get_start() = 0;\n      virtual bool is_goal( TNode ) = 0;\n      virtual void find_next( TNode ) = 0;\n\n   public:\n      IBFS() {\n         Q = queue <TNode>();\n      }\n\n      TNode run() {\n         init();\n         Q.push( get_start() );\n         while ( ! Q.empty() ) {\n            TNode node = Q.front();\n            Q.pop();\n            if ( is_goal( node ) ) {\n               return node;\n            }\n            find_next( node );\n         }\n         return TNode();\n      }\n\n      void push_next( TNode node ) {\n         Q.push(node);\n      }\n\n   };\n}\n\n\nnamespace solution {\n   using namespace std;\n   using namespace algorithm;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int SIZE = 201;\n   const int MAX_LENGTH = 10001;\n   const int NONE = -1.0;\n   const double EPS = 1e-9;\n   int N;\n   int K;\n   int T;\n   int U;\n   int V;\n   int L;\n   bool D[MAX_LENGTH];\n\n\n   bool lessthan_equal( double a, double b ) {\n      if ( fabs( a - b ) < EPS ) return true;\n      return a < b;\n   }\n\n   class Solution {\n   private:\n      void init() {\n         for ( int i = 0; i < MAX_LENGTH; ++ i ) {\n            D[i] = false;\n         }\n      }\n\n      bool input() {\n         if ( ! ( cin >> N >> K >> T >> U >> V >> L ) ) return false;\n         for ( int i = 0; i < N; ++ i ) {\n            int d;\n            cin >> d;\n            D[d] = true;\n         }\n         return true;\n      }\n\n      class Node {\n      public:\n         double cost;\n         int id;\n         int remains;\n         int carrots;\n         Node(): cost(NONE){}\n         Node( double cost, int id, int remains, int carrots ):\n            cost(cost), id(id), remains(remains), carrots(carrots) {}\n         friend ostream& operator << ( ostream& os, Node node ) {\n            return os << node.cost << \", \" << node.id << \", \"\n                      << node.remains << \", \" << node.carrots << \" / \";\n         }\n      };\n\n      class BFS: public IBFS<Node> {\n      private:\n         double base;\n         double fast;\n\n         void init() {\n            base = 1.0 / U;\n            fast = 1.0 / V;\n         }\n\n         Node get_start() {\n            return Node( 0.0, 0, 0, 0 );\n         }\n\n         bool is_goal( Node node ) {\n            return node.id == L;\n         }\n\n      public:\n         void find_next( Node node ) {\n            Node next_node = node;\n\n            if ( D[next_node.id] ) {\n               if ( next_node.carrots == K ) {\n                  next_node.remains = T * V;\n               } else {\n                  next_node.carrots ++;\n                  if ( next_node.remains == 0 ) {\n                     next_node.remains = T * V;\n                     next_node.carrots --;\n                  }\n               }\n            }\n\n            double t = base;\n            if ( next_node.remains ) {\n               t = min( t, fast );\n               next_node.remains --;\n            }\n            if ( next_node.remains == 0 && next_node.carrots ) {\n               next_node.remains = T * V;\n               next_node.carrots --;\n            }\n            next_node.cost += t;\n            next_node.id += 1;\n\n            push_next( next_node );\n         }\n      };\n\n      double solve() {\n         return BFS().run().cost;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            printf( \"%.9f\\n\", solve() );\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<iomanip>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<lli, lli> pii;\n\nint main(){\n  lli n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<lli> d(n);\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n    que.push(pii(d[i], 0));\n  }\n  que.push(pii(l, 1));\n  double ans = 0, prev, pos = 0, end = 0;\n  bool fast = false;\n  lli carrot = 0;\n  while(not que.empty()){\n    prev = pos;\n    pos = que.top().first;\n    ans += (pos - prev)/((fast)?v:u);\n    int event = que.top().second;\n    que.pop();\n    if(event == 0){\n      if(fast == false){\n        fast = true;\n        end = min((double)l, pos + v*t);\n        que.push(pii(min((double)l, pos + v*t), 1));\n      }else if(carrot == k){\n        end = min((double)l, pos + v*t);\n        que.push(pii(min((double)l, pos + v*t), 1));\n      }else{\n        carrot = min(k, carrot + 1);\n      }\n    }else if(end <= pos + 1e-9){\n      if(carrot > 0){\n        carrot--;\n        end = min((double)l, pos + v*t);\n        que.push(pii(min((double)l, pos + v*t), 1));\n      }else{\n        fast = false;\n      } \n      \n    }\n  }\n  printf(\"%.12lf\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,c,x,a,s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=1;\n  for(int i=0;i<l;i++){\n    if(s[i])\n      if(!x||k==c)x=v*t;\n      else c++;\n    else if(!x&&c)c--,x=v*t;\n    if(x)a++,x--;\n  }\n  printf(\"%.8f\\n\",a*1.0/v+(l-a)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,t,u,v,l,d[210],a,p;\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  for(int i=1;i<=n+1;i++){\n    if(a>d[i]-d[i-1]){\n      a-=d[i]-d[i-1];\n      a=min(a+v*t,v*t*(k+1));\n    }\n    else p+=d[i]-d[i-1]-a,a=v*t;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n, k, t, u, v, l;\nbool pos[100100];\ndouble dv[100100];\n\nint main() {\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) {\n\t\tint num;\n\t\tcin >> num;\n\t\tpos[num] = 1;\n\t}\n\tint w = 0;\n\tint cnt = 0;\n\tbool f = 0;\n\trep(i, l) {\n\t\tif (!f) {\n\t\t\tif (pos[i]) {\n\t\t\t\tf = 1;\n\t\t\t\tw = t*v - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (pos[i]) {\n\t\t\t\tif (cnt < k)cnt++;\n\t\t\t\telse w = t*v - 1;\n\t\t\t}\n\t\t\tif (w > 0)w--;\n\t\t\telse {\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tw += t*v;\n\t\t\t\t}\n\t\t\t\telse f = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)dv[i] = v;\n\t\telse dv[i] = u;\n\t}\n\tdouble ans = 0;\n\trep(i, l) {\n\t\t//cout << i << \" \" << dv[i] << endl;\n\t\tans += (1 / dv[i]);\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,a,n) for(int i=a;i<n;i++)\nusing namespace std;\nint n,k,x,p,l,a[201],v,u,t,c[11111];\ndouble ans,o=1;\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  r(i,0,n)cin>>a[i],c[a[i]]=1;\n  r(i,1,l+1){\n    ans+=x?o/v:o/u;\n    if(x&&p+t*v==i)x--,p=i;\n    if(c[i]){\n      if(++x==1)p=i;\n      if(x-1>k)x--,p=i;\n    }\n  }\n  printf(\"%.9f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\ntypedef enum { CARROT, DOWN, GOAL } Event;\nstruct event {\n  int dist;\n  Event ev;\n  event(int d, Event e) : dist(d), ev(e) {}\n  bool operator<(const event& that) const { return dist > that.dist; }\n};\n\nint main()\n{\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  priority_queue<event> q;\n  q.push(event(L, GOAL));\n  for (int i = 0; i < N; i++) {\n    int d;\n    cin >> d;\n    q.push(event(d, CARROT));\n  }\n\n  bool running = false;\n  int running_dist = 0;\n  int prev = 0;\n  int have = 0;\n  int ignore = 0;\n  bool goal = false;\n  while (!q.empty() && !goal) {\n    const Event ev = q.top().ev;\n    const int dist = q.top().dist;\n    q.pop();\n    if (running) {\n      running_dist += dist - prev;\n    }\n    switch (ev) {\n      case CARROT:\n        if (running) {\n          if (have == K) {\n            // over boost\n            ++ignore;\n            q.push(event(dist+V*T, DOWN));\n          } else {\n            ++have;\n          }\n        } else {\n          q.push(event(dist+V*T, DOWN));\n          running = true;\n        }\n        break;\n      case DOWN:\n        if (ignore > 0) {\n          --ignore;\n        } else {\n          if (have > 0) {\n            --have;\n            q.push(event(dist+V*T, DOWN));\n          } else {\n            running = false;\n          }\n        }\n        break;\n      case GOAL:\n        goal = true;\n        break;\n    }\n    prev = dist;\n  }\n\n  printf(\"%.6f\\n\", running_dist/double(V) + (L-running_dist)/double(U));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,k,t,u,v,L;\n  int d;\n  int vm=0,nm,nk=0,lk;\n  cin>>n>>k>>t>>u>>v>>L;\n  cin>>d;\n  nm=d;\n  lk=d;\n  for(int i=1;i<n;i++) {\n    cin>>d;\n    if(nk<k) nk++;\n    else if(lk+v > d){\n      vm+=d-lk;\n      lk=d;\n    }\n    else {\n      while(lk+v<d && nk!=0){\n\tvm+=v;\n\tlk+=v;\n\tnk--;\n      }\n      nk++;\n    }\n    nm=d;\n  }\n  if(L-lk<nk*v+v) vm+=L-d;\n  else vm+= nk*v+v;\n  //cout<<vm<<endl;\n  printf(\"%.10f\\n\",(double)vm/v+(double)(L-vm)/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tint N,K,T,U,V,L;\n\tcin >>N>>K>>T>>U>>V>>L;\n\t\n\tqueue<int> q;\n\tfor(int i=0; i<N; i++){\n\t\tint pos;\n\t\tcin >> pos;\n\t\tq.push(pos);\n\t}\n\t\n\tint stock=0;\n\tint nowpos;\n\tdouble time=0;\n\twhile(1){\n\t\tif(stock==0){\n\t\t\tif(!q.empty() && nowpos+U >= q.front()){\n\t\t\t\ttime += (q.front()-nowpos)/(double)U;\n\t\t\t\tnowpos = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tstock++;\n\t\t\t}else if(nowpos+U >= L){\n\t\t\t\ttime += (L-nowpos)/(double)U;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime +=\t1;\n\t\t\t\tnowpos += U;\n\t\t\t}\n\t\t}else{\n\t\t\tstock--;\n\t\t\tif(nowpos+T*V >= L){\n\t\t\t\ttime += (L-nowpos)/(double)V;\n\t\t\t\tnowpos = L;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\ttime += T;\n\t\t\t\tnowpos += T*V;\n\t\t\t\tint last;\n\t\t\t\twhile(!q.empty() && nowpos >= q.front()){\n\t\t\t\t\tstock++;\n\t\t\t\t\tlast = q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t\tif(stock > K){\n\t\t\t\t\tstock = K+1;\n\t\t\t\t\ttime -= (nowpos-last)/(double)V;\n\t\t\t\t\tnowpos = last;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << fixed;\n\tcout << setprecision(10);\n\tcout << time << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nint main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n    int n,k,L;\n    double t,u,v;\n    cin>>n>>k>>t>>u>>v>>L;\n    int d[n+1];\n    for(int i=0;i<n;i++){\n        cin>>d[i];\n    }\n    double ans = 0;\n    int cal=0;\n    d[n] = 0;\n    int l=0;\n    int calt=t*v;\n    for(int i=1;i<=L;i++){\n        if(calt<t*v){\n            calt++;\n            ans += 1/v;\n            if(calt>=t*v && cal) cal--,calt=0;\n        }\n        else{\n            ans += 1/u;\n        }\n        if(i==d[l]){\n            l++;\n            if(cal==k) calt=0;\n            else cal++;\n            if(calt>=t*v) cal--,calt=0;\n        }\n    }\n    cout << setprecision(10) << ans << endl;\n    //printf(\"%.10f\",ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l,d[201]={0};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  int a=0,p=0,st=0;\n  for(int i=1;i<=n+1;i++){\n    if(a+st*v*t>d[i]-d[i-1]){\n      if(a>=d[i]-d[i-1])a-=d[i]-d[i-1];\n      else st-=(d[i]-d[i-1]-a)/(v*t),a=0;\n      if(st<k)st++;\n      else if(st==k)a=v*t;\n    }\n    else p+=d[i]-d[i-1]-a-st*v*t,a=v*t,st=0;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXN 220\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint D[MAXN];\n\nint N, K, T, U, V, L;\n\nint main(void) {\n    cin >> N >> K >> T >> U >> V >> L;\n    if (U >= V) {\n        cout << 1.0 * L / U << endl;\n        return 0;\n    }\n    D[0] = 0;\n    for (int i = 1; i <= N; i++) {\n        cin >> D[i];\n    }\n    D[N+1] = L;\n    int cur = 0; // 今の位置がどのポイントを超えたところか(例えばD[1]の人参を超えたらcur = 1)\n    double pos = 0, time = 0; // 位置,時間\n    int car = 0; // 持ってる人参の数\n    bool boost = false; // ダッシュしてるかどうか\n    double boost_time = 0; // ダッシュの残り時間\n    while (cur < N+1) {\n        double next;\n        if (!boost) {\n            next = D[cur+1];\n            time += (next - pos) / U;\n            cur++;\n            boost = true;\n            boost_time = T;\n        } else {\n            // ダッシュが先に切れるかそれとも次の人参が先に来るか\n            // ダッシュが先に切れる\n            if (pos + boost_time * V < D[cur + 1]) {\n                next = pos + boost_time * V;\n                time += boost_time;\n                if (car > 0) {\n                    boost_time = T;\n                    car--;\n                } else {\n                    boost = false;\n                    boost_time = 0;\n                }\n            } else {\n                next = D[cur+1];\n                cur++;\n                time += (next - pos) / V;\n                if (car < K) {\n                    car++;\n                    boost_time -= (next - pos) / V;\n                } else {\n                    boost_time = T;\n                }\n            }\n        }\n        pos = next;\n    }\n    printf(\"%.10f\\n\", time);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n\tint ncarrot, max_have_carrot, accel_time, standard_speed, accel_speed, length;\n\tint carrot[201], suffix = 0;\n\n\tcin >> ncarrot >> max_have_carrot >> accel_time >> standard_speed >> accel_speed >> length;\n\n\tfor (int i = 0; i < ncarrot; i++) {\n\t\tcin >> carrot[i];\n\t}\n\n\tint have = 0;\n\tdouble time = 0.0, after_time = 0.0;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (carrot[suffix] == i) {\n\t\t\tif (have == 0 && after_time == 0) { //何も持っていない&加速していない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\telse if (have < max_have_carrot) { //まだ持てる\n\t\t\t\thave++;\n\t\t\t}\n\t\t\telse { //もう持てない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\tsuffix++;\n\t\t}\n\n\t\tif (after_time > 0.0) {\n\t\t\tif (after_time - (double)(1.0 / accel_speed) < 0.00000001) { //近似\n\t\t\t\tafter_time = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tafter_time -= (double)(1.0 / accel_speed);\n\t\t\t}\n\t\t\ttime += (double)(1.0 / accel_speed);\n\n\t\t\tif (after_time <= 0.0) {\n\t\t\t\tif (have > 0) {\n\t\t\t\t\thave--;\n\t\t\t\t\tafter_time = (double)accel_time;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thave = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttime += (double)(1.0 / standard_speed);\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\", time);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i, j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n    }\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l,d[201]={0};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  int a=0,p=0,st=0;\n  for(int i=1;i<=n+1;i++){\n    if(a+st*v*t>d[i]-d[i-1]){\n      if(a>=d[i]-d[i-1])a-=d[i]-d[i-1];\n      else st-=(d[i]-d[i-1]-a)/(v*t),a=0;\n      if(st<k)st++;\n      else if(st==k)a=v*t;\n    }\n    else p+=d[i]-d[i-1]-a-st*v*t,a=0,st=1;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nint main(){\n  int N,K,T,L;\n  double U,V;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N+1,0);\n  D[N+1]=0;\n  for(int i=0;i<N;++i){\n    cin >> D[i];\n  }\n  double Time=0;\n  int pos=0;\n  int Npos=0;\n  int until=0;\n  while(pos < L){\n    if(pos==D[Npos]){\n      ++Npos;\n      until+=T*V;\n      if(until>(K+1)*T*V){\n\tuntil=(K+1)*T*V;\n      }\n    }\n    //cout << \"proceed\" << endl;\n\n    if(until==0){\n      Time+=1/U;\n    }else{\n      Time+=1/V;\n      --until;   \n    }\n    pos+=1;\n  }\n  cout << setiosflags(ios::fixed) << setprecision(15) << Time << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(void){\n    int n, k, t, u, v, l;\n    int i;\n    long long j;\n    int input;\n    int dd = 0;\n    double ans;\n    cin >> n >> k >> t >> u >> v >> l;\n    int map[10005] = {};\n    for(i = 0; i < n; i++){\n        cin >> input;\n        map[input] = 1;\n    }\n\n    j = 0;\n    for(i = 0; i < l; i++){\n        if(map[i] == 1){\n            j = j + t*v;\n            if(j >= (k+1)*t*v){\n                j = (k+1)*t*v;\n            }\n            if(j > l - i + 1 || j < 0){\n                dd += l - i;\n                break;\n            }\n        }   \n    \n        if(j > 0){\n            dd++;\n            j--;\n        }\n        //cout << i << \" \" << dd << \" \" << j << endl;\n    }\n    //cout << dd <<endl;\n\n    ans = (double)dd/v + (double)(l-dd)/u;\n\n    std::cout << std::fixed;\n    std::cout << std::setprecision(10) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nint n,k,t,u,v,l,d,c,x,a,s[M];\n  \nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=1;\n  for(int i=0;i<l;i++){\n    if(s[i])\n      if(!x||k==c)x=v*t;\n      else c++;\n    else if(!x&&c)c--,x=v*t;\n    if(x)a++,x--;\n  }\n  printf(\"%.8f\\n\",a*1.0/v+(l-a)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define INF 1<<30\n#define EPS 1e-8\n#define mp make_pair\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n\tint n, k, l;\n\tdouble t, u, v;\n\tcin >> n >> k >> t >> u >> v >> l;\n\n\tbool d[100005];\n\tmemset(d, 0, sizeof(d));\n\n\trep(i, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\td[x] = true;\n\t}\n\n\tdouble ans = 0;\n\tdouble time = 0.0;\n\tint cnt = 0;\n\n\trep(i, l) {\n\t\tif(d[i]) {\n\t\t\tif(cnt == k) time = t;\n\t\t\telse cnt++;\n\t\t}\n\n\t\tif(equals(time, 0.0)) {\n\t\t\tif(cnt > 0) {\n\t\t\t\ttime = t;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\n\t\tif(time > EPS) {\n\t\t\tans += 1.0 / v;\n\t\t\ttime -= 1.0 / v;\n\t\t} else {\n\t\t\tans += 1.0 / u;\n\t\t}\n\t}\n\n\tcout << fixed;\n\tcout.precision(20);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<int> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<int> course(l + 1, 0);\n  for (int i = 0; i < n; i++) {\n    course[d[i]]++;\n    course[min(d[i] + t*v, l)]--;\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    course[i + 1] += course[i];\n  }\n  for (int i = 0; i < l; i++) {\n    course[i + 1] = min(course[i + 1], k + 1);\n  }\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n  }\n  std::cout << setprecision(12) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,k,t,u,v,l;\n\nint d[210];\n\nint main(void){\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i,n) cin >> d[i];d[n]=l;\n\tdouble ans=0.0,res=0.0,num=0;\n\trep(i,n+1){\n\t\tdouble dist=d[i];\n\t\tif(i-1>=0) dist-=d[i-1];\n\t\twhile(dist>0.0){\n\t\t\tif(res>0.0){\n\t\t\t\tans+=min(dist/v,res);\n\t\t\t\tdouble ndist=dist-min(dist,res*v);\n\t\t\t\tdouble nres=res-min(dist/v,res);\n\t\t\t\tdist=ndist,res=nres;\n\t\t\t}\n\t\t\tif(num>0&&res==0.0) res=t,num--;\n\t\t\tif(res==0.0) ans+=1.0*dist/u,dist=0.0;\n\t\t}\n\t\tif(num==k)\n\t\t\tres=t;\n\t\telse\n\t\t\tnum++;\n\t}\n\tcout.precision(10);\n\tcout << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int n, k, l;\n    double t, u, v, d[200];\n    \n    cin >> n >> k >> t >> u >> v >> l;\n    REP(i, n){\n        cin >> d[i];\n    }\n    \n    double ans = 0.0;\n    int boost_time = 0, ninjin_p = 0;\n    for(int i = 1; i <= l; i++){\n        if(boost_time){\n            ans += 1.0 / v + 1e-13;\n            boost_time--;\n        }\n        else{\n            ans += 1.0 / u + 1e-13;\n        }\n        \n        if(i == d[ninjin_p]){\n            if(boost_time > k * v){\n                boost_time = (k + 1) * v;\n            }\n            else{\n                boost_time += v;\n            }\n            if(ninjin_p < n - 1)ninjin_p++;\n        }\n    }\n    \n    printf(\"%.11lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\ndouble EPS = 1e-9;\n\nint main(){\n\tint n, k, T, u, v, l;\n\tcin >> n >> k >> T >> u >> v >> l;\n\tvector<int> d(n);\n\trep(i, n) cin >> d[i];\n\td.push_back(l);\n\n\tdouble pos = 0, time = 0, car = 0;\n\tint cnt = 0;\n\n\tauto mov = [](double from, double to, double vel){\n\t\treturn (to - from) / vel;\n\t};\n\n\twhile (pos + EPS < l){\n\t\tint nxt = upper_bound(ALL(d), pos) - d.begin();\n\n\t\tif (car > EPS){\n\t\t\tdouble t = mov(pos, d[nxt], v);\n\t\t\tif (car < t){\n\t\t\t\ttime += car;\n\t\t\t\tpos += car*v;\n\t\t\t\tcar = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttime += t;\n\t\t\t\tpos = d[nxt];\n\t\t\t\tcar -= t;\n\t\t\t\t++cnt;\n\t\t\t\tif (cnt > k) car = 0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdouble t = mov(pos, d[nxt], u);\n\t\t\tif (cnt == 0){\n\t\t\t\ttime += t;\n\t\t\t\tpos = d[nxt];\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt--;\n\t\t\t\tcar = T;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tcout << time << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,k,t,u,v,l,d[200];\n  double time,pos;\n  int b,i;\n\n  cin >> n >> k >> t >> u >> v >> l;\n  for(i=0;i<n;i++)cin >> d[i];\n\n  time = 0.0;\n  pos = 0.0;\n  b = 0;\n  i = 0;\n\n  while(1){\n    if(!b){\n      if(i==n){\n\ttime += (double)(l-pos)/u;\n\tbreak;\n      }\n      time += (double)(d[i]-pos)/u;\n      pos = d[i];\n      b++;\n      i++;\n    }else{\n      b--;\n      if(pos + v*t >= l){\n\ttime += (double)(l-pos)/v;\n\tbreak;\n      }\n      if(d[i] > pos + v*t){\n\ttime += t;\n\tpos += v*t;\n      }else{\n\twhile(i<n && d[i]<pos + v*t){\n\t  i++;\n\t  b = b+1;\n\t  if(b>k)break;\n\t}\n\tif(b>k){\n\t  time += (double)(d[i-1]-pos)/v;\n\t  pos = d[i-1];\n\t}else{\n\t  time += t;\n\t  pos += v*t;\n\t}\n      }\n    }\n  }\n\n  printf(\"%.8lf\\n\",time);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint d[201];\n\nint main() {\n    int n,k,t,u,v,l;\n    cin>>n>>k>>t>>u>>v>>l;\n    for(int i=0; i<n; ++i) cin>>d[i];\n    d[n] = l;\n\n    double rem = 0.0,ans = 0.0;\n    int now = 0,carrot = 0;\n\n    for(int i=0; i<=n; ++i) {\n        double diff = d[i] - now;\n        while(diff > 0) {\n            if(rem == 0) {\n                if(carrot > 0) {\n                    carrot--;\n                    rem += t;\n                }else {\n                    ans += (double)diff/u;\n                    diff = 0;\n                }\n            }else{\n                if(rem*v >= diff) {\n                    ans += (double)diff/v;\n                    rem -= (double)diff/v;\n                    diff = 0;\n                }else{\n                    ans += rem;\n                    diff -= rem*v;\n                    rem = 0;\n                }\n            }\n        }\n\n        if(carrot == k) {\n            rem = t;\n        }else carrot++;\n        now = d[i];\n    }\n\n    printf(\"%.12f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,c,x,a;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=true;\n  for(int i=0;i<l;i++){\n    if(s[i])\n      if(!x||k==c)x=v*t;\n      else c++;\n    else if(!x&&c)c--,x=v*t;\n    if(x)a++,x--;\n  }\n  printf(\"%.8f\\n\",a*1.0/v+(l-a)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\nusing namespace std;\ntypedef long long LL;\nconst int INF = 999999999;\n\nint main(){\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    vector<int> d(n+2);\n    rep(i, n) cin >> d[i];\n    d[n] = l;\n    d[n+1] = INF;\n\n    int now = d[0];\n    int have = 0, pass = 0;\n    int slow = d[0];\n    while(now < l){\n        now += v*t;\n        while(d[pass+1] <= now){\n            pass++;\n            have++;\n            if(have == k+1){\n                now = d[pass];\n                break;\n            }\n        }\n        if(have == 0){\n            slow += d[pass+1] - now;\n            now = d[pass+1];\n            pass++;\n        }\n        else have--;\n    }\n    int fast = l-slow;\n    double ans = 1.*fast/v + 1.*slow/u;\n    cout << fixed << setprecision(15) << ans << endl;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\n\nint main(void) {\n    int i,j;\n    int n,k,t,u,v,l;\n    cin >> n >> k >> t >> u >> v >> l;\n    vi a(l,0);\n    rep(i,n){\n        int d;\n        cin >> d;\n        a[d]++;\n    }\n    double ans = 0;\n    int cnt = 0;\n    int ne = -1;\n    rep(i,l){\n        if(a[i])cnt++;\n        if((cnt && i >= ne) || cnt > k){\n            cnt--;\n            ne = i + t * v;\n        }\n        if(i < ne){\n            ans += 1.0/v;\n        }else{\n            ans += 1.0/u;\n        }\n    }\n    cout << shosu(10) << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,c,x,a;\nbool s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=true;\n  for(int i=0;i<l;i++){\n    if(s[i])\n      if(!x||k==c)x=v*t;\n      else c++;\n    else if(!x&&c>0)c--,x=v*t;\n    if(x>0)a++,x--;\n  }\n  printf(\"%.10f\\n\",a*1.0/v+(l-a)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nint main(){\n  lli n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<lli> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<lli> course(l + 2, 0);\n  for (int i = 0; i < n; i++) {\n    course[d[i]]++;\n    course[min(d[i] + t*v, l + 1)]--;\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    course[i + 1] = min(course[i + 1] + course[i], k + 1);\n  }\n\n  for (int i = 0; i < l; i++) {\n    if(course[i] == 0 and sum > 0)sum--, course[i]++;\n    sum += max(course[i] - 1, 0LL);\n    course[i] = (course[i] > 0);\n  }\n  sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n  }\n  std::cout << setprecision(15) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10001\nusing namespace std;\nlong long n,k,t,u,v,l,d,c,x,a,s[M];\n\nint main(){\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=0;i<n;i++)cin>>d,s[d]=1;\n  for(int i=0;i<l;i++){\n    if(s[i])\n      if(!x||k==c)x=v*t;\n      else c++;\n    else if(!x&&c)c--,x=v*t;\n    if(x)a++,x--;\n  }\n  printf(\"%.8f\\n\",a*1.0/v+(l-a)*1.0/u);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n, k, t, u, v, l;\nbool pos[100100];\ndouble dv[100100];\n\nint main() {\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i, n) {\n\t\tint num;\n\t\tcin >> num;\n\t\tpos[num] = 1;\n\t}\n\tint w = 0;\n\tint cnt = 0;\n\tbool f = 0;\n\trep(i, l) {\n\t\tif (!f) {\n\t\t\tif (pos[i]) {\n\t\t\t\tf = 1;\n\t\t\t\tw = t*v - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (pos[i]) {\n\t\t\t\tif (cnt < k)cnt++;\n\t\t\t\telse w = t*v;\n\t\t\t}\n\t\t\tif (w > 0)w--;\n\t\t\telse {\n\t\t\t\tif (cnt > 0) {\n\t\t\t\t\tcnt--;\n\t\t\t\t\tw = t*v - 1;\n\t\t\t\t}\n\t\t\t\telse f = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)dv[i] = v;\n\t\telse dv[i] = u;\n\t}\n\tdouble ans = 0;\n\trep(i, l) {\n\t\t//cout << i << \" \" << dv[i] << endl;\n\t\tans += (1.0 / dv[i]);\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  long long n,k,t,u,v,l,d[210]={0};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  long long a=0,p=0;\n  for(int i=1;i<=n+1;i++){\n    if(a>d[i]-d[i-1]){\n      a-=d[i]-d[i-1];\n      if(a/(v*t)<k)a+=v*t;\n      else a=v*t*(k+1);\n    }\n    else p+=d[i]-d[i-1]-a,a=v*t;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\nusing namespace std;\nusing i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\nconstexpr bool AUTOFLUSH = false;\nconstexpr int IOS_PREC = 12;\nconstexpr int INF_I32 = 1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\nconstexpr auto INF = INF_I64;\nconstexpr double EPS = 1e-12;\nconstexpr i64 MOD = 1'000'000'007;\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nvoid SETBIT(T& x, int i) { x |= (T(1)<<i); }\ntemplate<typename T>\nvoid CLEARBIT(T& x, int i) { x &= ~(T(1)<<i); }\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\ntemplate<typename T>\nconstexpr T ABS(T x) {\n static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n return x < 0 ? -x : x;\n}\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n return x < y ? y-x : x-y;\n}\ntemplate<typename T>\nconstexpr bool is_odd(T x) { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n assert(b >= 0);\n T res(1);\n for(T i = 0; i < b; ++i)\n res *= a;\n return res;\n}\nconstexpr i64 div_ceil(i64 a, i64 b) {\n return a/b + (((a<0)^(b>0)) && (a%b));\n}\nconstexpr i64 div_floor(i64 a, i64 b) {\n return a/b - (((a>0)^(b>0)) && (a%b));\n}\nconstexpr i64 modulo(i64 a, i64 b) {\n assert(0 < b);\n i64 r = a % b;\n return r >= 0 ? r : r+b;\n}\ntemplate<typename T>\nconstexpr T CLAMP(T x, T lo, T hi) {\n assert(lo <= hi);\n if(x < lo)\n return lo;\n else if(hi < x)\n return hi;\n else\n return x;\n}\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n if(xmax < x) {\n xmax = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n if(x < xmin) {\n xmin = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n return static_cast<int>(c.size());\n}\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n return static_cast<int>(N);\n}\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n auto it = find(first, last, x);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n auto it = max_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n auto it = min_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n return all_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n return any_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n return !anytrue(first, last);\n}\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n return !alltrue(first, last);\n}\ntemplate<typename T>\nstruct myhash {\n size_t operator()(const T& x) const {\n hash<T> h;\n return h(x);\n }\n};\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n return hash<T>()(x);\n}\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n size_t operator()(const pair<T1,T2>& p) const {\n size_t seed = 0;\n myhash_combine(seed, p.first);\n myhash_combine(seed, p.second);\n return seed;\n }\n};\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n myhash_combine(seed, get<I>(t));\n TUPLEHASH<I+1, TS...>(seed, t);\n}\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n size_t operator()(const tuple<TS...>& t) const {\n size_t seed = 0;\n TUPLEHASH(seed, t);\n return seed;\n }\n};\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n for(const auto& e : v)\n myhash_combine(seed, e);\n}\ntemplate<typename T>\nstruct myhash<vector<T>> {\n size_t operator()(const vector<T>& v) const {\n size_t seed = 0;\n SEQHASH(seed, v);\n return seed;\n }\n};\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n size_t operator()(const array<T,N>& v) const {\n size_t seed = 0;\n SEQHASH(seed, v);\n return seed;\n }\n};\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n auto it = m.lower_bound(k);\n if(it != end(m) && !m.key_comp()(k,it->first)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n auto it = m.find(k);\n if(it != end(m)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n ostringstream out;\n out << x;\n return out.str();\n}\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n ostringstream out;\n while(first != last) {\n out << *first++;\n if(first != last)\n out << sep;\n }\n return out.str();\n}\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n using T = typename iterator_traits<InputIt>::value_type;\n return accumulate(first, last, T());\n}\ntemplate<typename T>\nvoid UNIQ(T& c) {\n c.erase(unique(begin(c), end(c)), end(c));\n}\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n f(e);\n}\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n for(auto& e : ary)\n ARRAY_FOREACH(e, f);\n}\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n T x = que.back(); que.pop_back();\n return x;\n}\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n T x = que.back(); que.pop_back();\n return x;\n}\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n T x = que.front(); que.pop_front();\n return x;\n}\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n T x = stk.top(); stk.pop();\n return x;\n}\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n T x = que.front(); que.pop();\n return x;\n}\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n T x = que.top(); que.pop();\n return x;\n}\ntemplate<typename T>\nvoid RD(T& x) {\n cin >> x;\n#ifdef LOCAL\n if(!cin) assert(false);\n#endif\n}\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n v.reserve(n);\n for(int i = 0; i < n; ++i) {\n T e; RD(e);\n v.emplace_back(e);\n }\n}\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n for(size_t i = 0; i < N; ++i) {\n RD(v[i]);\n }\n}\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n while(first != last) {\n out << *first++;\n if(first != last)\n out << ' ';\n }\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n FPRINTSEQ(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n FPRINTARRAY1(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n out << '\\n';\n for(const auto& e : c) {\n FPRINTARRAY1(out, e) << '\\n';\n }\n return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n FPRINTARRAY2(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n out << '\\n';\n for(const auto& e : c) {\n out << e << '\\n';\n }\n return out;\n}\nostream& operator<<(ostream& out, const vector<string>& c) {\n out << '\\n';\n for(const string& e : c) {\n out << e << '\\n';\n }\n return out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n return out << set<T>(begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n return out << multiset<T>(begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n out << \"{\\n\";\n for(auto it = first; it != last; ++it) {\n out << \"  \" << it->first << \" : \" << it->second << '\\n';\n }\n out << \"}\\n\";\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n FPRINTMAP(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n return FPRINTMAP(out, begin(c), end(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n return out << map<K,V>(begin(c), end(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n return FPRINTMAP(out, begin(c), end(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n return out << multimap<K,V>(begin(c), end(c));\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n while(!c.empty()) {\n out << c.front();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n return out << '(' << p.first << ',' << p.second << ')';\n}\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n if(sizeof...(TS) == 0)\n out << '(';\n return out << ')';\n}\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n if(I == 0)\n out << '(';\n else\n out << ',';\n out << get<I>(t);\n return FPRINTTUPLE<I+1, TS...>(out, t);\n}\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n return FPRINTTUPLE(out, t);\n}\nostream& FPRINT(ostream& out) { return out; }\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n out << x;\n if(sizeof...(args))\n out << ' ';\n return FPRINT(out, args...);\n}\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n FPRINT(out, args...);\n return out << '\\n';\n}\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n return FPRINT(cout, args...);\n}\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n return FPRINTLN(cout, args...);\n}\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n FPRINT(cerr, args...);\n#endif\n return cerr;\n}\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n FPRINTLN(cerr, args...);\n#endif\n return cerr;\n}\nvoid FLUSH() {\n cout.flush();\n}\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n cout.flush();\n cerr.flush();\n#else\n FLUSH();\n#endif\n _Exit(0);\n}\nstruct IoInit {\n IoInit() {\n#ifndef LOCAL\n cin.tie(nullptr);\n ios::sync_with_stdio(false);\n#endif\n cout << fixed << setprecision(IOS_PREC);\n if(AUTOFLUSH)\n cout << unitbuf;\n }\n} IOINIT;\n#define FOR(i,start,end) for(i64 i = (start); i < (end); ++i)\n#define REP(i,n) FOR(i, 0, n)\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n#define PAIR make_pair\n#define TUPLE make_tuple\ni64 N;\ni64 K;\ndouble T;\ndouble U;\ndouble V;\ndouble L;\nvector<double> D;\nstruct Player {\n double pos;\n double remain;\n Player() : pos(0), remain(0) {}\n double step(double dest) {\n assert(pos < dest);\n double res;\n double l = dest - pos;\n if(V*remain < l) {\n res = remain + (l-V*remain) / U;\n pos = dest;\n remain = T;\n }\n else {\n res = l / V;\n pos = dest;\n remain -= res;\n remain += T;\n remain = CLAMP(remain, 0.0, (K+1)*T);\n }\n DBG(res);\n DBG(pos);\n DBG(remain);\n return res;\n }\n};\nvoid solve() {\n RD(D, N);\n D.emplace_back(L);\n double ans = 0.0;\n Player player;\n for(auto d : D) {\n ans += player.step(d);\n }\n PRINTLN(ans);\n}\nsigned main(signed , char** ) {\n RD(N);\n RD(K);\n RD(T);\n RD(U);\n RD(V);\n RD(L);\n solve();\n EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n\nint n,k,t,u,v,l,d[210];\n\nint main(){\n\tcin >> n >> k >> t >> u >> v >> l;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> d[i];\n\t}\n\tint ifnin = 0;\n\tint ninhave = 0;\n\tdouble kigen = 0;\n\tint ninturn = 0;\n\tint normalturn = 0;\n\tint myplace = 0;\n\tdouble time = 0;\n\tint justmeet = 0;\n\tint passedi = 0;\n\twhile (myplace < l){\n\t\tif (myplace == d[passedi]){\n\t\t\tif (ninhave<k){\n\t\t\t\tninhave += 1;\n\t\t\t\tjustmeet = 0;\n\t\t\t}\n\t\t\telse if (kigen == time && ninhave == k) justmeet = 1;\n\t\t\telse justmeet = 0;\n\t\t\tpassedi += 1;\n\t\t}\n\t\telse{\n\t\t\tjustmeet = 0;\n\t\t}\n\n\t\tif (ifnin == 0){\n\t\t\tif (justmeet == 1){\n\t\t\t\tifnin = 1;\n\t\t\t\tkigen = t + time;\n\t\t\t}\n\t\t\telse if (ninhave != 0){\n\t\t\t\tifnin = 1;\n\t\t\t\tninhave += -1;\n\t\t\t\tkigen = t + time;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (kigen <= time){\n\t\t\t\tif (ninhave != 0){\n\t\t\t\t\tifnin = 1;\n\t\t\t\t\tninhave += -1;\n\t\t\t\t\tkigen = t + time;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (justmeet == 1){\n\t\t\t\t\t\tifnin = 1;\n\t\t\t\t\t\tkigen = t + time;\n\t\t\t\t\t}\n\t\t\t\t\telse ifnin = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmyplace += 1;\n\t\tif (ifnin == 0){\n\t\t\tnormalturn += 1;\n\t\t}\n\t\telse{\n\t\t\tninturn += 1;\n\t\t}\n\t\ttime = ninturn*1.0 / v + normalturn*1.0 / u;\n\t}\n\tcout << time << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\tint N, K, T, U, V, L; cin >> N >> K >> T >> U >> V >> L;\n\tvector<ld>ds;\n\tint pre = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint d; cin >> d;\n\t\tds.push_back(d-pre);\n\t\tpre = d;\n\t}\n\tds.push_back(L - pre);\n\tld max_dash = (K + 1)*T;\n\n\tld now_dash = 0;\n\tld ans = 0;\n\tfor (int i = 0; i < ds.size(); ++i) {\n\t\tif (now_dash*V > ds[i]) {\n\t\t\tnow_dash -= ds[i] / V;\n\t\t\tans += ds[i] / V;\n\t\t}\n\t\telse {\n\t\t\tans += now_dash + (ds[i] - now_dash*V) / U;\n\t\t\tnow_dash = 0;\n\t\t}\n\t\tnow_dash = min(now_dash + T, max_dash);\n\t}\n\tcout << setprecision(22)<<fixed<<ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nint main(){\n  lli n, k, t, u, v, l;\n  std::cin >> n >> k >> t >> u >> v >> l;\n  vector<lli> d(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> d[i];\n  }\n  double ans = 0;\n  vector<lli> course(l + 2, 0);\n  for (int i = 0; i < n; i++) {\n    course[d[i]]++;\n    course[min(d[i] + t*v, l + 1)]--;\n  }\n  double sum = 0;\n  for (int i = 0; i < l; i++) {\n    course[i + 1] += course[i];\n  }\n  for (int i = 0; i < l; i++) {\n    course[i] = min(course[i], k + 1);\n  }\n  for (int i = 0; i < l; i++) {\n    if(course[i] == 0 and sum > 0)sum--, course[i]++;\n    sum += max(course[i] - 1, 0LL);\n    course[i] = (course[i] > 0);\n  }\n  sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += course[i];\n  }\n  std::cout << setprecision(15) << sum/v + (l - sum)/u << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  long long n,k,t,u,v,l,d[210]={};\n  cin>>n>>k>>t>>u>>v>>l;\n  for(int i=1;i<=n;i++)cin>>d[i];\n  d[n+1]=l;\n  long long a=0,p=0;\n  for(int i=1;i<=n+1;i++){\n    if(a>d[i]-d[i-1]){\n      a-=d[i]-d[i-1];\n      a=min(a+v*t,v*t*(k+1));\n    }\n    else p+=d[i]-d[i-1]-a,a=v*t;\n  }\n  printf(\"%.10f\\n\",1.0*p/u+1.0*(l-p)/v);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[210];\nint h[11000];\nint main(){\n\tint a,b,c,d,e,f;\n\tscanf(\"%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",g+i);\n\tfor(int i=0;i<a;i++)h[g[i]]=1;\n\tint last=0;\n\tdouble ret=0;\n\tint now=0;\n\tfor(int i=1;i<=f;i++){\n\t\tif(now)ret+=1.0/e;\n\t\telse ret+=1.0/d;\n\t\tif(now&&last+c*e==i){\n\t\t\tnow--;\n\t\t\tlast=i;\n\t\t}\n\t\tif(h[i]){\n\t\t\tnow++;\n\t\t\tif(now==1)last=i;\n\t\t\tif(now>b+1){\n\t\t\t\tnow--;\n\t\t\t\tlast=i;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N,K,T,U,V,L;\n\nvoid solve(int D, double &nd, double &nt, double &restt, int &have){\n  double ddis = (restt+have*T)*V;\n  if(D-nd < ddis){\n    if(D-nd < restt*V){\n      restt = (restt*V-(D-nd))/V;\n    }else{\n      double diff = D-nd; diff -= restt*V;\n      double overdis = (have*T*V-diff)/V;\n      have = overdis/T;\n      restt = overdis-have*T;\n    }\n    nt += (double)(D-nd)/V;\n  }else{\n    double uset = restt+have*T;\n    double diff = (D-nd)-ddis;\n    nt += uset + diff/U;\n    restt = 0;\n    have = 0;\n  }\n  nd = D;\n  have++;\n  if(have > K){\n    restt = T;\n    have--;\n  }\n}\n\nint main(){\n  scanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\n  double nd = 0, nt = 0, restt = 0;int  have = 0;\n  rep(i,N){\n    int D;\n    scanf(\"%d\",&D);\n    solve(D, nd, nt, restt, have);\n    //    printf(\"%.12lf\\n\", nt);\n  }\n  solve(L, nd, nt, restt, have);\n  printf(\"%.12lf\\n\", nt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define INF 999999999\n\nint main(){\n\tint n, k, t, u, v, l, d[200], cal[10000], have=0, run=0;\n\tdouble ans = 0;\n\tcin >> n >> k >> t >> u >> v >> l;\n\tfor(int i=0; i<l; i++){\n\t\tcal[i] = 0;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tcin >> d[i];\n\t\tcal[ d[i] ] = 1;\n\t}\n\t\n\tint running = 0, walking =0;\n\t\n\tfor(int i=0; i<l; i++){\n\t\tif(have > 0 && run == 0){\n\t\t\trunning++;\n\t\t\thave--;\n\t\t\trun = v * t - 1;\n\t\t}\n\t\telse if(run > 0){\n\t\t\trunning++;\n\t\t\trun--;\n\t\t}\n\t\telse{\n\t\t\twalking++;\n\t\t}\n\t\t\n\t\tif(cal[i] == 1 && have < k){\n\t\t\thave++;\n\t\t}\n\t\telse if(cal[i] == 1 && have == k){\n\t\t\trun = v * t;\n\t\t}\n\t}\n\t\n\tans = (double)running / (double)v + (double)walking / (double)u;\n\t\n\tprintf(\"%.7f\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, K, T, U, V, L;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N >> K >> T >> U >> V >> L;\n  VI D(N); REP(i,N) cin >> D[i];\n  \n  int prv = 0, num = 0;\n  double ans = 0;\n  for(int i=0;i<N;++i){\n\tif(num > 0){\n\t  if(prv + T * V < D[i]){\n\t\tans += T;\n\t\tprv += T*V;\n\t\t--num, --i;\n\t  }\n\t  else{\n\t\t--num;\n\t\tint to = prv + T * V;\n\t\tfor(;i<N;++i){\n\t\t  if(to < D[i]){\n\t\t\t--i;\n\t\t\tans += T;\n\t\t\tprv = to;\n\t\t\tbreak;\n\t\t  }\n\t\t  if(++num > K){\n\t\t\tans += (D[i] - prv)*1. / V;\n\t\t\tprv = D[i];\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t\tif(i == N){\n\t\t  if(prv + T*V < L){\n\t\t\tans += T;\n\t\t\tprv = to;\n\t\t  }\n\t\t  else{\n\t\t\tans += (L - prv)*1. / V;\n\t\t\tprv = L;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\telse{\n\t  ans += (D[i] - prv)*1. / U;\n\t  prv = D[i];\n\t  ++num;\n\t}\n  }\n  if(prv != L){\n\twhile(num > 0){\n\t  if(prv + T*V < L){\n\t\tans += T;\n\t\tprv += T*V;\n\t  }\n\t  else{\n\t\tans += (L - prv)*1. / V;\n\t\tprv = L;\n\t\tnum = 0;\n\t  }\n\t  --num;\n\t}\n\tans += (L - prv)*1. / U;\n  }\n\n  cout << fixed << setprecision(9) << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, K;\n    double T, U, V, L;\n    cin >> N >> K >> T >> U >> V >> L;\n    vector<double> D(N);\n    for (int i=0; i<N; ++i) cin >> D[i];\n    \n    double tm = 0;\n    double r = L;\n    for (int i=N-1; i>=0; --i) {\n        if (i+K < N && D[i+K] < r-V*T) {\n            // D[i+K]の位置から加速\n            tm += T + (r-D[i+K]-V*T) / U;\n            r = D[i+K];\n        } else {\n            // rの位置まで加速\n            tm += min(V*T, r-D[i]) / V;\n            r -= min(V*T, r-D[i]);\n        }\n    }\n    tm += r / U;\n\n    printf(\"%.9f\\n\", tm);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, k, t, u, v, l;\n  cin >> n >> k >> t >> u >> v >> l;\n  VI d(n);\n  VI car(l+5, 0);\n  REP(i, n) cin >> d[i], car[d[i]] = 1;\n\n  int pos = -1, c = 0;\n  double res = 0;\n  REP(i, l) {\n    // cout << i << \" \" << res << \" \" << pos << \" \" << c << endl;\n    // にんじんがある場所なら\n    if(car[i]) {\n      // 使ってる\n      if(i <= pos) {\n        // 使う\n        if(c == k) {\n          pos = i + v*t - 1;\n        }\n        // 使わない\n        else {\n          c++;\n        }\n      }\n      // 使ってない\n      else {\n        // 使う\n        pos = i + v*t - 1;\n      }\n    }\n\n    if(i > pos && c > 0) {\n      pos = i + v*t - 1;\n      c--;\n    }\n\n    // 使ってるなら\n    if(i <= pos) {\n      // cout << \"used\" << endl;\n      res += 1.0/v;\n    }\n    // 使ってないなら\n    else {\n      res += 1.0/u;\n    }\n  }\n\n  cout << fixed << setprecision(9) << res << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint a, b, c, d, e, f, g;\nint remain;\nint speed;\nint x[10000000];\ndouble res;\nint main() {\n\tcin >> a >> b >> c >> d >> e >> f;\n\tfor (int i = 0; i < a; i++) {\n\t\tcin >> g;\n\t\tx[g] = 1;\n\t}\n\tfor (int i = 0; i < f; i++) {\n\t\tif (x[i] == 1) {\n\t\t\tif ((remain + c - 1) / c < b) {\n\t\t\t\tremain += c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg = (c - (remain%c));\n\t\t\t\tif (g == c) { g = 0; }\n\t\t\t\tremain += g;\n\t\t\t}\n\t\t}\n\t\tif (remain > 0) {\n\t\t\tspeed++;\n\t\t\tremain--;\n\t\t}\n\t}\n\tres = (1.0*(f - speed * e) / d) + (1.0*(speed * e) / e);\n\tcout << setprecision(15) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nint main() {\n    Int n, k, t, u, v, l;\n    std::cin >> n >> k >> t >> u >> v >> l;\n\n    Vector<Int> d(n);\n    for (auto& x : d) std::cin >> x;\n    d.push_back(l);\n\n    Int stock = 0, to = 0, cur = 0;\n    Real time = 0;\n    for (auto x : d) {\n        while (to < x && stock > 0) {\n            --stock;\n            to += v * t;\n        }\n\n        if (to < x) {\n            time += Real(to - cur) / v + Real(x - to) / u;\n        } else {\n            time += Real(x - cur) / v;\n        }\n        cur = x;\n        to = std::max(to, cur);\n\n        if (++stock > k) {\n            --stock;\n            to = cur + v * t;\n        }\n    }\n\n    std::cout << Fout(9) << time << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint N,K,T,U,V,L,D[10010];\n\nint main() {\n  cin>>N>>K>>T>>U>>V>>L;\n  REP(i,0,N) cin>>D[i];\n\n  int pos=D[0], vdist=0, di=1, keep=0;\n  int diEnd = D[0]+V*T;\n  queue<int> dq;\n\n  while(1){\n    REP(nowPos,pos,diEnd+1){\n      if(nowPos!=pos)vdist++;\n      if(nowPos == L)break;\n      if(di < N && nowPos == D[di]){\n        if(keep < K) keep++, dq.push(di);\n        else{\n          diEnd = max(nowPos,D[dq.front()]) + V*T;\n          dq.pop();\n          dq.push(di);\n        }\n        di++; //uodate next_Di_candidate\n      }\n      if(nowPos==diEnd && keep>0){\n        diEnd = max(nowPos,D[dq.front()]) + V*T;\n        dq.pop();\n        keep--;\n      }\n    }\n    pos = diEnd+1;\n    if(pos >= L) break;\n\n    bool flag = true;\n    /*always leep is 0 here*/\n    REP(nowPos,pos,L+1){\n      if(di < N && D[di] == nowPos){\n        pos = D[di];\n        diEnd = D[di] + V*T;\n        di++;\n        //use immediately\n        flag = false;\n        break;\n      }\n    }\n    if(flag) break;\n  }\n\n  double ans = (double)(L-vdist)/(double)U + (double)vdist/(double)V;\n  printf(\"%.8lf\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main(void) {\n    int n,k,t,u,v,l;\n    char d[1000]={};\n    scanf(\"%d%d%d%d%d%d\",&n,&k,&t,&u,&v,&l);\n    for(int i=0; i<n; i++) {\n        int t;\n        scanf(\"%d\",&t);\n        d[t]=1;\n    }\n\n    double res=0.0,rem=0.0;\n    int carrot=0;\n    for(int i=0; i<l; i++) {\n        if(d[i]) carrot++;\n        if(carrot>k) carrot=k, rem = 1.0*t;\n\n        double now=0.0;\n        while(now<1.0) {\n            if(rem==0.0) {\n                if(carrot) {\n                    carrot--;\n                    rem = 1.0*t;\n                } else {\n                    res+= (1.0-now)/u;\n                    now = 1.0;\n                }\n            }\n\n            if(rem > (1.0-now)/v) {\n                res+= (1.0-now)/v;\n                rem-= (1.0-now)/v;\n                now = 1.0;\n            } else {\n                res+= rem;\n                now+= rem*v;\n                rem = 0.0;\n            }\n        }\n    }\n    printf(\"%f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\nusing namespace std;\nusing i8 = int8_t;\nusing u8 = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\nconstexpr bool AUTOFLUSH = false;\nconstexpr int IOS_PREC = 12;\nconstexpr int INF_I32 = 1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\nconstexpr auto INF = INF_I64;\nconstexpr double EPS = 1e-12;\nconstexpr i64 MOD = 1'000'000'007;\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nvoid SETBIT(T& x, int i) { x |= (T(1)<<i); }\ntemplate<typename T>\nvoid CLEARBIT(T& x, int i) { x &= ~(T(1)<<i); }\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\ntemplate<typename T>\nconstexpr T ABS(T x) {\n static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n return x < 0 ? -x : x;\n}\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n return x < y ? y-x : x-y;\n}\ntemplate<typename T>\nconstexpr bool is_odd(T x) { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\ntemplate<typename T>\nconstexpr T ipow(T a, T b) {\n assert(b >= 0);\n T res(1);\n for(T i = 0; i < b; ++i)\n res *= a;\n return res;\n}\nconstexpr i64 div_ceil(i64 a, i64 b) {\n return a/b + (((a<0)^(b>0)) && (a%b));\n}\nconstexpr i64 div_floor(i64 a, i64 b) {\n return a/b - (((a>0)^(b>0)) && (a%b));\n}\nconstexpr i64 modulo(i64 a, i64 b) {\n assert(0 < b);\n i64 r = a % b;\n return r >= 0 ? r : r+b;\n}\ntemplate<typename T>\n[[nodiscard]] constexpr T CLAMP(T x, T lo, T hi) {\n assert(lo <= hi);\n if(x < lo)\n return lo;\n else if(hi < x)\n return hi;\n else\n return x;\n}\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n if(xmax < x) {\n xmax = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n if(x < xmin) {\n xmin = x;\n return true;\n }\n else {\n return false;\n }\n}\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n return static_cast<int>(c.size());\n}\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n return static_cast<int>(N);\n}\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n auto it = find(first, last, x);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n auto it = max_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n auto it = min_element(first, last);\n return distance(first, it);\n}\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n return all_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n return any_of(first, last, [](bool b) { return b; });\n}\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n return !anytrue(first, last);\n}\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n return !alltrue(first, last);\n}\ntemplate<typename T>\nstruct myhash {\n size_t operator()(const T& x) const {\n hash<T> h;\n return h(x);\n }\n};\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n return hash<T>()(x);\n}\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n size_t operator()(const pair<T1,T2>& p) const {\n size_t seed = 0;\n myhash_combine(seed, p.first);\n myhash_combine(seed, p.second);\n return seed;\n }\n};\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n myhash_combine(seed, get<I>(t));\n TUPLEHASH<I+1, TS...>(seed, t);\n}\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n size_t operator()(const tuple<TS...>& t) const {\n size_t seed = 0;\n TUPLEHASH(seed, t);\n return seed;\n }\n};\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n for(const auto& e : v)\n myhash_combine(seed, e);\n}\ntemplate<typename T>\nstruct myhash<vector<T>> {\n size_t operator()(const vector<T>& v) const {\n size_t seed = 0;\n SEQHASH(seed, v);\n return seed;\n }\n};\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n size_t operator()(const array<T,N>& v) const {\n size_t seed = 0;\n SEQHASH(seed, v);\n return seed;\n }\n};\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n auto it = m.lower_bound(k);\n if(it != end(m) && !m.key_comp()(k,it->first)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n auto it = m.find(k);\n if(it != end(m)) {\n it->second = v;\n return make_pair(it, false);\n }\n else {\n auto it_ins = m.insert(it, make_pair(k,v));\n return make_pair(it_ins, true);\n }\n}\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n ostringstream out;\n out << x;\n return out.str();\n}\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n ostringstream out;\n while(first != last) {\n out << *first++;\n if(first != last)\n out << sep;\n }\n return out.str();\n}\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n using T = typename iterator_traits<InputIt>::value_type;\n return accumulate(first, last, T());\n}\ntemplate<typename T>\nvoid UNIQ(T& c) {\n c.erase(unique(begin(c), end(c)), end(c));\n}\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n f(e);\n}\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n for(auto& e : ary)\n ARRAY_FOREACH(e, f);\n}\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n T x = que.back(); que.pop_back();\n return x;\n}\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n T x = que.back(); que.pop_back();\n return x;\n}\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n T x = que.front(); que.pop_front();\n return x;\n}\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n T x = stk.top(); stk.pop();\n return x;\n}\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n T x = que.front(); que.pop();\n return x;\n}\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n T x = que.top(); que.pop();\n return x;\n}\ntemplate<typename T>\nvoid RD(T& x) {\n cin >> x;\n#ifdef LOCAL\n if(!cin) assert(false);\n#endif\n}\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n v.reserve(n);\n for(int i = 0; i < n; ++i) {\n T e; RD(e);\n v.emplace_back(e);\n }\n}\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n for(size_t i = 0; i < N; ++i) {\n RD(v[i]);\n }\n}\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n while(first != last) {\n out << *first++;\n if(first != last)\n out << ' ';\n }\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n FPRINTSEQ(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n FPRINTARRAY1(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n out << '\\n';\n for(const auto& e : c) {\n FPRINTARRAY1(out, e) << '\\n';\n }\n return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n FPRINTARRAY2(cerr, c);\n#endif\n return cerr;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n out << '\\n';\n for(const auto& e : c) {\n out << e << '\\n';\n }\n return out;\n}\nostream& operator<<(ostream& out, const vector<string>& c) {\n out << '\\n';\n for(const string& e : c) {\n out << e << '\\n';\n }\n return out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n return out << set<T>(begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n return out << multiset<T>(begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n out << \"{\\n\";\n for(auto it = first; it != last; ++it) {\n out << \"  \" << it->first << \" : \" << it->second << '\\n';\n }\n out << \"}\\n\";\n return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n FPRINTMAP(cerr, first, last);\n#endif\n return cerr;\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n return FPRINTMAP(out, begin(c), end(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n return out << map<K,V>(begin(c), end(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n return FPRINTMAP(out, begin(c), end(c));\n}\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n return out << multimap<K,V>(begin(c), end(c));\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n while(!c.empty()) {\n out << c.front();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n while(!c.empty()) {\n out << c.top();\n c.pop();\n if(!c.empty()) out << ' ';\n }\n return out;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n return out << '(' << p.first << ',' << p.second << ')';\n}\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n if(sizeof...(TS) == 0)\n out << '(';\n return out << ')';\n}\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n if(I == 0)\n out << '(';\n else\n out << ',';\n out << get<I>(t);\n return FPRINTTUPLE<I+1, TS...>(out, t);\n}\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n return FPRINTTUPLE(out, t);\n}\nostream& FPRINT(ostream& out) { return out; }\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n out << x;\n if(sizeof...(args))\n out << ' ';\n return FPRINT(out, args...);\n}\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n FPRINT(out, args...);\n return out << '\\n';\n}\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n return FPRINT(cout, args...);\n}\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n return FPRINTLN(cout, args...);\n}\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n FPRINT(cerr, args...);\n#endif\n return cerr;\n}\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n FPRINTLN(cerr, args...);\n#endif\n return cerr;\n}\nvoid FLUSH() {\n cout.flush();\n}\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n cout.flush();\n cerr.flush();\n#else\n FLUSH();\n#endif\n _Exit(0);\n}\nstruct IoInit {\n IoInit() {\n#ifndef LOCAL\n cin.tie(nullptr);\n ios::sync_with_stdio(false);\n#endif\n cout << fixed << setprecision(IOS_PREC);\n if(AUTOFLUSH)\n cout << unitbuf;\n }\n} IOINIT;\n#define FOR(i,start,end) for(i64 i = (start); i < (end); ++i)\n#define REP(i,n) FOR(i, 0, n)\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n#define PAIR make_pair\n#define TUPLE make_tuple\ni64 N;\ni64 K;\ndouble T;\ndouble U;\ndouble V;\ndouble L;\nvector<double> D;\nstruct Player {\n double pos;\n double remain;\n Player() : pos(0), remain(0) {}\n double step(double dest) {\n assert(pos < dest);\n double res;\n double l = dest - pos;\n if(V*remain < l) {\n res = remain + (l-V*remain) / U;\n pos = dest;\n remain = T;\n }\n else {\n res = l / V;\n pos = dest;\n remain -= res;\n remain += T;\n remain = CLAMP(remain, 0.0, (K+1)*T);\n }\n DBG(res);\n DBG(pos);\n DBG(remain);\n return res;\n }\n};\nvoid solve() {\n RD(D, N);\n D.emplace_back(L);\n double ans = 0.0;\n Player player;\n for(auto d : D) {\n ans += player.step(d);\n }\n PRINTLN(ans);\n}\nsigned main(signed , char** ) {\n RD(N);\n RD(K);\n RD(T);\n RD(U);\n RD(V);\n RD(L);\n solve();\n EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint N,K,U,L;\ndouble cnt,V,T;\nbool mp[10010];\n\nint main(){\n  cin>>N>>K>>T>>U>>V>>L;\n  for(int i=0,a,A;i<N;i++){\n    cin>>a;\n    A=a;\n    while(mp[a]&&(a-A)/V/T<K)a++;\n    for(int j=a;j<L&&j<a+T*V;j++)cnt+=!mp[j],mp[j]=1;\n  }\n\n  printf(\"%.8f\\n\",cnt/V+(L-cnt)/U);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> D[i];\n\t}\n\tdouble res = 0;\n\tbool boost = false;\n\tint ind,rem,car;\n\tind = rem = car = 0;\n\tfor (int l = 1; l < L+1; ++l) {\n\t\tif (boost) {\n\t\t\tres += (double)1/V;\n\t\t}\n\t\telse {\n\t\t\tres += (double)1/U;\n\t\t}\n\n\t\tif (l == D[ind]) {\n\t\t\tif (car == K || (!boost)) {\n\t\t\t\trem = (V * T) + 1;\n\t\t\t\tboost = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++car;\n\t\t\t}\n\t\t\t++ind;\n\t\t}\n\n\t\tif (rem > 0) {\n\t\t\t--rem;\n\t\t\tif (rem == 0) {\n\t\t\t\tif (car > 0) {\n\t\t\t\t\trem = V * T;\n\t\t\t\t\t--car;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tboost = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(30) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#define F(n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(void){\nint n,k,t,u,v,l;\ncin>>n>>k>>t>>u>>v>>l;\nint ma=t*v*(k+1);\nint a=t*v;\nint rest=0;\nint temp,acc=0;\nvector<bool> d(l,false);\nF(n){\n\tcin>>temp;\n\td[temp]=true;\n}\nF(l){\n\tif(d[i]){\n\t\trest+=a;\n\t}\n\tif(rest>ma){\n\t\trest=ma;\n\t}\n\tif(rest!=0){\nacc++;\nrest--;\n\t}\n\t\n}\ndouble time=(double)acc/v+(double)(l-acc)/u;\nprintf(\"%0.7f\\n\",time);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N);\n  REP(i, N) cin >> D[i];\n\n\n  double res = 0;\n  double pos = 0;\n  int carrot = 0;\n  int i = 0;\n  while(i < N){\n    // move to a next carrot\n    res += (D[i] - pos) / U;\n    pos = D[i++];\n    carrot++;\n\n    while(carrot > 0 && pos < L - EPS){\n      // eat carrot\n      // cout << pos << \" \" << res << endl;      \n      carrot--;\n      double next = min(pos + T * V, (double)L);;\n\n      while(i < N && D[i] < next){\n        carrot++;\n        i++;\n      }\n\n      if(carrot > K){\n        carrot = K + 1;\n        res += (D[i-1] - pos) / V;\n        pos =  D[i-1];\n      }else{\n        res += (next - pos) / V;\n        pos = next;\n      }\n    }\n    assert(carrot == 0);\n  }\n  cout << fixed << setprecision(20) << res + (L - pos) / U << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  double lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  double ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=0;i<L;i++){\n    ans+=1.00/lv[i];\n  }\n  printf(\"%.10lf\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst double inf = 1e9;\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N, K, T, U, V, L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tvector<int> D(L+1, 0);\n\tfor (int i = 0;i < N;i++) {\n\t\tint d; cin >> d;\n\t\tD[d] = 1;\n\t}\n\tlong double ans = 0;\n\n\tint have_carrot = 0;\n\tint limit_l = -1;\n\tbool boost = false;\n\tfor (int l = 0; l < L;l++) {\n\t\t//cout << l << \" \" << \" \" << boost <<\" \" << limit_l << \" \"<< ans << endl;\n\t\t// no boost\n\t\tif (!boost) {\n\t\t\tif (D[l] == 1) {\n\t\t\t\tans += 1 / (double)V;\n\t\t\t\tboost = true;\n\t\t\t\tlimit_l = l + T*V;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += 1 / (double)U;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (l == limit_l) {\n\t\t\tif (have_carrot > 0) {\n\t\t\t\thave_carrot--;\n\t\t\t\tlimit_l = l + T*V;\n\t\t\t\tans += 1 / (double)V;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboost = false;\n\t\t\t\tans += 1 / (double)U;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tans += 1 / (double)V;\n\t\tif (D[l] == 1) {\n\t\t\thave_carrot++;\n\t\t\tif (have_carrot <= K) continue;\n\t\t\tlimit_l = l + T*V;\n\t\t\thave_carrot--;\n\t\t}\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n\tint ncarrot, max_have_carrot, accel_time, standard_speed, accel_speed, length;\n\tint carrot[201], suffix = 0;\n\n\tcin >> ncarrot >> max_have_carrot >> accel_time >> standard_speed >> accel_speed >> length;\n\n\tfor (int i = 0; i < ncarrot; i++) {\n\t\tcin >> carrot[i];\n\t}\n\n\tint have = 0;\n\tdouble time = 0.0, after_time = 0.0;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (carrot[suffix] == i) {\n\t\t\tif (have == 0 && after_time == 0) { //何も持っていない&加速していない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\telse if (have < max_have_carrot) { //まだ持てる\n\t\t\t\thave++;\n\t\t\t}\n\t\t\telse { //もう持てない\n\t\t\t\tafter_time = (double)accel_time;\n\t\t\t}\n\t\t\tsuffix++;\n\t\t}\n\n\t\tif (after_time > 0.0) {\n\t\t\tif (after_time - (double)(1.0 / accel_speed) < 0.00000001) { //近似\n\t\t\t\tafter_time = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tafter_time -= (double)(1.0 / accel_speed);\n\t\t\t}\n\t\t\ttime += (double)(1.0 / accel_speed);\n\n\t\t\tif (after_time <= 0.0) {\n\t\t\t\tif (have > 0) {\n\t\t\t\t\thave--;\n\t\t\t\t\tafter_time = (double)accel_time;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thave = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttime += (double)(1.0 / standard_speed);\n\t\t}\n\t}\n\n\tprintf(\"%.10f\", time);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int N,K,T,U,V,L;\n  while(cin>>N>>K>>T>>U>>V>>L){\n    bool d[10001] = {};\n    REP(i,N){\n      int t; cin>>t;\n      d[t] = true;\n    }\n    double ans = 0;\n    int k = 0;\n    double boost = 0;\n    for(int l = 0; l < L; l++){\n      if(d[l]){\n        if(boost == 0 || k == K){\n          boost = T;\n        }else{\n          k += K;\n        }\n      }else{\n        if(boost == 0 && k > 0){\n          boost = T;\n          k -= 1;\n        }\n      }\n      if(boost > 0){\n        ans += 1.0/V;\n        boost -= 1.0/V;\n        if(boost < 1e-7) boost = 0;\n      }else{\n        ans += 1.0/U;\n      }\n    }\n    printf(\"%.9lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint main(void){\n    for(int n, k, t, u, v, l; cin >> n >> k >> t >> u >> v >> l;){\n        vi d(n);\n        rep(i, n) cin >> d[i];\n\n        double res = 0.;\n        double default_tpm = 1. / u, speedup_tpm = 1. / v;\n        int numD = 0;\n        bool isSpeedup = false;\n        int speedup_m = t * v, spend_m = 0;\n        int ind = 0;\n\n        range(i, 1, l + 1){\n            res += (isSpeedup ? speedup_tpm:default_tpm);\n            if(isSpeedup) spend_m++;\n\n            if(ind < d.size() && i == d[ind]){\n                if(isSpeedup){\n                    if(numD == k){\n                        spend_m = 0;\n                    }\n                    else{\n                        numD++;\n                    }\n                }\n                else{\n                    isSpeedup = true;\n                    spend_m = 0;\n                }\n                ind++;\n            }\n\n            if(!isSpeedup) continue;\n\n            if(spend_m == speedup_m){\n                if(numD > 0){\n                    numD--;\n                    spend_m = 0;\n                }\n                else{\n                    isSpeedup = false;\n                }\n            }\n        }\n        \n        printf(\"%.9f\\n\", res);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_carrots;\n  int carrot_store_ability;\n  int power_up_duration;\n  int normal_speed;\n  int power_up_speed;\n  int goal_distance;\n  while(~scanf(\"%d %d %d %d %d %d\",\n\t       &total_carrots,\n\t       &carrot_store_ability,\n\t       &power_up_duration,\n\t       &normal_speed,\n\t       &power_up_speed,\n\t       &goal_distance)){\n\n    bool carrots[10001];\n    memset(carrots,false,sizeof(carrots));\n\n    for(int carrot_idx=0;carrot_idx< total_carrots; carrot_idx++){\n      int distance;\n      scanf(\"%d\",&distance);\n      carrots[distance] = true;\n    }\n\n    int current_pos = 0;\n\n    int current_carrots = 0;\n    int life = 0;\n\n    int high_speed_interval =0;\n    for(int pos=0;pos< goal_distance; pos++,life--){\n      if(carrots[pos]){\n\tcurrent_carrots++;\n      }\n\n      if((life <= 0 && current_carrots > 0)\n\t || (current_carrots > carrot_store_ability)){\n\tcurrent_carrots--;\n\tlife = power_up_duration * power_up_speed;\n      }\n\n      if(life > 0){\n\thigh_speed_interval++;\n      }\n    }\n\n    printf(\"%.9lf\\n\",(double)high_speed_interval/(double)power_up_speed\n\t   + (double)(goal_distance - high_speed_interval)/(double)normal_speed);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int N, K, T, U, V, L;\n  cin >> N >> K >> T >> U >> V >> L;\n  vector<int> D(N);\n  REP(i, N) cin >> D[i];\n\n\n  double res = 0;\n  double pos = 0;\n  int carrot = 0;\n  int i = 0;\n  while(i < N){\n    // move to a next carrot\n    res += (D[i] - pos) / U;\n    pos = D[i++];\n    carrot++;\n\n    while(carrot > 0){\n      // eat carrot\n      // cout << pos << \" \" << res << endl;      \n      carrot--;\n      double next = min(pos + T * V, (double)L);;\n\n      while(i < N && D[i] < next){\n        carrot++;\n        i++;\n      }\n\n      if(carrot > K){\n        carrot = K + 1;\n        res += (D[i-1] - pos) / V;\n        pos =  D[i-1];\n      }else{\n        res += (next - pos) / V;\n        pos = next;\n      }\n    }\n    assert(carrot == 0);\n  }\n  cout << fixed << setprecision(20) << res + (L - pos) / U << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_carrots;\n  int carrot_store_ability;\n  int power_up_duration;\n  int normal_speed;\n  int power_up_speed;\n  int goal_distance;\n  while(~scanf(\"%d %d %d %d %d %d\",\n\t       &total_carrots,\n\t       &carrot_store_ability,\n\t       &power_up_duration,\n\t       &normal_speed,\n\t       &power_up_speed,\n\t       &goal_distance)){\n\n    bool carrots[201];\n    memset(carrots,false,sizeof(carrots));\n\n    for(int carrot_idx=0;carrot_idx< total_carrots; carrot_idx++){\n      int distance;\n      scanf(\"%d\",&distance);\n      carrots[distance] = true;\n    }\n\n    int current_pos = 0;\n\n    int current_carrots = 0;\n    int life = 0;\n\n    int high_speed_interval =0;\n    for(int pos=0;pos< goal_distance; pos++,life--){\n      if(carrots[pos]){\n\tcurrent_carrots++;\n      }\n\n      if((life <= 0 && current_carrots > 0)\n\t || (current_carrots > carrot_store_ability)){\n\tcurrent_carrots--;\n\tlife = power_up_duration * power_up_speed;\n      }\n\n      if(life > 0){\n\thigh_speed_interval++;\n      }\n    }\n\n    printf(\"%.9lf\\n\",(double)high_speed_interval/(double)power_up_speed\n\t   + (double)(goal_distance - high_speed_interval)/(double)normal_speed);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define var auto\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n, k, t, u, v, l;\n    cin >> n >> k >> t >> u >> v >> l;\n    double remainDash = 0;\n    double place = 0;\n    double time = 0;\n    int count = 0;\n    vector<int> ds(n);\n    for (int i = 0; i < n; i++)\n        cin >> ds[i];\n    ds.push_back(l);\n    for (auto&& d : ds){\n        while (true){\n            if (place + remainDash * v >= d){\n                var takeTime = (d - place) / v;\n                time += takeTime;\n                remainDash -= takeTime;\n                place = d;\n                break;\n            }\n            place += remainDash * v;\n            time += remainDash;\n            remainDash = 0;\n            if (count != 0){\n                remainDash = t;\n                count--;\n                continue;\n            }\n            break;\n        }\n        var takeTime = (d - place) / u;\n        time += takeTime;\n        place = d;\n        count++;\n        if (count > k){\n            count = k;\n            remainDash = t;\n        }\n    }\n\n    cout << fixed << setprecision(15);\n    cout << time << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint main()\n{\n    int n,k,t,u,v,L;\n    scanf(\" %d %d %d %d %d %d\", &n, &k, &t, &u, &v, &L);\n    vector<int> d(n);\n    rep(i,n) scanf(\" %d\", &d[i]);\n\n    int idx=0;\n    int st=-1;\n    int stock=0;\n    double ans=0;\n\n    bool boost=false;\n\n    rep(i,L)\n    {\n        if(idx<n && d[idx]==i)\n        {\n            if(stock<k) ++stock;\n            else st=i;\n\n            ++idx;\n        }\n\n        if(st+t*v==i)\n        {\n            st=false;\n            boost=false;\n        }\n\n        if(!boost && stock>0)\n        {\n            boost=true;\n            --stock;\n            st=i;\n        }\n\n        if(boost) ans+=1.0/v;\n        else ans+=1.0/u;\n    }\n\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <vector> \n\nusing namespace std;\ntypedef vector<int> VI;\n\nint main(void) {\n    int n;\n    int k;\n    int t;\n    int u;\n    int v;\n    int l;\n    cin >> n >> k >> t >> u >> v >> l;\n    VI d(n);\n    vector<bool> x(l, false);\n    for (int i = 0; i < n; i++) {\n        cin >> d[i];\n    }\n    int number_carot = 0;\n    bool boost = false;\n    int dist = v * t;\n\n    for (int i = 0; i < n; i++) {\n        int carot = d[i];\n        if (x[carot] == false && boost == false) {\n            for (int j = 0; j < dist; j++) {\n                x[carot + j] = true;\n            }\n            boost = true;\n        } else if (x[carot] == true && boost == true && number_carot < k) {\n            number_carot++; \n        } else if (x[carot] == true && boost == true && number_carot == k) {\n            for (int j = 0; j < dist; j++) {\n                x[carot + j] = true;\n            }\n            number_carot = 0; \n        }\n    }\n    int u_dist = 0;\n    int v_dist = 0;\n    for (int i = 0; i < l; i++) {\n        if (x[i] == true) {\n            v_dist++;\n        } else {\n            u_dist++;\n        }\n    }\n    printf(\"%.7f\\n\", (double)((double)v_dist / v + (double)u_dist / u));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n, k, t, u, v, l;\nint road[10001];\ndouble ti[10001];\nint cnt;\nqueue<int> st;\n\nint main(){\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i,n){\n\t\tint d; cin >> d;\n\t\troad[d] = 1;\n\t}\n\tfor(int i = 1; i <= l; i++){\n\t\tif(cnt == 0){\n\t\t\tti[i] = ti[i-1]+1.0/u;\n\t\t} else{\n\t\t\tti[i] = ti[i-1]+1.0/v;\n\t\t\tif(i-st.front() >= t*v){\n\t\t\t\tst.pop();\n\t\t\t\tcnt--;\n\t\t\t\tif(cnt > 0) st.front() = i;\n\t\t\t}\n\t\t}\n\t\tif(road[i] == 1){\n\t\t\tif(cnt <= k){\n\t\t\t\tst.push(i);\n\t\t\t\tcnt++;\n\t\t\t} else{\n\t\t\t\tst.pop();\n\t\t\t\tst.front() = i;\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",ti[l]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,k,t,u,v,l;\n  cin>>n>>k>>t>>u>>v>>l;\n  int i,j;\n  set<int> s;\n  for(i=0;i<n;i++){\n    cin >> j;\n    s.insert(j);\n  }\n  int p=0,h=0,x=0;\n  double ans=0;\n  for(i=1;i<=l;i++){\n    \n    if(x==0){\n      if(h>0){\n\tx=v*t-1;h--;\n\tans+=1.0/v;\n      }else ans+=1.0/u;\n    }else{\n      ans+=1.0/v;\n      x--;\n    }\n    if(s.find(i)!=s.end()){\n      if(h<k) h++;\n      else{\n\tx=v*t;\n      }\n    }\n    \n    //cout << i << \":\" << h << \"/\";\n    //printf(\"%.9lf\\n\",ans);\n  }\n\n  printf(\"%.9lf\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main() {\n  int N, K;\n  double T, U, V, L;\n  double D[204];\n  while(cin >> N >> K >> T >> U >> V >> L) {\n    for(int i = 0; i < N; ++i) cin >> D[i];\n    D[N] = L;\n\n    double res = D[0]/U;\n    double remain = T*V;\n    double lim = T*V*(K+1);\n    for(int i = 0; i < N; ++i) {\n      double dist = D[i+1] - D[i];\n      if(dist <= remain) {\n\tres += dist/V;\n\tremain -= dist;\n      } else {\n\tres += remain/V + (dist-remain)/U;\n\tremain = 0;\n      }\n      remain = min(remain+T*V, lim);\n    }\n    printf(\"%.9f\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,k,t,u,v,l;\n\nint d[210];\n\nint main(void){\n\tcin >> n >> k >> t >> u >> v >> l;\n\trep(i,n) cin >> d[i];d[n]=l;\n\tdouble ans=0.0,res=0.0,num=0;\n\trep(i,n+1){\n\t\tdouble dist=d[i];\n\t\tif(i-1>=0) dist-=d[i-1];\n\t\twhile(dist>0.0){\n\t\t\tif(res>0.0){\n\t\t\t\tans+=min(dist/v,res);\n\t\t\t\tdouble ndist=dist-min(dist,res*v);\n\t\t\t\tdouble nres=res-min(dist/v,res);\n\t\t\t\tdist=ndist,res=nres;\n\t\t\t}\n\t\t\tif(num>0) res=t,num--;\n\t\t\tif(res==0.0) ans+=1.0*dist/u,dist=0.0;\n\t\t}\n\t\tif(num==k)\n\t\t\tres=t;\n\t\telse\n\t\t\tnum++;\n\t}\n\tcout.precision(10);\n\tcout << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,K,T,U,V,L;\n  cin>>N>>K>>T>>U>>V>>L;\n  queue<int> que;\n  float lv[10005];\n  for(int i=0;i<=10000;i++){\n    lv[i]=U;\n  }\n  for(int i=0;i<N;i++){\n    int val;\n    cin>>val;\n    que.push(val);\n  }\n  int l=1,k=0,vl=0;\n  while(l<=L){\n    if(l<vl) lv[l]=V;\n    if(l==que.front()){\n      k++;\n      que.pop();\n    }\n    if(k==1 && l>=vl){\n      k--;\n      lv[l]=V;\n      vl=l+T*V;\n    //  cout<<\"a\"<<vl<<endl;\n    }\n    if(l<vl && k>K){\n      k--;\n      vl=l+T*V;\n  //    cout<<vl<<endl;\n    }\n    l++;\n  }\n  double ans=0.0;\n  int x=0,y,v=lv[1],h=0;\n  for(int i=0;i<L;i++){\n    ans+=1.00/lv[i];\n  }\n  printf(\"%lf\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() \n{\n\tlong N,K,T,U,V,L;\n\tcin >> N >> K >> T >> U >> V >> L;\n\tlong d[202];\n\t\n\td[0] = 0;\n\tfor(int i=1;i<N+1;i++){\tcin >> d[i];}\n\td[N+1] = L;\n\t\n\tlong dis(0); //速度Uで走らなければいけない距離\n\tlong l(0); //速度Vで走れる残距離\n\tlong k(0); //ニンジンを持っている個数\n\t\n\tfor(int i=0 ; i < N+1 ; i++)\n\t{\n\t\t//地点i~i+1までの走りかたを判定\n\t\tif((d[i+1]-d[i]) >= (l + k*T*V)){\n\t\t\tdis += (d[i+1]-d[i]) - l - k*T*V;\n\t\t\tl = 0;\n\t\t\tk = 0;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tk = (-(d[i+1]-d[i]) + (l + k*T*V))/(T*V);\n\t\t\tl = (-(d[i+1]-d[i]) + (l + k*T*V)+T*V/*ナゾ*/)%(T*V);\n\t\t}\n\t\t\ncout << \"前 \" << i+1 << \" next \" << d[i+1]-d[i] << \" 余力 \" << l << \" car \" << k << endl;\n\t\t\n\t\t\n\t\t//地点i+1でのニンジンで初期化\n\t\tif(l==0){\n\t\t\tl = T*V;\n\t\t}else if(k==K){\n\t\t\tl = T*V;\n\t\t}else{\n\t\t\tk++;\n\t\t}\n\t\t\ncout << \"後 \" << i+1 << \" next \" << d[i+1]-d[i] << \" 余力 \" << l << \" car \" << k << endl;\n\n\t\t\n\t}\n\tdouble ans = (double)dis/(double)U + (double)(L - dis)/(double)V;\n\t\n\tcout << fixed << setprecision(6) << ans << endl;\n\t\n\treturn 0 ;\n}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K|(c&&!b))c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K|(c&!b))c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\n\tscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\n\tfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\n\tfor(;j<L;j++){\n\t\tif((c+=D[j])>K||(c&&!b))c--,b=T*V;\n\t\tb?v++,b--:u++;\n\t}\n\tprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[9999];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K||c&&!b)c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define EPS 1e-9\n\nint d[300];\nint main(){\n\tint n,k,t,u,v,l;\n\tscanf(\"%d%d%d%d%d%d\",&n,&k,&t,&u,&v,&l);\n\trep(i,0,n)scanf(\"%d\",d+i);\n\tdouble ans=0;\n\tint crr=0,cnt=0;\n\tdouble time=0;\n\trep(i,0,l){\n\t\tif(d[crr]==i)cnt++,crr++;\n\t\tif(fabs(time)<EPS&&cnt>0)time=t,cnt--;\n\t\tif(cnt>k)cnt=k,time=t;\n\t\tans+=time>EPS?1./v:1./u;\n\t\tif(time>EPS)time-=1./v;\n\t}\n\tprintf(\"%.9f\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "D[9999],i,j,c,b,v,u;main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K||c&&!b)c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K||c&&!b)c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(int argc, char *argv[]){\n\tint i,n,k,t,u,v,l,d[12000]={0},m;\n\tint now,carrot=0,spup=0;\n\tdouble time=0;\n\tscanf(\"%d %d %d %d %d %d \",&n,&k,&t,&u,&v,&l);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d \", &m);\n\t\td[m]=1;\n\t}\n\tfor(now=0;now<l;now++){\n\t\tif(d[now]){\n\t\t\tif(carrot < k) carrot ++;\n\t\t\telse spup=t*v;\n\t\t}\n\t\tif(!spup && carrot){\n\t\t\tcarrot --;\n\t\t\tspup = t*v;\n\t\t}\n\t\ttime += (double)1/(spup?v:u);\n\t\tif(spup)spup --;\n\t\t//printf(\"now %d, spup %d, time %lf, carrot %d\\n\", now, spup, time, carrot);\n\t}\n\tprintf(\"%lf\\n\", time);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K|c&&!b)c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if(c+=D[j]>K||c&&!b)c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "// AOJ 2298: Starting Line\n// 2017.11.2 bal4u@uu\n\n#include <stdio.h>\n\nint d[10002]; \n\nint main()\n{\n\tint n, k, t, u, v, l, i;\n\tint pos, up, keep;\n\tdouble ans;\n\n\tscanf(\"%d%d%d%d%d%d\", &n, &k, &t, &u, &v, &l);\n\twhile (n--) scanf(\"%d\", &i), d[i]++;\n\tans = 0, up = keep = 0;\n\tfor (pos = 1; pos <= l; pos++) {\n\t\tif (up) up--, ans += 1.0/v;\n\t\telse          ans += 1.0/u;\n\n\t\tif (keep && up == 0) keep--, up = v*t;\n\n\t\tif (d[pos]) {\n\t\t\tif (up == 0) d[pos]--, up = v*t;\n\t\t\tif (keep + d[pos] > k) d[pos]--, up = v*t, keep = k;\n\t\t\telse keep += d[pos];\n\t\t}\n\t}\n\tprintf(\"%.9lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K||c&&!b)c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\n}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K||c&&!b)c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "C",
    "code": "i,j,c,b,v,u,D[10000];main(N,K,T,U,V,L,x){\nscanf(\"%d%d%d%d%d%d\",&N,&K,&T,&U,&V,&L);\nfor(;i<N;i++)scanf(\"%d\",&x),D[x]=1;\nfor(;j<L;b?v++,b--:u++,j++)if((c+=D[j])>K||(c&&!b))c--,b=T*V;\nprintf(\"%f\\n\",1.*v/V+1.*u/U);\nexit(0);}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint N=sc.nextInt();//にんじんの個数\n\t\t\tint K=sc.nextInt();//保持できるにんじんの数\n\t\t\tint k=0;//保持しているにんじんの数\n\t\t\tint T=sc.nextInt();//加速できる時間\n\t\t\tint U=sc.nextInt();//普通の速さ\n\t\t\tint V=sc.nextInt();//加速の速さ\n\t\t\tint boost=0;//加速で進む距離\n\t\t\tint L=sc.nextInt();//スタ－トからゴールまでの距離\n\t\t\tint[] D=new int[N+1];//にんじんが置かれている場所\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tD[i]=sc.nextInt();\n\t\t\t}\n\t\t\tint index=1;\n\t\t\tdouble ans=0;\n\t\t\tfor(int i=0; i<L; i++) {\n\t\t\t\tif(index<=N && i==D[index]) {\n\t\t\t\t\tif(k < K)\tk++;\n\t\t\t\t\telse\t\tboost=V*T;\n\t\t\t\t\tindex++;\n\t\t\t\t}//とりあえず保持する\n\t\t\t\tif(boost==0 && k>0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tboost=V*T;\n\t\t\t\t}//加速範囲でないときにんじん使う\n\t\t\t\tif(boost==0) {\n\t\t\t\t\tans+=1.0/U;\n\t\t\t\t}//普通のとき\n\t\t\t\telse {\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\tboost--;\n\t\t\t\t}//加速のとき\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import javax.print.DocFlavor;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, K, T, U, V, L;\n    static int[] D;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        K = sc.nextInt();\n        T = sc.nextInt();\n        U = sc.nextInt();\n        V = sc.nextInt();\n        L = sc.nextInt();\n        D = sc.nextIntArray(N);\n\n        System.out.println(solve());\n    }\n\n    static String solve() {\n        double ans = 0;\n        Set<Integer> CARROT = new HashSet<>();\n        for (int d : D) {\n            CARROT.add(d);\n        }\n\n        int k = 0;\n        int power = 0;\n        for (int i = 0; i < L; i++) {\n            if( CARROT.contains(i) ) {\n                if( k == K ) {\n                    power = T*V;\n\n                } else {\n                    k++;\n                }\n            }\n            if( k > 0 && power == 0 ) {\n                power = T*V;\n                k--;\n            }\n\n            if( power > 0 ) {\n                ans += (double)1/V;\n                power--;\n            } else {\n                ans += (double)1/U;\n            }\n        }\n\n        return BigDecimal.valueOf(ans).toPlainString();\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n,k,t,u,v,l;\n        n = sc.nextInt();\n        k = sc.nextInt();\n        t = sc.nextInt();\n        u = sc.nextInt();\n        v = sc.nextInt();\n        l = sc.nextInt();\n\n        int[] d = new int[n+1];\n        for (int i = 0; i < n; ++i) d[i] = sc.nextInt();\n        d[n] = l;\n\n        int pos = 0, c = 0, nk = 0;\n        double tm = 0;\n\n        while (pos < l) {\n            // ??????????????????????????´???????????????\n            if (pos < d[c]) {\n                // ?????????????????£?????????\n                if (nk > 0) {\n                    nk--;\n                    int x = Math.min(l, pos+t*v);\n                    tm += (x-pos)/(double)v;\n                    pos = x;\n                }\n                // ?????£??????????????£??????\n                else {\n                    tm += (d[c]-pos)/(double)u;\n                    pos = d[c];\n                }\n            }\n            //  ?????????????????´???????????£??????\n            else {\n                // ?????????????????£??????????????£??????\n                if (d[c] == pos) {\n                    int x = Math.min(l, pos+t*v);\n                    tm += (x-pos)/(double)v;\n                    pos = x;\n                    ++c;\n                }\n                else {\n                    if (nk < k) {\n                        c++;\n                        nk++;\n                    }\n                    else {\n                        int x = Math.min(l, d[c++]+t*v);\n                        tm += (x-pos)/(double)v;\n                        pos = x;\n                    }\n                }\n            }\n        }\n        System.out.println(tm);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nclass UnionFind {\n\tint[] data;\n\tUnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tboolean unionSet(int x, int y) {\n\t\tx = root(x); \n\t\ty = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tboolean findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n}\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,-1,0,1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] check;\n\tstatic int idx;\n\t\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint T = sc.nextInt();\n\t\tint U = sc.nextInt();\n\t\tint V = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\t\n\t\tboolean[] state = new boolean[L+1];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tstate[sc.nextInt()] = true;\n\t\t}\n\t\tdouble time = 0;\n\t\tint    k    = 0;\n\t\tdouble timeX = 0;\n\t\tIN:for(int i = 0; i < L; i++) {\n\t\t\tif(state[i]) k++;\n\t\t\tif(Math.abs(timeX) <= 1.0e-4) {\n\t\t\t\tif(k != 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\ttimeX = T;\n\t\t\t\t\ttimeX -= 1.0 / V;\n\t\t\t\t\ttime += 1.0 / V;\n\t\t\t\t\tcontinue IN;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttime += 1.0 / U;\n\t\t\t\t\tcontinue IN;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(k == K+1) {\n\t\t\t\tk--;\n\t\t\t\ttimeX = T;\n\t\t\t}\n\t\t\t\n\t\t\ttimeX -= 1.0 / V;\n\t\t\ttime  += 1.0 / V;\n\t\t}\n\t\tSystem.out.printf(\"%.10f\\n\",time);\n\t}\n\n}\n\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint N=sc.nextInt();//にんじんの個数\n\t\t\tint K=sc.nextInt();//保持できるにんじんの数\n\t\t\tint k=0;//保持しているにんじんの数\n\t\t\tint T=sc.nextInt();//加速できる時間\n\t\t\tint U=sc.nextInt();//普通の速さ\n\t\t\tint V=sc.nextInt();//加速の速さ\n\t\t\tint d=V*T;//加速で進む距離\n\t\t\tint L=sc.nextInt();//スタ－トからゴールまでの距離\n\t\t\tint[] D=new int[L+1];//にんじんが置かれている場所\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tint carrot=sc.nextInt();\n\t\t\t\tD[carrot]=i;\n\t\t\t}\n\t\t\tdouble ans=0;\n\t\t\tfor(int i=0; i<L; i++) {\n\t\t\t\tif(l[i]==0 && D[i]==0 && k==0) {\n\t\t\t\t\tans+=1.0/U;\n\t\t\t\t}\n\t\t\t\telse if(D[i]>0){\n\t\t\t\t\tif(l[i]==0) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tif(i+d>=L) {\n\t\t\t\t\t\t\tfor(int j=i; j<L; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K>0) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tK--;\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K==0) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tif(i+d>=L) {\n\t\t\t\t\t\t\tfor(int j=i; j<L; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(l[i]==1) {\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t}\n\t\t\t\telse if(k>0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tK++;\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\tif(i+d>=L) {\n\t\t\t\t\t\tfor(int j=i; j<L; j++) {\n\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tint [] d = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint stock = 0, start = 0,end = 0, sum = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(d[i] <= end){\n\t\t\t\t\tif(stock == k){\n\t\t\t\t\t\tend = Math.min(l, d[i] + t * v);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstock++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(stock != 0 && d[i] > end){\n\t\t\t\t\t\tstock--;\n\t\t\t\t\t\tend = Math.min(l, end + t * v);\n\t\t\t\t\t}\n\t\t\t\t\tif(d[i] <= end){\n\t\t\t\t\t\tstock++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsum += end - start;\n\t\t\t\t\t\tstart = d[i];\n\t\t\t\t\t\tend = Math.min(l, d[i] + t * v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += Math.min(l, end + stock * t * v) - start;\n\t\t\tdouble res = (double)(l - sum) / u + (double)sum / v;\n\t\t\tSystem.out.printf(\"%.7f\\n\", res);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint t = sc.nextInt();\n\t\tint u = sc.nextInt();\n\t\tint v = sc.nextInt();\n\t\tint l = sc.nextInt();\n\n\t\tint d[] = new int[n + 1];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t}\n\t\td[n] = l;\n\n\t\tint index = 0;\n\t\tint nc = 0;\n\t\tint cn = 0;\n\t\tlong boost = t * v;\n\n\t\t\n\t\tint bl = 0;\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tif (d[index] <= i) {\n\t\t\t\tif (cn == 0) {\n\t\t\t\t\tnc = i;\n\t\t\t\t}\n\t\t\t\tif (cn == k+1) {\n\t\t\t\t\tnc = i;\n\t\t\t\t} else {\n\t\t\t\t\tcn++;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\t\n\t\t\tif (cn !=0 &&i - nc == boost) {\n\t\t\t\tnc = i;\n\t\t\t\tcn--;\n\t\t\t}\n\t\t\tif(cn > 0){\n\t\t\t\tbl++;\n\t\t\t}\n\t\t}\n\t\tint nbl = l-bl;\n\t\t\n\t\tSystem.out.println((double)bl/v + (double)nbl/u);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\tstatic Scanner scn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic Mathplus mp = new Mathplus();\n\tstatic int mod = 1000000007;\n\tstatic long modmod = (long)mod * mod;\n\tstatic long inf = (long)1e17;\n\tstatic int[] dx = {0,1,0,-1};\n\tstatic int[] dy = {1,0,-1,0};\n\tstatic int[] dx8 = {-1,-1,-1,0,0,1,1,1};\n\tstatic int[] dy8 = {-1,0,1,-1,1,-1,0,1};\n\tstatic char[] dc = {'R','D','L','U'};\n\tstatic String sp = \" \";\n\tpublic static void main(String[] args) {\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint T = sc.nextInt();\n\t\tint U = sc.nextInt();\n\t\tint V = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tint[] D = sc.nextInts(N);\n\t\tint slow = 0; //Um/sで走る距離\n\t\tint fast = 0; //Vm/sで走る距離\n\t\tint[] P = new int[L];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tP[D[i]] = 1;//ニンジンのある位置\n\t\t}\n\t\tboolean isfast = false;\n\t\tint run_end = 0;\n\t\tint carrot = 0;\n\t\tfor(int i=0;i<L;i++) {\n\t\t\tif(i==run_end)isfast = false;\n\t\t\tif(P[i]==1) {\n\t\t\t\tif(isfast) {\n\t\t\t\t\tif(carrot==K) run_end = i + T * V;\n\t\t\t\t\telse carrot++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisfast = true;\n\t\t\t\t\trun_end = i + T * V;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isfast&&carrot>0) {\n\t\t\t\tisfast = true;\n\t\t\t\trun_end = i + T * V;\n\t\t\t\tcarrot--;\n\t\t\t}\n\t\t\tif(isfast)fast++;\n\t\t\telse slow++;\n\t\t}\n\t\tSystem.out.println((double)fast/V+(double)slow/U);\n\t}\n\n}\n\nclass FastScanner {\n    private final java.io.InputStream in = System.in;\n    private final byte[] b = new byte[1024];\n    private int p = 0;\n    private int bl = 0;\n    private boolean hNB() {\n        if (p<bl) {\n            return true;\n        }else{\n            p = 0;\n            try {\n                bl = in.read(b);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (bl<=0) {\n                return false;\n            }\n        }\n        return true;\n    }\n   \n\tprivate int rB() { if (hNB()) return b[p++]; else return -1;}\n    private static boolean iPC(int c) { return 33 <= c && c <= 126;}\n    private void sU() { while(hNB() && !iPC(b[p])) p++;}\n    public boolean hN() { sU(); return hNB();}\n    public String next() {\n        if (!hN()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = rB();\n        while(iPC(b)) {\n            sb.appendCodePoint(b);\n            b = rB();\n        }\n        return sb.toString();\n    }\n    public char nextChar() {\n    \treturn next().charAt(0);\n    }\n    public long nextLong() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b=='-') {\n            m=true;\n            b=rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1||!iPC(b)){\n                return (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int nextInt() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b == '-') {\n            m = true;\n            b = rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b-'0';\n            }else if(b==-1||!iPC(b)){\n                return (int) (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int[] nextInts(int n) {\n    \tint[] a = new int[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public int[] nextInts(int n,int s) {\n    \tint[] a = new int[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public long[] nextLongs(int n, int s) {\n    \tlong[] a = new long[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n\t}\n    public long[] nextLongs(int n) {\n    \tlong[] a = new long[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n    }\n    public int[][] nextIntses(int n,int m){\n    \tint[][] a = new int[n][m];\n    \tfor(int i=0;i<n;i++) {\n    \t\tfor(int j=0;j<m;j++) {\n    \t\t\ta[i][j] = nextInt();\n    \t\t}\n    \t}\n    \treturn a;\n    }\n    \n    public String[] nexts(int n) {\n    \tString[] a = new String[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = next();\n    \t}\n    \treturn a;\n    }\n    void nextIntses(int n,int[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextInt();\n    \t\t}\n    \t}\n    }\n    void nextLongses(int n,long[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextLong();\n    \t\t}\n    \t}\n    }\n    \n   \n   \n}\n\n\nclass Mathplus{\n\tlong mod = 1000000007;\n\tlong[] fac;\n\tlong[] revfac;\n\tlong[][] comb;\n\tlong[] pow;\n\tlong[] revpow;\n\tboolean isBuild = false;\n\tboolean isBuildc = false;\n\tboolean isBuildp = false;\n\tint mindex = -1;\n\tint maxdex = -1;\n\tint graydiff = 0;\n\tint graymark = 0;\n\n\tint LIS(int N, int[] a) {\n\t\tint[] dp = new int[N+1];\n\t\tArrays.fill(dp,(int)mod);\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tint ok = 0;\n\t\t\tint ng = N;\n\t\t\twhile(ng-ok>1) {\n\t\t\t\tint mid = (ok+ng)/2;\n\t\t\t\tif(dp[mid]<a[i])ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tdp[ok+1] = a[i];\n\t\t}\n\t\tint ok = 0;\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tif(dp[i]<mod)ok=i;\n\t\t}\n\t\treturn ok;\n\t}\n\n\tpublic Integer[] Ints(int n, int i) {\n\t\tInteger[] ret = new Integer[n];\n\t\tArrays.fill(ret,i);\n\t\treturn ret;\n\t}\n\tpublic Long[] Longs(int n, long i) {\n\t\tLong[] ret = new Long[n];\n\t\tArrays.fill(ret,i);\n\t\treturn ret;\n\t}\n\n\tpublic boolean nexperm(int[] p) {\n\t\tint n = p.length;\n\t\tfor(int i=n-1;i>0;i--) {\n\t\t\tif(p[i-1]<p[i]) {\n\t\t\t\tint sw = n;\n\t\t\t\tfor(int j=n-1;j>=i;j--) {\n\t\t\t\t\tif(p[i-1]<p[j]) {\t\t\t\t\t\t\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint tmp = p[i-1];\n\t\t\t\tp[i-1] = p[sw];\n\t\t\t\tp[sw] = tmp;\n\t\t\t\tint[] r = new int[n];\n\t\t\t\tfor(int j=i;j<n;j++) {\n\t\t\t\t\tr[j] = p[n-1-j+i];\n\t\t\t\t}\n\t\t\t\tfor(int j=i;j<n;j++) {\n\t\t\t\t\tp[j] = r[j];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic int[] makeperm(int n) {\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = i;\n\t\t}\n\t\treturn a;\n\t}\n\n\tint color(int[][] diff,int N) {\n\n\t\tint[] val = new int[1<<N];\n\t\tval[0] = 1;\n\t\tfor(int i=0;i<(1<<N);i++) {\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\tif(contains(i,j)) {\n\t\t\t\t\tif(val[bitremove(i,j)]==1) {\n\t\t\t\t\t\tboolean b = true;\n\t\t\t\t\t\tfor(int k=0;k<N;k++) {\n\t\t\t\t\t\t\tif(contains(i,k)&&diff[j][k]==1) {\n\t\t\t\t\t\t\t\tb = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b)val[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[1<<N];\n\t\tArrays.fill(dp,N+1);;\n\t\tdp[0] = 0;\n\t\tfor(int i=0;i<(1<<N);i++) {\n\t\t\tfor(int j=i;j>0;j=(j-1)&i) {\n\t\t\t\tif(val[j]==1)dp[i]=Math.min(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t\treturn dp[(1<<N)-1];\n\t}\n\n\t\n\n\tpublic void timeout() throws InterruptedException {\n\t\tThread.sleep(10000);\n\t}\n\n\tpublic int gray(int i) {\n\t\tfor(int j=0;j<20;j++) {\n\t\t\tif(contains(i,j)) {\n\t\t\t\tgraydiff = j;\n\t\t\t\tif(contains(i,j+1))graymark=-1;\n\t\t\t\telse graymark = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i ^ (i>>1);\n\t\t\t\n\n\t}\n\n\tpublic void hakidashi(long[] A) {\n\t\tArrays.sort(A);\n\t\tint N = A.length;\n\t\tint[] index = new int[61];\n\t\tfor(int i=0;i<=60;i++){\n\t\t\tindex[i] = -1;\n\t\t}\n\t\tint searching = 60;\n\t\tint [] used = new int[N];\n\t\twhile(searching>=0){\n\t\t\tboolean b = true;\n\t\t\tfor(int i=N-1;i>=0;i--){\n\t\t\t\tfor(int j=60;j>searching;j--){\n\t\t\t\t\tif((A[i]>>j&1)==1){\n\t\t\t\t\t\tif(i!=index[j]&&index[j]!=-1){\n\t\t\t\t\t\t\tA[i] ^= A[index[j]];\n\t\t\t\t\t\t\t//System.out.println(i+\" changed by \" + index[j]);\n\t\t\t\t\t\t\t//System.out.println(A[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif((A[i]>>searching&1)==1&&used[i]==0){\n\t\t\t\t\t//System.out.println(\"find \" + searching+\" is \"+i);\n\t\t\t\t\tindex[searching] = i;\n\t\t\t\t\tsearching--;\n\t\t\t\t\tused[i] = 1;\n\t\t\t\t\tb = false;\n\t\t\t\t\tif(searching==-1){\n\t\t\t\t\t\tsearching = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b){\n\t\t\t\tsearching--;\n\t\t\t}\n\n\t\t}\n\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\tfor(int j=60;j>=searching;j--){\n\t\t\t\tif((A[i]>>j&1)==1){\n\t\t\t\t\tif(i!=index[j]&&index[j]!=-1){\n\t\t\t\t\t\tA[i] ^= A[index[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tArrays.sort(A);\n\t\t\n\t}\n\n\tpublic void printjudge(boolean b, String y, String n) {\n\t\tSystem.out.println(b?y:n);\n\t}\n\tpublic void printYN(boolean b) {\n\t\tprintjudge(b,\"Yes\",\"No\");\n\t}\n\tpublic void printyn(boolean b) {\n\t\tprintjudge(b,\"yes\",\"no\");\n\t}\n\t\n\tpublic void reverse(int[] x) {\n\t\tint[] r = new int[x.length];\n\t\tfor(int i=0;i<x.length;i++)r[i] = x[x.length-1-i];\n\t\tfor(int i=0;i<x.length;i++)x[i] = r[i];\n\t}\n\tpublic void reverse(long[] x) {\n\t\tlong[] r = new long[x.length];\n\t\tfor(int i=0;i<x.length;i++)r[i] = x[x.length-1-i];\n\t\tfor(int i=0;i<x.length;i++)x[i] = r[i];\n\t}\n\n\t\n\t\n\t\n\tpublic boolean dcross(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy) {\n\t\tdouble ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\t\tdouble tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\t\tdouble tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\t\tdouble td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\t\treturn((tc>=0&&td<=0)||(tc<=0&&td>=0))&&((ta>=0&&tb<=0)||(ta<=0&&tb>=0));\n\t}\n\n\tvoid buildFac(){\n\t\tfac = new long[10000003];\n\t\trevfac = new long[10000003];\n\t\tfac[0] = 1;\n\t\tfor(int i=1;i<=10000002;i++){\n\t\t\tfac[i] = (fac[i-1] * i)%mod;\n\t\t}\n\t\trevfac[10000002] = rev(fac[10000002])%mod;\n\t\tfor(int i=10000001;i>=0;i--) {\n\t\t\trevfac[i] = (revfac[i+1] * (i+1))%mod;\n\t\t}\n\t\tisBuild = true;\n\t}\n\tvoid buildFacn(int n){\n\t\tfac = new long[n+1];\n\t\trevfac = new long[n+1];\n\t\tfac[0] = 1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfac[i] = (fac[i-1] * i)%mod;\n\t\t}\n\t\trevfac[n] = rev(fac[n])%mod;\n\t\tfor(int i=n-1;i>=0;i--) {\n\t\t\trevfac[i] = (revfac[i+1] * (i+1))%mod;\n\t\t}\n\t\tisBuild = true;\n\t}\n\tpublic long[] buildrui(int[] a) {\n\t\tint n = a.length;\n\t\tlong[] ans = new long[n];\n\t\tans[0] = a[0];\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tans[i] = ans[i-1] + a[i];\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int[][] ibuildrui(int[][] a) {\n\t\tint n = a.length;\n\t\tint m = a[0].length;\n\t\tint[][] ans = new int[n][m];\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tans[i][j] = a[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tans[i][j] += ans[i][j-1] + ans[i-1][j] - ans[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic void buildruin(int[][] a) {\n\t\tint n = a.length;\n\t\tint m = a[0].length;\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\ta[i][j] += a[i][j-1] + a[i-1][j] - a[i-1][j-1];\n\t\t\t}\n\t\t}\n\t}\n\tpublic long[][] buildrui(int[][] a) {\n\t\tint n = a.length;\n\t\tint m = a[0].length;\n\t\tlong[][] ans = new long[n][m];\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tans[i][j] = a[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tans[i][j] += ans[i][j-1] + ans[i-1][j] - ans[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int getrui(int[][] r,int a,int b,int c,int d) {\n\t\treturn r[c][d] - r[a-1][d] - r[c][b-1] + r[a-1][b-1];\n\t}\n\tpublic long getrui(long[][] r,int a,int b,int c,int d) {\n\t\tif(a<0||b<0||c>=r.length||d>=r[0].length) return mod;\n\t\treturn r[c][d] - r[a-1][d] - r[c][b-1] + r[a-1][b-1];\n\t}\n\t\n\tlong divroundup(long n,long d) {\n\t\tif(n==0)return 0;\n\t\treturn (n-1)/d+1;\n\t}\n\tpublic long sigma(long i) {\n\t\treturn i*(i+1)/2;\n\t}\n\tpublic int digit(long i) {\n\t\tint ans = 1;\n\t\twhile(i>=10) {\n\t\t\ti /= 10;\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\n\t}\n\tpublic int digitsum(long n) {\n\t\tint ans = 0;\n\t\twhile(n>0) {\n\t\t\tans += n%10;\n\t\t\tn /= 10;\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int popcount(int i) {\n\t\tint ans = 0;\n\t\twhile(i>0) {\n\t\t\tans += i%2;\n\t\t\ti /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic boolean contains(int S,int i) {return (S>>i&1)==1;}\n\tpublic int bitremove(int S,int i) {return S&(~(1<<i));}\n\tpublic int bitadd(int S,int i) {return S|(1<<i);}\n\tpublic boolean isSubSet(int S,int T) {return (S-T)==(S^T);}\n\tpublic boolean isDisjoint(int S,int T) {return (S+T)==(S^T);}\n\tpublic boolean contains(long S,int i) {return (S>>i&1)==1;}\n\tpublic long bitremove(long S,int i) {return S&(~(1<<i));}\n\tpublic long bitadd(long S,int i) {return S|(1<<i);}\n\tpublic boolean isSubSet(long S,long T) {return (S-T)==(S^T);}\n\tpublic boolean isDisjoint(long S,long T) {return (S+T)==(S^T);}\n\tpublic int isBigger(int[] d, int i) {\n\t\tint ok = d.length;\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isSmaller(int[] d, int i) {\n\t\tint ok = -1;\n\t\tint ng = d.length;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isBigger(long[] d, long i) {\n\t\tint ok = d.length;\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isSmaller(long[] d, long i) {\n\t\tint ok = -1;\n\t\tint ng = d.length;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d[mid]<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isBigger(ArrayList<Integer> d, int i) {\n\t\tint ok = d.size();\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d.get(mid)>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isSmaller(ArrayList<Integer> d, int i) {\n\t\tint ok = -1;\n\t\tint ng = d.size();\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d.get(mid)<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isBigger(ArrayList<Long> d, long i) {\n\t\tint ok = d.size();\n\t\tint ng = -1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d.get(mid)>i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic int isSmaller(ArrayList<Long> d, long i) {\n\t\tint ok = -1;\n\t\tint ng = d.size();\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid = (ok+ng)/2;\n\t\t\tif(d.get(mid)<i) {\n\t\t\t\tok = mid;\n\t\t\t}else {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tpublic HashSet<Integer> primetable(int m) {\n\t\tHashSet<Integer> pt = new HashSet<Integer>();\n\t\tfor(int i=2;i<=m;i++) {\n\t\t\tboolean b = true;\n\t\t\tfor(int d:pt) {\n\t\t\t\tif(i%d==0) {\n\t\t\t\t\tb = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b) {\n\t\t\t\tpt.add(i);\n\t\t\t}\n\t\t}\n\t\treturn pt;\n\t}\n\tpublic ArrayList<Integer> primetablearray(int m) {\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\tfor(int i=2;i<=m;i++) {\n\t\t\tq.add(i);\n\n\t\t}\n\t\tboolean[] b = new boolean[m+1];\n\t\twhile(!q.isEmpty()) {\n\t\t\tint e = q.poll();\n\t\t\tif(!b[e]) {\n\t\t\t\tal.add(e);\n\t\t\t\tfor(int j=1;e*j<=1000000;j++) {\n\t\t\t\t\tb[e*j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn al;\n\t}\n\t\n\tpublic boolean isprime(int e) {\n\t\tif(e==1) return false;\n\t\tfor(int i=2;i*i<=e;i++) {\n\t\t\tif(e%i==0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic int[] hipPush(int[] a){\n\t\tint[] r = new int[a.length];\n\t\tint[] s = new int[a.length];\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\ts[i] = a[i];\n\t\t}\n\t\tArrays.sort(s);\n\t\tHashMap<Integer,Integer> m = new HashMap<Integer,Integer>();\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tm.put(s[i],i);\n\t\t}\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tr[i] = m.get(a[i]);\n\t\t}\n\t\treturn r;\n\t}\n\tpublic HashMap<Integer,Integer> hipPush(ArrayList<Integer> l){\n\t\tHashMap<Integer,Integer> r = new HashMap<Integer,Integer>();\n\t\tTreeSet<Integer> s = new TreeSet<Integer>();\n\t\tfor(int e:l)s.add(e);\n\t\tint p = 0;\n\t\tfor(int e:s) {\n\t\t\tr.put(e,p);\n\t\t\tp++;\n\t\t}\n\t\treturn r;\n\t}\n\tpublic TreeMap<Integer,Integer> thipPush(ArrayList<Integer> l){\n\t\tTreeMap<Integer,Integer> r = new TreeMap<Integer,Integer>();\n\t\tCollections.sort(l);\n\t\tint b = -(1000000007+9393);\n\t\tint p = 0;\n\t\tfor(int e:l) {\n\t\t\tif(b!=e) {\n\t\t\t\tr.put(e,p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tb=e;\n\t\t}\n\t\treturn r;\n\t}\n\tint[] count(int[] a) {\n\t\tint[] c = new int[max(a)+1];\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tc[a[i]]++;\n\t\t}\n\t\treturn c;\n\t}\n\tint[] count(int[] a, int m) {\n\t\tint[] c = new int[m+1];\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tc[a[i]]++;\n\t\t}\n\t\treturn c;\n\t}\n\tlong max(long[] a){\n\t\tlong M = Long.MIN_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(M<=a[i]){\n\t\t\t\tM =a[i];\n\t\t\t\tmaxdex = i;\n\t\t\t}\n\t\t}\n\t\treturn M;\n\t}\n\tint max(int[] a){\n\t\tint M = Integer.MIN_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(M<=a[i]){\n\t\t\t\tM =a[i];\n\t\t\t\tmaxdex = i;\n\t\t\t}\n\t\t}\n\t\treturn M;\n\t}\n\tlong min(long[] a){\n\t\tlong m = Long.MAX_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(m>a[i]){\n\t\t\t\tm =a[i];\n\t\t\t\tmindex = i;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tint min(int[] a){\n\t\tint m = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(m>a[i]){\n\t\t\t\tm =a[i];\n\t\t\t\tmindex = i;\n\t\t\t}\n\t\t}\n\t\treturn m;\n\t}\n\tlong sum(long[] a){\n\t\tlong s = 0;\n\t\tfor(int i=0;i<a.length;i++)s += a[i];\n\t\treturn s;\n\t}\n\tlong sum(int[] a){\n\t\tlong s = 0;\n\t\tfor(int i=0;i<a.length;i++)s += a[i];\n\t\treturn s;\n\t}\n\tlong  sum(ArrayList<Integer> l) {\n\t\tlong s = 0;\n\t\tfor(int e:l)s += e;\n\t\treturn s;\n\t}\n\tlong gcd(long a, long b){\n\t\ta = Math.abs(a);\n\t\tb = Math.abs(b);\n\t\tif(a==0)return b;\n\t\tif(b==0)return a;\n\t\tif(a%b==0) return b;\n\t\telse return gcd(b,a%b);\n\t}\n\tint igcd(int a, int b) {\n\t\tif(a%b==0) return b;\n\t\telse return igcd(b,a%b);\n\t}\n\tlong lcm(long a, long b) {return a / gcd(a,b) * b;}\n\tpublic long perm(int a,int num) {\n\t\tif(!isBuild)buildFac();\n\t\treturn fac[a]*(rev(fac[a-num]))%mod;\n\t}\n\tvoid buildComb(int N) {\n\t\tcomb = new long[N+1][N+1];\n\t\tcomb[0][0] = 1;\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tcomb[i][0] = 1;\n\t\t\tfor(int j=1;j<N;j++) {\n\t\t\t\tcomb[i][j] = comb[i-1][j-1]+comb[i-1][j];\n\t\t\t\tif(comb[i][j]>mod)comb[i][j]-=mod;\n\t\t\t}\n\t\t\tcomb[i][i] = 1;\n\t\t}\n\t}\n\tpublic long comb(int a,int num){\n\t\tif(a-num<0)return 0;\n\t\tif(num<0)return 0;\n\t\tif(!isBuild)buildFac();\n\t\tif(a>10000000) return combN(a,num);\n\t\treturn fac[a] * ((revfac[num]*revfac[a-num])%mod)%mod;\n\t}\n\tlong combN(int a,int num) {\n\t\tlong ans = 1;\n\t\tfor(int i=0;i<num;i++) {\n\t\t\tans *= a-i;\n\t\t\tans %= mod;\n\t\t}\n\t\treturn ans * revfac[num] % mod;\n\t}\n\tlong mulchoose(int n,int k) {\n\t\tif(k==0) return 1;\n\t\treturn comb(n+k-1,k);\n\t}\n\tlong rev(long l) {return pow(l,mod-2);}\n\n\tvoid buildpow(int l,int i) {\n\t\tpow = new long[i+1];\n\t\tpow[0] = 1;\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\tpow[j] = pow[j-1]*l;\n\t\t\tif(pow[j]>mod)pow[j] %= mod;\n\t\t}\n\t}\n\tvoid buildrevpow(int l,int i) {\n\t\trevpow = new long[i+1];\n\t\trevpow[0] = 1;\n\t\tfor(int j=1;j<=i;j++) {\n\t\t\trevpow[j] = revpow[j-1]*l;\n\t\t\tif(revpow[j]>mod) revpow[j] %= mod;\n\t\t}\n\t}\n\tlong pow(long l, long i) {\n\t\tif(i==0)return 1;\n\t\telse{\n\t\t\tif(i%2==0){\n\t\t\t\tlong val = pow(l,i/2);\n\t\t\t\treturn val * val % mod;\n\t\t\t}\n\t\t\telse return pow(l,i-1) * l % mod;\n\t\t}\n\t}\n\tlong mon(int i) {\n\t\tlong ans = 0;\n\t\tfor(int k=2;k<=i;k++) {\n\t\t\tans += (k%2==0?1:-1) * revfac[k];\n\t\t\tans += mod;\n\t\t}\n\t\tans %= mod;\n\t\tans *= fac[i];\n\t\treturn ans%mod;\n\t}\n\t\n\t\n\t\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tint [] d = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint stock = 0, start = 0,end = 0, sum = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(d[i] <= end){\n\t\t\t\t\tif(stock == k){\n\t\t\t\t\t\tend = Math.min(l, d[i] + t * v);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstock++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twhile(stock != 0 && d[i] > end){\n\t\t\t\t\t\tstock--;\n\t\t\t\t\t\tend = Math.min(l, end + t * v);\n\t\t\t\t\t}\n\t\t\t\t\tif(d[i] <= end){\n\t\t\t\t\t\tstock++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsum += end - start;\n\t\t\t\t\t\tstart = d[i];\n\t\t\t\t\t\tend = Math.min(l, d[i] + t * v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += Math.min(l, (long)end + (long)stock * t * v) - start;\n\t\t\tdouble res = (double)(l - sum) / u + (double)sum / v;\n\t\t\tSystem.out.printf(\"%.7f\\n\", res);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n, k, t, u, v, goal;\n\tint[] d;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\t\tt=sc.nextInt();\n\t\tu=sc.nextInt();\n\t\tv=sc.nextInt();\n\t\tgoal=sc.nextInt();\n\t\td=new int[n+1];\n\t\tfor(int i=0; i<n; i++){\n\t\t\td[i]=sc.nextInt();\n\t\t}\n\t\td[n]=goal;\n\n\t\tboolean boost=false;\n\t\tdouble boostTime=0;\n\t\tint carrot=0;\n\t\tdouble x=0;\n\t\tdouble time=0;\n\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tif(boost){\n\t\t\t\tfor(; carrot>=0; carrot--){\n\t\t\t\t\tif(x+v*boostTime>d[i]+EPS){\n\t\t\t\t\t\ttime+=(d[i]-x)/v;\n\t\t\t\t\t\tboostTime-=(d[i]-x)/v;\n\t\t\t\t\t\tx=d[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tx+=v*boostTime;\n\t\t\t\t\t\ttime+=boostTime;\n\t\t\t\t\t\tboostTime=t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble s=(double)(d[i]-x)/u;\n\t\t\ttime+=s;\n\t\t\tcarrot++;\n\t\t\tif(!boost||carrot>k){\n\t\t\t\tboost=true;\n\t\t\t\tboostTime=t;\n\t\t\t\tcarrot--;\n\t\t\t}\n\t\t\tx=d[i];\n\t\t}\n\t\tprintln(time+\"\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint N=sc.nextInt();//にんじんの個数\n\t\t\tint K=sc.nextInt();//保持できるにんじんの数\n\t\t\tint k=0;//保持しているにんじんの数\n\t\t\tint T=sc.nextInt();//加速できる時間\n\t\t\tint U=sc.nextInt();//普通の速さ\n\t\t\tint V=sc.nextInt();//加速の速さ\n\t\t\tint d=V*T;//加速で進む距離\n\t\t\tint L=sc.nextInt();//スタ－トからゴールまでの距離\n\t\t\tint[] D=new int[L+1];//にんじんが置かれている場所\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tint carrot=sc.nextInt();\n\t\t\t\tD[carrot]=i;\n\t\t\t}\n\t\t\tdouble ans=0;\n\t\t\tfor(int i=0; i<L; i++) {\n\t\t\t\tif(l[i]==0 && D[i]==0 && k==0) {\n\t\t\t\t\tans+=1.0/U;\n\t\t\t\t}\n\t\t\t\telse if(D[i]>0){\n\t\t\t\t\tif(l[i]==0) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tif(i+d>=L) {\n\t\t\t\t\t\t\tfor(int j=i; j<L; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K>0) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tK--;\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K==0) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(l[i]==1) {\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t}\n\t\t\t\telse if(k>0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tK++;\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\tfor(int j=i+1; j<i+d; j++) {\n\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] arg) {\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint T = sc.nextInt();\n\t\tint U = sc.nextInt();\n\t\tint V = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tint[] D = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tD[i] = sc.nextInt();\n\t\t}\n\t\tint pos = 0;\n\t\tdouble time = 0;\n\t\tdouble dist = 0;\n\t\tdouble bootEnd = -1;\n\t\tint carrot = 0;\n\t\twhile (true) {\n\t\t\tif (bootEnd < 0) {\n\t\t\t\tif (carrot > 0) {\n\t\t\t\t\t--carrot;\n\t\t\t\t\tbootEnd = dist + T * V;\n\t\t\t\t} else {\n\t\t\t\t\tif (pos < N) {\n\t\t\t\t\t\ttime += (D[pos] - dist) / U;\n\t\t\t\t\t\tdist = D[pos];\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\t++carrot;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime += (L - dist) / U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pos < N) {\n\t\t\t\t\tif (bootEnd < D[pos]) {\n\t\t\t\t\t\ttime += (bootEnd - dist) / V;\n\t\t\t\t\t\tdist = bootEnd;\n\t\t\t\t\t\tbootEnd = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime += (D[pos] - dist) / V;\n\t\t\t\t\t\tdist = D[pos];\n\t\t\t\t\t\tif (carrot == K) {\n\t\t\t\t\t\t\tbootEnd = D[pos] + T * V;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t++carrot;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (bootEnd < L) {\n\t\t\t\t\t\ttime += (bootEnd - dist) / V;\n\t\t\t\t\t\tdist = bootEnd;\n\t\t\t\t\t\tbootEnd = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime += (L - dist) / V;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(time);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Starting Line\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), K = sc.nextInt(), T = sc.nextInt(), U = sc.nextInt(), V = sc.nextInt(), L = sc.nextInt();\n\t\tint[] D = new int[n+1];\n\t\tfor(int i=0;i<n;i++)D[i]=sc.nextInt();\n\t\tD[n] = L;\n\t\tdouble res = 0;\n\t\tint pos = 0, k = 0, f = 0;\n\t\twhile(pos<L){\n\t\t\tif(pos<D[f]){\n\t\t\t\tif(0<k){\n\t\t\t\t\tk--;\n\t\t\t\t\tint nx = Math.min(L, pos+T*V);\n\t\t\t\t\tres+=(nx-pos+0.)/V;\n\t\t\t\t\tpos = nx;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tres+=(D[f]-pos+0.)/U;\n\t\t\t\t\tpos = D[f];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(k==0){\n\t\t\t\t\tif(D[f]==pos){\n\t\t\t\t\t\tint nx = Math.min(L, pos+T*V);\n\t\t\t\t\t\tres+=(nx-pos+0.)/V;\n\t\t\t\t\t\tpos = nx;\n\t\t\t\t\t\tf++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tk++; f++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(k==K){\n\t\t\t\t\tint nx = Math.min(L, D[f++]+T*V);\n\t\t\t\t\tres+=(nx-pos+0.)/V;\n\t\t\t\t\tpos = nx;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tf++;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.8f\\n\", res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint N=sc.nextInt();//にんじんの個数\n\t\t\tint K=sc.nextInt();//保持できるにんじんの数\n\t\t\tint k=0;//保持しているにんじんの数\n\t\t\tint T=sc.nextInt();//加速できる時間\n\t\t\tint U=sc.nextInt();//普通の速さ\n\t\t\tint V=sc.nextInt();//加速の速さ\n\t\t\tint d=V*T;//加速で進む距離\n\t\t\tint L=sc.nextInt();//スタ－トからゴールまでの距離\n\t\t\tint[] D=new int[L+1];//にんじんが置かれている場所\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tint carrot=sc.nextInt();\n\t\t\t\tD[carrot]=i;\n\t\t\t}\n\t\t\tdouble ans=0;\n\t\t\tfor(int i=0; i<L; i++) {\n\t\t\t\tif(l[i]==0 && D[i]==0 && k==0) {\n\t\t\t\t\tans+=1.0/U;\n\t\t\t\t}\n\t\t\t\telse if(D[i]>0){\n\t\t\t\t\tif(D[i]==1) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tif(i+d>=L) {\n\t\t\t\t\t\t\tfor(int j=i; j<L; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K>0) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tK--;\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K==0) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(l[i]==1) {\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t}\n\t\t\t\telse if(k>0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tK++;\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\tfor(int j=i+1; j<i+d; j++) {\n\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int N,K,T,U,V,L;\n\tstatic int[] ninjin;\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tN=sc.nextInt();\n\t\tK=sc.nextInt();\n\t\tT=sc.nextInt();\n\t\tU=sc.nextInt();\n\t\tV=sc.nextInt();\n\t\tL=sc.nextInt();\n\t\tninjin=new int[N+1];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tninjin[i]=sc.nextInt();\n\t\t}\n\t\tninjin[N]=L;\n\t\tdouble now=0.0;\n\t\tdouble cTime=0.0;\n\t\tint hasC=0;\n\t\tboolean isc=false;\n\t\tint ccnt=0;\n\t\tdouble velo=U;\n\t\tdouble ans=0.0;\n\t\twhile(now!=L){\n\t\t\tdouble ndist=ninjin[ccnt]-now;\n\t\t\tdouble ncarotto=cTime*V;\n\t\t\tdouble dist=0.0;\n\t\t\t// テ、ツコツコテ・ツ渉づ」ツδ妥」ツδッテ」ツδシテ・ツ按?」ツつ?\n\t\t\tif(ndist>ncarotto&&isc){\n//\t\t\t\tSystem.out.println(ans);\n\t\t\t\tdist=ncarotto;\n\t\t\t\tnow += dist;\n\t\t\t\tans += dist/velo;\n\t\t\t\tisc=false;\n\t\t\t\tcTime=0.0;\n\t\t\t\tvelo=U;\n\t\t\t}\n\t\t\t\n\t\t\t// ninjinテ・ツ慊ーテァツつケ\n\t\t\telse{\n//\t\t\t\tSystem.out.println(\"ninjin\"+ans);\n\t\t\t\tdist=ndist;\n\t\t\t\tnow = ninjin[ccnt];\n\t\t\t\tans += dist/velo;\n\t\t\t\tccnt++;\n\t\t\t\thasC++;\n\t\t\t\tif(isc){\n\t\t\t\t\tcTime -= dist/velo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isc&&hasC>0||hasC>K){\n\t\t\t\thasC--;\n\t\t\t\tvelo=V;\n\t\t\t\tisc=true;\n\t\t\t\tcTime = T;\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.10f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpublic void run() {\n\t\tint N = in.nextInt(), K = in.nextInt(), T = in.nextInt(), U = in.nextInt(), V = in.nextInt(), L = in.nextInt();\n\t\t\n\t\tint[] D = in.nextIntArray(N);\n\t\tArrays.sort(D);\n\t\t\n\t\tint rest = 0, has = 0;\n\t\tint cur = 0;\n\t\tdouble res = 0;\n\t\tfor (int pos = 0; pos < L; pos++) {\n\t\t\tif (cur < N && D[cur] == pos) {\n\t\t\t\tif (rest == 0) {\n\t\t\t\t\trest = T * V;\n\t\t\t\t} else {\n\t\t\t\t\tif (has != K) {\n\t\t\t\t\t\thas++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trest = T * V;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t}\n//\t\t\tSystem.out.println(pos + \" : \" + rest + \" \" + has + \" \" + cur + \" \" + res);\n\t\t\t\n\t\t\tif (rest > 0) {\n\t\t\t\trest--;\n\t\t\t\tres += 1.0 / V;\n\t\t\t} else {\n\t\t\t\tif (has > 0) {\n\t\t\t\t\thas--;\n\t\t\t\t\trest = T * V - 1;\n\t\t\t\t\tres += 1.0 / V;\n\t\t\t\t} else {\n\t\t\t\t\tres += 1.0 / U;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tint N=sc.nextInt();//にんじんの個数\n\t\t\tint K=sc.nextInt();//保持できるにんじんの数\n\t\t\tint k=0;//保持しているにんじんの数\n\t\t\tint T=sc.nextInt();//加速できる時間\n\t\t\tint U=sc.nextInt();//普通の速さ\n\t\t\tint V=sc.nextInt();//加速の速さ\n\t\t\tint d=V*T;//加速で進む距離\n\t\t\tint L=sc.nextInt();//スタ－トからゴールまでの距離\n\t\t\tint[] D=new int[L+1];//にんじんが置かれている場所\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=1; i<=N; i++) {\n\t\t\t\tint carrot=sc.nextInt();\n\t\t\t\tD[carrot]=i;\n\t\t\t}\n\t\t\tdouble ans=0;\n\t\t\tfor(int i=0; i<L; i++) {\n\t\t\t\tif(l[i]==0 && D[i]==0 && k==0) {\n\t\t\t\t\tans+=1.0/U;\n\t\t\t\t}\n\t\t\t\telse if(D[i]>0){\n\t\t\t\t\tif(D[i]==1) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K>0) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tK--;\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t}\n\t\t\t\t\telse if(l[i]==1 && K==0) {\n\t\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\t\tfor(int j=i; j<i+d; j++) {\n\t\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(l[i]==1) {\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t}\n\t\t\t\telse if(k>0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tK++;\n\t\t\t\t\tans+=1.0/V;\n\t\t\t\t\tfor(int j=i+1; j<i+d; j++) {\n\t\t\t\t\t\tl[j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        var i = _sz++;\n        while (i > 0)\n        {\n            var p = (i - 1) / 2;\n            if (Compare(_heap[p], x) <= 0) break;\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n            if (Compare(_heap[a], x) >= 0) break;\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count() => _count;\n    public T Peek() => _heap[0];\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\n\npublic class hello\n{\n    public static int n, k, t, U, V, L;\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        n = int.Parse(line[0]);\n        k = int.Parse(line[1]);\n        t = int.Parse(line[2]);\n        U = int.Parse(line[3]);\n        V = int.Parse(line[4]);\n        L = int.Parse(line[5]);\n        var c = new bool[L];\n        getAns();\n    }\n    static void getAns()\n    {\n        var c = new bool[L];\n        var pq = new PriorityQueue<int>(L * 2, 0);\n        for (int i = 0; i < n; i++)\n        {\n            var x = int.Parse(Console.ReadLine().Trim());\n            pq.Push(x);\n            c[x] = true;\n        }\n        var vup = false;\n        var time = 0d;\n        var take = 0;\n        var vdown = 0;\n        var preL = 0;\n        while (pq.Count() > 0)\n        {\n            var i = pq.Pop();\n\n            if (pq.Count() > 0 && pq.Peek() == i) pq.Pop();\n            if (i >= L) continue;\n            if (vdown == i)\n            {\n                if (take > 0) { take--; vdown = i + t * V; pq.Push(vdown); }\n                else\n                {\n                    vup = false;\n                    time += (double)(i - preL) / V;\n                    preL = i;\n                }\n            }\n            if (c[i])\n            {\n                if (!vup)\n                {\n                    vup = true;\n                    vdown = i + t * V;\n                    pq.Push(vdown);\n                    time += (double)(i - preL) / U; preL = i;\n                }\n                else\n                {\n                    if (take == k)\n                    {\n                        vdown = i + t * V;\n                        pq.Push(vdown);\n                        time += (double)(i - preL) / V;\n                        preL = i;\n                    }\n                    else take++;\n                }\n            }\n        }\n        if (vup) time += (double)(L - preL) / V;\n        else time += (double)(L - preL) / U;\n        Console.WriteLine(time);\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nvar NKTUVL=(Arr.shift()).split(\" \").map(Number);\nvar N=NKTUVL[0];\nvar K=NKTUVL[1];\nvar T=NKTUVL[2];\nvar U=NKTUVL[3];\nvar V=NKTUVL[4];\nvar L=NKTUVL[5];\nvar time=0;\nvar obj={};\nfor(var i=0;i<N;i++)obj[Arr.shift()-0]=true;\nvar fast=0;\nvar stock=0;\nfor(var i=0;i<L;i++){\n   var now=(obj.hasOwnProperty(i))?true:false;\n   if(fast==0 && now==true){time+=1/V;fast=(T*V-1);continue;}\n   if(fast==0 && now==false && stock==0){time+=1/U;continue;}\n   if(fast==0 && now==false && stock>0){time+=1/V;fast=(T*V-1);stock--;continue;}\n   if(fast>0 && now==false){time+=1/V;fast--;continue;}\n   if(fast>0 && now==true && stock+1<=K){time+=1/V;fast--;stock++;continue;}\n   if(fast>0 && now==true && stock+1>K){time+=1/V;fast=(T*V-1);continue;}\n}\nconsole.log(time.toFixed(9));"
  },
  {
    "language": "Ruby",
    "code": "require 'mathn'\n\nn, k, t, u, v, l = gets.split.map &:to_i\ncarrots = (1..n.to_i).map{gets.to_i}\ncarrots << l\n\nx = 0\nc = 0\naccel = 0\ntime = 0\n\ncarrots.each{|d|\n\tif x + accel * v >= d\n\t\tdt = (d - x) / v\n\t\ttime += dt\n\t\taccel -= dt\n\t\tx = d\n\t\tif c == k\n\t\t\taccel = t\n\t\telse\n\t\t\tc += 1\n\t\tend\n\telse\n\t\tx += accel * v\n\t\ttime += accel \n\t\taccel = 0\n\n\t\tif c == 0\n\t\t\ttime += (d - x) / u\n\t\t\tx = d\n\t\t\tc = 1\n\t\telse\n\t\t\tif x + c * t * v >= d\n\t\t\t\tused = ((d - x) / (t * v)).ceil\n\t\t\t\tc -= used - 1\n\t\t\t\tdt = (d - x) / v\n\t\t\t\ttime += dt\n\t\t\t\tx = d\n\t\t\t\taccel = used * t - dt\n\t\t\telse\n\t\t\t\tx += c * t * v\n\t\t\t\ttime += c * t\n\t\t\t\ttime += (d - x) / u\n\t\t\t\tx = d\n\t\t\t\tc = 1\n\t\t\tend\n\t\tend\n\tend\n}\n\np time.to_f"
  },
  {
    "language": "Ruby",
    "code": "N, K, T, U, V, L = gets.chomp.split(' ').map(&:to_f)\nd = []\nN.to_i.times do\n  d << gets.to_f\nend\n\ntime =  0.0\nboost = 0\nstock = 0\n\nt = d.shift / U\ndistance = t * U\ntime += t\nboost = 1\nb_time = T\n\nwhile true\n  case boost\n  when 0\n    break if d.size == 0\n    t = (d.shift - distance) / U\n    distance += t * U\n    time += t\n    boost = 1\n    b_time = T\n  when 1\n    distance += V\n    b_time -= 1\n    time += 1.0\n    boost = 0 if b_time == 0\n    if d.size > 0\n      if distance - d[0] >= 0 && distance - d[0] <= V\n        stock += 1 if stock < K\n      end\n    end\n  end\n  if boost == 0 && stock > 0\n    d.shift\n    boost = 1\n    b_time = T\n    stock -= 1\n  end\nend\n\ntime += (L - distance) / U\nputs sprintf(\"%.9f\", time)"
  },
  {
    "language": "Ruby",
    "code": "N, K, T, U, V, L = gets.split.map(&:to_f)\nstock = 0\nrestTime = 0.0\ntime = 0.0\ndistance = 0.0\nN.to_i.times do\n  d = gets.to_f\n  if restTime > 0.0 || stock > 0\n    t = (d - distance) / V\n    while true do\n      break if restTime >= t || stock == 0\n      restTime += T\n      stock -= 1\n    end\n    if restTime >= t\n      restTime -= t\n      time += t\n    else\n      time += restTime\n      time += (d - distance - V * restTime) / U\n      restTime = 0.0\n    end\n    distance = d\n  else\n    time += (d - distance) / U\n    distance = d\n  end\n  if stock < K\n    stock += 1\n  else\n    restTime = T\n  end\nend\n\nif restTime > 0.0 || stock > 0\n  t = (L - distance) / V\n  while true do\n    break if restTime > t || stock == 0\n    restTime += T\n    stock -= 1\n  end\n  if restTime >= t\n    restTime -= t\n    time += t\n  else\n    time += restTime\n    time += (L - distance - V * restTime) / U\n    restTime = 0.0\n  end\n  distance = L\nelse\n  time += (L - distance) / U\n  distance = L\nend\n\np time"
  },
  {
    "language": "Ruby",
    "code": "n, k, t, u, v, l = gets.split.map &:to_f\nk = k.to_i\ncarrots = (1..n.to_i).map{gets.to_i}\ncarrots << l\n\nx = 0\nc = 0\naccel = 0\ntime = 0\n\ncarrots.each{|d|\n\tif x + accel * v >= d\n\t\tdt = (d - x) / v\n\t\ttime += dt\n\t\taccel -= dt\n\t\tx = d\n\t\tif c == k\n\t\t\taccel = t\n\t\telse\n\t\t\tc += 1\n\t\tend\n\telse\n\t\tx += accel * v\n\t\ttime += accel \n\t\tif c == 0\n\t\t\ttime += (d - x) / u\n\t\t\tx = d\n\t\t\tc = 1\n\t\telse\n\t\t\tif x + c * t * v >= d\n\t\t\t\tused = ((d - x) / (t * v)).ceil\n\t\t\t\tc -= used - 1\n\t\t\t\tdt = (d - x) / v\n\t\t\t\ttime += dt\n\t\t\t\tx = d\n\t\t\t\taccel = used * t - dt\n\t\t\telse\n\t\t\t\tx += c * t * v\n\t\t\t\ttime += c * t\n\t\t\t\ttime += (d - x) / u\n\t\t\t\tx = d\n\t\t\t\tc = 1\n\t\t\tend\n\t\tend\n\tend\n}\n\np time"
  },
  {
    "language": "Ruby",
    "code": "N, K, T, U, V, L = gets.split.map(&:to_f)\n\ntime = 0.0\ndistance = 0.0\nstock = 0\nrestTime = 0.0\nN.to_i.times do\n  d = gets.to_f\n  t = (d - distance) / V\n  while true do\n    break if restTime >= t || stock == 0\n    restTime += T\n    stock -= 1\n  end\n  if restTime >= t\n    restTime -= t\n    time += t\n  else\n    time += restTime\n    time += (d - distance - V * restTime) / U\n    restTime = 0.0\n  end\n  distance = d\n\n  if stock < K\n    stock += 1\n  else\n    restTime = T\n  end\nend\n\nt = (L - distance) / V\nwhile true do\n  break if restTime > t || stock == 0\n  restTime += T\n  stock -= 1\nend\nif restTime >= t\n  restTime -= t\n  time += t\nelse\n  time += restTime\n  time += (L - distance - V * restTime) / U\n  restTime = 0.0\nend\ndistance = L\n\np time"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct E {\n    double dist;\n    int type; // 0: K++, 1: K--\n}\n\nvoid main() {\n    const INF = 1e9;\n    int N, K, T, U, V, L;\n    scanf(\"%d %d %d %d %d %d\\n\", &N, &K, &T, &U, &V, &L);\n    auto D = new double[N + 1];\n    D[N] = L;\n    foreach (i; 0 .. N) scanf(\"%lf\\n\", &D[i]);\n    int rK = 0;\n    int i = 0;\n    double time = 0;\n    double dist = 0;\n    double ndist = INF; // 繝九Φ繧ク繝ウ蛻?ｌdistance\n    bool fast = false;\n    while (true) {\n        //writeln([i, dist, ndist, time, rK]);\n        if (!fast) {\n            assert(rK == 0);\n            time += (D[i] - dist) / U;\n            dist = D[i];\n            if (i == N) break;\n            i++;\n            fast = true;\n            ndist = dist + V * T;\n        } else if (D[i] < ndist) {\n            time += (D[i] - dist) / V;\n            dist = D[i];\n            if (i == N) break;\n            i++;\n            if (rK == K) {\n                ndist = dist + V * T;\n            } else {\n                rK++;\n            }\n        } else {\n            time += (ndist - dist) / V;\n            dist = ndist;\n            if (rK == 0) {\n                fast = false;\n            } else {\n                rK--;\n                ndist = dist + V * T;\n            }\n        }\n    }\n    writefln(\"%.10f\", time);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct E {\n    double dist;\n    int type; // 0: K++, 1: K--\n}\n\nvoid main() {\n    const INF = 1e9;\n    int N, K, T, U, V, L;\n    scanf(\"%d %d %d %d %d %d\\n\", &N, &K, &T, &U, &V, &L);\n    auto D = new double[N + 1];\n    D[N] = L;\n    foreach (i; 0 .. N) scanf(\"%lf\\n\", &D[i]);\n    int rK = 0;\n    int i = 0;\n    double time = 0;\n    double dist = 0;\n    double ndist = INF; // 繝九Φ繧ク繝ウ蛻?ｌdistance\n    bool fast = false;\n    while (true) {\n        //writeln([i, dist, ndist, time, rK]);\n        if (!fast) {\n            assert(rK == 0);\n            time += (D[i] - dist) / U;\n            dist = D[i];\n            if (i == N) break;\n            i++;\n            fast = true;\n            ndist = dist + V;\n        } else if (D[i] < ndist) {\n            time += (D[i] - dist) / V;\n            dist = D[i];\n            if (i == N) break;\n            i++;\n            if (rK == K) {\n                ndist = dist + V;\n            } else {\n                rK++;\n            }\n        } else {\n            time += (ndist - dist) / V;\n            dist = ndist;\n            if (rK == 0) {\n                fast = false;\n            } else {\n                rK--;\n                ndist = dist + V;\n            }\n        }\n    }\n    writefln(\"%.10f\", time);\n}"
  },
  {
    "language": "Python",
    "code": "N,K,T,U,V,L = map(int,raw_input().split())\nR = [0]*L\nD = [int(raw_input()) for i in range(N)]\ndash = have = dashL = 0\nfor i in range(L):\n\tif i == dashL:\n\t\tif have == 0:\n\t\t\tdash = 0\n\t\telse:\n\t\t\tdashL = i + V*T\n\t\t\thave -= 1\n\tif i in D:\n\t\tif dash and have < K:\n\t\t\thave += 1\n\t\telse:\n\t\t\tdashL = i + V*T\n\t\t\tdash = 1\n\tif dash:\n\t\tR[i] = 1\nprint R.count(0)*1.0/U + R.count(1)*1.0/V"
  },
  {
    "language": "Python",
    "code": "carrot,maxstock,duration,normal,fast,goal = ((int(n) for n in input().split(\" \")))\nstack,used = [],0\nfor c in range(carrot):\n    newcar = int(input())\n    stack = list(filter(lambda x:x>newcar,stack))\n    if len(stack) == 0:\n        stack.append(newcar + (fast * duration))\n        used += fast*duration\n    elif stack[-1] >= goal:\n        used += stack[-1] - goal\n        break\n    else:\n        if len(stack) == maxstock + 1:\n            used += fast*duration - (stack[0]-newcar)\n            stack = list(map(lambda x:x+(fast*duration - (stack[0]-newcar)),stack))\n        else:\n            stack.append(stack[-1]+fast * duration)\n            used += fast*duration\nprint((goal - used) / normal + used / fast)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,k,t,u,v,l = LI()\n    d = [I() for _ in range(n)] + [l]\n    cd = ck = ct = 0\n    r = 0\n    for di in d:\n        while ct < di and ck > 0:\n            ct += t * v\n            ck -= 1\n        if ct >= di:\n            r += (di - cd) / v\n        else:\n            r += (ct - cd) / v\n            r += (di - ct) / u\n            ct = di\n        ck += 1\n        if ck > k:\n            ck = k\n            ct = di + t * v\n        cd = di\n\n    return '{:0.9f}'.format(r)\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "N, K, T, U, V, L = map(int, input().split())\nans = 0\nl = 0\nt = 0\nk = 0\nfor _ in range(N + 1):\n    if _ == N:\n        d = L\n    else:\n        d = int(input())\n    length = d - l\n    l = d\n    while t > 0 or k > 0:\n        if t > 0:\n            if t * V >= length:\n                tmp = (t * V - length) / V\n                ans += t - tmp\n                t = tmp\n                if K > k:\n                    k += 1\n                else:\n                    t = T\n                length = 0\n                break\n            else:\n                length = length - t * V\n                ans += t\n                t = 0\n                if k > 0:\n                    k -= 1\n                    t = T\n        if k > 0:\n            k -= 1\n            t = T\n    ans += length / U\n    if K > k:\n        k += 1\n    else:\n        t = T\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N, K, T, U, V, L = map(int, input().split())\nans = 0\nl = 0\nt = 0\nk = 0\nfor _ in range(N + 1):\n    print(ans, l, t, k)\n    if _ == N:\n        d = L\n    else:\n        d = int(input())\n    length = d - l\n    l = d\n    while t > 0 or k > 0:\n        if t > 0:\n            if t * V >= length:\n                tmp = (t * V - length) / V\n                ans += t - tmp\n                t = tmp\n                if K > k:\n                    k += 1\n                else:\n                    t = T\n                length = 0\n                break\n            else:\n                length = length - t * V\n                ans += t\n                t = 0\n                if k > 0:\n                    k -= 1\n                    t = T\n        elif k > 0:\n            k -= 1\n            t = T\n    if length > 0:\n        ans += length / U\n        if K > k:\n            k += 1\n        else:\n            t = T\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n,k,t,u,v,l = map(int,input().split())\n\ntime = 0\nline = [0 for _ in range(l)]\ncarrots_line = [0 for _ in range(l)]\nboost = False\ncarrots = 0\nboost_dist = 0\n\nfor _ in range(n):\n    carrots_line[int(input())-1] = 1\n\nfor i in range(l):\n    if boost:\n        line[i] = 1\n        boost_dist -= 1\n    else:\n        pass\n\n    if boost_dist == 0:\n        if carrots_line[i] == 1:\n            boost_dist = v*t\n            boost = True\n        else:\n            if carrots > 0:\n                carrots -= 1\n                boost_dist = v*t\n                boost = True\n            else:\n                boost = False\n    else:\n        if carrots_line[i] == 1:\n            carrots = min(carrots+1, k)\n            boost_dist = v*t\n        boost = True\n\nboost_run = sum(line)\n\nans = boost_run / v + (l - boost_run) / u\n\nprint(ans)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "n,k,t,u,v,l = map(int,input().split())\nD = []\nfor i in range(n):\n    d = int(input())\n    D.append(d)\nA = [0]*l\nspecial = 0\nnomal = 0\nninzin = 0\n\nfor i in range(l):\n    if i == special:\n        if ninzin == 0:\n            nomal = 0\n        else:\n            special = i + v*t\n            ninzin = ninzin-1\n    if i in D:\n        if nomal != 0 and ninzin < k:\n            ninzin += 1\n        else:\n            special = i + v*t\n            nomal += 1\n    if nomal != 0:\n        A[i] = 1\nprint(A.count(0)/u + A.count(1)/v)\n"
  },
  {
    "language": "Python",
    "code": "N,K,T,U,V,L = map(int,raw_input().split())\nVT = V*T\nD = [int(raw_input()) for i in range(N)]\nif D[-1] != L: D.append(L)\nX = D[0]\nQ = D[0] + VT\ni,k = 1,0\nwhile i < len(D):\n\tif D[i] == Q:\n\t\tQ += VT\n\t\ti += 1\n\telif D[i] < Q:\n\t\tif k == K:\n\t\t\tQ = D[i] + VT\n\t\telse:\n\t\t\tk += 1 \n\t\ti += 1\n\telse:\n\t\tif k > 0:\n\t\t\tQ += VT\n\t\t\tk -= 1\n\t\telse:\n\t\t\tX += D[i] - Q\n\t\t\tQ = D[i]\n\t\t\ti += 1\nprint X*1.0/U + (L-X)*1.0/V"
  },
  {
    "language": "Python",
    "code": "carrot,maxstock,duration,normal,fast,goal = ((int(n) for n in input().split(\" \")))\nstack,used = [],0\nfor c in range(carrot):\n    newcar = int(input())\n    stack = list(filter(lambda x:x>newcar,stack))\n    \n    if len(stack) == 0:\n        stack.append(newcar + (fast * duration))\n        used += fast*duration\n    else:\n        if len(stack) == maxstock + 1:\n            used += fast*duration - (stack[0]-newcar)\n            stack = list(map(lambda x:x+(fast*duration - (stack[0]-newcar)),stack))\n            \n            print(used)\n        else:\n            stack.append(stack[-1]+fast * duration)\n            used += fast*duration\nif stack[-1] > goal:\n    used -= stack[-1] - goal\nprint((goal - used) / normal + used / fast)"
  },
  {
    "language": "Python",
    "code": "n,k,t,u,v,l = map(int,input().split())\n\ntime = 0\nline = [0 for _ in range(l)]\ncarrots_line = [0 for _ in range(l)]\nboost = False\ncarrots = 0\nboost_dist = 0\n\nfor _ in range(n):\n    carrots_line[int(input())-1] = 1\n\nfor i in range(l):\n    if boost:\n        line[i] = 1\n        boost_dist -= 1\n    else:\n        pass\n\n    if boost_dist == 0:\n        if carrots_line[i] == 1:\n            boost_dist = v*t\n            boost = True\n        else:\n            if carrots > 0:\n                carrots -= 1\n                boost_dist = v*t\n                boost = True\n            else:\n                boost = False\n    else:\n        if carrots_line[i] == 1:\n            carrots = min(carrots+1, k)\n            boost_dist = v*t\n        boost = True\n\nboost_run = sum(line)\n\nans = boost_run / v + (l - boost_run) / u\n\nprint(ans)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "N,K,T,U,V,L = map(int,raw_input().split())\nVT = V*T\nD = [int(raw_input()) for i in range(N)] + [L]\nX = D[0]\nQ = D[0] + VT\ni,k = 1,0\nwhile i < N + 1:\n\tif D[i] == Q:\n\t\tQ += VT\n\t\ti += 1\n\telif D[i] < Q:\n\t\tif k == K:\n\t\t\tQ = D[i] + VT\n\t\telse:\n\t\t\tk += 1 \n\t\ti += 1\n\telse:\n\t\tif k > 0:\n\t\t\tQ += VT\n\t\t\tk -= 1\n\t\telse:\n\t\t\tX += D[i] - Q\n\t\t\tQ = D[i]\n\t\t\ti += 1\nprint X*1.0/U + (L-X)*1.0/V"
  },
  {
    "language": "Python",
    "code": "N, K, T, U, V, L = map(int, input().split())\nans = 0\nl = 0\nt = 0\nk = 0\nfor _ in range(N + 1):\n    if _ == N:\n        d = L\n    else:\n        d = int(input())\n    length = d - l\n    l = d\n    if t != 0:\n        if t * V > length:\n            tmp = (t * V - length) / V\n            ans += t - tmp\n            t = tmp\n            if K > k:\n                k += 1\n            else:\n                t = T\n            continue\n        else:\n            length = length - t * V\n            ans += t\n            t = 0\n    if k != 0:\n        k -= 1\n        t = T\n        if t * V > length:\n            tmp = (t * V - length) / V\n            ans += t - tmp\n            t = tmp\n            if K > k:\n                k += 1\n            else:\n                t = T\n            continue\n        else:\n            length = length - t * V\n            ans += t\n            t = 0\n    ans += length / U\n    if K > k:\n        k += 1\n    else:\n        t = T\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N, K, T, U, V, L = map(int, input().split())\nans = 0\nl = 0\nt = 0\nk = 0\nfor _ in range(N + 1):\n    if _ == N:\n        d = L\n    else:\n        d = int(input())\n    length = d - l\n    l = d\n    while t > 0 or k > 0:\n        if t > 0:\n            if t * V >= length:\n                tmp = (t * V - length) / V\n                ans += t - tmp\n                t = tmp\n                if K > k:\n                    k += 1\n                else:\n                    t = T\n                length = 0\n                break\n            else:\n                length = length - t * V\n                ans += t\n                t = 0\n                if k > 0:\n                    k -= 1\n                    t = T\n        elif k > 0:\n            k -= 1\n            t = T\n    if length > 0:\n        ans += length / U\n        if K > k:\n            k += 1\n        else:\n            t = T\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# your code goes he\n#carrot 22 2298\nN,K,T,U,V,L=(int(i) for i in input().split())\n#r=int(input())\ns=0\nc=0\nh=0\nTV=T*V\nD=[int(input()) for i in range(N)]\nD.append(L)\nr=D[0]\nfor i in range(N):\n    h+=1\n    if h>K:\n        h-=1\n        c=TV\n    Ds=D[i+1]-D[i]\n    if c>0:\n        if Ds>c:\n            Ds-=c\n            s+=c\n            c=0\n        else:\n            c-=Ds\n            s+=Ds\n            Ds=0\n    while Ds>0 and h>0:\n        h-=1\n        if Ds>TV:\n            Ds-=TV\n            s+=TV\n        else:\n            c=TV-Ds\n            s+=Ds\n            Ds=0\n    if Ds>0:\n        r+=Ds\nr/=U\ns/=V\nprint(r+s)"
  },
  {
    "language": "Python",
    "code": "n,k,t,u,v,l = map(int,input().split())\n\ntime = 0\nline = [0 for _ in range(l)]\ncarrots_line = [0 for _ in range(l)]\nboost = False\ncarrots = 0\nboost_dist = 0\n\nfor _ in range(n):\n    carrots_line[int(input())-1] = 1\n\nfor i in range(l):\n    if boost:\n        line[i] = 1\n        boost_dist -= 1\n    else:\n        pass\n\n    if boost_dist == 0:\n        if carrots_line[i] == 1:\n            boost_dist = v*t\n            boost = True\n        else:\n            if carrots > 0:\n                carrots -= 1\n                boost_dist = v*t\n                boost = True\n            else:\n                boost = False\n    else:\n        if carrots_line[i] == 1:\n            carrots = min(carrots+1, k)\n            boost_dist = v*t\n        boost = True\n\nboost_run = sum(line)\n\nans = boost_run / v + (l - boost_run) / u\n\nprint(ans)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nEPS = 1e-12\n\ndef main():\n    n,k,t,u,v,l = map(int, sys.stdin.readline().split())\n    carrots = [0] * 10001\n    for i in range(n):\n        carrots[ int(sys.stdin.readline()) ] = 1\n\n    remain_time  = 0\n    carrot_count = 0\n    ans = 0\n    for i in range(1,l + 1):\n        #print(\"kyori:{}\\tremain_time:{}\\tcarrot_count:{}\\tans:{}\".format(i,remain_time,carrot_count,ans))\n        # ???????????????????????????????????????\n        if carrots[i] == 1:\n            carrot_count += 1\n        # ?????????????¶?????????????????????????\n        if carrot_count > k:\n            remain_time = t\n            carrot_count -= 1\n\n        if remain_time > 0 + EPS:\n            # ????????????????????£???????????¶???\n            if remain_time * v >= 1.0:\n                ans += 1 / v\n                remain_time -= 1 / v\n            else:\n                if carrot_count > 0:\n                    ans += 1 / v\n                    carrot_count -= 1\n                    remain_time = t - (1 - (remain_time * v)) / v\n                else:\n                    ans += remain_time\n                    ans += (1 - (remain_time * v)) / u\n                    remain_time = 0\n        else:\n            remain_time = 0\n            # ????????????????????£???????????¶???\n            if carrot_count > 0:\n                ans += 1 / v\n                carrot_count -= 1\n                remain_time = t - 1 / v\n            else:\n                ans += 1 / u\n\n    print(\"{:.9f}\".format(ans))\n\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "carrot,maxstock,duration,normal,fast,goal = ((int(n) for n in input().split(\" \")))\nstack,used = [],0\nfor c in range(carrot):\n    newcar = int(input())\n    stack = list(filter(lambda x:x>newcar,stack))\n    \n    if len(stack) == 0:\n        stack.append(newcar + (fast * duration))\n        used += fast*duration\n    else:\n        if len(stack) == maxstock + 1:\n            used += fast*duration - (stack[0]-newcar)\n            stack = list(map(lambda x:x+(fast*duration - (stack[0]-newcar)),stack))\n        else:\n            stack.append(stack[-1]+fast * duration)\n            used += fast*duration\nif stack[-1] > goal:\n    used -= stack[-1] - goal\nprint((goal - used) / normal + used / fast)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    n, k, t, u, v, l = MI()\n    hp = []\n    # (位置、イベントの種類、時間)として、ヒープに突っ込んでいく\n    # イベントの種類は　\n    # 0 ゴールする\n    # 1 ニンジン効果終わる（+食べる）\n    # 2 ニンジン拾う（+食べる）　\n    # 時間が必要なのは1番だけで他のイベントの時は-1を突っ込んである\n    heappush(hp, (l, 0, -1))\n    for _ in range(n):\n        d = int(input())\n        heappush(hp, (d, 2, -1))\n    # 「最後に速さが変わった時間、位置」と「ニンジンの数」\n    time = pos = caro_n = 0\n    # ニンジン効果中ならTrue\n    boost = False\n    cancel=deque()\n    while hp:\n        here, e, now = heappop(hp)\n        if e == 2:\n            if boost:\n                if caro_n==k:\n                    cancel.append(pos+v*t)\n                    time += (here - pos) / v\n                    pos=here\n                    heappush(hp, (here + v * t, 1, time + t))\n                else:\n                    caro_n += 1\n            else:\n                time += (here - pos) / u\n                pos = here\n                boost = True\n                heappush(hp, (here + v * t, 1, time + t))\n        if e == 1:\n            if cancel and here==cancel[0]:\n                cancel.popleft()\n                continue\n            if caro_n:\n                pos=here\n                time=now\n                caro_n -= 1\n                heappush(hp, (here + v * t, 1, now + t))\n            else:\n                time = now\n                pos = here\n                boost = False\n        if e == 0:\n            uv = v if boost else u\n            print(time + (l - pos) / uv)\n            exit()\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "N, K, T, U, V, L = map(int, input().split())\nDlist = []\nfor i in range(N):\n    Dlist.append(int(input()))\n\nt = 0       # 経過時間\nv = U       # 速度（初期値はU）\ntimer = 0\nSto = 0     # 手持ちのにんじん\n\nfor i in range(1,L+1):\n    t += 1/v\n    if v==V:\n        timer += 1/v\n    if i in Dlist:\n        Sto += 1\n        if v==U:\n            v = V\n            Sto -= 1\n            timer = 0\n        elif timer<T:\n            if Sto>K:\n                Sto -= 1\n                timer = 0\n        elif Sto>0:\n            Sto -= 1\n            timer = 0\n        else:\n            v = U\n    else:\n        if v==V:\n            if Sto>0 and timer>T-1/V:\n                v = V\n                timer = 0\n                Sto -= 1\n            elif Sto==0:\n                if timer>T-1/V:\n                    v = U\nprint(f'{t:.9f}')\n"
  },
  {
    "language": "Python",
    "code": "N,K,T,U,V,L = map(int,raw_input().split())\nR = [0]*L\nD = [int(raw_input()) - 1 for i in range(N)]\ndash = have = dashL = 0\nfor i in range(L):\n\tif i == dashL:\n\t\tif have == 0:\n\t\t\tdash = 0\n\t\telse:\n\t\t\tdashL = i + V*T\n\t\t\thave -= 1\n\tif i in D:\n\t\tif dash and have < K:\n\t\t\thave += 1\n\t\telse:\n\t\t\tdashL = i + V*T\n\t\t\tdash = 1\n\tif dash:\n\t\tR[i] = 1\nprint R.count(0)*1.0/U + R.count(1)*1.0/V"
  },
  {
    "language": "Python",
    "code": "def get_carrot() :\n    global speed, stock, U, K, i, T, accel_time\n    if speed == U :\n        speed = V\n        accel_time = T\n    elif stock == K :\n        accel_time = T\n    else :\n        stock += 1\n    i += 1\n\ndef accel_time_end() :\n    global stock, accel_time, T, U, speed\n    if stock > 0 :\n        accel_time += T\n        stock -= 1\n    else :\n        speed = U\n\nN, K, T, U, V, L = map(int, input().split())\ncarrot=[]\nfor i in range(N) :\n    carrot.append(int(input()))\n\nstock = 0\ntime = 0\naccel_time = 0\ni = 0\nspeed = U\nnow = 0\n\nwhile True :\n    if i < N :\n        if accel_time == 0 :\n            time += (carrot[i] - now) / speed\n            now = carrot[i]\n            get_carrot()\n            \n        elif (carrot[i] - now) < accel_time * speed :\n            time_tmp = (carrot[i] - now) / speed\n            time += time_tmp\n            accel_time -= time_tmp\n            now = carrot[i]\n            get_carrot()\n        \n        elif accel_time * speed < (carrot[i] - now) :\n            now += accel_time * speed\n            time += accel_time\n            accel_time = 0\n            accel_time_end()\n        \n        elif  accel_time * speed == (carrot[i] - now) :\n            now = carrot[i]\n            time += accel_time\n            accel_time = 0\n            accel_time_end()\n            get_carrot()\n        \n    else :\n        if ( accel_time * speed < L - now ) and accel_time != 0:\n            now += accel_time * speed\n            time += accel_time\n            accel_time = 0\n            accel_time_end()\n        else :\n            time += (L - now) / speed\n            now += (L - now)\n            print('{:.10f}'.format(time))\n            break\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nEPS = 1e-12\n\ndef main():\n    n,k,t,u,v,l = map(int, sys.stdin.readline().split())\n    carrots = [0] * 10001\n    for i in range(n):\n        carrots[ int(sys.stdin.readline()) ] = 1\n\n    remain_time  = 0\n    carrot_count = 0\n    ans = 0\n    for i in range(0,l):\n        #print(\"kyori:{}\\tremain_time:{}\\tcarrot_count:{}\\tans:{}\".format(i,remain_time,carrot_count,ans))\n        # ???????????????????????????????????????\n        if carrots[i] == 1:\n            carrot_count += 1\n        # ?????????????¶?????????????????????????\n        if carrot_count > k:\n            remain_time = t\n            carrot_count -= 1\n\n        if remain_time > 0 + EPS:\n            # ????????????????????£???????????¶???\n            if remain_time * v >= 1.0:\n                ans += 1 / v\n                remain_time -= 1 / v\n            else:\n                if carrot_count > 0:\n                    ans += 1 / v\n                    carrot_count -= 1\n                    remain_time = t - (1 - (remain_time * v)) / v\n                else:\n                    ans += remain_time\n                    ans += (1 - (remain_time * v)) / u\n                    remain_time = 0\n        else:\n            remain_time = 0\n            # ????????????????????£???????????¶???\n            if carrot_count > 0:\n                ans += 1 / v\n                carrot_count -= 1\n                remain_time = t - 1 / v\n            else:\n                ans += 1 / u\n\n    print(\"{:.9f}\".format(ans))\n\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "n,k,t,u,v,l = map(int,input().split())\n\ntime = 0\nline = [0 for _ in range(l)]\ncarrots_line = [0 for _ in range(l)]\nboost = False\ncarrots = 0\nboost_dist = 0\n\nfor _ in range(n):\n    carrots_line[int(input())-1] = 1\n\nfor i in range(l):\n    if boost:\n        line[i] = 1\n        boost_dist -= 1\n    else:\n        pass\n\n    if boost_dist == 0:\n        if carrots_line[i] == 1:\n            boost_dist = v*t\n            boost = True\n        else:\n            if carrots > 0:\n                carrots -= 1\n                boost_dist = v*t\n                boost = True\n            else:\n                boost = False\n    else:\n        if carrots_line[i] == 1:\n            if carrots+1 > k:\n                boost_dist = v*t\n            else:\n                carrots += 1\n        boost = True\n\nboost_run = sum(line)\n\nans = boost_run / v + (l - boost_run) / u\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n,k,t,u,v,l,*d=map(int,open(0).read().split())\nans = d[0]/u\nfin = d[0]\nfastend = d[0] + v*t\nstack = 0\nfor now in d[1:]:\n    while stack and fastend < now:\n        ans += (fastend - fin)/v\n        fin = fastend\n        fastend += v*t\n        stack -=1\n    if fastend < now:\n        ans += (fastend - fin)/v + (now - fastend)/u\n        fin = now\n        fastend = now + v*t\n    elif fastend == now:\n        ans += (fastend - fin)/v\n        fin = now\n        fastend = now + v*t\n    elif stack == k:\n        ans += (now - fin)/v\n        fin = now\n        fastend = now + v*t\n    else:\n        stack += 1\nwhile stack and fastend <= l:\n    ans += (fastend - fin)/v\n    fin = fastend\n    fastend += v*t\n    stack -= 1\nif fastend > l:\n    print(ans + (l - fin)/v)\nelse:\n    ans += (fastend - fin)/v\n    fin = fastend\n    print(ans + (l - fin)/u)\n"
  }
]