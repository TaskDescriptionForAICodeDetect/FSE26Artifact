[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int pos;\n    int time;\n} State;\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint main() {\n    int N, M, K, U, V, T, P;\n    scanf(\"%d %d %d %d %d %d %d\", &N, &M, &K, &U, &V, &T, &P);\n    \n    int *carrots = (int *)malloc(M * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &carrots[i]);\n    }\n    \n    qsort(carrots, M, sizeof(int), compare);\n    \n    State *queue = (State *)malloc((M + 1) * sizeof(State));\n    int front = 0, rear = 0;\n    queue[rear].pos = 0;\n    queue[rear].time = 0;\n    rear++;\n    \n    int min_time = N * U;\n    \n    while (front < rear) {\n        State current = queue[front++];\n        \n        int time_without = current.time + (N - current.pos) * U;\n        if (time_without < min_time) {\n            min_time = time_without;\n        }\n        \n        if (current.pos >= N) {\n            continue;\n        }\n        \n        for (int i = 0; i < M; i++) {\n            if (carrots[i] > current.pos && (rear == 0 || carrots[i] > queue[rear - 1].pos)) {\n                int new_pos = current.pos + (carrots[i] - current.pos) * U;\n                int new_time = current.time + (carrots[i] - current.pos) * U;\n                \n                if (new_pos >= N) {\n                    if (new_time < min_time) {\n                        min_time = new_time;\n                    }\n                    continue;\n                }\n                \n                int boost_end = new_time + T;\n                int boost_pos = new_pos + V * T;\n                \n                if (boost_pos >= N) {\n                    int final_time = new_time + (N - new_pos) / V;\n                    if (final_time < min_time) {\n                        min_time = final_time;\n                    }\n                    continue;\n                }\n                \n                if (rear < M + 1) {\n                    queue[rear].pos = boost_pos;\n                    queue[rear].time = boost_end;\n                    rear++;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", min_time);\n    \n    free(carrots);\n    free(queue);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct Carrot {\n    int pos;\n    bool operator<(const Carrot& other) const {\n        return pos < other.pos;\n    }\n};\n\nint main() {\n    int L, N, K, U, V, T;\n    cin >> L >> N >> K >> U >> V >> T;\n    \n    vector<Carrot> carrots(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> carrots[i].pos;\n    }\n    sort(carrots.begin(), carrots.end());\n    \n    priority_queue<int> available_times;\n    available_times.push(0);\n    \n    double time = 0;\n    double pos = 0;\n    int carrot_idx = 0;\n    priority_queue<int, vector<int>, greater<int>> active_boosts;\n    \n    while (pos < L) {\n        while (!active_boosts.empty() && active_boosts.top() <= time) {\n            active_boosts.pop();\n        }\n        \n        int current_speed = active_boosts.empty() ? U : V;\n        \n        double next_event_time = time + (L - pos) / current_speed;\n        double next_carrot_time = (carrot_idx < N) ? time + (carrots[carrot_idx].pos - pos) / current_speed : next_event_time;\n        double next_boost_end = active_boosts.empty() ? next_event_time : active_boosts.top();\n        \n        double delta_time = min({next_event_time, next_carrot_time, next_boost_end}) - time;\n        pos += delta_time * current_speed;\n        time += delta_time;\n        \n        if (pos >= L) break;\n        \n        if (fabs(pos - carrots[carrot_idx].pos) < 1e-9 && carrot_idx < N) {\n            available_times.push(time + T);\n            carrot_idx++;\n        }\n        \n        if (!active_boosts.empty() && fabs(time - active_boosts.top()) < 1e-9) {\n            continue;\n        }\n        \n        if (!available_times.empty() && (active_boosts.size() < K || (active_boosts.size() == K && available_times.top() > (active_boosts.empty() ? 0 : active_boosts.top())))) {\n            if (active_boosts.size() == K) {\n                active_boosts.pop();\n            }\n            active_boosts.push(available_times.top());\n            available_times.pop();\n        }\n    }\n    \n    cout.precision(10);\n    cout << fixed << time << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int K = sc.nextInt();\n        int T = sc.nextInt();\n        int U = sc.nextInt();\n        int V = sc.nextInt();\n        int L = sc.nextInt();\n\n        int[] D = new int[M + 2];\n        for (int i = 1; i <= M; i++) {\n            D[i] = sc.nextInt();\n        }\n        D[M + 1] = L;\n        Arrays.sort(D);\n\n        double time = 0.0;\n        int boostEnd = 0;\n        Queue<Integer> carrots = new LinkedList<>();\n\n        for (int i = 1; i <= M + 1; i++) {\n            int distance = D[i] - D[i - 1];\n            if (boostEnd > D[i - 1]) {\n                int boostedPart = Math.min(boostEnd, D[i]) - D[i - 1];\n                time += (double) boostedPart / V;\n                int remaining = distance - boostedPart;\n                time += (double) remaining / U;\n            } else {\n                time += (double) distance / U;\n            }\n\n            while (!carrots.isEmpty() && carrots.peek() <= D[i]) {\n                carrots.poll();\n            }\n\n            if (carrots.size() < K) {\n                carrots.add(D[i] + T * V);\n                boostEnd = Math.max(boostEnd, D[i] + T * V);\n            }\n        }\n\n        System.out.printf(\"%.6f\\n\", time);\n    }\n}",
    "timestamp": "2025-08-05 21:21:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int INF = Integer.MAX_VALUE;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int L = Integer.parseInt(st.nextToken());  // Total path length\n        int U = Integer.parseInt(st.nextToken());  // Normal speed\n        int V = Integer.parseInt(st.nextToken());  // Boosted speed\n        int T = Integer.parseInt(st.nextToken());  // Boost duration\n        int K = Integer.parseInt(st.nextToken());  // Max carrots to hold\n\n        int N = Integer.parseInt(br.readLine());  // Number of carrots\n        int[] carrotPos = new int[N];\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            carrotPos[i] = Integer.parseInt(st.nextToken());\n        }\n\n        double[][] dp = new double[N + 1][K + 1];\n        for (int[] row : dp) Arrays.fill(row, INF);\n        dp[0][0] = 0;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= K; j++) {\n                if (dp[i][j] == INF) continue;\n\n                // Don't eat this carrot\n                if (j < K) {\n                    dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], \n                        dp[i][j] + (carrotPos[i] - (i > 0 ? carrotPos[i-1] : 0)) / (double)U);\n                }\n\n                // Eat this carrot\n                double boostTime = 0;\n                if (j > 0) {\n                    boostTime = T;\n                }\n\n                int remainingDist = L - carrotPos[i];\n                double remainingTime;\n                \n                if (boostTime > 0 && remainingDist > 0) {\n                    // Part of the distance with boosted speed\n                    double boostedDist = Math.min(remainingDist, boostTime * V);\n                    double normalDist = remainingDist - boostedDist;\n                    \n                    remainingTime = boostedDist / V + normalDist / U;\n                } else {\n                    remainingTime = remainingDist / (double)U;\n                }\n\n                dp[i + 1][j] = Math.min(dp[i + 1][j], \n                    dp[i][j] + (carrotPos[i] - (i > 0 ? carrotPos[i-1] : 0)) / (double)U + remainingTime);\n            }\n        }\n\n        double minTime = INF;\n        for (int j = 0; j <= K; j++) {\n            minTime = Math.min(minTime, dp[N][j]);\n        }\n\n        System.out.printf(\"%.6f\\n\", minTime);\n    }\n}",
    "timestamp": "2025-08-05 21:21:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int pos;\n    int speed_boost;\n} Carrot;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\ndouble solve(int L, int U, int V, int T, int K, Carrot carrots[], int N) {\n    double dp[MAX_N + 1][MAX_N + 1];\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= K; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n    dp[0][0] = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= K; j++) {\n            if (dp[i][j] == INT_MAX) continue;\n\n            // No carrot\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j] + (double)(carrots[i].pos - (i > 0 ? carrots[i-1].pos : 0)) / U);\n\n            // Take carrot if possible\n            if (j < K) {\n                dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + (double)(carrots[i].pos - (i > 0 ? carrots[i-1].pos : 0)) / U);\n            }\n        }\n    }\n\n    double best_time = INT_MAX;\n    for (int j = 0; j <= K; j++) {\n        double last_speed = (j > 0) ? V : U;\n        double remaining_dist = L - (N > 0 ? carrots[N-1].pos : 0);\n        double time_left = remaining_dist / last_speed;\n        \n        if (j > 0 && N > 0) {\n            time_left = min(time_left, T);\n        }\n        \n        best_time = min(best_time, dp[N][j] + time_left);\n    }\n\n    return best_time;\n}\n\nint main() {\n    int L, U, V, T, K, N;\n    Carrot carrots[MAX_N];\n\n    scanf(\"%d %d %d %d %d %d\", &L, &U, &V, &T, &K, &N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &carrots[i].pos);\n    }\n\n    double result = solve(L, U, V, T, K, carrots, N);\n    printf(\"%.10f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int pos;\n    int carrots;\n    double time;\n    int boost_remaining;\n    \n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\ndouble solve(int road_length, int U, int V, int T, int K, vector<int>& carrot_positions) {\n    priority_queue<State, vector<State>, greater<State>> pq;\n    vector<vector<vector<bool>>> visited(road_length + 1, \n        vector<vector<bool>>(K + 1, vector<bool>(T + 1, false)));\n    \n    pq.push({0, 0, 0.0, 0});\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        if (curr.pos == road_length) {\n            return curr.time;\n        }\n        \n        if (visited[curr.pos][curr.carrots][curr.boost_remaining]) \n            continue;\n        visited[curr.pos][curr.carrots][curr.boost_remaining] = true;\n        \n        double speed = (curr.boost_remaining > 0) ? V : U;\n        \n        for (int next_pos : carrot_positions) {\n            if (next_pos <= curr.pos) continue;\n            \n            double dist = next_pos - curr.pos;\n            double travel_time = dist / speed;\n            \n            if (curr.carrots < K) {\n                pq.push({\n                    next_pos, \n                    curr.carrots + 1, \n                    curr.time + travel_time, \n                    T\n                });\n            }\n        }\n        \n        int possible_pos = curr.pos + speed;\n        if (possible_pos > road_length) \n            possible_pos = road_length;\n        \n        double travel_time = (possible_pos - curr.pos) / speed;\n        \n        int new_boost = max(0, curr.boost_remaining - 1);\n        \n        pq.push({\n            possible_pos, \n            curr.carrots, \n            curr.time + travel_time, \n            new_boost\n        });\n    }\n    \n    return -1;\n}\n\nint main() {\n    int road_length, U, V, T, K, N;\n    \n    cin >> road_length >> U >> V >> T >> K >> N;\n    \n    vector<int> carrot_positions(N);\n    for (int i = 0; i < N; i++) {\n        cin >> carrot_positions[i];\n    }\n    \n    sort(carrot_positions.begin(), carrot_positions.end());\n    \n    double result = solve(road_length, U, V, T, K, carrot_positions);\n    \n    printf(\"%.6f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_time_to_reach_goal(distance, U, V, T, K, carrot_positions):\n    carrot_positions.sort()  # Sort positions of the carrots along the path\n    dp = [(0, 0)]  # (time taken, carrot count) for each reachable position\n    eat_last_time = [-float('inf')] * (distance + 1)\n\n    for i in range(1, distance + 1):\n        dp.append((dp[i-1][0] + 1/U, dp[i-1][1]))  # Running at speed U\n        \n        if dp[i][1] > 0:\n            # Consider if it was possible to continue with boost V\n            boost_time = eat_last_time[i-1] + T\n            regular_time = dp[i][0]\n\n            if boost_time >= regular_time - 1/U:\n                dp[i] = (dp[i-1][0] + 1/V, dp[i-1][1])\n            else:\n                dp[i] = min(dp[i], (dp[i-1][0] + 1/V, dp[i-1][1]))\n\n        if i in carrot_positions and dp[i][1] < K:\n            # Possibility to pick up the carrot\n            dp[i] = min(dp[i], (dp[i][0], dp[i][1] + 1))\n\n        if dp[i][1] > 0:\n            # Track the time to eat a carried carrot to gain V boost\n            eat_last_time[i] = min(eat_last_time[i], dp[i][0])\n\n    return dp[distance][0]\n\n# Example usage\ndistance = 100\nU = 10\nV = 15\nT = 5\nK = 3\ncarrot_positions = [20, 40, 60, 80]\n\nprint(min_time_to_reach_goal(distance, U, V, T, K, carrot_positions))",
    "timestamp": "2025-08-13 06:06:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RabbitTraining {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int L = scanner.nextInt();      // Length of the path\n        int U = scanner.nextInt();      // Normal speed\n        int V = scanner.nextInt();      // Accelerated speed\n        int T = scanner.nextInt();      // Time for accelerated speed\n        int K = scanner.nextInt();      // Maximum carrots the rabbit can hold\n        int N = scanner.nextInt();      // Number of carrots\n        \n        int[] carrotPositions = new int[N];\n        for (int i = 0; i < N; i++) {\n            carrotPositions[i] = scanner.nextInt();\n        }\n        \n        scanner.close();\n        \n        System.out.println(minimizeTime(L, U, V, T, K, carrotPositions));\n    }\n    \n    private static double minimizeTime(int L, int U, int V, int T, int K, int[] carrotPositions) {\n        int currentPos = 0;\n        double totalTime = 0.0;\n        Queue<Integer> carrotsEatenTimestamps = new LinkedList<>();\n        \n        for (int carrot : carrotPositions) {\n            if (currentPos >= L) break;\n            \n            while (!carrotsEatenTimestamps.isEmpty() && totalTime >= carrotsEatenTimestamps.peek() + T) {\n                carrotsEatenTimestamps.poll();\n            }\n            \n            int currentSpeed = (carrotsEatenTimestamps.size() > 0) ? V : U;\n            \n            double timeToNextCarrot = (carrot - currentPos) / (double) currentSpeed;\n            totalTime += timeToNextCarrot;\n            currentPos = carrot;\n            \n            carrotsEatenTimestamps.add(totalTime);\n            \n            while (carrotsEatenTimestamps.size() > K) {\n                carrotsEatenTimestamps.poll();\n            }\n        }\n        \n        if (currentPos < L) {\n            while (!carrotsEatenTimestamps.isEmpty() && totalTime >= carrotsEatenTimestamps.peek() + T) {\n                carrotsEatenTimestamps.poll();\n            }\n            \n            int currentSpeed = (carrotsEatenTimestamps.size() > 0) ? V : U;\n            double timeToFinish = (L - currentPos) / (double) currentSpeed;\n            totalTime += timeToFinish;\n        }\n        \n        return totalTime;\n    }\n}",
    "timestamp": "2025-08-13 06:06:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_CARROTS 1000 // Maximum number of carrots\n\ntypedef struct {\n    int position;\n    int speed;\n} Carrot;\n\nint minTimeToReachGoal(int start, int goal, Carrot carrots[], int numCarrots, int U, int V, int T, int K) {\n    int dp[MAX_CARROTS + 1][MAX_CARROTS + 1]; // dp[i][j] stores the minimum time to reach carrot i with j carrots in hand\n    for (int i = 0; i <= numCarrots; i++) {\n        for (int j = 0; j <= K; j++) {\n            dp[i][j] = 1e9; // Initialize with large value\n        }\n    }\n\n    dp[0][0] = 0; // Starting without any carrot takes 0 time\n    for (int i = 0; i < numCarrots; i++) {\n        for (int j = 0; j <= K; j++) {\n            int currentTime = dp[i][j];\n            int currentPos = i == 0 ? start : carrots[i - 1].position;\n            int nextPos = carrots[i].position;\n            \n            // Run without eating carrot\n            dp[i + 1][j] = currentTime + (nextPos - currentPos) / U;\n\n            // Eat a carrot, if possible\n            if (j > 0) {\n                int timeWithBoost = (nextPos - currentPos) / V;\n                dp[i + 1][j - 1] = currentTime + timeWithBoost;\n            }\n\n            // Pick up a carrot\n            if (j < K) {\n                dp[i + 1][j + 1] = currentTime + (nextPos - currentPos) / U;\n            }\n        }\n    }\n\n    int minTime = 1e9;\n    for (int j = 0; j <= K; j++) {\n        int lastCarrotPos = carrots[numCarrots - 1].position;\n        minTime = (minTime < dp[numCarrots][j]) ? minTime : dp[numCarrots][j];\n    }\n\n    return minTime + (goal - carrots[numCarrots - 1].position) / U;\n}\n\nint main() {\n    int start, goal, U, V, T, K, numCarrots;\n    \n    scanf(\"%d %d %d %d %d %d %d\", &start, &goal, &U, &V, &T, &K, &numCarrots);\n    \n    Carrot carrots[MAX_CARROTS];\n    for (int i = 0; i < numCarrots; ++i) {\n        scanf(\"%d %d\", &carrots[i].position, &carrots[i].speed);\n    }\n\n    printf(\"%d\\n\", minTimeToReachGoal(start, goal, carrots, numCarrots, U, V, T, K));\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 06:06:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(L, U, V, T, K, carrots):\n    carrots.sort()\n    time = 0\n    speed = U\n    speed_boost_end = 0\n    carrots_held = 0\n\n    for i in range(len(carrots)):\n        # Time to reach current carrot\n        time += (carrots[i] - (0 if i == 0 else carrots[i-1])) / speed\n\n        # Check speed boost expiration\n        if time >= speed_boost_end:\n            speed = U\n\n        # Eat carrot if possible\n        if carrots_held < K:\n            speed = V\n            speed_boost_end = time + T\n            carrots_held += 1\n\n    # Time to reach goal\n    time += (L - (0 if len(carrots) == 0 else carrots[-1])) / speed\n\n    return time\n\n# Input parsing\nL, U, V, T, K = map(int, input().split())\nN = int(input())\ncarrots = list(map(int, input().split()))\n\n# Solve and print\nprint(solve(L, U, V, T, K, carrots))",
    "timestamp": "2025-08-13 06:06:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    L = int(data[idx])\n    idx += 1\n    N = int(data[idx])\n    idx += 1\n    K = int(data[idx])\n    idx += 1\n    U = int(data[idx])\n    idx += 1\n    V = int(data[idx])\n    idx += 1\n    T = int(data[idx])\n    idx += 1\n    \n    carrots = []\n    for _ in range(N):\n        x = int(data[idx])\n        idx += 1\n        carrots.append(x)\n    carrots.sort()\n    \n    # Add the goal as a dummy carrot for easier calculation\n    carrots.append(L)\n    \n    prev_pos = 0\n    time = 0\n    available_carrots = []\n    heapq.heapify(available_carrots)\n    \n    for pos in carrots:\n        distance = pos - prev_pos\n        \n        # Time without using any carrots\n        normal_time = distance / U\n        \n        # Time if we use carrots\n        boosted_time = 0\n        remaining_distance = distance\n        \n        while remaining_distance > 0 and available_carrots:\n            t_boost_end, boost_speed = heapq.heappop(available_carrots)\n            boost_available = t_boost_end - time\n            if boost_available <= 0:\n                continue\n            \n            boost_distance = boost_speed * boost_available\n            if boost_distance >= remaining_distance:\n                boosted_time += remaining_distance / boost_speed\n                remaining_boost_time = boost_available - (remaining_distance / boost_speed)\n                if remaining_boost_time > 0:\n                    heapq.heappush(available_carrots, (time + remaining_boost_time, boost_speed))\n                remaining_distance = 0\n                break\n            else:\n                boosted_time += boost_available\n                remaining_distance -= boost_distance\n        \n        if remaining_distance > 0:\n            boosted_time += remaining_distance / U\n        \n        if boosted_time < normal_time:\n            time += boosted_time\n        else:\n            time += normal_time\n        \n        # Add the current carrot's boost if we can carry it\n        if pos != L:\n            if len(available_carrots) < K:\n                heapq.heappush(available_carrots, (time + T, V))\n            else:\n                # Replace the smallest boost if current is better\n                if available_carrots and V > available_carrots[0][1]:\n                    heapq.heappop(available_carrots)\n                    heapq.heappush(available_carrots, (time + T, V))\n        \n        prev_pos = pos\n    \n    print(\"{0:.6f}\".format(time))\n\nsolve()",
    "timestamp": "2025-08-13 06:06:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\n// Function to compute the shortest time to reach the goal\ndouble findShortestTime(int D, int U, int V, int T, int K, const vector<int>& carrots) {\n    int n = carrots.size();\n    vector<double> dp(n + 1, DBL_MAX);\n    dp[0] = 0.0;\n\n    for (int i = 0; i <= n; ++i) {\n        // Regular speed from current position to next carrot or end\n        int nextPos = (i == n) ? D : carrots[i];\n        double travelTime = (nextPos - (i == 0 ? 0 : carrots[i - 1])) / double(U);\n        dp[i] = min(dp[i], (i == 0 ? 0 : dp[i - 1]) + travelTime);\n\n        // Use carrots from current position to next carrot or end\n        for (int j = 1; j <= K; ++j) {\n            if (i + j > n) break;\n            nextPos = (i + j == n) ? D : carrots[i + j];\n            double acceleratedTime = (nextPos - (i == 0 ? 0 : carrots[i - 1])) / double(V);\n            double totalTime = (i == 0 ? 0 : dp[i - 1]) + T * j + acceleratedTime;\n            dp[i + j] = min(dp[i + j], totalTime);\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    int D, U, V, T, K, N;\n    cin >> D >> U >> V >> T >> K >> N;\n    vector<int> carrots(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> carrots[i];\n    }\n\n    // Calculate shortest time\n    double shortestTime = findShortestTime(D, U, V, T, K, carrots);\n    cout.precision(8);\n    cout << fixed << shortestTime << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:59"
  }
]