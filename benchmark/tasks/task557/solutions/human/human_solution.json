[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nobject Main extends App {\n  import scala.io.StdIn._\n\n\n  val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n  val direction = readLine.trim.map(_ == 'R').toArray\n  val costs = readLine.trim.split(' ').map(_.toInt)\n  val relation = Array.tabulate(m){_ ⇒\n    val Array(s, t, b) = readLine.trim.split(' ').map(_.toInt)\n    if (s < t) (s, t, b) else (t, s, b)\n  }\n  println(\n    calMinCut(direction, costs, relation)\n  )\n\n  def calMinCut(direction: Array[Boolean], costs: Array[Int], relations: Array[(Int, Int, Int)]): Long = {\n    val source = 0\n    val drain = direction.length + 1\n    val nodes = Array.tabulate(direction.length + 2){_ ⇒ ArrayBuffer[Edge]()}\n    for (i ← direction.indices){\n      if (direction(i)){\n        nodes(i + 1).append(Edge(drain, nodes(drain).length, costs(i)))\n        nodes(drain).append(Edge(i + 1, 0, 0))\n      }else {\n        nodes(i + 1).append(Edge(source, nodes(source).length, 0))\n        nodes(source).append(Edge(i + 1, 0, costs(i)))\n      }\n    }\n    for ((s, t, b) ← relations){\n      nodes(t).append(Edge(s, nodes(s).length, b))\n      nodes(s).append(Edge(t, nodes(t).length - 1, 0))\n    }\n    calMinCut(nodes, source, drain)\n  }\n  def calMinCut(nodes: Array[ArrayBuffer[Edge]], source: Int, drain: Int): Long = {\n    val depth = Array.tabulate(nodes.length){_ ⇒ 0}\n    val searching = Array.tabulate(nodes.length){_ ⇒ 0}\n    val queue = mutable.Queue[Int]()\n    def bfs(): Unit ={\n      queue.clear()\n      queue.enqueue(source)\n      depth.indices.foreach(i ⇒ depth(i) = -1)\n      depth(source) = 0\n      while (queue.nonEmpty && queue.head != drain){\n        val current = queue.dequeue()\n        for (next ← nodes(current) if next.flow > 0 && depth(next.to) == -1){\n          depth(next.to) = depth(current) + 1\n          queue.enqueue(next.to)\n        }\n      }\n    }\n    def dfs(current: Int, minFlow: Long = Long.MaxValue): Long = {\n      if (current == drain) minFlow\n      else {\n        var flow = 0L\n        while(searching(current) < nodes(current).length && flow == 0) {\n          val next = nodes(current)(searching(current))\n          if (next.flow > 0 && depth(current) < depth(next.to)) {\n            flow = dfs(next.to, math.min(minFlow, next.flow))\n            if (flow != 0) {\n              next.flow -= flow\n              nodes(next.to)(next.pair).flow += flow\n              searching(current) -= 1\n            }\n          }\n          searching(current) += 1\n        }\n        flow\n      }\n    }\n    var result = 0L\n    var canFlow = true\n    while(canFlow){\n      bfs()\n      searching.indices.foreach(i ⇒ searching(i) = 0)\n      canFlow = false\n      var r = dfs(source)\n      while(r != 0){\n        canFlow = true\n        result += r\n        r = dfs(source)\n      }\n    }\n    result\n  }\n  case class Edge(to: Int, pair: Int, var flow: Long)\n\n  implicit class Scope[T](val value: T) extends AnyVal {\n    @inline\n    def let[A](func: T ⇒ A): A = func(value)\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 10000\nstruct edge{int to;long long cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,long long cap){\n\tG[from].push_back((edge){to,cap,(ll)G[to].size()});\n\tG[to].push_back((edge){from,0,(ll)G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty())\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v ,int t,long long f){\n\tif(v == t)return f;\n\tfor(int &i = iter[v];i < G[v].size() ;++i){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tlong long d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long Dinic(int s,int t){\n\tlong long flow = 0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t] < 0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;while((f = dfs(s,t,INF)) > 0)flow += f;\n\t}\n}\n\nint main(){\n\tll st = 1000, en = 1001;\n\tll n, m;cin >> n >> m;\n\tstring str;cin >> str;\n\n\tREP(i, n){\n\t\tll a;cin >> a;\n\t\tif(str[i] == 'R'){\n\t\t\tadd_edge(st, i, 0);\n\t\t\tadd_edge(i, en, a);\n\t\t}\n\t\telse {\n\t\t\tadd_edge(st, i, a);\n\t\t\tadd_edge(i, en, 0);\n\t\t}\n\t}\n\n\tREP(i, m){\n\t\tll a, b ,c;cin >> a >> b >> c;\n\t\ta--;b--;\n\t\tif(a > b)swap(a, b);\n\t\tadd_edge(b, a, c);\n\t}\n\n\tcout << Dinic(st, en) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\nusing namespace std;\n\nusing Flow = int;\n\nstruct Edge {\n\tint src, dst;\n\tFlow cap;\n};\n\ntypedef vector<vector<Edge>> Graph;\nstruct dinic {\n\tint n, s, t;\n\tstd::vector<int> level, prog, que;\n\tstd::vector<std::vector<Flow>> cap, flow;\n\tstd::vector<std::vector<int>> g;\n\tFlow inf;\n\tdinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, std::vector<Flow>(n)),\n\t\tflow(n, std::vector<Flow>(n)),\n\t\tg(n, std::vector<int>()),\n\t\tinf(std::numeric_limits<Flow>::max() / 8) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tFlow c = e.cap;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tFlow solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tFlow res = 0;\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v])\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tFlow augment(int v, Flow lim) {\n\t\tFlow res = 0;\n\t\tif (v == t) return lim;\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst Flow aug = augment(d, std::min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint mat[501][501] = {};\n\nsigned main() {\n\n\tint n, m;\n\tstring u;\n\t\n\tcin >> n >> m >> u;\n\tvector<int> a(n);\n\n\tfor (int i = 0; n > i; i++)\n\t\tcin >> a[i];\n\n\tGraph g(n + 2);\n\n\tfor (int i = 0; n > i; i++) {\n\t\tif (u[i] == 'L') {\n\t\t\tg[n].push_back({n, i, 0});\n\t\t\tg[i].push_back({i, n + 1, a[i]});\n\t\t}\n\t\telse {\n\t\t\tg[n].push_back({ n, i, a[i] });\n\t\t\tg[i].push_back({ i, n + 1, 0 });\n\t\t}\n\t}\n\n\t\n\n\tfor (int i = 0; m > i; i++) {\n\t\tint s, t, b;\n\t\tcin >> s >> t >> b;\n\t\ts--, t--;\n\t\tif (s > t) swap(s, t);\n\n\t\tmat[s][t] += b;\n\t}\n\n\tfor(int i = 0; n > i; i++)\n\t\tfor (int j = 0; n > j; j++) {\n\t\t\tif (mat[i][j] != 0) {\n\t\t\t\tg[min(i,j)].push_back({ min(i,j), max(i,j), mat[i][j] });\n\t\t\t}\n\t\t}\n\n\tdinic din(g);\n\tcout << din.solve(n, n + 1) << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Dinic を信じろ\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate<typename T>\nstruct Dinic {\n    int N, M;\n    Graph<T> G;\n    vector<int> level, iter;\n    Dinic(int n, int m) : N(n), M(m) {\n        G.resize(N);\n        level.resize(N);\n        iter.resize(N);\n    }\n    void add_edge(int from, int to, T cost) {\n        G[from].push_back(Edge<T>(to  , cost, G[to  ].size()    ));\n        G[to  ].push_back(Edge<T>(from, 0.0 , G[from].size() - 1));\n    }\n    void readGraph() {\n        for(int i=0; i<M; i++) {\n            int a, b; T c;\n            cin >> a >> b >> c;\n            // a--; b--;\n            add_edge(a, b, c);\n        }\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> que; que.push(s);\n        level[s] = 0;\n        while(!que.empty()) {\n            int temp = que.front(); que.pop();\n            for(size_t i=0; i<G[temp].size(); i++) {\n                Edge<T> &e = G[temp][i];\n                if(e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[temp] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    T dfs(int v, int t, T f) {\n        if(v == t) return f;\n        for(int &i = iter[v]; i<(int)G[v].size(); i++) {\n            Edge<T> &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T max_flow(int s, int t) {\n        T flow = 0.0, f;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            while( (f = dfs(s, t, INF)) > 0 ) flow += f;\n        }\n    }\n};\n\n// 最小流量制約付きフロー\n// u から v に最小 lb, 最大 ub 流す\ntemplate<typename flow_type>\nstruct Dinic_lr {\n    Dinic<flow_type> fl;\n    int S, T;\n    flow_type sum_lb;\n\n    Dinic_lr() {}\n    Dinic_lr(int N) : fl(N+2, 0), S(N), T(N+1), sum_lb(0) {}\n\n    void add_edge(int u, int v, flow_type lb, flow_type ub) {\n        assert(0 <= lb && lb <= ub);\n        if(u == v || ub == 0) return;\n        fl.add_edge(u, v, ub - lb);\n        fl.add_edge(S, v, lb);\n        fl.add_edge(u, T, lb);\n        sum_lb += lb;\n    }\n\n    flow_type max_flow(int s, int t) {\n        flow_type a = fl.max_flow(S, T);\n        flow_type b = fl.max_flow(s, T);\n        flow_type c = fl.max_flow(S, t);\n        flow_type d = fl.max_flow(s, t);\n        return (a + c == sum_lb && a + b == sum_lb) ? b + d : -1;\n    }\n};\n\nsigned main() {\n    int N, M; cin >> N >> M;\n    string s; cin >> s;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) {\n        cin >> A[i];\n    }\n\n    Dinic<int> fl(N + 2, 0);\n\n    int source = N, sink = N + 1;\n    for(int i=0; i<N; i++) {\n        if(s[i] == 'L') fl.add_edge(source, i, A[i]);\n        if(s[i] == 'R') fl.add_edge(i, sink  , A[i]);\n    }\n\n    for(int i=0; i<M; i++) {\n        int S, T, cost; cin >> S >> T >> cost;\n        S--; T--;\n        if(S > T) swap(S, T);\n\n        fl.add_edge(T, S, cost);\n    }\n\n    cout << fl.max_flow(source, sink) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#define MAX_V 1010\n#define INF 100000000000000\nusing namespace std;\n\nstruct edge {long long to,cap,rev;};\n\nvector<edge> G[MAX_V];\nlong long level[MAX_V],iter[MAX_V];\n\nvoid add_edge(int from, int to, long long cap){\n\tG[from].push_back((edge){to,cap,(long long)G[to].size()});\n\tG[to].push_back((edge){from,0,(long long)G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long dfs(int v, int t, long long f){\n\tif(v==t) return f;\n\tfor(int i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\t\nlong long max_flow(int s, int t){\n\tlong long flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;\n\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\nint main(){\n\tint i,n,m;\n\tstring u;\n\tcin >> n >> m >> u;\n\tfor(i=1;i<=n;i++){\n\t\tint a; cin >> a;\n\t\tif(u[i-1]=='L'){\n\t\t\tadd_edge(0,i,a);\n\t\t\tadd_edge(i,n + 1,0);\n\t\t}else{\n\t\t\tadd_edge(0,i,0);\n\t\t\tadd_edge(i,n + 1,a);\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint s,t,b;\n\t\tcin >> s >> t >> b;\n\t\tif(s>t) swap(s,t);\n\t\tadd_edge(t,s,b);\n\t}\n\tcout << max_flow(0,n + 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n#define min(x,y) (x < y ? x : y)\n#define max(x,y) (x < y ? y : x)\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nclass MaxFlow {\npublic:\n  struct Edge {\n    ll to, cap, rev;\n  };\n  vector<vector<Edge>> G;\n  vector<ll> iter;\nprivate:\n  bool is_debug;\n  ll V;\n  vector<ll> bfs(ll s) {\n    vector<ll> dist(V, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n      ll v = Q.front(); Q.pop();\n      each(e, G[v]) {\n        if (e.cap > 0 && dist[e.to] == linf) {\n          dist[e.to] = dist[v]+1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return dist;\n  }\n  ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    for (ll& i = iter[v]; i < G[v].size(); ++i) {\n      Edge& e = G[v][i];\n      if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n        ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\npublic:\n  const vector<vector<Edge>>& Graph() {\n    return G;\n  }\n  MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n  void init(ll n) {\n    V = n;\n    G.assign(V, vector<Edge>());\n  }\n  void add(ll from, ll to, ll cap) {\n    if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n    assert(V > 0);\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, 0, (ll)G[from].size()-1});\n  }\n  // S -> s, T -> t に inf は自力で\n  void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n    if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n    add(from, to, cap-min_flow);\n    add(S, to, min_flow);\n    add(from, T, cap);\n    if (is_debug) cout << endl;\n  }\n  ll flow(ll s, ll t, ll f=linf) {\n    ll res = 0;\n    while (f > 0) {\n      vector<ll> dist = bfs(s);\n      if (dist[t] == linf) break;\n      iter.assign(G.size(), 0);\n      while (f > 0) {\n        vector<bool> used(V, false);\n        ll df = dfs(s, t, f, dist, used);\n        if (df == 0) break;\n        f -= df;\n        res += df;\n      }\n    }\n    return res;\n  }\n};\n\nvoid solve() {\n  ll n, m; cin >> n >> m;\n  string str; cin >> str;\n  vector<ll> a(n); cin >> a;\n  ll s = n, t = s+1;\n  MaxFlow mf(t+1);\n  rep(i, n) {\n    if (str[i] == 'R') {\n      mf.add(s, i, a[i]);\n    }\n    else {\n      mf.add(i, t, a[i]);\n    }\n  }\n  rep(i, m) {\n    ll l, r, c; cin >> l >> r >> c; --l, --r;\n    if (l > r) swap(l, r);\n    mf.add(l, r, c);\n  }\n  cout << mf.flow(s, t) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n\n//Appropriately Changed\nusing W = ll;\nusing edge = struct {int to, rev; W cap, flow;};\nusing G = vector<vector<edge>>;\n \n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c){\n\tvector<string> v;stringstream ss(s);string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a,Args... args){\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \",err(++it, args...);\n}\n\n\n//Appropriately Changed\nvoid add_edge(G &graph, int from, int to, W cap) {\n\t// error(from, to, cap);\n\tgraph[from].push_back({to, int(graph[to].size()) , cap , 0});\n\tgraph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0});\n}\n\nW dinic(G &graph, int s, int t) {\n\tconst W inf = 1LL << 50;\n\tconst int n = graph.size();\n\tvector<int> level(n), iter(n);\n\n\tauto bfs = [&](int s, int t) {\n\t\tfill(begin(level), end(level), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0, q.push(s);\n\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : graph[v]) {\n\t\t\t\tif (level[e.to] == - 1 and e.cap > e.flow) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (level[t] !=  -1);\n\t};\n\n\tauto dfs = [&](int v, int t, W f) {\n\t\tauto func = [&](int v, int t, W f, auto func)->W{\n\n\t\t\tif (v == t) return f;\n\t\t\tfor (int &i = iter[v]; i < graph[v].size(); i++) {\n\t\t\t\tedge &e = graph[v][i];\n\n\t\t\t\tif (e.cap > e.flow and level[v] < level[e.to]) {\n\n\t\t\t\t\tW d = func(e.to, t, min(f, e.cap - e.flow), func);\n\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\te.flow += d, graph[e.to][e.rev].flow -= d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t};\n\t\treturn func(v, t, f, func);\n\t};\n\n\twhile (bfs(s, t)) {\n\t\tfill(begin(iter), end(iter), 0);\n\t\twhile (dfs(s, t, inf) != 0 );\n\t}\n\n\tW ret = 0;\n\tfor (auto &e : graph[s]) ret += e.flow;\n\treturn ret;\n}\n\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring u;\n\tcin >> u;\n\n\tvector<int> a(n);\n\trep(i, n) cin >> a[i];\n\n\tconst int s = n;\n\tconst int t = s + 1;\n\tconst int all = t + 1;\n\tG graph(all);\n\n\trep(i ,n){\n\t\tif(u[i] == 'L'){\n\t\t\tadd_edge(graph, s, i, 0LL);\n\t\t\tadd_edge(graph, i, t, a[i]);\n\t\t} else {\n\t\t\tadd_edge(graph, s, i, a[i]);\n\t\t\tadd_edge(graph, i, t, 0LL);\n\t\t}\n\t}\n\n\trep(i, m){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tif(a >= b) swap(a, b);\n\t\ta--, b--;\n\t\tadd_edge(graph, a, b, c);\n\t}\n\t\n\tcout << dinic(graph, s, t) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\n\nstruct ResidualGraph{\n    int V;\n    std::vector<std::vector<std::tuple<int, int, int>>> graph;\n     \n    ResidualGraph(int V) : V(V), graph(V) { };\n \n    void add(int v, int w, int capacity){\n        graph[v].emplace_back(w, capacity, graph[w].size());\n        graph[w].emplace_back(v, 0, graph[v].size() - 1);\n    }\n \n    std::vector<std::tuple<int, int, int>>& operator[](int v){\n        return graph[v];\n    }\n};\n \nstruct Dinitz{\n    ResidualGraph &graph;\n    std::vector<int> level, lastIndex;\n \n    Dinitz(ResidualGraph &graph) : graph(graph), level(graph.V), lastIndex(graph.V) { }\n \n    void bfs(int s){\n        std::fill(level.begin(), level.end(), -1);\n \n        std::queue<int> q;\n        q.emplace(s);\n        level[s] = 0;\n \n        while(!q.empty()){\n            int v = q.front();\n            q.pop();\n             \n            for(auto &e : graph[v]){\n                int w, cap;\n                std::tie(w, cap, std::ignore) = e;\n \n                if(cap > 0 && level[w] < 0){\n                    level[w] = level[v] + 1;\n                    q.emplace(w);\n                }\n            }\n        }\n    }\n \n    int dfs(int v, int t, int flow){\n        if(v == t){\n            return flow;\n        }\n \n        for(int i=lastIndex[v];i<(int)graph[v].size();++i){\n            int w, rev;\n            int &cap = std::get<1>(graph[v][i]);\n            std::tie(w, std::ignore, rev) = graph[v][i];\n            int &rev_cap = std::get<1>(graph[w][rev]);\n             \n            if(cap > 0 && level[w] > level[v]){\n                int f = dfs(w, t, std::min(flow, cap));\n                if(f > 0){\n                    cap -= f;\n                    rev_cap += f;\n                    return f;\n                }\n            }\n        }\n \n        return 0;\n    }\n \n    int64_t solve(int s, int t){\n        int64_t res = 0;\n        while(true){\n            bfs(s);\n            if(level[t] < 0){\n                return res;\n            }\n            std::fill(lastIndex.begin(), lastIndex.end(), 0);\n            int f;\n            while((f = dfs(s, t, std::numeric_limits<int>::max())) > 0){\n                res += f;\n            }\n        }\n         \n        return 0;\n    }\n};\n\nint N, M;\nstd::string U;\nint A[500];\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N >> M >> U;\n\n    for(int i=0;i<N;++i){\n        std::cin >> A[i];\n    }\n\n    ResidualGraph g(N + 2);\n    \n    for(int i=1;i<=N;++i){\n        if(U[i - 1] == 'R'){\n            g.add(0, i, A[i - 1]);\n            g.add(i, N + 1, 0);\n        }else{\n            g.add(0, i, 0);\n            g.add(i, N + 1, A[i - 1]);\n        }\n    }\n\n    for(int i=0;i<M;++i){\n        int S, T, B;\n        std::cin >> S >> T >> B;\n\n        if(S > T){\n            std::swap(S, T);\n        }\n\n        g.add(S, T, B);\n    }\n\n    Dinitz d(g);\n    ll res = d.solve(0, N + 1);\n    std::cout << res << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n) \\\n  do{for(int i=0;i<(n);i++)cerr<<\"(\"<<i<<\" = \"<<(a)[i]<<\") \";cerr<<endl;}while(0)\n#define showA2(a, n, m) \\\n  do {for(int i=0;i<(n);i++){for(int j=0;j<(m);j++){cerr<<\"(\"<<i<<\", \"<<j<<\" = \"<<(a)[i][j]<<\") \";}cerr<<endl;}cerr<<endl;}while(0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF = 0x3f3f3f3f;       //1061109567\nconstexpr const ll LL_INF = 0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\ntemplate<typename T>\nclass Dinic{\npublic:\n  Dinic(int SIZE) :SIZE(SIZE) {\n    //level.resize(SIZE + 10, 0);\n    //iter.resize(SIZE + 10, 0);\n    v = vector<vector<tuple<int, int, T>>>(SIZE + 10);\n  }\n  void AddEdge(int from, int to, int cap) {\n    v[from].push_back(make_tuple(to, cap, v[to].size()));\n    v[to].push_back(make_tuple(from, 0, v[from].size() - 1));\n  }\n\n  void bfs(int s) {\n    // memset(level, -1, sizeof(level));\n    level = vector<int>(SIZE + 10, -1);\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int now = q.front(); q.pop();\n      for (int i = 0; i < (int)v[now].size(); i++) {\n        int next, nextc, nextrv; tie(next, nextc, nextrv) = v[now][i];\n        if (nextc > 0 && level[next] < 0) {\n          level[next] = level[now] + 1;\n          q.push(next);\n        }\n      }\n    }\n  }\n\n  int dfs(int now, int t, int f) {\n    if (now == t) return f;\n    for (int &i = iter[now]; i < (int)v[now].size(); i++) {\n      int next, nextc, nextrv; tie(next, nextc, nextrv) = v[now][i];\n      if (nextc > 0 && level[now] < level[next]) {\n        int d = dfs(next, t, min(f, nextc));\n        if (d > 0) {\n          get<1>(v[now][i]) -= d;\n          get<1>(v[next][nextrv]) += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      // memset(iter, 0, sizeof(iter));\n      iter = vector<int>(SIZE + 10, 0);\n      // for_each(iter.begin(), iter.end(), [](int x){cout << x << endl;});\n      int f;\n      while ((f = dfs(s, t, INT_MAX)) > 0) {\n        flow += f;\n      }\n    }\n  }\nprivate:\nint SIZE;\nvector<vector<tuple<int, int, T>>> v;\nvector<int> level, iter;\n};\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nint n, m;\nstring u;\nint a[501];\nint s[1501], t[1501], b[1501];\n\nint main()\n{\n  cin >> n >> m;\n  cin >> u;\n  rep(i, 0, n) cin >> a[i];\n  rep(i, 0, m) {\n    cin >> s[i] >> t[i] >> b[i];\n    s[i]--; t[i]--;\n  }\n  Dinic<int> flow(n);\n  rep(i, 0, n) {\n    if (u[i] == 'L') {\n      flow.AddEdge(n, i, a[i]);\n      flow.AddEdge(i, n + 1, 0);\n    } else {\n      flow.AddEdge(n, i, 0);\n      flow.AddEdge(i, n + 1, a[i]);\n    }\n  }\n  rep(i, 0, m) {\n    flow.AddEdge(max(s[i], t[i]), min(s[i], t[i]), b[i]);\n  }\n  // cerr << \"hi\" << endl;\n  cout << flow.max_flow(n, n + 1) << endl;\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct Dinic{\n  const int INF=1<<28;\n  \n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n          e.cap-=d;\n          G[e.to][e.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n        fl+=f;\n        lim-=f;\n      }\n    }\n  }\n\n  int flow(int s,int t){\n    return flow(s,t,INF);\n  }\n\n  //cap==1 only\n  bool back_edge(int s,int t,int from, int to){\n    for(int i=0;i<(int)G[from].size();i++) {\n      edge& e=G[from][i];\n      if(e.to==to) {\n        if(e.cap==0&&flow(from,to,1)==0) {\n          flow(from,s,1);\n          flow(t,to,1);\n          return 1;\n        }\n      }\n    }\n    return 0;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  string s;\n  cin>>s;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n\n  Dinic f(n+2);\n  int S=n,T=n+1;\n  for(int i=0;i<m;i++){\n    int x,y,z;\n    cin>>x>>y>>z;\n    x--;y--;\n    if(x>y) swap(x,y);\n    f.add_edge(x,y,z);\n  }\n  for(int i=0;i<n;i++){\n    if(s[i]=='R') f.add_edge(S,i,a[i]);\n    if(s[i]=='L') f.add_edge(i,T,a[i]);\n  }\n  cout<<f.flow(S,T)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T = int> using V = vector<T>; \ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<class T> struct Dinic {\n    struct Edge {\n        int to, rev;\n        T cap;\n    };\n    const int n;\n    const T inf = numeric_limits<T>::max();\n    VV<Edge> g;\n    V<> dist, i;\n    Dinic(int n) : n(n), g(n), dist(n), i(n) {}\n    void add_edge(int from, int to, T cap) {\n        g[from].emplace_back(Edge{to, (int) g[to].size(), cap});\n        g[to].emplace_back(Edge{from, (int) g[from].size() - 1, 0});\n    }\n    void bfs(int s) {\n        fill(begin(dist), end(dist), -1);\n        queue<int> que;\n        dist[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            for (const auto& e : g[v]) {\n                if (dist[e.to] != -1 or e.cap <= 0) continue;\n                dist[e.to] = dist[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n    T dfs(int v, int s, T f) {\n        if (v == s) return f;\n        for (; i[v] < g[v].size(); ++i[v]) {\n            Edge& e = g[v][i[v]];\n            if (dist[e.to] >= dist[v] or g[e.to][e.rev].cap <= 0) continue;\n            T d = dfs(e.to, s, min(f, g[e.to][e.rev].cap));\n            if (d > 0) {\n                g[e.to][e.rev].cap -= d;\n                e.cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    T max_flow(int s, int t) {\n        T res = 0;\n        while (true) {\n            bfs(s);\n            if (dist[t] == -1) return res;\n            fill(begin(i), end(i), 0);\n            while (true) {\n                T f = dfs(t, s, inf);\n                if (f == 0) break;\n                res += f;\n            }\n        }\n    }\n};\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    int n, m; cin >> n >> m;\n    string U; cin >> U;\n    V<> A(n); for (auto&& e : A) cin >> e;\n    Dinic<int> g(n + 2);\n    int S = n, T = n + 1;\n    for (int i = 0; i < n; ++i) {\n        if (U[i] == 'L') {\n            g.add_edge(S, i, A[i]);\n            g.add_edge(i, T, 0);\n        } else {\n            g.add_edge(S, i, 0);\n            g.add_edge(i, T, A[i]);\n        }\n    }\n    while (m--) {\n        int i, j, B; cin >> i >> j >> B, --i, --j;\n        if (i > j) swap(i, j);\n        g.add_edge(j, i, B);\n    }\n    cout << g.max_flow(S, T) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\n#include<cstring>\nstruct edge { int to, cap, rev; };\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint n, m;\nint a[500];\nint main() {\n\tcin >> n >> m;\n\tstring u; cin >> u;\n\tint s = n, t = n+1;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, n) {\n\t\tif (u[i] == 'L') {\n\t\t\tadd_edge(i, t, a[i]);\n\t\t}\n\t\telse {\n\t\t\tadd_edge(s, i, a[i]);\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint x, y, b; cin >> x >> y >> b; x--; y--;\n\t\tif (x < y) {\n\t\t\tadd_edge(x, y, b);\n\t\t}\n\t\telse {\n\t\t\tadd_edge(y, x, b);\n\t\t}\n\t}\n\tint f = max_flow(s,t);\n\tcout << f << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// edge class (for network-flow)\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1<<30; // to be set\n    vector<int> level, iter;\n\n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    string U;\n    cin >> N >> M >> U;\n    vector<long long> A(N);\n    for (int i = 0; i < N; ++i) cin >> A[i];\n\n    Graph<long long> G(N+2);\n    int s = N, t = N+1;\n    for (int i = 0; i < N; ++i) {\n        if (U[i] == 'R') {\n            G.addedge(s, i, A[i]);\n            G.addedge(i, t, 0);\n        }\n        else {\n            G.addedge(s, i, 0);\n            G.addedge(i, t, A[i]);\n        }\n    }\n    for (int _ = 0; _ < M; ++_) {\n        int a, b; long long c;\n        cin >> a >> b >> c;\n        --a, --b;\n        if (a > b) swap(a, b);\n        G.addedge(a, b, c);\n    }\n    \n    Dinic<long long> din;\n    long long res = din.solve(G, s, t);\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n\nstruct Dinic{\n  const int INF=1<<28;\n  \n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&level[e.to]<0){\n          level[e.to]=level[v]+1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n        int d = dfs(e.to,t,min(f,e.cap));\n\t     if(d>0){\n\t       e.cap-=d;\n\t       G[e.to][e.rev].cap+=d;\n\t       return d;\n\t     }\n      }\n    }\n    return 0;\n  }\n  \n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n\t     fl+=f;\n\t     lim-=f;\n      }\n    }\n  }\n\n  int flow(int s,int t){\n    return flow(s,t,INF);\n  }\n};\n\nint n,m,a,b,c;\nstring s;\ntypedef pair<int,int>P;\nmap<P,int>M;\n\nint main(){\n  cin>>n>>m>>s;\n  int S=n,T=n+1;\n  Dinic D(n+2);\n\n  r(i,n){\n    int x,y=0;\n    cin>>x;\n    if(s[i]=='L')swap(x,y);\n    D.add_edge(S,i,x);\n    D.add_edge(i,T,y);\n  }\n\n  r(i,m){\n    cin>>a>>b>>c; a--; b--;\n    if(a>b)swap(a,b);\n    M[P(a,b)]+=c;\n  }\n\n  for(map<P,int>::iterator it=M.begin();it!=M.end();it++){\n    D.add_edge((*it).first.first,(*it).first.second,(*it).second);\n  }\n\n  cout<<D.flow(S,T)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define inf 2000000000 // 1e17\n// 0-indexed\ntemplate <class T>\nstruct Dinic {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n  vector<vector<edge>> lst;\n  vector<int> completed;\n  vector<int> dist;\n  Dinic(int n = 1) {\n    // if 1-indexed\n    //++n;\n    lst.resize(n);\n    completed.resize(n);\n    dist.resize(n);\n  }\n  bool add(int start, int goal, T capacity) {\n    lst[start].push_back(\n        (edge){goal, capacity, (int)lst[goal].size()});\n    lst[goal].push_back(\n        (edge){start, 0, (int)lst[start].size() - 1});\n    return 1;\n  }\n  // dist = time from start to now number\n  void distbfs(int start) {\n    fill(dist.begin(), dist.end(), -1);\n    queue<int> bfsqu;\n    dist[start] = 0;\n    bfsqu.push(start);\n    while(bfsqu.size() > 0) {\n      int now = bfsqu.front();\n      bfsqu.pop();\n      for(int i = 0; i < lst[now].size(); ++i) {\n        edge* nowe = &lst[now][i];\n        if(nowe->cap > 0 && dist[nowe->to] < 0) {\n          dist[nowe->to] = dist[now] + 1;\n          bfsqu.push(nowe->to);\n        }\n      }\n    }\n  }\n  T pathdfs(int now, int goal, T nf) {\n    if(now == goal) return nf;\n    for(int& i = completed[now]; i < lst[now].size(); ++i) {\n      edge* e = &lst[now][i];\n      if(e->cap > 0 && dist[now] < dist[e->to]) {\n        T ans = pathdfs(e->to, goal, min(nf, e->cap));\n        if(ans > 0) {\n          e->cap -= ans;\n          lst[e->to][e->rev].cap += ans;\n          return ans;\n        }\n      }\n    }\n    return 0;\n  }\n  T solve(int start, int goal) {\n    T ans = 0, nf = 0;\n    while(1) {\n      // bfs\n      distbfs(start);\n      // cannnot go to goal from start\n      if(dist[goal] < 0) return ans;\n      // reset\n      fill(completed.begin(), completed.end(), 0);\n      while((nf = pathdfs(start, goal, inf)) > 0) ans += nf;\n    }\n    return -1;\n  }\n};\n\nDinic<int> din;\nstring u;\nint n, m;\n\nint main() {\n  cin >> n >> m >> u;\n  din = Dinic<int>(n + 2);\n  for(int i = 0; i < n; ++i) {\n    int a;\n    cin >> a;\n    din.add(n, i, (u[i] == 'R') * a);\n    din.add(i, n + 1, (u[i] == 'L') * a);\n  }\n  for(int i = 0; i < m; ++i) {\n    int s, t, b;\n    cin >> s >> t >> b;\n    --s, --t;\n    din.add(min(s, t), max(s, t), b);\n  }\n  cout << din.solve(n, n + 1) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <string.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_V 1010\n#define INF 1e9+10\n\nstruct edge {int to,cap,rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  string U;\n  cin>>U;\n  int A[N+1]={};\n  for(int i=1;i<=N;i++){\n      cin>>A[i];\n      if(U[i-1]=='L') add_edge(i,N+1,A[i]);\n      else add_edge(0,i,A[i]);\n  }\n  int S[M+1]={},T[M+1]={},B[M+1]={};\n  for(int i=0;i<M;i++){\n      cin>>S[i]>>T[i]>>B[i];\n      if(S[i]<T[i]){\n          add_edge(S[i],T[i],B[i]);\n      }else{\n          add_edge(T[i],S[i],B[i]);\n      }\n  }\n\n  cout<<max_flow(0,N+1)<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream &s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream &s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream &s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\n// Dinic法 O(E * V^2)\nclass DirectedGraph {\n  int t; // ゴール\n  vector<int> level, iter;\n  void bfs(int s) {\n    for (int i = 0; i < level.size(); i++) level[i] = -1;\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int v, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\npublic:\n  int V;\n  struct edge {int to, cap, rev; };\n  vector<vector<edge>> G;\n  DirectedGraph(int V) : V(V), G(V), level(V), iter(V) {}\n\n  void add_edge(int from, int to, int cap) {\n    G[from].push_back(edge{ to, cap, (int)G[to].size() });\n    G[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    this->t = t;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      for (int i = 0; i < iter.size(); i++) iter[i] = 0;\n      int f;\n      while ((f = dfs(s, (1LL << 60))) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\nsigned main() {\n  int n, m; cin >> n >> m;\n  string u; cin >> u;\n  DirectedGraph g(n + 2);\n  int s = n, t = n + 1;\n  REP (i, n) {\n    int a; cin >> a;\n    if (u[i] == 'R') {\n      g.add_edge(s, i, a);\n    } else {\n      g.add_edge(i, t, a);\n    }\n  }\n  map<ii, int> mp;\n  REP (i, m) {\n    int u, v, c; cin >> u >> v >> c;\n    u--; v--;\n    if (u > v) swap(u, v);\n    g.add_edge(u, v, c);\n  }\n  cout << g.max_flow(s, t) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-2;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\n#include<cstring>\nstruct edge { int to, cap, rev; };\nvector<edge> G[100000];\nbool used[100000];\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, mod);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint n, m;\nint a[500];\nint main() {\n\tcin >> n >> m;\n\tstring u; cin >> u;\n\tint s = n, t = n+1;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\trep(i, n) {\n\t\tif (u[i] == 'L') {\n\t\t\tadd_edge(i, t, a[i]);\n\t\t}\n\t\telse {\n\t\t\tadd_edge(s, i, a[i]);\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint x, y, b; cin >> x >> y >> b; x--; y--;\n\t\tif (x < y) {\n\t\t\tadd_edge(x, y, b);\n\t\t}\n\t\telse {\n\t\t\tadd_edge(y, x, b);\n\t\t}\n\t}\n\tint f = max_flow(s,t);\n\tcout << f << endl;\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n#define pb push_back\n#define FLOW int\n//using FLOW = int;\nnamespace flow{\n    constexpr FLOW INF = 1e7;\n    struct edge{\n        FLOW flow;\n        int to,rev;\n    };\n    typedef vector<edge> E;\n    typedef vector<E> Graph;\n    void addedge(Graph&g,int from,int to,FLOW f){\n        int x=g[from].size();\n        int y=g[to].size();\n        g[from].pb(edge{f,to,y});\n        g[to].pb(edge{(FLOW)0,from,x});\n    }\n\n    vector<int> bfs(Graph& G,int s){\n        int N = G.size();\n        queue<int> que;\n        vector<int> dist(N,-1);\n        dist[s] = 0;\n        que.push(s);\n        for(;!que.empty();que.pop()){\n            auto v=que.front();\n            for(auto& e : G[v])\n                if(e.flow>0&&dist[e.to]==-1){\n                    dist[e.to] = dist[v] + 1;\n                que.push(e.to);\n                }\n        }\n        return dist;\n    }\n}\nFLOW maxflow(flow::Graph& G,int s,int t){\n    using namespace flow;\n    FLOW res=0;\n    int N = G.size();\n    while(true){\n        auto dist = bfs(G,s);\n        if(dist[t] < 0)break;\n        vector<unsigned> iter(N,0);\n        std::function<FLOW(int,FLOW)> dfs=[&](int v,FLOW f){\n            if(v==s)return f;\n            for(auto &i = iter[v]; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                edge &re = G[e.to][e.rev];\n                if(re.flow>0 && dist[v] >dist[e.to]){\n                    FLOW d=dfs(e.to,min(f,re.flow));\n                    if(d>0){e.flow+=d;re.flow-=d;return d;}\n                }\n            }\n            return (FLOW)0;\n        };\n        FLOW f;\n        while((f=dfs(t,INF))> 0)res+=f;\n    }\n    return res;\n}\n\nint N,M;\nint A[1001];\nint B[1001];\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\tstring s;\n\tcin>>s;\n\tREP(i,N){\n\t\tcin>>A[i];\n\t}\n\tflow::Graph g(N+10);\n\tREP(i,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tint d=min(a,b);\n\t\tint e=max(a,b);\n\t\tflow::addedge(g,d,e,c);\n\t}\n\t\n\tREP(i,N){\n\t\tif(s[i]=='L'){\n\t\t\tflow::addedge(g,0,i+1,0);\n\t\t\tflow::addedge(g,i+1,N+1,A[i]);\n\t\t}else{\n\t\t\tflow::addedge(g,0,i+1,A[i]);\n\t\t\tflow::addedge(g,i+1,N+1,0);\n\t\t}\n\t}\n\tcout<<maxflow(g,0,N+1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double Double;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\n#define REP(i, n) for(int i=0;i<(int)n;++i)\n#define FOR(i, c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef ll Weight;\n\nstruct Edge {\n    int src, dst;\n    Weight weight;\n\n    Edge(int src, int dst, Weight weight) :\n            src(src), dst(dst), weight(weight) {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n           e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nconst ll INF = 1e18;\n\n\n#define RESIDUE(s, t) (capacity[s][t]-flow[s][t])\n\nWeight maximumFlow(const Graph &g, int s, int t) {\n    int n = g.size();\n    Matrix flow(n, Array(n)), capacity(n, Array(n));\n    REP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n    Weight total = 0;\n    while (1) {\n        queue<int> Q;\n        Q.push(s);\n        vector<int> prev(n, -1);\n        prev[s] = s;\n        while (!Q.empty() && prev[t] < 0) {\n            int u = Q.front();\n            Q.pop();\n            FOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n                    prev[e->dst] = u;\n                    Q.push(e->dst);\n                }\n        }\n        if (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n        Weight inc = INF;\n        for (int j = t; prev[j] != j; j = prev[j])\n            inc = min(inc, RESIDUE(prev[j], j));\n        for (int j = t; prev[j] != j; j = prev[j])\n            flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n        total += inc;\n    }\n}\n\nGraph g;\n\nvoid add(int a, int b, int f) {\n    g[a].push_back(Edge(a, b, f));\n    g[b].push_back(Edge(b, a, 0));\n}\n\nint main() {\n    int N, M;\n    string U;\n    cin >> N >> M;\n    cin >> U;\n    vector<int> A(N);\n    for (int i = 0; i < N; i++) cin >> A[i];\n\n    g.resize(N + 2);\n    int ss = g.size() - 1;\n    int tt = g.size() - 2;\n\n    for (int i = 0; i < N; i++) {\n        int l = U[i] == 'L' ? 0 : A[i];\n        int r = U[i] == 'R' ? 0 : A[i];\n        add(ss, i, l);\n        add(i, tt, r);\n    }\n    for (int i = 0; i < M; i++) {\n        int S, T, B;\n        cin >> S >> T >> B;\n        --S, --T;\n        if (S > T) swap(S, T);\n        add(S, T, B);\n    }\n\n    cout << maximumFlow(g, ss, tt) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\n#define MAX_V 510\n\n//// max flow(Dinic)\nstruct edge{ int to,cap,rev; };\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front(); que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,M;\n  cin>>N>>M;\n  string S;\n  cin>>S;\n\n  int source=N,sink=N+1;\n  rep(i,N){\n    int a;\n    cin>>a;\n    if(S[i]=='L'){\n      add_edge(source,i,a);\n      add_edge(i,sink,0);\n    }else{\n      add_edge(source,i,0);\n      add_edge(i,sink,a);\n    }\n  }\n\n  rep(i,M){\n    int s,t,b;\n    cin>>s>>t>>b;\n    s--;t--;\n    if(s>t)swap(s,t);\n    add_edge(t,s,b);\n  }\n  cout<<max_flow(source,sink)<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class C>\nstruct MaxFlow {\n    C flow;\n    V<char> dual;\n};\n\ntemplate <class C, class E>\nstruct MFExec {\n    static constexpr C INF = numeric_limits<C>::max();\n    C eps;\n    VV<E>& g;\n    int s, t;\n    V<int> level, iter;\n\n    C dfs(int v, C f) {\n        if (v == t) return f;\n        C res = 0;\n        for (int& i = iter[v]; i < int(g[v].size()); i++) {\n            E& e = g[v][i];\n            if (e.cap <= eps || level[v] >= level[e.to]) continue;\n            C d = dfs(e.to, min(f, e.cap));\n            e.cap -= d;\n            g[e.to][e.rev].cap += d;\n            res += d;\n            f -= d;\n            if (f == 0) break;\n        }\n        return res;\n    }\n\n    MaxFlow<C> info;\n    MFExec(VV<E>& _g, int _s, int _t, C _eps)\n            : eps(_eps), g(_g), s(_s), t(_t) {\n        int N = int(g.size());\n\n        C& flow = (info.flow = 0);\n        while (true) {\n            queue<int> que;\n            level = V<int>(N, -1);\n            level[s] = 0;\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front(); que.pop();\n                for (E e: g[v]) {\n                    if (e.cap <= eps || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n            if (level[t] == -1) break;\n            iter = V<int>(N, 0);\n            while (true) {\n                C f = dfs(s, INF);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        for (int i = 0; i < N; i++) info.dual.push_back(level[i] == -1);\n    }\n};\n\ntemplate <class C, class E> MaxFlow<C> get_mf(VV<E>& g, int s, int t, C eps) {\n    return MFExec<C, E>(g, s, t, eps).info;\n}\n\nstruct E {\n    int to, rev; ll cap;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    string st;\n    cin >> st;\n    VV<E> g(2 + n);\n    int sv = n, tv = sv + 1;\n    auto add_edge = [&](int from, int to, ll cap) {\n        g[from].push_back(E{to, int(g[to].size()), cap});\n        g[to].push_back(E{from, int(g[from].size()) - 1, 0});\n    };\n\n    for (int i = 0; i < n; i++) {\n        ll a;\n        cin >> a;\n        if (st[i] == 'L') {\n            add_edge(sv, i, a);\n        } else {\n            add_edge(i, tv, a);\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int s, t; ll b;\n        cin >> s >> t >> b; s--; t--;\n        if (s > t) swap(s, t);\n        add_edge(t, s, b);\n    }\n\n    auto mf = get_mf(g, sv, tv, 0LL);\n    cout << mf.flow << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\nint inf = 1e9;\nstruct edge{int to, cap, rev;};\nvector<edge> G[10010];\nint level[10010];\nint iter[10010];\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to,cap,(int) G[to].size()});\n\tG[to].push_back((edge){from,0,(int) G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> Q;\n\tlevel[s] = 0;\n\tQ.push(s);\n\twhile(!Q.empty()){\n\t\tint v = Q.front(); Q.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to]<0){\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(level[v]<level[e.to] && e.cap>0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,inf))>0) flow += f;\n\t}\n}\n\nint N,M;\nchar U[510];\nint A[510];\n\nint main(){\n    cin >> N >> M;\n    for(int i=1;i<=N;i++) cin >> U[i];\n    for(int i=1;i<=N;i++){\n        cin >> A[i];\n        if(U[i]=='L'){\n            add_edge(0,i,A[i]);\n            add_edge(i,N+1,0);\n        }else{\n            add_edge(0,i,0);\n            add_edge(i,N+1,A[i]);\n        }\n    }\n    int x,y,b;\n    for(int i=1;i<=M;i++){\n        cin >> x >> y >> b;\n        if(x>y) swap(x,y);\n        add_edge(y,x,b);\n    }\n    cout << max_flow(0,N+1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define int long long\nusing namespace std;\n\nconst int INF = 1e18;\n\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n\treturn vector<T>(x, a);\n}\n\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n\tauto cont = vectors(y, z, zs...);\n\treturn vector<decltype(cont)>(x, cont);\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n\tprivate:\n\t\tvector<Edge> G[MAX_V];\n\t\tbool used[MAX_V];\n\t\tint level[MAX_V]; //sからの距離\n\t\tint iter[MAX_V]; //どこまで調べ終わったか\n\t\tint dfs(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tused[v] = true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(not used[e.to] && e.cap > 0){\n\t\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint dfs_(int v, int t, int f){\n\t\t\tif(v == t) return f;\n\t\t\tfor(int &i = iter[v]; i < G[v].size(); i++){\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\t\t\tint d = dfs_(e.to, t, min(f, e.cap));\n\t\t\t\t\tif(d > 0){\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tvoid bfs(int s){\n\t\t\tmemset(level, -1, sizeof(level));\n\t\t\tqueue<int> que;\n\t\t\tlevel[s] = 0;\n\t\t\tque.push(s);\n\t\t\twhile(not que.empty()){\n\t\t\t\tint v = que.front(); que.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvoid addEdge(int from, int to, int cap){\n\t\t\tG[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n\t\t\tG[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n\t\t}\n\t\tint fordFulkerson(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif(f == 0) return flow;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\tint dinic(int s, int t){\n\t\t\tint flow = 0;\n\t\t\twhile(true){\n\t\t\t\tbfs(s);\n\t\t\t\tif(level[t] < 0) return flow;\n\t\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\t\tint f;\n\t\t\t\twhile( (f = dfs_(s, t, INF)) > 0){\n\t\t\t\t\tflow += f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\nsigned main(){\n\tint n, m;\n\tstring u;\n\tcin >> n >> m >> u;\n\n\tFlow f;\n\n\tint S = MAX_V - 2, T = S + 1;\n\trep(i,n){\n\t\tint a;\n\t\tcin >> a;\n\t\tif(u[i] == 'R'){\n\t\t\tf.addEdge(S, i, a);\n\t\t}else{\n\t\t\tf.addEdge(i, T, a);\n\t\t}\n\t}\n\n\trep(i,m){\n\t\tint s, t, b;\n\t\tcin >> s >> t >> b;\n\t\ts--; t--;\n\t\tif(s > t) swap(s,t);\n\n\t\tf.addEdge(s, t, b);\n\t}\n\tcout << f.dinic(S, T) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\n// Dinic法\nclass Dinic {\nprivate:\n\tstruct Edge {\n\t\tint to, cap, rev;\n\t\tEdge(int t, int c, int r) :to(t), cap(c), rev(r) {}\n\t};\n\tint V;\n\tstd::vector<std::vector<Edge>> graph;\n\tstd::vector<int> level, iter;\n\npublic:\n\tDinic(int v) : V(v) {\n\t\tgraph.resize(v);\n\t\tlevel.resize(v, -1);\n\t\titer.resize(v, 0);\n\t}\n\t// fromからtoへ向かう容量capの辺をグラフに追加する\n\tvoid addEdge(int from, int to, int cap) {\n\t\tgraph[from].emplace_back(to, cap, graph[to].size());\n\t\tgraph[to].emplace_back(from, 0, graph[from].size() - 1);\n\t}\n\n\t// sからの最短距離をBFSで計算する\n\tvoid bfs(int s) {\n\t\tstd::fill(level.begin(), level.end(), -1);\n\t\tstd::queue<int> queue;\n\t\tlevel[s] = 0;\n\t\tqueue.push(s);\n\t\twhile (!queue.empty()) {\n\t\t\tint v = queue.front(); queue.pop();\n\t\t\tfor (int i = 0; i < graph[v].size(); ++i) {\n\t\t\t\tEdge& e = graph[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tqueue.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 増加パスをDFSで探す\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int& i = iter[v]; i < graph[v].size(); ++i) {\n\t\t\tEdge& e = graph[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, std::min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// sからtへの最大流を求める\n\tint maxFlow(int s, int t) {\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return res;\n\t\t\tstd::fill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, (1LL << 31) - 1)) > 0) {\n\t\t\t\tres += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVAR(std::string, u);\n\tVEC(int, a, n);\n\n\tDinic dn(n + 2);\n\tconst int S = n, T = n + 1;\n\n\tREP(i, n) {\n\t\tif (u[i] == 'L') dn.addEdge(S, i, 0), dn.addEdge(i, T, a[i]);\n\t\telse dn.addEdge(S, i, a[i]), dn.addEdge(i, T, 0);\n\t}\n\tREP(_, m) {\n\t\tVAR(int, s, t, b); --s; --t;\n\t\tif (s > t) std::swap(s, t);\n\t\tdn.addEdge(s, t, b);\n\t}\n\n\tOUT(dn.maxFlow(S, T))BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n//Dinic O(EV^2)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nstruct MF{\n\tvector<vector<pair<pair<int,int>,T> > >G;\n\tvector<int>level,iter;\n\tMF(int n_=0):G(n_),level(n_),iter(n_){}\n\tvoid add_edge(int from,int to,T cap)\n\t{\n\t\tG[from].push_back(make_pair(\n\t\t\tmake_pair(to,G[to].size()),cap\n\t\t));\n\t\tG[to].push_back(make_pair(\n\t\t\tmake_pair(from,G[from].size()-1),0\n\t\t));\n\t}\n\tT dfs(int u,int t,T f)\n\t{\n\t\tif(u==t)return f;\n\t\tfor(;iter[u]<G[u].size();iter[u]++)\n\t\t{\n\t\t\tpair<pair<int,int>,T>&e=G[u][iter[u]];\n\t\t\tif(e.second>0&&level[u]<level[e.first.first])\n\t\t\t{\n\t\t\t\tT d=dfs(e.first.first,t,min(f,e.second));\n\t\t\t\tif(d>0)\n\t\t\t\t{\n\t\t\t\t\te.second-=d;\n\t\t\t\t\tG[e.first.first][e.first.second].second+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s,int t)\n\t{\n\t\tT ret=0;\n\t\tfor(;;)\n\t\t{\n\t\t\tfill(level.begin(),level.end(),-1);\n\t\t\tqueue<int>P;\n\t\t\tlevel[s]=0;\n\t\t\tP.push(s);\n\t\t\twhile(!P.empty())\n\t\t\t{\n\t\t\t\tint u=P.front();P.pop();\n\t\t\t\tfor(pair<pair<int,int>,T>&e:G[u])\n\t\t\t\t{\n\t\t\t\t\tif(e.second>0&&level[e.first.first]<0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlevel[e.first.first]=level[u]+1;\n\t\t\t\t\t\tP.push(e.first.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(level[t]<0)return ret;\n\t\t\tfill(iter.begin(),iter.end(),0);\n\t\t\tfor(T f;(f=dfs(s,t,numeric_limits<T>::max()))>0;)ret+=f;\n\t\t}\n\t}\n};\nint n,m;\nstring u;\nmain()\n{\n\tcin>>n>>m>>u;\n\tMF<long long>mf(n+2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long a;cin>>a;\n\t\tif(u[i]=='L')\n\t\t{\n\t\t\tmf.add_edge(0,i+1,0);\n\t\t\tmf.add_edge(i+1,n+1,a);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmf.add_edge(0,i+1,a);\n\t\t\tmf.add_edge(i+1,n+1,0);\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint s,t;\n\t\tlong long b;\n\t\tcin>>s>>t>>b;\n\t\tif(s<t)mf.add_edge(s,t,b);\n\t\telse mf.add_edge(t,s,b);\n\t}\n\tcout<<mf.max_flow(0,n+1)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\ntemplate< typename T >\nstruct Dinic\n{\n  struct edge\n  {\n    int to;\n    T cap;\n    int rev;\n  };\n\n  const T INF;\n  vector< vector< edge > > graph;\n  vector< T > min_cost;\n  vector< int > iter;\n\n  Dinic(int n) : INF(numeric_limits< T >::max())\n  {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, T cap)\n  {\n    graph[from].push_back((edge) {to, cap, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  bool bfs(int s, int t)\n  {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int p = que.front();\n      que.pop();\n      for(auto &e : graph[p]) {\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return (min_cost[t] != -1);\n  }\n\n  T dfs(int idx, const int t, T flow)\n  {\n    if(idx == t) return (flow);\n    for(int &i = iter[idx]; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        T d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  T max_flow(int s, int t)\n  {\n    T flow = 0;\n    while(bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      T f = 0;\n      while((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return (flow);\n  }\n};\n\nsigned main(){\n    int n, m;\n    string u;\n    cin >> n >> m >> u;\n    vector<int> a(n);\n    for(auto& x : a)\n        cin >> x;\n    vector<vector<int>> v(n, vector<int>(n, 0));\n    for(int i = 0; i < m; ++i){\n        int s, t, b;\n        cin >> s >> t >> b;\n        --s, --t;\n        if(s > t)\n            swap(s, t);\n        v[s][t] += b;\n    }\n    Dinic<i64> Segtree(n + 2);\n    for(int i = 0; i < n; ++i){\n        Segtree.add_edge(n, i, u[i] == 'R' ? a[i] : 0);\n        Segtree.add_edge(i, n + 1, u[i] == 'L' ? a[i] : 0);\n    }\n    for(int i = 0; i < n; ++i){\n        for(int j = i + 1; j < n; ++j){\n            if(v[i][j]){\n                Segtree.add_edge(i, j, v[i][j]);\n            }\n        }\n    }\n    cout << Segtree.max_flow(n, n + 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nconst ll INF = 1ll<<60;\n// Dinic http://www.prefield.com/algorithm/graph/dinic.html\nstruct dinic{\n  struct edge{int to;ll cost;};\n  int n;\n  vector< vector<edge> > G;\n  vector<vl> flow, capacity;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    flow.assign(n,vl(n,0));\n    capacity.assign(n,vl(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,ll cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    G[from].push_back((edge){to,cost});\n    G[to].push_back((edge){from,0ll});  // 逆に流すフローのためのダミー辺\n  }\n  ll dfs(int u, int t, ll cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,G[u].size()){\n      edge e = G[u][i];\n      if(level[e.to] > level[u]){\n        ll f = dfs(e.to, t, min(cur, RESIDUE(u,e.to)));\n        if(f>0){\n          flow[u][e.to] += f;\n          flow[e.to][u] -= f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  ll calc(int s, int t){\n    REP(i,n)REP(j,n)flow[i][j]=capacity[i][j]=0;\n    REP(u,n)REP(j,G[u].size()){\n      edge e = G[u][j];\n      capacity[u][e.to] += e.cost;\n    }\n    ll total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,G[u].size()){\n          edge e = G[u][i];\n          if(RESIDUE(u,e.to) > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        ll f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nint n,m;\nchar u[525];\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  dinic D(n+2);\n  const int S = n;\n  const int T = n+1;\n  scanf(\"%s\",u);\n  REP(i,n){\n    int a;\n    scanf(\"%d\",&a);\n    if(u[i]=='L'){\n      D.add_edge(S,i,0);\n      D.add_edge(i,T,a);\n    }else{\n      D.add_edge(S,i,a);\n      D.add_edge(i,T,0);\n    }\n  }\n  REP(i,m){\n    int s,t,b;\n    scanf(\"%d%d%d\",&s,&t,&b);\n    --s;--t;\n    if(s>t)swap(s,t);\n    D.add_edge(s,t,b);\n  }\n  printf(\"%lld\\n\",D.calc(S,T));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nusing i8 = ::std::int_least8_t;\nusing i32 = ::std::int_least32_t;\nusing i64 = ::std::int_least64_t;\nusing u8 = ::std::uint_least8_t;\nusing u32 = ::std::uint_least32_t;\nusing u64 = ::std::uint_least64_t;\nusing isize = ::std::ptrdiff_t;\nusing usize = ::std::size_t;\n\ntemplate <class T = usize> class rep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend rep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr rep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(f); }\n\tconstexpr itr end() const noexcept { return itr(l); }\n};\ntemplate <class T = usize> class revrep {\n\tconst T f, l;\n\npublic:\n\tclass itr {\n\t\tfriend revrep;\n\t\tT i;\n\t\tconstexpr itr(T x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\tconstexpr T operator*() const noexcept { return i; }\n\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\tconstexpr revrep(const T first, const T last) noexcept : f(first), l(last) {}\n\tconstexpr itr begin() const noexcept { return itr(l - 1); }\n\tconstexpr itr end() const noexcept { return itr(f - 1); }\n};\ntemplate <class T> bool amax(T &a, const T &b) {\n\treturn a <= b ? (a = b, 1) : 0;\n}\ntemplate <class T> bool amin(T &a, const T &b) {\n\treturn b <= a ? (a = b, 1) : 0;\n}\ntemplate <class T> bool asmax(T &a, const T &b) {\n\treturn b <= a ? 0 : (a = b, 1);\n}\ntemplate <class T> bool asmin(T &a, const T &b) {\n\treturn a <= b ? 0 : (a = b, 1);\n}\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class T> auto md_vec(usize n, const T &value) {\n\treturn ::std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(usize n, Args... args) {\n\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> const T &as_const(const T &v) noexcept { return v; }\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n\treturn a <= b ? b - a : a - b;\n}\n\n#include <cassert>\n#include <iterator>\n#include <utility>\n\ntemplate <class Monoid, template <class> class Container> class segment_tree {\npublic:\n\tusing value_structure = Monoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing container_type = Container<value_type>;\n\tusing const_reference = typename container_type::const_reference;\n\tusing size_type = typename container_type::size_type;\n\nprotected:\n\tstatic size_type getsize(const size_type size) {\n\t\tsize_type ret = 1;\n\t\twhile (ret < size)\n\t\t\tret <<= 1;\n\t\treturn ret;\n\t}\n\n\tsize_type size_;\n\tcontainer_type tree;\n\n\tsize_type base_size() const { return tree.size() >> 1; }\n\tvoid recalc(const size_type index) {\n\t\ttree[index] =\n\t\t\tvalue_structure::operation(tree[index << 1], tree[index << 1 | 1]);\n\t}\n\npublic:\n\tsegment_tree() : size_(0), tree() {}\n\texplicit segment_tree(const size_type size)\n\t\t: size_(size), tree(getsize(size) << 1, value_structure::identity()) {}\n\ttemplate <class InputIterator>\n\tsegment_tree(InputIterator first, InputIterator last)\n\t\t: size_(::std::distance(first, last)), tree() {\n\t\tconst size_type cap = getsize(size_);\n\t\ttree.reserve(cap << 1);\n\t\ttree.resize(cap, value_structure::identity());\n\t\ttree.insert(tree.end(), first, last);\n\t\ttree.resize(cap << 1, value_structure::identity());\n\t\tfor (size_type i = cap - 1; i; --i)\n\t\t\trecalc(i);\n\t}\n\n\tbool empty() const { return !size_; }\n\tsize_type size() const { return size_; }\n\n\tconst_reference operator[](const size_type index) const {\n\t\tassert(index < size());\n\t\treturn tree[index + base_size()];\n\t}\n\tvalue_type fold(size_type first, size_type last) const {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tvalue_type ret_l = value_structure::identity(),\n\t\t\tret_r = value_structure::identity();\n\t\tfor (first += base_size(), last += base_size(); first < last;\n\t\t\tfirst >>= 1, last >>= 1) {\n\t\t\tif (first & 1)\n\t\t\t\tret_l = value_structure::operation(::std::move(ret_l), tree[first++]);\n\t\t\tif (last & 1)\n\t\t\t\tret_r = value_structure::operation(tree[last - 1], ::std::move(ret_r));\n\t\t}\n\t\treturn value_structure::operation(::std::move(ret_l), ::std::move(ret_r));\n\t}\n\ttemplate <class F> size_type search(const F &f) const {\n\t\tif (f(value_structure::identity()))\n\t\t\treturn 0;\n\t\tif (!f(tree[1]))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile (i < base_size())\n\t\t\tif (!f(value_structure::operation(acc, tree[i <<= 1])))\n\t\t\t\tacc = value_structure::operation(::std::move(acc), tree[i++]);\n\t\treturn i - base_size() + 1;\n\t}\n\n\ttemplate <class F> void update(size_type index, const F &f) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\ttree[index] = f(::std::move(tree[index]));\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n};\n\n\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <numeric>\n#include <set>\n#include<array>\n#include<queue>\n\nnamespace std {\n\tu64 inf = static_cast<u64>(1) << 55;\n\n\tstruct max_flow {\n\t\tstruct edge { int to;u64 cap;int rev; };\n\t\tint V;\n\t\tvector<vector<edge>> G;\n\t\tvector<int> itr, level;\n\n\t\tmax_flow(u64 V) : V(V) { G.assign(V, vector<edge>()); }\n\n\t\tvoid add_edge(int from, int to, u64 cap) {\n\t\t\tG[from].push_back({ to, cap, (int)G[to].size() });\n\t\t\tG[to].push_back({ from, 0, (int)G[from].size() - 1 });\n\t\t}\n\n\t\tvoid bfs(int s) {\n\t\t\tlevel.assign(V, -1);\n\t\t\tqueue<int> q;\n\t\t\tlevel[s] = 0; q.push(s);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint v = q.front(); q.pop();\n\t\t\t\tfor (auto &e : G[v]) {\n\t\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tu64 dfs(int v, int t, u64 f) {\n\t\t\tif (v == t) return f;\n\t\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\t\tedge& e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\t\tu64 d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tu64 run(int s, int t) {\n\t\t\tu64 ret = 0, f;\n\t\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\t\titr.assign(V, 0);\n\t\t\t\twhile ((f = dfs(s, t, inf)) > 0) ret += f;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n}\n\n#include<string>\n\nint main() {\n\tusize n, m;\n\tstd::cin >> n >> m;\n\n\tstd::max_flow f(n + 2);\n\tconst usize l = n, r = n + 1;\n\n\tstd::string u;\n\tstd::cin >> u;\n\tfor (const auto i : rep<>(0, n)) {\n\t\tu64 a;\n\t\tstd::cin >> a;\n\t\tif (u[i] == 'L') {\n\t\t\tf.add_edge(l, i, a);\n\t\t}\n\t\telse {\n\t\t\tf.add_edge(i, r, a);\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tusize s, t;\n\t\tu64 b;\n\t\tstd::cin >> s >> t >> b;\n\t\t--s;\n\t\t--t;\n\t\tif (s > t) {\n\t\t\tstd::swap(s, t);\n\t\t}\n\t\tf.add_edge(t, s, b);\n\t}\n\n\tstd::cout << f.run(l, r) << std::endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}}star;\n#define DEBUG if(0)\n#endif\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\nclass reverse_range {private:struct I {int x;int operator*() {return x-1;}bool operator!=(I& lhs) {return x>lhs.x;}void operator++() {--x;}};I i, n;public:reverse_range(int n) :i({ 0 }), n({ n }){}reverse_range(int i, int n) :i({ i }), n({ n }){}I& begin() {return n;}I& end() {return i;}};\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }reverse_range operator!(){return reverse_range(*i,*n);}};\n\n\nint N,M;\nstring S;\nLL A[1123];\nint a[1123];\nint b[1123];\nLL B[1123];\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n\nusing FLOW = LL;\nnamespace flow{\n    constexpr FLOW INF = 1e12;\n    struct edge{\n        FLOW flow;\n        int to,rev;\n    };\n    typedef vector<edge> E;\n    typedef vector<E> Graph;\n    void addedge(Graph&g,int from,int to,FLOW f){\n        int x=g[from].size();\n        int y=g[to].size();\n        g[from].pb(edge{f,to,y});\n        g[to].pb(edge{(FLOW)0,from,x});\n    }\n\n    vector<int> bfs(Graph& G,int s){\n        int N = G.size();\n        queue<int> que;\n        vector<int> dist(N,-1);\n        dist[s] = 0;\n        que.push(s);\n        for(;!que.empty();que.pop()){\n            auto v=que.front();\n            for(auto& e : G[v])\n                if(e.flow>0&&dist[e.to]==-1){\n                    dist[e.to] = dist[v] + 1;\n                que.push(e.to);\n                }\n        }\n        return dist;\n    }\n}\nFLOW maxflow(flow::Graph& G,int s,int t){\n    using namespace flow;\n    FLOW res=0;\n    int N = G.size();\n    while(true){\n        auto dist = bfs(G,s);\n        if(dist[t] < 0)break;\n        vector<unsigned> iter(N,0);\n        std::function<FLOW(int,FLOW)> dfs=[&](int v,FLOW f){\n            if(v==s)return f;\n            for(auto &i = iter[v]; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                edge &re = G[e.to][e.rev];\n                if(re.flow>0 && dist[v] >dist[e.to]){\n                    FLOW d=dfs(e.to,min(f,re.flow));\n                    if(d>0){e.flow+=d;re.flow-=d;return d;}\n                }\n            }\n            return (FLOW)0;\n        };\n        FLOW f;\n        while((f=dfs(t,INF))> 0)res+=f;\n    }\n    return res;\n}\n\nint main(){\n    cin>>N>>M>>S;\n    for(int i:range(N))cin>>A[i];\n    int size=N;\n    int SS=size++;\n    int GG=size++;\n    for(int i:range(M)){\n        cin>>a[i]>>b[i]>>B[i];\n        a[i]--;b[i]--;\n        if(a[i]>b[i])swap(a[i],b[i]);\n    }\n    flow::Graph g(size);\n    for(int i:range(N)){\n        if(S[i]=='L'){\n            flow::addedge(g,SS,i,A[i]);\n        }\n        else{\n            flow::addedge(g,i,GG,A[i]);\n        }\n    }\n    for(int i:range(M)){\n        string X=string(1,S[a[i]])+string(1,S[b[i]]);\n        //cerr <<X << endl;\n        flow::addedge(g,b[i],a[i],B[i]);\n        /*\n        if(X==\"LL\"){\n            flow::addedge(g,a[i],b[i],B[i]);\n        }\n        if(X==\"LR\"){\n            flow::addedge(g,a[i],b[i],B[i]);\n        }\n        if(X==\"RL\"){\n            flow::addedge(g,a[i],b[i],B[i]);\n        }\n        if(X==\"RR\"){\n            flow::addedge(g,a[i],b[i],B[i]);\n        }\n        */\n\n    }\n    cout <<maxflow(g,SS,GG)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n#define MAX_N 30000\nclass Dinic {\npublic:\n  struct Edge { int to, cap, rev; };\n  vector<Edge> G[MAX_N];\n  int level[MAX_N], iter[MAX_N];\n\n  void add_edge(int from, int to, int cap) {\n    G[from].pb((Edge) { to, cap, (int)G[to].size() });\n    G[to].pb((Edge) { from, 0, (int)G[from].size() - 1 });\n  }\n\n  void bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int x = q.front(); q.pop();\n      for (int i=0; i<G[x].size(); i++) {\n        Edge &e = G[x][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[x] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int x, int t, int f) {\n    if (x == t) return f;\n    for (int &i=iter[x]; i<G[x].size(); i++) {\n      Edge &e = G[x][i];\n      if (e.cap > 0 && level[x] < level[e.to]) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      int f;\n      while (true) {\n        f = dfs(s, t, INF);\n        if (f <= 0) break;\n        flow += f;\n        if (flow >= INF) return INF;\n      }\n    }\n  }\n};\n\n\nint N, M;\nchar U[501];\nint A[500];\nDinic dinic;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  cin >> U;\n  rep(i, N) cin >> A[i];\n\n  int S = N, T = N+1;\n  rep(i, N) {\n    if (U[i] == 'R') {\n      dinic.add_edge(S, i, A[i]);\n    }\n    else {\n      dinic.add_edge(i, T, A[i]);\n    }\n  }\n  rep(i, M) {\n    int s, t, b;\n    cin >> s >> t >> b;\n    s--, t--;\n    if (s > t) swap(s, t);\n    dinic.add_edge(s, t, b);\n  }\n  cout << dinic.max_flow(S, T) << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n//Dinic\n\n#define SIZE 505\n\n\n//辺を表す構造体(行先、容量、逆辺のインデックス)\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t}\n\tint to,capacity,rev_index;\n};\n\nstruct Info{\n\n\tint a,b,cost;\n};\n\nint V,E;\n\nvector<Edge> G[SIZE]; //グラフの隣接リスト表現\nint dist[SIZE]; //sourceからの距離\nint cheked_index[SIZE]; //どこまで調べ終わったか\nint A[SIZE];\nchar buf[SIZE];\nInfo info[1005];\n\n\n//fromからtoへ向かう容量capacityの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size()));\n\tG[to].push_back(Edge(from,0,G[from].size()-1)); //逆辺の、初期容量は0\n}\n\n//sourceからの最短距離をBFSで計算する\nvoid bfs(int source){\n\tfor(int i = 0; i < V; i++)dist[i] = -1;\n\tqueue<int> Q;\n\tdist[source] = 0;\n\tQ.push(source);\n\n\twhile(!Q.empty()){\n\t\tint node_id = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tEdge &e = G[node_id][i];\n\t\t\tif(e.capacity > 0 && dist[e.to] < 0){ //辺の容量が正で、かつエッジの行先に未訪問の場合\n\t\t\t\tdist[e.to] = dist[node_id]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//増加パスをDFSで探す\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow; //終点についたらflowをreturn\n\n\tfor(int &i = cheked_index[node_id]; i < G[node_id].size(); i++){ //node_idから出ているエッジを調査\n\t\tEdge &e = G[node_id][i];\n\t\tif(e.capacity > 0 && dist[node_id] < dist[e.to]){ //流せる余裕があり、かつsourceからの距離が増加する方法である場合\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity)); //流せるだけ流す\n\t\t\tif(tmp_flow > 0){ //流せた場合\n\t\t\t\te.capacity -= tmp_flow; //流した分、エッジの容量を削減する\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow; //逆辺の容量を、流した分だけ増加させる\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//sourceからsinkへの最大流を求める\nint max_flow(int source,int sink){ //source:始点 sink:終点\n\tint flow = 0,add;\n\twhile(true){ //増加パスが存在する限り、流量を追加し続ける\n\t\tbfs(source);\n\t\tif(dist[sink] < 0)break; //sourceからsinkへと辿り着く残余グラフがない、つまり増加パスが無くなった場合、break\n\t\tfor(int i = 0; i < V; i++)cheked_index[i] = 0;\n\t\twhile((add = dfs(source,sink,BIG_NUM)) > 0){ //増加パスが見つかる間、加算\n\t\t\tflow += add;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\nint main(){\n\n\tint N,M;\n\tscanf(\"%d %d\",&N,&M);\n\tV = N+2;\n\n\tscanf(\"%s\",buf);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d\",&A[i]);\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%d %d %d\",&info[i].a,&info[i].b,&info[i].cost);\n\t\tinfo[i].a--;\n\t\tinfo[i].b--;\n\n\t\tif(info[i].a > info[i].b){\n\n\t\t\tswap(info[i].a,info[i].b);\n\t\t}\n\t}\n\n\tint source = N,sink = N+1;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(buf[i] == 'L'){\n\n\t\t\tadd_edge(source,i,A[i]);\n\t\t\tadd_edge(i,sink,0);\n\n\t\t}else{\n\n\t\t\tadd_edge(source,i,0);\n\t\t\tadd_edge(i,sink,A[i]);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\n\t\tadd_edge(info[i].b,info[i].a,info[i].cost);\n\t}\n\n\n\tprintf(\"%d\\n\",max_flow(source,sink));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<class T>\nstruct dinic {\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n        bool isrev;\n    };\n\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n\n    void bfs(int s) {\n        level.assign(G.size(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(que.size()) {\n            int v = que.front(); que.pop();\n            for(auto i: G[v]) {\n                if(i.cap > 0 && level[i.to] < 0) {\n                    level[i.to] = level[v] + 1;\n                    que.push(i.to);\n                }\n            }\n        }\n    }\n\n    T dfs(int v, const int t, T f) {\n        if(v == t) return f;\n        for(int &i = iter[v]; i<(ll)G[v].size(); ++i) {\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    dinic() {}\n    dinic(int n) : G(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back({to, cap, (int)G[to].size(), false});\n        G[to].push_back({from, 0, (int)G[from].size()-1, true});\n    }\n\n    // sからtへ流量fを流す\n    T maxflow(int s, int t, T f = 1LL<<30) {\n        T flow = 0;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(G.size(), 0);\n            T tmp;\n            while((tmp = dfs(s, t, f)) > 0) flow += tmp;\n        }\n    }\n\n    // sからtへ1流す\n    T flow(int s, int t) {\n        bfs(s);\n        if(level[t] < 0) return 0;\n        iter.assign(G.size(), 0);\n        return dfs(s, t, 1);\n    }\n    // 始点，終点tのフローで辺e=(from,to)の容量を1増やしたときの最大流の変化\n    // 並列辺はたぶんバグる\n    T add(int from, int to, int s, int t) {\n        for(auto &e: G[from]) {\n            if(e.to == to && !e.isrev) {\n                e.cap++;\n                break;\n            }\n        }\n        return flow(s, t);\n    }\n    // 始点s，終点tのフローで辺e=(from,to)の容量を1減らしたときの最大流の変化\n    // 並列辺はたぶんバグる\n    T sub(int from, int to, int s, int t) {\n        for(auto &e: G[from]) {\n            if(e.to == to && !e.isrev) {\n                T diff = 0;\n                // 辺(from,to)で容量いっぱいに流れている\n                if(e.cap == 0) {\n                    // 残余グラフでfrom→toのパスがない\n                    if(flow(from, to) == 0) {\n                        flow(t, to);\n                        flow(from, s);\n                        diff = -1;\n                    }\n                    G[e.to][e.rev].cap--;\n                } else {\n                    e.cap--;\n                }\n                return diff;\n            }\n        }\n        assert(false); // 存在しない辺を減らそうとした\n    }\n\n    friend ostream &operator <<(ostream& out, const dinic& a){\n        out << endl;\n        for(int i = 0; i < (int)a.G.size(); i++) {\n            for(auto &e : a.G[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = a.G[e.to][e.rev];\n                out << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n        return out;\n    }\n};\n\nint main(void) {\n    ll n, m;\n    string u;\n    cin >> n >> m >> u;\n    vector<ll> a(n);\n    REP(i, n) cin >> a[i];\n    vector<ll> x(m), y(m), z(m);\n    REP(i, m) {\n        cin >> x[i] >> y[i] >> z[i];\n        x[i]--, y[i]--;\n        if(x[i] > y[i]) swap(x[i], y[i]);\n    }\n\n    dinic<ll> graph(n+2);\n    ll s = n, t = n+1;\n\n    REP(i, n) {\n        if(u[i]=='R') {\n            graph.add_edge(s, i, 0);\n            graph.add_edge(i, t, a[i]);\n        } else {\n            graph.add_edge(s, i, a[i]);\n            graph.add_edge(i, t, 0);\n        }\n    }\n    REP(i, m) graph.add_edge(y[i], x[i], z[i]);\n    \n    cout << graph.maxflow(s, t) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Network{\n\tprivate:\n\tint V;\n\tstruct edge{\n\t\tint to,cap,rev;\n\t};\n\tvector<vector<edge> > g;\n\tint DFS(int v,int t,int f,vi& iter,vi level){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<g[v].size();i++){\n\t\t\tedge &e=g[v][i];\n\t\t\tif(e.cap>0&&level[v]<level[e.to]){\n\t\t\t\tint d=DFS(e.to,t,min(f,e.cap),iter,level);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid BFS(int s,vi& level){\n\t\tlevel=vi(V,-1);\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\tedge &e=g[v][i];\n\t\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic:\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tg[s].push_back(edge{t,c,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,0,(int)g[s].size()-1});\n\t}\n\tint Dinic(int s,int t){\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tvi iter(V),level;\n\t\t\tBFS(s,level);\n\t\t\tif(level[t]<0) return res;\n\t\t\tint f;\n\t\t\twhile((f=DFS(s,t,inf,iter,level))>0) res+=f;\n\t\t}\n\t}\n};\n\nint n,m;\nstring s;\nvi a;\n\nint main(){\n\tcin>>n>>m>>s;\n\tNetwork nt(n+2);\n\tfor(int i=0;i<n;i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tnt.add_edge(n,i,(s[i]=='L'?0:x));\n\t\tnt.add_edge(i,n+1,(s[i]=='L'?x:0));\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tcin>>u>>v>>c;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tnt.add_edge(u,v,c);\n\t}\n\tcout<<nt.Dinic(n,n+1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct Graph {\n  struct edge {\n    int to;\n    i64 cap;\n    i64 rev;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\nstruct Dinic {\n  int N;\n  vector<int> level;\n  vector<int> itr;\n  Graph G;\n\n  Dinic(int n) : G(n) { N = n; }\n\n  void add_edge(int from, int to, i64 cap, i64 rev_cap) {\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1});\n  }\n\n  bool g_level(int s, int t) {\n    level.assign(N, -1);\n    queue<int> que;\n    que.push(s);\n    level[s] = 0;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (auto &e : G[v]) {\n        if (e.cap > 0 && level[e.to] == -1) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return level[t] >= 0;\n  }\n\n  i64 dfs(int v, int t, i64 f) {\n    if (v == t) return f;\n\n    for (int &i = itr[v]; i < G[v].size(); i++) {\n      auto &e = G[v][i];\n      if (e.cap > 0 && level[e.to] > level[v]) {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0) {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n\n  i64 max_flow(int s, int t) {\n    i64 result = 0;\n    i64 flow;\n    while (g_level(s, t)) {\n      itr.assign(N, 0);\n      while ((flow = dfs(s, t, 1e9)) > 0) result += flow;\n    }\n    return result;\n  }\n};\n\n/*\nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\n\nint N,M;\n\nstring U;\n\ni64 A[505];\n\ni64 S[1010];\ni64 T[1010];\ni64 B[1010];\n\ni64 cost[505][505];\n\ni64 f[505];\n\n\nint main() {\n\n  cin >> N >> M;\n  cin >> U;\n  for(int i = 0;i < N;i++) {\n    if(U[i] == 'R') f[i] = 1;\n    else f[i] = -1;\n  }\n  for(int i = 0;i < N;i++) cin >> A[i];\n  for(int j = 0;j < M;j++) cin >> S[j] >> T[j] >> B[j];\n\n  for(int j = 0;j < M;j++) {\n    S[j]--;\n    T[j]--;\n    cost[min(S[j], T[j])][max(S[j], T[j])] += B[j];\n  }\n\n  Dinic pd(N + 10);\n  int s = N;\n  int t = N + 1;\n\n  for(int i = 0;i < N;i++) {\n    if(f[i] == 1) {\n      pd.add_edge(s, i, 0, 0);\n      pd.add_edge(i, t, A[i], 0);\n    }\n    else {\n\n      pd.add_edge(s, i, A[i], 0);\n      pd.add_edge(i, t, 0, 0);\n    }\n    for(int j = i + 1;j < N;j++) {\n      if(cost[i][j] > 0) {\n        pd.add_edge(j, i, cost[i][j], 0);\n      }\n    }\n  }\n\n  cout << pd.max_flow(s, t) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = 1'000'000'007;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\nstruct Dinic {\n\tusing Flow = int;\n\tconst Flow kInfFlow = INF;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap) :to(to), rev(rev), cap(cap) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<bool> used;\n\tvector<int> level;\n\tvector<int> iter;\n\tDinic(int n) :n(n), g(n), used(n), level(n), iter(n) {};\n\tvoid addArc(int from, int to, Flow cap) {\n\t\tdump(from, to, cap);\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, Flow());\n\t}\n\tvoid addEdge(int a, int b, Flow cap) {\n\t\tg[a].emplace_back(b, (int)g[b].size(), cap);\n\t\tg[b].emplace_back(a, (int)g[a].size() - 1, cap);\n\t}\n\tFlow maximumFlow(int s, int t) {\n\t\tFlow total = Flow();\n\t\twhile (true) {\n\t\t\tlevelize(s);\n\t\t\tif (level[t] < 0)return total;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tFlow f;\n\t\t\twhile (true) {\n\t\t\t\tf = augment(s, t, kInfFlow);\n\t\t\t\tif (f == Flow())break;\n\t\t\t\ttotal += f;\n\t\t\t}\n\t\t}\n\t}\n\tFlow augment(int v, int t, Flow f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < g[v].size(); i++) {\n\t\t\tEdge &e = g[v][i];\n\t\t\tif (e.cap > Flow() && level[v] < level[e.to]) {\n\t\t\t\tFlow d = augment(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > Flow()) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Flow();\n\t}\n\tvoid levelize(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile (q.size()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > Flow() && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M; cin >> N >> M;\n\tstring U; cin >> U;\n\tvector<int> A(N); rep(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\n\tvector<int> S(M), T(M), B(M); rep(i, 0, M) {\n\t\tcin >> S[i] >> T[i] >> B[i];\n\t\tS[i]--, T[i]--;\n\t\tif (S[i] > T[i])swap(S[i], T[i]);\n\t}\n\n\tint size = N + 2;\n\tDinic dinic(size);\n\tint s = size - 2;\n\tint t = size - 1;\n\n\trep(i, 0, N) {\n\t\tif (U[i] == 'R') {\n\t\t\tdinic.addArc(s, i, A[i]);\n\t\t}\n\t\telse {\n\t\t\tdinic.addArc(i, t, A[i]);\n\t\t}\n\t}\n\n\trep(i, 0, M) {\n\t\tdinic.addArc(S[i], T[i], B[i]);\n\t}\n\n\tcout << dinic.maximumFlow(s, t) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\ntemplate<typename flow_t>\nstruct FordFulkerson{\n    struct edge{\n        int to;\n        flow_t cap;\n        int rev;\n        bool isrev;\n    };\n    vector<vector<edge>> graph;\n    vector<int> used;\n    const flow_t INF;\n    FordFulkerson(int V):graph(V),used(V),INF(numeric_limits<flow_t>::max()){}\n\n    void add_edge(int from,int to,flow_t cap){\n        graph[from].push_back((edge){to,cap,(int)graph[to].size(),false});\n        graph[to].push_back((edge){from,0,(int)graph[from].size()-1,true});\n    }\n\n    flow_t dfs(int now,int t,flow_t f){\n        if(now==t) return f;\n        used[now]=true;\n        for(int i=0;i<graph[now].size();i++){\n            edge &e=graph[now][i];\n            if(!used[e.to]&&e.cap>0){\n                flow_t d=dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    graph[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    flow_t max_flow(int s,int t){\n        flow_t flow=0;\n        for(;;){\n            for(int i=0;i<graph.size();i++) used[i]=0;\n            flow_t f=dfs(s,t,INF);\n            if(f>0) flow+=f;\n            else return flow;\n        }\n    }\n};\n\nint main(){\n    int N,M;\n    cin>>N>>M;\n    string S;\n    cin>>S;\n    vector<ll> A(N);\n    for(int i=0;i<N;i++) cin>>A[i];\n\n    FordFulkerson<ll> graph(N+2);\n    int s=N,t=N+1;\n    for(int i=0;i<N;i++){\n        if(S[i]=='R'){\n            graph.add_edge(s,i,0);\n            graph.add_edge(i,t,A[i]);\n        }else{\n            graph.add_edge(s,i,A[i]);\n            graph.add_edge(i,t,0);\n        }\n    }\n    for(int i=0;i<M;i++){\n        int x,y,z;\n        cin>>x>>y>>z;\n        x--;y--;\n        if(x>y) swap(x,y);\n        graph.add_edge(y,x,z);\n    }\n\n    cout<<graph.max_flow(s,t)<<endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(X) debug_func(X, #X)\n#define DEBUG_ENDL endl\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(X) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\")\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\nvoid debug_func_preffix(const string &s) { if(s.size()) cout << s << \" = \"; }\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << t << DEBUG_ENDL_S(s);\n}\ntemplate <typename T, typename U>\nvoid debug_func(const P<T, U> &p, const string &s = \"\") {\n    debug_func_preffix(s);\n    cout << \"(\";\n    debug_func(p.first);\n    cout << \", \";\n    debug_func(p.second);\n    cout << \")\" << DEBUG_ENDL_S(s);\n}\ntemplate <typename T>\nvoid debug_func(const V<T> &v, const string &s = \"\") {\n    for(ll i = 0; i < v.size(); i++) {\n        string t = s + \"[\" + to_string(i) + \"]\";\n        debug_func(v[i], t);\n    }\n}\n\nstruct Edge{\n    ll to, cap, rev_index;\n};\n\nclass FordFulkerson{\n    private:\n        vector<vector<Edge>> v;\n        ll n;\n        bool *used;\n        const ll INF = numeric_limits<ll>::max();\n\n        int dfs(ll now, ll goal, ll f){\n            if(now == goal) return f;\n            used[now] = 1;\n            for(Edge &e : v[now]){\n                if(used[e.to]){\n                    continue;\n                }\n                if(e.cap <= 0){\n                    continue;\n                }\n                ll d = dfs(e.to, goal, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    v[e.to][e.rev_index].cap += d;\n                    return d;\n                }\n            }\n            return 0;\n        }\n\n    public:\n        FordFulkerson(const vector<vector<pair<ll, ll>>> &v){\n            this->n = v.size();\n            for(int i = 0; i < n; i++){\n                this->v.push_back(vector<Edge>(0));\n            }\n            for(int i = 0; i < n; i++){\n                for(auto e : v[i]){\n                    this->v[i].push_back((Edge){e.first, e.second, (ll)this->v[e.first].size()});\n                    this->v[e.first].push_back((Edge){i, 0, (ll)this->v[i].size() - 1});\n                }\n            }\n            used = new bool[n];\n        }\n\n        ll max_flow(ll start, ll goal){\n            ll ret = 0;\n            while(1){\n                memset(used, 0, n);\n                ll add = dfs(start, goal, INF);\n                if(add == 0){\n                    return ret;\n                }\n                ret += add;\n            }\n        }\n};\n\nconst ll INF = 5e15;\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    V<ll> A(N);\n    for(ll &e : A) cin >> e;\n    VV<ll> B(N, V<ll>(N, 0));\n    V<ll> bene(N);\n    for(ll i = 0; i < M; i++) {\n        ll S, T, b;\n        cin >> S >> T >> b;\n        S--;\n        T--;\n        B[S][T] += b;\n        B[T][S] += b;\n    }\n    ll start = N, goal = N + 1;\n    VV<PLL> edges(2 * N);\n    for(ll i = 0; i < N; i++) {\n        edges[start].emplace_back(i, S[i] == 'R' ? 0 : A[i]);\n        edges[i].emplace_back(goal, S[i] == 'R' ? A[i] : 0);\n        for(ll j = i + 1; j < N; j++) {\n            if(B[i][j] > 0) edges[j].emplace_back(i, B[i][j]);\n        }\n    }\n    DEBUG(edges);\n    cout << FordFulkerson(edges).max_flow(start, goal) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX_V 510\n\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nint V, E;\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used, 0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint a, M, s, t, b;\n\tstring U;\n\t\n\tcin>>V>>M;\n\t\n\tE = V+1;\n\t\n\tcin>>U;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tcin>>a;\n\t\tif(U[i] == 'R'){\n\t\t\tadd_edge(0,i+1,a);\n\t\t\tadd_edge(i+1,E,0);\n\t\t} else {\n\t\t\tadd_edge(0,i+1,0);\n\t\t\tadd_edge(i+1,E,a);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < M; i++){\n\t\tcin>>s>>t>>b;\n\t\tif(s < t) add_edge(s,t,b);\n\t\telse add_edge(t,s,b);\n\t}\n\t\n\t\n\tcout<<max_flow(0,E)<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// edge class (for network-flow)\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n\n    /* \n    // debug\n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.V; ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n    }\n    */\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1<<30; // to be set\n    vector<int> level, iter;\n\n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\n\n\nint main() {\n    int N, M;\n    string U;\n    while (cin >> N >> M >> U) {\n        vector<long long> A(N);\n        for (int i = 0; i < N; ++i) cin >> A[i];\n\n        Graph<long long> G(N+2);\n        int s = N, t = N+1;\n        for (int i = 0; i < N; ++i) {\n            if (U[i] == 'R') {\n                G.addedge(s, i, A[i]);\n                G.addedge(i, t, 0);\n            }\n            else {\n                G.addedge(s, i, 0);\n                G.addedge(i, t, A[i]);\n            }\n        }\n        for (int _ = 0; _ < M; ++_) {\n            int a, b; long long c;\n            cin >> a >> b >> c;\n            --a, --b;\n            if (a > b) swap(a, b);\n            G.addedge(a, b, c);\n        }\n\n        Dinic<long long> din;\n        long long res = din.solve(G, s, t);\n        cout << res << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7;\nconst ll LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nstruct Fordfulkerson{\n  const int INF = 1 << 28;\n  struct edge{\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> used;\n\n  Fordfulkerson(){}\n  Fordfulkerson(int sz):n(sz),G(n),used(n){}\n\n  void add_edge(int from,int to,int cap){\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n\n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e = G[v][i];\n      if(!used[e.to] && e.cap > 0 ){\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n          e.cap-=d;\n          G[e.to][e.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      fill(used.begin(),used.end(),0);\n      int f=dfs(s,t,lim);\n      if(f==0) return fl;\n      fl+=f;\n      lim-=f;\n    }\n  }\n\n  int flow(int s,int t){\n    return flow(s,t,INF);\n  }\n\n};\n//main\nsigned main(){\n  int N,M;cin>>N>>M;\n  Fordfulkerson fl(600);\n  string U;cin>>U;\n  for(int i=0;i<N;i++){\n    int a;cin>>a;\n    if(U[i]=='R')fl.add_edge(0,i+1,a);\n    else fl.add_edge(i+1,N+1,a);\n  }\n  for(int i=0;i<M;i++){\n    int s,t,b;cin>>s>>t>>b;\n    if(s>t)swap(s,t);\n    fl.add_edge(s,t,b);\n  }\n  cout<<fl.flow(0,N+1)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007 \n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m;\nstring U;\nint a[505];\nint s,t,b;\n\nstruct edge\n{\n\tint to,cap,rev;\n};\nvector<edge>G[1005];\nbool used[1005];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\nint dfs(int v,int t,int f)\n{ \n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0)\n\t\t{ \n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0) \n\t\t\t{ \n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{ \n\tint flow=0;\n\twhile(1)\n\t{ \n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f) return flow;\n\t\tflow+=f;\n\t}\n}\n\n\nint main(){\n\tcin>>n>>m;\n\tcin>>U;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\tadd_edge(1000,i,(U[i]=='L')?a[i]:0);\n\t\tadd_edge(i,1001,(U[i]=='R')?a[i]:0);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tcin>>s>>t>>b; s--; t--;\n\t\tif(s < t) swap(s,t);\n\t\tadd_edge(s,t,b);\n\t}\n\tcout<<max_flow(1000,1001)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MaxFlow {\npublic:\n  struct edge { int to, cap, rev; };\n\n  const int INF = 1 << 28;\n  int N;\n  vector<vector<edge>> E;\n  vector<int> level;\n  vector<int> iter;\n\n  MaxFlow(int N): N(N), E(N), level(N), iter(N) {}\n\n  void add_edge(int from, int to, int cap) {\n    E[from].push_back((edge) { to, cap, (int) E[to].size() });\n    E[to].push_back((edge) { from, 0, (int) E[from].size() - 1 });\n  }\n\n  void bfs(int s) {\n    for (int i = 0; i < N; i++) level[i] = -1;\n    level[s] = 0;\n\n    queue<int> q;\n    q.push(s);\n\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n\n      for (int i = 0; i < E[v].size(); i++) {\n        edge &e = E[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < E[v].size(); i++) {\n      edge &e = E[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) break;\n      for (int i = 0; i < N; i++) iter[i] = 0;\n      while (1) {\n        int f = dfs(s, t, INF);\n        if (f == 0 || f == INF) break;\n        flow += f;\n      }\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  string U;\n  cin >> U;\n  vector<ll> A(N);\n  REP(i, 0, N) cin >> A[i];\n  vector<ll> S(M), T(M), B(M);\n  REP(i, 0, M) cin >> S[i] >> T[i] >> B[i], S[i]--, T[i]--;\n\n  MaxFlow mf(N + 2);\n  ll s = N, t = N + 1;\n\n  REP(i, 0, N) {\n    if (U[i] == 'L') {\n      mf.add_edge(s, i, 0);\n      mf.add_edge(i, t, A[i]);\n    }\n    if (U[i] == 'R') {\n      mf.add_edge(s, i, A[i]);\n      mf.add_edge(i, t, 0);\n    }\n  }\n\n  REP(i, 0, M) {\n    if (S[i] > T[i]) swap(S[i], T[i]);\n    mf.add_edge(S[i], T[i], B[i]);\n  }\n\n  cout << mf.max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t flow_type;\n\nconst flow_type flow_inf = 1000 * 1000;\n\ntypedef struct flow_edge {\n  int32_t vertex;\n  int32_t next;\n  flow_type capacity;\n} flow_edge;\n\ntypedef struct maxFlowGraph {\n  flow_edge *edge;\n  int32_t *start;\n  int32_t vertex_num;\n  int32_t pointer;\n  int32_t edge_length;\n} graph;\n\ngraph* new_graph (const int32_t vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->vertex_num = vertex_num;\n  const int32_t initial_length = 4;\n  g->edge = (flow_edge *) calloc (initial_length, sizeof (flow_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->edge_length = initial_length;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph * const g, const int32_t from, const int32_t to, const flow_type capa) {\n  //printf (\"edge %\" PRIi32 \" -> %\" PRIi32 \", %\" PRIi32 \"\\n\", from, to, capa);\n  if (g->pointer == g->edge_length) {\n    g->edge_length *= 2;\n    g->edge = (flow_edge *) realloc (g->edge, sizeof (flow_edge) * g->edge_length);\n  }\n  const int32_t p = g->pointer;\n  g->edge[p] = (flow_edge) {to, g->start[from], capa};\n  g->start[from] = p;\n  g->edge[p + 1] = (flow_edge) {from, g->start[to], 0};\n  g->start[to] = p + 1;\n  g->pointer += 2;\n}\n\nflow_type dinic_dfs (const int32_t v, const graph * const g, const int32_t dst, const int32_t * const level, int32_t * const iter, flow_type e) {\n  if (v == dst) return e;\n  flow_type sum = 0;\n  for (int32_t p = iter[v]; p != -1; p = g->edge[p].next, iter[v] = p) {\n    const int32_t u = g->edge[p].vertex;\n    const flow_type capa = g->edge[p].capacity;\n    if (level[u] <= level[v] || capa <= 0) continue;\n    const flow_type f = dinic_dfs (u, g, dst, level, iter, capa < e ? capa : e);\n    if (f > 0) {\n      g->edge[p].capacity -= f;\n      g->edge[p ^ 1].capacity += f;\n      sum += f;\n      e -= f;\n      if (e <= 0) return sum;\n    }\n  }\n  return sum;\n}\n\nflow_type dinic (const graph * const g, const int32_t src, const int32_t dst) {\n  const int32_t vertex_num = g->vertex_num;\n  int32_t * const level = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const queue = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  int32_t * const iter  = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  flow_type flow = 0;\n  while (1) {\n    memset (level, 0, sizeof (int32_t) * vertex_num);\n    int32_t front = 0;\n    int32_t last = 0;\n    level[dst] = vertex_num;\n    queue[last++] = dst;\n    while (front < last && level[src] == 0) {\n      const int32_t v = queue[front++];\n      for (int32_t p = g->start[v]; p!=-1; p = g->edge[p].next) {\n        const int32_t u = g->edge[p].vertex;\n        if (g->edge[p ^ 1].capacity > 0 && level[u] == 0) {\n          level[u] = level[v] - 1;\n          queue[last++] = u;\n        }\n      }\n    }\n    if (level[src] == 0) break;\n    memcpy (iter, g->start, sizeof (int32_t) * vertex_num);\n    while (1) {\n      flow_type f = dinic_dfs (src, g, dst, level, iter, flow_inf);\n      if (f <= 0) break;\n      flow += f;\n    }\n  }\n  free (level);\n  free (queue);\n  free (iter);\n  return flow;\n}\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 n, m;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &m);\n  char *u = (char *) calloc (n + 1, sizeof (char));\n  scanf (\"%s\", u);\n  graph *g = new_graph (n + 2);\n  const i32 src = 0;\n  const i32 dst = n + 1;\n  for (i32 i = 1; i <= n; ++i) {\n    i32 a;\n    scanf (\"%\" SCNi32, &a);\n    if (u[i - 1] =='R') {\n      add_edge (g, src, i, a);\n    } else {\n      add_edge (g, i, dst, a);\n    }\n  }\n  while (m--) {\n    i32 s, t, b;\n    scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &s, &t, &b);\n    if (s > t) {\n      i32 swap = s;\n      s = t;\n      t = swap;\n    }\n    add_edge (g, s, t, b);\n  }\n  i32 ans = dinic (g, src, dst);\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\nint ta[100010],to[100010],co[100010],nt[100010],it[100010],l[100010];\nint MF(int e,int s,int t,int min){\n  if(s==t)return min;\n  int i,r;\n  for(;it[s]+1;it[s]=nt[it[s]]){\n    if(co[it[s]]==0||l[s]>=l[to[it[s]]])continue;\n    r=MF(e,to[it[s]],t,MIN(min,co[it[s]]));\n    co[it[s]]-=r;\n    co[(it[s]+e)%(2*e)]+=r;\n    if(r)return r;\n  }\n  return 0;\n}\n//呼び出す方\n//頂点v、辺eのグラフでsからgに流す\nint maxf(int v,int e,int s,int g){\n  int i,a=0,q[100010],t,r,c=3;\n  while(1){\n    for(i=t=0;i<v;i++)l[i]=0;\n    for(r=l[q[0]=s]=1;r-t;t++){\n      for(i=ta[q[t]];i+1;i=nt[i]){\n\tif(co[i]&&l[to[i]]==0)l[q[r++]=to[i]]=l[q[t]]+1;\n      }\n    }\n    if(l[g]==0)return a;\n    for(i=0;i<v;i++)it[i]=ta[i];\n    while(r=MF(e,s,g,1e9))a+=r;\n  }\n}\nvoid mklsb(int v,int e,int *a,int *b,int *c){\n  int i;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<e;i++){\n    nt[i  ]=ta[to[i+e]=a[i]];\n    nt[i+e]=ta[to[i  ]=b[i]];\n    co[ta[a[i]]=i  ]=c[i];      \n    co[ta[b[i]]=i+e]=0;\n  }\n}\nint main(){\n  int n,m,i,j,t,r=0,a[100010],b[100010],c[100010],d;\n  char s[100010];\n  scanf(\"%d %d %s\",&n,&m,s);\n  for(i=0;s[i];i++){\n    scanf(\"%d\",&d);\n    if(s[i]=='L'){\n      a[r]=0;\n      b[r]=i+1;\n      c[r++]=0;\n      a[r]=i+1;\n      b[r]=n+1;\n      c[r++]=d;\n    }\n    else{\n      a[r]=0;\n      b[r]=i+1;\n      c[r++]=d;\n      a[r]=i+1;\n      b[r]=n+1;\n      c[r++]=0;\n    }\n  }\n  while(m--){\n    scanf(\"%d %d %d\",&i,&j,&t);\n    a[r]=MIN(i,j);\n    b[r]=MAX(i,j);\n    c[r++]=t;\n  }\n  mklsb(n+2,r,a,b,c);\n  printf(\"%d\\n\",maxf(n+2,r,0,n+1));\n  return 0;\n}\n    \n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1LL<<62)-(1LL<<31))\n#define min(p,q)((p)<(q)?(p):(q))\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g,c;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[200010];//適宜変える(ecnt)\n\tint inv[200010];//逆辺のindex(ecnt)\n\tint id[100010];//適宜変える(vcnt)\n}G;\nG g;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\nint csort(const void*a,const void*b){\n\tll p=(*(E*)a).c,q=(*(E*)b).c;\n\treturn p<q?-1:p>q?1:0;\n}\n\nvoid makeinvedge(){\n\t//逆辺とidx\n\trep(i,0,g.ecnt){\n\t\tint l=0,r=g.ecnt;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(g.e[m].s<g.e[i].g||(g.e[m].s==g.e[i].g&&g.e[m].g<=g.e[i].s))l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tif(g.e[l].s!=g.e[i].g||g.e[l].g!=g.e[i].s){\n\t\t\tg.e[g.ecnt].s=g.e[i].g;\n\t\t\tg.e[g.ecnt].g=g.e[i].s;\n\t\t\tg.e[g.ecnt].c=0;\n\t\t\tg.ecnt++;\n\t\t}\n\t}\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\trep(i,0,g.ecnt){\n\t\tint l=0,r=g.ecnt;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(g.e[m].s<g.e[i].g||(g.e[m].s==g.e[i].g&&g.e[m].g<=g.e[i].s))l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tg.inv[i]=l;\n\t}\n}\n\nvoid readgraph(){\n\t//適宜変える\n\tll n,m;\n\tchar s[510];\n\tscanf(\"%lld%lld%s\",&n,&m,s);\n\trep(i,0,n){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tg.e[2*i  ].s=n;\n\t\tg.e[2*i  ].g=i;\n\t\tg.e[2*i  ].c=s[i]=='L'?t:0;\n\t\tg.e[2*i+1].s=i;\n\t\tg.e[2*i+1].g=n+1;\n\t\tg.e[2*i+1].c=s[i]=='R'?t:0;\n\t}\n\trep(i,0,m){\n\t\tll x,y,c;\n\t\tscanf(\"%lld%lld%lld\",&x,&y,&c);\n\t\tif(x<y){int t=x;x=y;y=t;}\n\t\tx--;y--;\n\t\tg.e[2*n+i].s=x;\n\t\tg.e[2*n+i].g=y;\n\t\tg.e[2*n+i].c=c;\n\t}\n\tg.vcnt=n+2;\n\tg.ecnt=2*n+m;\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n//\tqsort(g.e,g.ecnt,sizeof(E),csort);\n\tmakeinvedge();\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\n\n\n\n//dinic ただしO(VVE)ではなくO(V^4)\n//有向グラフの隣接行列capaと、ソースs,シンクtを引いてsからtへの最大流を返す\n//*\nint dist[1010];//ソースからの距離\nint checked[1010];//dfsの行き止まりフラグ\nvoid dinicbfs(int s){\n\trep(i,0,g.vcnt)dist[i]=-1;\n\tdist[s]=0;\n\t//まだ流せる辺だけを使ってbfs\n\tint que[1010],qcnt=0;\n\tque[qcnt++]=s;\n\trep(q,0,qcnt){\n\t\tint v=que[q];\n\t\trep(i,g.id[v],g.id[v+1])if(g.e[i].c>0&&dist[g.e[i].g]==-1){\n\t\t\tdist[g.e[i].g]=dist[v]+1;\n\t\t\tque[qcnt++]=g.e[i].g;\n\t\t}\n\t}\n}\nll dinicdfs(int a,int t,ll m){\n\t//aはm受け取ってる(⇔aから最大m流せる)\n\t//いくら流せるかを返す\n\tif(a==t)return m;\n\tif(checked[a])return 0;\n\tll ans=0;\n\tchecked[a]=1;\n\trep(i,g.id[a],g.id[a+1])if(g.e[i].c>0&&dist[g.e[i].g]>dist[a]){\n\t\tint b=g.e[i].g;\n\t\tll addedflow=dinicdfs(b,t,min(m,g.e[i].c));\n\t\tif(addedflow){\n\t\t\tg.e[i].c-=addedflow;\n\t\t\tg.e[g.inv[i]].c+=addedflow;\n\t\t\tchecked[a]=0;\n\t\t\tans+=addedflow;\n\t\t\tm-=addedflow;\n\t\t\tif(m<=0)break;\n\t\t}\n\t}\n\treturn ans;\n}\n//ソース,シンク\nll dinic(int s,int t){\n\tll ans=0;\n\tint flag=1;\n\twhile(flag){\n\t\tflag=0;//更新フラグ\n\t\tdinicbfs(s);\n\t\twhile(!checked[s]){\n\t\t\tll addedflow=dinicdfs(s,t,INF);\n\t\t\tans+=addedflow;\n\t\t\tif(addedflow)flag=1;\n\t\t}\n\t\trep(i,0,g.vcnt)checked[i]=0;\n\t}\n\treturn ans;\n}\n//*/\n\nint main(){\n\treadgraph();\n\tprintf(\"%lld\\n\",dinic(g.vcnt-2,g.vcnt-1));\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int M = cin.nextint;\n        var U = cin.next;\n        var A = cin.scanint;\n        var D = new Dinic(N + 2);\n        int s = N;\n        int t = N + 1;\n        for (int i = 0; i < N; i++)\n        {\n            if (U[i] == 'R')\n            {\n                D.add_edge(s, i, 0);\n                D.add_edge(i, t, A[i]);\n            }\n            else\n            {\n                D.add_edge(s, i, A[i]);\n                D.add_edge(i, t, 0);\n            }\n        }\n        for (int i = 0; i < M; i++)\n        {\n            int a = cin.nextint - 1;\n            int b = cin.nextint - 1;\n            D.add_edge(Max(a, b), Min(a, b), cin.nextint);            \n        }\n        WriteLine(D.max_flow(s, t));\n\n    }\n\n}\n\nclass Dinic\n{\n    // 辺を表すクラス（行き先、容量、逆辺）\n    class Edge_\n    {\n        public int to;\n        public long cap;\n        public int rev;\n        public Edge_(int to, long cap, int rev)\n        {\n            this.to = to;\n            this.cap = cap;\n            this.rev = rev;\n        }\n    }\n    public const long INF = long.MaxValue / 3;\n    List<Edge_>[] G; // グラフの隣接リスト表現\n    int[] level;    // sからの距離\n    int[] iter;     // どこまで調べ終わったか\n    public Dinic(int V)\n    {\n        G = new List<Edge_>[V];\n        for (int i = 0; i < V; i++) G[i] = new List<Edge_>();\n        level = new int[V];\n        iter = new int[V];\n    }\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    public void add_edge(int from, int to, long cap)\n    {\n        G[from].Add(new Edge_(to, cap, G[to].Count));\n        G[to].Add(new Edge_(from, 0, G[from].Count - 1));\n    }\n    // sからの最短距離をBFSで計算する\n    void bfs(int s)\n    {\n        for (int i = 0; i < level.Length; i++) level[i] = -1;\n        var que = new Queue<int>();\n        level[s] = 0;\n        que.Enqueue(s);\n        while (que.Any())\n        {\n            int v = que.Dequeue();\n            foreach (Edge_ e in G[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    que.Enqueue(e.to);\n                }\n            }\n        }\n    }\n    //増加パスをDFSで探す\n    long dfs(int v, int t, long f)\n    {\n        if (v == t) return f;\n        for (int i = iter[v]; i < G[v].Count; i++)\n        {\n            Edge_ e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                long d = dfs(e.to, t, Math.Min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    // sからtへの最大流を求める\n    public long max_flow(int s, int t)\n    {\n        long flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            for (int i = 0; i < iter.Length; i++) iter[i] = 0;\n            while (true)\n            {\n                long f = dfs(s, t, INF);\n                if (f <= 0) break;\n                flow += f;\n            }\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    auto U = readln.chomp;\n    auto A = readln.split.map!(to!long).array;\n\n    auto STB = M.iota.map!(_ => readln.split.map!(to!int).array).array;\n    auto mp = new long[][](N, N);\n\n    foreach (stb; STB) {\n        int S = stb[0] - 1;\n        int T = stb[1] - 1;\n        long B = stb[2];\n        if (S > T) swap(S, T);\n        mp[S][T] += B;\n    }\n\n    auto source = N;\n    auto sink = N + 1;\n    auto FF = new FordFulkerson(N+2, source, sink);\n\n    foreach (i; 0..N) {\n        FF.add_edge(source, i, U[i] == 'L' ? A[i] : 0);\n        FF.add_edge(i, sink, U[i] == 'L' ? 0 : A[i]);\n    }\n\n\n    foreach (i; 0..N) {\n        foreach (j; i+1..N) {\n            if (mp[i][j] == 0) continue;\n            FF.add_edge(j, i, mp[i][j]);\n        }\n    }\n\n    FF.run.writeln;\n}\n\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    long[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new long[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, long cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    long dfs(int v, long min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    long run() {\n        long ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            long f = dfs(source, long.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN,M = map(int,input().split())\nU = input()\nA = list(map(int,input().split()))\nsrc = [tuple(map(int,input().split())) for i in range(M)]\n\nedges = {}\nfor s,t,b in src:\n    s,t = s-1,t-1\n    if s>t: s,t = t,s\n    if (s,t) in edges:\n        edges[(s,t)] += b\n    else:\n        edges[(s,t)] = b\n\nP = N+2\nes = [[] for i in range(P)] # [[to1,cap1,rev1], ...]\n\ndef add_edge(fr,to,cap):\n    es[fr].append([to,cap,len(es[to])])\n    es[to].append([fr,0,len(es[fr])-1])\n\nfor i,(u,a) in enumerate(zip(U,A)):\n    if u == 'L':\n        add_edge(0,i+2,a)\n        add_edge(i+2,1,0)\n    else:\n        add_edge(0,i+2,0)\n        add_edge(i+2,1,a)\nfor (s,t),b in edges.items():\n    add_edge(t+2,s+2,b)\n\nINF = float('inf')\nlevel = [0] * P\niters = [0] * P\n\ndef dinic_max_flow(s,t):\n    global iters\n\n    def _bfs(s):\n        global level\n        level = [-1] * P\n        level[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for to,cap,rev in es[v]:\n                if cap > 0 and level[to] < 0:\n                    level[to] = level[v] + 1\n                    q.append(to)\n\n    def _dfs(v,t,f):\n        if v == t: return f\n        for i in range(iters[v],len(es[v])):\n            iters[v] += 1\n            to,cap,rev = es[v][i]\n            if es[v][i][1] > 0 and level[v] < level[to]:\n                d = _dfs(to,t,min(f,es[v][i][1]))\n                if d > 0:\n                    es[v][i][1] -= d #cap\n                    es[to][rev][1] += d\n                    return d\n        return 0\n\n    flow = 0\n    while True:\n        _bfs(s)\n        if level[t] < 0: return flow\n        iters = [0] * P\n        f = 0\n        while True:\n            f = _dfs(s,t,INF)\n            if f <= 0: break\n            flow += f\n\nprint(dinic_max_flow(0,1))\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/**\n * Dinic's algorithm for maximum flow problem.\n * Verified by: yukicoder No.177 (http://yukicoder.me/submissions/148371)\n * Min-cut (the second element of max_flow's returned values) is not verified.\n */\n\n#[derive(Clone)]\nstruct Edge<T> {\n    to: usize,\n    cap: T,\n    rev: usize, // rev is the position of the reverse edge in graph[to]\n}\n\nstruct Dinic<T> {\n    graph: Vec<Vec<Edge<T>>>,\n    iter: Vec<usize>,\n    zero: T,\n}\n\nimpl<T> Dinic<T>\n    where T: Clone,\n          T: Copy,\n          T: Ord,\n          T: std::ops::AddAssign,\n          T: std::ops::SubAssign,\n{\n    fn bfs(&self, s: usize, level: &mut [Option<usize>]) {\n        let n = level.len();\n        for i in 0 .. n {\n            level[i] = None;\n        }\n        let mut que = std::collections::VecDeque::new();\n        level[s] = Some(0);\n        que.push_back(s);\n        while let Some(v) = que.pop_front() {\n            for e in self.graph[v].iter() {\n\t        if e.cap > self.zero && level[e.to] == None {\n\t            level[e.to] = Some(level[v].unwrap() + 1);\n\t            que.push_back(e.to);\n                }\n            }\n\t}\n    }\n    /* search augment path by dfs.\n     * if f == None, f is treated as infinity.\n     */\n    fn dfs(&mut self, v: usize, t: usize, f: Option<T>, level: &mut [Option<usize>]) -> T {\n        if v == t {\n            return f.unwrap();\n        }\n        while self.iter[v] < self.graph[v].len() {\n            let i = self.iter[v];\n            let e = self.graph[v][i].clone();\n            if e.cap > self.zero && level[v] < level[e.to] {\n                let newf = std::cmp::min(f.unwrap_or(e.cap), e.cap);\n                let d = self.dfs(e.to, t, Some(newf), level);\n                if d > self.zero {\n                    self.graph[v][i].cap -= d;\n                    self.graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n            self.iter[v] += 1;\n        }\n        self.zero\n    }\n    pub fn new(n: usize, zero: T) -> Self {\n        Dinic {\n            graph: vec![Vec::new(); n],\n            iter: vec![0; n],\n            zero: zero,\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize, cap: T) {\n        let added_from = Edge { to: to, cap: cap,\n                            rev: self.graph[to].len() };\n        let added_to = Edge { to: from, cap: self.zero,\n                            rev: self.graph[from].len() };\n        self.graph[from].push(added_from);\n        self.graph[to].push(added_to);\n    }\n    pub fn max_flow(&mut self, s: usize, t: usize) -> (T, Vec<usize>) {\n        let mut flow = self.zero;\n        let n = self.graph.len();\n        let mut level = vec![None; n];\n        loop {\n            self.bfs(s, &mut level);\n            if level[t] == None {\n                let ret = (0 .. n).filter(|&i| level[i] == None)\n                    .collect();\n                return (flow, ret);\n            }\n            self.iter.clear();\n            self.iter.resize(n, 0);\n            loop {\n                let f = self.dfs(s, t, None, &mut level);\n                if f <= self.zero { break; }\n                flow += f;\n            }\n        }\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        m: usize,\n        u: chars,\n        a: [i64; n],\n        stb: [(usize1, usize1, i64); m],\n    }\n    let mut din = Dinic::new(2 + n, 0);\n    for i in 0..n {\n        let mut rcos = 0;\n        let mut lcos = 0;\n        if u[i] == 'R' {\n            lcos = a[i];\n        } else {\n            rcos = a[i];\n        }\n        din.add_edge(0, 2 + i, lcos);\n        din.add_edge(2 + i, 1, rcos);\n    }\n    for (s, t, b) in stb {\n        if s < t {\n            din.add_edge(2 + s, 2 + t, b);\n        } else {\n            din.add_edge(2 + t, 2 + s, b);\n        }\n    }\n    puts!(\"{}\\n\", din.max_flow(0, 1).0);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  }
]