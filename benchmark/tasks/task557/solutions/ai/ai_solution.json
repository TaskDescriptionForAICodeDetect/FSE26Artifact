[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100005\n\nint solve(int N, int M, char U[], int A[], int S[], int T[], int B[]) {\n    int minFear = INT_MAX;\n    \n    for (int mask = 0; mask < (1 << N); mask++) {\n        int currentFear = 0;\n        int valid = 1;\n        \n        // First check turning cost\n        for (int i = 0; i < N; i++) {\n            if ((mask & (1 << i)) != 0) {\n                currentFear += A[i];\n            }\n        }\n        \n        // Check constraints\n        for (int i = 0; i < M; i++) {\n            int s = S[i] - 1;\n            int t = T[i] - 1;\n            \n            // Determine ghost s's final direction\n            int sFacing = ((mask & (1 << s)) != 0) ? (U[s] == 'L' ? 'R' : 'L') : U[s];\n            \n            // Determine ghost t's final direction\n            int tFacing = ((mask & (1 << t)) != 0) ? (U[t] == 'L' ? 'R' : 'L') : U[t];\n            \n            // If s faces t and constraint violated\n            if ((s < t && sFacing == 'R' && tFacing == 'L') ||\n                (s > t && sFacing == 'L' && tFacing == 'R')) {\n                currentFear += B[i];\n            }\n        }\n        \n        minFear = (currentFear < minFear) ? currentFear : minFear;\n    }\n    \n    return minFear;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    char U[MAX_N];\n    int A[MAX_N], S[MAX_N], T[MAX_N], B[MAX_N];\n    \n    scanf(\"%s\", U);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &S[i], &T[i], &B[i]);\n    }\n    \n    int result = solve(N, M, U, A, S, T, B);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint N, M;\nchar U[100001];\nint A[100001];\nEdge edges[200002];\nint edge_count = 0;\nint dist[100001];\n\nvoid add_edge(int u, int v, int w) {\n    edges[edge_count].u = u;\n    edges[edge_count].v = v;\n    edges[edge_count].w = w;\n    edge_count++;\n}\n\nvoid bellman_ford() {\n    for (int i = 1; i <= N; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[1] = 0;\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j < edge_count; j++) {\n            int u = edges[j].u;\n            int v = edges[j].v;\n            int w = edges[j].w;\n            if (dist[u] != INT_MAX && dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    scanf(\"%s\", U + 1);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for (int i = 1; i <= M; i++) {\n        int S, T, B;\n        scanf(\"%d %d %d\", &S, &T, &B);\n        if (U[S] == 'L' && U[T] == 'L') {\n            add_edge(T, S, B);\n        } else if (U[S] == 'L' && U[T] == 'R') {\n            add_edge(S, T, B);\n        } else if (U[S] == 'R' && U[T] == 'L') {\n            add_edge(T, S, B);\n        } else if (U[S] == 'R' && U[T] == 'R') {\n            add_edge(S, T, B);\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (U[i] == 'L') {\n            add_edge(i + 1, i, A[i]);\n        } else {\n            add_edge(i, i + 1, A[i]);\n        }\n    }\n\n    bellman_ford();\n\n    if (dist[N + 1] == INT_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", dist[N + 1]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    long long cost;\n};\n\nconst long long INF = 1LL << 60;\n\nvector<long long> dijkstra(const vector<vector<Edge>>& graph, int start) {\n    vector<long long> dist(graph.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.push({0, start});\n    while (!pq.empty()) {\n        auto [current_dist, u] = pq.top();\n        pq.pop();\n        if (current_dist > dist[u]) continue;\n        for (const auto& edge : graph[u]) {\n            long long next_dist = current_dist + edge.cost;\n            if (next_dist < dist[edge.to]) {\n                dist[edge.to] = next_dist;\n                pq.push({next_dist, edge.to});\n            }\n        }\n    }\n    return dist;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    string U;\n    cin >> U;\n    vector<long long> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n    vector<vector<pair<int, long long>>> constraints(N);\n    for (int i = 0; i < M; ++i) {\n        int S, T;\n        long long B;\n        cin >> S >> T >> B;\n        --S; --T;\n        constraints[S].emplace_back(T, B);\n        constraints[T].emplace_back(S, B);\n    }\n\n    int V = 2 * N;\n    vector<vector<Edge>> graph(V);\n    for (int i = 0; i < N; ++i) {\n        int u0 = 2 * i;\n        int u1 = 2 * i + 1;\n        if (U[i] == 'L') {\n            graph[u0].push_back({u1, A[i]});\n            graph[u1].push_back({u0, 0});\n        } else {\n            graph[u0].push_back({u1, 0});\n            graph[u1].push_back({u0, A[i]});\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        for (const auto& [j, B] : constraints[i]) {\n            int u0 = 2 * i;\n            int u1 = 2 * i + 1;\n            int v0 = 2 * j;\n            int v1 = 2 * j + 1;\n            graph[u0].push_back({v1, B});\n            graph[u1].push_back({v0, B});\n        }\n    }\n\n    auto dist = dijkstra(graph, 0);\n    long long ans = min(dist[2 * (N - 1)], dist[2 * (N - 1) + 1]);\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Ghosts {\n    static class Edge {\n        int to;\n        long cost;\n        Edge(int to, long cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().split(\" \");\n        int N = Integer.parseInt(parts[0]);\n        int M = Integer.parseInt(parts[1]);\n        char[] U = br.readLine().toCharArray();\n        long[] A = new long[N + 1];\n        parts = br.readLine().split(\" \");\n        for (int i = 1; i <= N; i++) {\n            A[i] = Long.parseLong(parts[i - 1]);\n        }\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= 2 * N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 1; i <= N; i++) {\n            if (U[i - 1] == 'L') {\n                graph.get(i).add(new Edge(i + N, A[i]));\n                graph.get(i + N).add(new Edge(i, 0));\n            } else {\n                graph.get(i + N).add(new Edge(i, A[i]));\n                graph.get(i).add(new Edge(i + N, 0));\n            }\n        }\n\n        for (int i = 0; i < M; i++) {\n            parts = br.readLine().split(\" \");\n            int S = Integer.parseInt(parts[0]);\n            int T = Integer.parseInt(parts[1]);\n            long B = Long.parseLong(parts[2]);\n            graph.get(S).add(new Edge(T, B));\n            graph.get(T + N).add(new Edge(S + N, B));\n        }\n\n        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[1]));\n        long[] dist = new long[2 * N + 2];\n        Arrays.fill(dist, Long.MAX_VALUE);\n        dist[1] = 0;\n        pq.offer(new long[]{1, 0});\n\n        while (!pq.isEmpty()) {\n            long[] curr = pq.poll();\n            int u = (int) curr[0];\n            long d = curr[1];\n            if (d > dist[u]) continue;\n            for (Edge e : graph.get(u)) {\n                int v = e.to;\n                long newDist = d + e.cost;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new long[]{v, newDist});\n                }\n            }\n        }\n\n        System.out.println(Math.min(dist[N], dist[2 * N]));\n    }\n}",
    "timestamp": "2025-08-05 22:08:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GhostFear {\n    public static long minimumFear(int n, int m, String U, int[] A, int[] S, int[] T, int[] B) {\n        long[][] dp = new long[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][0] = Long.MAX_VALUE / 2;\n            dp[i][1] = Long.MAX_VALUE / 2;\n        }\n        \n        dp[0][U.charAt(0) == 'L' ? 1 : 0] = A[0];\n        dp[0][U.charAt(0) == 'L' ? 0 : 1] = 0;\n        \n        for (int i = 1; i < n; i++) {\n            char initialDir = U.charAt(i);\n            \n            // Turn left\n            dp[i][0] = Math.min(\n                dp[i-1][1] + A[i],\n                dp[i-1][0]\n            );\n            \n            // Turn right\n            dp[i][1] = Math.min(\n                dp[i-1][0] + A[i],\n                dp[i-1][1]\n            );\n        }\n        \n        for (int j = 0; j < m; j++) {\n            int s = S[j] - 1;\n            int t = T[j] - 1;\n            \n            long minFear = Long.MAX_VALUE;\n            for (int x = 0; x < 2; x++) {\n                for (int y = 0; y < 2; y++) {\n                    long currFear = dp[s][x] + dp[t][y];\n                    if (x != y) currFear += B[j];\n                    minFear = Math.min(minFear, currFear);\n                }\n            }\n            \n            return minFear;\n        }\n        \n        return Math.min(dp[n-1][0], dp[n-1][1]);\n    }\n}",
    "timestamp": "2025-08-05 22:08:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5005;\nint N, M;\nchar U[MAXN];\nint A[MAXN], fear[MAXN][2];\n\nint solve() {\n    int ans = INT_MAX;\n    for (int mask = 0; mask < (1 << N); mask++) {\n        int total_fear = 0;\n        vector<int> direction(N);\n        \n        for (int i = 0; i < N; i++) {\n            bool turn = (mask & (1 << i)) > 0;\n            direction[i] = (U[i] == 'L' ? 0 : 1);\n            \n            if (turn) {\n                direction[i] = 1 - direction[i];\n                total_fear += A[i];\n            }\n        }\n        \n        bool valid = true;\n        for (int i = 0; i < M; i++) {\n            int s = fear[i][0] - 1, t = fear[i][1] - 1;\n            if (direction[s] == 0 && direction[t] == 1) {\n                total_fear += fear[i][2];\n            }\n        }\n        \n        ans = min(ans, total_fear);\n    }\n    \n    return ans;\n}\n\nint main() {\n    cin >> N >> M;\n    \n    for (int i = 0; i < N; i++) {\n        cin >> U[i];\n    }\n    \n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    \n    for (int i = 0; i < M; i++) {\n        cin >> fear[i][0] >> fear[i][1] >> fear[i][2];\n    }\n    \n    cout << solve() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef calculate_fear(U, A, constraints):\n    total_fear = 0\n    direction = {'L': 'R', 'R': 'L'}\n    for i, c in enumerate(U):\n        if c != direction[A[i]]:\n            total_fear += A[i]\n    \n    for s, t, b in constraints:\n        if U[s] != U[t]:\n            total_fear += b\n            \n    return total_fear\n\ndef min_fear_level(U, A, constraints):\n    n = len(U)\n    min_fear = float('inf')\n    \n    for perm in permutations(['L', 'R'], n):\n        fear = calculate_fear(perm, A, constraints)\n        if fear < min_fear:\n            min_fear = fear\n    \n    return min_fear\n\n# Example usage\nn = 4\nM = 2\nU = ['L', 'R', 'L', 'R']\nA = [1, 3, 2, 4]\nconstraints = [(0, 2, 5), (1, 3, 7)]\n\nprint(min_fear_level(U, A, constraints))",
    "timestamp": "2025-08-13 09:05:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GhostsFear {\n\n    static class Ghost {\n        int index;\n        char direction;\n        int turnFear;\n\n        Ghost(int index, char direction, int turnFear) {\n            this.index = index;\n            this.direction = direction;\n            this.turnFear = turnFear;\n        }\n    }\n\n    static class Constraint {\n        int source;\n        int target;\n        int fearLevel;\n\n        Constraint(int source, int target, int fearLevel) {\n            this.source = source;\n            this.target = target;\n            this.fearLevel = fearLevel;\n        }\n    }\n\n    public static int minFearLevel(int n, int[] A, String U, int m, int[] S, int[] T, int[] B) {\n        Ghost[] ghosts = new Ghost[n];\n\n        for (int i = 0; i < n; i++) {\n            ghosts[i] = new Ghost(i, U.charAt(i), A[i]);\n        }\n\n        Constraint[] constraints = new Constraint[m];\n\n        for (int i = 0; i < m; i++) {\n            constraints[i] = new Constraint(S[i] - 1, T[i] - 1, B[i]);\n        }\n\n        int totalFear = 0;\n        boolean[] turned = new boolean[n];\n\n        for (Constraint constraint : constraints) {\n            Ghost source = ghosts[constraint.source];\n            Ghost target = ghosts[constraint.target];\n\n            if ((source.direction == 'R' && target.index > source.index) ||\n                (source.direction == 'L' && target.index < source.index)) {\n                continue; // Already avoiding the scary ghost\n            }\n\n            // Decide how to deal with the constraint\n            if (source.turnFear <= constraint.fearLevel) {\n                source.direction = (source.direction == 'R') ? 'L' : 'R';\n                totalFear += source.turnFear;\n                turned[source.index] = true;\n            } else {\n                totalFear += constraint.fearLevel;\n            }\n        }\n\n        return totalFear;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] A = new int[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = scanner.nextInt();\n        }\n        String U = scanner.next();\n        int m = scanner.nextInt();\n        int[] S = new int[m];\n        int[] T = new int[m];\n        int[] B = new int[m];\n        for (int i = 0; i < m; i++) {\n            S[i] = scanner.nextInt();\n            T[i] = scanner.nextInt();\n            B[i] = scanner.nextInt();\n        }\n\n        System.out.println(minFearLevel(n, A, U, m, S, T, B));\n    }\n}",
    "timestamp": "2025-08-13 09:05:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int from;\n    int to;\n    int penalty;\n} Constraint;\n\nint min_fear(int* A, char* U, Constraint* constraints, int n, int m) {\n    int dp_left[n], dp_right[n];\n    dp_left[0] = U[0] == 'L' ? 0 : A[0];\n    dp_right[0] = U[0] == 'R' ? 0 : A[0];\n\n    for (int i = 1; i < n; ++i) {\n        dp_left[i] = dp_right[i] = INT_MAX;\n    }\n\n    for (int i = 1; i < n; ++i) {\n        dp_left[i] = dp_left[i-1] + (U[i] == 'L' ? 0 : A[i]);\n        dp_right[i] = dp_right[i-1] + (U[i] == 'R' ? 0 : A[i]);\n\n        for (int j = 0; j < m; ++j) {\n            if (constraints[j].to == i) {\n                int s = constraints[j].from;\n                int penalty = constraints[j].penalty;\n                if (dp_right[s] != INT_MAX) {\n                    dp_left[i] = dp_left[i] < dp_right[s] + penalty ? dp_left[i] : dp_right[s] + penalty;\n                }\n                if (dp_left[s] != INT_MAX) {\n                    dp_right[i] = dp_right[i] < dp_left[s] + penalty ? dp_right[i] : dp_left[s] + penalty;\n                }\n            }\n        }\n    }\n    return dp_left[n-1] < dp_right[n-1] ? dp_left[n-1] : dp_right[n-1];\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int A[n];\n    char U[n];\n    for (int i = 0; i < n; ++i) {\n        scanf(\" %c %d\", &U[i], &A[i]);\n    }\n\n    Constraint constraints[m];\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d %d %d\", &constraints[i].from, &constraints[i].to, &constraints[i].penalty);\n        constraints[i].from--;  // To zero-based indexing\n        constraints[i].to--;\n    }\n\n    printf(\"%d\\n\", min_fear(A, U, constraints, n, m));\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:05:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_fear_level(N, M, U, A, S, T, B):\n    # Initialize dynamic programming table\n    dp = [[float('inf')] * 2 for _ in range(N)]\n    \n    # Initial state: each ghost can face left or right\n    for j in range(2):\n        dp[0][j] = A[0] if j != (1 if U[0] == 'L' else 0) else 0\n    \n    # Dynamic programming to find minimum fear level\n    for i in range(1, N):\n        for j in range(2):\n            # Determine current ghost's original and new facing direction\n            original_dir = 1 if U[i] == 'L' else 0\n            new_dir = 1 - j\n            \n            # Cost of turning\n            turn_cost = A[i] if new_dir != original_dir else 0\n            \n            # Check both previous states\n            for k in range(2):\n                # Check additional fear from previous constraints\n                extra_fear = 0\n                for x in range(M):\n                    if S[x] - 1 == i and T[x] - 1 < i:\n                        if (k == 0 and j == 1) or (k == 1 and j == 0):\n                            extra_fear += B[x]\n                \n                dp[i][j] = min(dp[i][j], dp[i-1][k] + turn_cost + extra_fear)\n    \n    # Return minimum of final states\n    return min(dp[N-1])\n\n# Example usage\nN, M = map(int, input().split())\nU = input().split()\nA = list(map(int, input().split()))\nS, T, B = [], [], []\nfor _ in range(M):\n    s, t, b = map(int, input().split())\n    S.append(s)\n    T.append(t)\n    B.append(b)\n\nprint(min_fear_level(N, M, U, A, S, T, B))",
    "timestamp": "2025-08-13 09:06:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M = map(int, input[ptr:ptr+2])\n    ptr +=2\n    U = input[ptr]\n    ptr +=1\n    A = list(map(int, input[ptr:ptr+N]))\n    ptr +=N\n    \n    adj = [[] for _ in range(2*N)]\n    constraints = []\n    for _ in range(M):\n        S, T, B = map(int, input[ptr:ptr+3])\n        ptr +=3\n        S -=1\n        T -=1\n        constraints.append((S, T, B))\n    \n    # Build implication graph\n    for S, T, B in constraints:\n        # Original: S is L (0) and T is L (0) => cost B\n        # S is L (0) and T is R (1) => cost 0\n        # S is R (1) and T is L (0) => cost 0\n        # S is R (1) and T is R (1) => cost B\n        # So, if S is 0 and T is 0, or S is 1 and T is 1, cost B\n        # Which is equivalent to (S is 0 and T is 0) or (S is 1 and T is 1)\n        # So, (S is 0 and T is 1) or (S is 1 and T is 0) is cost 0\n        # To model this, we can say:\n        # If S is 0, then T must be 1 (else cost B)\n        # If T is 0, then S must be 1 (else cost B)\n        # Similarly, if S is 1, then T must be 0 (else cost B)\n        # If T is 1, then S must be 0 (else cost B)\n        # So, for each constraint, we add implications:\n        # S is 0 => T is 1 (cost B if violated)\n        # T is 0 => S is 1 (cost B if violated)\n        # S is 1 => T is 0 (cost B if violated)\n        # T is 1 => S is 0 (cost B if violated)\n        # So, we add edges:\n        # S0 -> T1\n        # T0 -> S1\n        # S1 -> T0\n        # T1 -> S0\n        # Each with weight B\n        s0 = 2*S\n        s1 = 2*S +1\n        t0 = 2*T\n        t1 = 2*T +1\n        adj[s0].append((t1, B))\n        adj[t0].append((s1, B))\n        adj[s1].append((t0, B))\n        adj[t1].append((s0, B))\n    \n    # Now, we need to find the minimal assignment that satisfies all constraints\n    # This is a 2-SAT problem with minimal cost\n    # We can model this as a graph and find the strongly connected components\n    # Then, for each variable, if x and ~x are in the same component, it's impossible\n    # Otherwise, we can assign components in topological order\n    \n    # Step 1: Build the reverse graph for Kosaraju's algorithm\n    rev_adj = [[] for _ in range(2*N)]\n    for u in range(2*N):\n        for (v, w) in adj[u]:\n            rev_adj[v].append(u)\n    \n    # Step 2: First pass to get the order\n    visited = [False] * (2*N)\n    order = []\n    for u in range(2*N):\n        if not visited[u]:\n            stack = [(u, False)]\n            while stack:\n                node, processed = stack.pop()\n                if processed:\n                    order.append(node)\n                    continue\n                if visited[node]:\n                    continue\n                visited[node] = True\n                stack.append((node, True))\n                for (v, w) in adj[node]:\n                    if not visited[v]:\n                        stack.append((v, False))\n    \n    # Step 3: Second pass to find SCCs\n    visited = [False] * (2*N)\n    component = [0] * (2*N)\n    current_component = 0\n    for u in reversed(order):\n        if not visited[u]:\n            stack = [u]\n            visited[u] = True\n            component_nodes = []\n            while stack:\n                node = stack.pop()\n                component_nodes.append(node)\n                for v in rev_adj[node]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            for node in component_nodes:\n                component[node] = current_component\n            current_component +=1\n    \n    # Check for contradictions\n    for i in range(N):\n        if component[2*i] == component[2*i +1]:\n            print(-1)\n            return\n    \n    # Build the component graph\n    component_adj = [[] for _ in range(current_component)]\n    component_in_degree = [0] * current_component\n    for u in range(2*N):\n        for (v, w) in adj[u]:\n            if component[u] != component[v]:\n                component_adj[component[v]].append(component[u])\n                component_in_degree[component[u]] +=1\n    \n    # Topological sort of components\n    topo_order = []\n    q = deque()\n    for c in range(current_component):\n        if component_in_degree[c] ==0:\n            q.append(c)\n    while q:\n        c = q.popleft()\n        topo_order.append(c)\n        for d in component_adj[c]:\n            component_in_degree[d] -=1\n            if component_in_degree[d] ==0:\n                q.append(d)\n    \n    # Process components in reverse topological order\n    value = [None] * current_component\n    res = 0\n    for c in reversed(topo_order):\n        if value[c] is None:\n            value[c] = True\n            # The negation is component[neg_node]\n            # For variables 2*i and 2*i+1, the negation is the other\n            # So, for a node u, if u is 2*i, then neg is 2*i+1, component is component[2*i+1]\n            # Similarly, if u is 2*i+1, then neg is 2*i, component is component[2*i]\n            # So, find all nodes in component c, and for each, find its negation's component\n            # Then, set those components to False\n            # But since we process in reverse topological order, we can just set the negation to False\n            # But we need to find the negation's component\n            # So, for any node in c, find its negation's component\n            # Since all nodes in c are equivalent, we can pick any\n            # So, pick the first node in the component (but we don't have that info)\n            # So, we need to track for each component, the variables it contains\n            # Alternatively, we can track for each variable, its component\n            # So, for any i, component[2*i] and component[2*i+1] are negations\n            # So, for any node u in c, if u is 2*i, then the negation is component[2*i+1]\n            # So, we can iterate over all i, and check if component[2*i] == c, then set component[2*i+1] to False\n            # Or component[2*i+1] == c, then set component[2*i] to False\n            # So, we need to find for component c, whether it represents a variable's 0 or 1 state\n            # So, for each i, check if 2*i is in c or 2*i+1 is in c\n            # So, we can precompute for each component, the corresponding variable and its state\n            # But that's not necessary, since we can just iterate over all variables and check\n            for i in range(N):\n                if component[2*i] == c:\n                    neg_c = component[2*i +1]\n                    if value[neg_c] is None:\n                        value[neg_c] = False\n                if component[2*i +1] == c:\n                    neg_c = component[2*i]\n                    if value[neg_c] is None:\n                        value[neg_c] = False\n    \n    # Now, compute the total fear\n    total = 0\n    for i in range(N):\n        original_state = 0 if U[i] == 'L' else 1\n        if value[component[2*i + original_state]]:\n            # No turn\n            pass\n        else:\n            # Turn\n            total += A[i]\n    \n    # Now, check the constraints\n    for S, T, B in constraints:\n        s_state = 0 if U[S] == 'L' else 1\n        t_state = 0 if U[T] == 'L' else 1\n        if not value[component[2*S + s_state]]:\n            s_state ^=1\n        if not value[component[2*T + t_state]]:\n            t_state ^=1\n        if (s_state == 0 and t_state == 0) or (s_state ==1 and t_state ==1):\n            total += B\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 09:06:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Constraint {\n    int S, T, B;\n};\n\nint getMinimumFearLevel(const vector<char>& U, const vector<int>& A, const vector<Constraint>& constraints) {\n    int n = U.size();\n    int m = constraints.size();\n    vector<int> dp(1 << n, INT_MAX);\n    dp[0] = 0;\n\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        for (int i = 0; i < n; ++i) {\n            int nextMask = mask | (1 << i);\n            int fearLevel = dp[mask];\n            if (((mask >> i) & 1) == 0) { // i-th ghost turns around\n                fearLevel += A[i];\n            }\n            for (const auto& con : constraints) {\n                int SiFacing = ((nextMask >> con.S) & 1) ? 'R' : 'L';\n                int TiFacing = ((nextMask >> con.T) & 1) ? 'R' : 'L';\n\n                if ((SiFacing == 'R' && TiFacing == 'L') || (SiFacing == 'L' && TiFacing == 'R')) {\n                    fearLevel += con.B;\n                }\n            }\n            dp[nextMask] = min(dp[nextMask], fearLevel);\n        }\n    }\n    \n    return dp[(1 << n) - 1];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<char> U(n);\n    vector<int> A(n);\n    vector<Constraint> constraints(m);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> U[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> A[i];\n    }\n    for (int i = 0; i < m; ++i) {\n        int S, T, B;\n        cin >> S >> T >> B;\n        constraints[i] = {S - 1, T - 1, B};\n    }\n    \n    cout << getMinimumFearLevel(U, A, constraints) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:49:35"
  }
]