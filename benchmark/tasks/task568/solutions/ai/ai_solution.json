[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_VERTICES 1000\n#define INF 999999\n\n// Disjoint Set data structure for Kruskal's algorithm\ntypedef struct {\n    int parent[MAX_VERTICES];\n    int rank[MAX_VERTICES];\n} DisjointSet;\n\n// Edge structure\ntypedef struct {\n    int src, dest, weight;\n} Edge;\n\n// Compare function for sorting edges\nint compareEdges(const void* a, const void* b) {\n    return ((Edge*)a)->weight - ((Edge*)b)->weight;\n}\n\n// Initialize disjoint set\nvoid initDisjointSet(DisjointSet* ds, int n) {\n    for (int i = 0; i < n; i++) {\n        ds->parent[i] = i;\n        ds->rank[i] = 0;\n    }\n}\n\n// Find with path compression\nint find(DisjointSet* ds, int x) {\n    if (ds->parent[x] != x)\n        ds->parent[x] = find(ds, ds->parent[x]);\n    return ds->parent[x];\n}\n\n// Union by rank\nvoid unionSets(DisjointSet* ds, int x, int y) {\n    int xroot = find(ds, x);\n    int yroot = find(ds, y);\n\n    if (ds->rank[xroot] < ds->rank[yroot])\n        ds->parent[xroot] = yroot;\n    else if (ds->rank[xroot] > ds->rank[yroot])\n        ds->parent[yroot] = xroot;\n    else {\n        ds->parent[yroot] = xroot;\n        ds->rank[xroot]++;\n    }\n}\n\n// Kruskal's algorithm to find MST\nint kruskalMST(int n, Edge* edges, int edgeCount) {\n    // Sort edges by weight\n    qsort(edges, edgeCount, sizeof(Edge), compareEdges);\n\n    DisjointSet ds;\n    initDisjointSet(&ds, n);\n\n    int mstWeight = 0;\n    int mstEdges = 0;\n\n    for (int i = 0; i < edgeCount; i++) {\n        int x = find(&ds, edges[i].src);\n        int y = find(&ds, edges[i].dest);\n\n        // If including this edge doesn't create a cycle\n        if (x != y) {\n            unionSets(&ds, x, y);\n            mstWeight += edges[i].weight;\n            mstEdges++;\n\n            // MST is complete\n            if (mstEdges == n - 1)\n                break;\n        }\n    }\n\n    return mstWeight;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Edge* edges = malloc(m * sizeof(Edge));\n\n    // Read graph edges\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &edges[i].src, &edges[i].dest, &edges[i].weight);\n        edges[i].src--;  // 0-based indexing\n        edges[i].dest--;\n    }\n\n    // Find and print MST total weight\n    int minimumSpanningTreeWeight = kruskalMST(n, edges, m);\n    printf(\"%d\\n\", minimumSpanningTreeWeight);\n\n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int u, v, weight;\n} Edge;\n\nint find(int parent[], int i) {\n    if (parent[i] != i) {\n        parent[i] = find(parent, parent[i]);\n    }\n    return parent[i];\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n\n    if (rank[xroot] < rank[yroot]) {\n        parent[xroot] = yroot;\n    } else if (rank[xroot] > rank[yroot]) {\n        parent[yroot] = xroot;\n    } else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint compareEdges(const void* a, const void* b) {\n    Edge* edge1 = (Edge*)a;\n    Edge* edge2 = (Edge*)b;\n    return edge1->weight - edge2->weight;\n}\n\nint kruskalMST(Edge edges[], int V, int E) {\n    qsort(edges, E, sizeof(Edge), compareEdges);\n\n    int* parent = (int*)malloc(V * sizeof(int));\n    int* rank = (int*)malloc(V * sizeof(int));\n\n    for (int i = 0; i < V; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int mstWeight = 0;\n    int edgeCount = 0;\n\n    for (int i = 0; i < E && edgeCount < V - 1; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int weight = edges[i].weight;\n\n        int uroot = find(parent, u);\n        int vroot = find(parent, v);\n\n        if (uroot != vroot) {\n            mstWeight += weight;\n            unionSets(parent, rank, uroot, vroot);\n            edgeCount++;\n        }\n    }\n\n    free(parent);\n    free(rank);\n\n    return mstWeight;\n}\n\nint main() {\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n\n    Edge* edges = (Edge*)malloc(E * sizeof(Edge));\n\n    for (int i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].weight);\n    }\n\n    int mstWeight = kruskalMST(edges, V, E);\n    printf(\"%d\\n\", mstWeight);\n\n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint primMST(vector<vector<pii>>& graph, int V) {\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    vector<int> key(V, INT_MAX);\n    vector<bool> inMST(V, false);\n    int res = 0;\n\n    pq.push({0, 0});\n    key[0] = 0;\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n\n        if (inMST[u]) continue;\n        inMST[u] = true;\n        res += key[u];\n\n        for (auto& edge : graph[u]) {\n            int v = edge.first;\n            int weight = edge.second;\n            if (!inMST[v] && weight < key[v]) {\n                key[v] = weight;\n                pq.push({key[v], v});\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<pii>> graph(V);\n\n    for (int i = 0; i < E; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w});\n    }\n\n    cout << primMST(graph, V) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int src, dest, weight;\n\n    public int compareTo(Edge other) {\n        return this.weight - other.weight;\n    }\n}\n\nclass Subset {\n    int parent, rank;\n}\n\npublic class KruskalMST {\n    private int V, E;\n    private Edge[] edges;\n\n    KruskalMST(int v, int e) {\n        V = v;\n        E = e;\n        edges = new Edge[E];\n        for (int i = 0; i < e; ++i)\n            edges[i] = new Edge();\n    }\n\n    int find(Subset[] subsets, int i) {\n        if (subsets[i].parent != i)\n            subsets[i].parent = find(subsets, subsets[i].parent);\n        return subsets[i].parent;\n    }\n\n    void union(Subset[] subsets, int x, int y) {\n        int xroot = find(subsets, x);\n        int yroot = find(subsets, y);\n\n        if (subsets[xroot].rank < subsets[yroot].rank)\n            subsets[xroot].parent = yroot;\n        else if (subsets[xroot].rank > subsets[yroot].rank)\n            subsets[yroot].parent = xroot;\n        else {\n            subsets[yroot].parent = xroot;\n            subsets[xroot].rank++;\n        }\n    }\n\n    int kruskalMST() {\n        Edge[] result = new Edge[V];\n        int e = 0;\n        int i = 0;\n        for (i = 0; i < V; ++i)\n            result[i] = new Edge();\n\n        Arrays.sort(edges);\n\n        Subset[] subsets = new Subset[V];\n        for (i = 0; i < V; ++i) {\n            subsets[i] = new Subset();\n            subsets[i].parent = i;\n            subsets[i].rank = 0;\n        }\n\n        i = 0;\n        int totalWeight = 0;\n\n        while (e < V - 1) {\n            Edge next_edge = edges[i++];\n\n            int x = find(subsets, next_edge.src);\n            int y = find(subsets, next_edge.dest);\n\n            if (x != y) {\n                result[e++] = next_edge;\n                totalWeight += next_edge.weight;\n                union(subsets, x, y);\n            }\n        }\n        return totalWeight;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        KruskalMST graph = new KruskalMST(V, E);\n\n        for (int i = 0; i < E; i++) {\n            graph.edges[i].src = scanner.nextInt();\n            graph.edges[i].dest = scanner.nextInt();\n            graph.edges[i].weight = scanner.nextInt();\n        }\n\n        System.out.println(graph.kruskalMST());\n    }\n}",
    "timestamp": "2025-08-05 22:11:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n\n        public Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n\n        public int compareTo(Edge compareEdge) {\n            return this.weight - compareEdge.weight;\n        }\n    }\n\n    static class DisjointSet {\n        int[] parent, rank;\n\n        public DisjointSet(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        void union(int x, int y) {\n            int xRoot = find(x);\n            int yRoot = find(y);\n\n            if (rank[xRoot] < rank[yRoot]) {\n                parent[xRoot] = yRoot;\n            } else if (rank[xRoot] > rank[yRoot]) {\n                parent[yRoot] = xRoot;\n            } else {\n                parent[yRoot] = xRoot;\n                rank[xRoot]++;\n            }\n        }\n    }\n\n    public static int minimumSpanningTree(int n, List<Edge> edges) {\n        Collections.sort(edges);\n        DisjointSet ds = new DisjointSet(n);\n        int mstWeight = 0;\n\n        for (Edge edge : edges) {\n            int x = ds.find(edge.src);\n            int y = ds.find(edge.dest);\n\n            if (x != y) {\n                ds.union(edge.src, edge.dest);\n                mstWeight += edge.weight;\n            }\n        }\n\n        return mstWeight;\n    }\n\n    public static void main(String[] args) {\n        int n = 4; // number of vertices\n        List<Edge> edges = new ArrayList<>();\n        edges.add(new Edge(0, 1, 10));\n        edges.add(new Edge(0, 2, 6));\n        edges.add(new Edge(0, 3, 5));\n        edges.add(new Edge(1, 3, 15));\n        edges.add(new Edge(2, 3, 4));\n\n        int result = minimumSpanningTree(n, edges);\n        System.out.println(\"Minimum Spanning Tree Weight: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 22:11:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) return;\n\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n};\n\nstruct Edge {\n    int src, dest, weight;\n    \n    bool operator<(const Edge& other) const {\n        return weight < other.weight;\n    }\n};\n\nint kruskalMST(int V, vector<Edge>& edges) {\n    sort(edges.begin(), edges.end());\n    \n    DisjointSet ds(V);\n    int mstWeight = 0;\n\n    for (const Edge& edge : edges) {\n        if (ds.find(edge.src) != ds.find(edge.dest)) {\n            ds.unionSets(edge.src, edge.dest);\n            mstWeight += edge.weight;\n        }\n    }\n\n    return mstWeight;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<Edge> edges(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edges[i].src >> edges[i].dest >> edges[i].weight;\n        edges[i].src--;\n        edges[i].dest--;\n    }\n\n    int minSpanningTreeWeight = kruskalMST(V, edges);\n    cout << minSpanningTreeWeight << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef prims_mst(n, adj):\n    visited = [False] * n\n    minHeap = [(0, 0)]  # (cost, vertex)\n    total_weight = 0\n    \n    while minHeap:\n        weight, u = heapq.heappop(minHeap)\n        \n        if visited[u]:\n            continue\n        \n        total_weight += weight\n        visited[u] = True\n        \n        for v, edge_weight in adj[u]:\n            if not visited[v]:\n                heapq.heappush(minHeap, (edge_weight, v))\n    \n    return total_weight\n\ndef min_spanning_tree(n, edges):\n    # build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v, weight in edges:\n        adj[u].append((v, weight))\n        adj[v].append((u, weight))\n    \n    # find total weight of MST using Prim's\n    return prims_mst(n, adj)\n\n# Example graph\nn = 4  # number of vertices\nedges = [\n    (0, 1, 1),\n    (0, 2, 2),\n    (1, 2, 4),\n    (1, 3, 6),\n    (2, 3, 3)\n]\n\nprint(min_spanning_tree(n, edges))",
    "timestamp": "2025-08-13 09:17:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinimumSpanningTree {\n\n    static class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n\n        public int compareTo(Edge compareEdge) {\n            return this.weight - compareEdge.weight;\n        }\n    }\n\n    static class Subset {\n        int parent, rank;\n    }\n\n    int vertices, edges;\n    Edge[] edge;\n\n    MinimumSpanningTree(int v, int e) {\n        vertices = v;\n        edges = e;\n        edge = new Edge[e];\n        for (int i = 0; i < e; ++i)\n            edge[i] = new Edge();\n    }\n\n    int find(Subset[] subsets, int i) {\n        if (subsets[i].parent != i)\n            subsets[i].parent = find(subsets, subsets[i].parent);\n        return subsets[i].parent;\n    }\n\n    void union(Subset[] subsets, int x, int y) {\n        int xroot = find(subsets, x);\n        int yroot = find(subsets, y);\n\n        if (subsets[xroot].rank < subsets[yroot].rank)\n            subsets[xroot].parent = yroot;\n        else if (subsets[xroot].rank > subsets[yroot].rank)\n            subsets[yroot].parent = xroot;\n\n        else {\n            subsets[yroot].parent = xroot;\n            subsets[xroot].rank++;\n        }\n    }\n\n    void kruskalMST() {\n        Edge[] result = new Edge[vertices];\n        int e = 0;\n        int i = 0;\n        for (i = 0; i < vertices; ++i)\n            result[i] = new Edge();\n\n        Arrays.sort(edge);\n        Subset[] subsets = new Subset[vertices];\n        for (i = 0; i < vertices; ++i)\n            subsets[i] = new Subset();\n\n        for (int v = 0; v < vertices; ++v) {\n            subsets[v].parent = v;\n            subsets[v].rank = 0;\n        }\n\n        i = 0;\n\n        while (e < vertices - 1) {\n            Edge next_edge = edge[i++];\n            int x = find(subsets, next_edge.src);\n            int y = find(subsets, next_edge.dest);\n\n            if (x != y) {\n                result[e++] = next_edge;\n                union(subsets, x, y);\n            }\n        }\n\n        int totalWeight = 0;\n        for (i = 0; i < e; ++i)\n            totalWeight += result[i].weight;\n        \n        System.out.println(totalWeight);\n    }\n\n    public static void main(String[] args) {\n        int vertices = 4;  \n        int edges = 5;  \n        MinimumSpanningTree graph = new MinimumSpanningTree(vertices, edges);\n\n        graph.edge[0].src = 0;\n        graph.edge[0].dest = 1;\n        graph.edge[0].weight = 10;\n\n        graph.edge[1].src = 0;\n        graph.edge[1].dest = 2;\n        graph.edge[1].weight = 6;\n\n        graph.edge[2].src = 0;\n        graph.edge[2].dest = 3;\n        graph.edge[2].weight = 5;\n\n        graph.edge[3].src = 1;\n        graph.edge[3].dest = 3;\n        graph.edge[3].weight = 15;\n\n        graph.edge[4].src = 2;\n        graph.edge[4].dest = 3;\n        graph.edge[4].weight = 4;\n\n        graph.kruskalMST();\n    }\n}",
    "timestamp": "2025-08-13 09:17:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODES 1000\n#define INF 1000000000\n\ntypedef struct Edge {\n    int u, v, weight;\n} Edge;\n\nEdge edges[MAX_NODES * MAX_NODES];\nint parent[MAX_NODES];\nint rank[MAX_NODES];\nint numEdges = 0;\n\nint compareEdges(const void *a, const void *b) {\n    return ((Edge*)a)->weight - ((Edge*)b)->weight;\n}\n\nvoid makeSet(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint findSet(int u) {\n    if (u != parent[u]) {\n        parent[u] = findSet(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid unionSets(int u, int v) {\n    int rootU = findSet(u);\n    int rootV = findSet(v);\n    if (rootU != rootV) {\n        if (rank[rootU] < rank[rootV]) {\n            parent[rootU] = rootV;\n        } else if (rank[rootU] > rank[rootV]) {\n            parent[rootV] = rootU;\n        } else {\n            parent[rootV] = rootU;\n            rank[rootU]++;\n        }\n    }\n}\n\nint kruskalMST(int n) {\n    qsort(edges, numEdges, sizeof(Edge), compareEdges);\n    makeSet(n);\n    int mstWeight = 0;\n    for (int i = 0; i < numEdges; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int weight = edges[i].weight;\n        if (findSet(u) != findSet(v)) {\n            mstWeight += weight;\n            unionSets(u, v);\n        }\n    }\n    return mstWeight;\n}\n\nint main() {\n    int n, e;\n    scanf(\"%d %d\", &n, &e);\n    for (int i = 0; i < e; i++) {\n        int u, v, weight;\n        scanf(\"%d %d %d\", &u, &v, &weight);\n        edges[numEdges++] = (Edge){u, v, weight};\n    }\n    int mstWeight = kruskalMST(n);\n    printf(\"%d\\n\", mstWeight);\n    return 0;\n}",
    "timestamp": "2025-08-13 09:17:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class DisjointSet:\n    def __init__(self, vertices):\n        self.parent = list(range(vertices))\n        self.rank = [0] * vertices\n\n    def find(self, item):\n        if self.parent[item] != item:\n            self.parent[item] = self.find(self.parent[item])\n        return self.parent[item]\n\n    def union(self, x, y):\n        xroot = self.find(x)\n        yroot = self.find(y)\n        \n        if self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        elif self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n\ndef kruskal_mst(vertices, edges):\n    edges.sort(key=lambda x: x[2])\n    disjoint_set = DisjointSet(vertices)\n    mst_weight = 0\n    \n    for edge in edges:\n        u, v, weight = edge\n        if disjoint_set.find(u) != disjoint_set.find(v):\n            disjoint_set.union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Input reading\nV, E = map(int, input().split())\nedges = []\n\nfor _ in range(E):\n    u, v, weight = map(int, input().split())\n    edges.append((u-1, v-1, weight))\n\nprint(kruskal_mst(V, edges))",
    "timestamp": "2025-08-13 09:17:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef prim_mst(graph):\n    n = len(graph)\n    visited = [False] * n\n    min_heap = []\n    total_weight = 0\n    \n    # Start with node 0\n    heapq.heappush(min_heap, (0, 0))\n    \n    while min_heap:\n        weight, u = heapq.heappop(min_heap)\n        if visited[u]:\n            continue\n        visited[u] = True\n        total_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(min_heap, (w, v))\n    \n    return total_weight\n\n# Read input\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\n# Compute MST weight\nmst_weight = prim_mst(graph)\nprint(mst_weight)",
    "timestamp": "2025-08-13 09:17:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n    bool operator<(const Edge& other) const {\n        return weight < other.weight;\n    }\n};\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n, 1) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    }\n\n    bool unite(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU != rootV) {\n            if (rank[rootU] < rank[rootV]) {\n                parent[rootU] = rootV;\n            } else if (rank[rootU] > rank[rootV]) {\n                parent[rootV] = rootU;\n            } else {\n                parent[rootV] = rootU;\n                ++rank[rootU];\n            }\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<Edge> edges(E);\n    for (int i = 0; i < E; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n    }\n\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(V);\n    int mstWeight = 0;\n    for (const Edge& edge : edges) {\n        if (uf.unite(edge.u, edge.v)) {\n            mstWeight += edge.weight;\n        }\n    }\n\n    cout << mstWeight << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:50:33"
  }
]