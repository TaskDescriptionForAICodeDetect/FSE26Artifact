[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NODES 100001\n\nint parent[MAX_NODES];\nint depth[MAX_NODES];\n\nvoid init_tree(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = -1;\n        depth[i] = 0;\n    }\n}\n\nvoid set_parent(int node, int par) {\n    parent[node] = par;\n    depth[node] = (par == -1) ? 0 : depth[par] + 1;\n}\n\nint find_lca(int u, int v) {\n    while (depth[u] > depth[v]) {\n        u = parent[u];\n    }\n    \n    while (depth[v] > depth[u]) {\n        v = parent[v];\n    }\n    \n    while (u != v) {\n        u = parent[u];\n        v = parent[v];\n    }\n    \n    return u;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    \n    init_tree(n);\n    \n    for (int i = 1; i < n; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        set_parent(i, p);\n    }\n    \n    while (q--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        printf(\"%d\\n\", find_lca(u, v));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NODES 1000\n#define LOG 10\n\nint parent[MAX_NODES][LOG];\nint depth[MAX_NODES];\nint adj[MAX_NODES][MAX_NODES];\nint adj_size[MAX_NODES];\n\nvoid dfs(int u, int p) {\n    parent[u][0] = p;\n    depth[u] = depth[p] + 1;\n    for (int i = 1; i < LOG; i++) {\n        parent[u][i] = parent[parent[u][i-1]][i-1];\n    }\n    for (int i = 0; i < adj_size[u]; i++) {\n        int v = adj[u][i];\n        if (v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    for (int i = LOG - 1; i >= 0; i--) {\n        if (depth[u] - (1 << i) >= depth[v]) {\n            u = parent[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        adj_size[i] = 0;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        adj[p][adj_size[p]++] = i;\n    }\n    \n    depth[0] = -1;\n    dfs(0, 0);\n    \n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        printf(\"%d\\n\", lca(u, v));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> depth;\nvector<vector<int>> parent;\nint LOG;\n\nvoid dfs(int u, int p) {\n    parent[u][0] = p;\n    for (int i = 1; i < LOG; ++i) {\n        if (parent[u][i-1] != -1) {\n            parent[u][i] = parent[parent[u][i-1]][i-1];\n        }\n    }\n    for (int v : adj[u]) {\n        if (v != p) {\n            depth[v] = depth[u] + 1;\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) swap(u, v);\n    for (int i = LOG - 1; i >= 0; --i) {\n        if (depth[u] - (1 << i) >= depth[v]) {\n            u = parent[u][i];\n        }\n    }\n    if (u == v) return u;\n    for (int i = LOG - 1; i >= 0; --i) {\n        if (parent[u][i] != -1 && parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    adj.resize(n);\n    for (int i = 1; i < n; ++i) {\n        int p;\n        cin >> p;\n        adj[p].push_back(i);\n        adj[i].push_back(p);\n    }\n\n    LOG = 0;\n    while ((1 << LOG) <= n) ++LOG;\n    depth.assign(n, 0);\n    parent.assign(n, vector<int>(LOG, -1));\n    dfs(0, -1);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LCATree {\n    private List<List<Integer>> adj;\n    private int[] depth;\n    private int[][] parent;\n    private int LOG;\n\n    public LCATree(int n) {\n        adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        LOG = 1;\n        while ((1 << LOG) <= n) {\n            LOG++;\n        }\n        depth = new int[n];\n        parent = new int[n][LOG];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(parent[i], -1);\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adj.get(u).add(v);\n        adj.get(v).add(u);\n    }\n\n    public void preprocess(int root) {\n        dfs(root, -1);\n        for (int k = 1; k < LOG; k++) {\n            for (int v = 0; v < parent.length; v++) {\n                if (parent[v][k - 1] != -1) {\n                    parent[v][k] = parent[parent[v][k - 1]][k - 1];\n                }\n            }\n        }\n    }\n\n    private void dfs(int u, int p) {\n        parent[u][0] = p;\n        for (int v : adj.get(u)) {\n            if (v != p) {\n                depth[v] = depth[u] + 1;\n                dfs(v, u);\n            }\n        }\n    }\n\n    public int lca(int u, int v) {\n        if (depth[u] < depth[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n        for (int k = LOG - 1; k >= 0; k--) {\n            if (depth[u] - (1 << k) >= depth[v]) {\n                u = parent[u][k];\n            }\n        }\n        if (u == v) {\n            return u;\n        }\n        for (int k = LOG - 1; k >= 0; k--) {\n            if (parent[u][k] != -1 && parent[u][k] != parent[v][k]) {\n                u = parent[u][k];\n                v = parent[v][k];\n            }\n        }\n        return parent[u][0];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        LCATree tree = new LCATree(n);\n        for (int i = 1; i < n; i++) {\n            int parent = scanner.nextInt();\n            tree.addEdge(parent, i);\n        }\n        tree.preprocess(0);\n        int m = scanner.nextInt();\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            System.out.println(tree.lca(u, v));\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:22:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LowestCommonAncestor {\n    private static List<List<Integer>> tree;\n    private static int[] parent;\n    private static int[] depth;\n    private static int maxLog;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        \n        tree = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            tree.add(new ArrayList<>());\n        }\n        \n        parent = new int[n];\n        depth = new int[n];\n        \n        maxLog = (int) (Math.log(n) / Math.log(2)) + 1;\n        int[][] ancestor = new int[n][maxLog];\n        \n        // Build tree\n        for (int i = 1; i < n; i++) {\n            int p = scanner.nextInt();\n            tree.get(p).add(i);\n            parent[i] = p;\n        }\n        \n        // Perform DFS to set depths\n        dfs(0, 0);\n        \n        // Precompute ancestors\n        for (int j = 0; j < maxLog; j++) {\n            for (int i = 0; i < n; i++) {\n                if (j == 0) {\n                    ancestor[i][j] = parent[i];\n                } else {\n                    int mid = ancestor[i][j-1];\n                    ancestor[i][j] = (mid == -1) ? -1 : ancestor[mid][j-1];\n                }\n            }\n        }\n        \n        // Process queries\n        int q = scanner.nextInt();\n        for (int i = 0; i < q; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            System.out.println(lca(u, v, ancestor));\n        }\n        \n        scanner.close();\n    }\n    \n    private static void dfs(int node, int currentDepth) {\n        depth[node] = currentDepth;\n        for (int child : tree.get(node)) {\n            dfs(child, currentDepth + 1);\n        }\n    }\n    \n    private static int lca(int u, int v, int[][] ancestor) {\n        // Ensure u is the deeper node\n        if (depth[u] < depth[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n        \n        // Lift u to same depth as v\n        for (int j = maxLog - 1; j >= 0; j--) {\n            if (depth[u] - (1 << j) >= depth[v]) {\n                u = ancestor[u][j];\n            }\n        }\n        \n        // If u is v, we're done\n        if (u == v) return u;\n        \n        // Lift both u and v\n        for (int j = maxLog - 1; j >= 0; j--) {\n            if (ancestor[u][j] != ancestor[v][j]) {\n                u = ancestor[u][j];\n                v = ancestor[v][j];\n            }\n        }\n        \n        return parent[u];\n    }\n}",
    "timestamp": "2025-08-05 22:22:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nclass LCA {\nprivate:\n    int n, log_n;\n    vector<vector<int>> parent;\n    vector<int> depth;\n\n    void dfs(int node, int par, vector<vector<int>>& adj) {\n        parent[node][0] = par;\n        for (int next : adj[node]) {\n            if (next != par) {\n                depth[next] = depth[node] + 1;\n                dfs(next, node, adj);\n            }\n        }\n    }\n\n    void precompute_parents() {\n        for (int j = 1; j < log_n; j++) {\n            for (int i = 0; i < n; i++) {\n                if (parent[i][j-1] != -1) {\n                    parent[i][j] = parent[parent[i][j-1]][j-1];\n                }\n            }\n        }\n    }\n\npublic:\n    LCA(int nodes, vector<vector<int>>& adj) {\n        n = nodes;\n        log_n = log2(n) + 1;\n        parent.assign(n, vector<int>(log_n, -1));\n        depth.assign(n, 0);\n        dfs(0, -1, adj);\n        precompute_parents();\n    }\n\n    int get_lca(int u, int v) {\n        if (depth[u] < depth[v]) swap(u, v);\n        \n        for (int j = log_n - 1; j >= 0; j--) {\n            if (depth[u] - (1 << j) >= depth[v]) {\n                u = parent[u][j];\n            }\n        }\n        \n        if (u == v) return u;\n        \n        for (int j = log_n - 1; j >= 0; j--) {\n            if (parent[u][j] != parent[v][j]) {\n                u = parent[u][j];\n                v = parent[v][j];\n            }\n        }\n        \n        return parent[u][0];\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    vector<vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int parent;\n        cin >> parent;\n        adj[parent].push_back(i);\n        adj[i].push_back(parent);\n    }\n    \n    LCA lca(n, adj);\n    \n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.get_lca(u, v) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeAncestor:\n    def __init__(self, n, parent):\n        self.LOG = 1\n        while (1 << self.LOG) <= n:\n            self.LOG += 1\n        self.up = [[-1] * self.LOG for _ in range(n)]\n        self.depth = [0] * n\n\n        for v in range(n):\n            self.up[v][0] = parent[v]\n            if parent[v] != -1:\n                self.depth[v] = self.depth[parent[v]] + 1\n\n        for j in range(1, self.LOG):\n            for v in range(n):\n                if self.up[v][j - 1] != -1:\n                    self.up[v][j] = self.up[self.up[v][j - 1]][j - 1]\n\n    def get_lca(self, u, v):\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n\n        # Lift u to the same depth as v\n        for i in range(self.LOG - 1, -1, -1):\n            if (self.depth[u] - (1 << i)) >= self.depth[v]:\n                u = self.up[u][i]\n\n        if u == v:\n            return u\n\n        for i in range(self.LOG - 1, -1, -1):\n            if self.up[u][i] != self.up[v][i]:\n                u = self.up[u][i]\n                v = self.up[v][i]\n\n        return self.up[u][0]\n\ndef lowest_common_ancestor(n, parent, queries):\n    tree_ancestor = TreeAncestor(n, parent)\n    return [tree_ancestor.get_lca(u, v) for u, v in queries]\n\n# Example usage:\n# n = 5\n# parent = [-1, 0, 0, 1, 1]\n# queries = [(3, 4), (2, 4), (2, 3)]\n# print(lowest_common_ancestor(n, parent, queries))  # Output: [1, 0, 0]",
    "timestamp": "2025-08-13 10:13:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LCASolver {\n    private int[][] parent;\n    private int[] depth;\n    private int log;\n    private List<List<Integer>> tree;\n    private int n;\n\n    public LCASolver(int n, List<List<Integer>> tree) {\n        this.n = n;\n        this.tree = tree;\n        this.log = (int) (Math.log(n) / Math.log(2)) + 1;\n        this.parent = new int[n][log];\n        this.depth = new int[n];\n        preprocess(0, -1); // Preprocess starting at the root node\n    }\n\n    private void preprocess(int node, int par) {\n        parent[node][0] = par;\n        if (par != -1) {\n            depth[node] = depth[par] + 1;\n        }\n        for (int i = 1; i < log; i++) {\n            if (parent[node][i - 1] != -1) {\n                parent[node][i] = parent[parent[node][i - 1]][i - 1];\n            } else {\n                parent[node][i] = -1;\n            }\n        }\n        for (int child : tree.get(node)) {\n            if (child != par) {\n                preprocess(child, node);\n            }\n        }\n    }\n\n    public int findLCA(int u, int v) {\n        if (depth[u] < depth[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n\n        int diff = depth[u] - depth[v];\n        for (int i = 0; i < log; i++) {\n            if ((diff & (1 << i)) != 0) {\n                u = parent[u][i];\n            }\n        }\n\n        if (u == v) {\n            return u;\n        }\n\n        for (int i = log - 1; i >= 0; i--) {\n            if (parent[u][i] != parent[v][i]) {\n                u = parent[u][i];\n                v = parent[v][i];\n            }\n        }\n\n        return parent[u][0];\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        List<List<Integer>> tree = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tree.add(new ArrayList<>());\n        }\n\n        tree.get(0).add(1);\n        tree.get(0).add(2);\n        tree.get(1).add(3);\n        tree.get(1).add(4);\n\n        LCASolver solver = new LCASolver(n, tree);\n        System.out.println(solver.findLCA(3, 4)); // Output: 1\n        System.out.println(solver.findLCA(2, 4)); // Output: 0\n    }\n}",
    "timestamp": "2025-08-13 10:13:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000\n#define LOG_MAX_N 10\n\nint parent[MAX_N][LOG_MAX_N];\nint depth[MAX_N];\nint n;\n\n// Function to prepare the depth and parent arrays\nvoid dfs(int node, int par, int dep, int adj[MAX_N][MAX_N]) {\n    parent[node][0] = par;\n    depth[node] = dep;\n    for (int i = 1; i < LOG_MAX_N; i++) {\n        if (parent[node][i - 1] != -1) {\n            parent[node][i] = parent[parent[node][i - 1]][i - 1];\n        } else {\n            parent[node][i] = -1;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (adj[node][i] == 1 && i != par) {\n            dfs(i, node, dep + 1, adj);\n        }\n    }\n}\n\n// Function to find LCA of u and v\nint findLCA(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n\n    int diff = depth[u] - depth[v];\n    for (int i = 0; i < LOG_MAX_N; i++) {\n        if ((diff >> i) & 1) {\n            u = parent[u][i];\n        }\n    }\n\n    if (u == v) return u;\n\n    for (int i = LOG_MAX_N - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\nint main() {\n    int adj[MAX_N][MAX_N];\n    memset(adj, 0, sizeof(adj));\n    memset(parent, -1, sizeof(parent));\n    memset(depth, 0, sizeof(depth));\n\n    int m;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        adj[u][v] = 1;\n        adj[v][u] = 1;\n    }\n\n    dfs(0, -1, 0, adj);\n\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        printf(\"%d\\n\", findLCA(u, v));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:13:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class LCA:\n    def __init__(self, n):\n        self.n = n\n        self.depth = [0] * n\n        self.parent = [0] * n\n        self.log = 0\n        while (1 << self.log) <= n:\n            self.log += 1\n        self.up = [[0] * self.log for _ in range(n)]\n\n    def dfs(self, node, parent, curr_depth):\n        self.parent[node] = parent\n        self.depth[node] = curr_depth\n        self.up[node][0] = parent\n        \n        for j in range(1, self.log):\n            self.up[node][j] = self.up[self.up[node][j-1]][j-1]\n        \n        for child in graph[node]:\n            if child != parent:\n                self.dfs(child, node, curr_depth + 1)\n\n    def get_lca(self, u, v):\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        \n        # Move u up to same depth as v\n        for j in range(self.log-1, -1, -1):\n            if self.depth[u] - (1 << j) >= self.depth[v]:\n                u = self.up[u][j]\n        \n        if u == v:\n            return u\n        \n        # Move up together\n        for j in range(self.log-1, -1, -1):\n            if self.up[u][j] != self.up[v][j]:\n                u = self.up[u][j]\n                v = self.up[v][j]\n        \n        return self.parent[u]\n\n# Input and processing\nn = int(input())\ngraph = [[] for _ in range(n)]\n\n# Build graph\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\n# Create LCA object and run DFS from root\nlca_solver = LCA(n)\nlca_solver.dfs(0, 0, 0)\n\n# Process queries\nq = int(input())\nfor _ in range(q):\n    u, v = map(int, input().split())\n    print(lca_solver.get_lca(u, v))",
    "timestamp": "2025-08-13 10:14:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom math import log2, floor\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    parent = [0] * n\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        p = int(input[ptr])\n        ptr += 1\n        parent[i] = p\n        children[p].append(i)\n    \n    LOG = floor(log2(n)) + 1\n    up = [[-1] * n for _ in range(LOG)]\n    depth = [0] * n\n    \n    # BFS to set up initial parent and depth\n    q = deque([0])\n    up[0][0] = -1\n    while q:\n        u = q.popleft()\n        for v in children[u]:\n            depth[v] = depth[u] + 1\n            up[0][v] = u\n            q.append(v)\n    \n    # Binary lifting table\n    for k in range(1, LOG):\n        for v in range(n):\n            if up[k-1][v] != -1:\n                up[k][v] = up[k-1][up[k-1][v]]\n            else:\n                up[k][v] = -1\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u up to the depth of v\n        for k in range(LOG-1, -1, -1):\n            if depth[u] - (1 << k) >= depth[v]:\n                u = up[k][u]\n        if u == v:\n            return u\n        for k in range(LOG-1, -1, -1):\n            if up[k][u] != -1 and up[k][u] != up[k][v]:\n                u = up[k][u]\n                v = up[k][v]\n        return up[0][u]\n    \n    q = int(input[ptr])\n    ptr += 1\n    output = []\n    for _ in range(q):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        ptr += 2\n        output.append(str(lca(u, v)))\n    print('\\n'.join(output))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:14:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nclass Tree {\n  private:\n    int n, LOG;\n    vector<vector<int>> up;\n    vector<int> depth;\n    vector<vector<int>> adj;\n\n  public:\n    Tree(int n) : n(n), LOG(log2(n) + 1), adj(n), depth(n) {\n        up.assign(n, vector<int>(LOG));\n    }\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    void dfs(int v, int p) {\n        up[v][0] = p;\n        for (int i = 1; i < LOG; ++i) {\n            up[v][i] = up[up[v][i - 1]][i - 1];\n        }\n        for (int u : adj[v]) {\n            if (u != p) {\n                depth[u] = depth[v] + 1;\n                dfs(u, v);\n            }\n        }\n    }\n\n    int lca(int u, int v) {\n        if (depth[u] < depth[v]) {\n            swap(u, v);\n        }\n        int diff = depth[u] - depth[v];\n        for (int i = LOG - 1; i >= 0; --i) {\n            if ((1 << i) & diff) {\n                u = up[u][i];\n            }\n        }\n        if (u == v) {\n            return u;\n        }\n        for (int i = LOG - 1; i >= 0; --i) {\n            if (up[u][i] != up[v][i]) {\n                u = up[u][i];\n                v = up[v][i];\n            }\n        }\n        return up[u][0];\n    }\n\n    void prepare(int root) {\n        depth[root] = 0;\n        dfs(root, root);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n;\n    Tree tree(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        tree.addEdge(u, v);\n    }\n    tree.prepare(0); // Assuming 0 is the root\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:57:44"
  }
]