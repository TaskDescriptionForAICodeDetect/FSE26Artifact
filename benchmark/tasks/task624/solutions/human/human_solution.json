[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.io.StdIn._\n\nobject Main extends App {\n  val n = readInt\n  val nodes = Array.fill(n){Nil: List[Int]}\n  for (i ← 0 until n) {\n    val _::t = readLine.trim.split(' ').map(_.toInt).toList\n    nodes(i) = t\n  }\n  val parents = Array.fill(n){ArrayBuffer[Int]()}\n  val height = Array.fill(n){0}\n  val queue = mutable.Queue(0)\n  while (queue.nonEmpty) {\n    val current = queue.dequeue()\n    for (next ← nodes(current)) {\n      height(next) = height(current) + 1\n      parents(next).append(current)\n      while (parents(parents(next).last).length >= parents(next).length){\n        parents(next).append(parents(parents(next).last)(parents(next).length - 1))\n      }\n      queue.enqueue(next)\n    }\n  }\n  val q = readInt\n  for (_ ← 0 until q) {\n    val Array(u, v) = readLine.trim.split(' ').map(_.toInt)\n    var ua = u\n    var uv = v\n    while (ua != uv) {\n      if (height(ua) == height(uv)){\n        var left = 0\n        var right = parents(ua).length\n        while (left < right) {\n          val mid = (left + right) / 2\n          if (parents(ua)(mid) != parents(uv)(mid)) left = mid + 1\n          else right = mid\n        }\n        if (right != 0) right -= 1\n        ua = parents(ua)(right)\n        uv = parents(uv)(right)\n      }else if (height(ua) < height(uv)) {\n        var left = 0\n        var right = parents(uv).length\n        while (left < right) {\n          val mid = (left + right) / 2\n          if (height(parents(uv)(mid)) >= height(ua)) left = mid + 1\n          else right = mid\n        }\n        uv = parents(uv)(right - 1)\n      }else {\n        var left = 0\n        var right = parents(ua).length\n        while (left < right) {\n          val mid = (left + right) / 2\n          if (height(parents(ua)(mid)) >= height(uv)) left = mid + 1\n          else right = mid\n        }\n        ua = parents(ua)(right - 1)\n      }\n    }\n    println(ua)\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nstruct LCA {\n    int V;//頂点数\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    int MAX_LOG_V = 0;\n    int root = 0;//根ノードの番号\n\n    vector<vector<int>> parent;//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1とする)\n    vector<int> depth;//根からの深さ\n\n    LCA(int V) {\n        this->V = V;\n        while (1 << MAX_LOG_V < V) {//バグが怖い\n            MAX_LOG_V++;\n        }\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n\n    /**\n     * 辺を追加した後に初期化をする\n     */\n    void init() {\n        //parentとdepthの初期化\n        dfs(root, -1, 0);\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n\n    /**\n     * uとvのlcaを求める\n     * @param u 頂点\n     * @param v 頂点\n     * @return lcaとなる頂点\n     */\n    int lca(int u, int v) {\n        //uとvの高さが同じになるまで親を辿る\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k < MAX_LOG_V; k++) {\n            if((depth[v] - depth[u]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        //二分探索でLCAを求める\n        for (int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /**\n     * 辺を追加する\n     * @param from 元\n     * @param to 先\n     */\n    void add_edge(int from,int to){\n        G[from].push_back(to);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.init();\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n//    cout << \"---\" << endl;\n//    rep(i,0,lca.G.size()){\n//        rep(j,0,lca.G[i].size()){\n//            cout << i << \" \" << lca.G[i][j] << endl;\n//        }\n//    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\nclass RMQ{//RangeMinimumQuery\n\tint n;\n\tstd::vector<int> dat,idx;\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return dat.size()-1;\n\t\tif(a<=l&&r<=b)return idx[k];\n\t\telse{\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn dat[vl]<dat[vr]?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQ(){}\n\t~RMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tn=calcsize(a.size());\n\t\tidx.resize(2*n-1);\n\t\tfor(int i=0;i<(int)a.size();i++)idx[n-1+i]=i;\n\t\tfor(int i=a.size();i<n;i++)idx[n-1+i]=a.size();\n\t\tdat=a;\n\t\tdat.push_back(INT_MAX);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tidx[i]=dat[idx[i*2+1]]<dat[idx[i*2+2]]?idx[i*2+1]:idx[i*2+2];\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\tRMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nclass LCA{\n\tint log,n;\n\tstd::vector<int> depth,par;\n\tint dfs(const int parent[],int u){\n\t\tif(parent[u]==-1)return depth[u]=1;\n\t\tif(depth[u]!=0)return depth[u];\n\t\treturn depth[u]=dfs(parent,parent[u])+1;\n\t}\npublic:\n\tLCA(const int parent[],int n):n(n),depth(n,0){\n\t\tlog=1;\n\t\twhile((1<<log)<n)log++;\n\t\tlog++;\n\t\tfor(int i=0;i<n;i++)dfs(parent,i);\n\t\tpar.resize(n*log);\t\n\t\tfor(int i=0;i<n;i++)par[i]=parent[i];\n\t\tfor(int i=1;i<log;i++)\n\t\t\tfor(int v=0;v<n;v++)\n\t\t\t\tpar[i*n+v]=par[(i-1)*n+par[(i-1)*n+v]];\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(depth[u] > depth[v])std::swap(u,v);\n\t\tfor(int i=log-1;i>=0;i--)\n\t\t\tif(depth[u] <= depth[v]-(1<<i))\n\t\t\t\tv=par[i*n+v];\n\t\tfor(int i=log-1;i>=1;i--){\n\t\t\tif(par[i*n+u]!=par[i*n+v]){\n\t\t\t\tu=par[i*n+u];\n\t\t\t\tv=par[i*n+v];\n\t\t\t}\n\t\t}\n\t\treturn par[u];\n\t}\n};\n\nusing namespace std;\n\nint par[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)par[i]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tpar[v]=i;\n\t\t}\n\t}\n\tLCA lca(par,n);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 10005;\nconst int MAX_N = 100010;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n * n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int par, int d, int &k){\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(G[v][i] != par){\n                    dfs(G[v][i], v, d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, -1, 0, k);\n            rmqInit(depth,k * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n/*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n*/\n\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint N;\nvi depth;\nint maxdepth = 0;\nGraph G;\nvvi dblpar;\n\nvoid dfs1(int pos, int d = 0) {\n\tdepth[pos] = d;\n\tmaxdepth = max(maxdepth, d);\n\tfor (auto ch : G[pos]) {\n\t\tdfs1(ch.to, d + 1);\n\t}\n}\n\nvoid dfs2(int pos, int par, int dbl) {\n\tif (dbl == 0) {\n\t\tdblpar[0][pos] = par;\n\t}\n\telse {\n\t\tdblpar[dbl][pos] = dblpar[dbl - 1][dblpar[dbl - 1][pos]];\n\t}\n\tfor (auto ch : G[pos]) {\n\t\tdfs2(ch.to, pos, dbl);\n\t}\n}\n\nint parent(int pos, int step) {\n\tint ret = pos;\n\tint dbl = 0;\n\twhile (step > 0) {\n\t\tif ((step & 1) != 0) {\n\t\t\tret = dblpar[dbl][ret];\n\t\t}\n\t\tstep >>= 1;\n\t\tdbl++;\n\t}\n\treturn ret;\n}\n\nint bindigit(int n) {\n\tint ret = 0;\n\twhile (n > 0) {\n\t\tret++;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\tdepth = vi(N);\n\tG = Graph(N);\n\trep(i, N) {\n\t\tint num;\n\t\tcin >> num;\n\t\trep(j, num) {\n\t\t\tint ch;\n\t\t\tcin >> ch;\n\t\t\tG[i].push_back(Edge{ i,ch,1 });\n\t\t}\n\t}\n\n\tdfs1(0);\n\tint D = bindigit(maxdepth) + 1;\n\tdblpar = vvi(D, vi(N));\n\trep(i, D) {\n\t\tdfs2(0, 0, i);\n\t}\n\t/*\n\trep(i, N) {\n\t\tcout << depth[i] << \":\";\n\t\trep(j, D) {\n\t\t\tcout << dblpar[j][i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\tint Q;\n\tcin >> Q;\n\trep(q, Q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (depth[u] < depth[v]) {\n\t\t\tswap(u, v);\n\t\t}\n\t\tu = parent(u, depth[u] - depth[v]);\n\t\t// u,v???????????±???\n\t\tif (u == v) {\n\t\t\tcout << u << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ng = -1, ok = D - 1;\n\t\twhile (ok - ng > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (dblpar[mid][u] == dblpar[mid][v]) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\tcout << dblpar[ok][u] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n\nclass Tree {\n\tprivate:\n\t\tvector<vector<size_t> > children;\n\n\tpublic:\n\t\tTree (const size_t &verticesCount) {\n\t\t\tchildren.resize(verticesCount);\n\t\t}\n\n\t\tvoid addEdge (const size_t &parent, const size_t &child) {\n\t\t\tchildren[parent].push_back(child);\n\t\t}\n\n\t\tvoid DFS (vector<size_t> &depthList, vector<size_t> &verticesList, vector<size_t> &indexes, const size_t &vertex = 0, const size_t &depth = 0) {\n\t\t\tdepthList.push_back(depth);\n\t\t\tverticesList.push_back(vertex);\n\t\t\tindexes[vertex] = verticesList.size() - 1;\n\n\t\t\tfor (const size_t &child: children[vertex]) {\n\t\t\t\tDFS(depthList, verticesList, indexes, child, depth + 1);\n\t\t\t\tdepthList.push_back(depth);\n\t\t\t\tverticesList.push_back(vertex);\n\t\t\t\tindexes[vertex] = verticesList.size() - 1;\n\t\t\t}\n\t\t}\n};\n\nclass SparseTable {\n  private:\n  \ttypedef pair<size_t, size_t> Pair;\n\tvector<vector<Pair> > table;\n\n  public:\n\tSparseTable (const vector<size_t> &sequence) {\n\t\tconst size_t length = sequence.size();\n\t\tconst size_t height = static_cast<size_t>(log2(sequence.size())) + 1;\n\t\ttable.resize(height);\n\n\t\tfor (size_t i = 0; i < length; i ++) {\n\t\t\ttable[0].push_back(make_pair(sequence[i], i));\n\t\t}\n\n\t\tfor (size_t i = 1; i < height; i ++) {\n\t\t\tconst size_t currentLength = length - pow(2, i) + 1;\n\t\t\ttable[i].resize(currentLength);\n\n\t\t\tfor (size_t j = 0; j < currentLength; j ++) {\n\t\t\t\ttable[i][j] = min<Pair>(table[i - 1][j], table[i - 1][j + pow(2, i - 1)]); \n\t\t\t}\n\t\t}\n\t}\n\n\tPair RangeMinimumQuery (const size_t left, const size_t right) {\n\t\tif (left > right) {\n\t\t\tthrow \"out of range!\";\n\t\t}\n\n\t\tconst size_t length = right - left + 1;\n\t\tconst size_t power = static_cast<size_t>(log2(length));\n\t\tconst size_t flooredLength = pow(2, power);\n\n\t\tconst Pair leftValue = table[power][left];\n\t\tconst size_t padding = length - flooredLength;\n\t\tconst Pair rightValue = table[power][left + padding];\n\n\t\treturn min<Pair>(leftValue, rightValue);\n\t}\n};\n\n\n\nint main () {\n\tsize_t verticesCount;\n\tcin >> verticesCount;\n\n\t// Build tree:\n\tTree tree(verticesCount);\n\n\tfor (size_t parent = 0; parent < verticesCount; parent ++) {\n\t\tsize_t count;\n\t\tcin >> count;\n\n\t\tfor (size_t j = 0; j < count; j ++) {\n\t\t\tsize_t child;\n\t\t\tcin >> child;\n\t\t\ttree.addEdge(parent, child);\n\t\t}\n\t}\n\n\t// Count three needed arrays:\n\tvector<size_t> depthList;\n\tvector<size_t> verticesList;\n\tvector<size_t> indexes(verticesCount);\n\ttree.DFS(depthList, verticesList, indexes);\n\n\t/*for (const size_t &el: depthList)\n\t\tcout << el << \" \";\n\tcout << endl;\n\n\tfor (const size_t &el: verticesList)\n\t\tcout << (el + 1) << \" \";\n\tcout << endl;\n\n\tfor (const size_t &el: indexes)\n\t\tcout << el << \" \";\n\tcout << endl;*/\n\n\t// Prepare Sparse table for solving RMQ:\n\tSparseTable sparseTable(depthList);\n\n\tsize_t queriesCount;\n\tcin >> queriesCount;\n\n\t// Processing queries:\n\tfor (size_t i = 0; i < queriesCount; i ++) {\n\t\tsize_t firstVertex, secondVertex;\n\t\tcin >> firstVertex >> secondVertex;\n\t\tconst size_t firstIndex = indexes[firstVertex];\n\t\tconst size_t secondIndex = indexes[secondVertex];\n\t\tconst size_t minIndex = min<size_t>(firstIndex, secondIndex);\n\t\tconst size_t maxIndex = max<size_t>(firstIndex, secondIndex);\n\t\tconst size_t index = sparseTable.RangeMinimumQuery(minIndex, maxIndex).second;\n\t\tconst size_t vertex = verticesList[index];\n\t\tcout << (vertex) << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 1<<31-1\n\n\nint n;\nvector<int> G[100000];\nvector<int> depth,vs;\nint id[100000]={};\n//pii dat[4*100000];\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n    \n    void print(){\n        rep(i,_size*2)cout<<dat[i].first<<\" \"<<dat[i].second<<endl;\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int a;\n            cin>>a;\n            G[i].pb(a);\n        }\n    }\n    \n    init();\n    segtree<pii> st(depth.size(),pii(INF,INF));\n    rep(i,depth.size()){\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int q;\n    cin>>q;\n    rep(i,q){\n        int a,b;\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n// -------------8<------- start of library -------8<------------------------\nstruct LowestCommonAncestor {\n    const int root, INF, n;\n    int size, no;\n    std::vector<std::vector<int>> adj;\n    std::vector<int> idx;\n    std::vector<std::pair<int, int>> dep;\n\n    LowestCommonAncestor(int _n, int _r = 0) :\n        root(_r), INF(INT_MAX), n(_n), adj(n), idx(n) {}\n\n    void add_edge(int u, int v) { adj[u].push_back(v); adj[v].push_back(u); }\n\n    void Dfs(int cur, int p, int d) {\n        idx[cur] = no;\n        dep[size - 1 + no++] = std::make_pair(d, cur);\n        for (int nxt : adj[cur]) {\n            if (nxt == p) continue;\n            Dfs(nxt, cur, d + 1);\n            dep[size - 1 + no++] = std::make_pair(d, cur);\n        }\n    }\n\n    void Preprocessing() {\n        for (size = 1; size < 2 * n - 1; ) size <<= 1;\n        dep.assign(2 * size - 1, std::make_pair(INF, INF));\n\n        no = 0;\n        Dfs(root, -1, 0);\n\n        for (int i = size - 2; 0 <= i; --i) {\n            if (dep[2 * i + 1] < dep[2 * i + 2]) dep[i] = dep[2 * i + 1];\n            else dep[i] = dep[2 * i + 2];\n        }\n    }\n\n    int rmq(int l, int r) {\n        std::pair<int, int> res(INF, INF);\n        l += size - 1;\n        r += size - 1;\n        while (l < r) {\n            if ((l & 1) == 0) res = std::min(res, dep[l]);\n            if ((r & 1) == 0) res = std::min(res, dep[r - 1]);\n            l >>= 1;\n            r = (r - 1) >> 1;\n        }\n        return res.second;\n    }\n\n    int query(int u, int v) {\n        if (idx[v] < idx[u]) std::swap(u, v);\n        return rmq(idx[u], idx[v] + 1);\n    }\n};\n// -------------8<------- end of library ---------8-------------------------\n\nint main() {\n    std::cin.tie(0); std::ios::sync_with_stdio(false);\n\n    // AOJ GRL_5_C: Tree - Lowest Common Ancestor\n    int n;\n    std::cin >> n;\n\n    LowestCommonAncestor lca(n, 0);\n    for (int v = 0, deg, c; v < n; ++v) {\n        std::cin >> deg;\n        while (deg--) {\n            std::cin >> c;\n            lca.add_edge(v, c);\n        }\n    }\n    lca.Preprocessing();\n\n    int q, u, v;\n    std::cin >> q;\n    while (q--) {\n        std::cin >> u >> v;\n        std::cout << lca.query(u, v) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FASTIO\nusing namespace std;\n\nusing ll = long long;\nusing Vi = vector<int>;\nusing Vl = vector<ll>;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\nconstexpr int I_INF = numeric_limits<int>::max();\nconstexpr ll L_INF = numeric_limits<ll>::max();\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nclass LCA {\n    using Adj = std::vector<std::vector<int>>;  // 隣接リスト\n\nprivate:\n    int n;                              // 要素数\n    int logn;                           // floor(log2(n)) + 1\n    int root;                           // 根\n    std::vector<std::vector<int>> par;  // par[k][i]: i番目のノードの2^k番目の親\n    std::vector<int> dep;               // 深さ\n\n    void init(const Adj& g, int root) {\n        n = static_cast<int>(g.size());\n        root = root;\n\n        logn = 1;\n        while (n >> logn) ++logn;\n\n        par.assign(logn, std::vector<int>(n, -1));\n        dep.assign(n, -1);\n        dfs(g, root, -1, 0);\n\n        // parを初期化する\n        for (int k = 0; k + 1 < logn; k++) {\n            for (int i = 0; i < n; i++) {\n                if (par[k][i] != -1)\n                    par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n    }\n    // 初期化時にpar[0]やdepを求めるためのDFS\n    void dfs(const Adj& g, int v, int p, int d) {\n        par[0][v] = p;\n        dep[v] = d;\n        for (const auto& to : g[v]) {\n            if (to != p) dfs(g, to, v, d + 1);\n        }\n    }\n\npublic:\n    /**\n     * コンストラクタ\n     */\n    LCA(const Adj& g, int root) {\n        init(g, root);\n    }\n    // u と v のLCAを返す\n    int lca(int u, int v) const {\n        if (dep[u] > dep[v]) std::swap(u, v);\n\n        // u と v の深さが同じになるまで親をたどる\n        for (int k = 0; k < logn; k++) {\n            if ((dep[v] - dep[u]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n\n        if (u == v) return u;\n\n        // 二分探索する\n        for (int k = logn - 1; k >= 0; k--) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n\n        return par[0][u];\n    }\n    int parent(int idx, int d) const { return par[d][idx]; }\n};\n\nvoid solve() {\n    ll N;\n    cin >> N;\n    using Graph = vector<Vi>;\n    Graph g(N);\n    for (ll i = 0; i < N; i++) {\n        ll a;\n        cin >> a;\n        for (ll j = 0; j < a; j++) {\n            ll v;\n            cin >> v;\n            g[i].emplace_back(v);\n        }\n    }\n\n    LCA lca(g, 0);\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        ll u, v;\n        cin >> u >> v;\n        cout << lca.lca(u, v) << \"\\n\";\n    }\n}\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nint main() {\n#ifdef FASTIO\n    cin.tie(0), cout.tie(0);\n    ios::sync_with_stdio(false);\n#endif\n#ifdef FILEINPUT\n    ifstream ifs(\"./in_out/input.txt\");\n    cin.rdbuf(ifs.rdbuf());\n#endif\n#ifdef FILEOUTPUT\n    ofstream ofs(\"./in_out/output.txt\");\n    cout.rdbuf(ofs.rdbuf());\n#endif\n    solve();\n    cout << flush;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define override_rep(i, l, r, mes, ...) mes\n#define rep1(i, n) for (int i = 0; i < n; i++)\n#define rep2(i, l, r) for (int i = l; i < r; i++)\n#define rep(...) override_rep(__VA_ARGS__, rep2, rep1)(__VA_ARGS__)\ntypedef pair<int, int> P;\ntemplate<typename T, typename U>\nistream& operator>>(istream& in, pair<T, U>& p) {\n\tin >> p.first >> p.second;\n\treturn in;\n}\nvoid eulerTour(int now, int& cnt, int dist, int parent, const vector<vector<int>>& edge, vector<P>& v_arr) {\n\tv_arr[cnt++] = {dist, now};\n\tfor (auto it : edge[now]) {\n\t\tif (parent != it) {\n\t\t\teulerTour(it, cnt, dist + 1, now, edge, v_arr);\n\t\t\tv_arr[cnt++] = {dist, now};\n\t\t}\n\t}\n}\n\nvector<pair<long long, long long>> eulerTour(int v, const vector<vector<int>>& edge, int s = 0) {\n\tint cnt = 0;\n\tvector<pair<long long, long long>> v_arr((v - 1) * 2 + 1);\n\teulerTour(s, cnt, 0, -1, edge, v_arr);\n\treturn v_arr;\n}\n\nclass RMQ {\n\tvector<pair<long long, long long>> node;\n\tint size = 1;\n\tconst pair<long long, long long> inf = {INT_MAX, INT_MAX};\n\n  public:\n\tRMQ(int n) {\n\t\twhile (size < n) size *= 2;\n\t\tnode.resize(size, inf);\n\t}\n\n\tRMQ(int n, vector<pair<long long, long long>> list) {\n\t\twhile (size < n) size *= 2;\n\t\tnode.resize(size * 2, inf);\n\t\tfor (int i = 0; i < list.size(); i++) node[i + size] = list[i];\n\t\tint l = 0, r = size-1;\n\t\tl += size, r += size;\n\t\tl /= 2, r /= 2;\n\t\twhile (true) {\n\t\t\tif (l == 0) break;\n\t\t\tfor (int i = l; i <= r; i++) {\n\t\t\t\tnode[i] = min(node[i * 2], node[i * 2 + 1]);\n\t\t\t}\n\t\t\tl /= 2, r /= 2;\n\t\t}\n\t}\n\n\tvoid update(int index, pair<long long, long long> element) {\n\t\tindex += size;\n\t\tnode[index] = element;\n\t\tindex /= 2;\n\t\twhile (true) {\n\t\t\tif (index == 0) break;\n\t\t\tnode[index] = min(node[index * 2], node[index * 2 + 1]);\n\t\t\tindex /= 2;\n\t\t}\n\t}\n\n\tpair<long long, long long> query(int a, int b, int x = 1, int l = 0, int r = -1) {\n\t\tif (r == -1)r = size - 1;\n\t\tif(r<a||b<l)return inf;\n\t\tif(a<=l&&b>=r)return node[x];\n\t\treturn min(query(a,b,x*2,l,(l+r)/2),query(a,b,x*2+1,(l+r)/2+1,r));\n\t}\n};\n\nsigned main(signed argc, char* argv[]) {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tconst int MOD = 998244353;\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> e(n);\n\trep(i, n) {\n\t\tint k;\n\t\tcin>>k;\n\t\trep(j,k){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\te[i].push_back(c);\n\t\t\te[c].push_back(i);\n\t\t}\n\t}\n\tvector<P> ret = eulerTour(n, e);\n\tvector<int> memo(n+1,LLONG_MAX);\n\trep(i,ret.size()){\n\t\tmemo[ret[i].second]=min(memo[ret[i].second],i);\n\t}\n\tRMQ tree((n-1)*2+1,ret);\n\tint q;\n\tcin>>q;\n\trep(i,q){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta=memo[a],b=memo[b];\n\t\tif(a>b)swap(a,b);\n\t\tcout<<tree.query(a,b).second<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nvector<int> G[100009]; int root = 0, parent[17][100009], depth[100009];\nvoid dfs(int v, int p, int d) {\n\tparent[0][v] = p; depth[v] = d;\n\tfor (int i : G[v]) if (i != p) dfs(i, v, d + 1);\n}\nvoid init(int v) {\n\tdfs(root, -1, 0);\n\tfor (int i = 0; i < 16; i++) {\n\t\tfor (int j = 0; j < v; j++) {\n\t\t\tif (parent[i][j] < 0) parent[i + 1][j] = -1;\n\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t}\n\t}\n}\nint query(int v1, int v2) {\n\tif (depth[v1] > depth[v2]) swap(v1, v2);\n\tfor (int i = 0; i < 17; i++) {\n\t\tif ((depth[v2] - depth[v1]) >> i & 1) v2 = parent[i][v2];\n\t}\n\tif (v1 == v2) return v1;\n\tfor (int i = 16; i >= 0; i--) {\n\t\tif (parent[i][v1] != parent[i][v2]) {\n\t\t\tv1 = parent[i][v1];\n\t\t\tv2 = parent[i][v2];\n\t\t}\n\t}\n\treturn parent[0][v1];\n}\nint n, q, c, a, x, y;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &c);\n\t\tfor(int j = 0; j < c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG[i].push_back(a);\n\t\t\tG[a].push_back(i);\n\t\t}\n\t}\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tprintf(\"%d\\n\", query(x, y));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\n#define INF (1<<30)\nusing namespace std;\n\nvector<int> Ind(100010);\t\t//Ind[n]  ??\\???n???euler tour??¨??§???????????°?????????\nvector<bool> f(100010, false);\t//\nvector<vector<int>> T(100010);\t//??°??????\nvector<P> ET;                   //????????¢?´¢??¨\n\nvoid dfs(int n,int dep) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tInd[n] = ET.size() - 1;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1);\n\t\tET.emplace_back(make_pair(dep,n));\n\t}\n}\n\nP RMQ(int a, int b, int k, int l, int r, vector<P>& node) {\n\tif (r <= a || b <= l) {return P(INF, INF); }\n\tif (a <= l && r <= b) return node[k];\n\n\tP vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);\n\tP vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r, node);\n\treturn min(vl, vr);\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t//Graph initialize\n\tint n_; cin >> n_;\n\tfor (int i = 0; i < n_; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\t//ET??¨?????????\n\tdfs(0,0);\n\n\t//RMQ initialize\n\tn_ = ET.size();\n\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<P> node(2 * n - 1, P(INF, INF));\n\n\tfor (int i = 0; i < n_;i++) { node[n - 1 + i] = ET[i]; }\n\tfor (int i = n - 2; i >= 0; i--) { node[i] = min(node[2 * i + 1], node[2 * i + 2]); }\n\n\t//Answer\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tint a = Ind[u], b = Ind[v];\n\t\tif (a > b) { swap(a, b); }\n\t\tif (a == b) { cout << a << endl; continue; }\n\t\tcout << RMQ(a,b, 0, 0, n, node).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.resize(2 * size - 1);\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tif (i < n)\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = make_pair(depth[i], et[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = make_pair(INF, -1);\n\t\t\t}\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n/*\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n*/\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef pair<long long, long long> pll;\ntypedef vector<pll> vpll;\n\ntypedef long double ld;\ntypedef vector<ld> vld;\n\ntypedef vector<bool> vb;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, n) for (ll i = 1; i <= (n); i++)\n#define rrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, n) for (ll i = (n); i >= 1; i--)\n#define all(v) (v).begin(), (v).end()\n\ntemplate <class T> void chmin(T& a, T b) { a = min(a, b);}\ntemplate <class T> void chmax(T& a, T b) { a = max(a, b);}\n\nconstexpr int INF = 1 << 30;\nconstexpr ll INFL = 1LL << 60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-12;\nld PI = acos(-1.0);\n\nstruct Graph {\n    ll n;\n    vvll graph;\n    vll depth;\n    vll par;\n\n    Graph() {\n        read_graph();\n        init();\n    }\n\n    void read_graph() {\n        cin >> n;\n        graph = vvll(n);\n        for(ll i = 0; i < n; i++) {\n            ll k;\n            cin >> k;\n            for(ll j = 0; j < k; j++) {\n                ll c;\n                cin >> c;\n                graph[i].push_back(c);\n            }\n        }\n    }\n\n    void init() {\n        depth = vll(n);\n        par = vll(n, -1);\n        dfs(0, 0);\n    }\n\n    void dfs(ll x, ll d) {\n        depth[x] = d;\n        for(auto& i : graph[x]) {\n            if(i == par[x]) continue;\n            par[i] = x;\n            dfs(i, d + 1);\n        }\n    }\n};\n\nstruct LCA {\n    Graph g;\n    vvll par;\n\n    LCA(Graph& g) : g(g) {\n        set_par();\n    };\n\n    void set_par() {\n        ll max_d = 0;\n        ll n = g.n;\n        for(ll i = 0; i < n; i++) chmax(max_d, g.depth[i]);\n        ll log_d = 0;\n        while((1 << log_d) < max_d) log_d++;\n        par = vvll(log_d + 1, vll(n, -1));\n        par[0] = g.par;\n        for(ll i = 1; i <= log_d; i++) {\n            for(ll j = 0; j < n; j++) {\n                if(par[i - 1][j] != -1) {\n                    par[i][j] = par[i - 1][par[i - 1][j]];\n                }\n            }\n        }\n    }\n\n    ll get_lca(ll u, ll v) {\n        if(g.depth[u] < g.depth[v]) swap(u, v);\n        ll log_d = par.size();\n        for(ll i = 0; i < log_d; i++) {\n            if((g.depth[u] - g.depth[v]) & (1 << i)) u = par[i][u];\n        }\n        if(u == v) return u;\n        for(ll i = log_d - 1; i >= 0; i--) {\n            if(par[i][u] == par[i][v]) continue;\n            u = par[i][u], v = par[i][v];\n        }\n        return par[0][u];\n    }\n};\n\nvoid solve() {\n    Graph g;\n    LCA l(g);\n    ll q;\n    cin >> q;\n    vll ans;\n    for(ll i = 0; i < q; i++) {\n        ll u, v;\n        cin >> u >> v;\n        ans.push_back(l.get_lca(u, v));\n    }\n    for(auto i : ans) cout << i << endl;\n    return;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \nusing namespace std;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1145141919810364364LL;\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\nstruct LCA {\n\tvector<vector<int>>table;\n\tvector<int>dep;\n\tvector<vector<int>>e;\n\tconst int LOG = 25;\n\tvoid dfs(int now,int par,int d) {\n\t\ttable[now][0] = par;\n\t\tdep[now] = d;\n\t\tfore(x,e[now]) {\n\t\t\tif (x != par)dfs(x,now,d + 1);\n\t\t}\n\t}\n\t//0-indexed\n\t//edgesは双方向\n\tvoid lcainit(int n,int root,vector<int>edges[]){\n\t\te.resize(n);\n\t\tdep.resize(n);\n\t\ttable.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfore(x, edges[i])e[i].pb(x);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)table[i].resize(LOG);\n\t\tdfs(root,-1,0);\n\t\tfor (int k = 0; k + 1 < LOG; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (table[i][k] == -1)table[i][k + 1] = -1;\n\t\t\t\telse table[i][k + 1] = table[table[i][k]][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v) {\n\t\tif (dep[u] > dep[v])swap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--) {\n\t\t\tif(((dep[v]-dep[u]) >> i) & 1)v = table[v][i];\n\t\t}\n\t\tif (u == v)return v;\n\t\tfor (int i = LOG - 1; i >= 0;i--) {\n\t\t\tif (table[u][i] != table[v][i]) {\n\t\t\t\tu = table[u][i];\n\t\t\t\tv = table[v][i];\n\t\t\t}\n\t\t}\n\t\treturn table[u][0];\n\t}\n};\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint n;\n\tcin >> n;\n\tvector<int>e[101010];\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\te[i].pb(c);\n\t\t\te[c].pb(i);\n\t\t}\n\t}\n\n\tLCA lca;\n\tlca.lcainit(n,0,e);\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tputs(lca.query(u, v));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Lowest Common Ancestor\n//最小共通先祖\n//二部探索を用いる方法\n/*\nint main(){\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    a = max(a, b);\n    a = max(max(a, b), max(c, d));\n\n}*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 100010\n#define MAX_LOG_V 500\nvector<int> G[MAX_V];                   //グラフの隣接リスト\nint root;                               //根の頂点番号\nint parent[MAX_LOG_V][MAX_V];           //parent[i][j] := 頂点jから2^i親をたどって到達する頂点\nint depth[MAX_V];                       //根からの深さ\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    //parent[0]とdepthを初期化する\n    dfs(root, -1, 0);\n    //parentを初期化する\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親をたどる\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u] >> k) & 1){    //これあテクい\n            v = parent[k][v];\n        }\n    }\n\n    if(u == v) return u;\n\n\n    //二部探索でLCAを求める\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n\n    return parent[0][u];      //uの親を返す\n}\n\nint main(){\n\n    //0-indexed\n    int V; cin >> V;\n    root = 0;\n    for(int i = 0; i < V; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    init(V);\n    int q; cin >> q;\n\n    for(int i = 0; i < q; i++){\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];\nint size[MAX];\nint par[MAX];\nint dep[MAX];\nint depth[MAX];\nint parent[MAX];\n\nvoid idfs(int pos){\n  int m=-1;\n  if(G[pos].empty())return;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    depth[to]=depth[pos]+1;\n    idfs(to);\n    size[pos]+=size[to];\n    if(m==-1||size[m]<size[to])m=to;\n  }\n  par[m]=pos;\n}\n\nint calc(int x){\n  if(par[x]==x)return x;\n  return par[x]=calc(par[x]);\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    size[i]=1;\n    par[i]=i;\n  }\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n      parent[b]=i;\n    }\n  }\n  parent[0]=-1;\n  idfs(0);\n  for(int i=0;i<n;i++){\n    int p=calc(i);\n    while(p){\n      p=par[parent[p]];\n      dep[i]++;\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  init();\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d\",&a,&b);\n    while(par[a]!=par[b]){\n      if(dep[a]<dep[b])swap(a,b);\n      a=parent[par[a]];\n    }\n    printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\n\nconst int MAXN = 100005;\nconst int LOGN = 20;\n\nint idx_in_path[MAXN];\nii path[MAXN<<1];\nvi adjList[MAXN];\n\nint path_size = 0;\n\n// compute and store the dfs order in path\n// initial call with dfs(root)\nvoid dfs(int u, int depth = 0) {\n    idx_in_path[u] = path_size;\n\n    path[path_size++] = ii(depth,u);\n    for (int v : adjList[u]) {\n        dfs(v, depth + 1);\n\n        path[path_size++] = ii(depth, u);\n    }\n}\n\n// must call dfs before build\nii ST[LOGN][MAXN<<1];\nvoid build(int n) {\n    int h = ceil(log2(n + 1));\n\n    for (int i = 0; i < n; i++) ST[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n            ST[i][j] = min(ST[i-1][j], ST[i-1][j+(1<<(i-1))]);\n}\n\n// return the lowest common ancestor between node u and v\nint lca(int u, int v) {\n    int l = idx_in_path[u], r = idx_in_path[v]; \n    if (l > r) swap(l, r); r++; // range [l, r)\n    \n    int p = 31 - __builtin_clz(r-l);\n    return min(ST[p][l],ST[p][r-(1<<p)]).se;\n}\n\nint main() {\n\n    int num_nodes;\n    scanf(\"%d\", &num_nodes);\n    for (int u = 0; u < num_nodes; u++) {\n        int num_neighbors;\n        scanf(\"%d\", &num_neighbors);\n        for (int i = 0; i < num_neighbors; i++) {\n            int v;\n            scanf(\"%d\", &v);\n            \n            adjList[u].push_back(v); // directed edge\n        }\n    }\n\n    dfs(0);\n    build(path_size);\n\n    int num_queries;\n    scanf(\"%d\",&num_queries);\n    for (int i = 0; i < num_queries; i++) {\n        int u, v;\n        scanf(\"%d%d\",&u,&v);\n\n        printf(\"%d\\n\", lca(u, v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n\nstruct LCA{\n  int logn,n;\n  vector<vector<int>> adj;\n  vector<vector<int>> par;\n  vector<int> depth;\n  LCA(){}\n  LCA(vector<vector<int>>const& _adj,int _n,int r=0):adj(_adj),n(_n){\n    logn = 1;\n    while((1<<logn)<n)logn++;\n    par = vector<vector<int>>(logn,vector<int>(n,-1));\n    depth = vector<int>(n);\n    dfs(r,-1,0);\n    build();\n  }\n  void dfs(int cur,int prv,int dep){\n    par[0][cur] = prv;\n    depth[cur] = dep;\n    for(auto nxt:adj[cur]){\n      if(nxt==prv)continue;\n      dfs(nxt,cur,dep+1);\n    }\n  }\n  void build(){\n    for(int i=1;i<logn;++i){\n      for(int v=0;v<n;++v){\n        if(par[i-1][v]==-1)continue;\n        par[i][v] = par[i-1][par[i-1][v]];\n      }\n    }\n  }\n  int get_lca(int u,int v){\n    if(depth[u]>depth[v])swap(u,v);\n    int d = depth[v]-depth[u];\n    for(int i=0;i<logn;++i)if(d>>i&1)v=par[i][v];\n    if(u==v)return u;\n    for(int i=logn;i-->0;){\n      if(par[i][u]!=par[i][v]){\n        u = par[i][u];\n        v = par[i][v];\n      }\n    }\n    return par[0][u];\n  }\n};\n\nsigned main(){\n\n  int n;\n  cin>>n;\n  vector<vector<int>> adj(n);\n  rep(i,n){\n    int k;cin>>k;\n    rep(_,k){\n      int c;cin>>c;\n      adj[i].emplace_back(c);\n    }\n  }\n  LCA tree(adj,n);\n\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;cin>>u>>v;\n    int lca = tree.get_lca(u,v);\n    cout<<(lca)<<endl;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\nconst int MAX_N = 112345;\nvector<int> g[MAX_N];\n\nstruct LCA {\n\n  int log2(int b) {return 31 - __builtin_clz(b);}\n\n  int parent[20][MAX_N]; // [k][i] := i からちょうど 2^k 回親方向へ進んだ頂点番号。無いなら -1\n  int depth[MAX_N];\n  int N;\n\n  LCA(){}\n\n  void build(int N, int root) {\n    CLR(parent, -1);\n    this->N = N;\n    int K = log2(N) + 1;\n    dfs(root, -1, 0);\n    for (int k = 0; k < K; k++) {\n      for (int i = 0; i < N; i++) {\n        parent[k+1][i] = parent[k][i] >= 0 ? parent[k][parent[k][i]] : -1;\n      }\n    }\n  }\n  void dfs(int u, int p, int d) {\n    parent[0][u] = p;\n    depth[u] = d;\n    for (int v : g[u]) if (v != p) {\n      dfs(v, u, d+1);\n    }\n  }\n  int get(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    int K = log2(N) + 1;\n    for (int k = 0; k < K; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    if (u == v) return u;\n    for (int k = K-1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nLCA lca;\n\nint main2() {\n\n  REP(i, MAX_N) g[i].clear();\n\n  int N = nextInt();\n  REP(i, N) {\n    int K = nextInt();\n    REP(_, K) {\n      int j = nextInt();\n      g[i].push_back(j);\n      g[j].push_back(i);\n    }\n  }\n  lca.build(N, 0);\n  int Q = nextInt();\n  REP(_, Q) {\n    int u = nextInt();\n    int v = nextInt();\n    int ans = lca.get(u, v);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 1 << 17;\nconst int MAX_N = 1 << 18;\nconst int def = 1 << 25;\n\ntypedef pair<int, int> Node;\nstruct MinSegTree {\n\tint n;\n\tNode node[2 * MAX_N - 1];\n\tint dat[2 * MAX_N - 1];\n\tint minIdx[2 * MAX_N - 1];\n\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) node[i] = make_pair(def, def);\n\t}\n\n\tNode merge(Node l, Node r) {\n\t\tif(l.first <= r.first) return l;\n\t\treturn r;\n\t}\n\n\tvoid update(int k, int a) {\n\t\tk += n - 1;\n\t\tnode[k] = make_pair(a, k - (n - 1));\n\t\tdat[k] = a;\n\t\tminIdx[k] = k - (n - 1);\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\n\tNode query(int a, int b) { return query(a, b, 0, 0, n); }\n\n\tNode query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return make_pair(def, def);\n\t\tif(a <= l && r <= b) return node[k];\n\t\tNode vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tNode vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn merge(vl, vr);\n\t}\n\n\tvoid show() {\n\t\tfor(int i = 0; i < n; i++) cout << dat[i + n - 1] << \" \";\n\t\tcout << endl;\n\t}\n};\n\nclass LCA {\npublic:\n\tMinSegTree st;\n\tvector<int> G[MAX_V];\n\tint root;\n\n\tint vs[MAX_V * 2 - 1];\n\tint depth[MAX_V * 2 - 1];\n\tint id[MAX_V];\n\n\tvoid init(int V, int root = 0) {\n\t\tthis->root = root;\n\t\tint k = 0;\n\t\tdfs(root, -1, 0, k);\n\t\tst.init(2 * V - 1);\n\t\tfor(int i = 0; i < 2 * V - 1; i++) {\n\t\t\tst.update(i, depth[i]);\n\t\t}\n\t}\n\n\tvoid addEdge(int u, int v) {\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvoid dfs(int v, int p, int d, int& k) {\n\t\tid[v] = k;\n\t\tvs[k] = v;\n\t\tdepth[k++] = d;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tif(G[v][i] != p) {\n\t\t\t\tdfs(G[v][i], v, d + 1, k);\n\t\t\t\tvs[k] = v;\n\t\t\t\tdepth[k++] = d;\n\t\t\t}\n\t\t}\n\t}\n\n\tint lca(int u, int v) {\n\t\tint l = min(id[u], id[v]);\n\t\tint r = max(id[u], id[v]);\n\t\treturn vs[st.query(l, r + 1).second];\n\t}\n};\n\nLCA lca;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\twhile(k--) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tlca.addEdge(i, c);\n\t\t}\n\t}\n\n\tlca.init(n);\n\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.lca(u, v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll Size(vector<T> &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nclass Dubling{\nprivate:\n\tvvll next;\n\tll N, B;\n\tll next_(ll v, ll i){ return (v<0) ? -1 : next[v][i]; }\npublic:\n\tDubling(): N(0), B(0) {}\n\tDubling(const vll &nxt, ll nextTimesMax){ Init(nxt, nextTimesMax); }\n\tvoid Init(const vll &nxt, ll nextTimesMax){\n\t\tN = (ll)nxt.size();\n\t\tB = MSB(nextTimesMax) + 1;\n\t\tnext.resize(N, vll(B, -1));\n\t\tREP(v, N) next[v][0] = nxt[v];\n\t\tREPS(i, 1, B-1) REP(v, N) next[v][i] = next_(next_(v, i-1), i-1);\n\t}\n\tll Times(ll v, ll times){ //!< times個先  times=0も可\n\t\tDEPS(i, 0, MSB(times))  if ((times>>i)&1) v = next_(v, i);\n\t\treturn v;\n\t}\n\tll TimesPow2(ll v, ll i) { return next[v][i]; }  //!< 2^i個先\n};\n\nstruct DepthOfTree{\n\tvvll &to; vll depth;\n\tDepthOfTree(vvll &to, ll root): to(to), depth(to.size()) { dfs(root, -1, 0); }\n\tvoid dfs(ll v, ll p, ll d){ EACH(u, to[v]) if (u!=p) dfs(u, v, depth[u]=d+1); }\n\tvll get(){ return move(depth); }\n};\n\nstruct ParentOfTree{\n\tvvll &to; vll par;\n\tParentOfTree(vvll &to, ll root): to(to), par(to.size()) { dfs(root, -1); }\n\tvoid dfs(ll v, ll p){ par[v] = p;  EACH(u, to[v]) if (u!=p) dfs(u, v); }\n\tvll get(){ return move(par); }\n};\n\nstruct LCA{\n\tvvll &to; vll depth; Dubling pDbl;\n\tLCA(vvll &to, ll root): to(to), depth(move(DepthOfTree(to, root).get())),\n\t\tpDbl(ParentOfTree(to, root).get(), (ll)to.size()) {}\n\tll operator() (ll v, ll u){\n\t\tll dv = this->depth[v], du = this->depth[u];\n\t\tif (dv < du) { swap(v, u); swap(dv, du); }\n\t\tif ((v = this->pDbl.Times(v, dv-du)) == u) return v;\n\t\tDEPS(i, 0, MSB(du)){\n\t\t\tll vv = this->pDbl.TimesPow2(v, i), uu = this->pDbl.TimesPow2(u, i);\n\t\t\tif (vv != uu) { v = vv; u = uu; }\n\t\t}\n\t\treturn this->pDbl.TimesPow2(v, 0);\n\t}\n};\n\n\nvoid solve()\n{\n\tll n;  cin >> n;\n\tvvll to(n);\n\trep(i, 0, n-1){\n\t\tll k;  cin >> k;\n\t\trep(j, 0, k-1){\n\t\t\tll c;  cin >> c;\n\t\t\tto[i].push_back(c);\n\t\t\tto[c].push_back(i);\n\t\t}\n\t}\n\tll q;  cin >> q;\n\tvector<pair<ll, ll>> uv = cinv2<ll, ll>(q);\n\n\tLCA lca(to, 0);\n\t\n\trep(i, 0, q-1){\n\t\tll u; ll v;  tie(u, v) = uv[i];\n\t\tll ans = lca(u, v);\n\t\tcout << ans << '\\n';\n\t}\n\n\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 30\nusing namespace std;\nint n,k,c,depth[N],parent[N][M];\nvector<int> e[N];\n\nvoid dfs(int x,int d){\n  depth[x]=d;\n  for(int i=0;i<(int)e[x].size();i++)\n    dfs(e[x][i],d+1);\n}\n\nint lca(int u,int v){\n  if(depth[u]<depth[v])swap(u,v);\n  int K=depth[u]-depth[v];\n  for(int i=0;i<M;i++)\n    if(K>>i&1)u=parent[u][i];\n  if(u==v)return u;\n  for(int j=M-1;j>=0;j--){\n    if(parent[u][j]==parent[v][j])continue;\n    u=parent[u][j];\n    v=parent[v][j];\n  }\n  return parent[u][0];\n}\n\nint main(){\n  cin>>n;\n  memset(parent,-1,sizeof(parent));\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&k);\n    for(int j=0;j<k;j++){\n      scanf(\"%d\",&c);\n      e[i].push_back(c);\n      parent[c][0]=i;\n    }\n  }\n  for(int j=1;j<M;j++)\n    for(int i=0;i<n;i++)\n      if(parent[i][j-1]==-1)parent[i][j]=-1;\n      else parent[i][j]=parent[ parent[i][j-1] ][j-1];\n\n  dfs(0,0);\n  int q,u,v;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>u>>v;\n    printf(\"%d\\n\",lca(u,v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\n#define INF (1<<30)\nusing namespace std;\n\nvector<int> Ind(100010);\t\t//Ind[n]  ??\\???n???euler tour??¨??§???????????°?????????\nvector<bool> f(100010, false);\t//\nvector<vector<int>> T(100010);\t//??°??????\nvector<P> ET;                   //????????¢?´¢??¨\n\nvoid dfs(int n,int dep) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tInd[n] = ET.size() - 1;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1);\n\t\tET.emplace_back(make_pair(dep,n));\n\t}\n}\n\nP RMQ(int a, int b, int k, int l, int r, vector<P>& node) {\n\tif (r <= a || b <= l) {return P(INF, INF); }\n\tif (a <= l && r <= b) return node[k];\n\n\tP vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);\n\tP vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r, node);\n\treturn min(vl, vr);\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t//Graph initialize\n\tint n_; cin >> n_;\n\tfor (int i = 0; i < n_; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\t//ET??¨?????????\n\tdfs(0,0);\n\n\t//RMQ initialize\n\tn_ = ET.size();\n\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<P> node(2 * n - 1, P(INF, INF));\n\n\tfor (int i = 0; i < n_;i++) { node[n - 1 + i] = ET[i]; }\n\tfor (int i = n - 2; i >= 0; i--) { node[i] = min(node[2 * i + 1], node[2 * i + 2]); }\n\n\t//Answer\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tint a = Ind[u], b = Ind[v];\n\t\tif (a > b) { swap(a, b); }\n\t\tif (a == b) { cout << u << endl; continue; }\n\t\tcout << RMQ(a,b, 0, 0, n, node).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <map>\n#include <complex>\n#define fir first\n#define sec second\n#define sz(s) (s).size()\n#define pb push_back\n#define get(n) scanf(\"%d\",&n);\n#define gets(s) string s;cin >> (s);\n#define prfi(n) printf(\"%d\", &n);\n#define prfd(n) printf(\"%lf\", &n);\n#define All(s) (s).begin(), (s).end()\n#define rep(i,j) for(int (i)=0;(i)<(j);(i)++)\n#define For(i,j,k) for(int (i)=(j);(i)<(k);(i)++)\n#define drep(i,j) for(int (i)=(j);(i)>=0;(i)--)\n#define Ford(i,j,k) for(int (i)=(j);i>=(k);i--)\n#define fore(c,v) for(auto (c): (v))\n#define lp for(int __=0;__<n;i++)\n#define mem(a,b) memset(a,b,sizeof(a));\n#define dump(x)  std::cout << #x << \" = \" << (x) << std::endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing ull = unsigned long long int;\nusing ll = long long;\nusing ld = long double;\nusing pii = std::pair<int,int>;\nusing pll = std::pair<ll, ll>;\nusing vi = std::vector<int> ;\nusing vvi = std::vector<vi> ;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vd = std::vector<double> ;\nusing vvd = std::vector<vd> ;\nusing qi = std::queue<int> ;\nusing vpii = std::vector<std::pair<int, int> >;\nusing vpll = std::vector<pll>;\nusing namespace std;\n\nconst int Mod = (1e9) + 7;\nconst int INF = 1e9 + 19;\nconst ll INFL = 1e18 + 19;\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\nconst int dx2[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nconst int dy2[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\nconst double EPS = 1e-10;\n//_____________________________________Templates_________________________________________//\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\ntemplate<class T> inline void pri(T a){cout << a << endl;}\ntemplate<class Z> using vec = vector<Z>;\ntemplate<class T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n//mainly use for dynamic prog\ntemplate<class T1, class T2>\nvoid update(T1 &a, T2 b){\n  a += b;\n  if(a > Mod) a %= Mod;\n}\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\nbool pairsort(pll pl, pll pr){\n  if(pl.first == pr.first)return pl.second > pr.second;\n  return pl.first < pr.first;\n}\n\nint cntbit(ll a,int n,int j){int res = 0;For(i,j,n){if(a>>i & 1){res++;}}return res;}\nvector<int> make_bit(int a){vector<int> res; for(int i=31;i>=0;i--)if(a&(1<<i))res.pb(i);return res;}\nbool stdbit(int a, int b){return a&(1 << b); }\nint GCD(int a, int b){if(b > a)return GCD(b,a);if(a%b == 0)return b;else return GCD(b, a%b);}\nint LCM(int a, int b){return a*b/GCD(a,b);}\nint roundup(int a, int b){if(a % b == 0)return a/b;else return (a+b)/b;}\nint rounddown(int a, int b){if(a%b == 0)return a/b;else {return (a-b)/b;}}\nll pow(ll a, ll n){ll res = 1;while(n > 0){if(n&1)res *= a; a *= a; n = n >> 1;}return res;}\nll GetDiviserCount(ll N)//約数の個数\n{\n  ll res = 1;\n  For(i,2,sqrt(N)+1)\n  {\n    ll cnt = 0;\n    while(N%i == 0)\n    {\n      cnt++;\n      N /= i;\n    }\n    res *= (cnt + 1);\n    if(N == 1)break;\n  }\n  if(N != 1)res *= 2;\n  return res;\n}\nvll GetDivisor(ll N)//約数列挙\n{\n  vll res;\n  for(ll i = 1;i*i <= N;i++)\n  {\n    if(N%i == 0)\n    {\n      res.pb(i);\n      if(i*i != N)res.pb(N/i);\n    }\n  }\n  sort(All(res));\n  return res;\n}\n\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%Mod+Mod)%Mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += Mod-a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= Mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n \n  // for prime mod\n  mint inv() const {\n    return pow(Mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n  friend ostream& operator<<(ostream& os, const mint& a);\n};\nostream& operator<<(ostream& os, const mint& a)\n{\n  os << a.x;\n  return os;\n}\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < Mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n \ntemplate<class Z>\nstruct Matrix\n{\n  using mat = Matrix<Z>;\n  vector<vector<Z>> m_dat;\n  int m_h;\n  int m_w;\n  Matrix(int h, int w) : m_h(h), m_w(w) ,m_dat(h,vector<Z>(w)) {}\n  vector<Z> &operator[] (int idx)\n  {\n    return m_dat[idx];\n  }\n  mat Multiple(mat &a)\n  {\n    mat C(m_h, a.m_w);\n    for(int i=0;i<m_h;i++)\n    {\n      for(int j=0;j<a.m_w;j++)\n      {\n        for(int k=0;k<m_w;k++)\n        {\n         C[i][j] += m_dat[i][k] * a[k][j];\n        }\n      }\n    }\n    return C;\n  }\n  mat Pow(ll x)\n  {\n    mat B(m_h,m_w);\n    for(int i=0;i<m_h;i++)\n    {\n      B[i][i] = 1;\n    }\n    mat A = *this;\n    while(x > 0)\n    {\n      if(x&1)B = B.Multiple(A);\n      A = A.Multiple(A);\n      x = x >> 1;\n    }\n    return B;\n  }\n};\n\n//_____________________　following sorce code_________________________//\nconst int max_n = 3 * (1e5) + 1;\nconst int max_m = 83 * (1e5) + 1;\n\nint n,m,k;\nll N;\nint h,w;\nstring S;\nint a,b,c;\nvi v;\nint ans;\ndouble x,y,z;\nvector<int> G[1010101];\nstruct Edge\n{\n  int to;\n  long long int x;\n  Edge() {}\n  Edge(int to, long long int x) : to(to), x(x){}\n};\nstruct LCA\n{\n  int n;\n  int rmq_n;\n  int m;\n  int root;\n  vector<int> vs;// 行きがけ順に頂点を並べた\n  vector<int> depth;// 頂点ごとのふかさ\n  vector<long long int> dist;// 最短路\n  vector<int> dat;// それぞれの頂点がはじめに出現するインデックス\n  vector<Edge> G[101010];\n  vector<Edge> rmq_data;// rmq　用の配列\n  LCA(int n) : n(n), vs(2*n-1),depth(2*n-1), dat(n), dist(n) {}\n  void AddEdge(int v, int u, long long int x)\n  {\n    G[v].push_back({u,x});\n    G[u].push_back({v,x});\n  }\n  void init(int ro)\n  {\n    root = ro;\n    int k = 0;\n    dfs(root, -1, 0, k, 0);\n    rmq_init();\n  }\n  void dfs(int curr, int last,int d, int &k,long long int dis)\n  {\n    dat[curr] = k;\n    vs[k] = curr;\n    depth[k++] = d;\n    dist[curr]  = dis;\n    for(auto e: G[curr])\n    {\n      if(e.to == last)continue;\n      dfs(e.to, curr, d+1, k, dis + e.x);\n      vs[k] = curr;\n      depth[k++] = d;\n    }\n  }\n\n  Edge lca(int a, int b)\n  {\n    Edge e = find(min(dat[a], dat[b]), max(dat[a], dat[b]) + 1);\n    return e;\n  }\n  int GetDepth(int a, int b)\n  {\n    return depth[dat[a]] + depth[dat[b]] - 2*depth[dat[lca(a,b).to]];\n  }\n  long long int GetDist(int a, int b)\n  {\n    return dist[a] + dist[b] - dist[lca(a,b).to]*2;\n  }\n  // rmq methods\n  void rmq_init()\n  {\n    m = n*2 - 1;\n    rmq_n = 1;\n    while(rmq_n < m)rmq_n *= 2;\n    rmq_data.resize(rmq_n*2-1,Edge(-1,10101010101));\n    for(int i=0;i<m;i++)\n    {\n      rmq_data[i+rmq_n-1].to = vs[i];\n      update(i,depth[i]);\n    }\n  }\n  void update(int idx, long long int x)\n  {\n    idx += rmq_n-1;\n    rmq_data[idx].x = x;\n    while(idx > 0)\n    {\n      idx = (idx-1)/2;\n      rmq_data[idx] = change(rmq_data[idx*2+1], rmq_data[idx*2+2]);\n    }\n  }\n  Edge change(Edge a, Edge b)\n  {\n    if(a.x > b.x)return b;\n    else return a;\n  }\n  Edge query(int a,int b, int c, int l, int r)\n  {\n    Edge Unit(-1, 101010110);\n    if(b <= l or r <= a)return Unit;\n    if(a <= l and r <= b)return rmq_data[c];\n    return change(query(a,b,c*2+1,l,(r+l)/2), query(a,b,c*2+2,(r+l)/2,r));\n  }\n  Edge find(int a,int b)\n  {\n    return query(a,b,0,0,rmq_n);\n  }\n};\n\nsigned main (int argc, char* argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  IN(n);\n  LCA lc(n);\n  rep(i,n)\n  {\n    IN(m);\n    rep(j,m)\n    {\n      IN(a);\n      lc.AddEdge(i,a,1);\n    }\n  }\n  lc.init(0);\n  int q;\n  IN(q);\n  rep(i,q)\n  {\n    IN(a,b);\n    int ances = lc.lca(a,b).to;\n    cout << ances << endl;\n  }\n  //for(auto c : ans){cout << c << endl;}\n  //cout << fixed << setprecision(15) << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(40) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,n,a) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,n,0)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\nconst static int MAX_V = 10000;\n\nvector<int> G[MAX_V];\nint root = 0;\n\nint vs[MAX_V * 2 - 1];\nint depth[MAX_V * 2 - 1];\nint id[MAX_V];\n\n//?????????????????????????????????????±?????????????????????°???????????¨\n//int double ??¨??????numeric???????????£?????????????????????\n//n ????´???°\n//invalid_value ???????????°???????????????a????????????marge(a,invalidvalue) = a, marge(invalid_value, a) = a?????¨??????????????????\nclass SegmentTreeInt {\npublic:\n\tSegmentTreeInt(int n, int invalid_value);\n\t~SegmentTreeInt();\n\tvoid SetElem(int k, int val);\n\tint GetCount();\n\tint quary(int a, int b);\n\tint GetElem(int k);\n\n\t//?????????????????¢??°???????????????????????????\n\t//invalid_value??????????????£?????°????????????????????????\n\tbool IsInvalidValue(int value) {\n\t\treturn value == mInvalidValue;\n\t}\n\t//a??¨b?????? a???b????±?????????¢??°???????????§?¨?????????????????????§?±???????\n\tint Marge(int a, int b) {\n\t\tif (IsInvalidValue(a))return b;\n\t\tif (IsInvalidValue(b)) return a;\n\t\tif (depth[a] >= depth[b]) return b;\n\t\treturn a;\n\t}\nprivate:\n\tvector<int>\n\t\tmTree;\n\tint mCount;\n\tint mInvalidValue;\n\tvoid Update(int k, int val);\n\tint InternalQuary(int a, int b, int k, int l, int r);\n};\n\n//?????´??????????????????(??????????????¨???????????´??????)\nSegmentTreeInt::SegmentTreeInt(int n, int invalid_value) {\n\tint bin_n = 1;\n\twhile (bin_n < n) bin_n *= 2;\n\tmTree.resize(2 * bin_n);\n\tmInvalidValue = invalid_value;\n\tmCount = bin_n;\n\tfor (int i = 0; i < 2 * bin_n - 1; i++) {\n\t\tmTree[i] = invalid_value;\n\t}\n}\nSegmentTreeInt::~SegmentTreeInt() {\n}\nvoid SegmentTreeInt::SetElem(int k, int val) { Update(k, val); }\nint SegmentTreeInt::GetElem(int k) { return mTree[mCount - 1 + k]; }\nint SegmentTreeInt::GetCount() { return mCount; }\n//????????´??°\nvoid SegmentTreeInt::Update(int k, int val) {\n\tk += mCount - 1;\n\tmTree[k] = val;\n\twhile (k > 0) {\n\t\tk = ( k - 1 ) / 2;\n\t\tmTree[k] = Marge(mTree[2 * k + 1], mTree[2 * k + 2]);\n\t}\n}\n//??????[a,b]?????????O(ln(Count))??§?±??????? b < GetCount??¨???????????¨\n//ex. a = 0 , b = 2 ?????? 0,1,2?????????\nint SegmentTreeInt::quary(int a, int b) {\n\treturn InternalQuary(a, b + 1, 0, 0, mCount);\n}\n//?????¨?????????\nint SegmentTreeInt::InternalQuary(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return mInvalidValue;\n\tif (a <= l && r <= b)return mTree[k];\n\telse {\n\t\tint vl = InternalQuary(a, b, k * 2 + 1, l, ( l + r ) / 2);\n\t\tint vr = InternalQuary(a, b, k * 2 + 2, ( l + r ) / 2, r);\n\t\treturn Marge(vl, vr);\n\t}\n}\n//???????????§?????´??????\n\nSegmentTreeInt rmq(2*MAX_V-1,INF);\n\nvoid dfs(int v, int p, int d, int &k) {\n\tid[v] = k;\n\tvs[k] = v;\n\tdepth[k++] = d;\n\trep(i, G[v].size()) {\n\t\tif (G[v][i] != p) {\n\t\t\tdfs(G[v][i], v, d + 1, k);\n\t\t\tvs[k] = v;\n\t\t\tdepth[k++] = d;\n\t\t}\n\t}\n}\n//\nvoid init(int V) {\n\tint k = 0;\n\tdfs(root,-1,0,k);\n\trep(i, V * 2) {\n\t\trmq.SetElem(i,i);\n\t}\n}\n\nint LCA(int u, int v) {\n\treturn vs[rmq.quary(min(id[u], id[v]), max(id[u], id[v]))];\n}\n\nint main() {\n\tint n; put n;\n\trep(i, n) {\n\t\tint k; put k;\n\t\trep(j, k) {\n\t\t\tint c; put c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tint q; put q;\n\tinit(n);\n\trep(i, q) {\n\t\tint u, v; put u >> v;\n\t\tcout << LCA(u,v) << endl;\n\t}\nEND:\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100000\n#define MAX_LOG 30\nvector<int>G[MAX];\nint depth[MAX];\nint parent[MAX_LOG][MAX];\nint root;\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0;i<G[v].size();i++)\n    if(G[v][i]!=p)dfs(G[v][i],v,d+1);\n}\nvoid init(int V){\n  dfs(root,-1,0);\n  for(int k=0;k+1<MAX_LOG;k++)\n    for(int v=0;v<V;v++)\n      if(parent[k][v]<0)parent[k+1][v]=-1;\n      else parent[k+1][v]=parent[k][parent[k][v]];\n}\nint lca(int u,int v){\n  if(depth[u]>depth[v])swap(u,v);\n  for(int k=0;k<MAX_LOG;k++)\n    if((depth[v]-depth[u])>>k&1)\n      v=parent[k][v];\n  if(u==v)return u;\n  for(int k=MAX_LOG-1;k>=0;k--)\n    if(parent[k][u]!=parent[k][v]){\n    u=parent[k][u];\n    v=parent[k][v];\n  }\n  return parent[0][u];\n}\nint main(){\n  root=0;int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int p=0;cin>>p;\n    while(p--){\n      int t;cin>>t;\n      G[i].push_back(t);\n    }\n  }\n  init(n);  int p;  cin>>p;\n  while(p--){\n    int q,w;\n    cin>>q>>w;\n    cout<<lca(q,w)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Author:zeke\n    \n    pass System Test!\n    GET AC!!\n*/\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <stack>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define rep3(var, min, max) for (ll (var) = (min); (var) < (max); ++(var))\n#define repi3(var, min, max) for (ll (var) = (max) - 1; (var) + 1 > (min); --(var))\n#define Mp(a,b) make_pair((a),(b))\n#define F first\n#define S second\n#define CIN(s) int (s);cin>>(s);\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef vector<V> VV;\ntypedef vector<P> VP;\nll MOD = 1e9 + 7;\nll INF =1e18;\n\nint n;  //頂点数\nint logn;\nvector<vector<ll>> g;  //グラフの隣接リスト\nVV par;\nV depth;\n\n//初期化\nvoid dfs(int now,int parent,int d){\n  par[now][0]=parent;\n  depth[now]=d;\n  for(int i=0;i<g[now].size();++i){\n    if(g[now][i]!=parent)dfs(g[now][i],now,d+1);\n  }\n}\n\n//uとvのlcaを求める\nint lca(int u,int v){\n  //uとvの深さを揃える\n  if(depth[u]>depth[v])swap(u,v);\n  for(int k=logn;k>=0;--k){\n    if((1<<k) & depth[v]-depth[u]){\n      v=par[v][k];\n    }\n  }\n  if(u==v)return u;\n  for(int k=logn;k>=0;--k){\n    if(par[u][k] != par[v][k]){\n      u=par[u][k];\n      v=par[v][k];\n    }\n  }\n  return par[u][0];\n}\n\nint main() {\n    cin>>n;\n    g.resize(n);\n    logn=floor(log2(n));\n    par.resize(n+1,V(logn+2));\n    depth.resize(n);\n    rep(i,n){\n        int k;cin>>k;\n        rep(j,k){\n            int c;cin>>c;\n            g[i].push_back(c);\n        }\n    }\n    dfs(0,-1,0);\n    for(int k=0;k<logn;++k){\n    for(int i=0;i<n;++i){\n      if(par[i][k]==-1){\n        par[i][k+1]=-1;\n      }else{\n        par[i][k+1]=par[par[i][k]][k];\n      }\n    }\n  }\n  int q;cin>>q;\n  rep(i,q){\n      int u,v;cin>>u>>v;\n      cout<<lca(u,v)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n//     if(x == 0) return 0;\n//     x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n//     x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n//     x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n//     x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n//     int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n//     return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n    return 3;\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return node_[vl] < node_[vr] ? left_child(k) : right_child(k);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n\n// 根付き木\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int size() const {return node_.size();}\n    int lowest_common_ancestor(int u, int v) const {\n        RangeMinimumQuery rmq(size());\n        for(int i = 0; i < size(); ++i) rmq.update(i, depth(i));\n        return rmq.find_index(std::min(u, v), std::max(u, v)) - 1;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n\n\n/*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n//     int lowest_common_ancestor(int u, int v) const {\n//         while(depth(u) > depth(v)) u = parent(u);\n//         while(depth(u) < depth(v)) v = parent(v);\n//         while(u != v) {\n//             u = parent(u);\n//             v = parent(v);\n//         }\n//         return u;\n//     }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(u);\n            else                    u = parent(v);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return node_[vl] < node_[vr] ? left_child(k) : right_child(k);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n\n#include<iostream>\nusing namespace std;\n// 根付き木\n\n#include<vector>\n#include<memory>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int size() const {return node_.size();}\n    int lowest_common_ancestor(int u, int v) const {\n        for(auto n:node_)cout<<\" \"<<n.depth;cout<<endl;\n        RangeMinimumQuery rmq(size());\n        for(int i = 0; i < size(); ++i) rmq.update(i, depth(i));\n        return rmq.find_index(std::min(u, v), std::max(u, v)) - 1;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n\n\n/*\n// LCA: O(n)\n#include<vector>\n#include<memory>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n//     int lowest_common_ancestor(int u, int v) const {\n//         while(depth(u) > depth(v)) u = parent(u);\n//         while(depth(u) < depth(v)) v = parent(v);\n//         while(u != v) {\n//             u = parent(u);\n//             v = parent(v);\n//         }\n//         return u;\n//     }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(u);\n            else                    u = parent(v);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nstruct LowestCommonAncestor {\n\n  int V, MAX_LOG_V;\n  vector<vector<int>> edge;\n\n  vector<vector<int>> parent;\n  vector<int> depth;\n\n  LowestCommonAncestor(int V, int MAX_LOG_V = 17) : V(V), MAX_LOG_V(MAX_LOG_V) {\n    edge.resize(V);\n    parent.resize(MAX_LOG_V);\n    REP(i, MAX_LOG_V) parent[i].resize(V);\n    depth.resize(V);\n  }\n\n  void add_edge(int a, int b) {\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n\n  void dfs(int v, int par, int dep) {\n    parent[0][v] = par;\n    depth[v] = dep;\n    for (auto child : edge[v]) {\n      if (child != par) dfs(child, v, dep + 1);\n    }\n  }\n\n  void init(int root = 0) {\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n      for (int v = 0; v < V; v++) {\n        if (parent[k][v] < 0) {\n          parent[k+1][v] = -1;\n        } else {\n          parent[k+1][v] = parent[k][parent[k][v]];\n        }\n      }\n    }\n  }\n\n  tuple<int, int, int> run(int u, int v) {\n    int u_cnt = 0, v_cnt = 0;\n    bool swapflag = false;\n    if (depth[u] > depth[v]) swap(u, v), swapflag = true;\n    for (int k = 0; k < MAX_LOG_V; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n        v_cnt += 1 << k;\n      }\n    }\n    if (u == v) {\n      if (swapflag) swap(u_cnt, v_cnt);\n      return make_tuple(u, u_cnt, v_cnt);\n    }\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n        u_cnt += 1 << k;\n        v_cnt += 1 << k;\n      }\n    }\n    u_cnt++, v_cnt++;\n    if (swapflag) swap(u_cnt, v_cnt);\n    return make_tuple(parent[0][u], u_cnt, v_cnt);\n  }\n\n  int get_cntup_node(int v, int cnt) {\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (cnt >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    return v;\n  }\n};\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  LowestCommonAncestor lca(N);\n  REP(i, N) {\n    int K; cin >> K;\n    REP(_, K) {\n      int c; cin >> c;\n      lca.add_edge(i, c);\n    }\n  }\n\n  lca.init();\n\n  int Q; cin >> Q;\n  REP(i, Q) {\n    int u, v; cin >> u >> v;\n    int anc, u_cnt, v_cnt; tie(anc, u_cnt, v_cnt) = lca.run(u, v);\n    cout << anc << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_V 1010000\n \nusing namespace std;\n \ntypedef pair<int,int> ii;\n \n//RMQ\n \nint rn;\nii dat[2*MAX_V-1];\nvoid init(int n_){\n  rn = 1;\n  while(rn<n_)rn*=2;\n  for(int i=0;i<2*rn-1;i++)dat[i] = ii(IINF,IINF);//ii(depth,index)\n}\n  \n// k????????????(0-indexed)???a????????´\nvoid update(int k,ii a){\n  k += rn-1;\n  dat[k] = a;\n  while(k > 0){\n    k = (k-1)/2;\n    dat[k] = (dat[k*2+1].first>dat[k*2+2].first?dat[k*2+2]:dat[k*2+1]);\n  }\n}\n \nii _query(int a,int b,int k,int l,int r){\n  if(r<=a || b<=l)return ii(IINF,-1);\n  else if(a<=l && r<=b)return dat[k];\n   \n  ii vl = _query(a,b,k*2+1,l,(l+r)/2);\n  ii vr = _query(a,b,k*2+2,(l+r)/2,r);\n   \n  return min(vl,vr);\n}\n \n//n???????????§?????????????????????????\\?????????£???????????¨ \nii query(int a,int b){\n  return _query(a,b,0,0,rn);\n}\n \n//\n \nint V;\nvector<int> G[MAX_V];\nint root;\n \nint vs[MAX_V*2-1];\nint depth[MAX_V*2-1];\nint id[MAX_V];\n \nvoid dfs(int v,int p,int d,int &k){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  for(int i=0;i<G[v].size();i++){\n    if(G[v][i] != p){\n      dfs(G[v][i],v,d+1,k);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n \nvoid RQMinit(){\n  int k = 0;\n  dfs(root,-1,0,k);\n   \n  init(k+1);  \n  rep(i,k)update(i,ii(depth[i],vs[i]));\n}\n \nint lca(int u,int v){\n  return query(min(id[u],id[v]),max(id[u],id[v])+1).second;\n}\n \n \nint main(){\n  int n;\n  cin >> n;\n  V = n;\n  rep(i,V){\n    int k,c;\n    cin >> k;\n    rep(j,k){\n      cin >> c;\n      G[i].push_back(c);\n      G[c].push_back(i);\n    }\n  }\n \n  RQMinit();\n  int q,u,v;\n  cin >> q;\n  rep(i,q){\n    cin >> u >> v;\n    cout << lca(u,v) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// HLD + Euler Tour Trick\nconst int N = 100 * 1000 + 10;\nint n; vector<int> g[N];\nint size[N], depth[N], par[N];\nint head[N], chain[N], heavy[N];\nint tchains;\nvector <int> nodes;\nint tin[N], tout[N];\n\nvoid dfs(int u, int p, int d) {\n\tpar[u] = p; depth[u] = d; \n\tsize[u] = 1; heavy[u] = -1;\n\tfor (auto v : g[u]) if (v != p) {\n\t\tdfs(v, u, d + 1); size[u] += size[v];\n\t\tif (heavy[u] == -1 || size[v] > size[heavy[u]])\n\t\t\theavy[u] = v;\n\t}\n}\n\nvoid build_hld(int root, int u, int p) {\n\thead[u] = root; chain[u] = tchains;\n\ttin[u] = nodes.size(); nodes.push_back(u);\n\tif (heavy[u] != -1) build_hld(root, heavy[u], u);\n\tfor (auto v : g[u]) if (v != p && v != heavy[u])\n\t\ttchains++, build_hld(v, v, u);\n\ttout[u] = nodes.size() - 1;\n}\n\nvoid hld() { \n\ttchains = 0; nodes.clear(); \n\tdfs(0, 0, 0); \n\tbuild_hld(0, 0, -1);\n}\n\nint lca(int u, int v) {\n\twhile (chain[u] != chain[v]) {\n\t\tif (depth[head[v]] > depth[head[u]]) swap(u, v);\n\t\tu = par[head[u]];\n\t}\n\tif (depth[u] > depth[v]) swap(u, v); return u;\n}\n\nvoid test_hld() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tg[i].clear();\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint c;\n\t\tcin >> c;\n\t\twhile (c--) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tg[i].push_back(x);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t}\n\thld();\n\tint m;\n\tcin >> m;\n\twhile (m--) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcout << lca(x, y) << \"\\n\";\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\ttest_hld();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\ntemplate <typename Base>\nclass SparseTable\n{\npublic:\n    using T = typename Base::T;\n    using SemiLattice = Base;\n    SparseTable(const vector<T>& val)\n        : size(val.size()), lg2(size + 1, 0)\n    {\n        for (int i = 2; i <= size; i++) {\n            lg2[i] = lg2[i / 2] + 1;\n        }\n        table.resize(size, vector<T>(lg2[size] + 1));\n        for (int i = 0; i < size; i++) {\n            table[i][0] = val[i];\n        }\n        for (int j = 0; j < lg2[size]; j++) {\n            const int w = 1 << j;\n            for (int i = 0; i <= size - (w << 1); i++) {\n                T tl = table[i][j], tr = table[i + w][j];\n                table[i][j + 1] = op(tl, tr);\n            }\n        }\n    }\n    T accumulate(const int l, const int r) const\n    {\n        assert(0 <= l and l < r and r <= size);\n        const int j = lg2[r - l];\n        return op(table[l][j], table[r - (1 << j)][j]);\n    }\n\nprivate:\n    const int size;\n    vector<int> lg2;\n    vector<vector<T>> table;\n    const SemiLattice op{};\n};\n\n\n\nclass LowestCommonAncestor\n{\npublic:\n    LowestCommonAncestor(const Graph& g, const int root = 0) : left(g.V, 0)  // 無向根付き木\n    {\n        vector<bool> used(g.V, false);\n        auto dfs = fix([&](auto&& self, const pair<int, int>& s) -> void {\n            used[s.second] = true;\n            const int pos = s.second;\n            left[pos] = depth.size();\n            depth.push_back(s);\n            for (const int to : g.edge[pos]) {\n                if (used[to]) { continue; }\n                self(self, {s.first + 1, to});\n                depth.push_back(s);\n            }\n        });\n        dfs(make_pair(0, root));\n    }\n    int LCA(const int u, const int v) const\n    {\n        static const SparseTable<DepthMin> st{depth};\n        const int ul = left[u];\n        const int vl = left[v];\n        return st.accumulate(min(ul, vl), max(ul, vl) + 1).second;\n    }\n\nprivate:\n    struct DepthMin\n    {\n        using T = pair<int, int>;\n        T operator()(const T& a, const T& b) const { return min(a, b); }\n    };\n    vector<int> left;\n    vector<pair<int, int>> depth;\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n// Status: Accepted\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g.addEdge(i, c);\n        }\n    }\n\n    LowestCommonAncestor lca{g};\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.LCA(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n \nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nInt n;\n\n#define MAX_V 100001\nvector<Int> G[MAX_V], vs(MAX_V * 2 - 1), depth(MAX_V * 2 - 1), id(MAX_V);\n\n// セグメントツリー\nclass SegmentTree {\nprivate:\n    Int n;\n    vector<pair<Int, Int>> node;\n    pair<Int, Int> ident = {INF, -1};\n    pair<Int, Int> f(pair<Int, Int> x, pair<Int, Int> y) {\n        return x.fi < y.fi ? x : y;\n    }\npublic:\n    // SegmentTree(vector<Int> v) {\n    //     Int v_size = v.size();\n    //     n = 1;\n    //     while (n < v_size) {\n    //         n *= 2;\n    //     }\n    //     node.resize(2 * n, ident);\n    //     for (Int i = 0; i < v_size; i++) {\n    //         node[n + i] = v[i];\n    //     }\n    //     for (Int i = n - 1; i >= 1; i--) {\n    //         node[i] = f(node[i * 2], node[i * 2 + 1]);\n    //     }\n    // }\n    SegmentTree(vector<pair<Int, Int>> v) {\n        Int v_size = v.size();\n        n = 1;\n        while (n < v_size) {\n            n *= 2;\n        }\n        node.resize(2 * n, ident);\n        for (Int i = 0; i < v_size; i++) {\n            node[n + i] = v[i];\n        }\n        for (Int i = n - 1; i >= 1; i--) {\n            node[i] = f(node[i * 2], node[i * 2 + 1]);\n        }\n    }\n    // void update(Int x, Int val) {\n    //     x += n;\n    //     node[x] = val;\n    //     while (x > 1) {\n    //         x /= 2;\n    //         node[x] = f(node[x * 2], node[x * 2 + 1]);\n    //     }\n    // }\n    // [a, b) での答え\n    pair<Int, Int> query(Int a, Int b, Int k = 1, Int l = 0, Int r = -1) {\n        //cout << l << \" \" << r << endl;\n        if (r < 0) {\n            r = n;\n        }\n        if (r <= a or b <= l) {\n            return ident;\n        }\n        if (a <= l and r <= b) {\n            return node[k];\n        }\n        pair<Int, Int> vl = query(a, b, 2 * k, l, (l + r) / 2);\n        pair<Int, Int> vr = query(a, b, 2 * k + 1, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n};\n\n\n\nvoid dfs(Int v, Int d, Int &k) {\n    vs[k] = v;\n    depth[k] = d;\n    id[v] = k;\n    k++;\n    for (Int i = 0; i < (Int)G[v].size(); i++) {\n        dfs(G[v][i], d + 1, k);\n        vs[k] = v;\n        depth[k] = d;\n        k++;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (Int i = 0; i < n; i++) {\n        Int k;\n        cin >> k;\n        for (Int j = 0; j < k; j++) {\n            Int c;\n            cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    Int x = 0;\n    dfs(0, 0, x);\n    vector<pair<Int, Int>> arg(depth.size());\n    for (Int i = 0; i < (Int)depth.size(); i++) {\n        arg[i] = {depth[i], i};\n    }\n    SegmentTree seg(arg);\n    Int q;\n    cin >> q;\n    vector<Int> res(q);\n    for (Int i = 0; i < q; i++) {\n        Int u, v;\n        cin >> u >> v;\n        res[i] = vs[seg.query(min(id[u], id[v]), max(id[u], id[v]) + 1).se];\n    }\n    for (Int i = 0; i < q; i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i <(n); i++)\nusing namespace std;\nusing ll = long long;\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\nconst int MAX_LOG_N = 20;\n\nvector<int> graph[MAX_N];\nint parent[MAX_N][MAX_LOG_N];\nint depth[MAX_N];\n\nvoid dfs(int now, int p, int d)\n{\n    depth[now] = d;\n    for (auto next: graph[now])\n    {\n        if (next == p) continue;\n        dfs(next, now, d + 1);\n    }\n}\n\nint lca(int u, int v, int log_n)\n{\n    if (depth[v] > depth[u]) swap(u, v);\n    int dif = depth[u] - depth[v];\n    for (int i = log_n; i >= 0; i--)\n    {\n        if ((dif >> i) & 1)\n            u = parent[u][i];\n    }\n\n    if (u == v) return u;\n\n    for (int i = log_n; i >= 0; i--)\n    {\n        if (parent[u][i] == parent[v][i])\n            continue;\n        \n        u = parent[u][i];\n        v = parent[v][i];\n    }\n    return parent[u][0];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    int log_n = 0;\n    while ((1 << log_n) < n) log_n++;\n\n    rep(j, log_n)\n    rep(i, n)\n        parent[i][j] = -1;\n\n    rep(i, n)\n    {\n        int k, c;\n        cin >> k;\n        rep(j, k)\n        {\n            cin >> c;\n            parent[c][0] = i;\n\n            graph[i].push_back(c);\n            graph[c].push_back(i);\n        }\n    }\n\n    dfs(0, -1, 0);\n\n    parent[0][0] = -1;\n    rep(j, log_n)\n    rep(i, n)\n    {\n        if (parent[i][j] == -1)\n            continue;\n        else\n            parent[i][j + 1] = parent[parent[i][j]][j];\n    }\n\n    int q;\n    cin >> q;\n    rep(_q, q)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v, log_n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >t)\n    :tree(t),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct rmqsegtree{\n  vector< pair<int, int> > t; //<data, at>\n  pair<int, int> re;\n  int n;\n  void dflt(void){ re.first = INT_MAX; re.second = -1; return; }\n  void use(void){\n    int i; dflt();\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0].first = 1 << (i - 1); t[0].second = 1 << i;\n    for(i = 1;i < t[0].second;++i)t[i] = re;\n    for(i = 0;i < n;++i)t[i + t[0].first].second = i;\n    return;\n  }\n  void build(vector<int> a){\n    for(n = 1;;n <<= 1)if(n >= a.size())break;\n    t.resize(n << 1); dflt();\n    t[0].first = n; t[0].second = t[0].first << 1; n = a.size();\n    for(int i = 1;i < t[0].second;++i)t[i] = re;\n    for(int i = 0;i < n;++i){\n      t[t[0].first + i].first = a[i]; t[t[0].first + i].second = i;\n    }\n    for(int i = t[0].first - 1;i >= 1;--i)\n      t[i] = (t[i << 1] <= t[(i << 1) + 1]) ? t[i << 1] : t[(i << 1) + 1];\n    return;\n  }\n  void update(int at, int data){\n    t[t[0].first + at].first = data;\n    for(int x = t[0].first + at;x > 1;){\n      x >>= 1;\n      if(t[x << 1].first <= t[(x << 1) + 1].first)t[x] = t[x << 1];\n      else t[x] = t[(x << 1) + 1];\n    }\n    return;\n  }\n  pair<int, int> query(int l, int r, int k, int kl, int kr){\n    if(l <= t[k].second && t[k].second < r)return t[k];\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    pair<int, int> a = query(l, r, k << 1, kl, (kl + kr) >> 1);\n    pair<int, int> b = query(l, r, (k << 1) + 1, (kl + kr) >> 1, kr);\n    return (a.first < b.first) ? a : b;\n  }\n  pair<int, int> find(int l, int r){ return query(l, r, 1, 0, t[0].first); }\n  void deb(void){\n    int x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].first);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].second);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    return;\n  }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nstruct tree{\n  vector< vector<edge> > t;\n  int v;\n  void nexttree(int x){ //x-indexed\n    scanf(\"%d\", &v);  t.resize(v);\n    int from, to, cost = 1;\n    for(int i = 1;i < v;++i){\n      scanf(\"%d %d\", &from, &to);\n      t[from - x].push_back((edge){to - x, cost});\n      t[to - x].push_back((edge){from - x, cost});\n    }\n    return;\n  }\n  void nexttree2(int x){\n    scanf(\"%d\", &v); t.resize(v);\n    int k, to, cost = 1;\n    for(int i = 0;i < v;++i){\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;++j){\n        scanf(\"%d\", &to);\n        t[i - x].push_back((edge){to - x, cost});\n        t[to - x].push_back((edge){i - x, cost});\n      }\n    }\n    return;\n  }\n  rmqsegtree S;\n  vector<int> vst, dpth, id;\n  void lcarmqdfs(int now, int dep){ //575!!\n    id[now] = vst.size();\n    vst.push_back(now); dpth.push_back(dep);\n    for(int i = 0;i < t[now].size();++i)if(id[t[now][i].to] == -1){\n      lcarmqdfs(t[now][i].to, dep + 1);\n      vst.push_back(now); dpth.push_back(dep);\n    }\n    return;\n  }\n  void lcarmq(void){\n    if(vst.size() > v)return;\n    id.resize(v); for(int i = 0;i < v;++i)id[i] = -1;\n    lcarmqdfs(0, 0);\n    S.build(vst);\n    return;\n  }\n  int lcaid(int a, int b){\n    if(id[a] > id[b])swap(a, b);\n    return vst[S.find(id[a], id[b] + 1).second];\n  }\n  int depth(int a){ return dpth[id[a]]; }\n  int dist(int a, int b){ return depth(a) + depth(b) - 2 * depth(lcaid(a, b)); }\n};\n\nsigned main(void){\n  tree T; T.nexttree2(0);\n  T.lcarmq();\n\n  int q, a, b;\n  scanf(\"%d\", &q);\n  for(;q--;){\n    scanf(\"%d%d\", &a, &b);\n    printf(\"%d\\n\", T.lcaid(a, b));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#include<bits/stdc++.h>\nusing namespace std;\nusing cost_t=int;\n\nstruct Edge {\n    int from, to;\n    cost_t cost;\n    Edge(int from, int to, cost_t cost) : from(from), to(to), cost(cost) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct LCA{\n    static const int LOGN=20;\n    array<vector<int>,LOGN+1> par;\n    vector<int> dep;\n    void dfs(int v,int pre,Graph& g){\n        for(auto& e:g[v]){\n            if(e.to==pre) continue;\n            par[0][e.to]=v;\n            dep[e.to]=dep[v]+1;\n            dfs(e.to,v,g);\n        }\n    }\n\n    LCA(Graph& g,int root):dep(g.size()){\n        int n=g.size();\n        for(int i=0;i<=LOGN;i++) par[i].assign(n,-1);\n        dep[root]=0;\n        par[0][root]=root;\n        dfs(root,-1,g);\n        for(int i=0;i<LOGN;i++){\n            for(int j=0;j<n;j++){\n                par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n\n    int query(int u,int v){\n        if(dep[u]<dep[v]) swap(u,v);\n        int d = dep[u]-dep[v];\n        for(int i=LOGN;i>=0;i--){\n            if((d>>i)&1){\n                u = par[i][u];\n                d-=(1<<i);\n            }\n        }\n        if(u==v) return u;\n        for(int i=LOGN;i>=0;i--){\n            if(par[i][u]!=par[i][v]) u=par[i][u],v=par[i][v];\n        }\n        return par[0][u];\n    }\n};\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        while(k--){\n            int v; cin>>v;\n            g[i].push_back(Edge(i,v,0));\n            g[v].push_back(Edge(v,i,0));\n        }\n    }\n    LCA lca(g,0);\n    int q;\n    cin>>q;\n    while(q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<lca.query(u,v)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b){a = b; return true;} return false;}\n\nstruct Edge{\n    int to,weight;\n    Edge(int t,int w) : to(t), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nclass Tree{\n    public:\n        Tree(int size) : mGraph(size), mMemo(size), mLog2v(log2(size)) {}\n        void add_edge(int s, int t, int w = 1){\n            mGraph[s].emplace_back(t,w);\n            mGraph[t].emplace_back(s,w);\n        }\n\n        // diameter of a tree\n        pair<int,int> dfs(int v, int pv){\n            pair<int,int> ret(0,v);\n            for(Edge nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                pair<int,int> tmp = dfs(nv.to,v);\n                if(chmax(ret.first,tmp.first + nv.weight)){\n                    ret.second = tmp.second;\n                }\n            }\n            return ret;\n        }\n\n        int diameter(){\n            pair<int,int> s = dfs(0,-1);\n            pair<int,int> t = dfs(s.second,-1);\n            return t.first;\n        }\n        //\n\n        // height of a tree\n        int dfs_memo(int v,int e){\n            if(mMemo[v][e].weight >= 0) return mMemo[v][e].weight;\n            mMemo[v][e].weight = mGraph[v][e].weight;\n            int nv = mMemo[v][e].to;\n            for(int ne = 0; ne < mMemo[nv].size(); ++ne){\n                if(mMemo[nv][ne].to == v) continue;\n                mMemo[v][e].weight = max(mMemo[v][e].weight, dfs_memo(nv,ne) + mGraph[v][e].weight);\n            }\n            return mMemo[v][e].weight;\n        }\n\n        vector<int> height(){\n            mMemo = mGraph;\n            // init memo\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    mMemo[i][j].weight = -1;\n                }\n            }\n            //\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    if(mMemo[i][j].weight < 0){\n                        mMemo[i][j].weight = dfs_memo(i,j);\n                    }\n                }\n            }\n\n           // calc result\n           vector<int> ret(mMemo.size());\n           for(int i = 0; i < mMemo.size(); ++i){\n               for(int j = 0; j < mMemo[i].size(); ++j){\n                   ret[i] = max(ret[i],mMemo[i][j].weight);\n               }\n           }\n           return ret;\n        }\n        //\n        \n        // Lowest Common Ancester\n        void SetParentAndDepth(int v,int pv, int d){\n            mPar[0][v] = pv; // v is pv's 2^0 parent\n            mDepth[v] = d;\n            for(auto nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                SetParentAndDepth(nv.to,v,d+1);\n            }\n        }\n\n        void Init(int root){\n            mPar.resize(mGraph.size());\n            for(int i=0; i < mGraph.size();++i) mPar[i].resize(mGraph.size());\n            mDepth.resize(mGraph.size());\n            SetParentAndDepth(root,-1,0);\n            // calc 2^k parent of each vert\n            for(int k = 0; k + 1 < mLog2v; ++k){\n                for(int v = 0; v < mGraph.size(); ++v){\n                    if(mPar[k][v] < 0) mPar[k+1][v] = -1; // not having parent\n                    else mPar[k+1][v] = mPar[k][mPar[k][v]];\n                }\n            }\n        }\n\n        int GetLca(int u,int v){\n            while(mDepth[u] > mDepth[v]) swap(u,v);\n            for(int k = 0; k < mLog2v; ++k){\n                if((mDepth[v] - mDepth[u]) >> k & 1){\n                    v = mPar[k][v];\n                }\n            }\n            if(u==v) return u;\n            for(int k = mLog2v - 1; k >= 0; --k){\n                if(mPar[k][u] != mPar[k][v]) {\n                    u = mPar[k][u];\n                    v = mPar[k][v];\n                }\n            }\n            return mPar[0][u];\n        }\n        //\n\n\n    private:\n        Graph mGraph;\n        Graph mMemo;\n        \n        // LCA\n        int mLog2v;\n        vector<vector<int> > mPar;\n        vector<int> mDepth;\n};\n\nint main(){\n    int n,q,k,x,y;\n    cin >> n;\n    Tree tree(n);\n    for(int i = 0; i < n; ++i){\n        cin >> k;\n        for(int j = 0; j < k; ++j){\n            cin >> x;\n            tree.add_edge(i,x);\n        }\n    }\n    tree.Init(0);\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        cin >> x >> y;\n        cout << tree.GetLca(x,y) << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(40) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,n,a) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,n,0)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\n\n//?????????????????????????????????????±?????????????????????°???????????¨\n\t//int double ??¨??????numeric???????????£?????????????????????\n\t//n ????´???°\n\t//invalid_value ???????????°???????????????a????????????marge(a,invalidvalue) = a, marge(invalid_value, a) = a?????¨??????????????????\nclass SegmentTreeLL {\npublic:\n\tSegmentTreeLL(int n, ll invalid_value);\n\t~SegmentTreeLL();\n\tvoid SetElem(int k, ll val);\n\tint GetCount();\n\tll quary(int a, int b);\n\tll GetElem(int k);\n\n\t//?????????????????¢??°???????????????????????????\n\t//invalid_value??????????????£?????°????????????????????????\n\tbool IsInvalidValue(ll value) {\n\t\treturn value == mInvalidValue;\n\t}\n\t//a??¨b?????? a???b????±?????????¢??°???????????§?¨?????????????????????§?±???????\n\tll Marge(ll a, ll b) {\n\t\treturn min(a,b);\n\t}\nprivate:\n\tvector<ll>\n\t\tmTree;\n\tint mCount;\n\tll mInvalidValue;\n\tvoid Update(int k, ll val);\n\tll InternalQuary(int a, int b, int k, int l, int r);\n};\n\n//?????´??????????????????\nSegmentTreeLL::SegmentTreeLL(int n, ll invalid_value) {\n\tint bin_n = 1;\n\twhile (bin_n < n) bin_n *= 2;\n\tmTree.resize(2 * bin_n);\n\tmInvalidValue = invalid_value;\n\tmCount = bin_n;\n\tfor (int i = 0; i < 2 * bin_n - 1; i++) {\n\t\tmTree[i] = invalid_value;\n\t}\n}\nSegmentTreeLL::~SegmentTreeLL() {\n}\nvoid SegmentTreeLL::SetElem(int k, ll val) { Update(k, val); }\nll SegmentTreeLL::GetElem(int k) { return mTree[mCount - 1 + k]; }\nint SegmentTreeLL::GetCount() { return mCount; }\n//????????´??°\nvoid SegmentTreeLL::Update(int k, ll val) {\n\tk += mCount - 1;\n\tmTree[k] = val;\n\twhile (k > 0) {\n\t\tk = ( k - 1 ) / 2;\n\t\tmTree[k] = Marge(mTree[2 * k + 1], mTree[2 * k + 2]);\n\t}\n}\n//??????[a,b]?????????O(ln(Count))??§?±??????? b < GetCount??¨???????????¨\n//ex. a = 0 , b = 2 ?????? 0,1,2?????????\nll SegmentTreeLL::quary(int a, int b) {\n\treturn InternalQuary(a, b + 1, 0, 0, mCount);\n}\n//?????¨?????????\nll SegmentTreeLL::InternalQuary(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return mInvalidValue;\n\tif (a <= l && r <= b)return mTree[k];\n\telse {\n\t\tint vl = InternalQuary(a, b, k * 2 + 1, l, ( l + r ) / 2);\n\t\tint vr = InternalQuary(a, b, k * 2 + 2, ( l + r ) / 2, r);\n\t\treturn Marge(vl, vr);\n\t}\n}\n//???????????§?????´??????\n\n\nconst static int MAX_V = 10000;\n\nvector<int> G[MAX_V];\nint root = 0;\n\nint vs[MAX_V * 2 - 1];\nSegmentTreeLL depth(MAX_V,INF);\nint id[MAX_V];\n\nvoid dfs(int v, int p, int d, int &k) {\n\tid[v] = k;\n\tvs[k] = v;\n\tdepth.SetElem(k++, d);\n\trep(i, G[v].size()) {\n\t\tif (G[v][i] != p) {\n\t\t\tdfs(G[v][i], v, d + 1, k);\n\t\t\tvs[k] = v;\n\t\t\tdepth.SetElem(k++, d);\n\t\t}\n\t}\n}\n//\nvoid init(int V) {\n\tint k = 0;\n\tdfs(root,-1,0,k);\n}\n\nint LCA(int u, int v) {\n\treturn vs[depth.quary(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n}\n\nint main() {\n\tint n; put n;\n\trep(i, n) {\n\t\tint k; put k;\n\t\trep(j, k) {\n\t\t\tint c; put c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tint q; put q;\n\tinit(n);\n\trep(i, q) {\n\t\tint u, v; put u >> v;\n\t\tcout << LCA(u,v) << endl;\n\t}\n\nEND:\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<tuple>\n#include<list>\n#include<unordered_map>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n#define INF (1 << 30) - 1\n#define LLINF (1LL << 61) - 1\n#define int ll\nusing namespace std;\nconst int MOD = 1000000007;\nconst int MAX = 510000;\n\n\n//0-index\n\nll n,vs[2*100010],depth[2*100010],id[100010],root,q;\nvll G[100010];\n\nstruct SegmentTree{\n    static const int MAX_N = 1<<18;\n    int n;\n    pii dat[2 * MAX_N -1];\n    SegmentTree(int n_){\n        n=1;\n        while(n<n_) n*= 2;\n        for(int i=0;i<2*n-1;i++) dat[i] = pii(INT_MAX,0);\n    }\n    void update(int k,int a){\n        ll i=k;\n        k += n-1;\n        dat[k].first=a;\n        dat[k].second=i;\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    pii query(int a,int b,int k,int l,int r){\n        if(r<=a || b<=l) return pii(INT_MAX,INT_MAX);\n        if(a<=l && r<=b) return dat[k];\n        else{\n            pii vl = query(a,b,k*2+1,l,(l+r)/2);\n            pii vr = query(a,b,k*2+2,(l+r)/2,r);\n            return min(vr,vl);\n        }\n    }\n    int query(int a,int b){\n        return query(a,b,0,0,n).second;\n    }\n};\n\n\nvoid dfs(ll v,ll p,ll d,ll &k){\n    id[v]=k;\n    vs[k]=v;\n    depth[k++]=d;\n    rep(i,(ll)G[v].size()){\n        if(G[v][i]!=p){\n            dfs(G[v][i],v,d+1,k);\n            vs[k]=v;\n            depth[k++]=d;\n        }\n    }\n}\n\nvoid init(){\n    ll k=0;\n    dfs(root,-1,0,k);\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cin>>n;\n    root=0;\n    rep(i,n){\n        ll k;\n        cin>>k;\n        rep(j,k){\n            ll a;\n            cin>>a;\n            G[i].pb(a);\n            G[a].pb(i);\n        }\n    }\n    init();\n    SegmentTree sg(n*2-1);\n    rep(i,2*n-1){\n        sg.update(i,depth[i]);\n    }\n    cin>>q;\n    rep(i,q){\n        ll a,b;\n        cin>>a>>b;\n        ll s=vs[sg.query(min(id[a],id[b]),max(id[a],id[b])+1)];\n        cout<<s<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(40) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,n,a) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,n,0)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\nconst static int MAX_V = 10000;\n\nvector<int> G[MAX_V];\nint root = 0;\n\nint vs[MAX_V * 2 - 1];\nint depth[MAX_V * 2 - 1];\nint id[MAX_V];\n\n//?????????????????????????????????????±?????????????????????°???????????¨\n//int double ??¨??????numeric???????????£?????????????????????\n//n ????´???°\n//invalid_value ???????????°???????????????a????????????marge(a,invalidvalue) = a, marge(invalid_value, a) = a?????¨??????????????????\nclass SegmentTreeInt {\npublic:\n\tSegmentTreeInt(int n, int invalid_value);\n\t~SegmentTreeInt();\n\tvoid SetElem(int k, int val);\n\tint GetCount();\n\tint quary(int a, int b);\n\tint GetElem(int k);\n\n\t//?????????????????¢??°???????????????????????????\n\t//invalid_value??????????????£?????°????????????????????????\n\tbool IsInvalidValue(int value) {\n\t\treturn value == mInvalidValue;\n\t}\n\t//a??¨b?????? a???b????±?????????¢??°???????????§?¨?????????????????????§?±???????\n\tint Marge(int a, int b) {\n\t\tif (IsInvalidValue(a))return b;\n\t\tif (IsInvalidValue(b)) return a;\n\t\tif (depth[a] >= depth[b]) return b;\n\t\treturn a;\n\t}\nprivate:\n\tvector<int>\n\t\tmTree;\n\tint mCount;\n\tint mInvalidValue;\n\tvoid Update(int k, int val);\n\tint InternalQuary(int a, int b, int k, int l, int r);\n};\n\n//?????´??????????????????(??????????????¨???????????´??????)\nSegmentTreeInt::SegmentTreeInt(int n, int invalid_value) {\n\tint bin_n = 1;\n\twhile (bin_n < n) bin_n *= 2;\n\tmTree.resize(2 * bin_n);\n\tmInvalidValue = invalid_value;\n\tmCount = bin_n;\n\tfor (int i = 0; i < 2 * bin_n - 1; i++) {\n\t\tmTree[i] = invalid_value;\n\t}\n}\nSegmentTreeInt::~SegmentTreeInt() {\n}\nvoid SegmentTreeInt::SetElem(int k, int val) { Update(k, val); }\nint SegmentTreeInt::GetElem(int k) { return mTree[mCount - 1 + k]; }\nint SegmentTreeInt::GetCount() { return mCount; }\n//????????´??°\nvoid SegmentTreeInt::Update(int k, int val) {\n\tk += mCount - 1;\n\tmTree[k] = val;\n\twhile (k > 0) {\n\t\tk = ( k - 1 ) / 2;\n\t\tmTree[k] = Marge(mTree[2 * k + 1], mTree[2 * k + 2]);\n\t}\n}\n//??????[a,b]?????????O(ln(Count))??§?±??????? b < GetCount??¨???????????¨\n//ex. a = 0 , b = 2 ?????? 0,1,2?????????\nint SegmentTreeInt::quary(int a, int b) {\n\treturn InternalQuary(a, b + 1, 0, 0, mCount);\n}\n//?????¨?????????\nint SegmentTreeInt::InternalQuary(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return mInvalidValue;\n\tif (a <= l && r <= b)return mTree[k];\n\telse {\n\t\tint vl = InternalQuary(a, b, k * 2 + 1, l, ( l + r ) / 2);\n\t\tint vr = InternalQuary(a, b, k * 2 + 2, ( l + r ) / 2, r);\n\t\treturn Marge(vl, vr);\n\t}\n}\n//???????????§?????´??????\n\nSegmentTreeInt rmq(64-1,INF);\n\nvoid dfs(int v, int p, int d, int &k) {\n\tid[v] = k;\n\tvs[k] = v;\n\tdepth[k++] = d;\n\trep(i, G[v].size()) {\n\t\tif (G[v][i] != p) {\n\t\t\tdfs(G[v][i], v, d + 1, k);\n\t\t\tvs[k] = v;\n\t\t\tdepth[k++] = d;\n\t\t}\n\t}\n}\n//\nvoid init(int V) {\n\tint k = 0;\n\tdfs(root,-1,0,k);\n\trep(i, V * 2) {\n\t\trmq.SetElem(i,i);\n\t}\n}\n\nint LCA(int u, int v) {\n\treturn vs[rmq.quary(min(id[u], id[v]), max(id[u], id[v])+1)];\n}\n\nint main() {\n\tint n; put n;\n\trep(i, n) {\n\t\tint k; put k;\n\t\trep(j, k) {\n\t\t\tint c; put c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tint q; put q;\n\tinit(n);\n\trep(i, q) {\n\t\tint u, v; put u >> v;\n\t\tcout << LCA(u,v) << endl;\n\t}\nEND:\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <map>\n#include <utility>\n\n#define MAXN 100000\n\nusing namespace std;\n\nint pre[MAXN] = {-1};\nint st[MAXN];\n\nint search[MAXN][MAXN];\n\nvector<pair<int,int>> vp;\nmap<pair<int,int>,int> mans;\n\nvoid swap(int &i,int &j){\n    int t = i;\n    i = j;\n    j = t;\n}\n\n\nclass Edge{\npublic:\n    int s;\n    int t;\n    Edge(int si,int ti):s(si),t(ti){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    vector<forward_list<int>> adj;\n    Graph(int v):V(v){\n        adj.resize(v);\n        for(int i = 0; i < V;i++) {st[i] = i;pre[i] = -1;}\n        }\n    void addEdge(int i,int j){adj[i].push_front(j);}\n    void tarjanR(Edge e);\n};\n\nint root(int v){\n    while(st[v] != v) v = st[v];\n    return v;\n}\n\nvoid Graph::tarjanR(Edge e){\n    int t = e.t;\n    int s = e.s;\n    pre[t] = 0;\n\n    for(auto a = adj[t].begin();a != adj[t].end();++a){\n        int v = *a;\n        if(pre[v] == -1){\n            tarjanR(Edge(t,v));\n        }\n    }\n    for(int i = 0; i < V;i++){\n        int mi = i,ma = t;\n        if(mi > ma) swap(mi,ma);\n        pair<int,int> p = make_pair(mi,ma);\n        if(pre[i] != -1 && mans.find(p) != mans.end() && mans[p] == -1){\n            mans[p] = root(i);\n        }\n    }\n    st[t] = s;\n}\n\n\nint main()\n{\n    int V,j,q,tt;\n    scanf(\"%d\",&V);\n    Graph G(V);\n    for(int i = 0; i < V; i++){\n        scanf(\"%d\",&j);\n        for(int k = 0; k < j;k++)\n        {\n            scanf(\"%d\",&tt);\n            G.addEdge(i,tt);\n        }\n    }\n\n    int s,t;\n\n    scanf(\"%d\",&q);\n    for(int i = 0; i < q;i++){\n        scanf(\"%d %d\",&s,&t);\n        if(s > t){swap(s,t);}\n        vp.push_back(make_pair(s,t));\n        mans[make_pair(s,t)] = -1;\n    }\n\n    G.tarjanR(Edge(0,0));\n\n    for(int i = 0; i < q;i++){\n        printf(\"%d\\n\",mans[vp[i]]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<utility>\n\nconst int NIL = -1;\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :depth_(n, 0), child_(n) {\n        log_size_ = 1;\n        while(log_size_ << 1 < n) log_size_ <<= 1;\n        parent_.resize(log_size_ + 1, std::vector<int>(n, NIL));\n    }\n    void add(const int v, const int c) {\n        parent_[0][c] = v;\n        depth_[c] = depth_[v] + 1;\n        child_[v].push_back(c);\n    }\n    void init() {\n        for(int d = 1; d < log_size_; ++d) for(int u = 0; u < size(); ++u)\n            if(parent_[d - 1][u] != NIL && parent_[d - 1][parent_[d - 1][u]] != NIL)\n                parent_[d][u] = parent_[d - 1][parent_[d - 1][u]];\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        // u, vを同じ深さにする\n        if(depth_[v] < depth_[u]) std::swap(u, v);\n        for(int i = log_size_; i >= 0; --i) {\n            if(parent_[i][v] == NIL) continue;\n            if(depth_[parent_[i][v]] < depth_[u]) continue;\n            v = parent_[i][v];\n        }\n        if(u == v) return u;\n        // 共通の祖先を求める\n        for(int i = log_size_; i >= 0; --i) {\n            if(parent_[i][u] == NIL) continue;\n            if(parent_[i][u] == parent_[i][v]) continue;\n            u = parent_[i][u];\n            v = parent_[i][v];\n        }\n        return parent_[0][u];\n    }\nprivate:\n    int size() const {return depth_.size();}\n    int log_size_;\n    std::vector<std::vector<int>> parent_;\n    std::vector<std::vector<int>> child_;\n    std::vector<int> depth_;\n};\n\n/*/\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n//*/\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    t.init();\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b){a = b; return true;} return false;}\n\nstruct Edge{\n    int to,weight;\n    Edge(int t,int w) : to(t), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nclass Tree{\n    public:\n        Tree(int size) : mGraph(size), mMemo(size), mLog2v(log2(size)) {}\n        void add_edge(int s, int t, int w = 1){\n            mGraph[s].emplace_back(t,w);\n            mGraph[t].emplace_back(s,w);\n        }\n\n        // diameter of a tree\n        pair<int,int> dfs(int v, int pv){\n            pair<int,int> ret(0,v);\n            for(Edge nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                pair<int,int> tmp = dfs(nv.to,v);\n                if(chmax(ret.first,tmp.first + nv.weight)){\n                    ret.second = tmp.second;\n                }\n            }\n            return ret;\n        }\n\n        int diameter(){\n            pair<int,int> s = dfs(0,-1);\n            pair<int,int> t = dfs(s.second,-1);\n            return t.first;\n        }\n        //\n\n        // height of a tree\n        int dfs_memo(int v,int e){\n            if(mMemo[v][e].weight >= 0) return mMemo[v][e].weight;\n            mMemo[v][e].weight = mGraph[v][e].weight;\n            int nv = mMemo[v][e].to;\n            for(int ne = 0; ne < mMemo[nv].size(); ++ne){\n                if(mMemo[nv][ne].to == v) continue;\n                mMemo[v][e].weight = max(mMemo[v][e].weight, dfs_memo(nv,ne) + mGraph[v][e].weight);\n            }\n            return mMemo[v][e].weight;\n        }\n\n        vector<int> height(){\n            mMemo = mGraph;\n            // init memo\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    mMemo[i][j].weight = -1;\n                }\n            }\n            //\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    if(mMemo[i][j].weight < 0){\n                        mMemo[i][j].weight = dfs_memo(i,j);\n                    }\n                }\n            }\n\n           // calc result\n           vector<int> ret(mMemo.size());\n           for(int i = 0; i < mMemo.size(); ++i){\n               for(int j = 0; j < mMemo[i].size(); ++j){\n                   ret[i] = max(ret[i],mMemo[i][j].weight);\n               }\n           }\n           return ret;\n        }\n        //\n        \n        // Lowest Common Ancester\n        void SetParentAndDepth(int v,int pv, int d){\n            mPar[0][v] = pv; // v is pv's 2^0 parent\n            mDepth[v] = d;\n            for(auto nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                SetParentAndDepth(nv.to,v,d+1);\n            }\n        }\n\n        void Init(int root){\n            mPar.resize(mLog2v+1);\n            for(int i=0; i < mLog2v+1;++i) mPar[i].resize(mGraph.size());\n            mDepth.resize(mGraph.size());\n            SetParentAndDepth(root,-1,0);\n            // calc 2^k parent of each vert\n            for(int k = 0; k + 1 < mLog2v; ++k){\n                for(int v = 0; v < mGraph.size(); ++v){\n                    if(mPar[k][v] < 0) mPar[k+1][v] = -1; // not having parent\n                    else mPar[k+1][v] = mPar[k][mPar[k][v]];\n                }\n            }\n        }\n\n        int GetLca(int u,int v){\n            while(mDepth[u] > mDepth[v]) swap(u,v);\n            for(int k = 0; k < mLog2v; ++k){\n                if((mDepth[v] - mDepth[u]) >> k & 1){\n                    v = mPar[k][v];\n                }\n            }\n            if(u==v) return u;\n            for(int k = mLog2v - 1; k >= 0; --k){\n                if(mPar[k][u] != mPar[k][v]) {\n                    u = mPar[k][u];\n                    v = mPar[k][v];\n                }\n            }\n            return mPar[0][u];\n        }\n        //\n\n\n    private:\n        Graph mGraph;\n        Graph mMemo;\n        \n        // LCA\n        int mLog2v;\n        vector<vector<int> > mPar;\n        vector<int> mDepth;\n};\n\nint main(){\n    int n,q,k,x,y;\n    cin >> n;\n    Tree tree(n);\n    for(int i = 0; i < n; ++i){\n        cin >> k;\n        for(int j = 0; j < k; ++j){\n            cin >> x;\n            tree.add_edge(i,x);\n        }\n    }\n    tree.Init(0);\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        cin >> x >> y;\n        cout << tree.GetLca(x,y) << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint N; // Graph(Tree)の頂点数\nvector< vector<int> > G; // Graph(Tree)の隣接リスト表現\nvector<int> D; // 各頂点のrootからの距離\nint LOG_N; // log2(N)の天井\nvector< vector<int> > P; // P[k][v] : 頂点vの2^k番目の先祖\nvoid dfs(int prev, int index, int d) {\n    P[0][index] = prev;\n    D[index] = d;\n    for (int i = 0; i < G[index].size(); i++) {\n        int next = G[index][i];\n        if (next == prev) continue;\n        dfs(index, next, d + 1);\n    }\n}\nvoid init() {\n    LOG_N = int(ceil(log2(N)));\n    P.clear(); P.resize(LOG_N, vector<int>(N));\n    D.clear(); D.resize(N);\n    dfs(-1, 0, 0);\n    for (int k = 0; k < LOG_N - 1; k++) {\n        for (int v = 0; v < N; v++) {\n            if (P[k][v] < 0) P[k + 1][v] = -1;\n            else P[k + 1][v] = P[k][ P[k][v] ];\n        }\n    }\n}\n// 頂点vのn番目の親を返す\nint nth_parent(int v, int n) {\n    for (int k = 0; k < LOG_N; k++)\n        if (n & (1 << k)) v = P[k][v];\n    return v;\n}\n// 2頂点uとvのLCAを返す\nint lca(int u, int v) {\n    if (D[u] > D[v]) swap(u, v);\n    v = nth_parent(v, D[v] - D[u]);\n    if (u == v) return u;\n    for (int k = LOG_N - 1; k >= 0; k--) {\n        if (P[k][u] != P[k][v]) {\n            u = P[k][u];\n            v = P[k][v];\n        }\n    }\n    return P[0][u];\n}\n// 2頂点uとvの距離を返す\nint dist(int u, int v) {\n    int root = lca(u, v);\n    return (D[u] - D[root]) + (D[v] - D[root]);\n}\n\nint main() {\n    cin >> N;\n    G.clear(); G.resize(N);\n    for (int i = 0; i < N; i++) {\n        int k; cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    init();\n    int Q; cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nvector<int> et, depth, id;\n\nstruct ST\n{\n\tvector<pii> data;\n\tint n;\n\tint segn;\n\n\tST(int v,int k):n(v)\n\t{\n\t\tfor (segn = 1; segn < (n * 2 - 1); segn *= 2);\n\t\tdata.assign(2 * segn, make_pair(INF, -1));\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tdata[segn + i] = make_pair(depth[i], et[i]);\n\t\t}\n\t\tfor (int i = segn - 1; i >= 1; --i)\n\t\t{\n\t\t\tdata[i] = min(data[i * 2], data[i * 2 + 1]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = segn;\n\t\t}\n\t\tif (t <= s || r == 0)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (t - s == r)\n\t\t{\n\t\t\treturn data[l];\n\t\t}\n\n\t\treturn min(find(s, min(t, r / 2), l * 2, r / 2), find(max(0, s - (r / 2)), t - (r / 2), l * 2 + 1, r / 2));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tid[n] = eti;\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tet = vector<int>(n * 2 - 1);\n\tdepth = vector<int>(n * 2 - 1);\n\tid = vector<int>(n);\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(n,eti);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 1, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <iterator>\n#include <tuple>\n#include <utility>\n#include <random>\n#include <limits>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cstdint>\n#include <cassert>\n\n#ifdef DEBUG\n#include <fmt/format.h>\n#endif\n// }}}\n\nusing namespace std;\n\n// macros {{{\ntemplate<typename T, size_t N>\nconstexpr size_t NELEMS(T (&)[N]) { return N; }\n\ntemplate<typename InputIt>\nvoid PRINT_RANGE(InputIt first, InputIt last)\n{\n    for(; first != last; ++first)\n        cout << *first << (first==last ? \"\" : \" \");\n    cout << \"\\n\";\n}\n\ntemplate<typename T>\nvoid PRINT_MATRIX(T mat, size_t nr, size_t nc)\n{\n    for(size_t r = 0; r < nr; ++r) {\n        for(size_t c = 0; c < nc; ++c) {\n            cout << mat[r][c] << (c==nc-1 ? \"\" : \" \");\n        }\n        cout << \"\\n\";\n    }\n}\n\n#define FOR(i, start, end) for(int i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n// }}}\n\n// types {{{\nusing s64 = int64_t;\nusing u64 = uint64_t;\n// }}}\n\nint N;\nvector<vector<int>> T;\n\nvector<int> D; // ???????????±???\nvector<vector<int>> P; // P[v][i]: v??????2^i??????????????£?????????????????????\nint P_NI;\n\nvoid init()\n{\n    D.resize(N);\n\n    P.resize(N);\n    P_NI = 1 + static_cast<int>(log2(N));\n    for(auto& pi : P) {\n        pi.resize(P_NI);\n    }\n}\n\nvoid dfs(int u, int p, int d)\n{\n    D[u] = d;\n    P[u][0] = p;\n\n    for(int v : T[u]) {\n        if(v == p) continue;\n        dfs(v, u, d+1);\n    }\n}\n\nvoid make_p()\n{\n    REP(i, P_NI-1) {\n        REP(v, N) {\n            if(P[v][i] == -1) {\n                P[v][i+1] = -1;\n            }\n            else {\n                P[v][i+1] = P[P[v][i]][i];\n            }\n        }\n    }\n}\n\nint lca(int u, int v)\n{\n    // ?°????????????? D[u] <= D[v] ??¨??????\n    if(D[u] > D[v]) swap(u,v);\n\n    // ??±??????????????????(D[u] == D[v] ??¨??????)\n    for(int i = P_NI-1; i >= 0; --i) {\n        int d = D[v] - D[u];\n        if((d>>i) & 1) {\n            v = P[v][i];\n        }\n    }\n\n    // ?????´????????´??????????????\\?????????????????????\n    if(u == v) return u;\n\n    // ????????¢?´¢\n    for(int i = P_NI-1; i >= 0; --i) {\n        if(P[u][i] != P[v][i]) {\n            u = P[u][i];\n            v = P[v][i];\n        }\n    }\n    return P[u][0];\n}\n\nvoid solve()\n{\n    init();\n\n    dfs(0, -1, 0);\n\n    make_p();\n\n#ifdef DEBUG\n    fmt::print(\"D:\\n\");\n    PRINT_RANGE(begin(D), end(D));\n    fmt::print(\"P:\\n\");\n    PRINT_MATRIX(P, N, P_NI);\n#endif\n\n    int Q;\n    cin >> Q;\n    REP(_, Q) {\n        int u, v;\n        cin >> u >> v;\n\n        cout << lca(u,v) << \"\\n\";\n    }\n}\n\nint main()\n{\n    cin >> N;\n    T.resize(N);\n\n    REP(u, N) {\n        int k;\n        cin >> k;\n        REP(_, k) {\n            int v;\n            cin >> v;\n            T[u].push_back(v);\n            T[v].push_back(u);\n        }\n    }\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\nint dp[20][100020]={};\nvector<int>G[100020];\nint depth[100020];\nvoid dfs(int r,int de){\n\tdepth[r]=de;\n\tfor(auto v:G[r])dfs(v,de+1);\n}\n signed main(){\n \t\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n;\n \tcin>>n;\n \tfor(int i=0;i<n;i++){\n \t\tint k;\n \t\tcin>>k;\n \t\tfor(int j=0;j<k;j++){\n \t\t\tint y;\n \t\t\tcin>>y;\n \t\t\tG[i].pb(y);\n \t\t\tdp[0][y]=i;\n \t\t}\n \t}\n \tdfs(0,0);\n \t\n \tfor(int i=1;i<20;i++)for(int j=0;j<n;j++){\n \t\tdp[i][j]=dp[i-1][dp[i-1][j]];\n \t}\n \tint we;\n \tcin>>we;\n \tfor(int q=0;q<we;q++){\n \t\tint a,b;\n \t\tcin>>a>>b;\n \t\tif(depth[a]<depth[b])swap(a,b);\n \t\tint sa=depth[a]-depth[b];\n \t\tfor(int i=0;i<20;i++)if(sa&(1<<i))a=dp[i][a];\n \t\t\n \t\tif(a==b){\n \t\t\tcout<<a<<endl;\n \t\t\tcontinue;\n \t\t}\n \t\tfor(int i=19;i>=0;i--){\n \t\t\tif(dp[i][a]!=dp[i][b]){\n \t\t\t\ta=dp[i][a];\n \t\t\t\tb=dp[i][b];\n \t\t\t}\n \t\t}\n \t\tcout<<dp[0][a]<<endl;\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass LCA {\nprivate:\n    static const int MAX_LOG = 20;\n    const int n;\n    Graph G;\n    V depth;\n    VV par;\n    V cnt; // ?????????????????£????????°\npublic:\n    LCA(int _n) : n(_n), G(_n), par(MAX_LOG, V(_n)), depth(_n), cnt(_n) {}\n    // undirected\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n    // ??????????????±?????¨???1????????????????±???????\n    void dfs(int v, int p, int d) {\n        // cerr << v << \" \" << p << \" \" << d << endl;\n        par[0][v] = p;\n        depth[v] = d;\n        for (auto nxt : G[v]) {\n            if (nxt != p) {\n                dfs(nxt, v, d + 1);\n            }\n        }\n    }\n    // ????????????2^k????????????????±?????????????\n    void setPar() {\n        // 0????????¨??????1????????????????±???????\n        dfs(0, -1, 0);\n\n        // 2^i????????????????±???????\n        rep(i, MAX_LOG - 1) {\n            rep(j, n) {\n                if (par[i][j] == -1) {\n                    par[i + 1][j] = -1;\n                } else {\n                    par[i + 1][j] = par[i][par[i][j]];\n                }\n            }\n        }\n    }\n    int lca(int a, int b) {\n        // ??????a??¨b?????±???????????????\n        if (depth[a] > depth[b]) {\n            swap(a, b);\n        }\n        rep(i, MAX_LOG) {\n            if ((depth[b] - depth[a]) >> i & 1) {\n                b = par[i][b];\n            }\n        }\n        if (a == b) return a;\n\n        // ??¶???????????´????????§a, b????????????\n        rrep(i, MAX_LOG) {\n            if (par[i][a] != par[i][b]) {\n                a = par[i][a];\n                b = par[i][b];\n            }\n        }\n        // a??¨b???1????????????????????´????????????\n        return par[0][a];\n    }\n\n    void updateCnt(int u, int v) {\n        cnt[u]++;\n        cnt[v]++;\n        int w = lca(u, v);\n        cnt[w]--;\n        if (par[0][w] != -1) cnt[par[0][w]]--;\n    }\n    int imosFinal(int v, int p) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            t += imosFinal(nxt, v);\n        }\n        cnt[v] += t;\n        return cnt[v];\n    }\n    int answer() {\n        imosFinal(0, -1);\n        int ans = 0;\n        for (auto&& x : cnt) {\n            ans += (x + 1) * x / 2;\n        }\n        return ans;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    scanf(\"%lld\", &n);\n    LCA lca(n);\n    rep(i, n) {\n        int k;\n        scanf(\"%lld\", &k);\n        rep(j, k) {\n            int c;\n            scanf(\"%lld\", &c);\n            lca.addEdge(i, c);\n        }\n    }\n\n    lca.setPar();\n\n    int Q;\n    scanf(\"%lld\", &Q);\n    rep(i, Q) {\n        int u, v;\n        scanf(\"%lld%lld\", &u, &v);\n        printf(\"%lld\\n\", lca.lca(u, v));\n    }\n}\n\n// signed main() {\n//     std::ios::sync_with_stdio(false);\n//     std::cin.tie(0);\n//\n//     int N;\n//     cin >> N;\n//     LCA lca(N);\n//     rep(i, N) {\n//         int u, v;\n//         cin >> u >> v;\n//         u--, v--;\n//         lca.addEdge(u, v);\n//     }\n//\n//     cerr << \"hey!\" << endl;\n//\n//     lca.setPar();\n//\n//     cerr << \"hey!\" << endl;\n//\n//     int Q;\n//     cin >> Q;\n//     rep(i, Q) {\n//         int u, v;\n//         cin >> u >> v;\n//         u--, v--;\n//         lca.updateCnt(u, v);\n//     }\n//\n//     cerr << \"hey!\" << endl;\n//\n//     cout << lca.answer() << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\n\nint N,Q;\nvector<int> g[MAX_N+5];\nint root;\nint depth[MAX_N+5];\nint par[21][MAX_N];\n\nvoid dfs(int v,int p,int d){\n    if(depth[v]!=-1)return;\n    par[0][v]=p;\n    depth[v]=d;\n    for(int u=0;u<g[v].size();++u){\n        if(g[v][u]!=p)dfs(g[v][u],v,d+1);\n    }\n}\n\nvoid fill_table(){\n    fill(depth,depth+N,-1);\n    dfs(root,-1,0);\n    for(int i=0;i<20;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nint LCA(int u,int v){\n    if(depth[u]>depth[v])swap(u,v);\n    for(int i=0;i<20;++i){\n        if((depth[v]-depth[u])>>i&1)v=par[i][v];\n    }\n    if(v==u)return u;\n    for(int i=20;i>=0;--i){\n        if(par[i][v]!=par[i][v]){\n            u=par[i][u];\n            v=par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;++j){\n            int c;\n            cin>>c;\n            g[i].PB(c);\n        }\n    }\n    fill_table();\n    cin>>Q;\n    while(Q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<LCA(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 2147483647\n#define N 100005\n#define SegN (1<<19)\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,dep[N];\nvector<int> G[N];\n\nvector<int> Debug;\n\nP tree[SegN];\n\nvoid Update(int x,P y){\n  x+=(SegN/2)-1;\n  tree[x]=y;\n  while(x>0){\n    x=(x-1)/2;\n    tree[x]=min(tree[x*2+1],tree[x*2+2]);\n  }\n}\n\nP Find(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l) return P(INF,INF);\n  if(a<=l&&r<=b) return tree[k];\n  else{\n    P vl=Find(a,b,k*2+1,l,(l+r)/2);\n    P vr=Find(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n}\n\nvoid dfs(int pos){\n  Debug.push_back(pos);  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    dep[to]=dep[pos]+1;\n    dfs(to);\n    Debug.push_back(pos);\n  }\n}\n\nint main(){\n  for(int i=0;i<2*n-1;i++) Update(i,P(INF,INF));\n\n\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    int k,a;\n    scanf(\"%d\",&k);\n    for(int j=0;j<k;j++){\n      scanf(\"%d\",&a);\n      G[i].push_back(a);\n    }\n  }\n  dfs(0);\n\n  map<int,int> mp;\n\n  for(int i=0;i<(int)Debug.size();i++){\n    int id = Debug[i];\n    Update( i , P( dep[id] , id ) );\n    mp[id]=i;\n  }\n\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a=mp[a];\n    b=mp[b];\n    if(a>b)swap(a,b);\n    P ans=Find(a,b+1,0,0,SegN/2);\n    cout<< ans.second <<endl;\n\n  }\n  /*\n  for(int i=0;i<(int)Debug.size();i++){\n    cout<< (char)(Debug[i]+'A')<<' ';\n  }\n  cout<<endl;\n\n  for(int i=0;i<(int)Debug.size();i++){\n    cout<<  dep[ Debug[i] ]<<' ';\n  }\n  cout<<endl;\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nusing P=pair<int,int>;\nconst int INF=1<<29;\nconst int MAX_V=100010;\nvector<int> children[MAX_V];\n\nint dep[MAX_V];\nint par[MAX_V][20];\nvoid dfs(int node,int p,int d){\n  dep[node]=d;\n  for(int child:children[node]){\n    if(child==p)continue;\n    par[child][0]=node;\n    dfs(child,node,d+1);\n  }\n}\nint lca(int a,int b){\n  if(dep[a]<dep[b])swap(a,b);\n  REP(i,20) if((dep[a]-dep[b])&(1<<i))a=par[a][i];\n  if(a==b)return a;\n  for(int i=19;i>=0;i--) if(par[a][i]!=par[b][i]) a=par[a][i],b=par[b][i];\n  return par[a][0];\n}\n\nint main(){_;\n  int n,q,k,u,v;\n  cin>>n;\n  REP(i,n){\n    cin>>k;\n    children[i]=vector<int>(k);\n    REP(j,k)cin>>children[i][j];\n  }\n  dfs(0,-1,0);\n  REP(i,19) REP(j,n) par[j][i+1]=par[par[j][i]][i];\n  cin>>q;\n  REP(i,q){\n    cin>>u>>v;\n    cout<<lca(u,v)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100001\n#define LOG_MAX 30\nint n,q;\nvector<int> g[N];\nint root;\nint par[N][LOG_MAX];\nint depth[N];\n\nvoid dfs(int x,int d){\n  depth[x]=d;\n  //cout<<x<<endl;\n  for(int i=0;i<g[x].size();i++){\n    par[g[x][i]][0]=x;\n    dfs(g[x][i],d+1);\n  }\n}\n\nint KthAns(int u,int k){\n  for(int i=0;i<LOG_MAX;i++){\n    if(u==-1)return -1;\n    if(k>>i&1)u=par[u][i];\n  }\n  return u;\n}\n\nvoid build(){\n  dfs(root,0);\n  par[root][0]=-1;\n  for(int i=1;i<LOG_MAX;i++)\n    for(int j=0;j<n;j++){\n      if(par[j][i-1]==-1)par[j][i]=-1;\n      else par[j][i]=par[par[j][i-1]][i-1];\n    }\n}\n\nint lca(int u,int v){\n  //cout<<u<<\" \"<<v<<endl;\n  if(depth[u]>depth[v])swap(u,v);\n  v=KthAns(v,depth[v]-depth[u]);\n  for(int i=LOG_MAX-1;i>=0;i--){\n    int up=par[u][i];\n    int vp=par[v][i];\n    //cout<<u<<\" \"<<v<<endl;\n    if(up==vp)continue;\n    u=up,v=vp;\n  }\n  return par[u][0];\n}\n\nint main(){\n  root=0;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int k,c;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      cin>>c;\n      g[i].push_back(c);\n    }\n  }\n  build();\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca(u,v)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int nmax=100010;\nvector<int> graph[nmax];\nint parent[nmax][20];\nint depth[nmax];\n\nvoid init(int n){\n\tfunction<void (int,int,int)> dfs=[&dfs](int v,int p,int d){\n\t\tparent[v][0]=p;\n\t\tdepth[v]=d;\n\t\tfor(auto &v2:graph[v]) if(v2!=p) dfs(v2,v,d+1);\n\t};\n\tdfs(0,-1,0);\n\trep(j,19)rep(i,n){\n\t\tif(parent[i][j]==-1)\n\t\t\tparent[i][j+1]=-1;\n\t\telse\n\t\t\tparent[i][j+1]=parent[parent[i][j]][j];\n\t}\n}\n\nint lca(int u,int v){\n\tif(depth[u] < depth[v]) swap(u,v);\n\tfor(int i=19;i>=0;--i) if((depth[u]-depth[v])>>i&1) u=parent[u][i];\n\tif(u==v) return u;\n\tfor(int i=19;i>=0;--i){\n\t\tif(parent[u][i]!=parent[v][i]){\n\t\t\tu=parent[u][i];\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\treturn parent[u][0];\n}\n\nint main(void){\n\tint n; cin >> n;\n\trep(i,n){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint v; cin >> v;\n\t\t\tgraph[i].push_back(v);\n\t\t}\n\t}\n\tinit(n);\n\tint q; cin >> q;\n\trep(i,q){\n\t\tint u,v; cin >> u >> v;\n\t\tcout << lca(u,v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nclass Label_LCA{\nprivate:\n    ll v;\n    ll root;\n    vector<vector<ll>> edge;\n    vector<ll> number_to_node; //number::通りがけ順\n    vector<ll> node_to_number;\n    vector<pll> dp; //部分木のサイズ、Hevy child\n    vector<vector<ll>> Label;\n    bool made;\n    \n    void dfs(const ll &where,const ll &parent,ll &count){\n        node_to_number[where]=count;\n        number_to_node[count]=where;\n        dp[where]={1,-1};\n        ll mx=0;\n        for(int i=0;i<edge[where].size();i++){\n            const ll &to=edge[where][i];\n            if(to==parent){continue;}\n            count++;\n            dfs(to,where,count);\n            dp[where].F+=dp[to].F;\n            if(mx<dp[to].F){\n                mx=dp[to].F;\n                dp[where].S=to;\n            }\n        }\n    }\n    \n    void dfs2(const ll &where,const ll &parent){\n        const ll &H=dp[where].S;\n        if(H!=-1){\n            Label[H]=Label[where];\n            Label[H][Label[H].size()-1]=node_to_number[H];\n            dfs2(H,where);\n        }\n        for(int i=0;i<edge[where].size();i++){\n            const ll &to=edge[where][i];\n            if(to==parent || to==H){continue;}\n            Label[to]=Label[where];\n            Label[to].push_back(node_to_number[to]);\n            Label[to].push_back(node_to_number[to]);\n            dfs2(to,where);\n        }\n    }\n    \n    void mk_tree(){\n        ll count=0;\n        dfs(root,-1,count);\n        Label[root]={0,0};\n        dfs2(root,-1);\n        made=true;\n    }\n    \npublic:\n    Label_LCA(ll V,ll root):v(V),root(root),edge(V),number_to_node(V),node_to_number(V),dp(V),Label(V),made(false){}\n    \n    void add_edge(ll u,ll v){\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    \n    ll search_lca(ll a,ll b){\n        if(!made){mk_tree();}\n        if(a==b){return a;}\n        const vector<ll> &A=Label[a];\n        const vector<ll> &B=Label[b];\n        for(int i=0;i<min(A.size(),B.size());i++){\n            if(A[i]!=B[i]){\n                if(i%2==0){\n                    return number_to_node[A[i-1]];\n                }\n                else{\n                    return number_to_node[min(A[i],B[i])];\n                }\n            }\n        }\n        if(A.size()<B.size()){\n            return number_to_node[B[A.size()-1]];\n        }\n        return number_to_node[A[B.size()-1]];\n    }\n    \n    ll binary_search_lca(ll a,ll b){\n        if(!made){mk_tree();}\n        if(a==b){return a;}\n        const vector<ll> &A=Label[a];\n        const vector<ll> &B=Label[b];\n        ll l=0;\n        ll r=min(A.size(),B.size())-1;\n        if(A[r]==B[r]){return number_to_node[A[r]];}\n        while(r-l>=4){\n            ll m=l+(r-l)/2;\n            if(A[m]==B[m]){l=m;}\n            else{r=m;}\n        }\n        for(ll i=l;i<=r;i++){\n            if(A[i]!=B[i]){\n                if(i%2==0){\n                    return number_to_node[A[i-1]];\n                }\n                else{\n                    return number_to_node[min(A[i],B[i])];\n                }\n            }\n        }\n        return -1;\n    }\n    \n    void test(){\n        cout<<\"test\"<<endl;\n        for(int i=0;i<v;i++){\n            cout<<Label[i].size()<<endl;\n        }\n        cout<<endl;\n    }\n};\n\n\n\n\n\nint main(){\n    ll v;\n    cin>>v;\n    Label_LCA lca(v,0);\n    for(int i=0;i<v;i++){\n        ll k;\n        cin>>k;\n        for(int t=0;t<k;t++){\n            ll u;\n            cin>>u;\n            lca.add_edge(i,u);\n        }\n    }\n    ll q;\n    cin>>q;\n    while(q--){\n        ll a,b;\n        cin>>a>>b;\n        ll A=lca.search_lca(a,b);\n        ll B=lca.binary_search_lca(a,b);\n        assert(A==B);\n        cout<<A<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.assign(2 * size - 1, make_pair(INF, -1));\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = make_pair(depth[i], et[i]);\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k >= 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[l];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tid[n] = eti;\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t{\n\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL; lazy=0; update();\n  }\n   \n  inline void update(){\n    mini=val,minId=id;\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>=rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  inline void apply(int v){ lazy+=v, val+=v, mini+=v; }\n   \n  inline void push(){\n    if(lp)lp->apply(lazy);\n    if(rp)rp->apply(lazy);\n    lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  x->splay();\n  //return x;\n  return rp;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n  c->update();\n}\n\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->apply(val); }\n\nnode_t *LCA(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << LCA(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nclass LCA{\n    int n;\n    vector<int> dep;\n    vector<vector<int>> par;\n    Graph g;\n    const int LOGN_MAX=100;\n    void setDep(int v,int d,Graph& tree){\n        dep[v]=d;\n        for(int i=0;i<tree[v].size();i++) setDep(tree[v][i],d+1,tree);\n    }\n    public:\n    LCA(Graph &tree):n(tree.size()){\n        dep=vector<int>(n);\n        par=vector<vector<int>>(min(LOGN_MAX,int(log(n))+1),vector<int>(n));\n        g=Graph(n);\n        for(int i=0;i<tree.size();i++){\n            for(int j=0;j<tree[i].size();j++){\n                g[tree[i][j]].push_back(i);\n            }\n        }\n\n        bool isTree=true;\n        int root=-1;\n        for(int i=0;i<g.size();i++){\n            if(g[i].size()){\n                isTree&=(g[i].size()==1);\n            }\n            else if(root==-1){\n                root=i;\n                if(g[i].size()==0){\n                setDep(i,0,tree);\n               }\n            }\n            else{\n                isTree=false;\n            }\n        }\n        assert(isTree);\n\n        for(int i=0;i<n;i++){\n            par[0][i]=(g[i].size() ? g[i][0] : i);\n        }\n        for(int i=0;i+1<par.size();i++){\n            for(int j=0;j<par[i].size();j++){\n                par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n\n    int lca(int a,int b){\n        if(dep[a]>dep[b]) swap(a,b);\n        int dist=dep[b]-dep[a];\n        for(int i=0;dist;i++,dist/=2){\n            if(dist%2) b=par[i][b];\n        }\n        assert(dep[a]==dep[b]);\n        while(true){\n            if(a==b) return a;\n            if(par[0][a]==par[0][b]) return par[0][a];\n            int lb=0;\n            int ub=par.size();\n            //[ub,LOGN_MAX)->same anc\n            while(ub-lb>1){\n                int mid=(lb+ub)/2;\n                if(par[mid][a]==par[mid][b]) ub=mid;\n                else lb=mid;\n            }\n            a=par[lb][a];\n            b=par[lb][b];\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;j++){\n            int c;\n            cin>>c;\n            g[i].push_back(c);\n        }\n    }\n    LCA lg(g);\n    int q;\n    cin>>q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin>>u>>v;\n        cout<<lg.lca(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n\nusing namespace std;\n\nconst int sz = 1e5 + 13;\nconst int logsz = 17;\n\nint n;\n\nint p[sz][logsz];\nint t[sz], level[sz];\n\nvector<vector<int> > g (sz);\n\nvoid dfs(int u, int parent){\n    for(auto v: g[u]){\n        if(v != parent){\n            level[v] = level[u] + 1;\n            t[v] = u;\n            dfs(v, u);\n        }\n    }\n}\n\nvoid preprocess(){\n    dfs(0, -1);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; (1<<j) < n; ++j)\n            p[i][j] = -1;\n    for(int i = 0; i < n; ++i)\n        p[i][0] = t[i];\n    for(int j = 1; (1<<j) < n; ++j)\n        for(int i = 0; i < n; ++i) if(p[i][j-1] != -1)\n            p[i][j] = p[p[i][j-1]][j-1];\n}\n\nint lca(int u, int v){\n    if(level[u] < level[v]){u ^= v; v ^= u; u ^= v;}\n    int log;\n    for(log = 1; (1<<log) < level[u]; ++log);\n    log--;\n    for(int i = log; i >= 0; --i)\n        if(level[u]  - (1<< i) >= level[v])\n            u = p[u][i];\n    if(u == v)\n        return u;\n    for(int i = log; i>= 0; --i)\n        if(p[u][i] != -1 && p[u][i] != p[v][i]){\n            u = p[u][i]; v = p[v][i];\n        }\n    return t[u];\n}\n\n\nint main(){\n    cin>>n;\n    for(int i = 0; i < n; ++i){\n        int k;\n        cin>>k;\n        for(int j = 0; j < k; ++j){\n            int x;\n            cin>>x;\n            g[i].push_back(x);\n            g[x].push_back(i);\n        }\n    }\n    preprocess();\n    int q;\n    cin>>q;\n    for(int i = 0; i < q; ++i){\n        int u,v;\n        cin>>u>>v;\n        cout<<lca(u,v)<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdint>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::uint_fast32_t;\n\nprivate:\n\tstd::vector<std::pair<bool, size_type>> tree;\n\npublic:\n\tUnionFind(const size_type size) : tree(size, std::make_pair(1, 1)) {}\n\tsize_type find(const size_type x) {\n\t\tassert(x < size());\n\t\tif (tree[x].first)\n\t\t\treturn x;\n\t\treturn tree[x].second = find(tree[x].second);\n\t}\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (tree[x].second < tree[y].second)\n\t\t\tstd::swap(x, y);\n\t\ttree[x].second += tree[y].second;\n\t\ttree[y] = std::make_pair(0, x);\n\t\treturn true;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn tree[find(x)].second;\n\t}\n\tsize_type size() const noexcept { return tree.size(); }\n\tbool empty() const noexcept { return tree.empty(); }\n};\n\n#include <cstddef>\n#include <functional>\n#include <utility>\n#include <vector>\n\ntemplate <class GraphContainer, class UnionFindDataStructure>\nstd::vector<typename GraphContainer::size_type> TarjansOfflineLCA(\n\tconst GraphContainer &graph, const typename GraphContainer::size_type root,\n\tconst std::vector<std::pair<typename GraphContainer::size_type,\n\ttypename GraphContainer::size_type>> &queries) {\n\tusing size_type = typename GraphContainer::size_type;\n\tconst size_type size_ = graph::size();\n\tUnionFindDataStructure uft(size_);\n\tstd::vector<size_type> ret(queries.size(), size_), anc(size_);\n\tstd::vector<std::vector<std::size_t>> qset(size_);\n\n\tfor (std::size_t i = 0; i < queries.size(); ++i) {\n\t\tqset[queries[i].first].emplace_back(i);\n\t\tqset[queries[i].second].emplace_back(i);\n\t}\n\n\tst.emplace(root, 0);\n\n\tstd::function<void(const size_type, const size_type)> dfs =\n\t\t[&](const size_type v, const size_type prev) {\n\t\tanc[v] = v;\n\t\tfor (const auto &&e : graph[v]) {\n\t\t\tif (e.to != prev) {\n\t\t\t\tdfs(e.to);\n\t\t\t\tuft.unite(v, e.to);\n\t\t\t\tanc[uft.find(v)] = v;\n\t\t\t}\n\t\t}\n\t\tfor (const auto e : qset[v])\n\t\t\tif (ret[e] == size_)\n\t\t\t\tret[e] = v;\n\t\t\telse\n\t\t\t\tret[e] = anc[uft.find(ret[e])];\n\t};\n\tdfs(root, size_);\n\treturn ret;\n}\n\n\n#include <cstddef>\n#include <vector>\n\nstruct edge {\n\tusing cost_type = int;\n\tusing size_type = std::size_t;\n\n\tstd::size_t to;\n\tedge(size_type t):to(t){}\n};\n\ntemplate <class Edge> using Graph = std::vector<std::vector<Edge>>;\n\n#include<cstdio>\nint main() {\n\tusing uint = unsigned int;\n\tuint n;\n\tscanf(\"%u\", &n);\n\tGraph<edge> g(n);\n\tfor (uint i = 0;i < n;++i) {\n\t\tuint k, c;\n\t\tscanf(\"%u\", &k);\n\t\twhile (k--) {\n\t\t\tscanf(\"%u\", &c);\n\t\t\tg[i].emplace_back(c);\n\t\t}\n\t}\n\tuint q;\n\tscanf(\"%u\", &q);\n\tusing S = typename Graph<edge>::size_type;\n\tstd::vector<std::pair<S, S>> Q;\n\tQ.reserve(q);\n\twhile (q--) {\n\t\tuint u, v;\n\t\tscanf(\"%u%u\", &u, &v);\n\t\tQ.emplace_back(u, v);\n\t}\n\tconst auto &&ans=TarjansOfflineLCA<Graph<edge>, UnionFind>(g, 0, Q);\n\tfor (const auto e : ans)\n\t\tprintf(\"%u\\n\", e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T1, class T2> inline void minup(T1& m, T2 x){ if(m>x) m=static_cast<T2>(x); }\ntemplate<class T1, class T2> inline void maxup(T1& m, T2 x){ if(m<x) m=static_cast<T2>(x); }\n\n#define INF 1000000000\n#define MOD 1000000009\n#define EPS 1E-9\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind\n{\nprivate:\n  vi data;\n  int cnt;\n\npublic:\n  UnionFind(int size) : data(size, -1), cnt(size) {}\n  bool unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n      cnt -= 1;\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return root(x) == root(y); }\n  int root(int x){ return data[x] < 0 ? x : data[x] = root(data[x]); }\n  int size(int x){ return -data[root(x)]; }\n  int group(){ return cnt; }\n};\n\nstruct Query\n{\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\n\nvoid visit(const Graph &g, int u, int w, vector<Query> &qs, vi &color, vi &ancestor, UnionFind &uf)\n{\n  ancestor[ uf.root(u) ] = u;\n  vrep(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unite( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  vrep(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\n\nvoid LeastCommonAncestor(const Graph &g, int r, vector<Query> &qs)\n{\n  UnionFind uf(g.size());\n  vi color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint n;\nint k, c;\nint q;\nint u, v;\n\nint main()\n{\n  cin >> n;\n  Graph g(n);\n\n  rep(i, n){\n    cin >> k;\n    while(k--){\n      cin >> c;\n      g[i].pb(Edge(i, c, 1));\n      g[c].pb(Edge(c, i, 1));\n    }\n  }\n\n  cin >> q;\n  vector<Query> qs;\n  rep(i, q){\n    cin >> u >> v;\n    qs.pb(Query(u, v));\n  }\n\n  LeastCommonAncestor(g, 0, qs);\n\n  rep(i, q) cout << qs[i].w << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\nstruct rmqsegtree{\n  vector< pair<int, int> > t; //<data, at>\n  pair<int, int> re;\n  int n;\n  void dflt(void){ re.first = INT_MAX; re.second = -1; return; }\n  void use(void){\n    int i; dflt();\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0].first = 1 << (i - 1); t[0].second = 1 << i;\n    for(i = 1;i < t[0].second;++i)t[i] = re;\n    for(i = 0;i < n;++i)t[i + t[0].first].second = i;\n    return;\n  }\n  void build(vector<int> a){\n    for(n = 1;;n <<= 1)if(n >= a.size())break;\n    t.resize(n << 1); dflt();\n    t[0].first = n; t[0].second = t[0].first << 1; n = a.size();\n    for(int i = 1;i < t[0].second;++i)t[i] = re;\n    for(int i = 0;i < n;++i){\n      t[t[0].first + i].first = a[i]; t[t[0].first + i].second = i;\n    }\n    for(int i = t[0].first - 1;i >= 1;--i)\n      t[i] = (t[i << 1] <= t[(i << 1) + 1]) ? t[i << 1] : t[(i << 1) + 1];\n    return;\n  }\n  void update(int at, int data){\n    t[t[0].first + at].first = data;\n    for(int x = t[0].first + at;x > 1;){\n      x >>= 1;\n      if(t[x << 1].first <= t[(x << 1) + 1].first)t[x] = t[x << 1];\n      else t[x] = t[(x << 1) + 1];\n    }\n    return;\n  }\n  pair<int, int> query(int l, int r, int k, int kl, int kr){\n    if(l <= t[k].second && t[k].second < r)return t[k];\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    pair<int, int> a = query(l, r, k << 1, kl, (kl + kr) >> 1);\n    pair<int, int> b = query(l, r, (k << 1) + 1, (kl + kr) >> 1, kr);\n    return (a.first < b.first) ? a : b;\n  }\n  pair<int, int> find(int l, int r){ return query(l, r, 1, 0, t[0].first); }\n  void deb(void){\n    int x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].first);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].second);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    return;\n  }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nstruct tree{\n  vector< vector<edge> > t;\n  int v;\n  void nexttree(int x){ //x-indexed\n    scanf(\"%d\", &v);  t.resize(v);\n    int from, to, cost = 1;\n    for(int i = 1;i < v;++i){\n      scanf(\"%d %d\", &from, &to);\n      t[from - x].push_back((edge){to - x, cost});\n      t[to - x].push_back((edge){from - x, cost});\n    }\n    return;\n  }\n  void nexttree2(int x){\n    scanf(\"%d\", &v); t.resize(v);\n    int k, to, cost = 1;\n    for(int i = 0;i < v;++i){\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;++j){\n        scanf(\"%d\", &to);\n        t[i - x].push_back((edge){to - x, cost});\n        t[to - x].push_back((edge){i - x, cost});\n      }\n    }\n    return;\n  }\n\n\n  rmqsegtree S;\n  vector<int> vst, dpth, id;\n  void lcarmqdfs(int now, int dep){ //575!!\n    /* ????????° */\n    vector< pair<int,int> > stk; stk.resize(v * 2);   //stack\n    int head = 0;\n    stk[head].first = now; stk[head++].second = dep;\n\n    for(;head;){\n      pair<int,int> tmp = stk[--head];\n\n      if(id[tmp.first] == -1){\n        id[tmp.first] = vst.size();\n        vst.push_back(tmp.first); dpth.push_back(tmp.second);\n      }else{\n        vst.push_back(tmp.first); dpth.push_back(tmp.second);\n        continue;\n      }\n\n      for(int i = 0;i < t[tmp.first].size();++i)if(id[t[tmp.first][i].to] == -1){\n        stk[head++] = tmp;\n        stk[head].first = t[tmp.first][i].to; stk[head++].second = tmp.second + 1;\n      }\n    }\n    stk.clear();\n    return;\n  }\n\n\n  void lcarmq(void){\n    if(vst.size() > v)return;\n    id.resize(v); for(int i = 0;i < v;++i)id[i] = -1;\n    lcarmqdfs(0, 0);\n    S.build(vst);\n    return;\n  }\n  int lca(int a, int b){\n    if(id[a] > id[b])swap(a, b);\n    return vst[S.find(id[a], id[b] + 1).second];\n  }\n  int depth(int a){ return dpth[id[a]]; }\n  int dist(int a, int b){ return depth(a) + depth(b) - 2 * depth(lca(a, b)); }\n};\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    tree T; T.nexttree2(0);\n    T.lcarmq();\n\n    int(q);\n    for(;q--;){\n      int2(a, b);\n      pri(T.lca(a, b));\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nint n;\nvector<int> vs[100005];\n\nint ans[100005];\n\nset<int> s[100005];\n\nvoid dfs(int no){\n\trep(i,vs[no].size()){\n\t\tdfs(vs[no][i]);\n\t}\n\t\n\n\trep(i,vs[no].size()){\n\t\tint to=vs[no][i];\n\t\tif(s[to].size()>s[no].size())swap(s[no],s[to]);\n\t\t\n\t\tfor(set<int>::iterator ite=s[to].begin(); ite!=s[to].end(); ite++){\n\t\t\tint p=*ite;\n\t\t\tif(s[no].count(p)>=1){\n\t\t\t\ts[no].erase(p);\n\t\t\t\tans[p]=no;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[no].insert(p);\n\t\t\t}\n\t\t}\n\t\ts[to].clear();\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\trep(j,k){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tvs[i].push_back(a);\n\t\t}\n\t}\n\t\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a==b)ans[i]=a;\n\t\telse{\n\t\t\ts[a].insert(i);\n\t\t\ts[b].insert(i);\n\t\t}\n\t}\n\t\n\tdfs(0);\n\t\n\trep(i,q){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(40) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,n,a) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,n,0)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\nconst static int MAX_V = 10000;\n\nvector<int> G[MAX_V];\nint root = 0;\n\nint vs[MAX_V * 2 - 1];\nint depth[MAX_V * 2 - 1];\nint id[MAX_V];\n\n//?????????????????????????????????????±?????????????????????°???????????¨\n//int double ??¨??????numeric???????????£?????????????????????\n//n ????´???°\n//invalid_value ???????????°???????????????a????????????marge(a,invalidvalue) = a, marge(invalid_value, a) = a?????¨??????????????????\nclass SegmentTreeInt {\npublic:\n\tSegmentTreeInt(int n, int invalid_value);\n\t~SegmentTreeInt();\n\tvoid SetElem(int k, int val);\n\tint GetCount();\n\tint quary(int a, int b);\n\tint GetElem(int k);\n\n\t//?????????????????¢??°???????????????????????????\n\t//invalid_value??????????????£?????°????????????????????????\n\tbool IsInvalidValue(int value) {\n\t\treturn value == mInvalidValue;\n\t}\n\t//a??¨b?????? a???b????±?????????¢??°???????????§?¨?????????????????????§?±???????\n\tint Marge(int a, int b) {\n\t\tif (IsInvalidValue(a))return b;\n\t\tif (IsInvalidValue(b)) return a;\n\t\tif (depth[a] >= depth[b]) return b;\n\t\treturn a;\n\t}\nprivate:\n\tvector<int>\n\t\tmTree;\n\tint mCount;\n\tint mInvalidValue;\n\tvoid Update(int k, int val);\n\tint InternalQuary(int a, int b, int k, int l, int r);\n};\n\n//?????´??????????????????(??????????????¨???????????´??????)\nSegmentTreeInt::SegmentTreeInt(int n, int invalid_value) {\n\tint bin_n = 1;\n\twhile (bin_n < n) bin_n *= 2;\n\tmTree.resize(2 * bin_n);\n\tmInvalidValue = invalid_value;\n\tmCount = bin_n;\n\tfor (int i = 0; i < 2 * bin_n - 1; i++) {\n\t\tmTree[i] = invalid_value;\n\t}\n}\nSegmentTreeInt::~SegmentTreeInt() {\n}\nvoid SegmentTreeInt::SetElem(int k, int val) { Update(k, val); }\nint SegmentTreeInt::GetElem(int k) { return mTree[mCount - 1 + k]; }\nint SegmentTreeInt::GetCount() { return mCount; }\n//????????´??°\nvoid SegmentTreeInt::Update(int k, int val) {\n\tk += mCount - 1;\n\tmTree[k] = val;\n\twhile (k > 0) {\n\t\tk = ( k - 1 ) / 2;\n\t\tmTree[k] = Marge(mTree[2 * k + 1], mTree[2 * k + 2]);\n\t}\n}\n//??????[a,b]?????????O(ln(Count))??§?±??????? b < GetCount??¨???????????¨\n//ex. a = 0 , b = 2 ?????? 0,1,2?????????\nint SegmentTreeInt::quary(int a, int b) {\n\treturn InternalQuary(a, b + 1, 0, 0, mCount);\n}\n//?????¨?????????\nint SegmentTreeInt::InternalQuary(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return mInvalidValue;\n\tif (a <= l && r <= b)return mTree[k];\n\telse {\n\t\tint vl = InternalQuary(a, b, k * 2 + 1, l, ( l + r ) / 2);\n\t\tint vr = InternalQuary(a, b, k * 2 + 2, ( l + r ) / 2, r);\n\t\treturn Marge(vl, vr);\n\t}\n}\n//???????????§?????´??????\n\nSegmentTreeInt rmq(2*MAX_V-1,INF);\n\nvoid dfs(int v, int p, int d, int &k) {\n\tid[v] = k;\n\tvs[k] = v;\n\tdepth[k++] = d;\n\trep(i, G[v].size()) {\n\t\tif (G[v][i] != p) {\n\t\t\tdfs(G[v][i], v, d + 1, k);\n\t\t\tvs[k] = v;\n\t\t\tdepth[k++] = d;\n\t\t}\n\t}\n}\n//\nvoid init(int V) {\n\tint k = 0;\n\tdfs(root,-1,0,k);\n\trep(i, V * 2) {\n\t\trmq.SetElem(i,i);\n\t}\n}\n\nint LCA(int u, int v) {\n\treturn vs[rmq.quary(min(id[u], id[v]), max(id[u], id[v])+1)];\n}\n\nint main() {\n\tint n; put n;\n\trep(i, n) {\n\t\tint k; put k;\n\t\trep(j, k) {\n\t\t\tint c; put c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tint q; put q;\n\tinit(n);\n\trep(i, q) {\n\t\tint u, v; put u >> v;\n\t\tcout << LCA(u,v) << endl;\n\t}\nEND:\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int MAX_N = 1e5;\nconst int MAX_M = (MAX_N << 1) - 1;\nconst int LSIZE = (MAX_M + 7) >> 3;\n\npii table[15][LSIZE];\npii mini[9][1 << 7];\nint buck[LSIZE];\nint off[LSIZE];\n\n\nint it = 0;\n\nint vs[MAX_M];\nint id[MAX_N];\n\nint n;\nvector<int> G[MAX_N];\n\nvoid dfs(int v) {\n\tid[v] = it;\n\tbuck[it >> 3] |= 1 << (it & 7);\n\tvs[it++] = v;\n\tfor (auto to : G[v]) {\n\t\tdfs(to);\n\t\tvs[it++] = v;\n\t}\n}\n\nvoid bitDP() {\n\tfor (int b = 0; b < 8; b++) {\n\t\tfor (int i = 0; i < (1 << b); i++) {\n\t\t\tint mi = 0, id = 0, t = 0;\n\t\t\tfor (int j = 0; j + 1 < b; j++) {\n\t\t\t\tt += (((i >> j) & 1) << 1) - 1;\n\t\t\t\tif (t < mi) {\n\t\t\t\t\tmi = t;\n\t\t\t\t\tid = j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmini[b + 1][i] = { mi, id };\n\t\t}\n\t}\n}\n\nvoid init() {\n\tbitDP();\n\tint m = (n << 1) - 1;\n\tint l = (m + 7) >> 3;\n\tdfs(0);\n\toff[0] = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tpii tmp = mini[min(m - (i << 3), 8)][buck[i] >> 1];\n\t\ttable[0][i] = { tmp.first + off[i], tmp.second + (i << 3) };\n\t\toff[i + 1] = off[i] + (__builtin_popcount(buck[i]) << 1) - 8;\n\t}\n\tint h = 31 - __builtin_clz(l);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j + (1 << i) < l; j++) {\n\t\t\ttable[i + 1][j] = min(table[i][j], table[i][j + (1 << i)]);\n\t\t}\n\t}\n}\n\npii get_buck(int l, int r) {\n\tpii tmp = mini[r - l][(buck[l >> 3] & ((1 << ((r - 1) & 7)) - 1)) >> (l & 7)];\n\treturn pii(off[l >> 3] + tmp.first, l + tmp.second + 1);\n}\n\nint lca(int u, int v) {\n\tu = id[u], v = id[v];\n\tif (u > v) swap(u, v);\n\tif ((u >> 3) == (v >> 3)) {\n\t\treturn vs[u + mini[v - u + 1][(buck[u >> 3] & ((1 << (v & 7)) - 1)) >> (u & 7)].second + 1];\n\t}\n\tv++;\n\tpii left = get_buck(u, (u + 7) & (~7));\n\tpii right = get_buck(v & (~7), v);\n\tint b = 31 - __builtin_clz(v - u);\n\treturn vs[min(min(left, right), min(table[b][u], table[b][v - (1 << b)])).second];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/GRL_5_C.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\"\n\n#line 1 \"test/aoj/../../graph/template.cpp\"\n#include <vector>\n\ntemplate< typename T >\nstruct Edge {\n  int from, to;\n  T cost;\n  Edge() {}\n  Edge(int f, int t) : from(f), to(t), cost(1) {}\n  Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n  friend bool operator < (const Edge& lhs, const Edge& rhs) { return lhs.cost < rhs.cost; };\n  friend bool operator > (const Edge& lhs, const Edge& rhs) { return rhs < lhs; };\n  friend bool operator <= (const Edge& lhs, const Edge& rhs) { return !(lhs > rhs); };\n  friend bool operator >= (const Edge& lhs, const Edge& rhs) { return !(lhs < rhs); };\n};\n\ntemplate< typename T >\nusing Edges = std::vector< Edge< T > >;\ntemplate< typename T >\nusing Graph = std::vector< Edges< T > >;\n#line 2 \"test/aoj/../../graph/lca.cpp\"\n\n#include <cassert>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct LCA {\n  using graph = Graph<T>;\n  int root;\n  // n : 頂点数\n  const int n;\n  const int log2_n;\n  graph g;\n  vector<vector<int>> parent;\n  vector<int> depth;\n\n  LCA(int root, const graph &g) : root(root), n(g.size()), log2_n(log2(n)+1), g(g), parent(log2_n, vector<int>(n)), depth(n) {\n    dfs(g, root, root, 1);\n    for (int k = 0; k+1 < log2_n; ++k) {\n      parent.push_back(vector<int>(n, root)); // 要素数n, 値rootで初期化\n      for (int v = n-1; v >= 0; --v) {\n        int par = parent[k][v];\n        parent[k+1][v] = parent[k][par];\n      }\n    }\n  }\n  \n  /** \n   * par : 親のid\n   * d : 木の深さ (1から始める)\n   */ \n  void dfs(const graph& g, int from, int par, int d) {\n    parent[0][from] = par;\n    depth[from] = d;\n    for (auto &e: g[from]) {\n      if (depth[e.to] > 0) continue;\n      dfs(g, e.to, from, d+1);\n    }\n  }\n\n  int get(int v1, int v2) {\n    // 深さが同じになるまで片方を登らせる\n    if (depth[v1] < depth[v2]) swap(v1, v2);\n    for (int k = 0; k < log2_n; ++k) {\n      if ((depth[v1]-depth[v2]) >> k & 1) {\n        v1 = parent[k][v1];\n      }\n    }\n    if (v1 == v2) return v1;\n\n    // 親が同じになる直前まで登らせる\n    for (int k = log2_n-1; k >= 0; --k) {\n      int p_v1 = parent[k][v1];\n      int p_v2 = parent[k][v2];\n      if (p_v1 == p_v2) continue;\n      v1 = p_v1;\n      v2 = p_v2;\n    }\n    assert(parent[0][v1] == parent[0][v2]);\n    return parent[0][v1];\n  }\n};\n#line 4 \"test/aoj/GRL_5_C.test.cpp\"\n#include <iostream>\nusing namespace std;\n\nint main() {\n  int n; cin >> n;\n  Graph<int> graph(n);\n  for (int i = 0; i < n; ++i) {\n    int k; cin >> k;\n    for (int j = 0; j < k; ++j) {\n      int c; cin >> c;\n      graph[i].emplace_back(i, c);\n    }\n  }\n  LCA<int> lca(0, graph);\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; ++i) { \n    int u, v;\n    cin >> u >> v;\n    cout << lca.get(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\n#define NMAX 100000\n\nstruct edge {\n  int to, next;\n};\n\nstruct UnionFind {\n  vector<int> a;\n  UnionFind(int n) : a(n) { iota(a.begin(), a.end(), 0); }\n  int Find(int x) {\n    if (x == a[x])\n      return x;\n    auto y = Find(a[x]);\n    a[x] = y;\n    return y;\n  }\n  // special union: also sets the representative to the second argument\n  void Union(int x, int new_rep) {\n    int repx = Find(x);\n    int repy = Find(new_rep);\n    a[repx] = new_rep;\n    a[repy] = new_rep;\n    a[new_rep] = new_rep;\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> LE(n, -1), parent(n, -1);\n  vector<edge> E(n);\n  for (int i = 0, m = 0; i < n; ++i) { // n nodes\n    int nch;\n    cin >> nch;\n    for (int j = 0, ch; j < nch; ++j) {\n      cin >> ch;\n      E[m] = {ch, LE[i]};\n      LE[i] = m++;\n      parent[ch] = i;\n    }\n  }\n\n  {\n    int q;\n    cin >> q;\n  }\n\n  struct query {\n    int src, dst, res;\n  };\n  vector<query> queries;\n\n  struct query_ref {\n    int other, idx;\n  };\n  vector<vector<query_ref>> match(n);\n  vector<int> visited(n);\n\n  for (int i = 0, u, v; cin >> u >> v; ++i) {\n    queries.push_back({u, v, -1});\n    match[u].push_back({v, i});\n    match[v].push_back({u, i});\n  }\n\n  // the representative of the set associated with each node `u`\n  // is the active node of greatest depth that is an ancestor of `u`\n  UnionFind uf(n);\n\n  stack<int> s;\n  s.push(0);\n  while (!s.empty()) {\n    int u = s.top();\n    s.pop();\n    if (!visited[u]) {\n      visited[u] = 1;\n      s.push(u);\n      for (query_ref &qr : match[u]) {\n        if (visited[qr.other]) {\n          queries[qr.idx].res = uf.Find(qr.other);\n        }\n      }\n      for (int j = LE[u]; j != -1; j = E[j].next) {\n        s.push(E[j].to);\n      }\n    } else { // visited\n      if (parent[u] >= 0)\n        uf.Union(u, parent[u]);\n    }\n  }\n\n  for (query &quer : queries)\n    cout << quer.res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 30\nusing namespace std;\nint n,k,c,depth[N],parent[N][M];\nvector<int> e[N];\n\nvoid dfs(int x,int d){\n  depth[x]=d;\n  for(int i=0;i<(int)e[x].size();i++)\n    dfs(e[x][i],d+1);\n}\n\nint lca(int u,int v){\n  if(depth[u]<depth[v])swap(u,v);\n  int K=depth[u]-depth[v];\n  for(int i=0;i<M;i++)\n    if(K>>i&1)u=parent[u][i];\n  if(u==v)return u;\n  for(int j=M-1;j>=0;j--){\n    if(parent[u][j]==parent[v][j])continue;\n    u=parent[u][j];\n    v=parent[v][j];\n  }\n  return parent[u][0];\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&k);\n    for(int j=0;j<k;j++){\n      scanf(\"%d\",&c);\n      e[i].push_back(c);\n      parent[c][0]=i;\n    }\n  }\n  for(int j=1;j<M;j++)\n    for(int i=0;i<n;i++)\n      parent[i][j]=parent[parent[i][j-1]][j-1];\n  dfs(0,0);\n  int q,u,v;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    scanf(\"%d%d\",&u,&v);\n    printf(\"%d\\n\",lca(u,v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nclass TreeClass {// グラフ入力を受け取る\npublic:\n\tTreeClass() {\n\t\tN = 0, root = 0;\n\t\tnext = NULL;\n\t\tweight = NULL;\n\t\tparent = NULL;\n\t}\n\t~TreeClass() {\n\t\tif (weight != NULL) { delete[] weight; }\n\t\tif (next != NULL) { delete[] next; }\n\t\tif (parent != NULL) { delete[] parent; }\n\t}\n\n\tvoid activate(int n, int _root = 0) {// 頂点数nのグラフを初期化する。\n\t\tN = n;\n\t\troot = _root;\n\n\t\tif (weight != NULL) { delete[] weight; }\n\t\tif (next != NULL) { delete[] next; }\n\t\tedge.clear();\n\n\t\tdepth.clear();\n\t\tif (parent != NULL) { delete[] parent; }\n\t\tdistanceTable.clear();\n\n\t\tweight = new ll[N];\n\t\tfor (int i = 0; i < N; i++) { weight[i] = 1; }\n\t\tnext = new unordered_map<int, int>[N];\n\n\t\tdepth.resize(N);\n\t\tparent = new vector<int>[N];\n\t\tfor (int i = 0; i < N; i++) { parent[i].clear(); }\n\t\tdistanceTable.resize(N);\n\t}\n\tinline void setNodeWeight(int n, ll weight) {// n番のノードの重みをweightに設定\n\t\tthis->weight[n] = weight;\n\t}\n\n\tinline int getEdgeIndex(int x, int y) {// 辺の組からエッジの番号を得る\n\t\tif (next[x].find(y) != next[x].end()) {\n\t\t\treturn next[x][y];\n\t\t}\n\t\treturn -1;\n\t}\n\tinline void addEdge(int x, int y, ll _weight = 1) {// エッジ追加\n\t\tint M = (int)edge.size();\n\t\tedge.push_back({ {x,y}, _weight });\n\n\t\tnext[x].insert({ y, M });\n\t\tnext[y].insert({ x, M });\n\n\t\tif (edge.size() == N - 1) {\n\t\t\t{// bfsで根からの深さと距離を得る\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tdepth[i] = -1;\n\t\t\t\t}\n\n\t\t\t\tqueue<pair<int, pair<int, ll>>> q; q.push({ root, {0, 0} });\n\n\t\t\t\twhile (q.size() > 0) {\n\t\t\t\t\tint n = q.front().first;\n\t\t\t\t\tint d = q.front().second.first;\n\t\t\t\t\tll w = q.front().second.second;\n\t\t\t\t\tq.pop();\n\n\t\t\t\t\tdepth[n] = d;\n\t\t\t\t\tweight[n] = w;\n\n\t\t\t\t\tfor (auto itr = next[n].begin(); itr != next[n].end(); itr++) {\n\t\t\t\t\t\tint m = itr->first;\n\n\t\t\t\t\t\tif (depth[m] == -1) {\n\t\t\t\t\t\t\tparent[m].push_back(n);\n\t\t\t\t\t\t\tq.push({ m, {d + 1, w + edge[itr->second].second} });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{// ダブリング\n\t\t\t\tqueue<int> q;\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tif (i == root) { continue; }\n\t\t\t\t\tq.push(i);\n\t\t\t\t}\n\t\t\t\twhile (q.size() > 0) {\n\t\t\t\t\tint n = q.front();\n\t\t\t\t\tq.pop();\n\n\t\t\t\t\tint k = parent[n].size() - 1;\n\t\t\t\t\tif (depth[n] >= (1 << (k + 1))) {\n\t\t\t\t\t\tparent[n].push_back(parent[parent[n][k]][k]);\n\t\t\t\t\t\tq.push(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int LCA(int a, int b) {\n\t\tint d = min(depth[a], depth[b]);\n\n\t\tif (depth[a] > d) {\n\t\t\tint k = depth[a] - d;\n\t\t\tfor (int i = 0; k > 0; i++) {\n\t\t\t\tif ((1 << i) & k) {\n\t\t\t\t\tk -= (1 << i);\n\t\t\t\t\ta = parent[a][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (depth[b] > d) {\n\t\t\tint k = depth[b] - d;\n\t\t\tfor (int i = 0; k > 0; i++) {\n\t\t\t\tif ((1 << i) & k) {\n\t\t\t\t\tk -= (1 << i);\n\t\t\t\t\tb = parent[b][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (a == b) { return a; }\n\n\t\tfor (int k = parent[a].size() - 1; k >= 0; k--) {\n\t\t\tif (k < parent[a].size() && k < parent[b].size() && (parent[a][k] != parent[b][k])) {\n\t\t\t\ta = parent[a][k];\n\t\t\t\tb = parent[b][k];\n\t\t\t}\n\t\t}\n\t\treturn parent[a][0];\n\t}\n\n\tint N, root;\n\tll* weight;// ノードの重み\n\tunordered_map<int, int>* next;// 各ノードからの行き先とエッジ番号\n\tvector<pair<pair<int, int>, ll>> edge;// エッジ(頂点ペアと重み)\n\n\tvector<int> depth;// 根から見た深さ\n\tvector<int>* parent;//1番目、2番目、4番目、8番目...の親\n\tvector<ll> distanceTable;// 根からの距離\n};\n\nvoid bfs(TreeClass &T) {// 幅優先探索\n\tint N = T.N;\n\tbool* visited = new bool[N];\n\tfor (int i = 0; i < N; i++) {\n\t\tvisited[i] = (i == T.root);\n\t}\n\n\tqueue<int> q; q.push(T.root);\n\n\twhile (q.size() > 0) {\n\t\tint n = q.front(); q.pop();\n\t\tvisited[n] = true;\n\n\t\t// ここに各ノードで行う処理を書く\n\n\t\tfor (auto itr = T.next[n].begin(); itr != T.next[n].end(); itr++) {\n\t\t\tif (visited[itr->first] == false) {// まだ訪れていなかったら\n\n\t\t\t\t// ここに各エッジで行う処理を書く\n\n\t\t\t\tq.push(itr->first);\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete[] visited;\n}\n\nbool* dfs_visited = NULL;\nvoid dfs_process_main(TreeClass &T, int n, int depth) {// 深さ優先探索\n\n\t// ここに各ノードで行う処理を書く\n\n\tfor (auto itr = T.next[n].begin(); itr != T.next[n].end(); itr++) {\n\t\tint m = itr->first;\n\n\t\tif (dfs_visited[m] == false) {// まだ訪れていなかったら\n\n\t\t\t// ここに各エッジで行う処理を書く\n\n\t\t\tdfs_visited[m] = true;\n\t\t\tdfs_process_main(T, m, depth + 1);\n\t\t\tdfs_visited[m] = false;\n\t\t}\n\t}\n}\nvoid dfs(TreeClass &T) {// 深さ優先探索\n\tint N = T.N;\n\tdfs_visited = new bool[N];\n\tfor (int i = 0; i < N; i++) { dfs_visited[i] = false; }\n\n\tdfs_visited[T.root] = true;\n\tdfs_process_main(T, T.root, 0);\n\n\tdelete[] dfs_visited;\n\tdfs_visited = NULL;\n}\n\nint main() {\n\tint N; cin >> N;\n\tTreeClass T;\n\tT.activate(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint a; cin >> a;\n\t\t\tT.addEdge(i, a);\n\t\t}\n\t}\n\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tint c = T.LCA(a, b);\n\n\t\tcout << c << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <utility>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void init(int root) {\n    stack<pair<int, int>> s;\n    s.push(make_pair(root, -1));\n    while(!s.empty()) {\n      auto cur = s.top(); s.pop();\n      if(cur.second < 0) depth[cur.first] = 0;\n      else depth[cur.first] = depth[cur.second] + 1;\n\n      parent[0][cur.first] = cur.second;\n      for(int next : G[cur.first]) {\n        if(next != cur.second) {\n          s.push(make_pair(next, cur.first));\n        }\n      }\n    }\n\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] < 0) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//const ull mod = 1e9 + 7;\nconst ll mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\ntemplate< typename G >\nstruct DoublingLowestCommonAncestor {\n  const G &g;\n  vector< int > dep;\n  const int LOG;\n  vector< vector< int > > table;\n\n  DoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size())) {\n    table.assign(LOG, vector< int >(g.size(), -1));\n  }\n\n  void dfs(int idx, int par, int d) {\n    table[0][idx] = par;\n    dep[idx] = d;\n    for(auto &to : g[idx]) {\n      if(to != par) dfs(to, idx, d + 1);\n    }\n  }\n\n  void build() {\n    dfs(0, -1, 0);\n    for(int k = 0; k + 1 < LOG; k++) {\n      for(int i = 0; i < (int)table[k].size(); i++) {\n        if(table[k][i] == -1) table[k + 1][i] = -1;\n        else table[k + 1][i] = table[k][table[k][i]];\n      }\n    }\n  }\n\n  int query(int u, int v) {\n    if(dep[u] > dep[v]) swap(u, v);\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(((dep[v] - dep[u]) >> i) & 1) v = table[i][v];\n    }\n    if(u == v) return u;\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(table[i][u] != table[i][v]) {\n        u = table[i][u];\n        v = table[i][v];\n      }\n    }\n    return table[0][u];\n  }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    vector<vector<ll>> G(n);\n    REP(i, n){\n    \tll k;\n    \tcin >> k;\n    \tREP(j, k){\n    \t\tll c;\n    \t\tcin >> c;\n    \t\tG[i].push_back(c);\n    \t\tG[c].push_back(i);\n    \t}\n    }\n\n    DoublingLowestCommonAncestor<vector<vector<ll>>> lca(G);\n    lca.build();\n    ll Q;\n    cin >> Q;\n    while(Q--){\n    \tll x, y;\n    \tcin >> x >> y;\n    \tcout << lca.query(x, y) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nclass TreeSqrtDecomp {\n    int n, B;\n    int size() const { return n; }\n    // block_id[v]: vが属するblock\n    vi block_id, parent, depth, roots, visited;\n    vvi adj;\npublic:\n    vector<set<int>> block_nodes;\n    TreeSqrtDecomp(int n_) : n(n_), adj(n) {\n        int l = 0, r = n;\n        while (l < r - 1) {\n            i64 m = (l + r) / 2;\n            if (m * m >= n) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        B = r;\n    }\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    void decomp(int root = 0) {\n        block_id.assign(n, -1);\n        parent.assign(n, -1);\n        depth.assign(n, 0);\n        visited.assign(n, 0);\n        vi q(n + 1);\n        int l = 0, r = 0;\n        q[r++] = root;\n        while (l != r) {\n            int v = q[l++];\n            visited[v] = 1;\n            roots.push_back(v);\n            for (int c : adj[v]) {\n                if (!visited[c]) {\n                    parent[c] = v;\n                    depth[c] = depth[v] + 1;\n                    q[r++] = c;\n                }\n            }\n        }\n        int c = 0;\n        for (int u : roots) {\n            if (block_id[u] != -1) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for (int i = 0; i < B && l != r; i++) {\n                int v = q[l++];\n                block_id[v] = c;\n                for (int c : adj[v]) {\n                    if (block_id[c] == -1) {\n                        q[r++] = c;\n                    }\n                }\n            }\n            c++;\n        }\n        block_nodes = vector<set<int>>(c);\n        for (int i = 0; i < n; i++) {\n            block_nodes[block_id[i]].insert(i);\n        }\n    }\n    int get_block_root_by_id(int block_id) {\n        return roots[block_id];\n    }\n    int get_block_root(int node) {\n        return get_block_root_by_id(get_block_id(node));\n    }\n    int lca(int u, int v) {\n        while (depth[get_block_root(u)] > depth[get_block_root(v)]) u = parent[get_block_root(u)];\n        while (depth[get_block_root(u)] < depth[get_block_root(v)]) v = parent[get_block_root(v)];\n        while (depth[u] > depth[v]) u = parent[u];\n        while (depth[u] < depth[v]) v = parent[v];\n        while (u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n    int block_cnt() {\n        return roots.size();\n    }\n    int dist(int u, int v) {\n        int w = lca(u, v);\n        return depth[u] - depth[w] + depth[v] - depth[w];\n    }\n    bool in_same_block(int u, int v) {\n        return get_block_root(u) == get_block_root(v);\n    }\n    int get_block_id(int node) {\n        return block_id[node];\n    }\n    int get_parent(int node) {\n        return parent[node];\n    }\n    int get_depth(int node) {\n        return depth[node];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    TreeSqrtDecomp tree(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a;\n            cin >> a;\n            tree.addEdge(i, a);\n        }\n    }\n    tree.decomp();\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 310;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\nconst int logn=20;\n\nint n,q,l,sec,st[maxn],ed[maxn];\nint up[maxn][logn];\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n\tst[u]=sec++;\n\tup[u][0]=p;\n\tfor (int i=1;i<=l;i++)\n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\tfor (int v:G[u])\n\t\tif (v!=p) dfs(v,u);\n\ted[u]=sec;\n}\n\nbool upper(int u,int v) {\n\treturn st[u]<st[v] && ed[u]>=ed[v];\n}\n\nint lca(int u,int v) {\n\tif (u==v) return u;\n\tif (upper(u,v)) return u;\n\tif (upper(v,u)) return v;\n\tfor (int i=l;i>=0;i--) \n\t\tif (!upper(up[u][i],v))\n\t\t\tu=up[u][i];\n\treturn up[u][0];\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i=0;i<n;i++) {\n\t\tint m; cin>>m;\n\t\tfor (int j=0;j<m;j++) {\n\t\t\tint v; cin>>v;\n\t\t\tG[i].pb(v);\n\t\t}\n\t}\n\twhile ((1<<l)<=n) l++;\n\tdfs(0,0);\n\tcin>>q;\n\tfor (int i=0;i<q;i++) {\n\t\tint u,v; cin>>u>>v;\n\t\tcout<<lca(u,v)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconst int MAX_N = 100001;\n\n\n\nint D[MAX_N];// (HL分解後にあるnodeとあるnodeが同じHeavyPathに含まれているかどうか)\nint find(int a){return a-D[a]?(D[a]=find(D[a])):a; }\n  \nstruct node{\n  int id;\n  vector<int> to;\n  int h;//深さ\n  node(){ h = -1; }\n  bool operator<(const node& n) const{\n    return h < n.h;\n  }\n};\n  \nstruct HL_node{\n  int h;\n  vector<int> v;//sortされる\n  int np;//Light-edgeで結ばれた親\n};\n  \nbool used[MAX_N];\nint vid[MAX_N];\nnode G[MAX_N];//子への辺をもつ\nHL_node HL[MAX_N];\nint V;//頂点数\n\n  \nint dfs(int id,int h){\n  if( G[id].h>-1 ) return 0;\n  G[id].h = h;\n  vector<int> cs; int sum =1;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    cs.push_back(dfs(G[id].to[i],h+1)); sum+=cs.back();\n  }\n  if( sum == 1 ) return sum;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    if( sum/2 <= cs[i] ){\n      D[G[id].to[i]] = find(id);break;    \n    }\n  }\n  return sum;\n}\n\nvoid HeavyLightDecomposition(int root){\n  for(int i=0;i<V;i++) D[i] = i;\n  memset(used,0,sizeof(used));\n  dfs(root,0);\n  sort(G,G+V);\n  vector<int> vs;//after_hl\n  for(int i=0;i<V;i++) vid[G[i].id] = i;\n  for(int i=0;i<V;i++){\n    int now = G[i].id;\n    used[now] = true;\n    HL[find(now)].v.push_back(now);\n    for(int j=0;j<(int)G[vid[now]].to.size();j++){\n      int to = G[vid[now]].to[j];\n      if( used[to] ) continue;\n      if( find(to) == find(now) ) continue;\n      HL[find(to)].np = now;\n      HL[find(to)].h = HL[find(now)].h+1;\n    }  \n  }\n\n}\n  \nint HeavyLightLCA(int a, int b){\n  for(; HL[find(a)].h != HL[find(b)].h ; HL[find(a)].h>HL[find(b)].h?(a=HL[find(a)].np):(b=HL[find(b)].np) );\n  for(; find(a) != find(b) ; a = HL[find(a)].np, b = HL[find(b)].np );\n  return vid[a]<vid[b]?a:b;\n}\n\nint main(){\n  cin >> V;\n  for(int i=0;i<V;i++){\n    G[i].id = i;\n    int k; cin >> k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin >> c;\n      G[i].to.push_back( c );\n    }\n  }\n  HeavyLightDecomposition(0);\n  int Q;\n  cin >> Q;\n  for(int i=0;i<Q;i++){ \n    int u,v; cin >> u>> v;\n    cout << HeavyLightLCA(u,v) << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct Edge {\n\tint to;\n\t// int64_t dist{1};\n\n\t// int64_t cost;\n\t// int from;\n\t// int rev_i;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここからコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// コンストラクタに渡すのは子に向かう有向グラフでも無向グラフでもいい\nclass LCA {\nprivate:\n\tusing ve = std::vector<Edge>;\n\tusing vve = std::vector<ve>;\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\n\tconst vve& edges_;\n\tvvi ancestors_;\n\tvi depthList_;\n\tconst int root_;\n\n\tvoid dfs(const int index, const int parent, const int depth)\n\t{\n\t\tancestors_[index].front() = parent;\n\t\tdepthList_[index] = depth;\n\t\tfor (auto& e: edges_[index])\n\t\t\tif (e.to != parent)\n\t\t\t\tdfs(e.to, index, depth + 1);\n\t}\n\t\npublic:\n\tconst vi& depthList;\n\n\tLCA(const vve& adjacentList, const int root)\n\t\t: edges_(adjacentList), root_(root), depthList(depthList_)\n\t{\n\t\tint size{1};\n\t\twhile (1 << (size - 1) <= (int)edges_.size()) size++;\n\t\tancestors_.resize(edges_.size(), vi(size));\n\t\tdepthList_.resize(edges_.size());\n\t\tdfs(root_, root_, 0);\n\t\tfor (int i{1}; i < size; i++)\n\t\t\tfor (auto& e: ancestors_)\n\t\t\t\te[i] = ancestors_[e[i - 1]][i - 1];\n\t}\n\n\tint calcAncestor(const int from, const int distance)\n\t{\n\t\tint ret{from};\n\t\tfor (int digit{}, rest{distance}; rest > 0; rest >>= 1, digit++)\n\t\t\tif (rest & 1)\n\t\t\t\tret = ancestors_[ret][digit];\n\t\treturn ret;\n\t}\n\n\tint calcLCA(int index0, int index1)\n\t{\n\t\tif (depthList_[index0] > depthList_[index1])\n\t\t\tindex0 = calcAncestor(index0, depthList_[index0] - depthList_[index1]);\n\t\telse\n\t\t\tindex1 = calcAncestor(index1, depthList_[index1] - depthList_[index0]);\n\t\tif (index0 == index1) return index0;\n\t\t\n\t\tfor (int digit{(int)ancestors_.front().size() - 1}; digit >= 0; digit--)\n\t\t\tif (ancestors_[index0][digit] != ancestors_[index1][digit])\n\t\t\t{\n\t\t\t\tindex0 = ancestors_[index0][digit];\n\t\t\t\tindex1 = ancestors_[index1][digit];\n\t\t\t}\n\t\treturn ancestors_[index0][0];\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここまでコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tusing ve = std::vector<Edge>;\n\tusing vve = std::vector<ve>;\n\tvve graph(n);\n\tfor (auto& e: graph)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\te.resize(k);\n\t\tfor (auto& f: e)\n\t\t\tscanf(\"%d\", &f.to);\n\t}\n\tLCA lca(graph, 0);\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i{}; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tprintf(\"%d\\n\", lca.calcLCA(u, v));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<typename T> class Monoid{\npublic:\n\tvirtual inline T e()=0,c(T,T)=0;\n};\n\ntemplate<typename T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;Monoid<T>& m;\n\tSegmentTree(int n,Monoid<T>& m):size(n),n2(upper_pow2(size)),m(m){\n\t\tdat=vector<T>(n2*2,m.e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return m.e();//out of range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\nclass MiniMonoid:public Monoid<int>{\npublic:\n\tvector<int>& vs;\n\tMiniMonoid(vector<int>& vs):vs(vs){};\n\tinline int e(){return -1;}\n\tinline int c(int a,int b){\n\t\tif(b==-1)return a;if(a==-1)return b;\n\t\treturn min(vs[a],vs[b])==vs[a]?a:b;// left most\n\t}\n};\ntemplate<typename T> class SegmentTreei{\npublic:\n\tvector<T> vs;MiniMonoid mm;SegmentTree<T> seg;\n\tSegmentTreei(int n):vs(n),mm(vs),seg(n,mm){}\n\tvoid set(int v,T a){ vs[v]=a;seg.set(v,v);}\n};\n\ntypedef vector<vector<int>> Graph;\nclass EularTourLCA{\n\tpublic:\n\tGraph& g;int r;\n\tvector<int> id,depth,vs;\n\tSegmentTreei<int> rmq;\n\tEularTourLCA(Graph & g,int r):g(g),r(r),rmq(SegmentTreei<int>(2*g.size()-1)){\n\t\tid=vector<int>(g.size());\n\t\tdepth=vector<int>(2*g.size()-1);\n\t\tvs=vector<int>(2*g.size()-1);\n\t\tint k=0;dfs(-1,r,0,k);\n\t\tREP(i,vs.size())rmq.set(i,depth[i]);\n\t};\n\tvoid dfs(int p,int s,int d,int& k){\n\t\tid[s]=k;vs[k]=s;depth[k++]=d;\n\t\tfor(int t:g[s])if(t!=p){\n\t\t\tdfs(s,t,d+1,k);\n\t\t\tvs[k]=s;\n\t\t\tdepth[k++]=d;\n\t\t}\n\t}\n\tint lca(int u,int v){ return vs[rmq.seg.query(min(id[u],id[v]),max(id[u],id[v])+1)];}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t); g[t].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tEularTourLCA lca(g,0);\n\t\tint q;cin >>q;\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tcout << lca.lca(u,v) <<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = (1 << 17);\nconst int INF = 2147483647;\n\nint n;\nP v[2 * MAX_N - 1];\n\nvoid init(int _n){\n  n = 1;\n  while(n < _n) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(INF, INF);\n}\n\nvoid update(int k, P a){\n  k += n - 1;\n  v[k] = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = v[k * 2 + 1].first < v[k * 2 + 2].first ? v[k * 2 + 1] : v[k * 2 + 2];\n  }\n}\n\nP query(int a, int b, int k, int l, int r){\n  if(b <= l || a >= r) return P(INF, INF);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return min(vl, vr);\n}\n\nint id[MAX_N], vs[MAX_N * 2 - 1];\n\nvoid dfs(int v, int prev, int d, int &k, vector< vector<int> > &G, int *id, int *vs, int *depth){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  REP(i, G[v].size()){\n    if(G[v][i] != prev){\n      dfs(G[v][i], v, d + 1, k, G, id, vs, depth);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid lca_init(int N, int root, vector< vector<int> > &G){\n  int k = 0, depth[MAX_N * 2 - 1];\n  dfs(root, -1, 0, k, G, id, vs, depth);\n  init(N * 2 - 1);\n  REP(i, N * 2 - 1) update(i, P(depth[i], vs[i]));\n}\n\nint lca(int a, int b){\n  return query(min(id[a], id[b]), max(id[a], id[b]) + 1, 0, 0, n).second;\n}\n\nint main() {\n  int N; cin >>N;\n  vector< vector<int> > G(N);\n  REP(i, N){\n    int k; cin >>k;\n    REP(j, k){\n      int c; cin >>c;\n      G[i].push_back(c);\n    }\n  }\n  lca_init(N, 0, G);\n  int Q; cin >>Q;\n  REP(q, Q){\n    int a, b; cin >>a >>b;\n    cout <<lca(a, b) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nclass LowestCommonAncestor\n{\npublic:\n    const int N;\n    vector<vector<int>> G;\n    vector<int> parent,depth;\n    const int LOG;\n    vector<vector<int>> dp;\n\n    LowestCommonAncestor(vector<vector<int>> G):N(G.size()),G(G),parent(N),depth(N),LOG(32-__builtin_clz(N))\n    {\n        dfs(0,-1,0);\n        dp.assign(LOG,vector<int>(N,-1));\n        for(int i=0;i<N;i++) dp[0][i]=parent[i];\n        for(int i=0;i+1<LOG;i++){\n            for(int j=0;j<N;j++){\n                if(dp[i][j]==-1) dp[i+1][j]=-1;\n                else dp[i+1][j]=dp[i][dp[i][j]];\n            }\n        }\n    }\n    void dfs(int v,int p,int d)\n    {\n        parent[v]=p;\n        depth[v]=d;\n        for(int u:G[v]) if(u!=p){\n            dfs(u,v,d+1);\n        }\n    }\n    int query(int u,int v)\n    {\n        if(depth[u]>depth[v]) swap(u,v);\n        for(int i=0;i<LOG;i++){\n            if((depth[v]-depth[u])>>i&1) v=dp[i][v]; \n        }\n        if(u==v) return u;\n        for(int i=LOG-1;i>=0;i--){\n            if(dp[i][u]!=dp[i][v]){\n                u=dp[i][u];\n                v=dp[i][v];\n            }\n        }\n        return dp[0][u];\n    }\n};\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N; cin>>N;\n    vector<vector<int>> G(N);\n    for(int i=0;i<N;i++){\n        int k; cin>>k;\n        while(k--){\n            int j; cin>>j;\n            G[i].push_back(j);\n            G[j].push_back(i);\n        }\n    }\n    LowestCommonAncestor lca(G);\n    int Q; cin>>Q;\n    while(Q--){\n        int u,v; cin>>u>>v;\n        cout<<lca.query(u,v)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100001];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nint sub(int idx)\n{\n  sz[idx] = query[idx].size();\n  for(auto &to : g[idx]) sz[idx] += sub(to);\n  return (sz[idx]);\n}\n\nvoid dfs(int idx, bool keep)\n{\n  if(g[idx].empty()) {\n    if(keep) for(int &v : query[idx]) buf[v] = true;\n    return;\n  }\n\n  int heavy = g[idx][0];\n  for(auto &to : g[idx]) if(sz[to] > sz[heavy]) heavy = to;\n  if(sz[heavy] <= query[idx].size()) heavy = idx;\n  for(auto &to : g[idx]) if(heavy != to) dfs(to, false);\n\n  if(idx != heavy) {\n    dfs(heavy, true);\n    query[idx].swap(query[heavy]);\n  } else {\n    for(int &v : query[idx]) buf[v] = true;\n  }\n\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(buf[v]) lca[v] = idx;\n    }\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      buf[v] = true;\n      query[idx].push_back(v);\n    }\n  }\n\n  if(!keep) {\n    for(auto &v : query[idx]) buf[v] = false;\n  }\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n\n  memset(lca, -1, sizeof(lca));\n\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n\n  sub(0);\n  dfs(0, false);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define dhoom ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);  \ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll inf = 99999999999;\nconst int nax = 1e5 + 7;\nint n , q;\nvector< int > graph[nax];\nint l , timer;\nvector< int > tin(nax), tout(nax);\nvector<vector<int > >up(nax,vector< int > (30));\nbool is_ancestor(int u , int v){\n\treturn (tin[u] <= tin[v] && tout[u] >= tout[v]);\n}\nint lca(int u , int v){\n\tif(is_ancestor( u , v))\n\t\treturn u;\n\tif(is_ancestor( v, u))\n\t\treturn v;\n\tfor(int i = l ; i >= 0 ; i--){\n\t\tif(!is_ancestor(up[u][i] , v))\n\t\t\tu = up[u][i];\n\t}\n\treturn up[u][0];\n}\nvoid dfs(int u , int p){\n\ttin[u] = timer++;\n\tup[u][0] = p;\n\tfor(int i = 1 ; i <= l ; i++)\n\t\tup[u][i] = up[up[u][i-1]][i-1];\n\tfor(auto v : graph[u])\n\t{\n\t\tdfs(v , u);\n\t}\n\ttout[u] = timer++;\n}\nint main(){\n\tdhoom;\n\tcin >> n ;\n\tl = ceill(log2(n));\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint k;\n\t\tcin >> k;\n\t\t//cout << \"hey\" << endl;\n\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\tint r;\n\t\t\tcin >> r;\n\t\t\tgraph[i].push_back(r);\n\t\t}\n\t}\n\tdfs(0,0);\n\tcin >> q;\n\t//up.assign(n + 1 , vector< int > (l+1));\n//\tcout <<\"hey\" << endl;\n\twhile(q--){\n\t\tint u , v;\n\t\tcin >> u >> v;\n\t\tcout << lca(u , v) << endl;\n\t}\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathRoot;\n  vector<vector<int> >  tree;\n  \n  HeavyLight(vector<vector<int> >tree)\n    :n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathRoot(n),tree(tree){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    /*\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt;//, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n\nint n;\n\nint ps[100005];\nvector<int> vs[100005];\nint dep[100005];\n\nint dub[100005][30];\n\nvoid init(){\n\trep(i,n)dub[i][0]=ps[i];\n\t\n\trep(j,29){\n\t\trep(i,n){\n\t\t\tdub[i][j+1]=dub[dub[i][j]][j];\n\t\t}\n\t}\n}\n\nvoid dfs(int no,int d){\n\t//printf(\"dfs %d %d\\n\",no,d);\n\tdep[no]=d;\n\trep(i,vs[no].size()){\n\t\tdfs(vs[no][i],d+1);\n\t}\n}\n\nint lca(int p,int q){\n\tif(dep[p]<dep[q])swap(p,q);\n\tint d=dep[p]-dep[q];\n\trep(i,30){\n\t\tif(d&(1<<i)){\n\t\t\tp = dub[p][i];\n\t\t\td -= (1<<i);\n\t\t}\n\t}\n\t\n\t//printf(\"lca %d %d %d %d\\n\",p,q,dep[p],dep[q]);\n\tif(p==q)return p;\n\t\n\tirep(i,30){\n\t\tif(dub[p][i]!=dub[q][i]){\n\t\t\tp = dub[p][i]; \n\t\t\tq = dub[q][i];\n\t\t}\n\t}\n\t\n\treturn dub[p][0];\t\n}\n\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\trep(j,k){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tps[a]=i;\n\t\t\tvs[i].push_back(a);\n\t\t}\n\t}\n\tps[0]=0;\n\tinit();\n\tdfs(0,0);\n\t\n\t\n\t\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\t\n\t\tprintf(\"%d\\n\",lca(a,b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n  int ParIdx, ParDepth, Deep; // Deep: HeavyEdge?????§?????±???\n  int Size;\n};\ntypedef vector< vector< int > > Graph;\n\nint N, Q;\nGraph graph;\nint treesz[100000], sz;\nNode nodes[100000];\nvector< int > Nodes[100000];\nint nowtreeIdx[100000], nowtreeDepth[100000]; \n\nint sizeDFS(int idx, int prev) {\n  treesz[idx] = 1;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) treesz[idx] += sizeDFS(graph[idx][i], idx);\n  }\n  return(treesz[idx]);\n}\nvoid makeDFS(int idx, int prev, int treeIdx, int treeDepth, int ParDepth) {\n  nodes[treeIdx].Size++;\n  Nodes[treeIdx].push_back(idx);\n  nowtreeIdx[idx] = treeIdx;\n  nowtreeDepth[idx] = treeDepth;\n  int ret = 0;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) ret = max(ret, treesz[graph[idx][i]]);\n  }\n  bool done = false;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) {\n      if(!done && treesz[graph[idx][i]] == ret && !done++) {\n        makeDFS(graph[idx][i], idx, treeIdx, treeDepth + 1, ParDepth);\n      } else {\n        nodes[sz++] = (Node){ treeIdx, treeDepth, ParDepth + 1, 0};\n        makeDFS(graph[idx][i], idx, sz - 1, 0, ParDepth + 1);\n      }\n    }\n  }\n}\nvoid HL() { // ??????????§£\n  sizeDFS(0, -1);\n  sz = 0;\n  nodes[sz++] = (Node){ -1, -1, 0, 0};\n  makeDFS(0, -1, 0, 0, 0);\n}\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  graph.resize(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      graph[i].push_back(c);\n    }\n  }\n  HL();\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n\n    int TreeIdxA = nowtreeIdx[u], TreeDepthA = nowtreeDepth[u];\n    int TreeIdxB = nowtreeIdx[v], TreeDepthB = nowtreeDepth[v];\n    while(TreeIdxA != TreeIdxB) {\n      if(nodes[TreeIdxA].Deep > nodes[TreeIdxB].Deep) {\n        TreeDepthA = nodes[TreeIdxA].ParDepth;\n        TreeIdxA   = nodes[TreeIdxA].ParIdx;\n      } else {\n        TreeDepthB = nodes[TreeIdxB].ParDepth;\n        TreeIdxB   = nodes[TreeIdxB].ParIdx;\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    cout << Nodes[TreeIdxA][TreeDepthA] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define INCLUDE_EULER_TOUR_HPP\n#include <vector>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> begin, end;\n  std::vector<int> id, depth;\n\n  EulerTour(int N) : T(N), begin(N), end(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    begin[u] = end[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      end[u] = id.size();\n      id.push_back(u);\n      depth.push_back(d);\n    }\n  }\n};\n#define INCLUDE_RMQ_HPP\n#include <algorithm>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L;\n\n  std::vector<int> lg;\n  std::vector<BitIndex> small;\n  std::vector<std::vector<Index>> large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n\nprivate:\n  Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), lg(1 << S), small(N), large(L, std::vector<Index>(LG_L)) {\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li][0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li][0] = F(large[li][0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li][x + 1] = F(large[li][x], large[li + (1 << x)][x]);\n      }\n    }\n    std::vector<Index> st;\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      st.clear();\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (!st.empty() && f(i + si, st.back())) st.pop_back();\n        small[i + si] |= 1 << si;\n        if (!st.empty()) small[i + si] |= small[st.back()];\n        st.push_back(i + si);\n      }\n    }\n  }\n  int ntz(int x) const { return lg[x & -x]; }\n  int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l][x], large[r - (1 << x) + 1][x]);\n  }\n};\n#include <utility>\n\nstruct LCA {\n  EulerTour euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.begin[u];\n    int r = euler_tour.begin[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(std::move(et));\n\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    std::vector<Node> node_;\n};\n//*/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    RangeMinimumQuery rmq(n);\n    for(int i = 0; i < n; ++i) rmq.update(i, t.depth(i));\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<utility>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :depth_(n, 0), child_(n) {\n        log_size_ = 1;\n        while(log_size_ << 1 < n) log_size_ <<= 1;\n        parent_.resize(log_size_ + 1, std::vector<int>(n, NIL));\n    }\n    void add(const int v, const int c) {\n        parent_[0][c] = v;\n        depth_[c] = depth_[v] + 1;\n        child_[v].push_back(c);\n    }\n    void init() {\n        for(int d = 1; d < size(); ++d) for(int u = 0; u < size(); ++u)\n            if(parent_[d - 1][parent_[d - 1][u]] != NIL) parent_[d][u] = parent_[d - 1][parent_[d - 1][u]];\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        // u, vを同じ深さにする\n        if(depth_[v] < depth_[u]) std::swap(u, v);\n        for(int i = log_size_; i >= 0; --i) {\n            if(parent_[i][v] == NIL) continue;\n            if(depth_[parent_[i][v]] < depth_[u]) continue;\n            v = parent_[i][v];\n        }\n        if(u == v) return u;\n        // 共通の祖先を求める\n        for(int i = log_size_; i >= 0; --i) {\n            if(parent_[i][u] == NIL) continue;\n            if(parent_[i][u] == parent_[i][v]) continue;\n            u = parent_[i][u];\n            v = parent_[i][v];\n        }\n        return parent_[0][u];\n    }\nprivate:\n    const int NIL = -1;\n    int size() const {return depth_.size();}\n    int log_size_;\n    std::vector<std::vector<int>> parent_;\n    std::vector<std::vector<int>> child_;\n    std::vector<int> depth_;\n};\n\n/*/\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n//*/\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v)\n        : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass LowestCommonAncestor\n{\npublic:\n    LowestCommonAncestor(const Graph& g, const int root = 0) : left(g.V, 0)\n    {\n        vector<bool> used(g.V, false);\n        dfs(g, make_pair(0, root), used);\n    }  // 無向根付き木\n    int LCA(const int u, const int v) const\n    {\n        static const SparseTable<DepthMin> st{depth};\n        const int ul = left[u];\n        const int vl = left[v];\n        return st.accumulate(min(ul, vl), max(ul, vl) + 1).second;\n    }\n\nprivate:\n    struct DepthMin\n    {\n        using T = pair<int, int>;\n        T operator()(const T& a, const T& b) const { return min(a, b); }\n    };\n\n    void dfs(const Graph& g, const pair<int, int> s, vector<bool>& used)\n    {\n        used[s.second] = true;\n        const int pos = s.second;\n        left[pos] = depth.size();\n        depth.push_back(s);\n        for (const int to : g.edge[pos]) {\n            if (used[to]) continue;\n            dfs(g, make_pair(s.first + 1, to), used);\n            depth.push_back(s);\n        }\n    }\n    vector<int> left;\n    vector<pair<int, int>> depth;\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n// Status: Accepted\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g.addEdge(i, c);\n        }\n    }\n\n    LowestCommonAncestor lca{g};\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.LCA(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nvi MSB;\nvoid initMSB(int n){\n  MSB = vi(n+1,0);\n  int k = 2;\n  rep(i,n){\n    if(i+1==k)MSB[i+1] = MSB[i] + 1, k<<=1;\n    else MSB[i+1] = MSB[i];\n  }\n}\n\nstruct SparseTable{\n  vi val;\n  vector<vi> table;\n\n  SparseTable(void){}\n  SparseTable(const vi a):val(a){\n    int n = a.size();\n    initMSB(n);\n    table = vector<vi>(n,vi(MSB[n]+1,0));\n    rep(i,n)table[i][0] = i;\n\n    int k = 1;\n    rep(j,MSB[n]){\n      rep(i,n){\n\tint id1 = table[i][j], id2 = (i+k<n)?table[i+k][j]:id1;\n\ttable[i][j+1] = (val[id1]<=val[id2])?id1:id2;\n      }\n      k <<= 1;\n    }\n  }\n\n  int rmqi(int l, int r){\n    int ln = MSB[r-l];\n    int id1 = table[l][ln], id2 = table[r-(1<<ln)][ln];\n    return (val[id1]<=val[id2])?id1:id2;\n  }\n\n  int rmq(int l, int r){ return val[rmqi(l,r)]; }\n};\n\nstruct dif1RMQ{\n  int s;\n  vi val, subval, subid, bit;\n  SparseTable st;\n  vector< vector<vi> > lookup_table;\n\n  dif1RMQ(void){}\n  dif1RMQ(const vi a):val(a){\n    int n = a.size();\n    initMSB(n);\n    s = max(1,MSB[n]/2);\n    int m = (n+s-1)/s;\n\n    subval.resize(m); subid.resize(m); bit.resize(m);\n    rep(i,m){\n      subval[i] = val[s*i]; subid[i] = s*i;\n      int lim = min(s*(i+1),n);\n      for(int j=s*i;j<lim;j++){\n\tif(subval[i] > val[j]){ subval[i] = val[j]; subid[i] = j; }\n      }\n      bit[i] = 0;\n      for(int j=s*i;j<lim-1;j++){\n\tif(val[j]<val[j+1])bit[i] |= 1<<(j-s*i+1);\n      }\n    }\n    st = SparseTable(subval);\n\n    lookup_table.resize(1<<s);\n    rep(i,1<<s)lookup_table[i] = vector<vi>(s, vi(s,0));\n      \n    rep(i,1<<s)rep(j,s){\n      int cur = 0, minv = 0, minid = j;\n      lookup_table[i][j][j] = j;\n      for(int k=j+1;k<s;k++){\n\tif( (i>>k)&1 )cur++;\n\telse cur--;\n\tif(minv > cur){ minv = cur; minid = k; }\n\tlookup_table[i][j][k] = minid;\n      }\n    }\n  }\n\n  int rmqi(int l, int r){\n    //cerr << l << \" \" << r << endl;\n    r--;\n    int bl = l/s, br = r/s;\n    if(bl == br)return lookup_table[bit[bl]][l-bl*s][r-br*s] + bl*s;\n    else{\n      //cerr << bit[bl] << \" \"<< l-bl*s << \" \" << s << endl;\n      int res = lookup_table[bit[bl]][l-bl*s][s-1] + bl*s;\n      int tmp = lookup_table[bit[br]][0][r-br*s] + br*s;\n\n      //cerr << res << \" \" << tmp << endl;\n      if(val[res] > val[tmp])res = tmp;\n      if(br-bl>0){\n\ttmp = subid[st.rmqi(bl+1,br)];\n\tif(val[res] > val[tmp])res = tmp;\n      }\n      return res;\n    }\n  }\n\n  int rmq(int l, int r){ return val[rmqi(l,r)]; }\n};\n\nstruct LCA{\n  vi tour, depth, id;\n  dif1RMQ dr;\n  \n  LCA(void){}\n  LCA(const vector<vi> t,int root){\n    int n = t.size(), k = 0;\n    tour.resize(2*n-1); depth.resize(2*n-1); id.resize(n);\n    dfs(root,-1,0,k,t);\n    dr = dif1RMQ(depth);\n  }\n\n  void dfs(int v,int p, int d, int &k, const vector<vi> &t){\n    id[v] = k; tour[k] = v;\n    depth[k++] = d;\n    for(int u : t[v]){\n      if(u != p){\n\tdfs(u,v,d+1,k,t);\n\ttour[k] = v;\n\tdepth[k++] = d;\n      }\n    }\n  }\n\n  int lca(int u, int v){\n    int a = min(id[u],id[v]), b = max(id[u],id[v]);\n    return tour[dr.rmqi(a,b+1)];\n  }\n  int dep(int v){ return depth[id[v]]; }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<vi> g(n);\n  rep(i,n){\n    int k;\n    cin >> k;\n    rep(j,k){\n      int c;\n      cin >> c;\n      g[i].push_back(c);\n    }\n  }\n  LCA lca(g,0);\n  \n  int q;\n  cin >> q;\n  rep(i,q){\n    int a,b;\n    cin >> a >> b;\n    int x = lca.lca(a,b);\n    cout << x << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> > t,int n)\n    :tree(t),n(n),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree,n);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ??°??????????????????(?????????????°??????¨???)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to){ \n\tgraph[from].push_back({to});\n}\n\n// Description: ??¨????????????????°???±????\\????  \n// TimeComplexity: Init $ \\mathcal{O}(N) $ Query:$ \\mathcal{O}(\\log V)$\n// Verifyed: AOJ GRL_5_C\n \nauto init(const G& graph){\n    const int n=graph.size(),logn=32-__builtin_clz(n);\n    vector<vector<int>> par(logn,vector<int>(n));\n    vector<int> depth(n);\n\n    auto dfs=[&](int v,int p,int d){\n        auto func=[&](int v,int p,int d,auto func)->void{\n            par[0][v]=p,depth[v]=d;\n            for(auto &e:graph[v]) if(e.to!=p) func(e.to,v,d+1,func);\n        };\n        return func(v,p,d,func);\n    };\n\n    dfs(0,-1,0);\n    rep(k,logn-1)rep(v,n){\n        par[k+1][v]=-1;\n        if(par[k][v]!=-1) par[k+1][v]=par[k][par[k][v]];\n    }\n    return make_tuple(par,depth);\n}\n\nint lca(const auto &par,const auto &depth,int u,int v){\n    const int logn=par.size();\n    if(depth[u]<depth[v]) swap(u,v);\n    rrep(k,logn) if((depth[u]-depth[v])>>k&1) u=par[k][u];\n    if(u==v) return u;\n    rrep(k,logn) if(par[k][u]!=par[k][v])u=par[k][u],v=par[k][v];\n    return par[0][u];\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tG graph(n);\n\n\trep(v,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            add_edge(graph,v,c);\n        }\n\t}\n\n    auto info=init(graph);\n\n    int q;\n    cin >> q;\n    rep(loop,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca(get<0>(info),get<1>(info),a,b) << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < N; i++) { sort(D[i].begin(), D[i].end()); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\tif (W == 0 || (Depth[b[A]] == 1 && Depth[b[B]] == 1)) { cout << \"0\" << endl; continue; }\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return k;\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return (node_[vl] < node_[vr] ? left_child(k) : right_child(k));\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    std::vector<Node> node_;\n};\n//*/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n\n    RangeMinimumQuery rmq(n);\n    for(int i = 0; i < n; ++i) rmq.update(i, t.depth(i));\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n//         cout << t.lowest_common_ancestor(u, v) << endl;\n//         rmq.find(u, v);\n        cout << rmq.find_index(u, v) - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100000\n#define MAX_LOG_V 100\n\nvector<int> G[MAX_V];\nint root;\nint deg[MAX_V];\n\nint parent[MAX_LOG_V][MAX_V];  \nint depth[MAX_V];\n\nvoid dfs(int v,int p,int d){\n  parent[0][v] = p;\n  depth[v] = d;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    if(G[v][i] != p){\n      dfs(G[v][i],v,d+1);\n    }\n  }\n}\n\nint getRoot(int V){\n  for(int i = 0 ; i < V ; i++){\n    if(deg[i] == 0){\n      return i;\n    }\n  }\n  return -1;\n}\n\nvoid init(int V){\n  root = getRoot(V);\n  dfs(root,-1,0);\n  for(int k = 0 ; k + 1 < MAX_LOG_V ; k++){\n    for(int v = 0 ; v < V ; v++){\n      if(parent[k][v] < 0){\n        parent[k+1][v] = -1;\n      }else{\n        parent[k+1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n}\n\nint lca(int u,int v){\n  if(depth[u] > depth[v]){\n    swap(u,v);\n  }\n  for(int k = 0 ; k < MAX_LOG_V ; k++){\n    if((depth[v] - depth[u]) >> k & 1){\n      v = parent[k][v];\n    }\n  }\n  if(u == v){ return u; }\n  for(int k = MAX_LOG_V-1 ; k >= 0 ; k--){\n    if(parent[k][u] != parent[k][v]){\n      u = parent[k][u];\n      v = parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint main(){\n  int N,K,x;\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> K;\n    for(int j = 0 ; j < K ; j++){\n      cin >> x;\n      G[i].push_back(x);\n    }\n  }\n  init(N);\n  int Q,a,b;\n  cin >> Q;\n  for(int i = 0 ; i < Q ; i++){\n    cin >> a >> b;\n    cout << lca(a,b) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\nconst int inf = 1 << 30;\nconst ll linf = 1e18;\ntemplate<class T> void chmin(T& x, T y){if(x > y) x = y;}\ntemplate<class T> void chmax(T& x, T y){if(x < y) x = y;}\n\nint N, Q;\nconst int m_log = 20;\nvector<int> G[100010];\nint par[m_log][100010];\nint depth[100010];\n\nvoid dfs(int v, int p, int d){\n    par[0][v] = p;\n    depth[v] = d;\n\n    for(auto& u : G[v]){\n        if(p == u) continue;\n        dfs(u, v, d + 1);\n    }\n}\n\nvoid setting(){\n    dfs(0, -1, 0);\n    for(int i = 1; i < m_log; i++){\n        for(int j = 0; j < N; j++){\n            if(par[i - 1][j] < 0) par[i][j] = -1;\n            else par[i][j] = par[i - 1][par[i - 1][j]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] < depth[v]) swap(u, v);\n    int d = depth[u] - depth[v];\n\n    for(int i = 0; i < m_log; i++){\n        if(d >> i & 1) u = par[i][u];\n    }\n    if(u == v) return u;\n\n    for(int i = m_log - 1; i >= 0; i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main(){\n    cin >> N;\n    for(int i = 0; i < N; i++){\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; j++){\n            int c;\n            cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    setting();\n\n    cin >> Q;\n    for(int i = 0; i < Q; i++){\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr ll mod = 1e9 + 7;\n\ntemplate <class T> inline bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <class T> inline bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nint n, q, par[100000][17], dep[100009];\n\nint LCA(int u, int v) {\n    if(dep[u] > dep[v]) swap(u, v);\n\n    rep(i, 17) if((dep[v] - dep[u] >> i) & 1) v = par[v][i];\n\n    if(u == v) return u;\n\n    for(int i = 16; i >= 0; i--)\n        if(par[u][i] != par[v][i]) {\n            u = par[u][i];\n            v = par[v][i];\n        }\n\n    return par[u][0];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> n;\n    par[0][0] = -1;\n    rep(i, n) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int a;\n            cin >> a;\n            par[a][0] = i;\n            dep[a] = dep[i] + 1;\n        }\n    }\n\n    FOR(i, 1, 17) {\n        rep(j, n) {\n            if(par[j][i - 1] == -1)\n                par[j][i] = -1;\n            else\n                par[j][i] = par[par[j][i - 1]][i - 1];\n        }\n    }\n\n    cin >> q;\n\n    while(q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << LCA(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n);i++)\n#define sz(x) int(x.size())\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct LowestCommonAncestor {\n  int n, h;\n  vector<vector<int>> g, par;\n  vector<int> dep;\n\n  LowestCommonAncestor(int sz) {\n    n = sz; h = 1;\n    g.resize(n), dep.resize(n);\n    while ((1 << h) <= n) h++;\n    par.assign(h, vector<int>(n, -1));\n  }\n\n  void add_edge(int u, int v) {\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n\n  void dfs(int u, int p, int depth) {\n    par[0][u] = p;\n    dep[u] = depth;\n    for (auto v : g[u]) {\n      if (v == p) continue;\n      dfs(v, u, depth + 1);\n    }\n  }\n\n  void build(int root = 0) {\n    dfs(root, -1, 0);\n    for (int i = 0; i + 1 < h; i++) {\n      for (int j = 0; j < n; j++) {\n        if (par[i][j] != -1) par[i+1][j] = par[i][par[i][j]];\n        else par[i+1][j] = -1;\n      }\n    }\n  }\n\n  int query(int u, int v) {\n    if (dep[u] > dep[v]) swap(u, v);\n    for (int i = h-1; i >= 0; i--) {\n      if ( ((dep[v] - dep[u]) >> i) & 1) v = par[i][v];\n    }\n    if (u == v) return u;\n    for (int i = h-1; i >= 0; i--) {\n      if (par[i][u] != par[i][v]) {\n        u = par[i][u];\n        v = par[i][v];\n      }\n    }\n    return par[0][u];\n  }\n};\n\nint main(){ \n  int n;\n  cin >> n;\n  LowestCommonAncestor lca(n);\n  rep(i,n) {\n    int k;\n    cin >> k;\n    rep(j,k) {\n      int c; cin >> c;\n      lca.add_edge(i, c);\n    }\n  }\n  lca.build();\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.query(u, v) << endl;\n  }\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define N 100010\n\nclass Segtree{\n  public:\n  ll n;\n  ll *dat;\n  void init(ll nn){\n    for(n=1;n<nn;n*=2){}\n    dat=new ll[n];\n    for(int i=0;i<n;i++)dat[i]=1;\n  }\n  \n  \n  void upd(ll l,ll r){\n    for(ll i=l;i<=r;i++)dat[i]=0;\n  }\n  \n  ll qry(ll l,ll r){\n    ll res=0;\n    for(ll i=l;i<=r;i++)res+=dat[i];\n    return res;\n  }\n};\n\nvector<ll> g[N];\nll n;\nclass HLD{\n  public:\n  ll chain[N],id[N],chn;\n  ll par[N],len[N];\n  \n  ll siz[N],dep[N];\n  void dfs(ll x,ll from,ll d){\n    siz[x]=1; dep[x]=d;\n    for(auto y:g[x]){\n      if(y==from)continue;\n      dfs(y,x,d+1);\n      siz[x]+=siz[y];\n    }\n  }\n  \n  void build(){\n    for(int i=1;i<=n;i++){\n      chain[i]=-1;\n    }\n    P dat[N];\n    for(int i=1;i<=n;i++){\n      dat[i-1]=make_pair(dep[i],i);\n    }sort(dat,dat+n);\n    chn=0;\n    for(int i=0;i<n;i++){\n      ll x=dat[i].second;\n      if(~chain[x])continue;\n      for(auto y:g[x])if(~chain[y])par[chn]=y;\n      for(int j=0;;j++){\n\tchain[x]=chn;\n\tid[x]=j; len[chn]=j;\n\tll ma=-1,pnt=-1;\n\tfor(auto y:g[x]){\n\t  if(~chain[y])continue;\n\t  if(ma<siz[y])ma=siz[y],pnt=y;\n\t}\n\tif(pnt==-1)break;\n\tx=pnt;\n      }\n      chn++;\n    }\n  }\n  \n  Segtree seg[N];\n  void init(){\n    dfs(0,-1,0);\n    build();\n    for(int i=0;i<chn;i++){\n      seg[i].init(len[i]+1);\n    }\n  }\n  \n  void upd(ll a,ll b){\n    while(chain[a]!=chain[b]){\n      if(chain[a]<chain[b])swap(a,b);\n      ll c=chain[a];\n      seg[c].upd(0,id[a]);\n      //cout<<c<<\" 0 \"<<id[a]<<endl;\n      a=par[c];\n    }\n    ll aid=id[a],bid=id[b]; if(aid>bid)swap(aid,bid);\n    if(aid!=bid)seg[chain[a]].upd(aid+1,bid);\n    //cout<<chain[a]<<\" \"<<aid+1<<\" \"<<bid<<endl;\n  }\n  \n  ll qry(ll a,ll b){\n    ll res=0;\n    while(chain[a]!=chain[b]){\n      if(chain[a]<chain[b])swap(a,b);\n      ll c=chain[a];\n      res+=seg[c].qry(0,id[a]);\n      //cout<<c<<\" 0 \"<<id[a]<<\" \"<<seg[c].qry(0,id[a])<<endl;\n      a=par[c];\n    }\n    ll aid=id[a],bid=id[b]; if(aid>bid){swap(aid,bid);swap(a,b);}\n    if(aid!=bid)res+=seg[chain[a]].qry(aid+1,bid);\n    //cout<<chain[a]<<\" \"<<aid+1<<\" \"<<bid<<\" \"<<seg[chain[a]].qry(aid+1,bid)<<endl;\n    \n    return a;\n    \n    return res;\n  }\n  \n};HLD hld;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n      ll k;cin>>k;\n      for(int j=0;j<k;j++){\n\t  ll x;cin>>x;\n\t  g[x].push_back(i);\n\t  g[i].push_back(x);\n      }\n  }\n  hld.init();\n  ll q;cin>>q;\n  for(int i=0;i<q;i++){\n      ll a,b;cin>>a>>b;\n      cout<<hld.qry(a,b)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\n\n// Global variables declared here\nint n, q;\nvector<int> childs[maxn];\nint jt[18][100005];\nint depth[100005];\n// End of global variables\n\nvoid dfs(int n, int p = -1) {\n    depth[n] = p == -1 ? 0 : depth[p] + 1;\n    for (int h : childs[n])\n        dfs(h, n);\n}\n\nvoid init() {\n    dfs(0);\n\n    jt[0][0] = -1;\n\n    for (int i = 0; i < 17; i++) {\n        for (int j = 0; j < n; j++) {\n            if (jt[i][j] != -1) {\n                jt[i + 1][j] = jt[i][jt[i][j]];\n            }\n        }\n    }\n}\n\n// Walk up n from v\nint up(int v, int n) {\n    for (int i = 17; i >= 0; i--) {\n        if (n & (1 << i)) {\n            v = jt[i][v];\n        }\n    }\n\n    return v;\n}\n\nint lca(int a, int b) {\n    if (depth[a] > depth[b])\n        swap(a, b);\n\n    b = up(b, depth[b] - depth[a]);\n\n    if (a == b)\n        return a;\n\n    for (int i = 17; i >= 0; i--) {\n        if (jt[i][a] != jt[i][b]) {\n            a = jt[i][a], b = jt[i][b];\n        }\n    }\n\n    return jt[0][a];\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int k; cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c; cin >> c;\n            childs[i].push_back(c);\n            jt[0][c] = i;\n        }\n    }\n\n    init();\n\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t{\n\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL; lazy=0;\n  }\n\n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    rp=p;\n  }\n  x->splay();\n  //return x;\n  return rp;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n}\n\nnode_t *lowestCommonAncestor(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << lowestCommonAncestor(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nint n;\nint main(void) {\n    cin >> n;\n    int parent[n];\n    for (int i = 0; i < n; i++) parent[i] = -1;\n    for (int i = 0; i < n; i++) {\n        int k, tmp;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            cin >> tmp;\n            parent[tmp] = i;\n        }\n    }\n//    for (int i = 0; i < n; i++) {\n//        printf(\"%d parent is %d\\n\", i, parent[i]);\n//    }\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        vector<int> parents_u, parents_v;\n        for (int j = u; j != -1; j = parent[j]) {\n            parents_u.push_back(j);\n        }\n        for (int j = v; j != -1; j = parent[j]) {\n            parents_v.push_back(j);\n        }\n        for (int j = 0; j < parents_u.size(); j++) {\n            int flag = 0;\n            for (int k = 0; k < parents_v.size(); k++) {\n                if (parents_u[j] == parents_v[k]) {\n                    cout << parents_u[j] << endl;\n                    flag = 1;\n                    break;\n                }\n            }\n            if (flag == 1) break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << a[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << a[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\nstruct rmqsegtree{\n  vector< pair<int, int> > t; //<data, at>\n  pair<int, int> re;\n  int n;\n  void dflt(void){ re.first = INT_MAX; re.second = -1; return; }\n  void use(void){\n    int i; dflt();\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0].first = 1 << (i - 1); t[0].second = 1 << i;\n    for(i = 1;i < t[0].second;++i)t[i] = re;\n    for(i = 0;i < n;++i)t[i + t[0].first].second = i;\n    return;\n  }\n  void build(vector<int> a){\n    for(n = 1;;n <<= 1)if(n >= a.size())break;\n    t.resize(n << 1); dflt();\n    t[0].first = n; t[0].second = t[0].first << 1; n = a.size();\n    for(int i = 1;i < t[0].second;++i)t[i] = re;\n    for(int i = 0;i < n;++i){\n      t[t[0].first + i].first = a[i]; t[t[0].first + i].second = i;\n    }\n    for(int i = t[0].first - 1;i >= 1;--i)\n      t[i] = (t[i << 1] <= t[(i << 1) + 1]) ? t[i << 1] : t[(i << 1) + 1];\n    return;\n  }\n  void update(int at, int data){\n    t[t[0].first + at].first = data;\n    for(int x = t[0].first + at;x > 1;){\n      x >>= 1;\n      if(t[x << 1].first <= t[(x << 1) + 1].first)t[x] = t[x << 1];\n      else t[x] = t[(x << 1) + 1];\n    }\n    return;\n  }\n  pair<int, int> query(int l, int r, int k, int kl, int kr){\n    if(l <= t[k].second && t[k].second < r)return t[k];\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    pair<int, int> a = query(l, r, k << 1, kl, (kl + kr) >> 1);\n    pair<int, int> b = query(l, r, (k << 1) + 1, (kl + kr) >> 1, kr);\n    return (a.first < b.first) ? a : b;\n  }\n  pair<int, int> find(int l, int r){ return query(l, r, 1, 0, t[0].first); }\n  void deb(void){\n    int x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].first);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].second);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    return;\n  }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nstruct tree{\n  vector< vector<edge> > t;\n  int v;\n  void nexttree(int x){ //x-indexed\n    scanf(\"%d\", &v);  t.resize(v);\n    int from, to, cost = 1;\n    for(int i = 1;i < v;++i){\n      scanf(\"%d %d\", &from, &to);\n      t[from - x].push_back((edge){to - x, cost});\n      t[to - x].push_back((edge){from - x, cost});\n    }\n    return;\n  }\n  void nexttree2(int x){\n    scanf(\"%d\", &v); t.resize(v);\n    int k, to, cost = 1;\n    for(int i = 0;i < v;++i){\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;++j){\n        scanf(\"%d\", &to);\n        t[i - x].push_back((edge){to - x, cost});\n        t[to - x].push_back((edge){i - x, cost});\n      }\n    }\n    return;\n  }\n\n\n  rmqsegtree S;\n  vector<int> vst, dpth, id;\n  void lcarmqdfs(int now, int dep){ //575!!\n    /* ????????° */\n    vector< pair<int,int> > stk; stk.resize(v);   //stack\n    int head = 0;\n    stk[head].first = now; stk[head++].second = dep;\n\n    for(;head;){\n      pair<int,int> tmp = stk[--head];\n\n      if(id[tmp.first] == -1){\n        id[tmp.first] = vst.size();\n        vst.push_back(tmp.first); dpth.push_back(tmp.second);\n      }else{\n        vst.push_back(tmp.first); dpth.push_back(tmp.second);\n        continue;\n      }\n\n      for(int i = 0;i < t[tmp.first].size();++i)if(id[t[tmp.first][i].to] == -1){\n        stk[head++] = tmp;\n        stk[head].first = t[tmp.first][i].to; stk[head++].second = tmp.second + 1;\n      }\n    }\n    stk.clear();\n    return;\n  }\n\n\n  void lcarmq(void){\n    if(vst.size() > v)return;\n    id.resize(v); for(int i = 0;i < v;++i)id[i] = -1;\n    lcarmqdfs(0, 0);\n    S.build(vst);\n    return;\n  }\n  int lca(int a, int b){\n    if(id[a] > id[b])swap(a, b);\n    return vst[S.find(id[a], id[b] + 1).second];\n  }\n  int depth(int a){ return dpth[id[a]]; }\n  int dist(int a, int b){ return depth(a) + depth(b) - 2 * depth(lca(a, b)); }\n};\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    tree T; T.nexttree2(0);\n    T.lcarmq();\n\n    int(q);\n    for(;q--;){\n      int2(a, b);\n      pri(T.lca(a, b));\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b){a = b; return true;} return false;}\n\nstruct Edge{\n    int to,weight;\n    Edge(int t,int w) : to(t), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nclass Tree{\n    public:\n        Tree(int size) : mGraph(size), mMemo(size), mLog2v(log2(size)) {}\n        void add_edge(int s, int t, int w = 1){\n            mGraph[s].emplace_back(t,w);\n            mGraph[t].emplace_back(s,w);\n        }\n\n        // diameter of a tree\n        pair<int,int> dfs(int v, int pv){\n            pair<int,int> ret(0,v);\n            for(Edge nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                pair<int,int> tmp = dfs(nv.to,v);\n                if(chmax(ret.first,tmp.first + nv.weight)){\n                    ret.second = tmp.second;\n                }\n            }\n            return ret;\n        }\n\n        int diameter(){\n            pair<int,int> s = dfs(0,-1);\n            pair<int,int> t = dfs(s.second,-1);\n            return t.first;\n        }\n        //\n\n        // height of a tree\n        int dfs_memo(int v,int e){\n            if(mMemo[v][e].weight >= 0) return mMemo[v][e].weight;\n            mMemo[v][e].weight = mGraph[v][e].weight;\n            int nv = mMemo[v][e].to;\n            for(int ne = 0; ne < mMemo[nv].size(); ++ne){\n                if(mMemo[nv][ne].to == v) continue;\n                mMemo[v][e].weight = max(mMemo[v][e].weight, dfs_memo(nv,ne) + mGraph[v][e].weight);\n            }\n            return mMemo[v][e].weight;\n        }\n\n        vector<int> height(){\n            mMemo = mGraph;\n            // init memo\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    mMemo[i][j].weight = -1;\n                }\n            }\n            //\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    if(mMemo[i][j].weight < 0){\n                        mMemo[i][j].weight = dfs_memo(i,j);\n                    }\n                }\n            }\n\n           // calc result\n           vector<int> ret(mMemo.size());\n           for(int i = 0; i < mMemo.size(); ++i){\n               for(int j = 0; j < mMemo[i].size(); ++j){\n                   ret[i] = max(ret[i],mMemo[i][j].weight);\n               }\n           }\n           return ret;\n        }\n        //\n        \n        // Lowest Common Ancester\n        void SetParentAndDepth(int v,int pv, int d){\n            mPar[0][v] = pv; // v is pv's 2^0 parent\n            mDepth[v] = d;\n            for(auto nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                SetParentAndDepth(nv.to,v,d+1);\n            }\n        }\n\n        void Init(int root){\n            mPar.resize(mLog2v);\n            for(int i=0; i < mLog2v;++i) mPar[i].resize(mGraph.size());\n            mDepth.resize(mGraph.size());\n            SetParentAndDepth(root,-1,0);\n            // calc 2^k parent of each vert\n            for(int k = 0; k + 1 < mLog2v; ++k){\n                for(int v = 0; v < mGraph.size(); ++v){\n                    if(mPar[k][v] < 0) mPar[k+1][v] = -1; // not having parent\n                    else mPar[k+1][v] = mPar[k][mPar[k][v]];\n                }\n            }\n        }\n\n        int GetLca(int u,int v){\n            while(mDepth[u] > mDepth[v]) swap(u,v);\n            for(int k = 0; k < mLog2v; ++k){\n                if((mDepth[v] - mDepth[u]) >> k & 1){\n                    v = mPar[k][v];\n                }\n            }\n            if(u==v) return u;\n            for(int k = mLog2v - 1; k >= 0; --k){\n                if(mPar[k][u] != mPar[k][v]) {\n                    u = mPar[k][u];\n                    v = mPar[k][v];\n                }\n            }\n            return mPar[0][u];\n        }\n        //\n\n\n    private:\n        Graph mGraph;\n        Graph mMemo;\n        \n        // LCA\n        int mLog2v;\n        vector<vector<int> > mPar;\n        vector<int> mDepth;\n};\n\nint main(){\n    int n,q,k,x,y;\n    cin >> n;\n    Tree tree(n);\n    for(int i = 0; i < n; ++i){\n        cin >> k;\n        for(int j = 0; j < k; ++j){\n            cin >> x;\n            tree.add_edge(i,x);\n        }\n    }\n    tree.Init(0);\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        cin >> x >> y;\n        cout << tree.GetLca(x,y) << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cfloat>\n#include <climits>\n#include <cassert>\n#include <random>\n#include <bitset>\n#include <memory>\n\nclass Tree {\n\tstd::vector<std::vector<int>> parent, nodes;\n\tstd::vector<int> depth;\n\tint move_up_to(int v, int step) const {\n\t\tif (step == 0) return v; \n\t\tauto i = 0;\n\t\tfor (; ((1 << i) & step) == 0; ++i) {}\n\t\treturn move_up_to(parent[v][i], step - (1 << i));\n\t}\npublic:\n\tTree(const std::vector<std::vector<int>>& _nodes): parent(_nodes.size()), nodes(_nodes), depth(_nodes.size(), -1) {\n\t\tstd::stack<int> stack; stack.push(0); depth[0] = 0;\n\t\twhile (!stack.empty()) {\n\t\t\tconst auto top = stack.top(); stack.pop();\n\t\t\tfor (const auto c : _nodes[top]) if (depth[c] == -1) {\n\t\t\t\tdepth[c] = depth[top] + 1;\n\t\t\t\tstack.push(c);\n\t\t\t\tparent[c].push_back(top);\n\t\t\t\twhile (parent[parent[c].back()].size() >= parent[c].size()) {\n\t\t\t\t\tparent[c].push_back(parent[parent[c].back()][parent[c].size() - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto i = 0; i < nodes.size(); ++i) {\n\t\t\tnodes[i].erase(std::remove_if(nodes[i].begin(), nodes[i].end(), [i, this](int j) {return depth[i] > depth[j]; }), nodes[i].end());\n\t\t}\n\t};\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tif (depth[u] < depth[v]) v = move_up_to(v, depth[v] - depth[u]);\n\t\tif (u == v) return u;\n\t\tint i = 0;\n\t\twhile (i + 1 < parent[v].size() && parent[v][i + 1] != parent[u][i + 1]) ++i;\n\t\treturn lca(parent[v][i], parent[u][i]);\n\t}\n\tconst std::vector<int>& children(int v) const {\n\t\treturn nodes[v];\n\t}\n\tint size() const {\n\t\treturn nodes.size();\n\t}\n\tint root() const {\n\t\treturn 0;\n\t}\n};\nint main() {\n\tint n; std::cin >> n;\n\tstd::vector<std::vector<int>> nodes(n);\n\tfor (auto& node : nodes) {\n\t\tint k; std::cin >> k;\n\t\tnode = std::vector<int>(k);\n\t\tfor (auto& c : node) std::cin >> c;\n\t}\n\tTree tree(nodes);\n\tint q; std::cin >> q;\n\tfor (auto i = 0; i < q; ++i) {\n\t\tint u, v; std::cin >> u >> v;\n\t\tstd::cout << tree.lca(u, v) << std::endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <type_traits>\n#include <vector>\n#include <cstdint>\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_C\"\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\n\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return std::cout << \"\\n\", 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\n\ntemplate<typename Cost = usize>\nstruct edge\n{\n    using cost_type = Cost;\n    usize u, v;\n    Cost c;\n    edge(const usize u, const usize v) : u{u}, v{v}, c{1} {}\n    edge(const usize u, const usize v, const Cost& c) : u{u}, v{v}, c{c} {}\n    operator usize() const { return v; }\n    usize from() const { return u; }\n    usize to() const { return v; }\n    Cost cost() const { return c; }\n    friend std::ostream& operator<<(std::ostream& os, const edge& e) { return os << e.u << \"->\" << e.v << \":\" << e.c; }\n};\ntemplate<typename Edge>\nclass base_graph\n{\npublic:\n    base_graph(const usize n) : v{n}, es(n), res(n) {}\n    void add_edge(const usize u, const usize v, const bool bi = false)\n    {\n        es[u].emplace_back(u, v), res[v].emplace_back(v, u);\n        if (bi) { es[v].emplace_back(v, u), res[u].emplace_back(u, v); }\n    }\n    template<typename Cost>\n    void add_edge(const usize u, const usize v, const Cost& c, const bool bi = false)\n    {\n        es[u].emplace_back(u, v, c), res[v].emplace_back(v, u, c);\n        if (bi) { es[v].emplace_back(v, u, c), res[u].emplace_back(u, v, c); }\n    }\n    std::vector<Edge>& operator[](const usize u) { return es[u]; }\n    const std::vector<Edge>& operator[](const usize u) const { return es[u]; }\n    std::vector<Edge>& from(const usize u) { return es[u]; }\n    const std::vector<Edge>& from(const usize u) const { return es[u]; }\n    std::vector<Edge>& to(const usize v) { return res[v]; }\n    const std::vector<Edge>& to(const usize v) const { return res[v]; }\n    usize size() const { return v; }\n\nprivate:\n    usize v;\n    std::vector<std::vector<Edge>> es, res;\n};\ntemplate<typename Edge>\nusing base_tree = base_graph<Edge>;\nusing graph     = base_graph<edge<>>;\nusing tree      = base_graph<edge<>>;\ntemplate<typename Cost>\nusing cost_graph = base_graph<edge<Cost>>;\ntemplate<typename Cost>\nusing cost_tree = base_graph<edge<Cost>>;\ntemplate<typename Edge = edge<>>\nclass level_ancestor\n{\npublic:\n    level_ancestor(const base_tree<Edge>& g, const usize r = 0) : par(g.size())\n    {\n        std::vector<usize> d(g.size(), 0);\n        auto dfs = [&](auto&& self, const usize s, const usize p) -> void {\n            for (usize k = 1; (1UL << k) <= d[s]; k++) { par[s].push_back(par[par[s][k - 1]][k - 1]); }\n            for (const auto& e : g[s]) {\n                const usize to = e.to();\n                if (to == p) { continue; }\n                d[to] = d[s] + 1;\n                par[to].push_back(s);\n                self(self, to, s);\n            }\n        };\n        dfs(dfs, r, g.size());\n    };\n    usize operator()(usize v, usize d) const\n    {\n        for (int k = (int)log2p1(d); k >= 0; k--) {\n            if (btest(d, k)) {\n                v = par[v][(usize)k];\n                breset(d, k);\n            }\n        }\n        return v;\n    }\n\nprivate:\n    std::vector<std::vector<usize>> par;\n};\nint main()\n{\n    auto V = in<usize>();\n    graph g(V);\n    for (usize i = 0; i < V; i++) {\n        const auto k = in<usize>();\n        for (usize j = 0; j < k; j++) {\n            const auto v = in<usize>();\n            g.add_edge(i, v, true);\n        }\n    }\n    std::vector<usize> d(V);\n    mfp([&](auto&& self, const usize s, const usize p) -> void {\n        for (const usize to : g[s]) {\n            if (to == p) { continue; }\n            d[to] = d[s] + 1;\n            self(self, to, s);\n        }\n    })(0, V);\n    const level_ancestor<edge<>> la{g};\n    const auto Q = in<usize>();\n    for (usize q = 0; q < Q; q++) {\n        usize u  = in<usize>();\n        usize v  = in<usize>();\n        usize du = d[u];\n        usize dv = d[v];\n        if (du > dv) { std::swap(u, v), std::swap(du, dv); }\n        v = la(v, dv - du), dv = du;\n        if (u == v) {\n            outln(u);\n        } else {\n            usize inf = 0, sup = du;\n            while (sup - inf > 1) {\n                const usize mid                        = (inf + sup) / 2;\n                (la(u, mid) == la(v, mid) ? sup : inf) = mid;\n            }\n            outln(la(u, sup));\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pr;\n\n#define N 100005\n\nint n, m;\n\nbitset<N> vis;\n\narray<int, N> fa;\n\narray<int, N> ans;\n\narray<vector<int>, N> to;\n\narray<vector<pr>, N> qry;\n\nint find(int u)\n{\n\treturn fa[u] == u ? u : fa[u] = find(fa[u]);\n}\n\nvoid tarjan(int u, int f)\n{\n\tvis.set(u);\n\t\n\tfor (auto e : qry[u])\n\t{\n\t\tint v = e.first;\n\t\tint id = e.second;\n\t\t\n\t\tif (vis[v])\n\t\t\tans[id] = find(v);\n\t}\n\t\n\tfor (auto v : to[u])\n\t\tif (v != f)\n\t\t\ttarjan(v, u);\n\t\t\t\n\tif (u)fa[u] = find(f);\n}\n\nsigned main(void)\n{\n\tcin >> n;\n\t\n\tfor (int u = 0; u < n; ++u)\n\t{\n\t\tint k; cin >> k;\n\t\t\n\t\tfor (int v; k--; )\n\t\t{\n\t\t\tcin >> v;\n\t\t\t\n\t\t\tto[u].push_back(v);\n\t\t\tto[v].push_back(u);\n\t\t}\n\t}\n\t\n\tcin >> m;\n\t\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint x, y; cin >> x >> y;\n\t\t\n\t\tqry[x].push_back(make_pair(y, i));\n\t\tqry[y].push_back(make_pair(x, i));\n\t}\n\t\n\tfor (int i = 0; i < n; ++i)\n\t\tfa[i] = i;\n\t\t\n\tvis.reset();\n\t\n\ttarjan(0, -1);\n\t\n\tfor (int i = 0; i < m; ++i)\n\t\tcout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\n// Edge {{{\ntemplate <class Weight>\nstruct Edge {\n    size_t from, to;\n    Weight weight;\n\n    Edge() {}\n    Edge(size_t from, size_t to, Weight weight = 1) :\n        from(from), to(to), weight(weight)\n    {}\n\n    bool operator<(const Edge &rhs) const {\n        return weight < rhs.weight;\n    }\n\n    bool operator>(const Edge &rhs) const {\n        return weight > rhs.weight;\n    }\n\n    operator size_t() const {\n        return to;\n    }\n};\n// }}}\n\n// Graph {{{\ntemplate <class Weight>\nclass Graph : public vector<vector<Edge<Weight>>> {\n    using graph = vector<vector<Edge<Weight>>>;\n\npublic:\n    Graph() {}\n    Graph(const size_t V) : graph(V) {}\n\n    void connect(size_t from, size_t to, Weight weight = 1) {\n        (*this)[from].emplace_back(from, to, weight);\n    }\n\n    friend ostream& operator<<(ostream &strm, const Graph &G) {\n        for (size_t v = 0; v < G.size(); ++v) {\n            strm << '[' << setw(2) << v << ']';\n            for (const auto &e: G[v]) {\n                strm << ' ' << setw(2) << e.to;\n            }\n            strm << '\\n';\n        }\n        return strm;\n    }\n};\n// }}}\n\n// DoublingLCA {{{\ntemplate <class Weight>\nclass DoublingLCA {\npublic:\n    const size_t V;\n    const size_t LOG_V;\n    Graph<Weight> G;\n    vector<int> depth;\n    vector<Weight> weightSum;\n    vector<vector<int>> table;\n    // table[k][v] := ノード v から根へ 2^k だけ移動した先のノード番号\n\n    DoublingLCA(size_t n) :\n        V(n),\n        LOG_V(32 - __builtin_clz(V)), // ceil(log2(V))\n        G(V),\n        depth(V),\n        weightSum(V),\n        table(LOG_V, vector<int>(V, -1))\n    {}\n\n    // u - v 間に無向辺を張る\n    void connect(size_t u, size_t v, Weight weight = 0) {\n        G.connect(u, v, weight);\n        G.connect(v, u, weight);\n    }\n\n    // 構築 O(V log(V))\n    void build(size_t root) {\n        dfs(root, -1, 0, 0);\n        for (size_t k = 0; k + 1 < LOG_V; ++k) {\n            for (size_t v = 0; v < V; ++v) {\n                if (table[k][v] == -1) {\n                    continue;\n                }\n                table[k + 1][v] = table[k][table[k][v]];\n            }\n        }\n    }\n\n    // u, v の最深共通祖先を求める O(log(V))\n    size_t lca(size_t u, size_t v) {\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int i = LOG_V - 1; i >= 0; --i) {\n            if ((depth[v] - depth[u]) >> i & 1) {\n                v = table[i][v];\n            }\n        }\n\n        if (u == v) {\n            return u;\n        }\n\n        for (int i = LOG_V - 1; i >= 0; --i) {\n            if (table[i][u] != table[i][v]) {\n                u = table[i][u];\n                v = table[i][v];\n            }\n        }\n\n        return table[0][u];\n    }\n\n    // v から根へ k だけ移動した先のノードを求める\n    size_t climb(size_t v, size_t k) {\n        size_t i = 0;\n        while (k > 0) {\n            if (k & 1) {\n                v = table[i][v];\n            }\n            ++i;\n            k >>= 1;\n        }\n        return v;\n    }\n\n    // u - v 間のパスの重みの和を求める\n    Weight pathWeight(size_t u, size_t v) {\n        return weightSum[u] + weightSum[v] - 2 * weightSum[lca(u, v)];\n    }\n\n    // u - v 間のパスの辺の本数 (長さ) を求める\n    int pathLength(size_t u, size_t v) {\n        return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n    }\n\nprivate:\n    void dfs(size_t cur, int p, int d, Weight w) {\n        depth[cur] = d;\n        weightSum[cur] = w;\n        table[0][cur] = p;\n        for (const auto &e: G[cur]) {\n            if (e.to != p) {\n                dfs(e.to, cur, d + 1, w + e.weight);\n            }\n        }\n    }\n};\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n    var(size_t, N);\n    DoublingLCA<size_t> G(N);\n    rep(v, 0, N) {\n        var(size_t, K);\n        rep(j, 0, K) {\n            var(size_t, u);\n            G.connect(u, v);\n        }\n    }\n    G.build(0);\n    var(size_t, Q);\n    while (Q--) {\n        var(size_t, u, v);\n        output(G.lca(u, v));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include \"limits.h\"\n#include <limits>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(i) std::cerr << \"debug \" <<\"LINE:\"<<__LINE__<<\"  \"<< #i <<\":\"<< i << std::endl\n\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if ((a == 0)||(mod!=-1&&a%mod==0)) {\n    return 0;\n  }\n \n  long long x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P = std::pair<long long,long long>;\n\n//非再帰抽象セグ木 0-indexed 単位元はiで指定\ntemplate <class T>\nclass SegmentTree {\n private:\n\n  using F=std::function<T(T,T)>;\n\n  long long n;\n  T init;\n  std::vector<T> dat;\n  F fn;\n\n public:\n  SegmentTree(long long i, T para, F fun)\n      : init(para), fn(fun) {\n    n = 1;\n    while (n < i) {\n      n *= 2;\n    }\n    dat = std::vector<T>(2 * n - 1, init);\n  }\n\n  SegmentTree(const std::vector<T>& seq,T para,F fun)\n      : init(para),fn(fun){\n    n=1;\n    while(n<seq.size())n<<=1;\n    dat=std::vector<T>(2*n-1,init);\n    for(long long i=0;i<seq.size();i++)dat[i+n-1]=seq[i];\n    for(long long i=n-2;i>=0;i--)dat[i]=fn(dat[i*2+1],dat[i*2+2]);\n  }\n\n  // k番目(0-indexed)を値aで更新,dest=trueのときは更新前を破壊して初期化する\n  void update(long long k, T a, bool dest) {\n    assert(0<=k&&k<n);\n    k += n - 1;\n    if (dest) dat[k] = a;\n    else dat[k] = fn(dat[k], a);\n\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = fn(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n\n  //[a,b)の値を返す\n  T query(long long a, long long b){\n    assert(0<=a&&b<=n);\n    T rval=init,lval=init;\n\n    long long l=a+n-1,r=b+n-1;\n    for(;l<r;l=(l>>1),r=(r>>1)){\n      if(!(r&1)){\n        r--;\n        rval=fn(rval,dat[r]);\n      }\n      if(!(l&1)){\n        lval=fn(lval,dat[l]);\n        l++;\n      }\n    }\n\n    return fn(lval,rval);\n  }\n};\n\nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<std::vector<ll>> graph(n);\n\n  rep(i,0,n){\n    ll k;\n    std::cin>>k;\n    rep(j,0,k){\n      ll c;\n      std::cin>>c;\n      graph[i].push_back(c);\n    }\n  }\n\n  std::vector<P> tour(1,{-1,-1});\n  std::vector<ll> itr(n,-1);\n\n  auto f=[&](auto f,ll now,ll par)->void{\n    itr[now]=tour.size();\n    P e=tour.back();\n    tour.push_back({e.first+1,now});\n\n    for(ll next:graph[now]){\n      if(next!=par){\n        f(f,next,now);\n        tour.push_back({e.first+1,now});\n      }\n    }\n  };\n\n  f(f,0,-1);\n\n  SegmentTree<P> rmq(tour,{MOD,-1},[](P a,P b){return (a.first<b.first)?a:b;});\n\n  ll q;\n  std::cin>>q;\n\n  rep(_,0,q){\n    ll u,v;\n    std::cin>>u>>v;\n    ll a=itr[u],b=itr[v];\n    if(a>b)std::swap(a,b);\n    std::cout<<rmq.query(a,b+1).second<<\"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L;\n\n  std::vector<int> lg;\n  std::vector<BitIndex> small;\n  std::vector<std::vector<Index>> large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n\nprivate:\n  Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), lg(1 << S), small(N), large(L, std::vector<Index>(LG_L)) {\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li][0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li][0] = F(large[li][0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li][x + 1] = F(large[li][x], large[li + (1 << x)][x]);\n      }\n    }\n    std::vector<Index> st;\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      st.clear();\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (!st.empty() && f(i + si, st.back())) st.pop_back();\n        small[i + si] |= 1 << si;\n        if (!st.empty()) small[i + si] |= small[st.back()];\n        st.push_back(i + si);\n      }\n    }\n  }\n  int ntz(int x) const { return lg[x & -x]; }\n  int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l][x], large[r - (1 << x) + 1][x]);\n  }\n};\n#include <vector>\n#include <unordered_map>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct IoSetup { // {{{\n  IoSetup() {\n    std::ios::sync_with_stdio(0);\n    std::cin.tie(0);\n    std::cout.precision(20);\n    std::cout.setf(std::ios::fixed);\n  }\n} iosetup; //}}}\n\ninline int in(){ int x; cin >> x; return x; }\n\nint main() {\n  // std::freopen(\"in.txt\", \"r\", stdin);\n  int N = in();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = in();\n    for (int j = 0; j < k; j++) {\n      et.add_edge(i, in());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = in();\n  for (int i = 0; i < Q; i++) {\n    int u = in(), v = in();\n    cout << lca.query(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nstruct LCA {\n    int V;//頂点数\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    int MAX_LOG_V = 0;\n    int root = 0;//根ノードの番号\n\n    vector<vector<int>> parent;//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1とする)\n    vector<int> depth;//根からの深さ\n\n    LCA(int V) {\n        this->V = V;\n        while (1 << MAX_LOG_V < V) {//バグが怖い\n            MAX_LOG_V++;\n        }\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n\n    /**\n     * 辺を追加した後に初期化をする\n     */\n    void init() {\n        //parentとdepthの初期化\n        dfs(root, -1, 0);\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n\n    /**\n     * uとvのlcaを求める\n     * @param u 頂点\n     * @param v 頂点\n     * @return lcaとなる頂点\n     */\n    int lca(int u, int v) {\n        //uとvの高さが同じになるまで親を辿る\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k < MAX_LOG_V; k++) {\n            if((depth[u] - depth[v]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        //二分探索でLCAを求める\n        for (int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /**\n     * 辺を追加する\n     * @param from 元\n     * @param to 先\n     */\n    void add_edge(int from,int to){\n        G[from].push_back(to);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.init();\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val,E laz):\n      cnt(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  F f;\n  G g;\n  H h;\n  P p;\n  T ti;\n  E ei;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  LinkCutTree(F f,G g,H h,P p,T ti,E ei):\n    f(f),g(g),h(h),p(p),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v,ei));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,v);\n    t->dat=g(t->dat,p(v,t->cnt));\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    eval(t);\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\teval(q);eval(t);\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\teval(r);eval(q);eval(t);\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(c);\n    expose(par);\n    c->p=par;\n    par->r=c;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=nullptr;\n    par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  bool is_connected(Node *a,Node *b){\n    expose(a);\n    while(a->l) a=a->l;\n    expose(b);\n    while(b->l) b=b->l;\n    return a==b;\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n\n  void set_propagate(Node *t,E v){\n    expose(t);\n    propagate(t,v);\n    eval(t);\n  }\n};\n\n//END CUT HERE\n//INSERT ABOVE HERE\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT::P p=[](int a,size_t b){b++;return a;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_C\n*/\n\nsigned GRL_5_D(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return a+b;};\n  LCT::P p=[](int a,size_t b){b++;return a;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.expose(v[a]);\n      v[a]->val=f(v[a]->val,b);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_D\n*/\n\n\nsigned GRL_5_E(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<Int,Int>;\n  LCT::F f=[](Int a,Int b){return a+b;};\n  LCT::P p=[](Int a,size_t b){return a*b;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  Int c=0;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.set_propagate(v[a],b);\n      c+=b;\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat-c<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_E\n*/\n\n\nsigned main(){\n  GRL_5_C();\n  //GRL_5_D();\n  //GRL_5_E();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      //if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n#define FOR(i, a, b) for(int i = a; i < (int)b; ++i)\n#define rrep(i, n) for(int i = ((int)n - 1); i >= 0; --i)\n\nusing ll = long long;\nusing ld = long double;\n\nconst int Inf = 1e9;\nconst double EPS = 1e-9;\nconst int MOD = 1e9 + 7;\n\ntemplate <typename T>\nclass LCA {\n    public:\n        int n, log_v = 0;\n        vector<int> depth;\n        vector<T> costs;\n        vector<vector<int> > to;\n        vector<vector<T> > cost;\n        vector<vector<int> > parent;\n\n        LCA() {}\n        LCA(int n_): n(n_) {\n            while ((1 << log_v) < n) ++log_v;\n            depth.assign(n, 0);\n            costs.assign(n, 0);\n            to = vector<vector<int> >(n);\n            cost = vector<vector<T> >(n);\n            parent = vector<vector<int> >(log_v, vector<int>(n, 0));\n        }\n\n        void addEdge(int u, int v, T c = 0) {\n            to[u].push_back(v);\n            to[v].push_back(u);\n            cost[u].push_back(c);\n            cost[v].push_back(c);\n        }\n\n        void init(int root) {\n            dfs(root);\n            rep (i, log_v - 1) {\n                rep (j, n) {\n                    // if (parent[i][j] < 0) parent[i + 1][j] = -1;\n                    parent[i + 1][j] = parent[i][parent[i][j]];\n                }\n            }\n        }\n\n        void dfs(int v, int p = -1, int d = 0, T c = 0) {\n            if (p != -1) parent[0][v] = p;\n            depth[v] = d;\n            costs[v] = c;\n            rep (i, to[v].size()) {\n                int e = to[v][i];\n                if (e == p) continue;\n                dfs(e, v, d + 1, c + cost[v][i]);\n            }\n        }\n\n        int query(int u, int v) {\n            if (depth[u] > depth[v]) swap(u, v);\n            rep (i, log_v) {\n                if ((depth[v] - depth[u]) >> i & 1) v = parent[i][v];\n            }\n            if (u == v) return u;\n            rrep (i, log_v) {\n                if (parent[i][u] != parent[i][v]) {\n                    u = parent[i][u];\n                    v = parent[i][v];\n                }\n            }\n            return parent[0][u];\n        }\n\n        int length(int u, int v) {\n            return depth[u] + depth[v] - 2 * depth[query(u, v)];\n        }\n\n        // is x on the path u - v\n        bool isOnPath(int u, int v, int x) {\n            return length(u, x) + length(v, x) == length(u, v);\n        }\n\n        T dist(int u, int v) {\n            return costs[u] + costs[v] - 2 * costs[query(u, v)];\n        }\n};\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n;\n    int root;\n    LCA<int> lca = LCA<int>(n);\n    rep (i, n) {\n        int k;\n        cin >> k;\n        rep (j, k) {\n            int c;\n            cin >> c;\n            lca.addEdge(i, c);\n        }\n    }\n    lca.init(root);\n    cin >> q;\n    rep (i, q) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <iomanip>\n#include <unordered_set>\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<pair<ll,ll> > vpll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vc> vvc;\ntypedef vector<vs> vvs;\ntypedef vector<vll> vvll;\ntypedef map<int,int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define arep(i,v) for(auto i : v)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define fi first\n#define se second\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ntemplate <class T> inline void dump(T &v){irep(i, v){cout<<*i<<((i==--v.end())?'\\n':' ');}}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconstexpr ll LLINF = 1LL<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr double EPS = 1e-9;\n\nclass LCA {\n    int n;\n    static const int MAX = 20;\n    vvi doubling, v;\n\n    void init() {\n        rep(i, n) {\n            for(auto j : v[i]) {\n                doubling[0][j] = i;\n            }\n        }\n        for(int i = 1; i < MAX; i++) {\n            rep(j, n) {\n                doubling[i][j] = doubling[i - 1][doubling[i - 1][j]];\n            }\n        }\n        depth[0] = 0;\n        dfs(0, -1);\n    }\n\n    void dfs(const int crrPos, const int befPos) {\n        for(auto i : v[crrPos]) {\n            if(i == befPos || depth[i] != -1) {\n                continue;\n            }\n            depth[i] = depth[crrPos] + 1;\n            dfs(i, crrPos);\n        }\n    }\n\n    // ダブリングでVのnum個親の祖先を調べる\n    int doublingNode(int V, const int num) {\n        rep(i, MAX) {\n            if((1LL<<i) & num) {\n                V = doubling[i][V];\n            }\n        }\n        return V;\n    }\n\npublic:\n    vi depth;\n\n    LCA(vvi &_v) : v(_v), n(_v.size()) {\n        doubling = vvi(MAX, vi(n, 0));\n        depth = vi(n, -1);\n        init();\n    }\n\n    void show_doubling(const int height = MAX) {\n        rep(i, height) {\n            dump(doubling[i]);\n        }\n        dump(depth);\n    }\n\n    int lca(int A, int B) {\n        // Aのが深い位置にあるようにする\n        if(depth[A] < depth[B]) {\n            swap(A, B);\n        }\n        A = doublingNode(A, depth[A] - depth[B]);\n        if(A == B) {\n            return A;\n        }\n        \n        int ng = -1;\n        int ok = depth[A] + 1;\n        while(abs(ng - ok) > 1) {\n            int mid = (ng + ok)/2;\n            if(doublingNode(A, mid) != doublingNode(B, mid)) {\n                ng = mid;\n            }\n            else ok = mid;\n        }\n        return  doublingNode(A, ng + 1);\n    }\n};\n\nint main() {\n    \n    int n, Q, k, V, A, B;\n    scanf(\"%d\", &n);\n    vvi v(n);\n    \n    rep(i, n) {\n        scanf(\"%d\", &k);\n        rep(j, k) {\n            scanf(\"%d\", &V);\n            v[i].pb(V);\n        }\n    }\n    LCA lca(v);\n    scanf(\"%d\", &Q);\n    rep(_, Q) {\n        scanf(\"%d %d\", &A, &B);\n        printf(\"%d\\n\", lca.lca(A, B));\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nvector<int> t[100000];\nint d[100000];\nint s[100000][17];\nint q;\n\nvoid dfs(int x){\n\trep(i, t[x].size()){\n\t\tint y = t[x][i];\n\t\td[y] = d[x] + 1;\n\t\tdfs(y);\n\t}\n}\n\nvoid init(){\n\trep(i, n){\n\t\tfill_n(s[i], 17, -1);\n\t}\n\n\trep(i, n){\n\t\trep(j, t[i].size()){\n\t\t\ts[t[i][j]][0] = i;\n\t\t}\n\t}\n\n\tfor(int i = 1; i < 17; ++i){\n\t\trep(j, n){\n\t\t\tint p = s[j][i - 1];\n\t\t\ts[j][i] = p != -1 ? s[p][i - 1] : -1;\n\t\t}\n\t}\n}\n\nint up(int i, int x){\n\trep(j, 17){\n\t\tif(x & (1 << j)){\n\t\t\ti = s[i][j];\n\t\t}\n\t}\n\treturn i;\n}\n\nint lca(int u, int v){\n\tif(d[u] > d[v]){\n\t\tswap(u, v);\n\t}\n\tv = up(v, d[v] - d[u]);\n\n\tif(u == v){\n\t\treturn u;\n\t}\n\n\tfor(int i = 16; i >= 0; --i){\n\t\tif(s[u][i] != s[v][i]){\n\t\t\tu = s[u][i];\n\t\t\tv = s[v][i];\n\t\t}\n\t}\n\treturn s[u][0];\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\trep(j, k){\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tt[i].push_back(c);\n\t\t}\n\t}\n\n\tdfs(0);\n\n\tinit();\n\n\tscanf(\"%d\", &q);\n\trep(i, q){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tprintf(\"%d\\n\", lca(a, b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\n#include <functional>\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> P;\n\nclass LcaTree {\npublic:\n    int N;\n    int logN = 1;\n    int root;\n    vector<vector<int>> G;\n    vector<vector<int>> parent;\n    vector<int> depth;\n\n    LcaTree(int _N, int _root){\n        N = _N;\n        root = _root;\n        G.resize(N);\n        while((1 << logN) < N) logN++;\n        parent.resize(logN, vector<int>(N));\n        depth.resize(N);\n    }\n\n    void make_edge(int s, int t){\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n\n    //parent[0]とdepthの初期化\n    void dfs(int n, int par, int d){\n        parent[0][n] = par;\n        depth[n] = d;\n        for(int i = 0; i < (int)G[n].size(); i++){\n            int nx = G[n][i];\n            if(nx != par) dfs(nx, n, d + 1);\n        }\n    }\n\n    void init(){\n        dfs(root, -1, 0);\n\n        //parentの初期化\n        for(int k = 0; k < logN - 1; k++){\n            for(int i = 0; i < N; i++){\n                if(parent[k][i] < 0) parent[k + 1][i] = -1;\n                else parent[k + 1][i] = parent[k][parent[k][i]];\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        //uとvが同じ深さになるまでたどる\n        if(depth[u] > depth[v]) swap(u, v); //u < v\n\n        for(int k = 0; k < logN; k++){\n            if((depth[v] - depth[u]) & (1 << k)){\n                v = parent[k][v];\n            }\n        }\n\n        if(u == v) return u;\n\n        for(int k = logN - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n};\n\n//////////////////////////////////////////////////////////////////////\n\nint main(){\n    int N;\n    cin >> N;\n\n    LcaTree tr = LcaTree(N, 0);\n\n    for(int i = 0; i < N; i++){\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; j++){\n            int c;\n            cin >> c;\n            tr.make_edge(i, c);\n            //cout << \"make_edge \" << i << \" \" << c << endl;\n        }\n    }\n\n    tr.init();\n\n    int Q;\n    cin >> Q;\n    vector<int> ans;\n    for(int q = 0; q < Q; q++){\n        //cout << q << endl;\n        int u, v;\n        cin >> u >> v;\n        ans.push_back(tr.lca(u, v));\n    }\n\n    for(int x : ans){\n        cout << x << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct Node{\n  int id,val,parent,size,in,out;\n  vector<int> children;\n  Node(){}\n  Node(int id,int v,vector<int>ch):id(id),val(v),children(ch){}\n};\n\ntypedef vector<Node> Tree;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>path,pathSize,pathPos,pathRoot;\n  Tree tree;//, len;\n  \n  HeavyLight(Tree tree)\n    :pathCount(0),n(tree.size()),path(n),pathSize(n),pathPos(n),pathRoot(n),tree(tree){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    /*\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    tree[u].in=k++, tree[u].parent=p, tree[u].size=1;\n    EACH(v,tree[u].children)if(*v!=p)dfs(*v, u, k),tree[u].size+=tree[*v].size;\n    tree[u].out=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u].children)if(*v != tree[u].parent)\n      buildPaths(*v, 2* tree[*v].size >= tree[u].size ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return tree[p].in <= tree[ch].in && tree[ch].out <= tree[p].out;\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=tree[root].parent);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=tree[root].parent);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  Tree tree(n);\n  \n  REP(i,n){\n    tree[i].id=i;\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].children.push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t{\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n  bool rev;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL;\n    rev=false; \n    lazy=0; \n    update();\n  }\n   \n  void update(){\n    mini=val,minId=id;\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>=rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  void apply(int v){ lazy+=v, val+=v, mini+=v; }\n   \n  void push(){\n    if(rev){\n      rev=false;\n      swap(lp,rp);\n      if(lp)lp->rev^=true;\n      if(rp)rp->rev^=true;\n    }\n    if(lp)lp->apply(lazy);\n    if(rp)rp->apply(lazy);\n    lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  x->splay();\n  return rp;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n  c->update();\n}\n\n//Unverified.\nvoid evert(node_t *p){\n  expose(p);\n  p->rev^=true;\n}\n\n//Verified.\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->apply(val); }\n\n//Verified. AOJ GRL_5_C\nnode_t *LCA(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\n//AOJ GRL_5_C\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << LCA(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef vector<int> V;\n\nint n;\nV t[100000];\nint d[100000];\nint p[17][100000];\n\nvoid dfs(int x){\n\tfor(int i: t[x]){\n\t\td[i] = d[x] + 1;\n\t\tp[0][i] = x;\n\t\tdfs(i);\n\t}\n}\nvoid init(){\n\tp[0][0] = -1;\n\tdfs(0);\n\tfor(int i = 1; i < 17; ++i){\n\t\trep(j, n){\n\t\t\tint v = p[i - 1][j];\n\t\t\tp[i][j] = v != -1 ? p[i - 1][v] : -1;\n\t\t}\n\t}\n}\n\nint up(int v, int x){\n\trep(i, 17){\n\t\tif(x >> i & 1){\n\t\t\tv = p[i][v];\n\t\t}\n\t}\n\treturn v;\n}\nint lca(int u, int v){\n\tif(d[u] > d[v]){\n\t\tswap(u, v);\n\t}\n\tv = up(v, d[v] - d[u]);\n\tif(u == v){\n\t\treturn u;\n\t}\n\tfor(int i = 17 - 1; i >= 0; --i){\n\t\tif(p[i][u] != p[i][v]){\n\t\t\tu = p[i][u];\n\t\t\tv = p[i][v];\n\t\t}\n\t}\n\treturn p[0][u];\n}\n\nint main(){\n\tcin >> n;\n\trep(i, n){\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j, k){\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tt[i].push_back(c);\n\t\t}\n\t}\n\n\tinit();\n\n\tint q;\n\tcin >> q;\n\trep(i, q){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca(u, v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint m = 31;\nbool vis[100005] = {false};\nint depth[100005], parent[100005][32];\nvector <int> adj[100005];\nvoid dfs(int v, int d) {\n\tvis[v] = true;\n\tdepth[v] = d;\n\tfor(int i = 0; i < adj[v].size(); i++)\n\t\tif(!vis[adj[v][i]]) dfs(adj[v][i], d + 1);\n\treturn;\n}\nint lca(int u, int v) {\n\tif(depth[u] < depth[v]) swap(u, v);\n\tint z = depth[u] - depth[v];\n\tfor(int i = 0; i < m; i++)\n\t\tif((z >> i) & 1) u = parent[u][i];\n\tfor(int i = m - 1; i >= 0; i--)\n\t\tif(parent[u][i] != parent[v][i]) {\n\t\t\tu = parent[u][i];\n\t\t\tv = parent[v][i];\n\t\t}\n\treturn parent[u][0];\n}\nint main() {\n\tint n, q, i, j, u, v, c, k;\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\twhile(k--) {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tadj[i].push_back(c);\n\t\t\tparent[c][0] = i;\n\t\t}\n\t}\n\tfor(j = 1; j < m; j++)\n\t\tfor(i = 0; i < n; i++)\n\t\t\tparent[i][j] = parent[parent[i][j - 1]][j - 1];\n\tdfs(0, 0);\n\tscanf(\"%d\", &q);\n\twhile(q--) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100000\n#define MAX_LOG 30\nvector<int>G[MAX];\nint depth[MAX];\nint parent[MAX_LOG][MAX];\nint root;\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0;i<G[v].size();i++){\n    if(G[v][i]!=p)dfs(G[v][i],v,d+1);\n  }\n}\nvoid init(int V){\n  //parent??¨dfs??????????????????\n  dfs(root,-1,0);\n  //parent??????????????????\n  for(int k=0;k+1<MAX_LOG;k++){\n    for(int v=0;v<V;v++){\n      if(parent[k][v]<0)parent[k+1][v]=-1;\n      else parent[k+1][v]=parent[k][parent[k][v]];\n    }\n  }\n}\nint lca(int u,int v){\n  if(depth[u]>depth[v])swap(u,v);\n  for(int k=0;k<MAX_LOG;k++){\n    if((depth[v]-depth[u])>>k&1){\n      v=parent[k][v];\n    }\n  }\n  if(u==v)return u;\n  for(int k=MAX_LOG-1;k>=0;k--){\n    if(parent[k][u]!=parent[k][v]){\n    u=parent[k][u];\n    v=parent[k][v];\n  }\n  }\n  return parent[0][u];\n}\nint main(){\n  root=0;\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int p=0;\n    cin>>p;\n    while(p--){\n      int t;\n      cin>>t;\n      G[i].push_back(t);\n    }\n  }\n  init(n);\n  int p;\n  cin>>p;\n  while(p--){\n    int q,w;\n    cin>>q>>w;\n    cout<<lca(q,w)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100001;\nint N, k, cs, P[maxn], lca[maxn][17], L[maxn], Q;\nvector<int> A[maxn];\n\n\nvoid dfs( int v, int lvl ){\n\n\tL[v] = lvl;\n\tvector<int>::iterator x = A[v].begin();\n\tfor( ; x != A[v].end(); ++x )\n\t\tdfs( *x, lvl + 1 );\n}\n\n\nvoid preLCA(){\n\n\tfor( int i = 0; i < N; ++i )\n\t\tfor( int j = 0; ( 1 << j ) < N; ++j )\n\t\t\tlca[i][j] = -1;\n\n\t\t\t\n\tfor( int i = 0; i < N; ++i )\n\t\tlca[i][0] = P[i];\n\n\n\tfor( int i = 1; ( 1 << i) < N; ++i )\n\t\tfor( int j = 0; j < N; ++j )\n\t\t\tif(lca[j][i] != - 1)\n\t\t\t\tlca[j][i] = lca[lca[j][i - 1]][i - 1];\n}\n\nint findlca( int nx, int ny ){\n\n\tif( L[nx] < L[ny] )\n\t\tswap(nx, ny);\n\n\tint lg = 0;\n\n\tfor( ; (1 << lg) <= L[nx]; ++lg );\n\t--lg;\n\n\tfor( int i = lg; i >= 0; --i )\n\t\tif( L[nx] - ( 1 << i) >= L[ny] )\n\t\t\tnx = lca[nx][i];\n\n\tif( nx == ny )\n\t\treturn nx;\n\n\tfor( int i = lg; i >= 0; --i )\n\t\tif( lca[nx][i] != -1 && lca[nx][i] != lca[ny][i] )\n\t\t\tnx = lca[nx][i], ny = lca[ny][i];\n\n\treturn P[nx];\n}               \n\n\n\n\n\n\nint main( void ){\n\n\t//freopen(\"input.in\", \"r\", stdin);\n    scanf(\"%d\", &N);\n\n    for( int i = 0; i < N; ++i ){\n    \tscanf(\"%d\", &k);\n    \tfor( int j = 0; j < k; ++j )\n    \t\tscanf(\"%d\", &cs), A[i].push_back(cs), P[cs] = i; \n    }\n\t\n\tdfs(0, 0);\n\tpreLCA();\n\tscanf(\"%d\", &Q);\n\tint a, b;\n\tfor( ; Q > 0; --Q ){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tprintf(\"%d\\n\", findlca(a, b));\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\n\nvector<int> G[V_MAX];\nvector<bool> used(V_MAX,false);\nvector<int> visit;\nvector<int> first_visit(V_MAX,-1);\nvector<int> dat(20*V_MAX,INT_MAX);\nint counter=0;\nint n;\n\nvoid vector_out(vector<int> &vec,int k){\n\tfor (int i=0;i<k;i++){\n\t\tcout << vec[i] << endl;\n\t}\n}\n\nvoid dfs(int s){\n\tif(used[s]==true){return;}\n\tused[s]=true;\n\tvisit.push_back(s);\n\tfirst_visit[s]=counter;\n\tcounter++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(used[G[s][i]]==false){\n\t\t\tdfs(G[s][i]);\n\t\t\tvisit.push_back(s);\n\t\t\tcounter++;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid update(int k, int a){\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int l,int r,int k){\n\tif(r<=a || b<=l){\n\t\treturn INT_MAX;\n\t}\n\tif(a<=l && r<=b){\n\t\treturn dat[k];\n\t}else{\n\t\treturn min(query(a,b,l,(l+r)/2,2*k+1),query(a,b,(l+r)/2,r,2*k+2));\n\t}\n}\n\nint LCA(int u,int v,int n){\n\tu=first_visit[u];\n\tv=first_visit[v];\n\tint x = min(u,v);\n\tint y = max(u,v);\n\treturn query(x,y+1,0,n+1,0);\n}\n\nint main(){\n\tint V,deg,to;\n\tcin>> V ;\n\tfor (int i=0;i<V;i++){\n\t\tcin >> deg;\n\t\tfor(int j=0;j<deg;j++){\n\t\t\tcin >> to;\n\t\t\tG[i].push_back(to);\n\t\t}\n\t}\n\tdfs(0);\n\t\n\tint R = visit.size();\n\t\n\tn=1;\n\twhile(n<R){\n\t\tn=2*n;\n\t}\n\t\n\tfor(int i=0;i<R;i++){\n\t\tupdate(i,visit[i]);\n\t}\n\t\n\tint Q;\n\tcin >> Q ;\n\t\n\tif(V==1){\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tcout << 0 <<endl;\n\t\t}\n\t}else{\n\t\tfor (int i=0;i<Q;i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tcout << LCA(x,y,n) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100001\n#define LOG_MAX 30\nint n,q;\nvector<int> g[N];\nint root;\nint par[N][LOG_MAX];\nint depth[N];\n\nvoid dfs(int x,int d){\n  depth[x]=d;\n  //cout<<x<<endl;\n  for(int i=0;i<g[x].size();i++){\n    par[g[x][i]][0]=x;\n    dfs(g[x][i],d+1);\n  }\n}\n\nint KthAns(int u,int k){\n  for(int i=0;i<LOG_MAX;i++){\n    if(u==-1)return -1;\n    if(k>>i&1)u=par[u][i];\n  }\n  return u;\n}\n\nvoid build(){\n  dfs(root,0);\n  par[root][0]=-1;\n  for(int i=1;i<LOG_MAX;i++)\n    for(int j=0;j<n;j++){\n      if(par[j][i-1]==-1)par[j][i]=-1;\n      else par[j][i]=par[par[j][i-1]][i-1];\n    }\n}\n\nint lca(int u,int v){\n  //cout<<u<<\" \"<<v<<endl;\n  if(depth[u]>depth[v])swap(u,v);\n  v=KthAns(v,depth[v]-depth[u]);\n  if(u==v)return u;\n  for(int i=LOG_MAX-1;i>=0;i--){\n    int up=par[u][i];\n    int vp=par[v][i];\n    //cout<<u<<\" \"<<v<<endl;\n    if(up==vp)continue;\n    u=up,v=vp;\n  }\n  return par[u][0];\n}\n\nint main(){\n  root=0;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int k,c;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      cin>>c;\n      g[i].push_back(c);\n    }\n  }\n  build();\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca(u,v)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long MOD = 1'000'000'007LL;\nconst long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nll clz(ll x) {\n\tfor (ll i = 31; i >= 0; i--) {\n\t\tif ((x >> i) & 1) {\n\t\t\treturn 31 - i;\n\t\t}\n\t}\n}\n\ntemplate< typename G >\nstruct DoublingLowestCommonAncestor {\n\tconst int LOG;\n\tvector< int > dep;\n\tconst G &g;\n\tvector< vector< int > > table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - clz(g.size())) {\n\t\ttable.assign(LOG, vector< int >(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d) {\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor (auto &to : g[idx]) {\n\t\t\tif (to != par) dfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build() {\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; k++) {\n\t\t\tfor (int i = 0; i < table[k].size(); i++) {\n\t\t\t\tif (table[k][i] == -1) table[k + 1][i] = -1;\n\t\t\t\telse table[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v) {\n\t\tif (dep[u] > dep[v]) swap(u, v);\n\t\tfor (int i = LOG - 1; i >= 0; i--) {\n\t\t\tif (((dep[v] - dep[u]) >> i) & 1) v = table[i][v];\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int i = LOG - 1; i >= 0; i--) {\n\t\t\tif (table[i][u] != table[i][v]) {\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\nint main()\n{\n  int N, Q;\n  scanf(\"%d\", &N);\n  vector<vector<int>> g(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    while(k--) {\n      int c;\n      scanf(\"%d\", &c);\n      g[i].push_back(c);\n    }\n  }\n  DoublingLowestCommonAncestor< vector<vector<int>> > lca(g);\n  lca.build();\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    printf(\"%d\\n\", lca.query(x, y));\n  }\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nconst int N=100010;\nvector<int>graph[N];\nint dep[N],p[20][N];\nvoid go(int now){\n\tfor(int i=0;i<graph[now].size();i++){\n\t\tdep[graph[now][i]]=dep[now]+1;\n\t\tp[0][graph[now][i]]=now;\n\t\tgo(graph[now][i]);\n\t}\n\treturn;\n}\nint LCA(int l,int r){\n\tif(dep[l]<dep[r])swap(l,r);\n\tfor(int i=19;i>=0;i--){\n\t\tif(dep[p[i][l]]>=dep[r]){\n\t\t\tl=p[i][l];\n\t\t}\n\t}\n\tfor(int i=19;i>=0;i--){\n\t\tif(p[i][l]!=p[i][r]){\n\t\t\tl=p[i][l];\n\t\t\tr=p[i][r];\n\t\t}\n\t}\n\tif(l!=r)return p[0][l];\n\telse return l;\n}\nint main(){\n\tint n,k,temp,q,l,r;\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;j++){\n\t\t\tscanf(\"%d\",&temp);\n\t\t\tgraph[i].push_back(temp);\n\t\t}\n\t}\n\tgo(0);\n\tfor(int i=1;i<20;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp[i][j]=p[i-1][p[i-1][j]];\n\t\t}\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tprintf(\"%d\\n\",LCA(l,r));\n\t}\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 200000;\nconst int INF = 2147483647;\n\nint n;\nP v[2 * MAX_N - 1];\n\nvoid init(int _n){\n  n = 1;\n  while(n < _n) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(INF, INF);\n}\n\nvoid update(int k, P a){\n  k += n - 1;\n  v[k] = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = v[k * 2 + 1].first < v[k * 2 + 2].first ? v[k * 2 + 1] : v[k * 2 + 2];\n  }\n}\n\nP query(int a, int b, int k, int l, int r){\n  if(b <= l || a >= r) return P(INF, INF);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return min(vl, vr);\n}\n\nint id[MAX_N], vs[MAX_N * 2 - 1];\n\nvoid dfs(int v, int prev, int d, int &k, vector< vector<int> > &G, int *id, int *vs, int *depth){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  REP(i, G[v].size()){\n    if(G[v][i] != prev){\n      dfs(G[v][i], v, d + 1, k, G, id, vs, depth);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid lca_init(int N, int root, vector< vector<int> > &G){\n  int k = 0, depth[MAX_N * 2 - 1];\n  dfs(root, -1, 0, k, G, id, vs, depth);\n  init(N * 2 - 1);\n  REP(i, N * 2 - 1) update(i, P(depth[i], vs[i]));\n}\n\nint lca(int a, int b){\n  return query(min(id[a], id[b]), max(id[a], id[b]) + 1, 0, 0, n).second;\n}\n\nint main() {\n  int N; cin >>N;\n  vector< vector<int> > G(N);\n  REP(i, N){\n    int k; cin >>k;\n    REP(j, k){\n      int c; cin >>c;\n      G[i].push_back(c);\n    }\n  }\n  lca_init(N, 0, G);\n  int Q; cin >>Q;\n  REP(q, Q){\n    int a, b; cin >>a >>b;\n    cout <<lca(a, b) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nusing Weight = int;\nstruct Edge {\n\tint s, d; Weight w;\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nstruct LowestCommonAncestor {\n\tconst int n, log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\tLowestCommonAncestor(const Graph &g, int root)\n\t\t:n(g.size()), log2_n(log2(n) + 1), parent(log2_n, vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph &g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (e.d != p) dfs(g, e.d, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tGraph g(n);\n\trep(i, 0, n) {\n\t\tint k; cin >> k;\n\t\trep(j, 0, k) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(i, c);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tLowestCommonAncestor lca(g, 0);\n\trep(i, 0, q) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << lca.get(u, v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n// -------------8<------- start of library -------8<------------------------\nstruct LowestCommonAncestor {\n    const int root, INF, n;\n    int size, no;\n    std::vector<std::vector<int>> adj;\n    std::vector<int> idx;\n    std::vector<std::pair<int, int>> dep;\n\n    LowestCommonAncestor(int _n, int _r = 0) :\n        root(_r), INF(INT_MAX), n(_n), adj(n), idx(n) {}\n\n    void add_edge(int u, int v) { adj[u].push_back(v); adj[v].push_back(u); }\n\n    void Dfs(int cur, int p, int d) {\n        idx[cur] = no;\n        dep[size - 1 + no++] = std::make_pair(d, cur);\n        for (int nxt : adj[cur]) {\n            if (nxt != p) {\n                Dfs(nxt, cur, d + 1);\n                dep[size - 1 + no++] = std::make_pair(d, cur);\n            }\n        }\n    }\n\n    void Preprocessing() {\n        for (size = 1; size < 2 * n - 1; ) size <<= 1;\n        dep.assign(2 * size - 1, std::make_pair(INF, INF));\n\n        no = 0;\n        Dfs(root, -1, 0);\n\n        for (int i = size - 2; 0 <= i; --i)\n            dep[i] = std::min(dep[2 * i + 1], dep[2 * i + 2]);\n    }\n\n    int rmq(int l, int r) {\n        std::pair<int, int> res(INF, INF);\n        l += size - 1;\n        r += size - 1;\n        while (l < r) {\n            if ((l & 1) == 0) res = std::min(res, dep[l]);\n            if ((r & 1) == 0) res = std::min(res, dep[r - 1]);\n            l >>= 1;\n            r = (r - 1) >> 1;\n        }\n        return res.second;\n    }\n\n    int query(int u, int v) {\n        if (idx[v] < idx[u]) std::swap(u, v);\n        return rmq(idx[u], idx[v] + 1);\n    }\n};\n// -------------8<------- end of library ---------8-------------------------\n\nint main() {\n    std::cin.tie(0); std::ios::sync_with_stdio(false);\n\n    // AOJ GRL_5_C: Tree - Lowest Common Ancestor\n    int n;\n    std::cin >> n;\n\n    LowestCommonAncestor lca(n, 0);\n    for (int v = 0, deg, c; v < n; ++v) {\n        std::cin >> deg;\n        while (deg--) {\n            std::cin >> c;\n            lca.add_edge(v, c);\n        }\n    }\n    lca.Preprocessing();\n\n    int q, u, v;\n    std::cin >> q;\n    while (q--) {\n        std::cin >> u >> v;\n        std::cout << lca.query(u, v) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nint h, w, n, m, k, s, t, q, ans, sum, last, cnt;\nstruct Edge { int to,cost; };\nvector<Edge>vec[100010];\nstring str;\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tint n;\n\tvector<int>node, num;\n\tSeg(int n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = std::numeric_limits<int>::max();\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t}\n\tvoid update(int i, int x,int u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tPll find(int i, int a, int b, int l, int r) {\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n};\nstruct vertex {\n\tint l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<int>root;\n\tint num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tint u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tvec[u].erase(vec[u].begin()+j);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    const vector<vector<int>> &g;\n    int h;\n    vector<vector<int>> par;    // par[k][v] := 2^k-th parent of v\n    vector<int> dep, ord;\n    LowestCommonAncestor(const vector<vector<int>> &g, int r = 0)\n        : g(g), dep(g.size()), ord(g.size()) { build(r); }\n    void build(int r) {\n        int V = g.size(), id = 0;\n        h = 1; while ((1 << h) < V) ++h;        // 32 - __builtin_clz(V)\n        par.assign(h, vector<int>(V, -1));\n        dfs(r, -1, 0, id);\n        for (int k = 0; k + 1 < h; ++k) for (int v = 0; v < V; ++v) {\n            if (par[k][v] != -1) par[k + 1][v] = par[k][par[k][v]];\n        }\n    }\n    void dfs(int u, int p, int d, int &id) {\n        par[0][u] = p;\n        dep[u] = d;\n        ord[u] = id++;\n        for (auto v: g[u]) if (v != p) dfs(v, u, d + 1, id);\n    }\n    int get(int u, int v) {\n        if (dep[u] > dep[v]) swap(u, v);\n        for (int k = 0; k < h; ++k) {\n            if ((dep[v] - dep[u]) >> k & 1) v = par[k][v];\n        }\n        if (u == v) return u;\n        for (int k = h - 1; k >= 0; --k) {\n            if (par[k][u] != par[k][v]) u = par[k][u], v = par[k][v];\n        }\n        return par[0][u];\n    }\n    int ancestor(int u, int k) {\n        for (int i = h - 1; i >= 0; i--) if (k >> i & 1) u = par[i][u];\n        return u;\n    }\n    int dist(int u, int v) { return dep[u] + dep[v] - dep[get(u, v)] * 2; }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n; i++) {\n        int k; cin >> k;\n        while (k--) {\n            int c; cin >> c;\n            g[i].emplace_back(c);\n            g[c].emplace_back(i);\n        }\n    }\n    LowestCommonAncestor lca(g);\n    int q; cin >> q;\n    while (q--) {\n        int u, v; cin >> u >> v;\n        cout << lca.get(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\ntypedef long long int ll;\ntypedef pair<int, int> P;\nstruct Edge { long long to; };\nusing Graph = vector<vector<Edge>>;\n\nint n, q;\nGraph G; //LCAの外で持っておく\n\nstruct LCA\n{\n  vector<vector<int>> parent;\n  vector<long long> dist;\n  LCA(const Graph &G, int root)\n  {\n    init(G, root);\n  }\n  \n  void init(const Graph &G, int root)\n  {\n    int n = G.size();\n    int m = 1;\n    while((1 << m) < n) m++;\n    parent.assign(m, vector<int>(n, -1));\n    dist.assign(n, -1);\n    dfs(G, root, 0, -1);\n    //ダブリング\n    for(int i = 0; i < m-1; i++)\n    {\n      for(int j = 0; j < n; j++)\n      {\n        if(parent[i][j] < 0) parent[i][j] = -1;\n        else parent[i+1][j] = parent[i][parent[i][j]];\n      }\n    }\n  }\n  \n  void dfs(const Graph &G, int a, int pa, int dep)\n  {\n    parent[0][a] = pa;\n    dist[a] = dep;\n    for(auto e : G[a])\n    {\n      if(e.to != pa)\n        dfs(G, e.to, a, dep+1);\n    }\n  }\n  \n  long long query(int u, int v)\n  {\n    int m = parent.size();\n    \n    //深さをu >= vとする\n    if(dist[u] < dist[v]) swap(u, v);\n    //深さを揃える\n    for(int i = 0; i < m; i++)\n    {\n      if((dist[u] - dist[v]) & (1 << i))\n      {\n        u = parent[i][u];\n      }\n    }\n    \n    //ダブリング（二分探索）でLCAを求める\n    if(u == v) return u;\n    for(int i = m - 1; i >= 0; i--) //大きい桁から見ていく\n    {\n      if(parent[i][u] != parent[i][v])\n      {\n        u = parent[i][u];\n        v = parent[i][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nvoid init()\n{\n  cin >> n;\n  G.assign(n, vector<Edge>(0));\n  rep(i, n)\n  {\n    int k;\n    cin >> k;\n    rep(j,k)\n    {\n      ll c;\n      cin >> c;\n      Edge e;\n      e.to = c;\n      G[i].emplace_back(e);\n    }\n  }\n}\n\nvoid solve()\n{\n  LCA lca(G, 0);\n  cin >> q;\n  rep(i, q)\n  {\n    int a, b;\n    cin >> a >> b;\n    cout << lca.query(a, b) << \"\\n\";\n  }\n  //rep(i,n){ for(auto e : G[i]) cout << e.to << \" \"; cout << endl;}\n  return;\n}\n\nint main()\n{\n  init();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream &operator << (ostream& out,const pair<S,T>& o){\n    out << \"(\" << o.first << \",\" << o.second << \")\"; return out;\n}\n\n\nstruct edge{\n    ll u,v,c;\n    edge():u(0),v(0),c(0){}\n    edge(ll u,ll v,ll c):u(u),v(v),c(c){}\n};\ntypedef vector<vector<edge>> Graph;\nGraph G;\nclass LCA{\npublic:\n    const ll n = 0;\n    const ll log2_n = 0;\n    vector<vector<ll>> parent;\n    vector<ll> depth;\n    LCA();\n    LCA(const Graph &g,ll root):n((ll)g.size()),log2_n(log2(n)+1),parent(log2_n,vector<ll>(n)),depth(n){\n        dfs(g,root,-1,0);\n        for(int k = 0; k+1 < log2_n; k++){\n            for(int v = 0; v < (int)g.size();v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n    \n    void dfs(const Graph &g,ll v,ll p,ll d){\n        parent[0][v] = p; depth[v] = d;\n        for(auto &e :g[v]){\n            if(e.v != p) dfs(g, e.v, v, d+1);\n        }\n    }\n    \n    ll get(ll u,ll v){\n        if(depth[u] > depth[v]) swap(u,v);\n        for(int k = 0; k < log2_n; k++){\n            if(((depth[v]-depth[u])>>k) & 1) v = parent[k][v];\n        }\n        if(u == v) return u;\n        for(int k = (int)log2_n - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u]; v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    G.resize(n);\n    for(int i = 0; i < n;i++){\n        ll k; cin >> k;\n        for(int j = 0; j < k;j++){\n            ll c; cin >> c;\n            G[i].push_back(edge(i,c,0));\n            G[c].push_back(edge(c,i,0));\n        }\n    }\n    LCA lca(G,0);\n    ll q; cin >> q;\n    while(q--){\n        ll u,v; cin >> u >> v;\n        cout << lca.get(u,v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << endl;\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\nll MOD = 1e9+7;\n\n// by RMQ\nstruct LCA {\n    typedef pair<ll, int> ST;  // depth, index\n\n    vector<ST> E;\n    vector<ll> O, depth;\n    vector<vi> to;\n\n    struct SegTree {\n        int N;\n        vector<ST> dat;\n\n        int get_n(int n) {\n            int ret = 1;\n            while (ret < n) ret <<= 1;\n\n            return ret;\n        }\n\n        SegTree() : N(0) {}\n\n        // {depth, index}\n        explicit SegTree(const vector<ST> &v) {\n            N = get_n(v.size());\n            dat.resize(2 * N - 1, {INF, inf});\n\n            REP(i, v.size()) dat[N + i - 1] = v[i];\n            for (int i = N - 2; i > -1; --i) dat[i] = _op(dat[2 * i + 1], dat[2 * i + 2]);\n        }\n\n        ST _op(const ST& a, const ST& b) {\n            if (a.fi > b.fi) return b;\n            return a;\n        }\n\n        void _up(ST &a, const ST& b) {\n            a = b;\n        }\n\n        void update(int i, ST v) {\n            i += N - 1;\n            _up(dat[i], v);\n\n            while (i > 0) {\n                i = (i - 1) / 2;\n                dat[i] = _op(dat[2 * i + 1], dat[2 * i + 2]);\n            }\n        }\n\n        // query for [a, b), k: current node id, [l, r): current range.\n        ST query(int a, int b, int k = 0, int l = 0, int r = -1) {\n            if (r < 0) r = N;\n\n            if (b <= l || r <= a) return {INF, inf};\n            if (a <= l && r <= b) return dat[k];\n\n            int mid = (l + r) / 2;\n            ST c1 = query(a, b, 2 * k + 1, l, mid);\n            ST c2 = query(a, b, 2 * k + 2, mid, r);\n\n            return _op(c1, c2);\n        }\n    } seg;\n\n    LCA(int n = 0): to(n), O(n, -1), depth(n) {};\n\n    void add_edge(int a, int b) {\n        to[a].pb(b);\n        to[b].pb(a);\n    }\n\n    void init(int root) {\n        dfs(root); // euler tour\n        seg = SegTree(E);\n    }\n\n    ST query(int a, int b) {\n        int c = O[a], d = O[b];\n        if (c > d) swap(c, d);\n\n        return seg.query(c, d + 1); // return LCA's depth from root\n    }\n\n    void dfs(int v, int p = -1, int d = 0) {\n        E.eb(d, v);\n        depth[v] = d;\n        if(O[v] == -1) O[v] = E.size() - 1;\n\n        for(int u : to[v]) {\n            if (u == p) continue;\n            dfs(u, v, d + 1);\n            E.eb(d, v);\n        }\n    }\n};\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=ja\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int n; cin >> n;\n\n    LCA g(n);\n\n    REP(i, n) {\n        int k; cin >> k;\n        REP(j, k) {\n            int c; cin >> c;\n            g.add_edge(i, c);\n        }\n    }\n\n    g.init(0);\n\n    debug(g.depth, g.E)\n\n    int q; cin >> q;\n    REP(i, q) {\n        int u, v; cin >> u >> v;\n\n        print(g.query(u, v).second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nstruct LCA {\n    int V;//頂点数\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    int MAX_LOG_V = 0;\n    int root = 0;//根ノードの番号\n\n    vector<vector<int>> parent;//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1とする)\n    vector<int> depth;//根からの深さ\n\n    LCA(int V) {\n        this->V = V;\n        while (1 << MAX_LOG_V <= V) {//バグが怖い\n            MAX_LOG_V++;\n        }\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n\n    /**\n     * 辺を追加した後に初期化をする\n     */\n    void init() {\n        //parentとdepthの初期化\n        dfs(root, -1, 0);\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n\n    /**\n     * uとvのlcaを求める\n     * @param u 頂点\n     * @param v 頂点\n     * @return lcaとなる頂点\n     */\n    int lca(int u, int v) {\n        //uとvの高さが同じになるまで親を辿る\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k < MAX_LOG_V; k++) {\n            if((depth[u] - depth[v]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        //二分探索でLCAを求める\n        for (int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /**\n     * 辺を追加する\n     * @param from 元\n     * @param to 先\n     */\n    void add_edge(int from,int to){\n        G[from].push_back(to);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.init();\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\nconst int logn=20;\n\nint n,q,l;\nint dep[maxn];\nint up[maxn][logn];\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n    dep[u]=dep[p]+1;\n    up[u][0]=p;\n    for (int i=0;i<l;i++) up[u][i+1]=up[up[u][i]][i];\n    for (int v:G[u])\n        if (v!=p) dfs(v,u);\n}\n\nint lca(int u,int v) {\n    if (dep[u]<dep[v]) swap(u,v);\n    for (int i=l;i>=0;i--) {\n        if (dep[up[u][i]]>=dep[v]) u=up[u][i];\n        if (u==v) return u;\n    }\n    for (int i=l;i>=0;i--)\n        if (up[u][i]!=up[v][i]) {\n            u=up[u][i];\n            v=up[v][i];\n        }\n    return up[u][0];\n}\n\nint main() {\n    cin>>n;\n    for (int i=0;i<n;i++) {\n        int m; cin>>m;\n        for (int j=0;j<m;j++) {\n            int v; cin>>v;\n            G[i].pb(v);\n        }\n    }\n    while ((1<<l)<n) ++l;\n    dfs(0,0);\n    cin>>q;\n    for (int i=0;i<q;i++) {\n        int u,v; cin>>u>>v;\n        cout<<lca(u,v)<<'\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define MAX_V 100010\n#define MAX_LOG_V 20\n\nvector<int> edge[MAX_V];\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nstruct LCA{\n  int root;\n\n  LCA(int r): root(r){}\n\n  void add_edge(int a, int b) {\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  \n  void dfs(int v, int par, int dep) {\n    parent[0][v] = par;\n    depth[v] = dep;\n    for (auto child : edge[v]) {\n      if (child != par) dfs(child, v, dep + 1);\n    }\n  }\n\n  void init(int V) {\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n      for (int v = 0; v < V; v++) {\n\tif (parent[k][v] < 0) {\n\t  parent[k+1][v] = -1;\n\t} else {\n\t  parent[k+1][v] = parent[k][parent[k][v]];\n\t}\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n\tv = parent[k][v];\n      }\n    }\n    if (u == v) return u;\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n\tu = parent[k][u];\n\tv = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  int N;\n  LCA lca(0);\n  \n  cin >> N;\n  REP(i, N) {\n    int k;\n    cin >> k;\n    REP(j, k) {\n      int c;\n      cin >> c;\n      lca.add_edge(i, c);\n    }\n  }\n  lca.init(N);\n  int Q;\n  cin >> Q;\n  REP(i, Q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconstexpr int kN = int(1E5 + 10);\n\n#define PB push_back\n#define F first\n#define S second\n\nvector<int> graph[kN];\nvector<pair<int, int>> que[kN];\nint p[kN], ans[kN];\nbool went[kN];\n\nint Find(int n) {return p[n] == n ? n : p[n] = Find(p[n]);}\n\nvoid dfs(int pos) {\n\twent[pos] = true;\n\tfor (int i : graph[pos]) {\n\t\tdfs(i);\n\t\tp[i] = pos;\n\t}\n\tfor (pair<int, int> i : que[pos]) if (went[i.F]) ans[i.S] = Find(i.F);\n\treturn ;\n}\n\nint main() {\n\tint n, k, l, r, tmp, q;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tscanf(\"%d\", &tmp);\n\t\t\tgraph[i].PB(tmp);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++) p[i] = i;\n\tfor (int i = 0; i < n; i++) went[i] = false;\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++)\t{\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tque[l].PB({r, i});\n\t\tque[r].PB({l, i});\n\t}\n\n\tdfs(0);\n\n\tfor (int i = 0; i < q; i++) printf(\"%d\\n\", ans[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint n;\n\tint segn;\n\tST(int v,int k):n(v)\n\t{\n\t\tfor (segn = 1; segn < (n * 2 - 1); segn *= 2);\n\t\tdata.assign(2 * segn, make_pair(INF, -1));\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tdata[segn + i] = make_pair(depth[i], et[i]);\n\t\t}\n\t\tfor (int i = segn - 1; i >= 1; --i)\n\t\t{\n\t\t\tdata[i] = min(data[i * 2], data[i * 2 + 1]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = segn;\n\t\t}\n\t\tif (t <= s || r == 0)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (t - s == r)\n\t\t{\n\t\t\treturn data[l];\n\t\t}\n\n\t\treturn min(find(s, min(t, r / 2), l * 2, r / 2), find(max(0, s - (r / 2)), t - (r / 2), l * 2 + 1, r / 2));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tid[n] = eti;\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(n,eti);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 1, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define INCLUDE_EULER_TOUR_HPP\n#include <stack>\n#include <vector>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> begin, end;\n  std::vector<int> id, depth;\n\n  EulerTour(int N) : T(N), begin(N), end(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) begin[f.u] = id.size();\n      end[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#define INCLUDE_RMQ_HPP\n#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <utility>\n\nstruct LCA {\n  EulerTour euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.begin[u];\n    int r = euler_tour.begin[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(std::move(et));\n\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100000\n#define MAX_LOG 30\nvector<int>G[MAX];\nint depth[MAX];\nint parent[MAX_LOG][MAX];\nint root;\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0;i<G[v].size();i++)\n    if(G[v][i]!=p)dfs(G[v][i],v,d+1);\n}\nvoid init(int V){\n  //parent??¨dfs??????????????????\n  dfs(root,-1,0);\n  //parent??????????????????\n  for(int k=0;k+1<MAX_LOG;k++)\n    for(int v=0;v<V;v++)\n      if(parent[k][v]<0)parent[k+1][v]=-1;\n      else parent[k+1][v]=parent[k][parent[k][v]];\n}\nint lca(int u,int v){\n  if(depth[u]>depth[v])swap(u,v);\n  for(int k=0;k<MAX_LOG;k++)\n    if((depth[v]-depth[u])>>k&1)\n      v=parent[k][v];\n  if(u==v)return u;\n  for(int k=MAX_LOG-1;k>=0;k--)\n    if(parent[k][u]!=parent[k][v]){\n    u=parent[k][u];\n    v=parent[k][v];\n  }\n  return parent[0][u];\n}\nint main(){\n  root=0;\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int p=0;\n    cin>>p;\n    while(p--){\n      int t;\n      cin>>t;\n      G[i].push_back(t);\n    }\n  }\n  init(n);\n  int p;\n  cin>>p;\n  while(p--){\n    int q,w;\n    cin>>q>>w;\n    cout<<lca(q,w)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, q, l;\nint u[100010], v[100010];\nvector<int> C[100010];\nint depth[100010], par[20][100010];\n\nvoid dfs(int v, int p, int d){\n    par[0][v] = p;\n    depth[v] = d;\n    for(auto u : C[v]){\n        dfs(u, v, d + 1);\n    }\n}\n\nvoid build(){\n    dfs(0, -1, 0);\n    for(int k = 0; k <= l; k++){\n        for(int i = 0; i < n; i++){\n            if(par[k][i] == -1) par[k + 1][i] = -1;\n            else par[k + 1][i] = par[k][par[k][i]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] < depth[v]) swap(u, v);\n    for(int i = 0; i <= l; i++){\n        if(((depth[u] - depth[v]) >> i) & 1){\n            u = par[i][u];\n        }\n    }\n    if(u == v) return u;\n    for(int i = l; i >= 0; i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nvoid solve(){\n    build();\n    cin >> q;\n    for(int i = 0; i < q; i++){\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n}\n\nvoid init(){\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; j++){\n            int chi;\n            cin >> chi;\n            C[i].push_back(chi);\n        }\n    }\n    while((1 << l) < n) l++;\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconstexpr double EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nclass LCA\n{\n  int n, log_n;\n  vector<vector<int>> parent;\n  vector<int> depth;\n  void dfs(const vector<vector<int>> &g, int v, int p, int d)\n  {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (int i = 0; i < (int)g[v].size(); i++)\n    {\n      if (g[v][i] != p)\n        dfs(g, g[v][i], v, d + 1);\n    }\n  }\n\npublic:\n  LCA(const vector<vector<int>> &g, int root) : n(g.size()), log_n(0), depth(n, 0)\n  {\n    for (int v = n; v > 0; v /= 2)\n      log_n++;\n    parent.assign(log_n, vector<int>(n, 0));\n    dfs(g, root, -1, 0);\n    for (int k = 0; k < log_n - 1; k++)\n    {\n      for (int v = 0; v < n; v++)\n      {\n        if (parent[k][v] < 0)\n          parent[k + 1][v] = -1;\n        else\n          parent[k + 1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n  int query(int u, int v)\n  {\n    if (depth[u] > depth[v])\n      swap(u, v);\n    for (int k = 0; k < log_n; k++)\n    {\n      if (((depth[v] - depth[u]) >> k) & 1)\n      {\n        v = parent[k][v];\n      }\n    }\n    if (u == v)\n      return u;\n    for (int k = log_n - 1; k >= 0; k--)\n    {\n      if (parent[k][u] != parent[k][v])\n      {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;cin>>n;\n    vector<vector<int>> g(n);\n    for(int i=0;i<n;i++){\n        int k;cin>>k;\n        for(int j=0;j<k;j++){\n            int c;cin>>c;\n            g[i].push_back(c);\n        }\n    }\n    LCA lca(g,0);\n    int q;cin>>q;\n    for(int i=0;i<q;i++){\n        int u,v;cin>>u>>v;\n        cout<<lca.query(u,v)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n//pre:O(nlog n)\n//query:O(log n)\n\nclass LCA {\nprivate:\n  int V, LV;\n  int root;\n  vector<vector<int>> G, parent;\n  vector<int> depth;\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  void dfs(int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (int i = 0; i < G[v].size(); i++) {\n      if (G[v][i] != p)\n        dfs(G[v][i], v, d + 1);\n    }\n  }\n  void get_init() {\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < LV; k++) {\n      for (int v = 0; v < V; v++) {\n        if (parent[k][v] < 0)\n          parent[k + 1][v] = -1;\n        else\n          parent[k + 1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n  int get_lca(int u, int v) {\n    if (depth[u] > depth[v])\n      swap(u, v);\n    for (int k = 0; k < LV; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    if (u == v)\n      return u;\n\n    for (int k = LV - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n\npublic:\n  LCA(int V, int root) : V(V), root(root), G(V, vector<int>()), depth(V) {\n    int v_ = 1, cnt = 0;\n    while (v_ < V) v_ *= 2, cnt++;\n    LV = cnt;\n    parent.resize(LV, vector<int>(V));\n  }\n\n  void init() { return get_init(); }\n  void addEdge(int u, int v) { return add_edge(u, v); }\n  int get(int u, int v) { return get_lca(u, v); }\n};\n\nsigned main() {\n  int n;\n  cin >> n;\n\n  if (n == 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  LCA lca(n, 0);\n\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int c;\n      cin >> c;\n      lca.addEdge(i, c);\n    }\n  }\n\n  lca.init();\n\n  int q;\n  cin >> q;\n\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.get(u, v) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\ntemplate <typename T>\nclass SparseTable {\n\tusing func_t = function<T(T, T)>;\n\tint n;\n\tfunc_t merge;\n\tvector<vector<T>> t;\n\tint clz(unsigned int w) {\n\t\treturn (w & 0xffff0000) ? (w & 0xff000000) ? (w & 0xf0000000) ? (w & 0xc0000000) ? (w & 0x80000000) ? 0 : 1 : (w & 0xe0000000) ? 2 : 3 : (w & 0xfc000000) ? (w & 0xf8000000) ? 4 : 5 : (w & 0xfe000000) ? 6 : 7 : (w & 0xfff00000) ? (w & 0xffc00000) ? (w & 0xff800000) ? 8 : 9 : (w & 0xffe00000) ? 10 : 11 : (w & 0xfffc0000) ? (w & 0xfff80000) ? 12 : 13 : (w & 0xfffe0000) ? 14 : 15 : (w & 0xffffff00) ? (w & 0xfffff000) ? (w & 0xffffc000) ? (w & 0xffff8000) ? 16 : 17 : (w & 0xffffe000) ? 18 : 19 : (w & 0xfffffc00) ? (w & 0xfffff800) ? 20 : 21 : (w & 0xfffffe00) ? 22 : 23 : (w & 0xfffffff0) ? (w & 0xffffffc0) ? (w & 0xffffff80) ? 24 : 25 : (w & 0xffffffe0) ? 26 : 27 : (w & 0xfffffffc) ? (w & 0xfffffff8) ? 28 : 29 : (w & 0xfffffffe) ? 30 : 31;\n\t}\npublic:\n\tSparseTable() {}\n\tSparseTable(const vector<T>& b, func_t mq = [](T l, T r) { return min(l, r); }) : merge(mq) {\n\t\tn = b.size();\n\t\tt.push_back(b);\n\t\tfor (int i = 2, j = 1; i <= n; i <<= 1, j++) {\n\t\t\tt.push_back(vector<T>());\n\t\t\tfor (int k = 0; k + i <= n; k++) {\n\t\t\t\tt[j].push_back(merge(t[j - 1][k], t[j - 1][k + i / 2]));\n\t\t\t}\n\t\t}\n\t}\n\tT find(int l, int r) {\n\t\tr++;\n\t\tassert(l < r);\n\t\tunsigned int w = r - l;\n\t\tint i = 31 - clz(w);\n\t\treturn merge(t[i][l], t[i][r - (1 << i)]);\n\t}\n\tT operator[](int id) {\n\t\treturn t[0][id];\n\t}\n};\n\nclass LCA {\n\tint V, rt;\n\tvector<vector<int>> G;\n\tvector<int> depth, used, id;\n\tvector<int> vs, de;\n\tSparseTable<pii> st;\n\tvoid dfs(int s, int d) {\n\t\tused[s] = 1;\n\t\tvs.push_back(s);\n\t\tde.push_back(d);\n\t\tfor (int v : G[s]) {\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t\tvs.push_back(s);\n\t\t\t\tde.push_back(d);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCA(int n, int rt_ = 0) : G(n), depth(n), used(n), id(n) {\n\t\tV = n;\n\t\trt = rt_;\n\t}\n\tvoid add(int a, int b) {\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tvoid build() {\n\t\tfill(used.begin(), used.end(), 0);\n\t\tfill(id.begin(), id.end(), -1);\n\t\tdfs(rt, 0);\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tif (id[vs[i]] == -1) {\n\t\t\t\tid[vs[i]] = i;\n\t\t\t}\n\t\t}\n\t\tvector<pii> r((int)vs.size());\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tr[i] = pii(de[i], vs[i]);\n\t\t}\n\t\tSparseTable<pii> res(r);\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tdepth[i] = res[id[i]].first;\n\t\t}\n\t\tst = res;\n\t}\n\tint calc(int a, int b) {\n\t\treturn st.find(min(id[a], id[b]), max(id[a], id[b])).second;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n;\n\tLCA lca(n);\n\tfor (int i = 0, k; i < n; i++) {\n\t\tcin >> k;\n\t\tfor (int j = 0, c; j < k; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c > i) lca.add(i, c);\n\t\t}\n\t}\n\tlca.build();\n\tcin >> q;\n\tfor (int i = 0, u, v; i < q; i++) {\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\ntypedef pair<ll,ll> P;\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\nconst ll mod=1000000007;\n//ios_base::sync_with_stdio(false);\n//cin.tie(NULL);\nll gcd(ll a,ll b) {return b ? gcd(b,a%b):a;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<typename G>\nstruct DLCA{\n    const int Log;\n    vector<int> dep;\n    const G &g;\n    vector<vector<int>> table;\n    explicit DLCA(const G &g):g(g),dep(g.size()),Log(32-__builtin_clz(g.size())){\n        table.assign(Log,vector<int>(g.size(),-1));\n    }\n    void dfs(int idx,int par,int d){\n        table[0][idx]=par;\n        dep[idx]=d;\n        for(auto &to:g[idx]){\n            if(to!=par)dfs(to,idx,d+1);\n        }\n    }\n    void build(){\n        dfs(0,-1,0);\n        for(int k=0;k<Log-1;k++){\n           for(int i=0;i<table[k].size();i++){\n               if(table[k][i]==-1)table[k+1][i]=-1;\n               else table[k+1][i]=table[k][table[k][i]];\n           }\n        }\n    }\n    int query(int u,int v){\n       if(dep[u]>dep[v])swap(u,v);\n       for(int i=Log-1;i>=0;i--){\n           if(dep[v]-dep[u]&(1<<i))v=table[i][v];\n       }\n       if(u==v)return u;\n       for(int i=Log-1;i>=0;i--){\n           if(table[i][u]!=table[i][v]){\n               u=table[i][u];\n               v=table[i][v];\n           }\n       }\n       return table[0][u];\n    }\n};\nint main(){\n    int n;\n    cin>>n;\n    vector<vector<int>> graph(n);\n    for(int i=0;i<n;i++){\n        int t;cin>>t;\n        for(int j=0;j<t;j++){\n            int v;cin>>v;\n            graph[i].push_back(v);\n        }\n    }\n   DLCA<vector<vector<int>>>lca(graph);\n    lca.build();\n    int q;cin>>q;\n    while(q--){\n        int x,y;\n        cin>>x>>y;\n        cout<<lca.query(x,y)<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nclass LCA {\n\tusing pii = pair<int, int>;\n\tvector<int> depth, par, heavy, head, vid;\n\tint dfs(int v, int prev, const graph& G) {\n\t\tpar[v] = prev;\n\t\tdepth[v] = prev != -1 ? depth[prev] + 1 : 0;\n\t\tint ma = 0, cnt = 1;\n\t\tfor (auto to : G[v]) if (to != prev) {\n\t\t\tint c = dfs(to, v, G);\n\t\t\tif (c > ma) {\n\t\t\t\tma = c;\n\t\t\t\theavy[v] = to;\n\t\t\t}\n\t\t\tcnt += c;\n\t\t}\n\t\treturn cnt;\n\t}\npublic:\n\tLCA(const graph& G, int rt = 0)\n\t\t: depth(G.size()), par(G.size()), heavy(G.size(), -1), head(G.size()), vid(G.size()) {\n\t\tdfs(rt, -1, G);\n\t\tint id = 0;\n\t\tqueue<int> q;\n\t\tq.push(rt);\n\t\twhile (!q.empty()) {\n\t\t\tint h = q.front(); q.pop();\n\t\t\tfor (int v = h; v != -1; v = heavy[v]) {\n\t\t\t\tvid[v] = id++;\n\t\t\t\thead[v] = h;\n\t\t\t\tfor (auto to : G[v]) if (to != par[v] && to != heavy[v]) {\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint calc(int u, int v) {\n\t\twhile (true) {\n\t\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\t\tif (head[u] == head[v]) return u;\n\t\t\tv = par[head[v]];\n\t\t}\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph G(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tLCA lca(G);\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t{\n\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n  bool rev;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL;\n    rev=false; \n    lazy=0; \n    update();\n  }\n   \n  inline void update(){\n    mini=val,minId=id;\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>=rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  inline void apply(int v){ lazy+=v, val+=v, mini+=v; }\n   \n  inline void push(){\n    if(rev){\n      rev=false;\n      swap(lp,rp);\n      if(lp)lp->rev^=true;\n      if(rp)rp->rev^=true;\n    }\n    if(lp)lp->apply(lazy);\n    if(rp)rp->apply(lazy);\n    lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  x->splay();\n  return rp;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n  c->update();\n}\n\nvoid evert(node_t *p){\n  expose(p);\n  p->rev^=true;\n}\n\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->apply(val); }\n\nnode_t *LCA(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << LCA(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 500){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, -1);\n        int c = 0;\n        for(int u : tord){\n            if(color[u] != -1) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(color[c] == -1) q[r++] = c;\n            }\n            c++;\n        }\n    }\n    int solve(int u, int v){\n        while(topDepth[u] > topDepth[v]) u = goUp[u];\n        while(topDepth[u] < topDepth[v]) v = goUp[v];\n        while(depth[u] > depth[v]) u = parent[u];\n        while(depth[u] < depth[v]) v = parent[v];\n        while(u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n#define all(c) c.begin(),c.end()\n#define sz(x) ((int)x.size())\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\n\nstruct UnionFind {\n    vi data;\n    int comp;\n    UnionFind() {}\n    UnionFind(int size) {\n        init(size);\n    }\n    void init(int size) {\n        data.assign(size, -1);\n        comp = size;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        if (data[x] < 0) {\n            return x;\n        } else {\n            return data[x] = root(data[x]);\n        }\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() {\n        return comp;\n    }\n};\n\nstruct LCA {\n    using Query = pii;\n    \n    vector<vector<int>> g;\n    vector<int> color;\n    vector<int> ancestor;\n    vector<vector<pair<int, Query>>> query_set;\n    UnionFind uf;\n    vector<int> res;\n\n    LCA(const vector<vector<int>> &g, vector<Query> &query) : g(g), color(sz(g)), ancestor(sz(g)), query_set(sz(g)), uf(sz(g)), res(sz(query)) {\n        int qs = sz(query);\n        for (int i = 0; i < qs; ++i) {\n            query_set[query[i].first ].emplace_back(i, query[i]);\n            query_set[query[i].second].emplace_back(i, query[i]);\n        }\n    }\n\n    void visit(int v, int prev) {\n        ancestor[uf.root(v)] = v;\n        for (auto &w : g[v]) {\n            if (w == prev) {\n                continue;\n            }\n            visit(w, v);\n            uf.unite(v, w);\n            ancestor[uf.root(v)] = v;\n        }\n        color[v] = 1;\n        for (auto &p : query_set[v]) {\n            Query q = p.second;\n            int w = (q.second == v ? q.first\n                    : (q.first == v ? q.second : -1));\n            if (w == -1 || !color[w]) {\n                continue;\n            }\n            res[p.first] = ancestor[uf.root(w)];\n        }\n    }\n\n    vi solve(int root) {\n        visit(root, -1);\n        return res;\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> G(N);\n    rep(v, 0, N) {\n        int K;\n        cin >> K;\n        rep(k, 0, K) {\n            int X;\n            cin >> X;\n            G[v].push_back(X);\n        }\n    }\n    int Q;\n    cin >> Q;\n    vector<pii> queries;\n    rep(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        queries.emplace_back(U, V);\n    }\n    LCA lca(G, queries);\n    vi res = lca.solve(0);\n\n    for (int ans : res) {\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Monoid >\nstruct DisjointSparseTable {\n  using F = function< Monoid(Monoid, Monoid) >;\n  const F &f;\n  vector< vector< Monoid > > st;\n\n  DisjointSparseTable(const vector< Monoid > &v, const F &f) : f(f) {\n\n    int b = 0;\n    while((1 << b) <= v.size()) ++b;\n    st.resize(b, vector< Monoid >(v.size(), Monoid()));\n    for(int i = 0; i < v.size(); i++) st[0][i] = v[i];\n    for(int i = 1; i < b; i++) {\n      int shift = 1 << i;\n      for(int j = 0; j < v.size(); j += shift << 1) {\n        int t = min(j + shift, (int) v.size());\n        st[i][t - 1] = v[t - 1];\n        for(int k = t - 2; k >= j; k--) st[i][k] = f(v[k], st[i][k + 1]);\n        if(v.size() <= t) break;\n        st[i][t] = v[t];\n        int r = min(t + shift, (int) v.size());\n        for(int k = t + 1; k < r; k++) st[i][k] = f(st[i][k - 1], v[k]);\n      }\n    }\n  }\n\n  Monoid query(int l, int r) {\n    if(l == --r) return st[0][l];\n    int p = 31 - __builtin_clz(l ^ r);\n    return f(st[p][l], st[p][r]);\n  }\n};\n\nusing Pi = pair< int, int >;\n\nvector< int > g[100000];\nvector< Pi > depth;\nint rev[100000];\n\nvoid dfs(int idx, int dep) {\n  rev[idx] = (int) depth.size();\n  depth.emplace_back(dep, idx);\n  for(auto &to : g[idx]) {\n    dfs(to, dep + 1);\n    depth.emplace_back(dep, idx);\n  }\n}\n\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      g[i].push_back(c);\n    }\n  }\n  dfs(0, -1);\n  auto f = [](const Pi &a, const Pi &b) { return min(a, b); };\n  DisjointSparseTable< Pi > beet(depth, f);\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    auto p = minmax(rev[a], rev[b]);\n    printf(\"%d\\n\", beet.query(p.first, p.second).second);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nvector<int> G[100009]; int root = 0, parent[17][100009], depth[100009];\nvoid dfs(int v, int p, int d) {\n\tparent[0][v] = p; depth[v] = d;\n\tfor (int i : G[v]) if (i != p) dfs(i, v, d + 1);\n}\nvoid init(int v) {\n\tdfs(root, -1, 0);\n\tfor (int i = 0; i < 16; i++) {\n\t\tfor (int j = 0; j < v; j++) {\n\t\t\tif (parent[i][j] < 0) parent[i + 1][j] = -1;\n\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t}\n\t}\n}\nint query(int v1, int v2) {\n\tif (depth[v1] > depth[v2]) swap(v1, v2);\n\tfor (int i = 0; i < 17; i++) {\n\t\tif ((depth[v2] - depth[v1]) >> i & 1) v2 = parent[i][v2];\n\t}\n\tif (v1 == v2) return v1;\n\tfor (int i = 16; i >= 0; i--) {\n\t\tif (parent[i][v1] != parent[i][v2]) {\n\t\t\tv1 = parent[i][v1];\n\t\t\tv2 = parent[i][v2];\n\t\t}\n\t}\n\treturn parent[0][v1];\n}\nint n, q, c, a, x, y;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG[i].push_back(a);\n\t\t\tG[a].push_back(i);\n\t\t}\n\t}\n\tinit(n);\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tprintf(\"%d\\n\", query(x, y));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) // cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n\nclass lca {\npublic:\n  int n;\n  int log2_n;\n  vector<vector<int>> parent;\n  vector<int> depth;\n\n  lca() {}\n\n  lca(const Graph &g, int root)\n      : n(g.size()), log2_n(log2(n) + 2), parent(log2_n, vector<int>(n)),\n        depth(n) {\n    dfs(g, root, -1, 0);\n    for (int k = 0; k + 1 < log2_n; k++) {\n      for (int v = 0; v < (int)g.size(); v++) {\n        if (parent[k][v] < 0)\n          parent[k + 1][v] = -1;\n        else\n          parent[k + 1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n\n  void dfs(const Graph &g, int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (auto &e : g[v]) {\n      if (e.dst != p)\n        dfs(g, e.dst, v, d + 1);\n    }\n  }\n\n  int get(int u, int v) {\n    if (depth[u] > depth[v])\n      swap(u, v);\n    for (int k = 0; k < log2_n; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    if (u == v)\n      return u;\n    for (int k = log2_n - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nconst int B = 300;\n\nint N, Q;\nGraph g;\nvector<tuple<int, int, int, int>> query;\n\nint dist[100010];\nvector<pair<int, int>> add_at[100010];\nvector<int> stk;\n\nvoid make_dist(int v, int p, int s) {\n  dist[v] = s;\n  for (auto &e : g[v]) {\n    if (e.dst != p) {\n      make_dist(e.dst, v, dist[v] + e.weight);\n    }\n  }\n}\n\nvoid add_many(int v, int p) {\n  for (auto &aq : add_at[v]) {\n    int k = aq.first;\n    int x = aq.second;\n    if (k < (int)stk.size())\n      stk.rbegin()[k] += x;\n  }\n\n  int add = stk.back();\n  stk.pop_back();\n  for (auto &e : g[v]) {\n    if (e.dst != p) {\n      e.weight += add;\n      add_many(e.dst, v);\n    }\n  }\n  stk.push_back(add);\n\n  for (auto &aq : add_at[v]) {\n    int k = aq.first;\n    int x = aq.second;\n    if (k < (int)stk.size())\n      stk.rbegin()[k] -= x;\n  }\n}\n\nsigned main(){\n    int n;\n    cin >> n;\n    Graph g(n);\n    rep(i, n){\n        int k;\n        cin >> k;\n        rep(j, k){\n            int c;\n            cin >> c;\n            g[i].emplace_back(i, c, 1);\n        }\n    }\n    lca l(g, 0);\n    int q;\n    cin >> q;\n    rep(i, q){\n        int u, v;\n        cin >> u >> v;\n        cout << l.get(u, v) << '\\n';\n    }\n}\n\n// signed main() {\n//   ios::sync_with_stdio(0);\n//   cin.tie(0);\n\n//   cin >> N;\n//   g.assign(N, {});\n//   for (int i = 0; i < N - 1; i++) {\n//     int a, b, c;\n//     cin >> a >> b >> c;\n//     --a;\n//     --b;\n//     g[a].emplace_back(a, b, c);\n//     g[b].emplace_back(b, a, c);\n//   }\n\n//   lca lc(g, 0);\n\n//   cin >> Q;\n//   query.resize(Q);\n//   for (auto &q : query) {\n//     int t;\n//     cin >> t;\n//     if (t == 1) {\n//       int v, k, x;\n//       cin >> v >> k >> x;\n//       --v;\n//       --k;\n//       q = make_tuple(t, v, k, x);\n//     } else {\n//       int u, v;\n//       cin >> u >> v;\n//       --u;\n//       --v;\n//       q = make_tuple(t, u, v, -1);\n//     }\n//   }\n\n//   for (int i = 0; i < Q; i += B) {\n//     make_dist(0, -1, 0);\n\n//     int left = i, right = min(Q, i + B);\n\n//     for (int j = left; j < right; ++j) {\n//       int t, u, v;\n//       tie(t, u, v, ignore) = query[j];\n//       if (t == 2) {\n//         int add = 0;\n//         for (auto &path_v : {u, v}) {\n//           for (int jj = left; jj < j; ++jj) {\n//             int tt, add_v, k, x;\n//             tie(tt, add_v, k, x) = query[jj];\n//             if (tt == 1 && lc.get(add_v, path_v) == add_v &&\n//                 lc.depth[path_v] > lc.depth[add_v] + k) {\n//               add += x;\n//             }\n//           }\n//         }\n//         dump(add);\n//         int l = lc.get(u, v);\n//         cout << dist[u] + dist[v] - 2 * dist[l] + add << '\\n';\n//       }\n//     }\n\n//     for (int j = left; j < right; ++j) {\n//       int t, v, k, x;\n//       tie(t, v, k, x) = query[j];\n//       if (t == 1)\n//         add_at[v].push_back(make_pair(k, x));\n//     }\n//     stk.assign(N, 0);\n//     add_many(0, -1);\n//   }\n// }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst int MAX_V = 100000, MAX_LOG_V = 18;\nint N, Q;\nstd::vector<int> G[MAX_V];\nint parent[MAX_LOG_V][MAX_V], depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    REP(i, G[v].size()){\n        if(G[v][i] != p){\n            dfs(G[v][i], v, d+1);\n        }\n    }\n}\n\nvoid init(){\n    dfs(0, -1, 0);\n    for(int i=0;i+1<MAX_LOG_V;i++){\n        REP(v, N){\n            if(parent[i][v] == -1){parent[i+1][v] = -1;}\n            else{parent[i+1][v] = parent[i][parent[i][v]];}\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]){std::swap(u, v);}\n    for(int i=0;i<MAX_LOG_V;i++){\n        if((depth[v]-depth[u]) >> i & 1){\n            v = parent[i][v];\n        }\n    }\n    if(u == v){return u;}\n    for(int i=MAX_LOG_V-1;i>=0;i--){\n        if(parent[i][u] != parent[i][v]){\n            u = parent[i][u];\n            v = parent[i][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    std::cin >> N;\n    REP(i, N){\n        int k;\n        std::cin >> k;\n        REP(j, k){\n            int c;\n            std::cin >> c;\n            G[i].push_back(c);\n        }\n    }\n\n    init();\n\n    std::cin >> Q;\n    REP(i, Q){\n        int u, v;\n        std::cin >> u >> v;\n        std::cout << lca(u, v) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf = 1.01e9;\nconst i64 inf64 = 4.01e18;\nconst double eps = 1e-9;\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, size_t size> void fill(T (&ary)[size], const T& val){\n    fill_n((T*)ary, size, val);\n}\n\n/*\n * 構築: O(nlog(n))\n * LCAの計算: O(log(n))\n */\nclass lca_solver {\npublic:\n    vector<vector<int>> tree; // tree[i] = 頂点iに隣接する頂点のリスト\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &tree_, int root_)\n            : tree(tree_), root(root_) {\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u, int v) {\n        // make sure depth(u) > depth(v).\n        if (depth[u] < depth[v]) swap(u, v);\n        for (size_t k = 0; k < parent_pow2.size(); k++) {\n            if (((depth[u] - depth[v]) >> k) & 1) {\n                u = parent_pow2[k][u];\n            }\n        }\n        if (u == v) return u;\n        for (int k = (int)parent_pow2.size() - 1; k >= 0; k--) {\n            if (parent_pow2[k][u] != parent_pow2[k][v]) {\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n    int dist(int u, int v) {\n        return depth[u] + depth[v] - depth[lca(u, v)] * 2;\n    }\n\nprivate:\n    void calc_parent_and_depth() {\n        parent = vector<int>(tree.size(), -1);\n        depth = vector<int>(tree.size(), -1);\n        sub_calc_parent_and_depth(root, -1, 0);\n    }\n    void sub_calc_parent_and_depth(int cur, int par, int dep) {\n        parent[cur] = par;\n        depth[cur] = dep;\n        for (int child : tree[cur]) {\n            if (child != par) {\n                sub_calc_parent_and_depth(child, cur, dep + 1);\n            }\n        }\n    }\n    void calc_parent_pow2() {\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(tree.size()) / log(2) + 1),\n                                          vector<int>(tree.size(), -1));\n        parent_pow2[0] = parent;\n        for (size_t k = 0; k + 1 < parent_pow2.size(); k++) {\n            for (size_t v = 0; v < tree.size(); v++) {\n                if (parent_pow2[k][v] >= 0) {\n                    parent_pow2[k + 1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\nvoid solve() {\n    //const i64 mod = 1'000'000'007;\n\n    i64 n;\n    cin >> n;\n\n    vector<vector<int>> tree(n);\n    rep(i,0,n){\n        i64 k;\n        cin >> k;\n\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            tree[i].emplace_back(c);\n            tree[c].emplace_back(i);\n        }\n    }\n\n    lca_solver ls(tree,0);\n\n    i64 q;\n    cin >> q;\n    rep(i,0,q){\n        int u,v;\n        cin >> u >> v;\n        cout << ls.lca(u,v) << endl;\n    }\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n// typedef __int128_t Int;\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nstruct Graph {\n  int V;\n  vector<vector<int>> g;\n  vector<int> dist;\n  Graph(int V) : V(V), g(V), dist(V, -1) {}\n  void add_edge(int s, int t) {\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n};\n\nstruct Tree { // rooted tree\n  vector<vector<int>> g, parent;\n  int root, V, log2_n;\n  vector<int> depth;\n  int get_depth(int x) { return depth[x]; }\n  void dfs(int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i, 0, g[v].size()) {\n      if (g[v][i] != p)\n        dfs(g[v][i], v, d + 1);\n    }\n  }\n  Tree(Graph G, int root)\n      : root(root), V(G.V), g(G.g), depth(V), log2_n(1 + (int)log2(V)) {\n    parent.resize(log2_n, vector<int>(V));\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < log2_n; k++) {\n      for (int v = 0; v < V; v++) {\n        if (parent[k][v] < 0)\n          parent[k + 1][v] = -1;\n        else\n          parent[k + 1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n  int lca(int u, int v) {\n    if (depth[u] > depth[v])\n      swap(u, v);\n    for (int k = 0; k < log2_n; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    if (u == v)\n      return u;\n    for (int k = log2_n - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int N;\n  cin >> N;\n  Graph g(N);\n  rep(i, 0, N) {\n    int k;\n    cin >> k;\n    rep(j, 0, k) {\n      int c;\n      cin >> c;\n      g.add_edge(i, c);\n    }\n  }\n  Tree t(g, 0);\n  int Q;\n  cin >> Q;\n  loop(Q) {\n    int u, v;\n    cin >> u >> v;\n    cout << t.lca(u, v) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    len.resize(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];\nint size[MAX];\nint par[MAX];\nint dep[MAX];\nint depth[MAX];\nint parent[MAX];\n\nvoid idfs(int pos,int prev){\n  int m=-1;\n  parent[pos]=prev;\n  if(G[pos].size()==1&&prev!=-1)return;  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    depth[to]=depth[pos]+1;\n    idfs(to,pos);\n    size[pos]+=size[to];\n    if(m==-1||size[m]<size[to]){\n      m=to;\n    }\n  }\n  par[m]=pos;\n}\n\nint calc(int x){\n  if(par[x]==x)return x;\n  return par[x]=calc(par[x]);\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    size[i]=1;\n    par[i]=i;\n  }\n  for(int i=0;i<n;i++){    \n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n      G[b].push_back(i);\n    }\n  }\n  for(int i=0;i<n;i++)sort(G[i].begin(),G[i].end());\n  depth[0]=0;\n  idfs(0,-1);\n  for(int i=0;i<n;i++){\n    calc(i);\n    int p=par[i];\n    while(p>0){\n      p= par[ parent[p] ];      \n      dep[i]++;\n    }\n  }  \n}\n\nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n      scanf(\"%d %d\",&a,&b);\n\n      while(par[a]!=par[b]){\n        if(dep[a]<dep[b])swap(a,b);\n        a=parent[par[a]];\n      }\n      printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n\n    }\n    break;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int limit=17;\nconst int nmax=100010;\n\nvector<int> graph[nmax];\nint parent[nmax][limit]; // all is -1\nint depth[nmax];\n\nvoid dfs(int v,int p,int d){\n\tparent[v][0]=p;\n\tdepth[v]=d;\n\tfor(auto &v2:graph[v]) if(v2!=p) dfs(v2,v,d+1);\n}\n\nint lca(int u,int v){\n\tif(depth[u] < depth[v]) swap(u,v);\n\tfor(int i=limit-1;i>=0;--i) if((depth[u]-depth[v])>>i&1) u=parent[u][i];\n\tif(u==v) return u;\n\tfor(int i=limit-1;i>=0;--i){\n\t\tif(parent[u][i]!=parent[v][i]){\n\t\t\tu=parent[u][i];\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\treturn parent[u][0];\n}\n\nint main(void){\n\tint n; cin >> n;\n\trep(i,n){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint v; cin >> v;\n\t\t\tgraph[i].push_back(v);\n\t\t}\n\t}\n\n\t// rep(i,n)rep(j,20) parent[i][j]=-1;\n\tdfs(0,-1,0);\n\trep(i,n)rep(j,limit-1) parent[i][j+1]=parent[parent[i][j]][j];\n\n\tint q; cin >> q;\n\trep(i,q){\n\t\tint u,v; cin >> u >> v;\n\t\tcout << lca(u,v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\nclass RMQsub1{//隣接差が±1だけのRMQ\n\tstd::vector<int> pattern;//ブロックがどのパターンか\n\tstd::vector<std::vector<int> > minpos;//バイナリパターンに対する最小位置\n\tstd::vector<int> dat;//葉でないノード\n\tstd::vector<int> depth;\n\tint blocksize;\n\tint n;\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return -1;\n\t\tif(n-1<=k){//leaf\n\t\t\tif(pattern[k-(n-1)]==-1)return -1;\n\t\t\tint s=l<a?a-l:0;\n\t\t\tint t=r<=b?blocksize:b-l;\n\t\t\treturn (k-(n-1))*blocksize+minpos[pattern[k-(n-1)]][s*blocksize+t-1];\n\t\t}else{\n\t\t\tif(a<=l&&r<=b)return dat[k];\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn vl!=-1&&(vr==-1||depth[vl]<depth[vr])?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k-1;//log(n)/2\n\t\tif(blocksize==0)blocksize=1;\n\t\tint m=(n+blocksize-1)/blocksize;//num node\n\t\twhile(m&m-1)m+=m&-m;\n\t\tthis->n=m;\n\t\tdat.resize(m-1,-1);\n\t\tpattern.resize(n,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==1)break;\n\t\t\tint par=(m-1+i-1)/2;\n\t\t\tif(dat[par]==-1 || a[i*blocksize+minpos[p][0+b-1]]<a[dat[par]])\n\t\t\t\tdat[par]=i*blocksize+minpos[p][0+b-1];\n\t\t}\n\n\t\tdat.resize(m-1);\n\t\tfor(int i=(m-2)/2-1;i>=0;i--){\n\t\t\tint vl,vr;\n\t\t\tvl=dat[2*i+1];\n\t\t\tvr=dat[2*i+2];\n\t\t\tdat[i]=vr==-1||a[vl]<a[vr]?vl:vr;\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n*blocksize);\n\t}\n};\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nlong double EPS=1E-8;\n////////////////////////////////////////\n#define MAX_V 500000\n#define MAX_LOGV 30\nvector<int>G[MAX_V];\nint root;//根ノード\nint parent[MAX_LOGV][MAX_V];//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1)\nint depth[MAX_V];\nvoid dfs(int v,int p,int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    for(auto x:G[v]){\n        if(x!=p)dfs(x,v,d+1);\n    }\n}\nvoid init(int V){\n    //parent[0]とdepthを初期化\n    dfs(root,-1,0);\n    //parentを初期化\n    rep(k,0,MAX_LOGV-2){\n        rep(v,0,V-1){\n            if(parent[k][v]<0)parent[k+1][v]=-1;\n            else parent[k+1][v]=parent[k][parent[k][v]];\n        }\n    }\n}\n//uとvのLCAを求める\nint lca(int u,int v){\n    //uとvの深さが同じになるまで親をたどる\n    if(depth[u]>depth[v])swap(u,v);\n    rep(k,0,MAX_LOGV-2){\n        if((depth[v]-depth[u])>>k&1){\n            v=parent[k][v];\n        }\n    }\n    if(u==v)return u;\n    for(int k=MAX_LOGV-1;k>=0;k--){\n        if(parent[k][u]!=parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\n////////////////////////////////////////\nint main(){\n    int n;cin>>n;\n    rep(i,0,n-1){\n        int s;cin>>s;\n        rep(j,1,s){\n            int c;cin>>c;G[i].pb(c);\n            G[c].pb(i);\n        }\n    }\n    \n    init(n);\n    int q;cin>>q;\n    while(q--){\n        ll a,b;cin>>a>>b;\n        cout<<lca(a,b)<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define si(i) scanf(\"%d\", &i)\n#define sll(i) scanf(\"%lld\", &i)\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define nl '\\n'\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair< int, int > pii;\n\nvector < vector < int > > v;\nint n, l[100005];\nint f[100005][21];\n\nint main(){\n    si(n);\n    v.resize(n);\n    int nn = 20;\n    memset( f[0], -1, sizeof f[0]);\n    for( int i = 0 ; i < n ; i++ ){\n        int k; si(k);\n        for( int j = 0 ; j < k ; j++ ){\n            int c; si(c);\n            v[i].pb( c );\n            v[c].pb( i );\n            f[0][c] = i;\n        }\n    }\n    \n    memset(l, -1, sizeof(l));\n    queue < int > q;\n    q.push(0);\n    l[0] = 0;\n    while(!q.empty()){\n    \tint u = q.front();\n    \tq.pop();\n    \tfor( int x : v[u] ){\n    \t\tif( l[x] == -1 ){\n    \t\t\tl[x] = l[u]+1;\n    \t\t\tq.push(x);\n\t\t\t}\n\t\t}\n\t}\n    \n    for( int i = 1 ; i <= nn ; i++ ){\n        for( int j = 0 ; j < n ; j++ ){\n            int x = f[i - 1][j];\n            if( x == -1 ){\n                f[i][j] = -1;\n                continue;\n            }\n            int y = f[i - 1][x];\n            f[i][j] = y;\n        }\n    }\n    \n    int _q; si(_q);\n    while( _q-- ){\n        int u, v;\n        si(u); si(v);\n        if( l[u] < l[v] ) swap( u, v );\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( ( 1 << i ) <= l[u] - l[v] ){\n                u = f[i][u];\n            }\n        }\n        if( u == v ){\n            cout << u << nl;\n            continue;\n        }\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( f[i][u] == f[i][v] ) continue;\n            u = f[i][u];\n            v = f[i][v];\n        }\n        cout << f[0][u] << nl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nclass LCA{\n    int n;\n    vector<int> dep;\n    vector<vector<int>> par;\n    Graph g;\n    const int LOGN_MAX=100;\n    void setDep(int v,int d,Graph& tree){\n        dep[v]=d;\n        for(int i=0;i<tree[v].size();i++) setDep(tree[v][i],d+1,tree);\n    }\n    public:\n    LCA(Graph &tree):n(tree.size()){\n        dep=vector<int>(n);\n        par=vector<vector<int>>(min(LOGN_MAX,int(log2(n))+1),vector<int>(n));\n        g=Graph(n);\n        for(int i=0;i<tree.size();i++){\n            for(int j=0;j<tree[i].size();j++){\n                g[tree[i][j]].push_back(i);\n            }\n        }\n\n        bool isTree=true;\n        int root=-1;\n        for(int i=0;i<g.size();i++){\n            if(g[i].size()){\n                isTree&=(g[i].size()==1);\n            }\n            else if(root==-1){\n                root=i;\n                if(g[i].size()==0){\n                setDep(i,0,tree);\n               }\n            }\n            else{\n                isTree=false;\n            }\n        }\n        assert(isTree);\n\n        for(int i=0;i<n;i++){\n            par[0][i]=(g[i].size() ? g[i][0] : i);\n        }\n        for(int i=0;i+1<par.size();i++){\n            for(int j=0;j<par[i].size();j++){\n                par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n\n    int lca(int a,int b){\n        if(dep[a]>dep[b]) swap(a,b);\n        int dist=dep[b]-dep[a];\n        for(int i=0;dist;i++,dist/=2){\n            if(dist%2) b=par[i][b];\n        }\n        assert(dep[a]==dep[b]);\n        while(true){\n            if(a==b) return a;\n            if(par[0][a]==par[0][b]) return par[0][a];\n            int lb=0;\n            int ub=par.size();\n            //[ub,LOGN_MAX)->same anc\n            while(ub-lb>1){\n                int mid=(lb+ub)/2;\n                if(par[mid][a]==par[mid][b]) ub=mid;\n                else lb=mid;\n            }\n            a=par[lb][a];\n            b=par[lb][b];\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;j++){\n            int c;\n            cin>>c;\n            g[i].push_back(c);\n        }\n    }\n    LCA lg(g);\n    int q;\n    cin>>q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin>>u>>v;\n        cout<<lg.lca(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n//*/\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n\n#define N 100003\n#define LEV 21\n\nclass LCADoubling {\n  int n, lev;\n  int kprv[LEV][N], de[N];\n\n  inline void construct_kprv() {\n    for(int k=0; k<lev; ++k) {\n      for(int i=0; i<n; ++i) {\n        if(kprv[k][i] == -1) continue;\n        kprv[k+1][i] = kprv[k][kprv[k][i]];\n      }\n    }\n  }\n\npublic:\n  LCADoubling(int n) : n(n) {\n    int n0 = 1;\n    lev = 0;\n    while(n0 < n) n0 <<= 1, ++lev;\n  }\n  void construct(int *prv, int *depth) {\n    for(int i=0; i<n; ++i) kprv[0][i] = prv[i], de[i] = depth[i];\n    construct_kprv();\n  }\n\n  void construct_from_graph(vector<int> g[N], int s) {\n    bool used[N];\n    queue<int> que;\n    for(int i=0; i<n; ++i) used[i] = false;\n\n    used[s] = true;\n    kprv[0][s] = -1; de[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n      int v = que.front(); que.pop();\n      for(int i=0; i<g[v].size(); ++i) {\n        int w = g[v][i];\n        if(used[w]) continue;\n        used[w] = true;\n        kprv[0][w] = v; de[w] = de[v] + 1;\n        que.push(w);\n      }\n    }\n    construct_kprv();\n  }\n\n  int query(int u, int v) {\n    int dd = de[v] - de[u];\n    if(dd < 0) {\n      swap(u, v);\n      dd = -dd;\n    }\n\n    // de[u] <= de[v]\n    for(int k=0; k<=lev; ++k) {\n      if(dd & 1) {\n        v = kprv[k][v];\n      }\n      dd >>= 1;\n    }\n\n    // de[u] == de[v]\n    if(u == v) return u;\n\n    for(int k=lev-1; k>=0; --k) {\n      int pu = kprv[k][u], pv = kprv[k][v];\n      if(pu != pv) u = pu, v = pv;\n    }\n    return kprv[0][u];\n  }\n};\n\nint n, q;\nbool used[N];\nvector<int> g[N];\n\nint main() {\n  cin >> n;\n  for(int i=0; i<n; ++i) {\n    int k; cin >> k;\n    while(k--) {\n      int c; cin >> c;\n      g[i].push_back(c);\n    }\n  }\n\n  LCADoubling lca(n);\n  lca.construct_from_graph(g, 0);\n\n  cin >> q;\n  while(q--) {\n    int u, v; cin >> u >> v;\n    int w = lca.query(u, v);\n    cout << w << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n\n    vector<vector<int>> parent_pow2;\n\n    lca_solver(vector<vector<int>> children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n\n    int lca(int u,int v){\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            graph[i].push_back(c);\n        }\n    }\n\n    lca_solver ls(graph,0);\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int u,v;\n        cin >> u >> v;\n        cout << ls.lca(u,v) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass SparseTable{\nprivate:\n    int N;\n    int H;\n    vector<vector<int>> data;\n    vector<int> rdata;\n    \npublic:\n    SparseTable(vector<int> rdata): rdata(rdata){\n        N = rdata.size();\n        H = log2(N);\n        \n        data.resize(H+1);\n        for(int i=0; i<N; i++){\n            data[0].push_back(i);\n        }\n        int l = 1;\n        for(int h=1; h<=H; h++){\n            for(int i=0; i+l*2<=N; i++){\n                int idx = -1;\n                if(rdata[data[h-1][i]] < rdata[data[h-1][i+l]])\n                    idx = data[h-1][i];\n                else\n                    idx = data[h-1][i+l];\n                data[h].push_back(idx);\n            }\n            l <<= 1;\n        }\n    }\n    int find(int a, int b){\n        int h = log2(b-a);\n        if(rdata[data[h][a]] < rdata[data[h][b-(1<<h)]])\n            return data[h][a];\n        else\n            return data[h][b-(1<<h)];\n    }\n};\n\nvoid euler_tour(vector<vector<int>> &G, int u, int d, vector<int> &tour, vector<int> &depth){\n    tour.push_back(u);\n    depth.push_back(d);\n    for(auto v: G[u]){\n        euler_tour(G, v, d+1, tour, depth);\n        tour.push_back(u);\n        depth.push_back(d);\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    \n    for(int i=0; i<N; i++){\n        int k; cin >> k;\n        for(int j=0; j<k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    \n    vector<int> tour, depth;\n    euler_tour(G, 0, 0, tour, depth);\n    vector<int> rightmsot(N);\n    for(int i=0; i<tour.size(); i++)\n        rightmsot[tour[i]] = i;\n    \n    SparseTable st(tour);\n    \n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++){\n        int u, v; cin >> u >> v;\n        int ru = rightmsot[u], rv = rightmsot[v];\n        if(ru > rv)\n            swap(ru, rv);\n//        rv++;\n        int d = st.find(ru, rv);\n        cout << tour[d] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T> struct SegmentTree {\n  using F = function<T(T, T)>;\n\n  int n;\n  T init;\n  F f;\n  vector<T> data;\n\n  SegmentTree() {}\n  SegmentTree(int n_, vector<T> v = vector<T>(),\n      F f = [](T a, T b) { return min(a, b); }, T init = INT_MAX)\n      : f(f), init(init) {\n    n = 1;\n    while(n < n_) n *= 2;\n    data.assign(2 * n - 1, init);\n    if(n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void update(int k, T x) {\n    k += n - 1;\n    data[k] = x;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      data[k] = f(data[k * 2 + 1], data[k * 2 + 2]);\n    }\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    if (b <= l || r <= a) return init;\n    if (a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n};\n\nstruct Tree {\n  using P = pair<int, int>;\n\n  int n;\n  int time;\n  vector<vector<int>> g;\n  vector<int> num;\n  vector<P> depth;\n  vector<int> eulerTour;\n  SegmentTree<P> seg;\n\n  Tree(int n)\n    : n(n), time(0), g(n),\n      num(n), depth(n * 2 - 1), eulerTour(n * 2 - 1) {}\n\n  void init(int r) {\n    dfs(r, r, 0);\n    SegmentTree<P>::F f = [](P a, P b) { return min(a, b); };\n    seg = SegmentTree<pair<int, int>>(n * 2 - 1, depth, f, {INT_MAX, -1});\n  }\n  void addEdge(int s, int t) {\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  void dfs(int u, int p, int d) {\n    num[u] = time;\n    eulerTour[time] = u;\n    depth[time] = {d, time};\n    ++time;\n    for (auto&& v : g[u]) {\n      if (v != p) {\n        dfs(v, u, d + 1);\n        eulerTour[time] = u;\n        depth[time] = {d, time};\n        ++time;\n      }\n    }\n  }\n  int lowestCommonAncestor(int u, int v) {\n    int i = num[u];\n    int j = num[v];\n    if (i > j) swap(i, j);\n    return eulerTour[seg.query(i, j + 1).second];\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n; cin >> n;\n  Tree t(n);\n  for (int i = 0; i < n; ++i) {\n    int k; cin >> k;\n    while (k--) {\n      int c; cin >> c;\n      t.addEdge(i, c);\n    }\n  }\n\n  t.init(0);\n  int q; cin >> q;\n  while (q--) {\n    int u, v; cin >> u >> v;\n    cout << t.lowestCommonAncestor(u, v) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    for (int i=0; i<(((int)(v).size())); ++i) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n/*\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    return 0;\n}\n*/\n/**\n * @brief\n * 最小共通祖先（ダブリング）\n * 構築O(VlogV), クエリO(logV)\n *\n * LCA(G, root)で構築（無向木Gを、rootを根として向きづけしたときのLCAを構築）\n * query(u, v)で取得\n *\n * @author ゆきのん？\n * @date 2019/12\n */\nstruct LCA {\n    /**\n    * @brief コンストラクタ. O(nlog n)\n    * @param[in] G 無向木.\n    * @param[in] root 指定した根.\n    */\n    LCA(const vector<vector<int>>& G, int root = 0) :\n            n(G.size()), log2_n(log2(n)), depth(n),\n            par(log2_n+1, vector<int>(n,-1)) {\n        dfs(G, root, -1, 0);\n        for (int k = 0; k < log2_n; ++k) {\n            for (int v = 0; v < n; ++v) {\n                if (par[k][v] != -1) {\n                    par[k+1][v] = par[k][par[k][v]];\n                }\n            }\n        }\n    }\n    /**\n    * @brief lca を取得する. O(log n);\n    * @param[in] u, v: lca を求めたい2頂点.\n    * @return u, v のlca.\n    */\n    int query(int u, int v) {\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k <= log2_n; ++k) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v) return u;\n        for (int k = log2_n; k >= 0; --k) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\nprivate:\n    int n, log2_n;\n    vector<int> depth;\n    vector<vector<int>> par;\n    void dfs(const vector<vector<int>>& G, int v, int p, int d) {\n        depth[v] = d;\n        par[0][v] = p;\n        for (auto to : G[v]) {\n            if (to != p) dfs(G, to, v, d+1);\n        }\n    }\n};\nint main() {\n    int N, Q;\n    cin >> N;\n    vector<vector<int>> g(N);\n    for(int i = 0; i < N; i++) {\n        int k; cin >> k;\n        while (k--) {\n            int c; cin >> c;\n            g[i].push_back(c);\n        }\n    }\n    LCA lca(g);\n    cin >> Q;\n    while (Q--) {\n        int x, y; cin >> x >> y;\n        printf(\"%d\\n\", lca.query(x, y));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n\nstd::vector<int> vec[100000];\nint ra[100000], n;\n\nvoid dfs(int a) {\n  int i;\n  for(i = 0; i < vec[a].size(); ++i) {\n    ra[vec[a][i]] = ra[a] + 1;\n    dfs(vec[a][i]);\n  }\n}\n\nint main(void) {\n  int i, j, q, k, c, u, v;\n  scanf(\"%d\", &n);\n  int p[n];\n  p[0] = 0, ra[0] = 0;\n  for(i = 1; i < n; ++i) ra[i] = -1;\n  for(i = 0; i < n; ++i) {\n    scanf(\"%d\", &k);\n    for(j = 0; j < k; ++j) {\n      scanf(\"%d\", &c);\n      vec[i].push_back(c);\n      p[c] = i;\n    }\n  }\n  dfs(0);\n  scanf(\"%d\", &q);\n  for(i = 0; i < q; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    while(ra[u] > ra[v]) u = p[u];\n    while(ra[v] > ra[u]) v = p[v];\n    while(u != v) u = p[u], v = p[v];\n    printf(\"%d\\n\", u);\n  }\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 200005\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct data{ll x,a,b;};\n\nint N,Q;\nint a,b,c;\nvector<int> G[MAX_N];\nint p[MAX_N],d[MAX_N],cnt=0;\nvector<int> g,flg;\n\n\nvoid rec(int pos,int prev,int depth){\n  d[pos]=depth;\n  p[pos]=g.size();\n  g.push_back(pos);\n\n  for(int i=0;i<(int)G[pos].size();i++){\n    int w=G[pos][i];\n    if(w==prev)continue;\n    rec(w,pos,depth+1);\n    g.push_back(pos);\n  }\n\n}\n\nP dp[MAX_N][26];\n\nint lca(int u,int v){\n\n  u=p[u];\n  v=p[v];\n  if(u>v)swap(u,v);\n  int dist=v-u+1;\n  int pos=u;\n  P res=P((1<<26),(1<<26));\n\n  for(int I=26;I>=0;I--){\n    int i=(1<<I);\n    if(dist>=i){\n      dist-=i;\n      res=min(res,dp[pos][I]);\n      pos+=i;\n    }\n  }\n\n  return g[res.second];\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&a);\n    for(int j=0;j<a;j++){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n    }\n  }\n\n  rec(0,-1,0);\n\n\n  for(int i=0;i<(int)g.size();i++)\n    dp[i][0]=P(d[g[i]],i);\n\n  int K=1;\n  for(int k=1;k<30;k++){\n    for(int i=0;i<(int)g.size();i++){\n      dp[i][k]=dp[i][k-1];\n      int j=i+K;\n      if(j>=(int)g.size())j=g.size()-1;\n      dp[i][k]=min(dp[i][k],dp[j][k-1]);\n    }\n    K*=2;\n  }\n  \n  cin>>Q;\n\n\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",lca(a,b));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    //buildPaths(0,newPath(0));\n    len.resize(pathCount);\n    /*\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\nusing namespace std;\n\n/**\n * @brief lowest common ancestor with doubling\n */\nstruct lowest_common_ancestor {\n    vector<vector<int> > a;\n    vector<int> depth;\n    lowest_common_ancestor() = default;\n    /**\n     * @note O(N \\log N)\n     */\n    lowest_common_ancestor(int root, vector<vector<int> > const & g) {\n        int n = g.size();\n        int log_n = 1 + floor(log2(n));\n        a.resize(log_n, vector<int>(n, -1));\n        depth.resize(n, -1);\n        {\n            auto & parent = a[0];\n            stack<int> stk;\n            depth[root] = 0;\n            parent[root] = -1;\n            stk.push(root);\n            while (not stk.empty()) {\n                int x = stk.top(); stk.pop();\n                for (int y : g[x]) if (depth[y] == -1) {\n                    depth[y] = depth[x] + 1;\n                    parent[y] = x;\n                    stk.push(y);\n                }\n            }\n        }\n        repeat (k, log_n-1) {\n            repeat (i, n) {\n                if (a[k][i] != -1) {\n                    a[k+1][i] = a[k][a[k][i]];\n                }\n            }\n        }\n    }\n    /**\n     * @brief find the LCA of x and y\n     * @note O(log N)\n     */\n    int operator () (int x, int y) const {\n        int log_n = a.size();\n        if (depth[x] < depth[y]) swap(x,y);\n        repeat_reverse (k, log_n) {\n            if (a[k][x] != -1 and depth[a[k][x]] >= depth[y]) {\n                x = a[k][x];\n            }\n        }\n        assert (depth[x] == depth[y]);\n        assert (x != -1);\n        if (x == y) return x;\n        repeat_reverse (k, log_n) {\n            if (a[k][x] != a[k][y]) {\n                x = a[k][x];\n                y = a[k][y];\n            }\n        }\n        assert (x != y);\n        assert (a[0][x] == a[0][y]);\n        return a[0][x];\n    }\n    /**\n     * @brief find the descendant of x for y\n     */\n    int descendant (int x, int y) const {\n        assert (depth[x] < depth[y]);\n        int log_n = a.size();\n        repeat_reverse (k, log_n) {\n            if (a[k][y] != -1 and depth[a[k][y]] >= depth[x]+1) {\n                y = a[k][y];\n            }\n        }\n        assert (a[0][y] == x);\n        return y;\n    }\n};\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n) {\n        int edges; scanf(\"%d\", &edges);\n        while (edges --) {\n            int j; scanf(\"%d\", &j);\n            g[i].push_back(j);\n            g[j].push_back(i);\n        }\n    }\n    constexpr int root = 0;\n    lowest_common_ancestor lca(root, g);\n    int query; scanf(\"%d\", &query);\n    while (query --) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        printf(\"%d\\n\", lca(x, y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nclass LCA{\n    int n;\n    vector<int> dep;\n    vector<vector<int>> par;\n    Graph g;\n    const int LOGN_MAX=100;\n    void setDep(int v,int d,Graph& tree){\n        dep[v]=d;\n        for(int i=0;i<tree[v].size();i++) setDep(tree[v][i],d+1,tree);\n    }\n    public:\n    LCA(Graph &tree):n(tree.size()){\n        dep=vector<int>(n);\n        par=vector<vector<int>>(min(LOGN_MAX,int(log(n))+1),vector<int>(n));\n        g=Graph(n);\n        for(int i=0;i<tree.size();i++){\n            for(int j=0;j<tree[i].size();j++){\n                g[tree[i][j]].push_back(i);\n            }\n        }\n\n        bool isTree=true;\n        int root=-1;\n        for(int i=0;i<g.size();i++){\n            if(g[i].size()){\n                isTree&=(g[i].size()==1);\n            }\n            else if(root==-1){\n                root=i;\n                if(g[i].size()==0){\n                setDep(i,0,tree);\n               }\n            }\n            else{\n                cout<<\"Myao\"<<endl;\n                isTree=false;\n            }\n        }\n        assert(isTree);\n\n        for(int i=0;i<n;i++){\n            par[0][i]=(g[i].size() ? g[i][0] : i);\n        }\n        for(int i=0;i+1<par.size();i++){\n            for(int j=0;j<par[i].size();j++){\n                par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n\n    int lca(int a,int b){\n        if(dep[a]>dep[b]) swap(a,b);\n        int dist=dep[b]-dep[a];\n        for(int i=0;dist;i++,dist/=2){\n            if(dist%2) b=par[i][b];\n        }\n        assert(dep[a]==dep[b]);\n        while(true){\n            if(a==b) return a;\n            if(par[0][a]==par[0][b]) return par[0][a];\n            int lb=0;\n            int ub=LOGN_MAX;\n            //[ub,LOGN_MAX)->same anc\n            while(ub-lb>0){\n                int mid=(lb+ub)/2;\n                if(par[mid][a]==par[mid][b]) ub=mid;\n                else lb=mid;\n            }\n            a=par[lb][a];\n            b=par[lb][b];\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;j++){\n            int c;\n            cin>>c;\n            g[i].push_back(c);\n        }\n    }\n    LCA lg(g);\n    int q;\n    cin>>q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin>>u>>v;\n        cout<<lg.lca(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vii> vvii;\ntypedef vector<int>::iterator vit;\n\nconst int MAXN = 100005;\nconst int LOGN = 20;\n\nint idx[MAXN]; // i : index of node i in dfs path\nii path[MAXN << 1];\nvi adjList[MAXN];\n\nii ST[LOGN][MAXN<<1];\n\nvoid build(int n) {\n    int h = (n == 1 ? 1 : ceil(log2(n)));\n\n    for (int i = 0; i < n; i++) ST[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n            ST[i][j] = min(ST[i-1][j], ST[i-1][j+(1<<(i-1))]);\n}\n\nint RMQ(int l, int r) {    // range [l,r)\n    int p = 31 - __builtin_clz(r-l);\n    return min(ST[p][l],ST[p][r-(1<<p)]).se;\n}\n\n// build dfs path, depth\nint cnt = 0;\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n\n    path[cnt++] = ii(d,curr);\n    for (vit it = adjList[curr].begin(); it != adjList[curr].end(); it++) {\n        dfs(*it,d+1);\n\n        path[cnt++] = ii(d,curr);\n    }\n}\n\nint N, M, Q, v;\n\nint main(){\n\n    scanf(\"%d\",&N);\n    for (int u = 0; u < N; u++){\n        scanf(\"%d\",&M);\n        for (int i = 0; i < M; i++){\n            scanf(\"%d\",&v);\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted as 0\n    dfs(0,0);\n    build(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v, l, r; i < Q; i++){\n    scanf(\"%d%d\",&u,&v);\n\n        l = idx[u], r = idx[v]; if (l > r) swap(l,r);\n\n        printf(\"%d\\n\",RMQ(l,r+1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint n;\nvector<int> c[100005];\nint p[100005];\nint d[100005];\n\nvoid dfs(int k, int depth) {\n  d[k] = depth;\n  for (auto i: c[k]) {\n    dfs(i, depth + 1);\n  }\n}\n\nint lca(int l, int r) {\n  while (l != r) {\n    if (d[l] > d[r]) l = p[l];\n    else r = p[r];\n  }\n  return l;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  rep(i, n) p[i] = -1;\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      int cj;\n      cin >> cj;\n      c[i].push_back(cj);\n      p[cj] = i;\n    }\n  }\n\n  int root = 0;\n  rep(i, n) if (p[i] == -1) root = i;\n\n  dfs(root, 0);\n\n  int q;\n  cin >> q;\n  rep(i, q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca(u, v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#include <bitset>\n#include <cctype>\n#include <set>\n#include <map>\n#include <numeric>\n#include <functional>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline void Yes(bool condition){ if(condition) PRINT(\"Yes\"); else PRINT(\"No\"); }\ntemplate<class itr> void cins(itr first,itr last){\n    for (auto i = first;i != last;i++){\n        cin >> (*i);\n    }\n}\ntemplate<class itr> void array_output(itr start,itr goal){\n    string ans = \"\",k = \" \";\n    for (auto i = start;i != goal;i++) ans += to_string(*i)+k;\n    if (!ans.empty()) ans.pop_back();\n    PRINT(ans);\n}\nll gcd(ll a, ll b) {\n    return a ? gcd(b%a,a) : b;\n}\nconst ll INF = 1e16;\nconst ll MOD = 1000000007;\ntypedef pair<ll,ll> P;\nconst ll MAX = 200005;\nconstexpr ll nx[8] = {1,0,-1,0,-1,-1,1,1};\nconstexpr ll ny[8] = {0,1,0,-1,-1,1,-1,1};\nclass LowestCommonAncestor{\n    private:\n        const int LOG;\n        vector<int> depth;\n        vector<vector<int>> par,g;\n    public:\n        LowestCommonAncestor(vector<vector<int>> &g):g(g),depth(g.size()),LOG(32){\n            par.resize(LOG,vector<int>(g.size()));\n        }\n        void dfs(int v,int p,int d){\n            par[0][v] = p;\n            depth[v] = d;\n            for(int u:g[v]){\n                if (u != p) dfs(u,v,d+1);\n            }\n        }\n        void build(int root){\n            dfs(root,-1,0);\n            rep(k,LOG-1){\n                rep(i,depth.size()){\n                    if (par[k][i] < 0) par[k+1][i] = -1;\n                    else par[k+1][i] = par[k][par[k][i]];\n                }\n            }\n        }\n        int lca(int u,int v){\n            if (depth[u] > depth[v]) swap(u,v);\n            rep(k,LOG){\n                if ((depth[v]-depth[u]) >> k & 1){\n                    v = par[k][v];\n                }\n            }\n            if (u == v) return u;\n            for (int k = LOG - 1; k >= 0; k--){\n                if (par[k][u] != par[k][v]){\n                    u = par[k][u];\n                    v = par[k][v];\n                }\n            }\n            return par[0][u];\n        }\n};\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,k,c;\n    cin >> n;\n    vector<vector<int>> g(n);\n    rep(i,n){\n        cin >> k;\n        rep(j,k){\n            cin >> c;\n            g[i].push_back(c);\n            g[c].push_back(i);\n        }\n    }\n    LowestCommonAncestor tree(g);\n    int q,u,v;\n    cin >> q;\n    tree.build(0);\n    rep(i,q){\n        cin >> u >> v;\n        PRINT(tree.lca(u,v));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 500){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(topDepth[u] > topDepth[v]) u = goUp[u];\n        while(topDepth[u] < topDepth[v]) v = goUp[v];\n        while(depth[u] > depth[v]) u = parent[u];\n        while(depth[u] < depth[v]) v = parent[v];\n        while(u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)N;++i)\n#define rep1(i,N) for(int i=1;i<=(int)N;++i)\n\nusing int64 = long long;\nusing i64 = long long;\n\nconst int inf = 1 << 30;\nconst i64 inf64 = 1ll << 60;\n\nconst int mod = 1e9 + 7;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n   return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nint dy[] = { 0, 1, 0, -1 };\nint dx[] = { -1, 0, 1, 0 };\n\n// Doubling\nstruct LowestCommonAncestor {\n   const int LOG;\n   const vector<vector<int>>& g;\n   int root;\n   vector<int> dep;\n   vector<vector<int>> table;\n\n   LowestCommonAncestor(const vector<vector<int>>& g, int root = 0) : g(g), dep(g.size()), LOG(0), root(root) {\n      int k = 0;\n      for (; (1 << k) <= g.size(); ++k) {}\n      const_cast<int&>(LOG) = k + 1;\n      table.assign(LOG, vector<int>(g.size(), -1));\n   }\n\n   void dfs(int u, int par, int d) {\n      table[0][u] = par;\n      dep[u] = d;\n      for (auto& v : g[u]) if (v != par) dfs(v, u, d + 1);\n   }\n\n   void build() {\n      dfs(root, -1, 0);\n      for (int k = 0; k + 1 < LOG; ++k) {\n         for (int i = 0; i < g.size(); ++i) {\n            if (table[k][i] < 0) table[k + 1][i] = -1;\n            else table[k + 1][i] = table[k][table[k][i]];\n         }\n      }\n   }\n\n   int query(int u, int v) {\n      if (dep[u] > dep[v]) swap(u, v);\n      for (int k = 0; k < LOG; ++k) {\n         if ((dep[v] - dep[u]) >> k & 1) v = table[k][v];\n      }\n      if (u == v) return u;\n      for (int i = LOG - 1; i >= 0; --i) {\n         if (table[i][u] != table[i][v]) {\n            u = table[i][u];\n            v = table[i][v];\n         }\n      }\n      return table[0][u];\n   }\n};\n\nint main() {\n   int n; cin >> n;\n   vector<vector<int>> g(n);\n   rep(i, n) {\n      int k; cin >> k;\n      rep(j, k) {\n         int u; cin >> u;\n         g[i].emplace_back(u);\n         g[u].emplace_back(i);\n      }\n   }\n\n   LowestCommonAncestor lca(g);\n   lca.build();\n   int Q; cin >> Q;\n   rep(i, Q) {\n      int u, v; cin >> u >> v;\n      cout << lca.query(u, v) << endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];//*\nint size[MAX];// *\nint par[MAX];// *\nint cur[MAX];// *\nint dep[MAX];// *\nint depth[MAX];\nint het[MAX];\nint parent[MAX];\n\nvoid idfs(int pos,int prev){\n  int m=-1;\n  parent[pos]=prev;\n  if(G[pos].size()==1&&prev!=-1)return;  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    depth[to]=depth[pos]+1;\n    idfs(to,pos);\n    size[pos]+=size[to];\n    het[pos]=max(het[pos],het[to]+1);\n    if(m==-1||size[m]<size[to]){\n      m=to;\n    }\n  }\n  cur[pos]=m;\n  par[m]=pos;\n  het[pos]=max(het[pos],het[m]);\n}\n\nint calc(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    par[x]=calc(par[x]);\n    return par[x];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n    size[i]=1;\n    par[i]=i;\n    cur[i]=-1;\n    dep[i]=0;\n    depth[i]=0;\n    het[i]=0;\n    parent[i]=0;\n  }\n  for(int i=0;i<n;i++){    \n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n      G[b].push_back(i);\n    }\n  }\n  for(int i=0;i<n;i++)sort(G[i].begin(),G[i].end());\n  depth[0]=0;\n  idfs(0,-1);\n  for(int i=0;i<n;i++){\n    int root=calc(i);\n    het[i]=het[root];\n    int p=par[i];\n    while(p>0){\n      p= par[ parent[p] ];      \n      dep[i]++;\n    }\n\n    /*    \n    cout<< (char)('A'+i) <<\"   -> \";\n    cout<< (char)('A'+par[i]) <<endl;    \n    cout<<\"size = \"<< size[i]<<\" , \";    \n    cout<<\"depth = \"<< depth[i]<<\" , \";\n    cout<<\"dep = \"<< dep[i]<<\" , \";\n    cout<<\"parent = \"<< (char)('A'+parent[i]) <<\" , \";\n    cout<<\"cur = \"<< (char)('A'+cur[i]) <<\" , \";\n    cout<<\"het = \"<< het[i] << endl;\n    \n    cout<<endl;\n    */\n  }\n\n  \n}\n\nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n      scanf(\"%d %d\",&a,&b);\n      if(par[a]==par[b])printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n      else{\n        while(par[a]!=par[b]){\n          if(dep[a]<dep[b])swap(a,b);\n          a=parent[par[a]];\n        }\n        printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n      }\n    }\n    break;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n/*\n\n\t<LowerCommonAncestor>\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n\n\nstruct Graph\n{\n\tstruct edge\n\t{\n\t\tint to;\n\t};\n\n\tint n;\n\tvector<vector<edge>> edges;\n\n\tGraph(int N)\n\t{\n\t\tn = N;\n\t\tedges.resize(n,vector<edge>());\n\t}\n\n\tint size() const\n\t{\n\t\treturn n;\n\t}\n\n\tvector<edge>& operator[](int v)\n\t{\n\t\treturn edges[v];\n\t}\n};\n\n\nstruct Lca\n{\n\tint n;\n\tint log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\n\tLca(Graph& g , int root)\n\t{\n\t\tn = g.size();\n\t\tlog2_n = floor(log2(n) + 2);\n\t\tparent.resize(log2_n,vector<int>(n));\n\t\tdepth.resize(n);\n\n\t\tdfs(g,root,-1,0);\n\t\tfor(int k = 0;k + 1 < log2_n;k++)\n\t\t{\n\t\t\tfor(int v = 0;v < n;v++)\n\t\t\t{\n\t\t\t\tif(parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(Graph &g , int v,int p,int d)\n\t{\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor(auto& e : g[v])\n\t\t{\n\t\t\tif(e.to != p)\n\t\t\t\tdfs(g,e.to,v,d + 1);\n\t\t}\n\t}\n\n\tint get(int u,int v)\n\t{\n\t\tif(depth[u] > depth[v]) swap(u,v);\n\t\tfor(int k = 0;k < log2_n;k++)\n\t\t{\n\t\t\tif((depth[v] - depth[u]) >> k & 1)\n\t\t\t{\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int k = log2_n - 1;k >= 0;k--)\n\t\t{\n\t\t\tif(parent[k][u] != parent[k][v])\n\t\t\t{\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tGraph g(n);\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 0;j < k;j++)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tg[i].push_back({c});\n\t\t}\n\t}\n\n\tLca lca(g,0);\n\n\tint q;\n\tcin >> q;\n\n\tfor(int i = 0;i < q;i++)\n\t{\n\t\tint u,v;\n\t\tcin >> u >> v;\n\n\t\tcout << lca.get(u,v) << endl;\n\t}\n\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/* Задано дерево с корнем, содержащее (1 ≤ n ≤ 100 000) вершин, пронумерованных от 0 до n-1.\n * Требуется ответить на m (1 ≤ m ≤ 10 000 000) запросов о наименьшем общем предке для пары вершин.\n * Запросы генерируются следующим образом. Заданы числа a1, a2 и числа x, y и z.\n * Числа a3, ..., a2m генерируются следующим образом: ai = (x ⋅ ai-2 + y ⋅ ai-1 + z) mod n.\n * Первый запрос имеет вид (a1, a2). Если ответ на i-1-й запрос равен v, то i-й запрос имеет вид ((a2i-1 + v) mod n, a2i).\n * Для решения задачи можно использовать метод двоичного подъёма.\n */\n\nusing namespace std;\n\n// Ячейка в дереве отрезков\nclass Node {\nprivate:\n    unsigned long long left, right;\n    unsigned long long value;\n    // [left, right) - отрезок, за который \"отвечает\" данная вершина\n    // значение на отрезке\n    const unsigned long long INF = 1e9 + 7;\n\npublic:\n    Node() {\n        left = 0;\n        right = 0;\n        value = INF;\n    }\n\n    unsigned long long get_left() {\n        return left;\n    }\n\n    unsigned long long get_right() {\n        return right;\n    }\n\n    unsigned long long get_value() {\n        return value;\n    }\n\n    unsigned long long set_left(unsigned long long _left) {\n        left = _left;\n    }\n\n    unsigned long long set_right(unsigned long long _right) {\n        right = _right;\n    }\n\n    unsigned long long set_value(unsigned long long _value) {\n        value = _value;\n    }\n\n    unsigned long long get_INF() {\n        return INF;\n    }\n};\n\nclass MyGraph {\nprivate:\n    vector<unsigned long long> order;\n    vector<unsigned long long> high, first;\n    vector<vector<unsigned long long> > gr;\n    unsigned long long n, root = 0, m;\n\npublic:\n    MyGraph() {}\n\n    vector<unsigned long long>& adjacent(unsigned long long v) {\n        return gr[v];\n    }\n\n    void dfs(unsigned long long v, unsigned long long h) {\n        order.push_back(v);\n        first[v] = order.size() - 1;\n        for (unsigned long long u : adjacent(v)) {\n//            cout << v << \" \" << u << endl;\n            if (high[u] == 0) {\n                dfs(u, h + 1);\n                order.push_back(v);\n                high[u] = h + 1;\n            }\n        }\n    }\n\n    unsigned long long get_root() {\n        return root;\n    }\n\n    vector<unsigned long long>& get_order() {\n        return order;\n    }\n\n    unsigned long long get_queries_num() {\n        return m;\n    }\n\n    unsigned long long get_high(unsigned long long v) {\n        return high[v];\n    }\n\n    unsigned long long get_first(unsigned long long v) {\n        return first[v];\n    }\n\n    unsigned long long get_order_size() {\n        return order.size();\n    }\n\n    unsigned long long get_size() {\n        return n;\n    }\n\n    friend istream& operator >>(istream&, MyGraph&);\n};\n\nistream& operator >>(istream& in, MyGraph& g){\n    in >> g.n;\n    g.high.resize(g.n, 0);\n    g.first.resize(g.n);\n    g.gr.resize(g.n, vector<unsigned long long>());\n\n    for (int i = 0; i < g.n; i++) {\n        unsigned long long k;\n        in >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            in >> c;\n            g.gr[i].push_back(c);\n        }\n    }\n\n    in >> g.m;\n}\n\nclass SegmentTree{\nprivate:\n    vector<Node> tree; // дерево\n    unsigned long long len, n;\n    const unsigned long long INF = 1e9 + 7;\n    unsigned long long ans = 0;\n\npublic:\n    SegmentTree() {};\n\n    unsigned long long find_min(MyGraph& g, unsigned long long x, unsigned long long y) {\n        if (g.get_high(x) < g.get_high(y))\n            return x;\n        else\n            return y;\n    }\n\n    // Находит индексы вершин, отвечающих за отрезки, входящие в запрос\n    unsigned long long find_ans(unsigned long long ind, unsigned long long ll, unsigned long long rr, MyGraph& g) {\n//        cout << ind << endl;\n\n        // Если индекс выходит за пределы дерева\n        if (ind >= len * 2)\n            return INF;\n\n        // Если вершина с данным индексом не отвечает за реальные данные\n        if (tree[ind].get_value() == tree[ind].get_INF())\n            return INF;\n\n        // Если вершина \"отвечает\" за отрезок, не входящий в запрос\n        if ((tree[ind].get_left() >= rr) || (tree[ind].get_right() <= ll))\n            return INF;\n\n//        cout << ind << \" \" << tree[ind].get_left() << \" \" << tree[ind].get_right() << endl;\n//        cout << \"  \" << ll << \" \" << rr << endl;\n\n        // Если вершина отвечает за отрезок, полностью лежащий в запросе\n        if ((tree[ind].get_left() >= ll) && (tree[ind].get_right() <= rr)) {\n//            cout << \"value \" << tree[ind].get_value() << endl;\n            return tree[ind].get_value();\n        }\n\n        unsigned long long x = find_ans(ind * 2, ll, rr, g);\n//        cout << x << endl;\n        unsigned long long y = find_ans(ind * 2 + 1, ll, rr, g);\n//        cout << y << endl;\n\n        if (y == INF)\n            return x;\n        if (x == INF)\n            return y;\n\n        return find_min(g, x, y);\n    }\n\n    // Выполняет запросы\n    void queries(MyGraph& g) {\n//        unsigned long long a1, a2, x, y, z;\n//        cin >> a1 >> a2 >> x >> y >> z;\n        unsigned long long a1, a2;\n\n        for (int i = 0; i < g.get_queries_num(); i++) {\n            cin >> a1 >> a2\n//            cout << \"---query \" << i + 1 << \"---\\n\";\n            unsigned long long left = g.get_first(a1), right = g.get_first(a2);\n            if (right < left)\n                swap(left, right);\n//            cout << left << \" \" << r\n// << endl;\n            unsigned long long v = find_ans(1, left, right + 1, g);\n//            a1 = (x * a1 + y * a2 + z) % n;\n//            a2 = (x * a2 + y * a1 + z) % n;\n//            a1 = (a1 + v) % n;\n            ans += v;\n            cout << v << endl;\n        }\n    }\n\n    void build_tree(MyGraph& g) {\n        n = g.get_size();\n        unsigned long long len_log = (unsigned long long) trunc(log2((double) g.get_order_size())) + 1;\n        len = (1 << len_log);\n        tree.resize(len * 2);\n\n        vector<unsigned long long>& order1 = g.get_order();\n        for (int i = 0; i < len; ++i) {\n            if (i < g.get_order_size())\n                tree[i + len].set_value(order1[i]);\n            else\n                tree[i + len].set_value(INF);\n            tree[len + i].set_left(i);\n            tree[len + i].set_right(i + 1);\n        }\n\n        for (int i = len - 1; i > 0; --i) {\n            unsigned long long ind1 = 2 * i, ind2 = 2 * i + 1;\n            tree[i].set_left(tree[ind1].get_left());\n            tree[i].set_right(tree[ind2].get_right());\n            if (tree[ind2].get_value() == INF)\n                tree[i].set_value(tree[ind1].get_value());\n            else\n                tree[i].set_value(find_min(g, tree[ind1].get_value(), tree[ind2].get_value()));\n        }\n\n//        for (int i = 1; i < tree.size(); i++)\n//            cout << tree[i].get_value() << \" \";\n//        cout << endl;\n    }\n\n    friend ostream& operator <<(ostream&, SegmentTree&);\n};\n\nostream& operator <<(ostream& out, SegmentTree& t) {\n    out << t.ans << endl;\n}\n\nint main() {\n    MyGraph graph;\n    cin >> graph;\n//    cout << \"--dfs--\" << endl;\n    graph.dfs(graph.get_root(), 0);\n//    cout << graph.get_size() << endl;\n//    for (int i = 0; i < graph.get_size(); i++)\n//        cout << graph.get_high(i) << \" \";\n//    cout << endl;\n    SegmentTree st;\n//    cout << \"keka\\n\";\n    st.build_tree(graph);\n//    cout << \"peka\\n\";\n    st.queries(graph);\n//    cout << st;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<functional>\n#include<stack>\n#include<tuple>\n\nusing namespace std;\n\n//STL: <functional>\ntemplate <class Monoid> struct SegTree {\n\tint N;\n\tvector<Monoid> node;\n\tstd::function<Monoid(Monoid, Monoid)> operation;\n\tMonoid unit;//単位元\n\n\tstd::function<bool(Monoid, Monoid)> comp;\n\tMonoid not_find_sgn;\n\n\tSegTree() = default;\n\n\tSegTree(vector<Monoid>& data, std::function<Monoid(Monoid, Monoid)> op, Monoid U) {\n\t\t//データ　演算　単位元\n\t\toperation = op;\n\t\tunit = U;\n\t\tint size = data.size();\n\t\tN = 1;\n\t\twhile (N < size)N <<= 1;\n\t\tnode.resize(2 * N - 1, unit);\n\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tnode[i + N - 1] = data[i];\n\t\t}\n\n\t\tfor (int i = N - 2; i >= 0; i--) {\n\t\t\tnode[i] = operation(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvoid update(int pos, Monoid val) {\n\t\tpos += N - 1;\n\t\tnode[pos] = val;\n\t\twhile (pos > 0) {\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tnode[pos] = operation(node[pos * 2 + 1], node[pos * 2 + 2]);\n\t\t}\n\t}\n\n\tMonoid getval(int a, int b, int idx, int l, int r = -1) {\n\t\t//[a, b)を求める。　使い方はgetval(a, b, );\n\t\tif (r == -1)r = N;\n\t\tif (b <= l || r <= a)return unit;\n\t\tif (a <= l && r <= b)return node[idx];\n\t\tMonoid left = getval(a, b, idx * 2 + 1, l, (l + r) / 2);\n\t\tMonoid right = getval(a, b, idx * 2 + 2, (l + r) / 2, r);\n\t\treturn operation(left, right);\n\t}\n\n\tMonoid getval(int a, int b) {\n\t\t//ラッパー。\n\t\treturn getval(a, b, 0, 0, -1);\n\t}\n\n};\n\n//STL:<tuple> <algorithm>  MyLibrary: \"SegTree\" \nstruct LCA {\n\tSegTree<pair<int, int>> rmq;\n\tvector<int> dfs_tour_order;\n\tvector<pair<int, int>> visited_order;//pos, depth\n\n\tvoid dfs(vector<vector<int>>& E, int pos, int beforepos, int depth) {\n\t\tif (dfs_tour_order[pos] == -1)dfs_tour_order[pos] = visited_order.size();\n\t\tvisited_order.push_back(make_pair(pos, depth));\n\t\tfor (int i = 0; i < E[pos].size(); i++) {\n\t\t\tint nxt = E[pos][i];\n\t\t\tif (nxt == beforepos)continue;\n\t\t\tdfs(E, nxt, pos, depth + 1);\n\t\t\tvisited_order.push_back(make_pair(pos, depth));\n\t\t}\n\t}\n\n\tLCA(vector<vector<int>>& E, int root) {\n\t\t//基本的に0-idxで\n\t\tdfs_tour_order.resize(E.size(), -1);//初めてその頂点を尋ねた際、何番目の\n\t\t\n\t\tdfs(E, root, -1, 0);\n\n\t\trmq = SegTree<pair<int, int>>(visited_order,\n\t\t\t[](pair<int, int> a, pair<int, int> b) {\n\t\t\tif (a.second != b.second) return a.second > b.second ? b : a; \n\t\t\treturn a.first > b.first ? b : a;//ここは逆の順番にしてもいい。LCAは最終的には一位に定まり、aとbのsecondによってユニークのため\n\t\t}\n\t\t, make_pair(0, E.size()));\n\t}\n\t\n\tpair<int, int> lca(int u, int v) {\n\t\t//LCAになってる頂点の番号と、根から見た深さを返す\n\t\tif (dfs_tour_order[u] > dfs_tour_order[v])swap(u, v);\n\t\treturn rmq.getval(dfs_tour_order[u], dfs_tour_order[v] + 1);\n\t}\n\n\tint dis(int u, int v) {\n\t\t//u->vへの最短距離\n\t\tint root_to_u = rmq.getval(dfs_tour_order[u], dfs_tour_order[u] + 1).second;\n\t\tint root_to_v = rmq.getval(dfs_tour_order[v], dfs_tour_order[v] + 1).second;\n\t\treturn root_to_u + root_to_v - 2 * lca(u, v).second;\n\t}\n\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> E(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tE[i].push_back(c);\n\t\t\tE[c].push_back(i);\n\t\t}\n\t}\n\n\tLCA lca(E, 0);\n\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.lca(u, v).first << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n//by NeighThorn\nusing namespace std;\nconst int maxn=100000+5;\nint n,q,hd[maxn],to[maxn*2],nxt[maxn*2],cnt,vis[maxn],fa[maxn],ans[maxn];\nstruct M{\n    int y,id;\n    M(int a=0,int b=0){\n        y=a,id=b;\n    }\n};\nvector<M> v[maxn];\ninline int find(int x){\n    return fa[x]==x?x:fa[x]=find(fa[x]);    \n}\ninline void add(int x,int y){\n    to[cnt]=y;nxt[cnt]=hd[x];hd[x]=cnt++;   \n}\ninline void tarjan(int root){\n    vis[root]=1;\n    for(int i=0;i<(int)v[root].size();i++)\n        if(vis[v[root][i].y])\n            ans[v[root][i].id]=find(v[root][i].y);\n    for(int i=hd[root];i!=-1;i=nxt[i])\n        if(!vis[to[i]])\n            tarjan(to[i]),fa[to[i]]=root;\n}\nsigned main(void){\n    scanf(\"%d\",&n);cnt=0;\n    memset(hd,-1,sizeof(hd));\n    for(int i=0,k;i<n;i++){\n        scanf(\"%d\",&k);\n        for(int j=1,x;j<=k;j++)\n            scanf(\"%d\",&x),add(i,x),add(x,i);\n    }scanf(\"%d\",&q);\n    for(int i=0;i<n;i++)\n        fa[i]=i,vis[i]=0;\n    for(int i=1,x,y;i<=q;i++)\n        scanf(\"%d%d\",&x,&y),v[x].push_back(M(y,i)),v[y].push_back(M(x,i));\n    tarjan(0);\n    for(int i=1;i<=q;i++)\n        printf(\"%d\\n\",ans[i]);\n    return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define MAX_V 100010\n#define MAX_LOG_V 20\n\nvector<int> edge[MAX_V];\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nstruct LCA{\n  int root;\n\n  LCA(int r): root(r){}\n\n  void add_edge(int a, int b) {\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  \n  void dfs(int v, int par, int dep) {\n    parent[0][v] = par;\n    depth[v] = dep;\n    for (auto child : edge[v]) {\n      if (child != par) dfs(child, v, dep + 1);\n    }\n  }\n\n  void init(int V) {\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n      for (int v = 0; v < V; v++) {\n\tif (parent[k][v] < 0) {\n\t  parent[k+1][v] = -1;\n\t} else {\n\t  parent[k+1][v] = parent[k][parent[k][v]];\n\t}\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n\tv = parent[k][v];\n      }\n    }\n    if (u == v) return u;\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n\tu = parent[k][u];\n\tv = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  int N;\n  LCA lca(0);\n  \n  scanf(\"%d\", &N);\n  REP(i, N) {\n    int k;\n    scanf(\"%d\", &k);\n    REP(j, k) {\n      int c;\n      scanf(\"%d\", &c);\n      lca.add_edge(i, c);\n    }\n  }\n  lca.init(N);\n  int Q;\n  scanf(\"%d\", &Q);\n  REP(i, Q) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", lca.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPr(i, n) for(int i = (n)-1; i >= 0; --i)\n#define FORq(i, m, n) for(int i = (m); i <= (n); ++i)\n#define FORqr(i, m, n) for(int i = (n); i >= (m); --i)\n#define MP make_pair\n#define SIN(x, S) (S.count(x) != 0)\n#define M0(x) memset(x, 0, sizeof(x))\n#define FILL(x, y) memset(x, y, sizeof(x))\n#define MM(x) memset(x, -1, sizeof(x))\n#define ALL(x) (x).begin(), (x).end()\n#define DB(x) cerr << #x << \" = \" << x << endl\n#define DB2(x, y)                                                              \\\n    cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\";\n#define DEBUG                                                                  \\\n    int x12345;                                                                \\\n    cin >> x12345;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n///////////////////////////////////////////////\nconst long long MOD = 1e9 + 7;\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n///////////////////////////////////////////////\n/// 🍈( '-' 🍈 |AC|\n\ntemplate <typename C>\nstruct Vertex{\n    C cost;\n    bool done;\n    int from;\n    vector<int> edges_to; //to vertex number\n\tvector<C> edges_cost; // edge cost\n\n    bool operator<(const Vertex& another) const { // priority --> min\n        return another.cost < cost; // order(cost)\n    }\n\t\n\tbool operator==(const Vertex& another) const {\n        return another.cost == cost; // order(cost)\n    }\n};\n\ntemplate <typename C>\nstruct Graph{\n    vector<Vertex<C>> vertex;\n    Graph(int n){\n        vertex.resize(n);\n    }\n\n    void resize(int n){\n        vertex.resize(n);\n    }\n\n    void addedgedir(int x,int y){\n        vertex[x].edges_to.push_back(y);\n    }\n    void addedge(int x, int y){\n        vertex[x].edges_to.push_back(y);\n        vertex[y].edges_to.push_back(x);\n    }\n\n    void caddedgedir(int x, int y, C c){\n        vertex[x].edges_to.push_back(y);  \n        vertex[x].edges_cost.push_back(c);  \n    }\n\n    void caddedge(int x, int y, C c){\n        vertex[x].edges_to.push_back(y);  \n        vertex[x].edges_cost.push_back(c);  \n        vertex[y].edges_to.push_back(x);  \n        vertex[y].edges_cost.push_back(c); \n    }\n\n    void dijkstra(int start){\n        int N = vertex.size();\n        priority_queue<C> Q;\n        \n        REP(i,N){\n            vertex[i].done = false;\n            vertex[i].cost = -1;\n        }\n        \n        vertex[start].cost = 0; //start\n        Q.push(start);\n        \n        while (!Q.empty()){\n            int now = Q.top(); Q.pop();\n            vertex[now].done = true;\n            REP(i,vertex[now].edges_to.size()){\n                int nto = vertex[now].edges_to[i];\n                C ncost = vertex[now].cost + vertex[now].edges_cost[i];\n                if (((vertex[nto].cost) < 0) or (ncost < vertex[nto].cost)){  //not visited or required refresh\n                    vertex[nto].cost = ncost;\n                    vertex[nto].from = now;\n                    Q.push(nto);\n                }\t\n            }\n        }\n    }\n\n};\n\ntemplate<typename C>\nstruct DoublingLowestCommonAncestor{\n    const Graph<int> &g;\n    int N;\n    vector<int> depth;\n    const int LOG; // default = 32\n    vector<vector<int>> bpar; //bpar[k][v] vが2^k回上にいったときのvertex\n    DoublingLowestCommonAncestor(const Graph<int> &g) : g(g),depth(g.vertex.size()) ,LOG(32){\n        bpar.assign(LOG,vector< int > (g.vertex.size(), -1) );\n    }\n\n    void dfs(int v,int p, int d){\n        // v .. now vertex, p .. parent , d .. depth\n        bpar[0][v] = p;\n        depth[v] = d;\n        int Enum = g.vertex[v].edges_to.size();\n        for(int i = 0; i < Enum; i++){\n            for (int j = 0; j < g.vertex[v].edges_to.size(); j++){\n                if (g.vertex[v].edges_to[j] != p) dfs(g.vertex[v].edges_to[j],v,d+1);\n            }\n        }\n    }\n\n    void bfs(int root){\n        queue<int> Q;\n        vector<bool> vis;\n        vis.assign(g.vertex.size(),false);\n        Q.push(root);\n        while(!Q.empty()){\n            int now = Q.front();\n            Q.pop();\n            vis[now] = true;\n            REP(i,g.vertex[now].edges_to.size()){\n                int next = g.vertex[now].edges_to[i];\n                if (vis[next]) continue;\n                bpar[0][next] = now;\n                depth[next] = depth[now] + 1;\n                Q.push(next);\n            }\n        }\n    }\n\n    void build(int root){\n        int GS = g.vertex.size();\n        //dfs(root,-1,0);\n        bfs(root);\n        for(int k = 0; k + 1 < LOG; k++){\n            for(int i = 0; i < GS; i++){\n                if (bpar[k][i] == -1) bpar[k+1][i] = -1;\n                else bpar[k+1][i] = bpar[k][bpar[k][i]];\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        if (depth[u] > depth[v]) swap(u,v);\n        for(int i = LOG - 1; i >= 0; i--){\n            if (((depth[v] - depth[u]) >> i) & 1) v = bpar[i][v]; \n        }\n        if (u == v) return u;\n        for(int i = LOG - 1; i >= 0; i--){\n            if (bpar[i][u] != bpar[i][v]){\n                u = bpar[i][u];\n                v = bpar[i][v];\n            }\n        }\n        return bpar[0][u];\n    }\n};\n\nint main() {\n    clock_t t1 = clock();\n    int n;\n    scanf(\"%d\\n\",&n);\n    Graph<int> G(n);\n    REP(i,n){\n        int k; scanf(\"%d\",&k);\n        REP(j,k){\n            int c; scanf(\"%d\",&c);\n            \n            G.addedgedir(i,c);\n        }\n    }\n    clock_t t2 = clock();\n    DoublingLowestCommonAncestor<Graph<int>> LCA(G);\n    \n    LCA.build(0);\n    clock_t t3 = clock();\n\n    int q; scanf(\"%d\",&q);\n    REP(i,q){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\",LCA.lca(u,v));\n    }\n    clock_t t4 = clock();\n    const double time1 = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC * 1000.0;\n    const double time2 = static_cast<double>(t3 - t2) / CLOCKS_PER_SEC * 1000.0;\n    const double time3 = static_cast<double>(t4 - t3) / CLOCKS_PER_SEC * 1000.0;\n\n    //cout << time1 << \"ms \\n\";\n    //cout << time2 << \"ms \\n\";\n    //cout << time3 << \"ms \\n\";\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> >tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),path(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v)); //Heavy, Light\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAX_N 100100\n#define MAX_LOG_N 20\nint N,root;\nvector<int> g[MAX_N];\nint depth[MAX_N];\nint par[MAX_N][MAX_LOG_N];\nvoid dfs(int v,int p,int d){\n  par[v][0]=p;\n  depth[v]=d;\n  for(int i=0;i<g[v].size();i++){\n    if(g[v][i]==p)continue;\n    dfs(g[v][i],v,d+1);\n  }\n}\nvoid fill_table(){\n  for(int i=0;i<19;i++){\n    for(int j=0;j<N;j++){\n      if(par[j][i]==-1)par[j][i+1]=-1;\n      else par[j][i+1]=par[par[j][i]][i];\n    }\n  }\n\n}\nint lca(int u,int v){\n  if(depth[u]>depth[v])swap(u,v);\n  for(int i=19;i>=0;i--){\n    if(((depth[v]-depth[u])>>i)&1)v=par[v][i];\n  }\n  if(u==v)return u;\n  for(int i=19;i>=0;i--){\n    if(par[u][i]!=par[v][i]){\n      u=par[u][i];\n      v=par[v][i];\n    }\n  }\n \n  return par[u][0];\n}\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int k;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      int x;\n      cin >> x ;\n      g[i].push_back(x);\n    }\n  }\n  root=0;\n  dfs(root,-1,0);\n \n  fill_table();\n \n  int Q;\n  cin >> Q;\n  for(int i=0;i<Q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << lca(u,v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 1<<31-1\n\n\nint n;\nvector<int> G[100000];\nvector<int> depth,vs;\nint id[100000]={};\n//pii dat[4*100000];\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n    \n    void print(){\n        rep(i,_size*2)cout<<dat[i].first<<\" \"<<dat[i].second<<endl;\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\nint main(){\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int a;\n            cin>>a;\n            G[i].pb(a);\n        }\n    }\n    \n    init();\n    segtree<pii> st(depth.size(),pii(INF,INF));\n    rep(i,depth.size()){\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int q;\n    cin>>q;\n    rep(i,q){\n        int a,b;\n        cin>>a>>b;\n        cout<<st.find(id[a],id[b]).second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n??\ntemplate <typename T>\nstruct RMQ {\n????using Index = int;\n????using BitIndex = int;\n??\n????const std::vector<T>& A;\n????const int N, S, L, LG_L;\n??\n????std::vector<int> lg;\n????BitIndex* const small;\n????Index* const large;\n??\n????bool f(Index a, Index b) const {\n????????if (A[a] != A[b]) return A[a] < A[b];\n????????return a < b;\n????}\n????RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n????Index query(Index l, Index r) const {\n????????const int a = l / S, b = r / S;\n????????if (a == b) return query_small(l, r);\n??\n????????Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n????????if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n????????return ans;\n????}\n????~RMQ() {\n????????std::free(small);\n????????std::free(large);\n????}\nprivate:\n????inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n??\n????RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n????RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n????RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n????RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n????????????: A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n????????assert(small != nullptr);\n????????assert(large != nullptr);\n????????for (int i = 1, sz = lg.size(); i < sz; i++) {\n????????????lg[i] = std::__lg(i);\n????????}\n????????for (int li = 0; li < L; li++) {\n????????????int i = li * S;\n????????????large[li * LG_L + 0] = i;\n????????????for (int si = 0; si < S && i + si < N; si++) {\n????????????????large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n????????????}\n????????}\n????????for (int x = 0; x < LG_L - 1; x++) {\n????????????for (int li = 0; li + (1 << x) < L; li++) {\n????????????????large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n????????????}\n????????}\n????????Index st[32];\n????????for (int li = 0; li < L; li++) {\n????????????int i = li * S;\n????????????int sti = 0;\n????????????for (int si = 0; si < S && i + si < N; si++) {\n????????????????while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n????????????????small[i + si] |= 1 << si;\n????????????????if (sti > 0) small[i + si] |= small[st[sti - 1]];\n????????????????st[sti] = i + si;\n????????????????++sti;\n????????????}\n????????}\n????}\n????inline int ntz(int x) const { return lg[x & -x]; }\n????inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n????inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n????inline Index query_large(Index l, Index r) const {\n????????int x = lg[r - l + 1];\n????????return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n????}\n};\n#include <vector>\n#include <unordered_map>\n??\nstruct EulerTour {\n????using tree_type = std::vector<std::vector<int>>;\n????tree_type T;\n????std::vector<int> id, depth;\n????std::vector<int> ord;\n??\n????EulerTour(int N) : T(N), ord(N) {}\n??\n????void add_edge(int s, int t) {\n????????T[s].push_back(t);\n????????T[t].push_back(s);\n????}\n??\n????void build(int root) {\n????????id.reserve(T.size() * 3);\n????????depth.reserve(T.size() * 3);\n????????traverse(root);\n????????id.shrink_to_fit();\n????????depth.shrink_to_fit();\n????}\n??\n????void traverse(int u, int p=-1, int d=0) {\n????????ord[u] = id.size();\n????????id.push_back(u);\n????????depth.push_back(d);\n????????for (int v : T[u]) {\n????????????if (v == p) continue;\n????????????traverse(v, u, d + 1);\n????????????id.push_back(u);\n????????????depth.push_back(d);\n????????}\n????}\n};\n#include <vector>\n??\nstruct LCA {\n????EulerTour& euler_tour;\n????const RMQ<int> rmq;\n??\n????LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n??\n????int query(int u, int v) const {\n????????int l = euler_tour.ord[u];\n????????int r = euler_tour.ord[v];\n????????if (r < l) std::swap(r, l);\n????????int x = rmq.query(l, r);\n????????return euler_tour.id[x];\n????}\n};\n??\n#include <bits/stdc++.h>\nusing namespace std;\n??\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n??\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n??\nint main() {\n????int N = rd();\n????EulerTour et(N);\n????for (int i = 0; i < N; i++) {\n????????int k = rd();\n????????et.T[i].reserve(k);\n????????for (int j = 0; j < k; j++) {\n????????????et.T[i].push_back(rd());\n????????}\n????}\n????et.build(0);\n????LCA lca(et);\n????int Q = rd();\n????for (int i = 0; i < Q; i++) {\n????????int u = rd(), v = rd();\n????????wr(lca.query(u, v));\n????}\n????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];\nint size[MAX];\nint par[MAX];\nint dep[MAX];\nint depth[MAX];\nint parent[MAX];\n\nvoid idfs(int pos,int prev){\n  int m=-1;\n  parent[pos]=prev;\n  if(G[pos].empty())return;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    depth[to]=depth[pos]+1;\n    idfs(to,pos);\n    size[pos]+=size[to];\n    if(m==-1||size[m]<size[to]){\n      m=to;\n    }\n  }\n  par[m]=pos;\n}\n\nint calc(int x){\n  if(par[x]==x)return x;\n  return par[x]=calc(par[x]);\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    size[i]=1;\n    par[i]=i;\n  }\n  for(int i=0;i<n;i++){    \n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n    }\n  }\n  \n  depth[0]=0;\n  idfs(0,-1);\n  for(int i=0;i<n;i++){\n    calc(i);\n    int p=par[i];\n    while(p>0){\n      p= par[ parent[p] ];      \n      dep[i]++;\n    }\n  }  \n}\n\nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n      scanf(\"%d %d\",&a,&b);\n\n      while(par[a]!=par[b]){\n        if(dep[a]<dep[b])swap(a,b);\n        a=parent[par[a]];\n      }\n      printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n\n    }\n    break;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <stack>\n#include <vector>\n\nclass kth_ancestor {\n\n\tusing size_type = ::std::uint_least64_t;\n\tusing container_type = ::std::vector<size_type>;\n\tusing iterator = typename container_type::iterator;\n\tusing const_iterator = typename container_type::const_iterator;\n\tusing difference_type = typename container_type::difference_type;\n\n\tstatic size_type msb(size_type c) noexcept {\n\t\tstatic_assert(\n\t\t\t::std::numeric_limits<size_type>::digits == 64,\n\t\t\t\"this implementation is specialized for 64 bit unsigned integer\");\n#ifdef __has_builtin\n\t\treturn static_cast<size_type>(63 - __builtin_clzll(c));\n#else\n\t\tstatic const ::std::array<::std::uint_least8_t, 64> table = {\n\t\t\t0,  1,  2,  7,  3,  13, 8,  27, 4,  33, 14, 36, 9,  49, 28, 19,\n\t\t\t5,  25, 34, 17, 15, 53, 37, 55, 10, 46, 50, 39, 29, 42, 20, 57,\n\t\t\t63, 6,  12, 26, 32, 35, 48, 18, 24, 16, 52, 54, 45, 38, 41, 56,\n\t\t\t62, 11, 31, 47, 23, 51, 44, 40, 61, 30, 22, 43, 60, 21, 59, 58 };\n\t\tc |= c >> 1;\n\t\tc |= c >> 2;\n\t\tc |= c >> 4;\n\t\tc |= c >> 8;\n\t\tc |= c >> 16;\n\t\tc |= c >> 32;\n\t\treturn static_cast<size_type>(\n\t\t\ttable[((c >> 1) + 1) * 0x218A7A392DD9ABFULL >> 58 & 0x3F]);\n#endif\n\t\t// for 32 bit\n\t\t/*\n\t\tstatic const ::std::array<::std::uint_least8_t, 32> table = {\n\t\t0,  1, 2,  6,  3,  11, 7,  16, 4,  14, 12, 21, 8,  23, 17, 26,\n\t\t31, 5, 10, 15, 13, 20, 22, 25, 30, 9,  19, 24, 29, 18, 28, 27};\n\t\tc |= c >> 1;\n\t\tc |= c >> 2;\n\t\tc |= c >> 4;\n\t\tc |= c >> 8;\n\t\tc |= c >> 16;\n\t\treturn static_cast<size_type>(\n\t\ttable[((c >> 1) + 1) * 0x4653ADF >> 27 & 0x1F]);\n\t\t*/\n\t}\n\n\tcontainer_type ladder;\n\t::std::vector<const_iterator> jump;\n\npublic:\n\tkth_ancestor(const ::std::vector<size_type> &parents) {\n\t\tconst size_type n = parents.size();\n\t\tassert(!parents.empty() && \"parents must not be empty\");\n\t\t::std::vector<const_iterator> v_to_itr(n + 1);\n\t\t{\n\t\t\t::std::vector<::std::vector<size_type>> rev(n + 1);\n\t\t\tfor (size_type i = static_cast<size_type>(0); i != n; ++i) {\n\t\t\t\trev[parents[i]].emplace_back(i);\n\t\t\t}\n\t\t\t::std::vector<size_type> height(n + 1, static_cast<size_type>(0));\n\t\t\t{\n\t\t\t\t::std::stack<size_type, ::std::vector<size_type>> st(rev[n]);\n\t\t\t\twhile (!st.empty()) {\n\t\t\t\t\tconst size_type v = st.top();\n\t\t\t\t\tif (height[v] == static_cast<size_type>(0)) {\n\t\t\t\t\t\tfor (const auto e : rev[v]) {\n\t\t\t\t\t\t\tst.emplace(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\theight[v] = static_cast<size_type>(1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tif (height[v] >= height[parents[v]]) {\n\t\t\t\t\t\t\theight[parents[v]] = height[v] + static_cast<size_type>(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto &v : rev) {\n\t\t\t\tfor (auto &e : v) {\n\t\t\t\t\tif (height[v.back()] < height[e]) {\n\t\t\t\t\t\t::std::swap(v.back(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tladder.resize(n * 3 - height[rev[n].back()], n);\n\t\t\tv_to_itr[n] = ladder.cend() - static_cast<difference_type>(n);\n\t\t\t{\n\t\t\t\t::std::stack<size_type, ::std::vector<size_type>> st(rev[n]);\n\t\t\t\titerator itr = ladder.end() - static_cast<difference_type>(n);\n\t\t\t\twhile (!st.empty()) {\n\t\t\t\t\tconst size_type v = st.top();\n\t\t\t\t\tst.pop();\n\t\t\t\t\tif (rev[parents[v]].back() != v) {\n\t\t\t\t\t\titr -= static_cast<difference_type>(height[v]);\n\t\t\t\t\t\t::std::copy(v_to_itr[parents[v]],\n\t\t\t\t\t\t\tv_to_itr[parents[v]] +\n\t\t\t\t\t\t\tstatic_cast<difference_type>(height[v]),\n\t\t\t\t\t\t\titr);\n\t\t\t\t\t}\n\t\t\t\t\t*--itr = v;\n\t\t\t\t\tv_to_itr[v] = itr;\n\t\t\t\t\tfor (const auto e : rev[v]) {\n\t\t\t\t\t\tst.emplace(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (n != static_cast<size_type>(1)) {\n\t\t\tjump.resize(\n\t\t\t\tn * (msb(n - static_cast<size_type>(1)) + static_cast<size_type>(1)));\n\t\t}\n\t\t{\n\t\t\t::std::vector<size_type> curr(n + 1), next(n + 1);\n\t\t\t::std::copy(parents.cbegin(), parents.cend(), curr.begin());\n\t\t\tcurr[n] = n;\n\t\t\tnext[n] = n;\n\t\t\tfor (size_type p = static_cast<size_type>(0);\n\t\t\t\tstatic_cast<size_type>(1) << p < n; ++p) {\n\t\t\t\tconst size_type base = n * p;\n\t\t\t\tfor (size_type i = static_cast<size_type>(0); i != n; ++i) {\n\t\t\t\t\tnext[i] = curr[curr[i]];\n\t\t\t\t\tjump[base + i] = v_to_itr[curr[i]];\n\t\t\t\t}\n\t\t\t\t::std::swap(curr, next);\n\t\t\t}\n\t\t}\n\t}\n\n\tsize_type size() const noexcept { return ladder.back(); }\n\tsize_type get(const size_type x, const size_type k) const noexcept {\n\t\tassert(x < size() && \"index out of range\");\n\t\tif (k >= size()) {\n\t\t\treturn size();\n\t\t}\n\t\telse if (k == static_cast<size_type>(0)) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tconst size_type p = msb(k);\n\t\t\treturn *(\n\t\t\t\tjump[size() * p + x] +\n\t\t\t\tstatic_cast<difference_type>(k - (static_cast<size_type>(1) << p)));\n\t\t}\n\t}\n};\n\n#include <iostream>\n#include <vector>\n\nint main() {\n\tint n;\n\t::std::cin >> n;\n\t::std::vector<int> p(n, n);\n\tfor (int i = 0;i != n;++i) {\n\t\tint k;\n\t\t::std::cin >> k;\n\t\twhile (k--) {\n\t\t\tint c;\n\t\t\t::std::cin >> c;\n\t\t\tp[c] = i;\n\t\t}\n\t}\n\tconst kth_ancestor ka({ p.cbegin(),p.cend() });\n\tint q;\n\t::std::cin >> q;\n\tconst auto depth = [&](const int v) {\n\t\tint ok = 0, ng = n;\n\t\twhile (ng - ok != 1) {\n\t\t\tconst int mid = (ok + ng) / 2;\n\t\t\tif (ka.get(v, mid) != n) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t};\n\twhile (q--) {\n\t\tint u, v;\n\t\t::std::cin >> u >> v;\n\t\tconst int du = depth(u);\n\t\tconst int dv = depth(v);\n\t\tif (du > dv) {\n\t\t\tu = ka.get(u, du - dv);\n\t\t}\n\t\telse {\n\t\t\tv = ka.get(v, dv - du);\n\t\t}\n\t\tint ng = -1, ok = n;\n\t\twhile (ok - ng != 1) {\n\t\t\tconst int mid = (ng + ok) / 2;\n\t\t\tif (ka.get(u, mid) != ka.get(v, mid)) {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t}\n\t\t::std::cout << ka.get(u, ok) << ::std::endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define exist(container, item) (lower_bound(container.begin(),container.end(),item)!=container.end())\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFL 9e18\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\ntemplate<class T>\nstruct augEdge {\n\tT from, to;\n\tint cost;\n\tbool operator<(augEdge e) { return cost < e.cost; }\n\tbool operator>(augEdge e) { return cost > e.cost; }\n};\ntemplate<class T>\nusing augGraph = vector<augEdge<T>>;\n\nclass LCA {\npublic:\n\tint N;\n\tvi depth;\n\tint maxdepth = 0;\n\tvvi dblpar;\n\n\tLCA(const Graph G) {\n\t\tN = G.size();\n\t\tdepth = vi(N);\n\t\tdfs1(G, 0, -1);\n\t\tint D = bindigit(maxdepth) + 1;\n\t\tdblpar = vvi(D, vi(N));\n\t\trep(i, D) {\n\t\t\tdfs2(G, 0, 0, i);\n\t\t}\n\t}\n\n\tvoid dfs1(const Graph &G, int pos, int par, int d = 0) {\n\t\tdepth[pos] = d;\n\t\tmaxdepth = max(maxdepth, d);\n\t\tfor (auto e : G[pos]) {\n\t\t\tif (e.to == par)continue;\n\t\t\tdfs1(G, e.to, pos, d + 1);\n\t\t}\n\t}\n\n\tvoid dfs2(const Graph &G, int pos, int par, int dbl) {\n\t\tif (dbl == 0) {\n\t\t\tdblpar[0][pos] = par;\n\t\t}\n\t\telse {\n\t\t\tdblpar[dbl][pos] = dblpar[dbl - 1][dblpar[dbl - 1][pos]];\n\t\t}\n\t\tfor (auto e : G[pos]) {\n\t\t\tif (e.to == par)continue;\n\t\t\tdfs2(G, e.to, pos, dbl);\n\t\t}\n\t}\n\n\tint parent(int pos, int step) {\n\t\tint ret = pos;\n\t\tint dbl = 0;\n\t\twhile (step > 0) {\n\t\t\tif ((step & 1) != 0) {\n\t\t\t\tret = dblpar[dbl][ret];\n\t\t\t}\n\t\t\tstep >>= 1;\n\t\t\tdbl++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint bindigit(int n) {\n\t\tint ret = 0;\n\t\twhile (n > 0) {\n\t\t\tret++;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint lca(int u, int v) {\n\t\tif (depth[u] < depth[v]) {\n\t\t\tswap(u, v);\n\t\t}\n\t\tu = parent(u, depth[u] - depth[v]);\n\t\tint ng = -1, ok = depth[u];\n\t\twhile (ok - ng > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (parent(u, mid) == parent(v, mid)) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn parent(u, ok);\n\t}\n};\n\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\tGraph G(N);\n\trep(i, N) {\n\t\tint num;\n\t\tcin >> num;\n\t\trep(j, num) {\n\t\t\tint ch;\n\t\t\tcin >> ch;\n\t\t\tG[i].push_back(Edge{ i,ch,1 });\n\t\t\tG[ch].push_back(Edge{ ch,i,1 });\n\t\t}\n\t}\n\n\tLCA lca(G);\n\n\tint Q;\n\tcin >> Q;\n\trep(q, Q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.lca(u, v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.assign(2 * size - 1, make_pair(INF, -1));\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = make_pair(depth[i], et[i]);\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k >= 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tid[n] = eti;\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nstruct UnionFind{\n    vector<int> par,rank,ss;\n    int size;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);if(x==y)return;\n        if(rank[x]>rank[y])swap(x,y);\n        par[x] = y;ss[y]+=ss[x];\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\ntypedef vector<vector<int>> Graph;\nclass TarjanLCA{\npublic:\n\tGraph& g;vector<tuple<int,int,int>>& qs;\n\tUnionFind uf;\n\tvector<int> ancestor;vector<bool> passed;\n\tvector<vector<int>> uquery;\n\tTarjanLCA(Graph &g,int r,vector<tuple<int,int,int>>& qs):g(g),qs(qs),uf(UnionFind(g.size())){\n\t\tpassed=vector<bool>(g.size());ancestor=vector<int>(g.size());\n\t\tuquery=vector<vector<int>>(g.size());\n\t\tfor(int i:range(qs.size())){\n\t\t\tint u,v,res;tie(u,v,res)=qs[i];\n\t\t\tuquery[u].push_back(i);uquery[v].push_back(i);\n\t\t}\n\t\tvisit(-1,r);\n\t};\n\tvoid visit(int p,int s) {\n\t\tancestor[uf.root(s)] = s;\n\t\tfor(int t:g[s]) if(t != p) {\n\t\t\tvisit(s,t);\n\t\t\tuf.unite(s,t);\n\t\t\tancestor[uf.root(s)] = s;\n\t\t}\n\t\tpassed[s] = true;\n\t\tfor(int i : uquery[s]){\n\t\t\tint u,v,res;tie(u,v,res)=qs[i];\t\n\t\t\tint w = (u == s ? v : v == s ? u : -1);\n\t\t\tif (w >= 0 && passed[w])get<2>(qs[i]) = ancestor[uf.root(w)];\n\t\t}\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t);\n\t\t\t\tg[t].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint q;cin >>q;\n\t\tvector<tuple<int,int,int>> qs(q);\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tqs[i]=make_tuple(u,v,-1);\n\t\t}\n\n\t\tTarjanLCA lca(g,0,qs);\n\t\tREP(i,q)cout << get<2>(qs[i])<<endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int , int> i_i;\ntypedef vector<ll> vel;\ntypedef vector<int> vei;\ntypedef vector<char> vec;\ntypedef vector<bool> veb;\ntypedef vector<string> ves;\ntypedef vector<vector<ll>> ve_vel;\ntypedef vector<vector<int>> ve_vei;\ntypedef vector<vector<char>> ve_vec;\ntypedef vector<vector<bool>> ve_veb;\ntypedef vector<vector<string>> ve_ves;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<(int)(n);i++)\n#define rep2(i,n) for(int i=2;i<(int)(n);i++)\n#define repk(i,k,n) for(int i=k;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pub push_back\n#define pob pop_back\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define maxel(a) *max_element(all(a))\n#define minel(a) *min_element(all(a))\n#define acc accumulate\n#define EPS (1e-7)\n//#define INF (1e9)\n#define PI (acos(-1))\n#define mod (1000000007)\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n//LCA(Lowest Common Ancestor):根付き木の2頂点の共通祖先で最も近いもの\n//AOJ(Lowest Common Ancestor)\n\n#define MAX_V 100005\n#define MAX_LOG_V 50\nvei G[MAX_V]; //隣接リスト表現\nint root = 0; //根ノード番号\n\nint parent[MAX_LOG_V][MAX_V]; //親を2^k回辿って到達する頂点\nint depth[MAX_V]; //根からの深さ\n\nvoid dfs(int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i,G[v].size()) {\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\n//初期化\nvoid init(int V) {\n    //parent[0], depthの初期化\n    dfs(root, -1, 0);\n    //parentの初期化\n    for(int k = 0; k + 1 < MAX_LOG_V; k++) {\n        for(int v = 0; v < V; v++) {\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCA\nint lca(int u, int v) {\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u, v);\n    rep(k, MAX_LOG_V) {\n        if( (depth[v] - depth[u]) >> k & 1 ) {\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = MAX_LOG_V - 1; k >= 0; k--) {\n        if(parent[k][u] != parent[k][v]) {\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    \n    rep(i,n) {\n        int k; cin >> k;\n        rep(j,k) {\n            int c; cin >> c;\n            G[i].pub(c);\n        }\n    }\n\n    init(n);\n\n    int q; cin >> q;\n    rep(i,q) {\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> vi;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct hl_decomp {\n\tint N, M;\n\tvector<vi> G;\n\tvi sz, id, par, dep;\n\thl_decomp(int _N, vector<vi> _G)\n\t\t: N(_N), G(_G), sz(N), id(N), par(N), dep(N) {\n\t\tdfs_sz(0, -1);\n\t\tdfs_decomp(0, -1);\n\t\tM = 1; par[0] = -1; dfs_decomp(0, -1);\n\t\tdfs_dep(0, -1);\n\t}\n\tvoid dfs_sz(int u, int p) {\n\t\tsz[u] = 1;\n\t\tfor (int v : G[u]) if (v != p) {\n\t\t\tdfs_sz(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t}\n\tvoid dfs_decomp(int u, int p) {\n\t\tint v0 = -1;\n\t\tfor (int v : G[u]) if (v != p)\n\t\t\tif (v0 == -1 || sz[v] > sz[v0]) v0 = v;\n\t\tfor (int v : G[u]) if (v != p) {\n\t\t\tif (v == v0) {\n\t\t\t\tid[v] = id[u];\n\t\t\t\tpar[v] = par[u];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid[v] = M++;\n\t\t\t\tpar[v] = u;\n\t\t\t}\n\t\t\tdfs_decomp(v, u);\n\t\t}\n\t}\n\tvoid dfs_dep(int u, int p) {\n\t\tfor (int v : G[u]) if (v != p) {\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tdfs_dep(v, u);\n\t\t}\n\t}\n\tint lca(int u, int v) {\n\t\twhile (id[u] != id[v]) {\n\t\t\tint _u = par[u], _v = par[v];\n\t\t\tif (_u != -1 && dep[_u] >= dep[_v]) u = _u;\n\t\t\telse v = _v;\n\t\t}\n\t\treturn dep[u] < dep[v] ? u : v;\n\t}\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int> > G(N);\n\trep(u, N) {\n\t\tint K; scanf(\"%d\", &K);\n\t\twhile (K--) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\tG[u].pb(v);\n\t\t}\n\t}\n\thl_decomp hl(N, G);\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tint w = hl.lca(u, v);\n\t\tprintf(\"%d\\n\", w);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct LowestCommonAncestor{\n  ll n,h;\n  vector< vector<ll> > G,par;\n  vector<ll> dep;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(ll n):n(n),G(n),dep(n){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<ll>(n,-1));\n  }\n\n  void add_edge(ll u,ll v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  void dfs(ll v,ll p,ll d){\n    par[0][v]=p;\n    dep[v]=d;\n    for(ll u:G[v])\n      if(u!=p) dfs(u,v,d+1);\n  }\n\n  void build(ll r=0){\n    dfs(r,-1,0);\n    for(ll k=0;k+1<h;k++)\n      for(ll v=0;v<n;v++)\n        if(~par[k][v])\n          par[k+1][v]=par[k][par[k][v]];\n  }\n\n  ll lca(ll u,ll v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(ll k=0;k<h;k++)\n      if((dep[v]-dep[u])>>k&1)\n        v=par[k][v];\n\n    if(u==v) return u;\n\n    for(ll k=h-1;k>=0;k--)\n      if(par[k][u]!=par[k][v])\n        u=par[k][u],v=par[k][v];\n\n    return par[0][u];\n  }\n\n  ll distance(ll u,ll v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n\nint main() {\n  ll n;\n  cin >> n;\n  LowestCommonAncestor lca(n);\n  for(ll i=0;i<n;i++) {\n    ll k;\n    cin >> k;\n    for(ll j=0;j<k;j++) {\n      ll c;\n      cin >> c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  ll q;\n  cin >> q;\n  for(ll i=0;i<q;i++) {\n    ll f,t;\n    cin >> f >> t;\n    cout << lca.lca(f,t) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n//-------------------------------------------------------------------------\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define prv(v) for (auto i : v) { cout << i << \" \";}\n#define prmat(v) for (auto i : v) { prv(i); cout << \"\\n\";}\n#define cout(x) cout << fixed << setprecision(x)\n#define read(v) for (int i_ = 0; i_ < v.size(); i_++) { cin >> v[i_];}\n#define fast_io ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define all(v) (v.begin()), (v.end())\n#define rall(v) (v.rbegin()), (v.rend())\n#define pii pair<int, int>\n//------------------------------------------------------------------------\nstruct lca{\n    vector<vector<int>> g;\n    vector<pii> t;\n    int n, on;\n    int timer = 0;\n    vector<int> order, vorder, h, tin;\n    void dfs0(int v, int p = -1){\n        for(auto to : g[v]){\n            if(to != p){\n                h[to] = h[v] + 1;\n                dfs0(to, v);\n            }\n        }\n    }\n    void dfs(int v, int p = -1){\n        order.push_back(h[v]);\n        vorder.push_back(v);\n        for(auto to : g[v]){\n            if(to != p){\n                dfs(to, v);\n                order.push_back(h[v]);\n                vorder.push_back(v);\n            }\n        }\n    }\n    \n    void build(int v, int tl, int tr){\n        if(tl == tr){\n            t[v] = {order[tl], tl};\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        build(v * 2, tl, tm);\n        build(v * 2 + 1, tm + 1, tr);\n        t[v] = min(t[v * 2], t[v * 2 + 1]);\n    }\n    \n    pii get(int v, int tl, int tr, int l, int r){\n        if(tl > r || tr < l){\n            return pii{1e9, 1e9};\n        }\n        if(tl >= l && tr <= r){\n            return t[v];\n        }\n        int tm = (tl + tr) / 2;\n        return min(get(v * 2, tl, tm, l, r), get(v * 2 + 1, tm + 1, tr, l, r));\n    }\n    lca(vector<vector<int>> &tt){\n        g = tt;\n        n = (int)tt.size();\n        tin.resize(n, 1e9);\n        h.resize(n);\n        dfs0(0);\n        dfs(0);\n        on = (int)order.size();\n        for(int i = 0; i < vorder.size(); i++){\n            tin[vorder[i]] = min(tin[vorder[i]], i);\n        }\n        t.resize(on * 4);\n        build(1, 0, on - 1);\n    }\n    int get(int i, int j){\n        \n        int x = tin[i];\n        int y = tin[j];\n        if(x > y){\n            swap(x, y);\n        }\n        pii a = get(1, 0, on - 1, x, y);\n        return vorder[a.second];\n    }\n};\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n; i++){\n        int m;\n        cin >> m;\n        for(int j = 0; j < m; j++){\n            int x;\n            cin >> x;\n            g[i].push_back(x);\n            g[x].push_back(i);\n        }\n    }\n    lca x(g);\n    int q;\n    cin >> q;\n    while(q--){\n        int a, b;\n        cin >> a >> b;\n        cout << x.get(a, b) << \"\\n\";\n    }\n}\nint main() {\n    fast_io;\n#ifdef LOCALKA\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n#endif\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rrep(i,x) for(int i=(int)x-1;i>=0;--i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvi G[100010];\n\nint depth[100010];\nint par[100010][22];\n\nvoid lca_dfs(int v, int p, int d)\n{\n    depth[v] = d;\n    par[v][0] = p;\n\n    for (int ch : G[v]) {\n        if (ch == p) continue;\n        lca_dfs(ch, v, d + 1);\n    }\n}\n\nvoid lca_init(int root = 0)\n{\n    lca_dfs(root, -1, 0);\n\n    rep(i, 20) {\n        rep(j, 100010) {\n            par[j][i + 1] = par[j][i] == -1 ? -1 : par[par[j][i]][i];\n        }\n    }\n}\n\nint lca(int u, int v)\n{\n    if (depth[u] > depth[v]) swap(u, v);\n\n    int diff = depth[v] - depth[u];\n\n    rep(i, 20) {\n        if (diff >> i & 1) v = par[v][i];\n    }\n\n    if (u == v) return u;\n\n    rrep(i, 20) {\n        if (par[u][i] != par[v][i]) {\n            u = par[u][i];\n            v = par[v][i];\n        }\n    }\n\n    return par[u][0];\n}\n\nint main()\n{\n    int n = in();\n\n    rep(i, n) {\n        int k = in();\n\n        rep(j, k) {\n            int c = in();\n\n            G[i].PB(c);\n            G[c].PB(i);\n        }\n    }\n\n    lca_init();\n\n    int q = in();\n\n    rep(_, q) {\n        int u = in(), v = in();\n\n        printf(\"%d\\n\", lca(u, v));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.resize(2 * size - 1);\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = pii(INF, -1);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = pii(depth[i], et[i]);\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn pii(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  ????????±????\\????????±???????\n */\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_V 100000\n#define MAX_LOG_V 100\n\nvector<int> G[MAX_V];\nint root;\nint deg[MAX_V];\n\nint parent[MAX_LOG_V][MAX_V];  \nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d)\n{\n    parent[0][v] = p;\n    depth[v] = d;\n    for (int i = 0; i < (int)G[v].size(); i++) { \n\tif(G[v][i] != p) {\n\t    dfs(G[v][i], v, d+1);\n\t}\n    }\n}\n\nint getRoot(int V)\n{\n    for (int i = 0; i < V; i++) {\n\tif (deg[i] == 0) {\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\nvoid init(int V)\n{\n    root = getRoot(V);\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n\tfor (int v = 0; v < V; v++) {\n\t    if (parent[k][v] < 0) {\n\t\tparent[k+1][v] = -1;\n\t    } else {\n\t\tparent[k+1][v] = parent[k][parent[k][v]];\n\t    }\n\t}\n    }\n}\n\nint lca(int u, int v)\n{\n    if(depth[u] > depth[v]){\n\tswap(u, v);\n    }\n    for (int k = 0; k < MAX_LOG_V; k++) {\n\tif ((depth[v] - depth[u]) >> k & 1) {\n\t    v = parent[k][v];\n\t}\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int k = MAX_LOG_V-1; k >= 0; k--) {\n\tif (parent[k][u] != parent[k][v]) {\n\t    u = parent[k][u];\n\t    v = parent[k][v];\n\t}\n    }\n    return parent[0][u];\n}\n\nint main()\n{\n    int N, K, x;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n\tcin >> K;\n\tfor (int j = 0; j < K; j++) {\n\t    cin >> x;\n\t    G[i].push_back(x);\n\t}\n    }\n    init(N);\n    int Q, a, b;\n    cin >> Q;\n    for (int i = 0; i < Q; i++) {\n\tcin >> a >> b;\n\tcout << lca(a, b) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Monoid = int, typename OperatorMonoid = Monoid >\nstruct LinkCutTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  struct Node {\n    Node *l, *r, *p;\n    int idx;\n    Monoid key, sum;\n    bool rev;\n    int sz;\n\n    bool is_root() {\n      return !p || (p->l != this && p->r != this);\n    }\n\n    Node(int idx, const Monoid &key) :\n        idx(idx), key(key), sum(key), sz(1),\n        l(nullptr), r(nullptr), p(nullptr), rev(false) {}\n  };\n\n  const Monoid M1;\n  const OperatorMonoid OM0;\n  const F f;\n  const G g;\n  const H h;\n\n  LinkCutTree() : LinkCutTree(F(), Monoid()) {}\n\n  LinkCutTree(const F &f, const Monoid &M1) :\n      LinkCutTree(f, G(), H(), M1, OperatorMonoid()) {}\n\n  LinkCutTree(const F &f, const G &g, const H &h,\n              const Monoid &M1, const OperatorMonoid &OM0) :\n      f(f), g(g), h(h), M1(M1), OM0(OM0) {}\n\n  Node *make_node(int idx, const Monoid &v = Monoid()) {\n    return new Node(idx, v);\n  }\n\n  void push(Node *t) {\n    if(t->rev) {\n      swap(t->l, t->r);\n      if(t->l) t->l->rev ^= true;\n      if(t->r) t->r->rev ^= true;\n    }\n  }\n\n  void update(Node *t) {\n    t->sz = 1;\n    t->sum = t->key;\n    if(t->l) t->sz += t->l->sz, t->sum = t->l->sum + t->sum;\n    if(t->r) t->sz += t->r->sz, t->sum = t->sum + t->r->sum;\n  }\n\n  void rotr(Node *t) { // 右回転\n    auto *x = t->p, *y = x->p;\n    if((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void rotl(Node *t) { // 左回転\n    auto *x = t->p, *y = x->p;\n    if((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t) {\n    push(t);\n    while(!t->is_root()) {\n      auto *q = t->p;\n      if(q->is_root()) {\n        push(q), push(t);\n        if(q->l == t) rotr(t);\n        else rotl(t);\n      } else {\n        auto *r = q->p;\n        push(r), push(q), push(t);\n        if(r->l == q) {\n          if(q->l == t) rotr(q), rotr(t);\n          else rotl(t), rotr(t);\n        } else {\n          if(q->r == t) rotl(q), rotl(t);\n          else rotr(t), rotl(t);\n        }\n      }\n    }\n  }\n\n  Node *expose(Node *t) {\n    Node *rp = nullptr;\n    for(Node *cur = t; cur; cur = cur->p) {\n      splay(cur);\n      cur->r = rp;\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert(Node *t) {\n    expose(t);\n    t->rev ^= true;\n    push(t);\n  }\n\n  Node *lca(Node *u, Node *v) {\n    expose(u);\n    return expose(v);\n  }\n};\n\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  LinkCutTree<> lctree;\n  vector< LinkCutTree<>::Node * > uku(N);\n  for(int i = 0; i < N; i++) {\n    uku[i] = lctree.make_node(i);\n  }\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      lctree.link(uku[T], uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    printf(\"%d\\n\", lctree.lca(uku[V], uku[U])->idx);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n\nusing namespace std;\n\nconst int sz = 1e5 + 13;\nconst int logsz = 10;\n\nint n;\n\nint p[sz][logsz];\nint t[sz], level[sz];\n\nvector<vector<int> > g (sz);\n\nvoid dfs(int u, int parent){\n    for(auto v: g[u]){\n        if(v != parent){\n            level[v] = level[u] + 1;\n            t[v] = u;\n            dfs(v, u);\n        }\n    }\n}\n\nvoid preprocess(){\n    dfs(0, -1);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; (1<<j) < n; ++j)\n            p[i][j] = -1;\n    for(int i = 0; i < n; ++i)\n        p[i][0] = t[i];\n    for(int j = 1; (1<<j) < n; ++j)\n        for(int i = 0; i < n; ++i) if(p[i][j-1] != -1)\n            p[i][j] = p[p[i][j-1]][j-1];\n}\n\nint lca(int u, int v){\n    if(level[u] < level[v]){u ^= v; v ^= u; u ^= v;}\n    int log;\n    for(log = 1; (1<<log) < level[u]; ++log);\n    log--;\n    for(int i = log; i >= 0; --i)\n        if(level[u]  - (1<< i) >= level[v])\n            u = p[u][i];\n    if(u == v)\n        return u;\n    for(int i = log; i>= 0; --i)\n        if(p[u][i] != -1 && p[u][i] != p[v][i]){\n            u = p[u][i]; v = p[v][i];\n        }\n    return t[u];\n}\n\n\nint main(){\n    cin>>n;\n    for(int i = 0; i < n; ++i){\n        int k;\n        cin>>k;\n        for(int j = 0; j < k; ++j){\n            int x;\n            cin>>x;\n            g[i].push_back(x);\n            g[x].push_back(i);\n        }\n    }\n    preprocess();\n    int q;\n    cin>>q;\n    for(int i = 0; i < q; ++i){\n        int u,v;\n        cin>>u>>v;\n        cout<<lca(u,v)<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return node_[vl] < node_[vr] ? left_child(k) : right_child(k);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n\n// 根付き木\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int size() const {return node_.size();}\n    int lowest_common_ancestor(int u, int v) const {\n        RangeMinimumQuery rmq(size());\n        for(int i = 0; i < size(); ++i) rmq.update(i, depth(i));\n        return rmq.find_index(std::min(u, v), std::max(u, v)) - 1;\n    }\nprivate:\n//     static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n \nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n \n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(max(logN, 1), vector<int>(N));\n  }\n \n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n \n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n \n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n \nint main() {\n  ios::tie(nullptr);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n\nclass RMQ{//RangeMinimumQuery\n\tint n;\n\tstd::vector<int> dat,idx;\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return dat.size()-1;\n\t\tif(a<=l&&r<=b)return idx[k];\n\t\telse{\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn dat[vl]<dat[vr]?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQ(){}\n\t~RMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tn=calcsize(a.size());\n\t\tidx.resize(2*n-1);\n\t\tfor(int i=0;i<(int)a.size();i++)idx[n-1+i]=i;\n\t\tfor(int i=a.size();i<n;i++)idx[n-1+i]=a.size();\n\t\tdat=a;\n\t\tdat.push_back(INT_MAX);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tidx[i]=dat[idx[i*2+1]]<dat[idx[i*2+2]]?idx[i*2+1]:idx[i*2+2];\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\tRMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size) {for(int i=0;i<size;i++)data[i]=i;}\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      //data[x] += data[y];\n\t  data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x]==x ? x : (data[x] = root(data[x]));\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    //cout << \"Path Count = \" << pathCount << \"\\n\";\n    len=vector<vector<int> >(pathCount);\n    /*\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\nstruct LCA{//lowest common ancestor\n\tint MAX_LOG_V = 50;\n\tvector<vector<int> > g;\n\tvector<vector<int> > parent;\n\tint root = 0,V;\n\tvector<int> depth;\n\tLCA(){}\n\tLCA(int V):V(V){init();}\n\tvoid init(){\n\t\tfor(int i=0;i<g.size();i++)g[i].clear();\n\t\tg.clear();\n\t\tfor(int i=0;i<parent.size();i++)parent[i].clear();\n\t\tparent.clear();\n\t\tdepth.clear();\n\t\tg.resize(V);\n\t\tparent.resize(MAX_LOG_V,vector<int>(V) );\n\t\tdepth.resize(V);\n\t}\n\tvoid dfs(int v,int p,int d){\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor(int i=0;i<g[v].size();i++)if(g[v][i] != p) dfs(g[v][i],v,d+1);\n\t}\n\tvoid construct(){\n\t\tdfs(root,-1,0);\n\t\tfor(int k=0;k+1<MAX_LOG_V;k++)\n\t\t    for(int i=0;i<V;i++)\n\t\t\tif(parent[k][i]<0) parent[k+1][i] = -1;\n\t\t\telse parent[k+1][i] = parent[k][parent[k][i]];\n\t}\n\tint lca(int u,int v){\n\t\tif(depth[u] > depth[v]) swap(u,v);\n\t\tfor(int k=0;k<MAX_LOG_V;k++)\n\t\t    if( (depth[v]-depth[u]) >> k&1)\n\t\t\tv = parent[k][v];\n\t\tif(u==v) return u;\n\t\tfor(int k=MAX_LOG_V-1;k>=0;k--)\n\t\t    if(parent[k][u] != parent[k][v]){\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t    }\n\t\treturn parent[0][u];\n\t}\n\tvoid add_edge(int u,int v){ \n\t    g[u].push_back(v);\n\t    g[v].push_back(u);\n\t}\n};\n\nint main(){\n\tint n;\n\tcin>>n;\n\tLCA t(n);\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tt.add_edge(i,c);\n\t\t}\n\t}\n\tt.construct();\n\tint q;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tcout<<t.lca(u,v)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100005;\nconst int MAX_N = 100005;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n + n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int d, int &k){\n            assert(v < MAX_V);\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(id[G[v][i]] == 0){\n                    dfs(G[v][i], d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, 0, k);\n            rmqInit(depth,V * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<vector>\n#include<cmath>\n#include<utility>\n\ntemplate<typename Label>\nclass RootedTree {\npublic:\n  void join(const Label& u, const Label& v) {\n    edge_[u].push_back(v);\n    edge_[v].push_back(u);\n  }\n  void initialize(const Label& root) {initialize(root, root, 0);}\n  int depth(const Label& v) const {return depth_.at(v);}\n  // v の d 番目の祖先を求める O(log(d))\n  Label ancestor(Label v, int d = 1) const {\n    for(int i = 1; i <= d; i <<= 1) if(d & i) v = ancestor_.at(v).at(i);\n    return v;\n  }\n  Label lca(Label u, Label v) const {\n    // u, v の深さを一致させる O(log(深さの差))\n    if(depth(v) < depth(u)) std::swap(u, v);\n    v = ancestor(v, depth(v) - depth(u));\n    // lca を求める O(log(深さ))\n    if(u == v) return u;\n    int bits = log2(depth(u));\n    for(int i = 1 << bits; 0 < i; i >>= 1) {\n      if(ancestor(u, i) == ancestor(u, i)) continue;\n      u = ancestor(u, i);\n      v = ancestor(v, i);\n    }\n    return ancestor(u, 1);\n  }\nprivate:\n  void initialize(const Label& current, const Label& previous, int depth) {\n    depth_[current] = depth;\n    for(int i = 2; i <= depth; i <<= 1) {ancestor_[current][i] = ancestor_[ancestor_[current][i >> 1]][i >> 1];}\n    for(const auto& v: edge_[current]) {\n      if(v == previous) continue;\n      ancestor_[v][1] = current;\n      initialize(v, current, depth + 1);\n    }\n  }\n  std::unordered_map<Label, int> depth_;\n  std::unordered_map<Label, std::vector<Label>> edge_;\n  std::unordered_map<Label, std::unordered_map<int, Label>> ancestor_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  RootedTree<int> t;\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      t.join(i, c);\n    }\n  }\n  t.initialize(0);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << t.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\n\nconst int MAXN = 100005;\nconst int LOGN = 20;\n\nint H[MAXN];        // index of node i in dfs path\nii path[MAXN << 1];\nvi adjList[MAXN];\n\nii ST[LOGN][MAXN<<1];\n\nvoid build(int n) {\n    int h = ceil(log2(n+1));\n\n    for (int i = 0; i < n; i++) ST[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n        ST[i][j] = min(ST[i-1][j], ST[i-1][j+(1<<(i-1))]);\n}\n\nint RMQ(int l, int r) {     // range [l,r)\n    int p = 31 - __builtin_clz(r-l);\n    return min(ST[p][l],ST[p][r-(1<<p)]).se;\n}\n\nint cnt = 0;\nvoid dfs(int node, int depth){\n    H[node] = cnt;\n\n    path[cnt++] = ii(depth,node);\n    for (int i = 0; i < adjList[node].size(); i++) {\n        dfs(adjList[node][i],depth+1);\n\n        path[cnt++] = ii(depth,node);\n    }\n}\n\nint N, M, Q, v;\n\nint main(){\n\n    scanf(\"%d\",&N);\n    for (int u = 0; u < N; u++){\n        scanf(\"%d\",&M);\n        for (int i = 0; i < M; i++){\n            scanf(\"%d\",&v);\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted at 0\n    dfs(0,0);\n    build(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v, l, r; i < Q; i++){\n        scanf(\"%d%d\",&u,&v);\n\n        l = H[u], r = H[v]; if (l > r) swap(l,r);\n\n        printf(\"%d\\n\",RMQ(l,r+1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<utility>\n\nconst int NIL = -1;\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :depth_(n, 0), child_(n) {\n        log_size_ = 1;\n        while(log_size_ << 1 < n) log_size_ <<= 1;\n        parent_.resize(log_size_ + 1, std::vector<int>(n, NIL));\n    }\n    void add(const int v, const int c) {\n        parent_[0][c] = v;\n        depth_[c] = depth_[v] + 1;\n        child_[v].push_back(c);\n    }\n    void init() {\n        for(int d = 1; d < size(); ++d) for(int u = 0; u < size(); ++u)\n            if(parent_[d - 1][parent_[d - 1][u]] != NIL) parent_[d][u] = parent_[d - 1][parent_[d - 1][u]];\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        // u, vを同じ深さにする\n        if(depth_[v] < depth_[u]) std::swap(u, v);\n        for(int i = log_size_; i >= 0; --i) {\n            if(parent_[i][v] == NIL) continue;\n            if(depth_[parent_[i][v]] < depth_[u]) continue;\n            v = parent_[i][v];\n        }\n        if(u == v) return u;\n        // 共通の祖先を求める\n        for(int i = log_size_; i >= 0; --i) {\n            if(parent_[i][u] == NIL) continue;\n            if(parent_[i][u] == parent_[i][v]) continue;\n            u = parent_[i][u];\n            v = parent_[i][v];\n        }\n        return parent_[0][u];\n    }\nprivate:\n    int size() const {return depth_.size();}\n    int log_size_;\n    std::vector<std::vector<int>> parent_;\n    std::vector<std::vector<int>> child_;\n    std::vector<int> depth_;\n};\n\n/*/\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n#include<utility>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n//*/\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\nconst int MOD = 1e9 + 7;\n\nstruct LCA{\n    vector<vector<int>> parent;\n    vector<int> depth;\n    int n;\n    int max_k;\n    vector<vector<int>> graph;\n\n    LCA(vector<vector<int>>& _graph, int v=0): graph(_graph), n(_graph.size()), max_k(int(log2(n)) + 1) {\n        parent.assign(max_k+1, vector<int>(n, -1));\n        depth.assign(n, 0);\n        dfs(v);\n        doubling();\n    }\n\n    void dfs(int v, int p=-1) {\n        for (int nv: graph[v]) {\n            if (nv == p) continue;\n            depth[nv] = depth[v] + 1;\n            parent[0][nv] = v;\n            dfs(nv, v);\n        }\n    }\n\n    void doubling() {\n        for (int k = 0; k < max_k; ++k) {\n            for (int i = 0; i < n; ++i) {\n                if (parent[k][i] == -1) {\n                    parent[k+1][i] = -1;\n                } else {\n                    parent[k+1][i] = parent[k][parent[k][i]];\n                }\n            }\n        }\n    }\n\n    int get_lca(int u, int v) {\n        if (depth[u] < depth[v]) swap(u, v);\n        for (int k = max_k; k >= 0; --k) {\n            if (((depth[u] - depth[v]) >> k) & 1) {\n                u = parent[k][u];\n            }\n        }\n        if (u == v) return u;\n        for (int k = max_k; k >= 0; --k) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n    int get_path_length(int u, int v) {\n        int lca = get_lca(u, v);\n        return (depth[u] - depth[lca]) + (depth[v] - depth[lca]);\n    }\n};\n\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> graph(n);\n    rep(i, n) {\n        int k; cin >> k;\n        rep(j, k) {\n            int v; cin >> v;\n            graph[i].push_back(v);\n        }\n    }\n\n    LCA lca(graph);\n\n    int q; cin >> q;\n    rep(i, q) {\n        int u, v; cin >> u >> v;\n        cout << lca.get_lca(u, v) << endl;\n    }\n    \n\n    return 0;\n}\n\n\n    \n\n"
  },
  {
    "language": "C++",
    "code": "/* lca_doubling.cpp\n    最近共通祖先(LCA:Lowest Common Ancestor)をダブリングにより求める\n    (u,v の2^k先の親が同じかどうかを二分探索で調べる)\n\n    verified: AOJ GRL_5_C\n        http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    long long to;\n};\nusing Graph = vector<vector<Edge>>;\n\n/* LCA(G, root): 木 G に対する根を root として Lowest Common Ancestor を求める構造体\n    query(u,v): u と v の LCA を求める。計算量 O(logn)\n    dist(u,v): u と v の距離を求める。計算量 O(logn)\n    is_on_path(u,v,a): u, v を繋ぐパス上に a が存在するかを判定する。計算量 O(logn)\n    前処理: O(nlogn)時間, O(nlogn)空間\n*/\nstruct LCA {\n    vector<vector<int>> parent;  // parent[k][u]:= u の 2^k 先の親\n    vector<int> depth;           // root からの深さ\n    LCA(const Graph &G, int root = 0) { init(G, root); }\n    void init(const Graph &G, int root = 0) {\n        int V = G.size();\n        int K = 1;\n        while ((1 << K) < V) K++;\n        parent.assign(K, vector<int>(V, -1));\n        depth.assign(V, -1);\n        dfs(G, root, -1, 0);  // initialization of parent[0] & depth\n        // initialization of parent\n        for (int k = 0; k + 1 < K; k++) {\n            for (int v = 0; v < V; v++) {\n                if (parent[k][v] < 0) {\n                    parent[k + 1][v] = -1;\n                } else {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n    void dfs(const Graph &G, int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (auto e : G[v]) {\n            if (e.to != p) dfs(G, e.to, v, d + 1);\n        }\n    }\n    int query(int u, int v) {\n        if (depth[u] < depth[v]) swap(u, v);\n        int K = parent.size();\n        for (int k = 0; k < K; k++) {\n            if ((depth[u] - depth[v]) >> k & 1) {\n                u = parent[k][u];\n            }\n        }\n        if (u == v) return u;\n        for (int k = K - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    int dist(int u, int v) { return depth[u] + depth[v] - 2 * depth[query(u, v)]; }\n    bool is_on_path(int u, int v, int a) { return dist(u, a) + dist(a, v) == dist(u, v); }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    Graph G(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            G[i].push_back({c});\n            G[c].push_back({i});\n        }\n    }\n    int q;\n    cin >> q;\n    vector<int> u(q), v(q);\n    for (int i = 0; i < q; i++) {\n        cin >> u.at(i) >> v.at(i);\n    }\n\n    LCA lca(G, 0);\n\n    for (int i = 0; i < q; i++) {\n        cout << lca.query(u[i], v[i]) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 200;\nint color[100010],  par[100010], depth[100010];\nint colorTop[100010/B];\nint goUp[100010/B];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = 0, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    assert(q.size() == 0);\n    rep(i,n) vis[i] = 0;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        colorTop[c] = u;\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\n#define all(x) x.begin(), x.end()\n#define rep(i,a,b) for(int i = a; i < b; i++)\n\nint N;\nvvi children(100002);\nvvi jumps(100002, vi(18, -1));\n\nvi trail(0);\nvoid gen_jumps(int n, int l) {\n  trail.push_back(n);\n  rep(i,0,18) {\n    int dest = (l&(l^(1<<i)))|((1<<i)-1);\n    if(dest <= l)\n      jumps[n][i] = trail[dest];\n  }\n  rep(i,0,(int)children[n].size())\n    gen_jumps(children[n][i], l+1);\n  trail.pop_back();\n}\n\nint lca(int u, int v) {\n  int lowest = 0;\n  for(int i = 17; i >= 0; i--) {\n    if(jumps[u][i] == -1 && jumps[v][i] == -1) continue;\n    else if(jumps[u][i] == -1) v = jumps[v][i];\n    else if(jumps[v][i] == -1) u = jumps[u][i];\n    else if(jumps[u][i] == jumps[v][i]) {\n      if(jumps[u][i] == u || jumps[v][i] == v) return jumps[u][i];\n      lowest = jumps[u][i];\n    }\n    else {\n      u = jumps[u][i];\n      v = jumps[v][i];\n    }\n  }\n  return lowest;\n}\n\nint main() {\n  cin >> N;\n  rep(n,0,N) {\n    int K, c;\n    cin >> K;\n    rep(k,0,K) {\n      cin >> c;\n      children[n].push_back(c);\n    }\n  }\n\n  gen_jumps(0, 0);\n  \n  int Q;\n  cin >> Q;\n  rep(q,0,Q) {\n    int u, v;\n    cin >> u;\n    cin >> v;\n    cout << lca(u, v) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Monoid >\nstruct DisjointSparseTable {\n  using F = function< Monoid(Monoid, Monoid) >;\n  const F &f;\n  vector< vector< Monoid > > st;\n\n  DisjointSparseTable(const vector< Monoid > &v, const F &f) : f(f) {\n\n    int b = 0;\n    while((1 << b) <= v.size()) ++b;\n    st.resize(b, vector< Monoid >(v.size(), Monoid()));\n    for(int i = 0; i < v.size(); i++) st[0][i] = v[i];\n    for(int i = 1; i < b; i++) {\n      int shift = 1 << i;\n      for(int j = 0; j < v.size(); j += shift << 1) {\n        int t = min(j + shift, (int) v.size());\n        st[i][t - 1] = v[t - 1];\n        for(int k = t - 2; k >= j; k--) st[i][k] = f(v[k], st[i][k + 1]);\n        if(v.size() <= t) break;\n        st[i][t] = v[t];\n        int r = min(t + shift, (int) v.size());\n        for(int k = t + 1; k < r; k++) st[i][k] = f(st[i][k - 1], v[k]);\n      }\n    }\n  }\n\n  Monoid query(int l, int r) {\n    if(l >= --r) return st[0][l];\n    int p = 31 - __builtin_clz(l ^ r);\n    return f(st[p][l], st[p][r]);\n  }\n};\n\nusing Pi = pair< int, int >;\n\nvector< int > g[100000];\nvector< Pi > depth;\nint rev[100000];\n\nvoid dfs(int idx, int dep) {\n  rev[idx] = (int) depth.size();\n  depth.emplace_back(dep, idx);\n  for(auto &to : g[idx]) {\n    dfs(to, dep + 1);\n    depth.emplace_back(dep, idx);\n  }\n}\n\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      g[i].push_back(c);\n    }\n  }\n  dfs(0, -1);\n  auto f = [](const Pi &a, const Pi &b) { return min(a, b); };\n  DisjointSparseTable< Pi > beet(depth, f);\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    auto p = minmax(rev[a], rev[b]);\n    printf(\"%d\\n\", beet.query(p.first, p.second).second);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Lowest Common Ancestor\n//最小共通先祖\n//二部探索を用いる方法\n/*\nint main(){\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    a = max(a, b);\n    a = max(max(a, b), max(c, d));\n\n}*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 100010\n#define MAX_LOG_V 100\nvector<int> G[MAX_V];                   //グラフの隣接リスト\nint root;                               //根の頂点番号\nint parent[MAX_LOG_V][MAX_V];           //parent[i][j] := 頂点jから2^i親をたどって到達する頂点\nint depth[MAX_V];                       //根からの深さ\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    //parent[0]とdepthを初期化する\n    dfs(root, -1, 0);\n    //parentを初期化する\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親をたどる\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u] >> k) & 1){    //これあテクい\n            v = parent[k][v];\n        }\n    }\n\n    if(u == v) return u;\n\n\n    //二部探索でLCAを求める\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n\n    return parent[0][u];      //uの親を返す\n}\n\nint main(){\n\n    //0-indexed\n    int V; cin >> V;\n    root = 0;\n    for(int i = 0; i < V; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    init(V);\n    int q; cin >> q;\n\n    for(int i = 0; i < q; i++){\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    logN = max(1, logN);\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  for(int i = 2; i <= 20; i++) {\n    LCA lca(i);\n    cout << i << \": \" << lca.logN << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\nconst int logn=20;\n\nint n,q,l;\nint dep[maxn];\nint up[maxn][logn];\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n    dep[u]=dep[p]+1;\n    up[u][0]=p;\n    for (int i=1;i<=l;i++) up[u][i]=up[up[u][i-1]][i-1];\n    for (int v:G[u])\n        if (v!=p) dfs(v,u);\n}\n\nint lca(int u,int v) {\n    if (u==v) return u;\n    if (dep[u]<dep[v]) swap(u,v);\n    for (int i=l;i>=0;i--) {\n        if (dep[up[u][i]]>=dep[v]) u=up[u][i];\n        if (dep[u]==dep[v]) break;\n    }\n    for (int i=l;i>=0;i--)\n        if (up[u][i]!=up[v][i]) {\n            u=up[u][i];\n            v=up[v][i];\n        }\n    if (u==v) return u;\n    return up[u][0];\n}\n\nint main() {\n    cin>>n;\n    for (int i=0;i<n;i++) {\n        int m; cin>>m;\n        for (int j=0;j<m;j++) {\n            int v; cin>>v;\n            G[i].pb(v);\n        }\n    }\n    while ((1<<l)<=n) ++l;\n    dfs(0,0);\n    cin>>q;\n    for (int i=0;i<q;i++) {\n        int u,v; cin>>u>>v;\n        cout<<lca(u,v)<<'\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nconst int N = 100010;\n\nvector<int> graph[N];\nint dep[N], p[20][N];\n\nvoid go(int now) {\n\tfor (int i = 0; i < graph[now].size(); i++) {\n\t\tdep[graph[now][i]] = dep[now] + 1;\n\t\tp[0][graph[now][i]] = now;\n\t\tgo(graph[now][i]);\n\t}\n\treturn ;\n}\n\nint LCA(int l, int r) {\n\tif (dep[l] < dep[r]) swap(l, r);\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (dep[p[i][l]] >= dep[r]) {\n\t\t\tl = p[i][l];\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (p[i][l] != p[i][r]) {\n\t\t\tl = p[i][l];\n\t\t\tr = p[i][r];\n\t\t}\n\t}\n\tif (l != r) return p[0][l];\n\telse return l;\n}\n\nint main() {\n\tint n, k, temp, q, l, r;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tscanf(\"%d\", &temp);\n\t\t\tgraph[i].push_back(temp);\n\t\t}\n\t}\n\tgo(0);\n\tfor (int i = 1; i < 20; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tp[i][j] = p[i - 1][p[i - 1][j]];\n\t\t}\n\t}\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tprintf(\"%d\\n\", LCA(l, r));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ntemplate <typename T>\nstruct edge\n{\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\ntemplate <typename G>\nstruct DoublingLowestCommonAncestor\n{\n    const int LOG;\n    vector<int> dep;\n    const G &g;\n    vector<vector<int>> table;\n\n    DoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size()))\n    {\n        table.assign(LOG, vector<int>(g.size(), -1));\n    }\n\n    void dfs(int idx, int par, int d)\n    {\n        table[0][idx] = par;\n        dep[idx] = d;\n        for (auto &to : g[idx])\n        {\n            if (to != par)\n                dfs(to, idx, d + 1);\n        }\n    }\n\n    void build()\n    {\n        dfs(0, -1, 0);\n        for (int k = 0; k + 1 < LOG; k++)\n        {\n            for (int i = 0; i < table[k].size(); i++)\n            {\n                if (table[k][i] == -1)\n                    table[k + 1][i] = -1;\n                else\n                    table[k + 1][i] = table[k][table[k][i]];\n            }\n        }\n    }\n\n    int query(int u, int v)\n    {\n        if (dep[u] > dep[v])\n            swap(u, v);\n        for (int i = LOG - 1; i >= 0; i--)\n        {\n            if (((dep[v] - dep[u]) >> i) & 1)\n                v = table[i][v];\n        }\n        if (u == v)\n            return u;\n        for (int i = LOG - 1; i >= 0; i--)\n        {\n            if (table[i][u] != table[i][v])\n            {\n                u = table[i][u];\n                v = table[i][v];\n            }\n        }\n        return table[0][u];\n    }\n};\n\nint main()\n{\n    int N, Q;\n    scanf(\"%d\", &N);\n    UnWeightedGraph g(N);\n    for (int i = 0; i < N; i++)\n    {\n        int k;\n        scanf(\"%d\", &k);\n        while (k--)\n        {\n            int c;\n            scanf(\"%d\", &c);\n            g[i].push_back(c);\n        }\n    }\n    DoublingLowestCommonAncestor<UnWeightedGraph> lca(g);\n    lca.build();\n    scanf(\"%d\", &Q);\n    while (Q--)\n    {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        printf(\"%d\\n\", lca.query(x, y));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\nstruct rmqsegtree{\n  vector< pair<int, int> > t; //<data, at>\n  pair<int, int> re;\n  int n;\n  void dflt(void){ re.first = INT_MAX; re.second = -1; return; }\n  void use(void){\n    int i; dflt();\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0].first = 1 << (i - 1); t[0].second = 1 << i;\n    for(i = 1;i < t[0].second;++i)t[i] = re;\n    for(i = 0;i < n;++i)t[i + t[0].first].second = i;\n    return;\n  }\n  void build(vector<int> a){  //???????¨?\n    for(n = 1;;n <<= 1)if(n >= a.size())break;\n    t.resize(n << 1); dflt();\n    t[0].first = n; t[0].second = t[0].first << 1; n = a.size();\n    for(int i = 1;i < t[0].second;++i)t[i] = re;\n    for(int i = 0;i < n;++i){\n      t[t[0].first + i].first = a[i]; t[t[0].first + i].second = i;\n    }\n    for(int i = t[0].first - 1;i >= 1;--i)\n      t[i] = (t[i << 1] <= t[(i << 1) + 1]) ? t[i << 1] : t[(i << 1) + 1];\n    return;\n  }\n  void update(int at, int data){\n    t[t[0].first + at].first = data;\n    for(int x = t[0].first + at;x > 1;){\n      x >>= 1;\n      if(t[x << 1].first < t[(x << 1) + 1].first)t[x] = t[x << 1];\n      else t[x] = t[(x << 1) + 1];\n    }\n    return;\n  }\n  pair<int, int> query(int l, int r, int k, int kl, int kr){\n    //printf(\"%d %d %d %d %d\\n\", l, r, k, kl, kr);\n    if(l <= t[k].second && t[k].second < r)return t[k];\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    pair<int, int> a = query(l, r, k << 1, kl, (kl + kr) >> 1);\n    pair<int, int> b = query(l, r, (k << 1) + 1, (kl + kr) >> 1, kr);\n    return (a.first < b.first) ? a : b;\n  }\n  pair<int, int> find(int l, int r){ return query(l, r, 1, 0, t[0].first); }\n  void deb(void){\n    int x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%11d\", t[i].first);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    return;\n  }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nstruct tree{\n  vector< vector<edge> > t;\n  int v;\n  void nexttree(int x){ //x-indexed\n    scanf(\"%d\", &v);  t.resize(v);\n    int from, to, cost = 1;\n    for(int i = 1;i < v;++i){\n      scanf(\"%d %d\", &from, &to);\n      t[from - x].push_back((edge){to - x, cost});\n      t[to - x].push_back((edge){from - x, cost});\n    }\n    return;\n  }\n  void nexttree2(int x){\n    scanf(\"%d\", &v); t.resize(v);\n    int k, to, cost = 1;\n    for(int i = 0;i < v;++i){\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;++j){\n        scanf(\"%d\", &to);\n        t[i - x].push_back((edge){to - x, cost});\n        t[to - x].push_back((edge){i - x, cost});\n      }\n    }\n    return;\n  }\n  rmqsegtree S;\n  vector<int> vst, dpth, id;\n  void lcarmqdfs(int now, int dep){\n    id[now] = vst.size();\n    vst.push_back(now); dpth.push_back(dep);\n    for(int i = 0;i < t[now].size();++i)if(id[t[now][i].to] == -1){\n      lcarmqdfs(t[now][i].to, dep + 1);\n      vst.push_back(now); dpth.push_back(dep);\n    }\n    return;\n  }\n  void lcarmq(void){\n    if(vst.size() > v)return;\n    id.resize(v); for(int i = 0;i < v;++i)id[i] = -1;\n    lcarmqdfs(0, 0);\n    S.build(vst);\n    return;\n  }\n  int lca(int a, int b){ return vst[S.find(id[a], id[b] + 1).second]; }\n};\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    tree T; T.nexttree2(0);\n    T.lcarmq();\n\n    int(q);\n    for(;q--;){\n      int2(a, b);\n      int x = T.lca(a, b);\n      pri(x);\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef BUILT_LOCAL\n\n#include \"niklib.h\"\n\n#endif\n\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <map>\n#include <cmath>\n#include <set>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef __int128 lll;\nconstexpr ll mod = 1000000007;\n\n#define bs(n) (1u<<(unsigned)(n))\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> p(n);\n    vector<set<int>> s(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            p[c] = i;\n            s[i].insert(c);\n        }\n    }\n    vector<int> d(n, 0);\n    queue<int> q;\n    q.push(0);\n    while (!q.empty()) {\n        int t = q.front();\n        q.pop();\n        for (auto &e:s[t]) {\n            d[e] = d[t] + 1;\n            q.push(e);\n        }\n    }\n    vector<array<int, 20>> h(n);\n    for (int i = 0; i < n; i++) {\n        h[i][0] = p[i];\n    }\n    for (int i = 1; i < 20; i++) {\n        for (int j = 0; j < n; j++) {\n            h[j][i] = h[h[j][i - 1]][i - 1];\n        }\n    }\n    int k;\n    cin >> k;\n    auto get_ancestor = [&h](int n, int d) {\n        for (int i = 0; i < 20; i++) {\n            if (d & bs(i)) {\n                n = h[n][i];\n            }\n        }\n        return n;\n    };\n    for (int i = 0; i < k; i++) {\n        int u, v;\n        cin >> u >> v;\n        if (d[u] > d[v]) swap(u, v);\n        v = get_ancestor(v, d[v] - d[u]);\n        int l = -1, r = d[u];\n        while (r - l > 1) {\n            int m = (r + l) / 2;\n            int uu = get_ancestor(u, m);\n            int vv = get_ancestor(v, m);\n            if (uu == vv) r = m;\n            else l = m;\n        }\n        cout << get_ancestor(u, r) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type, ps, pt;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n),ps(n),pt(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int, int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v=st.top().first;\n      int &i=st.top().second;\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tfor(int j=0;j<(int)G[v].size();j++){\n\t  int &u=G[v][j];\n\t  if(u==par[v]){\n\t    swap(u,G[v].back());\n\t    continue;\n\t  }\n\t  sub[v]+=sub[u];\n\t  if(sub[u]>sub[G[v].front()]) swap(u,G[v].front());\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    using T = tuple<int, int, int>;\n    stack<T> st;\n    st.emplace(r,r,0);\n    while(!st.empty()){\n      int v,h;\n      tie(v,h,ignore)=st.top();\n      int &i=get<2>(st.top());\n      if(!i){\n\ttype[v]=c;\n\tps[v]=vid[v]=pos++;\n\tinv[vid[v]]=v;\n\thead[v]=h;\n        hvy[v]=(G[v].empty()?-1:G[v][0]);\n\tif(hvy[v]==par[v]) hvy[v]=-1;\n      }\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tst.emplace(u,(i?u:h),0);\n      }else{\n\tst.pop();\n\tpt[v]=pos;\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\nsigned AOJ_GRL5C(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned YUKI_529(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){a++;return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/12/31\nhttps://yukicoder.me/problems/no/529\n*/\n\nsigned main(){\n  AOJ_GRL5C();\n  //YUKI_529();\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "//Lowest Common Ancestor\n//最小共通先祖\n//二部探索を用いる方法\n/*\nint main(){\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    a = max(a, b);\n    a = max(max(a, b), max(c, d));\n\n}*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 10000\n#define MAX_LOG_V 100\nvector<int> G[MAX_V];                   //グラフの隣接リスト\nint root;                               //根の頂点番号\nint parent[MAX_LOG_V][MAX_V];           //parent[i][j] := 頂点jから2^i親をたどって到達する頂点\nint depth[MAX_V];                       //根からの深さ\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    //parent[0]とdepthを初期化する\n    dfs(root, -1, 0);\n    //parentを初期化する\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親をたどる\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u] >> k) & 1){    //これあテクい\n            v = parent[k][v];\n        }\n    }\n\n    if(u == v) return u;\n\n\n    //二部探索でLCAを求める\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n\n    return parent[0][u];      //uの親を返す\n}\n\nint main(){\n\n    //0-indexed\n    int V, E; cin >> V >> E >> root;\n    for(int i = 0; i < E; i++){\n        int a, b; cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    init(V);\n    int q; cin >> q;\n\n    for(int i = 0; i < q; i++){\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 310;\nint color[100010],  par[100010], depth[100010];\nint top[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(!vis[c]){\n                q.push(c);\n                par[c] = v;\n                depth[c] = depth[v] + 1;\n            }\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            top[v] = u;\n            k++;\n            for(int c : g[v]){\n                if(!vis[c]) q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n    // rep(i,n) printf(\"v:%d col:%d dep:%d\\n\", i, color[i], depth[i]);\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        // cout << u << \" \" << v << endl;\n        assert(u != -1 && v != -1);\n        if(depth[top[u]] > depth[top[v]]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntemplate<typename Type> class RMQ {\nprivate:\n\tint size_; vector<Type> dat;\n\tType query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tType lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tType rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn min(lc, rc);\n\t}\npublic:\n\tRMQ() : size_(0), dat(vector<Type>()) {};\n\tRMQ(int size__) {\n\t\tfor (size_ = 1; size_ < size__; size_ <<= 1); dat.resize(size_ * 2, numeric_limits<Type>::max());\n\t}\n\ttemplate<class T>\n\tRMQ(T l, T r) {\n\t\tint n = (r - l);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ * 2, numeric_limits<Type>::max());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = *(l + i);\n\t\tfor (int i = size_ - 1; i >= 1; i--) dat[i] = min(dat[2 * i], dat[2 * i + 1]);\n\t}\n\tint size() { return size_; }\n\tint ndat() { return numeric_limits<Type>::max(); }\n\tvoid update(int i, Type x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = min(dat[2 * i], dat[2 * i + 1]);\n\t}\n\tType query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nclass LCA {\nprivate:\n\tint V; vector<vector<int> > G; vector<int> vs, depth, id; RMQ<int> q;\n\tvoid rec(int v, int p, int d, int &k) {\n\t\tid[v] = k, vs[k] = v, depth[k++] = d;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tif (G[v][i] != p) {\n\t\t\t\trec(G[v][i], v, d + 1, k);\n\t\t\t\tvs[k] = v, depth[k++] = d;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCA() : V(0), G(vector<vector<int> >()) {};\n\tLCA(int V_) : V(V_) , G(vector<vector<int> >(V_)) {};\n\ttemplate<class T>\n\tLCA(T l, T r) : V(r - l) {\n\t\tG.resize(V); vs.resize(2 * V - 1); depth.resize(2 * V - 1); id.resize(V);\n\t\tint root = -1, k = 0;\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (*(l + i) == -1) root = i;\n\t\t\telse G[i].push_back(*(l + i)), G[*(l + i)].push_back(i);\n\t\t}\n\t\trec(root, -1, 0, k);\n\t\tq = RMQ<int>(depth.begin(), depth.end());\n\t}\n\ttemplate<class T>\n\tLCA(vector<T> v) : V(v.size()) {\n\t\tG.resize(V); vs.resize(2 * V - 1); depth.resize(2 * V - 1); id.resize(V);\n\t\tint root = -1, k = 0;\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (v[i] == -1) root = i;\n\t\t\telse G[i].push_back(v[i]), G[v[i]].push_back(i);\n\t\t}\n\t\trec(root, -1, 0, k);\n\t\tq = RMQ<int>(depth.begin(), depth.end());\n\t}\n\tint query(int v1, int v2) {\n\t\treturn vs[q.query(min(id[v1], id[v2]), max(id[v1], id[v2]) + 1)];\n\t}\n};\nint N, Q, a, b; vector<int> v;\nint main() {\n\tcin >> N; v.resize(N, -1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a;\n\t\twhile (a--) cin >> b, v[b] = i;\n\t}\n\tLCA lca(v.begin(), v.end());\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\tcout << lca.query(a, b) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L;\n\n  std::vector<int> lg;\n  std::vector<BitIndex> small;\n  std::vector<std::vector<Index>> large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n\nprivate:\n  Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), lg(1 << S), small(N), large(L, std::vector<Index>(LG_L)) {\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li][0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li][0] = F(large[li][0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li][x + 1] = F(large[li][x], large[li + (1 << x)][x]);\n      }\n    }\n    std::vector<Index> st;\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      st.clear();\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (!st.empty() && f(i + si, st.back())) st.pop_back();\n        small[i + si] |= 1 << si;\n        if (!st.empty()) small[i + si] |= small[st.back()];\n        st.push_back(i + si);\n      }\n    }\n  }\n  int ntz(int x) const { return lg[x & -x]; }\n  int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l][x], large[r - (1 << x) + 1][x]);\n  }\n};\n#include <vector>\n#include <map>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::map<int, int> ord;\n\n  EulerTour(int N) : T(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ninline int in(){ int x; cin >> x; return x; }\n\nint main() {\n  int N = in();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = in();\n    for (int j = 0; j < k; j++) {\n      et.add_edge(i, in());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = in();\n  for (int i = 0; i < Q; i++) {\n    int u = in(), v = in();\n    cout << lca.query(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.assign(2 * size - 1);\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tif (i < n)\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = make_pair(depth[i], et[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = make_pair(INF, -1);\n\t\t\t}\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; ++i)\nusing namespace std;\n\nusing ll = long long;\n\n\ntemplate<typename T> // T: type of cost\nstruct LCA {\n  int n, root, l;\n  vector<vector<int>> to;  // グラフ\n  vector<vector<T>> co;    // コスト\n  vector<int> dep;         // 根からの深さ\n  vector<T> costs;         // コスト（距離）\n  vector<vector<int>> par;  // ダブリング配列\n  LCA(int n):n(n),to(n),co(n),dep(n),costs(n) {\n    l = 0;\n    while ((1<<l) < n) ++l;\n    par = vector<vector<int>>(n+1,vector<int>(l,n));\n  }\n\n  // a - b の間にコスト c の辺を張る\n  void add_edge(int a, int b, T c=0) {\n    to[a].push_back(b); co[a].push_back(c);\n    to[b].push_back(a); co[b].push_back(c);\n  }\n  void dfs(int v, int d=0, T c=0, int p=-1) {\n    if (p != -1) par[v][0] = p;\n    dep[v] = d;\n    costs[v] = c;\n    for (int i = 0; i < to[v].size(); ++i) {\n      int u = to[v][i];\n      if (u == p) continue;\n      dfs(u, d+1, c+co[v][i], v);\n    }\n  }\n\n  // 初期化 _root: 根の頂点番号\n  void init(int _root=0) {\n    root = _root;\n    dfs(root);\n    // ダブリングのテーブルを構築する\n    for (int i = 0; i < l-1; ++i) {\n      for (int v = 0; v < n; ++v) {\n        par[v][i+1] = par[par[v][i]][i];\n      }\n    }\n  }\n  // LCA\n  int lca(int a, int b) {\n    if (dep[a] > dep[b]) swap(a,b);  // 深いほうが b になるようにしておく\n    int gap = dep[b]-dep[a];         // gap ぶん b から登る\n    for (int i = l-1; i >= 0; --i) {\n      int len = 1<<i;\n      if (gap >= len) {\n        gap -= len;\n        b = par[b][i];\n      }\n    }\n    if (a == b) return a;\n    for (int i = l-1; i >= 0; --i) {\n      int na = par[a][i];\n      int nb = par[b][i];\n      if (na != nb) a = na, b = nb;\n    }\n    return par[a][0];\n  }\n  // 2点間の距離を求める（辺の重みを1とした場合のコストと等しい）\n  int length(int a, int b) {\n    int c = lca(a,b);\n    return dep[a]+dep[b]-dep[c]*2;\n  }\n  // 2点間のコストを求める\n  T dist(int a, int b) {\n    int c = lca(a,b);\n    return costs[a]+costs[b]-costs[c]*2;\n  }\n};\n\n\nvoid aoj_grl_5_c() {\n  int n; cin >> n;\n  int root = 0;\n  LCA<int> lca(n);\n\n  rep(i, n) {\n    int k; cin >> k;\n    rep(j, k) {\n      int c; cin >> c;\n      lca.add_edge(i, c);\n    }\n  }\n  lca.init(root);\n\n  int q; cin >> q;\n  rep(i, q) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  aoj_grl_5_c();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nclass TreeSqrtDecomp {\n    int n, B;\n    int size() const { return n; }\n    // block_id[v]: vが属するblock\n    // block_parent[v]: vが属するblockのparent(vと同じblockには入らない)\n    vi block_id, parent, depth, block_parent, tops, visited;\n    vvi adj;\npublic:\n    vector<set<int>> block_nodes;\n    TreeSqrtDecomp(int n_) : n(n_), adj(n) {\n        int l = 0, r = n;\n        while (l < r - 1) {\n            i64 m = (l + r) / 2;\n            if (m * m >= n) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        B = r;\n    }\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    void decomp(int root = 0) {\n        block_id.assign(n, -1);\n        parent.assign(n, -1);\n        depth.assign(n, 0);\n        block_parent.assign(n, -1);\n        visited.assign(n, 0);\n        vi q(n + 1);\n        int l = 0, r = 0;\n        q[r++] = root;\n        while (l != r) {\n            int v = q[l++];\n            visited[v] = 1;\n            tops.push_back(v);\n            for (int c : adj[v]) {\n                if (!visited[c]) {\n                    parent[c] = v;\n                    depth[c] = depth[v] + 1;\n                    q[r++] = c;\n                }\n            }\n        }\n        int cnt = 0;\n        for (int u: tops) {\n            if (block_id[u] != -1) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for (int i = 0; i < B && l != r; i++) {\n                int v = q[l++];\n                block_id[v] = cnt;\n                block_parent[v] = parent[u];\n                for (int c: adj[v]) {\n                    if (block_id[c] == -1) {\n                        q[r++] = c;\n                    }\n                }\n            }\n            cnt++;\n        }\n        block_nodes = vector<set<int>>(cnt);\n        for (int i = 0; i < n; i++) {\n            block_nodes[block_id[i]].insert(i);\n        }\n    }\n    int get_block_parent(int node) {\n        return block_parent[node];\n    }\n    int get_block_parent_by_id(int block_id) {\n        // if block_id is 0, return -1\n        if (block_id == 0) return -1;\n        return get_block_parent(tops[block_id - 1]);\n    }\n    int get_top_depth(int block_id) {\n        if (block_id == 0) return 0;\n        return depth[tops[block_id - 1]];\n    }\n    int get_block_top_depth(int node) {\n        return get_top_depth(block_id[node]);\n    }\n    int lca(int u, int v) {\n        while (get_block_top_depth(u) > get_block_top_depth(v)) u = block_parent[u];\n        while (get_block_top_depth(u) < get_block_top_depth(v)) v = block_parent[v];\n        while (depth[u] > depth[v]) u = parent[u];\n        while (depth[u] < depth[v]) v = parent[v];\n        while (u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n    int block_cnt() {\n        return tops.size();\n    }\n    int dist(int u, int v) {\n        int w = lca(u, v);\n        return depth[u] - depth[w] + depth[v] - depth[w];\n    }\n    bool in_same_block(int u, int v) {\n        return get_block_parent(u) == get_block_parent(v);\n    }\n    int get_block_id(int node) {\n        return block_id[node];\n    }\n    int get_parent(int node) {\n        return parent[node];\n    }\n    int get_depth(int node) {\n        return depth[node];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    TreeSqrtDecomp tree(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a;\n            cin >> a;\n            tree.addEdge(i, a);\n        }\n    }\n    tree.decomp();\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename G >\nstruct DoublingLowestCommonAncestor {\n  const int LOG;\n  vector< int > dep;\n  const G &g;\n  vector< vector< int > > table;\n\n  DoublingLowestCommonAncestor(const G &g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size())) {\n    table.assign(LOG, vector< int >(g.size(), -1));\n  }\n\n  void dfs(int idx, int par, int d) {\n    table[0][idx] = par;\n    dep[idx] = d;\n    for(auto &to : g[idx]) {\n      if(to != par) dfs(to, idx, d + 1);\n    }\n  }\n\n  void build() {\n    dfs(0, -1, 0);\n    for(int k = 0; k + 1 < LOG; k++) {\n      for(int i = 0; i < table[k].size(); i++) {\n        if(table[k][i] == -1) table[k + 1][i] = -1;\n        else table[k + 1][i] = table[k][table[k][i]];\n      }\n    }\n  }\n\n  int query(int u, int v) {\n    if(dep[u] > dep[v]) swap(u, v);\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(((dep[v] - dep[u]) >> i) & 1) v = table[i][v];\n    }\n    if(u == v) return u;\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(table[i][u] != table[i][v]) {\n        u = table[i][u];\n        v = table[i][v];\n      }\n    }\n    return table[0][u];\n  }\n};\n\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  UnWeightedGraph g(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    while(k--) {\n      int c;\n      scanf(\"%d\", &c);\n      g[i].push_back(c);\n    }\n  }\n  DoublingLowestCommonAncestor< UnWeightedGraph > lca(g);\n  lca.build();\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    printf(\"%d\\n\", lca.query(x, y));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n// #define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 30;\nvector<int> G[MAX_V];\nint root;\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    dfs(root, -1, 0);\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u]) >> k & (int)1){\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n}\n\nsigned main(){\n    int n;\n    root = 0;\n    cin >> n;\n    rep(i, 0, n){\n        int k;\n        cin >> k;\n        rep(j, 0, k){\n            int c;\n            cin >> c;\n            G[i]. push_back(c);\n            // G[c]. push_back(i);\n        }\n    }\n    init(n);\n    int q;\n    cin >> q;\n    rep(i, 0, q){\n        int u, v;\n        cin >> u >> v;\n        int tmp = lca(u, v);\n        cout << tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100005;\nconst int MAX_N = 100005;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n + n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int d, int &k){\n            assert(v < MAX_V);\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(id[G[v][i]] == 0){\n                    dfs(G[v][i], d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, 0, k);\n            rmqInit(depth,V * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// RMQ\n#include<vector>\n#include<climits>\n#include<cassert>\nconst int INF = INT_MAX;\nclass RangeMinimumQuery {\npublic:\n  explicit RangeMinimumQuery(int s);\n  void update(int i, int v);\n  int index(int left, int right) const;\n  int value(int left, int right) const;\nprivate:\n  int parent(int node) const;\n  int left_child(int node) const;\n  int right_child(int node) const;\n  int power_of_two(int n) const;\n  int query(int left, int right, int node, int node_left, int node_right) const;\n  int size_, nil_, inf_;\n  std::vector<int> index_, value_;\n};\nRangeMinimumQuery::RangeMinimumQuery(int s) : size_(power_of_two(s)), nil_(size_), inf_(INF), index_(2 * size_ - 1, nil_), value_(size_ + 1, inf_) {}\nvoid RangeMinimumQuery::update(int i, int v) {\n  int node = i + size_ - 1;\n  index_.at(node) = i;\n  value_.at(i) = v;\n  while((node = parent(node)) != nil_) {\n    int l = value_.at(index_.at(left_child(node)));\n    int r = value_.at(index_.at(right_child(node)));\n    index_.at(node) = index_.at(l <= r ? left_child(node) : right_child(node));\n  }\n}\nint RangeMinimumQuery::index(int left, int right) const {\n  return query(left, right, 0, 0, size_ - 1);\n}\nint RangeMinimumQuery::value(int left, int right) const {\n  return value_.at(query(left, right, 0, 0, size_ - 1));\n}\nint RangeMinimumQuery::parent(int node) const {return node ? (node - 1) / 2 : nil_;}\nint RangeMinimumQuery::left_child(int node) const {return 2 * node + 1;}\nint RangeMinimumQuery::right_child(int node) const {return 2 * node + 2;}\nint RangeMinimumQuery::power_of_two(int n) const {\n  while(n & (n - 1)) n += n & -n;\n  return n;\n}\nint RangeMinimumQuery::query(int left, int right, int node, int node_left, int node_right) const {\n  assert(left <= right);\n  assert(0 <= left);\n  assert(right < size_);\n  if(node_right < left || right < node_left) return nil_;\n  if(left <= node_left && node_right <= right) return index_.at(node);\n  int middle = (node_left + node_right) / 2;\n  int l = query(left, right, left_child(node), node_left, middle);\n  int r = query(left, right, right_child(node), middle + 1, node_right);\n  return value_.at(l) <= value_.at(r) ? l : r;\n}\n\n// Graph: Adjacency list\n#include<vector>\ntypedef std::vector<std::vector<int>> Graph;\n\n// LCA\n#include<vector>\n#include<utility>\n#include<memory>\nclass LowestCommonAncestor {\npublic:\n  explicit LowestCommonAncestor(const Graph& g) : id_(g.size()) {\n    dfs(g, 0, 0);\n    RMQ_ = std::unique_ptr<RangeMinimumQuery>(new RangeMinimumQuery(depth_.size()));\n    for(int i = 0; i < depth_.size(); ++i) RMQ_->update(i, depth_.at(i));\n  }\n  int find(int u, int v) const {\n    if(id_.at(u) > id_.at(v)) std::swap(u, v);\n    return vs_.at(RMQ_->index(id_.at(u), id_.at(v)));\n  }\nprivate:\n  void dfs(const Graph& g, int current, int depth) {\n    id_.at(current) = vs_.size();\n    vs_.push_back(current);\n    depth_.push_back(depth);\n    for(const auto& next: g.at(current)) {\n      dfs(g, next, depth + 1);\n      vs_.push_back(current);\n      depth_.push_back(depth);\n    }\n  }\n  std::vector<int> id_, vs_, depth_;\n  std::unique_ptr<RangeMinimumQuery> RMQ_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n\n  Graph g(n);\n  for(auto& list: g) {\n    int k;\n    cin >> k;\n    list.resize(k);\n    for(auto& c: list) cin >> c;\n  }\n\n  LowestCommonAncestor lca(g);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.find(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <assert.h>\n\n#define LL long long\n#define VI vector<int>\n#define VL vector<long long>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_LOG_V = 20;\n// ??\\???\nvector<int> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint root = 0; // ?????????????????????\nint parent[MAX_LOG_V][MAX_V]; // ??????2^k????????£?????°???????????????(???????????????????????´??????-1??¨??????)\nint depth[MAX_V]; // ??????????????±???\n\nvoid dfs(int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (int i = 0; i < G[v].size(); i++) {\n        if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\n// ?????????\nvoid init(int V) {\n    // parent[0]??¨depth??????????????????\n    dfs(root, -1, 0);\n    // parent??????????????????\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n        for (int v = 0; v < V; v++) {\n            if (parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n// u??¨v???LCA????±???????\nint lca(int u, int v) {\n    // u??¨v?????±??????????????????????????§????????????\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n        if ((depth[v] - depth[u]) >> k & 1) {\n            v = parent[k][v];\n        }\n\n    }\n    if (u == v) return u;\n    // ????????¢?´¢??§LCA????±???????\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n        if (parent[k][u] != parent[k][v]) {\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(int argc, char *argv[]) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, c;\n    cin >> n;\n    \n    FOR(i, 0, n) {\n        cin >> k;\n        FOR(j, 0, k) {\n            cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    init(n);\n\n    int q, u, v;\n    cin >> q;\n    FOR(i, 0, q) {\n        cin >> u >> v;\n        cout << lca(u, v) << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct LCNode {\n  using LP = LCNode *;\n\n  using data_t = int;\n  using lazy_t = int;\n\n  LP l, r, p;\n  int idx, sz;\n  bool rev;\n  data_t key, sum;\n  lazy_t lazy;\n\n  void init_node(int idx, const data_t &v) {\n    this->sz = 1;\n    this->idx = idx;\n    this->lazy = 0; // <-\n    this->key = this->sum = v;\n  }\n\n  void update() {\n    sz = 1;\n    sum = key;\n    if(l) {\n      sz += l->sz;\n      // <- sum += l->sum\n    }\n    if(r) {\n      sz += r->sz;\n      // <- sum += r->sum\n\n    }\n  }\n\n  void propagate(const lazy_t &v) {\n    // <- lazy+=v, key+=v, sum+=v\n  }\n\n  void toggle() {\n    swap(l, r);\n    rev ^= true;\n    // <-\n  }\n\n  bool is_root() {\n    return !p || (p->l != this && p->r != this);\n  }\n\n  void push() {\n    if(lazy) { // <-\n      if(l) l->propagate(lazy);\n      if(r) r->propagate(lazy);\n      lazy = 0; // <-\n    }\n    if(rev) {\n      if(l) l->toggle();\n      if(r) r->toggle();\n      rev = false;\n    }\n  }\n\n  void rotr() {\n    LP x = p, y = x->p;\n    if((x->l = r)) r->p = x;\n    r = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void rotl() {\n    LP x = p, y = x->p;\n    if((x->r = l)) l->p = x;\n    l = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void splay() {\n    push();\n    while(!is_root()) {\n      LP q = p;\n      if(q->is_root()) {\n        q->push(), push();\n        if(q->l == this) this->rotr();\n        else this->rotl();\n      } else {\n        LP r = q->p;\n        r->push(), q->push(), push();\n        if(r->l == q) {\n          if(q->l == this) q->rotr(), rotr();\n          else rotl(), rotr();\n        } else {\n          if(q->r == this) q->rotl(), rotl();\n          else rotr(), rotl();\n        }\n      }\n    }\n  }\n\n  LP expose() {\n    LP rp = nullptr;\n    for(LP cur = this; cur; cur = cur->p) {\n      cur->splay();\n      cur->r = rp;\n      cur->update();\n      rp = cur;\n    }\n    splay();\n    return rp;\n  }\n\n  void link(LP parent) {\n    expose();\n    parent->expose();\n    p = parent;\n    parent->r = this;\n  }\n\n  void cut() {\n    expose();\n    LP parent = l;\n    l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert() {\n    expose();\n    toggle();\n    push();\n  }\n\n  LP lca(LP v) {\n    expose();\n    return v->expose();\n  }\n\n  void set_propagate(const lazy_t &x) {\n    expose();\n    propagate(x);\n    push();\n  }\n};\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  vector< LCNode * > uku(N);\n  for(int i = 0; i < N; i++) {\n    uku[i] = new LCNode();\n    uku[i]->init_node(i, 0);\n  }\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      uku[T]->link(uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    printf(\"%d\\n\", uku[V]->lca(uku[U])->idx);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 500;\nint color[100010], par[100010], depth[100010];\nint depthTop[100010];\nint goUp[100010];\nint vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    vector<int> q(n+1); int l = 0, r = 0;\n    q[r++] = root;\n    vector<int> tord;\n    while(l != r){\n        int v = q[l++]; vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q[r++] = c;\n            par[c] = v; depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        l = 0, r = 0;\n        q[r++] = u;\n        for(int i = 0; i < B && l != r; i++){\n            int v = q[l++];\n            vis[v] = true; color[v] = c; goUp[v] = par[u]; depthTop[v] = depth[u];\n            for(int c : g[v]) if(!vis[c]) q[r++] = c;\n        }\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depthTop[u] > depthTop[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOP 20\t\t//Number Of Fathers\nusing namespace std;\n\nstruct nodo\n{\n\tint lv;\n\tset<int>Fx;\n\tvector<int>Pb;\n\tnodo()\n\t{\n\t\tlv = 0;\n\t\tPb.assign(NOP,0);\n\t}\n};\n\nclass tree\n{\n\tprivate:\n\t\tvector<nodo> v;\n\t\tint root;\n\tpublic:\t\n\ttree(int n)\n\t{\n\t\tv.assign(n,nodo());\n\t\troot = 0;\n\t}\n\ttree(int n , int r)\n\t{\n\t\tv.assign(n,nodo());\n\t\troot = r;\n\t\tv[r].Pb[0] = r;\n\t}\n\tvoid conect(int x , int y)\n\t{\n\t\tv[x].Fx.insert(y);\n\t\tv[y].Fx.insert(x);\n\t\tv[y].Pb[0] = x;\n\t}\n\tvoid LV(int x , int l , int p)\n\t{\n//\t\tcout << x << \" , \" << l << '\\n';\n\t\tv[x].lv = l;\n\t\tset<int>::iterator it;\n\t\tfor(it = v[x].Fx.begin() ; it != v[x].Fx.end() ; it++)\n\t\t\tif(*it != p)\n\t\t\t\tLV(*it , l + 1 , x);\n\t}\n\tvoid BinaryP()\n\t{\n\t\tfor(int i = 1 ; i < NOP ; i++)\n\t\t\tfor(int j = 0 ; j < v.size() ; j++)\n\t\t\t\tv[j].Pb[i] = v[v[j].Pb[i-1]].Pb[i-1];\n\t}\n\tint LCA(int x , int y)\n\t{\n\t\tint dif = abs(v[x].lv - v[y].lv);\n\t\tint p1 , p2;\n\t\tif(v[x].lv > v[y].lv)\n\t\t{\n\t\t\tp1 = x;\n\t\t\tp2 = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = y;\n\t\t\tp2 = x;\n\t\t}\n//\t\tcout<< '\\n' << dif << \" , \" << p1 << \" , \" << p2 << \" DIF\\n\";\n\t\tif(dif > 0)\n\t\t{\n\t\t\tfor(int i = 0 ; (1<<i) <= dif ; i++)\n\t\t\t{\n\t\t\t\tif(((1<<i)&dif) != 0)\n\t\t\t\t\tp1 = v[p1].Pb[i];\n\t\t\t}\n\t\t}\n//\t\tcout << p1 << \" , \" << p2 << \" PS\\n\";\n\t\tif(p1 == p2)\n\t\t\treturn p1;\n\t\telse\n\t\t{\n\t\t\tfor(int i = NOP - 1 ; i >= 0 ; i--)\n\t\t\t{\n\t\t//\t\tcout << v[p1].Pb[i] << \" , \" << v[p2].Pb[i] << \" FIND\\n\";\n\t\t\t\tif(v[p1].Pb[i] != v[p2].Pb[i])\n\t\t\t\t{\n\t\t\t\t\tp1 = v[p1].Pb[i];\n\t\t\t\t\tp2 = v[p2].Pb[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn v[p1].Pb[0];\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n , q , a , b;\n\tcin >> n;\n\ttree tr(n);\n\tfor(int i = 0 ; i < n ; i++)\n\t{\n\t\tcin >> a;\n\t\tfor(int j = 0 ; j < a ; j++)\n\t\t{\n\t\t\tcin >> b;\n\t\t\ttr.conect(i,b);\n\t\t}\n\t}\n\ttr.LV(0,0,0);\n\ttr.BinaryP();\n\tcin >> q;\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t\tcin >> a >> b;\n\t\tcout << tr.LCA(a,b) << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int MAX_N = 1e5;\nconst int MAX_M = (MAX_N << 1) - 1;\nconst int LSIZE = (MAX_M + 7) >> 3;\n\npii table[15][LSIZE];\npii mini[9][1 << 7];\nint buck[LSIZE];\nint off[LSIZE];\n\n\nint it = 0;\n\nint vs[MAX_M];\nint id[MAX_N];\n\nint n;\nvector<int> G[MAX_N];\n\nvoid dfs(int v) {\n\tid[v] = it;\n\tif (it) {\n\t\tbuck[(it - 1) >> 3] |= 1 << ((it - 1) & 7);\n\t}\n\tvs[it++] = v;\n\tfor (auto to : G[v]) {\n\t\tdfs(to);\n\t\tvs[it++] = v;\n\t}\n}\n\nvoid bitDP() {\n\tmini[0][0] = { 1e9, -100 };\n\tfor (int b = 0; b < 8; b++) {\n\t\tfor (int i = 0; i < (1 << b); i++) {\n\t\t\tint mi = 0, id = 0, t = 0;\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\tt += (((i >> j) & 1) << 1) - 1;\n\t\t\t\tif (t < mi) {\n\t\t\t\t\tmi = t;\n\t\t\t\t\tid = j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmini[b + 1][i] = { mi, id };\n\t\t}\n\t}\n}\n\nvoid init() {\n\tbitDP();\n\tint m = (n << 1) - 1;\n\tint l = (m + 7) >> 3;\n\tdfs(0);\n\toff[0] = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tpii tmp = mini[min(m - (i << 3), 8)][buck[i] & ((1 << 7) - 1)];\n\t\ttable[0][i] = { tmp.first + off[i], tmp.second + (i << 3) };\n\t\toff[i + 1] = off[i] + (__builtin_popcount(buck[i]) << 1) - 8;\n\t}\n\tint h = 31 - __builtin_clz(l);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j + (1 << i) < l; j++) {\n\t\t\ttable[i + 1][j] = min(table[i][j], table[i][j + (1 << i)]);\n\t\t}\n\t}\n}\n\npii get_buck(int l, int r) {\n\tpii tmp = mini[r - l][(buck[l >> 3] & ((1 << ((r - 1) & 7)) - 1)) >> (l & 7)];\n\treturn pii(off[l >> 3] + (__builtin_popcount(buck[l >> 3] & ((1 << (l & 7)) - 1)) << 1) - (l & 7) + tmp.first, l + tmp.second);\n}\n\nint lca(int u, int v) {\n\tu = id[u], v = id[v];\n\tif (u > v) swap(u, v);\n\tv++;\n\tif (((u + 7) >> 3) > (v >> 3)) {\n\t\treturn vs[u + mini[v - u][(buck[u >> 3] & ((1 << ((v - 1) & 7)) - 1)) >> (u & 7)].second];\n\t}\n\tpii left = get_buck(u, (u + 7) & (~7));\n\tpii right = get_buck(v & (~7), v);\n\tu = (u + 7) >> 3;\n\tv >>= 3;\n\tif (u == v) {\n\t\treturn vs[min(left, right).second];\n\t}\n\tint b = 31 - __builtin_clz(v - u);\n\treturn vs[min(min(left, right), min(table[b][u], table[b][v - (1 << b)])).second];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nusing ll =  long long ;\nusing P = pair<int,int> ;\nconst int INF = 1e9;\nconst int MOD = 1000000007;\nint v = 100005; //頂点の数\nvector<vector<int>> tree(v,vector<int>()); //木\nvector<vector<int>> parents; //parents[i][j] := i の　2^j　上の祖先\nvector<int> dist(v,0); //rootからの距離\n\nvoid init_dfs(int i,int before=-1,int d=0){\n    parents[i][0] = before;\n    dist[i] = d;\n    for(int next:tree[i]){\n        if(next == before) continue;\n        init_dfs(next,i,d+1);\n    }\n}\n\nvoid LCAinit(int root = 0){\n    int k = 1;\n    while((1<<k)<v) k ++;\n    parents.assign(v,vector<int>(k,-1));\n    init_dfs(root);\n    for(int j = 0;j < k-1;j++){\n        for(int i = 0;i < v;i++){\n            if(parents[i][j] < 0){\n                parents[i][j+1] = -1;\n            }else{\n                parents[i][j+1] = parents[parents[i][j]][j];\n            }\n        }\n    }\n}\n\nint LCA(int x,int y){\n    if(dist[x] < dist[y]) swap(x,y);\n    int k = parents[0].size();\n    for(int i = 0;i < k;i++){\n        if((dist[x]-dist[y]) >> i & 1){\n            x = parents[x][i];\n        }\n    }\n\n    if(x == y) return x;\n    for(int i = k-1;i >= 0 ;i--){\n        if(parents[x][i] != parents[y][i]){\n            x = parents[x][i];\n            y = parents[y][i];\n        }\n    }\n    return parents[x][0];\n}\n\nint main(){\n    cin >> v;\n    rep(i,v){\n        int p;\n        cin >> p;\n        rep(j,p){\n            int c;\n            cin >> c;\n            tree[i].push_back(c);\n            tree[c].push_back(i);\n        }\n    }\n    LCAinit();\n\n    int q;\n    cin >> q;\n    while(q--){\n        int a,b;\n        cin >> a >> b;\n        cout << LCA(a,b) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <functional>\n#include <vector>\n\nstruct HLDecomposition {\n  const int N;\n  std::vector<std::vector<int>> tree;\n  std::vector<int> cluster, par, depth, ord, head, offset;\n\n  // ord[head[cluster[u]] + offset[u]] == u\n\n  HLDecomposition(int N) : N(N), tree(N), cluster(N, -1), par(N, -1), depth(N), ord(N), offset(N) {}\n\n  void add_edge(int u, int v) {\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n  void build(int root = 0) {\n    std::vector<int> Q;\n    Q.reserve(N);\n    Q.push_back(root);\n    for (int i = 0; i < N; i++) {\n      int u = Q[i];\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        par[v] = u;\n        depth[v] = depth[u] + 1;\n        Q.push_back(v);\n      }\n    }\n    std::vector<int> subtree_size(N, 1);\n    for (int i = N - 1; i > 0; i--) {\n      subtree_size[par[Q[i]]] += subtree_size[Q[i]];\n    }\n\n    std::vector<std::vector<int>> pathes;\n    for (int u : Q) {\n      if (cluster[u] == -1) {\n        cluster[u] = pathes.size();\n        pathes.emplace_back();\n      }\n      pathes[cluster[u]].push_back(u);\n\n      int max_subsize = -1, selected = -1;\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        if (max_subsize >= subtree_size[v]) continue;\n        max_subsize = subtree_size[v];\n        selected = v;\n      }\n      if (selected != -1) cluster[selected] = u;\n    }\n\n    int P = pathes.size();\n    head.resize(P + 1);\n    for (int p = 0; p < P; p++) {\n      int H = head[p];\n      int L = pathes[p].size();\n      head[p + 1] = H + L;\n      for (int i = 0; i < L; i++) {\n        int v = pathes[p][i];\n        offset[v] = i;\n        ord[H + i] = v;\n      }\n    }\n  }\n  void for_each(int u, int v, std::function<void(int, int)> f) const {\n    while (cluster[u] != cluster[v]) {\n      if (depth[head[cluster[u]]] > depth[head[cluster[v]]]) std::swap(u, v);\n      int h = head[cluster[v]];\n      f(h, h + offset[v] + 1);\n      v = par[h];\n    }\n    if (offset[u] > offset[v]) std::swap(u, v);\n    f(head[cluster[u]] + offset[u], head[cluster[v]] + offset[v] + 1);\n  }\n  int lca(int u, int v) const {\n    int x;\n    for_each(u, v, [&](int l, int r) { x = ord[l]; });\n    return x;\n  }\n  std::vector<std::vector<int>> build_pathes() const {\n    const int P = head.size() - 1;\n    std::vector<std::vector<int>> pathes(P);\n    for (int i = 0; i < P; i++) {\n      pathes[i].reserve(head[i + 1] - head[i]);\n      for (int j = head[i]; j < head[i + 1]; j++) {\n        pathes[i].push_back(ord[j]);\n      }\n    }\n    return pathes;\n  }\n};\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n// clang-format off\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}if(m)x=-x;return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n\nint main() {\n  int N = rd();\n  HLDecomposition hl(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    for (int j = 0; j < k; j++) {\n      hl.add_edge(i, rd());\n    }\n  }\n  hl.build();\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(hl.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = ceil(log2(N));\n    // logN = 0;\n    // for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowestCommonAncestor{\n    const int MAX_LOG_V = 50;\n    vector<vector<int> > G, parent;\n    int root = 0, V;\n    vector<int> depth;\n    LowestCommonAncestor(int _V){\n        V = _V;\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n    void add_edge(int u, int v){\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    void dfs(int v, int p, int d){\n        parent[0][v] = p;\n        depth[v] = d;\n        for(int i = 0; i < G[v].size(); i++){\n            if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n    void build(){\n        dfs(root, -1, 0);\n        for(int k = 0; k + 1 < MAX_LOG_V; k++){\n            for(int v = 0; v < V; v++){\n                if(parent[k][v] < 0) parent[k + 1][v] = -1;\n                else parent[k + 1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n    int query(int u, int v){\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int k = 0; k < MAX_LOG_V; k++){\n            if((depth[v] - depth[u]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        for(int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];    \n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor lca(n);\n    for(int i = 0; i < n; i++){\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; j++){\n            int c;\n            cin >> c;\n            lca.add_edge(i, c);\n        }\n    }\n    lca.build();\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; i++){\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n// -------------8<------- start of library -------8<------------------------\nstruct LowestCommonAncestor {\n    const int root, INF, n;\n    int size, no;\n    std::vector<std::vector<int>> adj;\n    std::vector<int> ord, idx;\n    std::vector<std::pair<int, int>> dep;\n\n    LowestCommonAncestor(int _n, int _r = 0) :\n        root(_r), INF(INT_MAX), n(_n), adj(n), ord(2 * n - 1), idx(n) {}\n\n    void add_edge(int u, int v) { adj[u].push_back(v); adj[v].push_back(u); }\n\n    void Dfs(int cur, int p, int d) {\n        ord[no] = cur;\n        idx[cur] = no;\n        dep[size - 1 + no++] = std::make_pair(d, cur);\n        for (int nxt : adj[cur]) {\n            if (nxt == p) continue;\n            Dfs(nxt, cur, d + 1);\n            ord[no] = cur;\n            dep[size - 1 + no++] = std::make_pair(d, cur);\n        }\n    }\n\n    void Preprocessing() {\n        for (size = 1; size < 2 * n - 1; ) size <<= 1;\n        dep.assign(2 * size - 1, std::make_pair(INF, INF));\n\n        no = 0;\n        Dfs(root, -1, 0);\n\n        for (int i = size - 2; 0 <= i; --i) {\n            if (dep[2 * i + 1] < dep[2 * i + 2]) dep[i] = dep[2 * i + 1];\n            else dep[i] = dep[2 * i + 2];\n        }\n    }\n\n    int rmq(int l, int r) {\n        std::pair<int, int> res(INF, INF);\n        l += size - 1;\n        r += size - 1;\n        while (l < r) {\n            if ((l & 1) == 0) res = std::min(res, dep[l]);\n            if ((r & 1) == 0) res = std::min(res, dep[r - 1]);\n            l >>= 1;\n            r = (r - 1) >> 1;\n        }\n        return res.second;\n    }\n\n    int query(int u, int v) {\n        if (idx[v] < idx[u]) std::swap(u, v);\n        return rmq(idx[u], idx[v] + 1);\n    }\n};\n// -------------8<------- end of library ---------8-------------------------\n\nint main() {\n    std::cin.tie(0); std::ios::sync_with_stdio(false);\n\n    // AOJ GRL_5_C: Tree - Lowest Common Ancestor\n    int n;\n    std::cin >> n;\n\n    LowestCommonAncestor lca(n, 0);\n    for (int v = 0, deg, c; v < n; ++v) {\n        std::cin >> deg;\n        while (deg--) {\n            std::cin >> c;\n            lca.add_edge(v, c);\n        }\n    }\n    lca.Preprocessing();\n\n    int q, u, v;\n    std::cin >> q;\n    while (q--) {\n        std::cin >> u >> v;\n        std::cout << lca.query(u, v) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst int sqrtN = 512;\nconst int logN = 32;\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nstruct LowestCommonAncestor{\n\tvector<vector<int>> g, parent;\n\tvector<int> depth;\n\tbool built = false;\n\tint N;\n\t\n\tLowestCommonAncestor(int n) : N(n) {\n\t\tg.resize(N);\n\t\tparent.resize(logN, vector<int>(N));\n\t\tdepth.resize(N);\n\t}\n\t\n\tvoid add_edge(int u, int v){\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int par = -1, int d = 0){\n\t\tparent[0][v] = par;\n\t\tdepth[v] = d;\n\t\t\n\t\tfor(auto e:g[v]){\n\t\t\tif(e == par) continue;\n\t\t\tdfs(e, v, d + 1);\n\t\t}\n\t}\n\t\n\tvoid build(){\n\t\tdfs(0);\n\t\tREP(k, 0, logN - 1){\n\t\t\tREP(i, 0, N){\n\t\t\t\tif(parent[k][i] < 0) parent[k + 1][i] = -1;\n\t\t\t\telse parent[k + 1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint get(int u, int v){\n\t\tif(!built) build(); built = true;\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\t\n\t\tREP(k, 0, logN) if(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\t\n\t\tif(u == v) return u;\n\t\t\n\t\tRREP(k, logN - 1, 0){\n\t\t\tif(parent[k][u] == parent[k][v]) continue;\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\t\t\t\n\t\t}\n\t\t\n\t\treturn parent[0][u];\n\t}\n};\n\nint main(){\n\tint n; cin >> n;\n\tLowestCommonAncestor lca(n);\n\tREP(i, 0, n){\n\t\tint k; cin >> k;\n\t\tREP(j, 0, k){\n\t\t\tint a; cin >> a;\n\t\t\tlca.add_edge(i, a);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tREP(i, 0, q){\n\t\tint a, b; cin >> a >> b;\n\t\t\n\t\tcout << lca.get(a, b) << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\nconst int LOG_N = 17;\n\nvector<int> G[MAX_N];\n\nint par[LOG_N][MAX_N];\nint depth[MAX_N];\n\nvoid dfs(int u,int p,int d)\n{\n    par[0][u] = p;\n    depth[u] = d;\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            dfs(G[u][i],u,d+1);\n        }\n    }\n}\n\nint lca(int u,int v)\n{\n    if(depth[u] > depth[v]){\n        swap(u,v);\n    }\n    rep(i,LOG_N){\n        if((depth[v] - depth[u]) & (1 << i)){\n            v = par[i][v];\n        }\n    }\n    for(int i=LOG_N-1;i>=0;i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,-1,0);\n    rep(i,LOG_N-1){\n        rep(j,n){\n            if(par[i][j] < 0){\n                par[i+1][j] = -1;\n            }else{\n                par[i+1][j] = par[i][par[i][j]];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        printf(\"%d\\n\",lca(x,y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.resize(2 * size - 1);\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tif (i < n)\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = make_pair(depth[i], et[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = make_pair(INF, -1);\n\t\t\t}\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass LCA{\npublic:\n  const int LOG_V=30;                 //log V (自分で決めて)\n  int V;                              //言わずもがな頂点数\n  vector<vector<int> > G;             //グラフの隣接リストの表現\n  int root;                         //根のノード番号\n  vector<vector<int> > parent;        //親を2^k回辿って到達する頂点(根を通りすぎる場合は-1とする)\n  vector<int> depth;                  //根からの深さ\n  int ok;\n  \n  LCA():V(-1){}\n  LCA(int V,int root = 0):V(V),G(V),root(root),parent(LOG_V,vector<int>(V)),depth(V),ok(0){}\n  \n  void add_edge(int a, int b){\n    assert(a < V && b < V);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  void dfs(int v,int p,int d){\n    assert(v < V);\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int to:G[v]) if(to != p) dfs(to,v,d+1);\n  }\n  \n  //vからn個上の祖先\n  int getAnc(int v,int n){\n    for(int k=0; k<LOG_V ;k++) if((v != -1) && (n>>k&1)) v=parent[k][v];\n    return v;\n  }\n\n  //初期化\n  void build(){\n    ok = 1;\n    //parent[0]とdepthを初期化する。\n    dfs(root,-1,0);\n    //parentを初期化する\n    for(int k=0; k+1<LOG_V ;k++)\n      for(int v=0; v<V ;v++)\n        if(parent[k][v] < 0)parent[k+1][v] = -1;\n        else parent[k+1][v] = parent[k][parent[k][v]];\n  }\n\n  //uとvのLCAを求める\n  int lca(int u,int v){\n    assert(ok);\n    assert(u < V && v < V);\n    //uとvの深さが同じになるまで親を辿る\n    if(depth[u]>depth[v]) swap(u,v);\n    v = getAnc(v,depth[v] - depth[u]);\n    \n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=LOG_V-1; k>=0 ;k--)\n      if(parent[k][u] != parent[k][v]){\n        u=parent[k][u];\n        v=parent[k][v];\n      }\n    return parent[0][u];\n  }\n};\n\nint main(){\n  int n;\n  cin>>n;\n  LCA lca(n);\n  \n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n\n  lca.build();\n\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int limit=16;\nconst int nmax=100010;\n\nvector<int> graph[nmax];\nint parent[nmax][limit]; // all is -1\nint depth[nmax];\n\nvoid dfs(int v,int p,int d){\n\tparent[v][0]=p;\n\tdepth[v]=d;\n\tfor(auto &v2:graph[v]) if(v2!=p) dfs(v2,v,d+1);\n}\n\nint lca(int u,int v){\n\tif(depth[u] < depth[v]) swap(u,v);\n\tfor(int i=limit-1;i>=0;--i) if((depth[u]-depth[v])>>i&1) u=parent[u][i];\n\tif(u==v) return u;\n\tfor(int i=limit-1;i>=0;--i){\n\t\tif(parent[u][i]!=parent[v][i]){\n\t\t\tu=parent[u][i];\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\treturn parent[u][0];\n}\n\nint main(void){\n\tint n; cin >> n;\n\trep(i,n){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint v; cin >> v;\n\t\t\tgraph[i].push_back(v);\n\t\t}\n\t}\n\n\t// rep(i,n)rep(j,20) parent[i][j]=-1;\n\tdfs(0,-1,0);\n\trep(i,n)rep(j,limit-1) parent[i][j+1]=parent[parent[i][j]][j];\n\n\tint q; cin >> q;\n\trep(i,q){\n\t\tint u,v; cin >> u >> v;\n\t\tcout << lca(u,v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nusing Weight = int;\nstruct Edge {\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O((E+V)logV)\n//dist: ?§????????????????????????§??????????????¢ distance\n//?????????: ???????????¨????????????(??????-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\tusing State = tuple<Weight, int, int>; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State>> PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF);\n\tdist[s] = 0; PQ.emplace(0, s, -1); color[s] = GRAY; //?§????\n\twhile (PQ.size()) {\n\t\tWeight d; int v, u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°???¨??????State???????????????\n\t\tif (dist[v] < d)continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto &e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//??¨?????´???\nEdge diameter(const Graph &g, int s = 0) {\n\tvector<Weight> dist;\n\tdijkstra(g, s, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++) if (dist[i] != INF && (u == -1 || dist[i] > dist[u])) u = i;\n\tdijkstra(g, u, dist);\n\tfor (int i = 0; i < n; i++) if (dist[i] != INF && (v == -1 || dist[i] > dist[v])) v = i;\n\tWeight d = dist[v];\n\tif (u > v) swap(u, v);\n\treturn Edge(u, v, d);\n}\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (set_size(x) < set_size(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint set_size(int x) { return -parent[root(x)]; }\n};\n\n//Tarjan's off-line lowest common ancestors\nstruct Query {\n\tint u, v, w;\n\tQuery(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int s, int prev, vector<Query> &qs, vector<int> &color, vector<int> &ancestor, UnionFind &uf) {\n\tancestor[uf.root(s)] = s;\n\tfor (auto &e : g[s]) {\n\t\tif (e.d == prev)continue;\n\t\tvisit(g, e.d, s, qs, color, ancestor, uf);\n\t\tuf.unite(e.s, e.d);\n\t\tancestor[uf.root(s)] = s;\n\t}\n\tcolor[s] = 1;\n\tfor (auto &q : qs) {\n\t\tint w = (q.v == s ? q.u : q.u == s ? q.v : -1);\n\t\tif (w >= 0 && color[w]) q.w = ancestor[uf.root(w)];\n\t}\n}\nvoid least_common_ancestor(const Graph &g, int root, vector<Query> &qs) {\n\tint n = g.size();\n\tUnionFind uf(n);\n\tvector<int> color(n), ancestor(n);\n\tvisit(g, root, -1, qs, color, ancestor, uf);\n}\n\nsigned main() {\n\tint n; cin >> n;\n\tGraph g(n);\n\trep(i, 0, n) {\n\t\tint k; cin >> k;\n\t\trep(j, 0, k) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(i, c);\n\t\t\tg[c].emplace_back(c, i);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tvector<Query> qs;\n\trep(i, 0, q) {\n\t\tint u, v; cin >> u >> v;\n\t\tqs.emplace_back(u, v);\n\t}\n\tleast_common_ancestor(g, 0, qs);\n\tfor (auto &e : qs) {\n\t\tcout << e.w << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define M 30\nusing namespace std;\nint n,k,c,depth[N],parent[N][M];\nvector<int> e[N];\n\nvoid dfs(int x,int d){\n  depth[x]=d;\n  for(int i=0;i<(int)e[x].size();i++)\n    dfs(e[x][i],d+1);\n}\n\nint lca(int u,int v){\n  if(depth[u]<depth[v])swap(u,v);\n  int K=depth[u]-depth[v];\n  for(int i=0;i<M;i++)\n    if(K>>i&1)u=parent[u][i];\n  if(u==v)return u;\n  for(int j=M-1;j>=0;j--){\n    if(parent[u][j]==parent[v][j])continue;\n    u=parent[u][j];\n    v=parent[v][j];\n  }\n  return parent[u][0];\n}\n\nint main(){\n  cin>>n;\n  memset(parent,-1,sizeof(parent));\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&k);\n    for(int j=0;j<k;j++){\n      scanf(\"%d\",&c);\n      e[i].push_back(c);\n      parent[c][0]=i;\n    }\n  }\n  for(int j=1;j<M;j++)\n    for(int i=0;i<n;i++)\n      if(parent[i][j-1]==-1)parent[i][j]=-1;\n      else parent[i][j]=parent[parent[i][j-1]][j-1];\n  dfs(0,0);\n  int q,u,v;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>u>>v;\n    printf(\"%d\\n\",lca(u,v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing stkll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#ifndef ONLINE_JUDGE\n    #define debug(x) cerr << #x << \": \" << x << endl;\n#else\n    #define debug(x)\n#endif\n\nusing Graph = vvll;\n/* LCA(G, root): 木 G に対する根を root として Lowest Common Ancestor を求める構造体\n    query(u,v): u と v の LCA を求める。計算量 O(logn)\n    前処理: O(nlogn)時間, O(nlogn)空間\n*/\nstruct LCA {\n    vector<vector<int>> parent;  // parent[k][u]:= u の 2^k 先の親\n    vector<int> dist;            // root からの距離\n    LCA(const Graph &G, int root = 0) { init(G, root); }\n    // 初期化\n    void init(const Graph &G, int root = 0) {\n        int V = G.size();\n        int K = 1;\n        while ((1 << K) < V) K++;\n        parent.assign(K, vector<int>(V, -1));\n        dist.assign(V, -1);\n        dfs(G, root, -1, 0);\n        for (int k = 0; k + 1 < K; k++) {\n            for (int v = 0; v < V; v++) {\n                if (parent[k][v] < 0) {\n                    parent[k + 1][v] = -1;\n                } else {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n    // 根からの距離と1つ先の頂点を求める\n    void dfs(const Graph &G, int v, int p, int d) {\n        parent[0][v] = p;\n        dist[v] = d;\n        for (auto e : G[v]) {\n            if (e != p) dfs(G, e, v, d + 1);\n        }\n    }\n    int query(int u, int v) {\n        if (dist[u] < dist[v]) swap(u, v);  // u の方が深いとする\n        int K = parent.size();\n        // LCA までの距離を同じにする\n        for (int k = 0; k < K; k++) {\n            if ((dist[u] - dist[v]) >> k & 1) {\n                u = parent[k][u];\n            }\n        }\n        // 二分探索で LCA を求める\n        if (u == v) return u;\n        for (int k = K - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    ll n; cin >> n;\n    Graph g(n);\n    rep(i, n) {\n        ll k; cin >> k;\n        if(k > 0) {\n            rep(j, k) {\n                ll c; cin >> c;\n                g[i].push_back(c);\n                g[c].push_back(i);\n            }\n        }\n    }\n\n    LCA lca(g);\n    lca.init(g);\n\n    ll q; cin >> q;\n    rep(i, q) {\n        ll u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\n// graph by adjacency list\ntemplate <typename T>\nstruct Edge {\n  int dst; T weight;\n  Edge(int dst, T weight) : dst(dst), weight(weight) { }\n  bool operator < (const Edge<T> &e) const {\n    return weight > e.weight;\n  }\n};\n\ntemplate <typename T>\nstruct Graph {\n  int V;\n  vector<vector<Edge<T>>> E;\n  Graph(int V) : V(V) { E.resize(V); }\n  void add_edge(int src, int dst, T weight) {\n    E[src].emplace_back(dst, weight);\n  }\n};\n\ntemplate <typename T>\nstruct HeavyLightDecomposition {\n  const Graph<T> g;\n  vector<int> vid, head, heavy, parent;\n  HeavyLightDecomposition(const Graph<T> g, int root = 0) : g(g), vid(g.V, -1), head(g.V), heavy(g.V, -1), parent(g.V) {\n    dfs(root, -1);\n    bfs(root);\n  }\n\n  int dfs(int v, int par) {\n    parent[v] = par;\n    int sub = 1, max_sub = 0;\n    for (Edge<T> child : g.E[v]) {\n      if (child.dst != par) {\n        int child_sub = dfs(child.dst, v);\n        sub += child_sub;\n        if (child_sub > max_sub) {\n          max_sub = child_sub;\n          heavy[v] = child.dst;\n        }\n      }\n    }\n    return sub;\n  }\n\n  void bfs(int root = 0) {\n    int k = 0;\n    queue<int> que({root});\n    while (not que.empty()) {\n      int r = que.front(); que.pop();\n      for (int v = r; v != -1; v = heavy[v]) {\n        vid[v] = k++;\n        head[v] = r;\n        for (Edge<T> child : g.E[v]) {\n          if (child.dst != parent[v] and child.dst != heavy[v]) que.push(child.dst);\n        }\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    while(head[u] != head[v]) {\n      if (vid[u] > vid[v]) swap(u, v);\n      v = parent[head[v]];\n    }\n    if (vid[u] > vid[v]) swap(u, v);\n    return u;\n  }\n};\n\nint main() {\n  int N; scanf(\"%d\", &N);\n  Graph<int> g(N);\n  REP(i, N) {\n    int k; scanf(\"%d\", &k);\n    REP(_, k) {\n      int c; scanf(\"%d\", &c);\n      g.add_edge(i, c, 1);\n      g.add_edge(c, i, 1);\n    }\n  }\n\n  HeavyLightDecomposition<int> hld(g);\n\n  int Q; scanf(\"%d\", &Q);\n  REP(_, Q) {\n    int u, v; scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", hld.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <map>\n#include <unordered_map>\n#include <utility>\n\n#define MAXN 100000\n\nusing namespace std;\n\nint pre[MAXN] = {-1};\nint st[MAXN];\n\nvector<pair<int,int>> vp;\nmap<pair<int,int>,int> mans;\n\nstruct pair_hash {\n    template <class T1, class T2>\n    size_t operator () (const pair<T1, T2> &p)const {\n        auto h1 = hash<T1>{}(p.first);\n        auto h2 = hash<T2>{}(p.second);\n        return h1 ^ h2;\n    }\n};\n\nunordered_map<pair<int,int>,int,pair_hash> seek;\n\nvoid swap(int &i,int &j){\n    int t = i;\n    i = j;\n    j = t;\n}\n\n\nclass Edge{\npublic:\n    int s;\n    int t;\n    Edge(int si,int ti):s(si),t(ti){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    vector<forward_list<int>> adj;\n    Graph(int v):V(v){\n        adj.resize(v);\n        for(int i = 0; i < V;i++) {st[i] = i;pre[i] = -1;}\n        }\n    void addEdge(int i,int j){adj[i].push_front(j);}\n    void tarjanR(Edge e);\n};\n\nint root(int v){\n    while(st[v] != v) v = st[v];\n    return v;\n}\n\nvoid Graph::tarjanR(Edge e){\n    int t = e.t;\n    int s = e.s;\n    pre[t] = 0;\n\n    for(auto a = adj[t].begin();a != adj[t].end();++a){\n        int v = *a;\n        if(pre[v] == -1){\n            tarjanR(Edge(t,v));\n        }\n    }\n    for(int i = 0; i < V;i++){\n        int mi = i,ma = t;\n        if(mi > ma) swap(mi,ma);\n        pair<int,int> p = make_pair(mi,ma);\n        if(pre[i] != -1 && seek.find(p)!=seek.end() && seek[p] == -1){\n            seek[p] = root(i);\n        }\n    }\n    st[t] = s;\n}\n\n\nint main()\n{\n    int V,j,q,tt;\n    scanf(\"%d\",&V);\n    Graph G(V);\n    for(int i = 0; i < V; i++){\n        scanf(\"%d\",&j);\n        for(int k = 0; k < j;k++)\n        {\n            scanf(\"%d\",&tt);\n            G.addEdge(i,tt);\n        }\n    }\n\n    int s,t;\n\n    scanf(\"%d\",&q);\n    for(int i = 0; i < q;i++){\n        scanf(\"%d %d\",&s,&t);\n        if(s > t){swap(s,t);}\n        vp.push_back(make_pair(s,t));\n        seek[make_pair(s,t)] = -1;\n    }\n\n    G.tarjanR(Edge(0,0));\n\n    for(int i = 0; i < q;i++){\n        printf(\"%d\\n\",seek[vp[i]]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\n\nint n,q,l,sec,st[maxn],ed[maxn];\nvector<vector<int>>up;\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n\tst[u]=sec++;\n\tup[u][0]=p;\n\tfor (int i=1;i<=l;i++) \n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\tfor (int v:G[u])\n\t\tif (v!=p) dfs(v,u);\n\ted[u]=sec;\n}\n\nbool upper(int u,int v) {\n\treturn st[u]<st[v] && ed[u]>=ed[v];\n}\n\nint lca(int u,int v) {\n\tif (upper(u,v)) return u;\n\tif (upper(v,u)) return v;\n\tfor (int i=l;i>=0;i--) \n\t\tif (!upper(up[u][i],v))\n\t\t\tu=up[u][i];\n\treturn up[u][0];\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i=0;i<n;i++) {\n\t\tint m; cin>>m;\n\t\tfor (int j=0;j<m;j++) {\n\t\t\tint v; cin>>v;\n\t\t\tG[i].pb(v);\n\t\t}\n\t}\n\twhile ((1<<l)<=n) l++;\n\t up.assign(n, vector<int>(l + 1));\n\tdfs(0,0);\n\tcin>>q;\n\tfor (int i=0;i<q;i++) {\n\t\tint u,v; cin>>u>>v;\n\t\tcout<<lca(u,v)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n//by NeighThorn\nusing namespace std;\nconst int maxn=100000+5;\nint n,q,hd[maxn],to[maxn*2],nxt[maxn*2],cnt,vis[maxn],fa[maxn],ans[maxn];\nstruct M{\n\tint y,id;\n\tM(int a=0,int b=0){\n\t\ty=a,id=b;\n\t}\n};\nvector<M> v[maxn];\ninline int find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\t\n}\ninline void add(int x,int y){\n\tto[cnt]=y;nxt[cnt]=hd[x];hd[x]=cnt++;\t\n}\ninline void tarjan(int root){\n\tvis[root]=1;\n\tfor(int i=0;i<(int)v[root].size();i++)\n\t\tif(vis[v[root][i].y])\n\t\t\tans[v[root][i].id]=find(v[root][i].y);\n\tfor(int i=hd[root];i!=-1;i=nxt[i])\n\t\tif(!vis[to[i]])\n\t\t\ttarjan(to[i]),fa[to[i]]=root;\n}\nsigned main(void){\n\tscanf(\"%d\",&n);cnt=0;\n\tmemset(hd,-1,sizeof(hd));\n\tfor(int i=0,k;i<n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t\tscanf(\"%d\",&x),add(i,x),add(x,i);\n\t}scanf(\"%d\",&q);\n\tfor(int i=0;i<n;i++)\n\t\tfa[i]=i,vis[i]=0;\n\tfor(int i=1,x,y;i<=q;i++)\n\t\tscanf(\"%d%d\",&x,&y),v[x].push_back(M(y,i)),v[y].push_back(M(x,i));\n\ttarjan(0);\n\tfor(int i=1;i<=q;i++)\n\t\tprintf(\"%d\\n\",ans[i]);\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int infty = 1e9;\nstruct segment_tree {\n  public:\n    int n, N;\n    vector<pair<int, int>> tr;\n    segment_tree (vector<pair<int, int>> v) {\n      n = v.size();\n      N = 1;\n      while (N < n) {\n        N <<= 1;\n      }\n      tr.resize(2 * N, {infty, -1});\n      for (int i = 0; i < n; i++) {\n        tr[N + i] = v[i];\n      }\n      for (int i = N - 1; i >= 1; i--) {\n        tr[i] = min(tr[2 * i], tr[2 * i + 1]);\n      }\n    }\n    pair<int, int> pairMin (pair<int, int>a, pair<int, int>b) {\n      if (a.first < b.first) return a;\n      if (a.first == b.first && a.second < b.second) return a;\n      return b;\n    }\n    void update (int i, pair<int, int> x) {\n      i += N;\n      tr[i] = x;\n      i >>= 1;\n      for (; i; i >>= 1) {\n        tr[i] = min(tr[2 * i], tr[2 * i + 1]);\n      }\n    }\n    pair<int, int> getMin (int l, int r, int k = 1, int L = 0, int R = -1) {\n      if (R == -1) R = N;\n      if (l <= L && R <= r) {\n        return tr[k];\n      } else if (r <= L || R <= l) {\n        return {infty, -1};\n      } else {\n        int C = (L + R) >> 1;\n        return min(getMin(l, r, 2 * k, L, C), getMin(l, r, 2 * k + 1, C, R));\n      }\n    }\n};\nvector<vector<int>> grh;\nvector<int> pos;\nvector<pair<int, int>> ord;\nvoid dfs (int crr, int d) {\n  pos[crr] = ord.size();\n  ord.push_back({d, crr});\n  for (int nxt : grh[crr]) {\n    dfs(nxt, d + 1);\n    ord.push_back({d, crr});\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  grh.resize(n);\n  pos.resize(n);\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      int c;\n      cin >> c;\n      grh[i].push_back(c);\n    }\n  }\n  dfs(0, 0);\n  segment_tree sgt(ord);\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    int l = pos[u];\n    int r = pos[v];\n    if (l > r) swap(l, r);\n    r++;\n    auto p = sgt.getMin(l, r);\n    cout << p.second << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass LCA {\n\n    using Graph = vector<vector<int>>;\n\n    vector<int> dist;\n    vector<vector<int>> parent;\n\n    void dfs(const Graph& g, int v, int p, int d) {\n        parent[0][v] = p;\n        dist[v] = d;\n        for (int nv: g[v]) {\n            if (nv != p) {\n                dfs(g, nv, v, d + 1);\n            }\n        }\n    }\n\n\npublic:\n    LCA(Graph g, int root) {\n        init(g, root);\n    }\n\n    void init(Graph g, int root) {\n        int V = g.size();\n        int K = 1;\n        while ((1<<K) < V) {\n            K++;\n        }\n        parent.assign(K, vector<int>(V, -1));\n        dist.assign(V, -1);\n        dfs(g, root, -1, 0);\n        for (int k = 0; k < K - 1; k++) {\n            for (int v = 0; v < V; v++) {\n                if (parent[k][v] < 0) {\n                    parent[k + 1][v] = -1;\n                }\n                else {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n\n    \n\n    int query(int u, int v) {\n        if (dist[u] < dist[v]) {\n            swap(u, v);\n        }\n        int K = parent.size();\n        for (int k = 0; k < K; k++) {\n            if ((dist[u] - dist[v]) >> k & 1) {\n                u = parent[k][u];\n            }\n        }\n\n        if (u == v) {\n            return u;\n        }\n        for (int k = K - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            g[c].push_back(i);\n        }\n    }\n\n    LCA lca = LCA(g, 0);\n\n    vector<int> ANS;\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        ANS.push_back(lca.query(u, v));\n    }\n\n    for (int i = 0; i < ANS.size(); i++) {\n        cout << ANS[i] << '\\n';\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\n#define INF (1<<30)\nusing namespace std;\n\nvector<int> Ind(100010);\t\t//Ind[n]  ??\\???n???euler tour??¨??§???????????°?????????\nvector<bool> f(100010, false);\t//\nvector<vector<int>> T(100010);\t//??°??????\nvector<P> ET;                   //????????¢?´¢??¨\n\nvoid dfs(int n,int dep) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tInd[n] = ET.size() - 1;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1);\n\t\tET.emplace_back(make_pair(dep,n));\n\t}\n}\n\nP RMQ(int a, int b, int k, int l, int r, vector<P>& node) {\n\tif (r <= a || b <= l) return P(INF, INF);\n\tif (a <= l && r <= b) return node[k];\n\n\tP vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);\n\tP vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r, node);\n\treturn min(vl, vr);\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t//Graph initialize\n\tint n_; cin >> n_;\n\tfor (int i = 0; i < n_; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\n\t//ET??¨?????????\n\tdfs(0,0);\n\n\n\t//RMQ initialize\n\tn_ = ET.size();\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<P> node(2 * n - 1, P(INF, INF));\n\n\tfor (int i = 0; i < n_;i++) { node[n - 1 + i] = ET[i]; }\n\tfor (int i = n - 2; i >= 0; i--) { node[i] = min(node[2 * i + 1], node[2 * i + 2]); }\n\n\t//Answer\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tint a = Ind[u], b = Ind[v];\n\t\tif (a > b) { swap(a, b); }\n\t\tcout << RMQ(a,b, 0, 0, n, node).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename T>\nstruct HeavyLightDecomposition{\n  struct edge{\n    int to;\n    T w;\n    edge(int to, T w): to(to), w(w){}\n  };\n  int n, cid;\n  vector<vector<edge>> edges;\n  vector<int> par, chain, depth, siz, pos_seg, head;\n  vector<T> parw;\n  HeavyLightDecomposition(){}\n  explicit HeavyLightDecomposition(int n): n(n){\n    edges.resize(n);\n    par.resize(n, -1);\n    chain.resize(n, -1);\n    depth.resize(n, -1);\n    siz.resize(n, 1);\n    pos_seg.resize(n, -1);\n    head.resize(n, -1);\n    parw.resize(n);\n  }\n  void adde(int from, int to, T w){\n    edges[from].emplace_back(to, w);\n  }\n  void build(int r = 0){\n    par.assign(n, -1);\n    chain.assign(n, -1);\n    depth.assign(n, -1);\n    siz.assign(n, -1);\n    pos_seg.assign(n, -1);\n\n    dfs(r);\n\n    hld(r);\n  }\n  void dfs(int r = 0){\n    par[r] = r;\n    depth[r] = 0;\n    deque<int> dq;\n    dq.push_back(r);\n\n    int l = 0;\n    while(l < (int)dq.size()){\n      int i = dq[l];\n      siz[i] = 1;\n      for(auto &e: edges[i]){\n        if(par[e.to] != -1)continue;\n        par[e.to] = i;\n        parw[e.to] = e.w;\n        depth[e.to] = depth[i] + 1;\n        dq.push_back(e.to);\n      }\n      l++;\n    }\n    while(!dq.empty()){\n      int i = dq.back(); dq.pop_back();\n      if(par[i] != i){\n        siz[par[i]] += siz[i];\n      }\n    }\n  }\n  void hld(int r = 0){\n    cid = 0;\n    chain[r] = cid;\n    pos_seg[r] = 0;\n    head[r] = r;\n\n    stack<int> st;\n    st.push(r);\n\n    while(!st.empty()){\n      int i = st.top(); st.pop();\n      int max_siz = 0;\n      int idx = -1;\n      for(auto &e: edges[i]){\n        if(par[e.to] != i)continue;\n        if(max_siz < siz[e.to]){\n          max_siz = siz[e.to];\n          idx = e.to;\n        }\n      }\n      if(idx == -1)continue;\n      for(auto &e: edges[i]){\n        if(par[e.to] != i)continue;\n        if(idx == e.to){\n          chain[e.to] = chain[i];\n          pos_seg[e.to] = pos_seg[i] + 1;\n          head[e.to] = head[i];\n          st.push(e.to);\n        }else{\n          chain[e.to] = ++cid;\n          pos_seg[e.to] = 0;\n          head[e.to] = e.to;\n          st.push(e.to);\n        }\n      }\n    }\n  }\n  int lca(int u, int v){\n    while(true){\n      if(chain[u] == chain[v]){\n        if(depth[u] < depth[v])return u;\n        else return v;\n      }\n      if(depth[head[u]] > depth[head[v]])swap(u, v);\n      v = par[head[v]];\n    }\n  }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  int n; cin >> n;\n  HeavyLightDecomposition<int> hld(n);\n  rep(i, n){\n    int k; cin >> k;\n    rep(j, k){\n      int u; cin >> u;\n      hld.adde(i, u, 1);\n    }\n  }\n  hld.build();\n  int q; cin >> q;\n  rep(i, q){\n    int u, v; cin >> u >> v;\n    cout << hld.lca(u, v) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.resize(2 * size - 1);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = pii(depth[i], et[i]);\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn pii(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(id[u], id[v] + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n  vector<vector<int> > tree;//, len;\n  \n  HeavyLight(vector<vector<int> >tree)\n    :pathCount(0),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n),tree(tree){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    /*\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\ntypedef vector<vector<int>> Graph;\n//O(Q * logN)\nclass DoublingLCA{\n\tGraph& g;int r;\n\tvector<vector<int> > parent;\n\tvector<int> depth;\npublic:\n\tDoublingLCA(Graph& g,int r):g(g),r(r),parent(msb(g.size())+1,vector<int>(g.size())),depth(vector<int>(g.size())){\n\t\tdfs(-1,r,0);\n\t\tfor(int l:range(1,parent.size()))for(int s:range(parent[l].size()))\n\t\t\tparent[l][s] = (parent[l-1][s]==-1)?-1:parent[l-1][parent[l-1][s]];\n\t}\n\tvoid dfs(int p,int s,int d){\n\t\tparent[0][s]=p;depth[s]=d;\n\t\tfor(int t:g[s])if(t!=p)dfs(s,t,d+1);\n\t}\n\tint lca(int u,int v){\t\n\t\tif(depth[u]>depth[v])swap(u,v);\n\t\tREP(l,parent.size())if((depth[v]-depth[u])&(1<<l)){\t\n\t\t\tv=parent[l][v];\n\t\t}\n\t\tassert(depth[u] == depth[v]);\n\t\tif(u==v) return u;\n\t\tfor(int l=parent.size()-1;l>=0;l--){\n\t\t\tif(parent[l][u]==parent[l][v])continue;\n\t\t\tu=parent[l][u];\n\t\t\tv=parent[l][v];\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t);\n\t\t\t\tg[t].push_back(i);\n\t\t\t}\n\t\t}\n\t\tDoublingLCA lca(g,0);\n\t\tint q;cin >>q;\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tcout << lca.lca(u,v) <<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct LCA{\n  const int lg = 8;\n  const int sz = 1<<lg;\n  const int ms = sz-1;\n  int n;\n  vector<int> P,D,E,A,B,T,ht;\n  vector<vector<int> > G,dat;\n  LCA(int n):\n    n(n),P(n,-1),D(n),E(n*2,0),A(n*2,-1),B(n*2/lg+1),T(sz,0),G(n){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  void dfs(int v,int p,int d,int &k){\n    D[v]=k;\n    A[k]=P[v]=p;\n    E[k++]=d;\n    for(int u:G[v])\n      if(u!=p) dfs(u,v,d+1,k);\n    A[k]=P[v];\n    E[k++]=d-1;\n  }\n\n  inline int comp(int i,int j){return E[i]<E[j]?i:j;};\n  inline int comp(int i,int j,int k){return comp(comp(i,j),k);};\n  \n  void build(int r=0){\n    int k=0;\n    dfs(r,-1,1,k);\n    \n    B[0]=1;\n    for(int i=1;i<n*2;i++) B[i/lg]|=(E[i-1]<E[i])<<(i%lg);\n\n    for(int b=0;b<sz;b++){\n      int e=0,w=1,&x=T[b];\n      for(int i=0;i<lg;i++){\n\tif((b>>i)&1) e++;\n\telse e--;\n\tif(e<w) e=w,x=i;\n      }\n    }\n\n    int m=(n*2+lg-1)/lg;\n    int h=1;\n    while((1<<h)<m) h++;\n    dat.assign(h,vector<int>(m,-1));\n    ht.assign(m+1,0);\n    for(int j=2;j<=m;j++) ht[j]=ht[j>>1]+1;\n    \n    for(int j=0;j<n*2;j++){\n      if(dat[0][j/lg]<0) dat[0][j/lg]=j;\n      dat[0][j/lg]=comp(dat[0][j/lg],j);\n    }\n    \n    for(int i=1,p=1;i<h;i++,p<<=1)\n      for(int j=0;j<m;j++)\n        dat[i][j]=comp(dat[i-1][j],dat[i-1][min(j+p,m-1)]);\n  }\n\n  inline int cs(int a,int b){\n    int l=b-a;\n    return comp(dat[ht[l]][a],dat[ht[l]][b-(1<<ht[l])]);\n  }\n\n  inline int es(int i,int l,int r){\n    int x=r-i*lg+1,y=l-i*lg;\n    int b=(((B[i]|(ms<<x))>>y)|(ms<<(lg-y)))&ms;\n    return l+T[b];\n  }\n  \n  inline int ls(int i,int l){\n    int k=l-i*lg;\n    int b=((B[i]>>k)|(ms<<(lg-k)))&ms;\n    return l+T[b];\n  }\n\n  inline int rs(int j,int r){\n    int k=r-j*lg+1;\n    int b=(B[j]|(ms<<k))&ms;\n    return j*lg+T[b];\n  }\n\n  inline int rmq(int l,int r){\n    int i=l/lg,j=r/lg;\n    if(i==j) return es(i,l,r);\n    if(i+1==j) return comp(ls(i,l),rs(j,r));\n    return comp(ls(i,l),cs(i+1,j),rs(j,r));    \n  }\n  \n  int lca(int l,int r){\n    if(l==r) return l;\n    if(D[l]>D[r]) swap(l,r);\n    int x=D[l],y=D[r];\n    int m=rmq(x,y);\n    return m==x?l:A[m];\n  }\n};\n//END CUT HERE\n\n//INSERT ABOVE HERE\nsigned GRL_5_C(){\n  int n;\n  scanf(\"%d\",&n);\n  LCA lca(n);\n  for(int i=0;i<n;i++){\n    int k,c;\n    scanf(\"%d\",&k);\n    for(int j=0;j<k;j++){\n      scanf(\"%d\",&c);\n      lca.add_edge(i,c);\n    }\n  }\n  \n  lca.build();\n  int q;\n  scanf(\"%d\",&q);\n  for(int i=0;i<q;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    printf(\"%d\\n\",lca.lca(x,y));\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/08/13\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  GRL_5_C();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconst int MAX_N = 200001;\n\n\nbool used[MAX_N];//used\n\nint D[MAX_N];//union-find (HL分解後にあるnodeとあるnodeが同じHeavyPathに含まれているかどうか)\nint find(int a){return a-D[a]?(D[a]=find(D[a])):a; }\n\nstruct node{\n  int id;\n  vector<int> to;\n  int h;//深さ\n  bool operator<(const node& n) const{\n    return h < n.h;\n  }\n};\n\nstruct HL_node{\n  int h;\n  vector<int> v;//sortされる\n  int np;//Light-edgeで結ばれた親\n};\n\nnode G[MAX_N];//子への辺をもつ\nHL_node HL[MAX_N];\nint V;//頂点数\n\nint dfs(int id,int h){\n  if( used[id] ) return 0;\n  G[id].h = h;\n  used[id] = true;\n  vector<int> cs; int sum =1;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    cs.push_back(dfs(G[id].to[i],h+1)); sum+=cs.back();\n  }\n  if( sum == 1 ) return sum;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    if( sum/2 <= cs[i] ){\n      D[G[id].to[i]] = find(id); break;\n    }\n  }\n  return sum;\n}\n\nvector<int> HeavyLightDecomposition(int root){\n  for(int i=0;i<V;i++) D[i] = i;\n  memset(used,0,sizeof(used));\n  dfs(root,0);\n  sort(G,G+V);\n  vector<int> vs;//after_hl\n  for(int i=0;i<V;i++){\n    HL[find(G[i].id)].v.push_back(G[i].id);\n    vs.push_back( find(G[i].id) );\n  }\n  sort(vs.begin(),vs.end());\n  vs.erase(unique(vs.begin(),vs.end()),vs.end());\n\n  for(int i=0;i<(int)vs.size();i++){\n    for(int j=0;j<(int)HL[vs[i]].v.size();j++){\n      int id = HL[vs[i]].v[j];\n      for(int k=0;k<(int)G[id].to.size();k++){\n        int to = find(G[id].to[k]);\n        if( to == vs[i] ) continue;\n        HL[to].np = id;\n        HL[to].h = HL[vs[i]].h+1;\n      }\n    }\n  }  \n  return vs;\n}\n\n\nint HeavyLightLCA(int a, int b){\n  for(; HL[find(a)].h != HL[find(b)].h ; HL[find(a)].h>HL[find(b)].h?(a=HL[find(a)].np):(b=HL[find(b)].np) );\n  for(; find(a) != find(b) ; a = HL[find(a)].np, b = HL[find(b)].np);\n  return G[a].h<G[b].h?a:b;\n}\n\nint main(){\n  cin >> V;\n  for(int i=0;i<V;i++){\n    G[i].id = i;\n    int k; cin >> k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin >> c;\n      G[i].to.push_back( c );\n    }\n  }\n  HeavyLightDecomposition(0);\n  int Q;\n  cin >> Q;\n  for(int i=0;i<Q;i++){ \n    int u,v; cin >> u>> v;\n    cout << HeavyLightLCA(u,v) << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\n#include<climits>\n#include<sstream>\nusing namespace std;\n\n#define maxn 200010\nstruct ST{//返回[L,R]区间最小值的索引\n    int n,a[maxn],st[maxn][30];\n    void init(int n,int data[]){\n        int i,j,l,r;\n        for(i=0;i<n;i++) a[i]=data[i];\n        memset(st,0,sizeof st);\n        for(i=0;i<n;i++) st[i][0]=i;\n        for(j=1;(1<<j)<=n;j++)\n            for(i=0;i+(1<<j)-1<n;i++){\n                st[i][j]=a[st[i][j-1]]<a[st[i+(1<<(j-1))][j-1]]?st[i][j-1]:st[i+(1<<(j-1))][j-1];\n        }\n    }\n    int query(int l,int r){\n        int k=(int)(log(r-l+1)/log(2.0));\n        return a[st[l][k]]<a[st[r-(1<<k)+1][k]]?st[l][k]:st[r-(1<<k)+1][k];\n    }\n};\n\nvector<vector<int> > g;\nint h[maxn],dfn[maxn],depth[maxn],low[maxn];\nint cnt=0;\nvoid dfs(int deep,int x){\n    dfn[cnt]=x;depth[cnt++]=deep;\n    for(int i=0;i<g[x].size();i++){\n        int y=g[x][i];\n        if(h[y]==0){\n            h[y]=1;\n            dfs(deep+1,y);\n            dfn[cnt]=x;depth[cnt++]=deep;\n        }\n    }\n}\nint n,q;\nST st;\nint main(){\n\n    int i,j,k,x,l,r;\n    cin>>n;\n    for(i=0;i<n;i++){//占位\n        vector<int> tmp;\n        g.push_back(tmp);\n    }\n    for(i=0;i<n;i++){\n        cin>>k;\n        for(j=0;j<k;j++){\n            cin>>x;\n            g[i].push_back(x);\n        }\n    }\n    memset(h,0,sizeof h);\n    memset(dfn,0,sizeof dfn);\n    memset(depth,0,sizeof depth);\n    memset(low,-1,sizeof low);\n    dfs(0,0);\n    for(i=0;i<2*n;i++)\n        if(low[dfn[i]]==-1)\n            low[dfn[i]]=i;\n\n\n    st.init(2*n-1,depth);\n    cin>>q;\n    for(i=0;i<q;i++){\n        cin>>l>>r;\n        cout<<dfn[st.query(min(low[l],low[r]),max(low[l],low[r]))]<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int  long long\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 11;\nconst int LOG = 25 + 1;\nint dp[N][LOG];\nint depth[N];\nvector<int> g[N];\n\nvoid dfs(int u, int v){\n   dp[u][0] = v;\n   for (int i = 1; i < LOG; i++)\n     dp[u][i] = dp[dp[u][i - 1]][i - 1];\n   for (auto it : g[u]){\n\t   if (it != v){\n\t\t  depth[it] = depth[u] + 1;\n\t\t  dfs(it, u);  \n\t\t }  \n\t }\t\n}\n\nint lca(int u, int v){\n   if (depth[v] < depth[u]) swap(u, v);\n   int delta = depth[v] - depth[u];\n   for (int i = 0; i < LOG; i++)\n     if ((delta >> i) & 1)\n       v = dp[v][i];\n   if (u == v) return u;\n   for (int i = LOG - 1; i >= 0; i--){\n\t  if (dp[u][i] != dp[v][i])\n\t     u = dp[u][i], v = dp[v][i];  \n\t }\n   return dp[u][0];\t\n}\n\nvoid solve(){\n   int n, q;\n   cin >> n;\n   for (int i = 0; i < n; i++){\n\t    int idx;\n\t    cin >> idx;\n\t    while (idx--){\n\t\t  int val;\n\t\t  cin >> val;\n\t\t  g[i].push_back(val);\t\n\t\t  g[val].push_back(i);\n\t   } \n\t}\n\tdfs(0, 0);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++){\n\t   int l, r;\n\t   cin >> l >> r;\n\t   int ret = lca(l, r);\n\t   cout << ret << endl;\t\n\t}\t\n}\n\nint32_t main(){\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n     solve();\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint n;\nvvi g;\nvector<bool> is_root;\nint root;\n\nint MAX_LOG_V = 40;\nvi depth;\nvvi par;\n\nvoid lca_dfs(int u, int prev, int d) {\n  depth[u] = d;\n  par[u][0] = prev;\n  for (int v : g[u]) {\n    if (v == prev) {\n      continue;\n    }\n    lca_dfs(v, u, d+1);\n  }\n}\n\nvoid lca_init() {\n  lca_dfs(root, -1, 0);\n  rep (k, MAX_LOG_V - 1) {\n    rep (i, n) {\n      if (par[i][k] < 0) {\n        continue;\n      } else {\n        par[i][k+1] = par[par[i][k]][k];\n      }\n    }\n  }\n}\n\nint lca(int u, int v) {\n  if (depth[u] > depth[v]) {\n    swap(u, v);\n  }\n  rep (k, MAX_LOG_V) {\n    if ((((depth[v] - depth[u]) >> k) & 1) == 1) {\n      v = par[v][k];\n    }\n  }\n  if (u == v) { return u; }\n  for (int k = MAX_LOG_V - 1; k >= 0; --k) {\n    if (par[u][k] != par[v][k]) {\n      u = par[u][k];\n      v = par[v][k];\n    }\n  }\n  return par[u][0];\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  g.resize(n);\n  is_root.assign(n, true);\n  rep (i, n) {\n    int k;\n    scanf(\"%d\", &k);\n    int c;\n    rep (j, k) {\n      scanf(\"%d\", &c);\n      g[i].push_back(c);\n      g[c].push_back(i);\n      is_root[c] = false;\n    }\n  }\n  root = -1;\n  rep (i, n) {\n    if (is_root[i]) {\n      root = i;\n    }\n  }\n  depth.assign(n, 0);\n  par.assign(n, vi(MAX_LOG_V, -1));\n  lca_init();\n\n  int q;\n  scanf(\"%d\", &q);\n  rep (query, q) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", lca(u, v));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define all(a) (a).begin(), (a).end()\n#define bit32(x) (1 << (x))\n#define bit64(x) (1ll << (x))\n#define sz(v) ((int) v.size())\n\nusing namespace std;\n\nusing i64 = long long;\nusing f80 = long double;\nusing vi32 = vector<int>;\nusing vi64 = vector<i64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\nvoid yes() { cout << \"Yes\" << endl; exit(0); }\nvoid no() { cout << \"No\" << endl; exit(0); }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> void amax(T &x, T y) { x = max(x, y); }\ntemplate <typename T> void amin(T &x, T y) { x = min(x, y); }\ntemplate <typename T> T exp(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { for (auto &x : v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\n\nconst int INF = 1001001001;\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {1, 0, -1, 0};\n\nstruct LowestCommonAncestor {\n  vector<vector<int>> g;\n  int n;\n  int l = 0;\n  vector<vector<int>> par;\n  vector<int> dep;\n  LowestCommonAncestor(int n) : n(n), g(n), dep(n) {\n    while ((1 << l) < n) l++;\n    par.assign(n + 1, vector<int>(l, n));\n  }\n  void add_edge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  void build(int root = 0) {\n    auto dfs = [&](auto dfs, int u, int p, int d) -> void {\n      if (p != -1) par[u][0] = p;\n      dep[u] = d;\n      for (auto v : g[u]) if (v != p) {\n        dfs(dfs, v, u, d + 1);\n      }\n    };\n    dfs(dfs, root, -1, 0);\n    for (int i = 0; i < l - 1; i++) {\n      for (int u = 0; u < n; u++) {\n        par[u][i + 1] = par[par[u][i]][i];\n      }\n    }\n  }\n  int operator()(int u, int v) {\n    if (dep[u] < dep[v]) swap(u, v);\n    int gap = dep[u] - dep[v];\n    for (int i = l - 1; i >= 0; i--) {\n      if ((1 << i) & gap) u = par[u][i];\n    }\n    if (u == v) return u;\n    for (int i = l - 1; i >= 0; i--) {\n      int pv = par[u][i];\n      int pu = par[v][i];\n      if (pv != pu) u = pv, v = pu;\n    }\n    return par[u][0];\n  }\n  int dist(int u, int v) {\n    int a = (*this)(u, v);\n    return dep[u] + dep[v] - dep[a] * 2;\n  }\n};\n\nvoid solve() {\n  int n;\n  cin >> n;\n  LowestCommonAncestor lca(n);\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      int v;\n      cin >> v;\n      lca.add_edge(i, v);\n    }\n  }\n  lca.build();\n  int q;\n  cin >> q;\n  rep(i, q) {\n    int a, b;\n    cin >> a >> b;\n    cout << lca(a, b) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\tif (W == 0) { cout << \"0\" << endl; continue; }\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int MAXN = 100005;\n\nint path[MAXN << 1], depth[MAXN << 1], idx[MAXN];  // idx: index of node in dfs path\nvi adjList[MAXN];\n\nclass SparseTable {\t // return index of minimum number\nprivate:\n    int n, h;\n    vvi t;\n\n    int combine(int l, int r){\n        if (l == -1 || r == -1) return max(l,r);\n        return depth[l] < depth[r] ? l : r;\n    }\npublic:\n    SparseTable(int size){\n        n = size; h = ( n == 1 ? 1 : ceil(log2(n)));\n        t.assign(h, vi());\n\n        t[0].assign(n,0);\n        for (int i = 0; i < n; i++) t[0][i] = i;\n        for (int i = 1; i < h; i++) {\n            t[i].assign(n,0);\n            for (int j = 0; j + (1<<i) <= n; j++){\n                t[i][j] = combine(t[i-1][j],t[i-1][j+(1<<(i-1))]);\n            }\n        }\n    }\n    int query(int l, int r){                            // query in range v[l,r)\n        int p = 31 - __builtin_clz(r-l);\n        return combine(t[p][l],t[p][r-(1<<p)]);\n    }\n};\n\n// build dfs path, depth\nint cnt = 0;\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n    \n    path[cnt] = curr;\n    depth[cnt++] = d;\n    for (int i = 0; i < adjList[curr].size(); i++){\n        dfs(adjList[curr][i],d+1);\n\n        path[cnt] = curr;\n        depth[cnt++] = d;\n    }\n}\nint N, M, Q, v;\n\nint main(){\n\n    scanf(\"%d\",&N);\n    for (int u = 0; u < N; u++){\n        scanf(\"%d\",&M);\n        for (int i = 0; i < M; i++){\n            scanf(\"%d\",&v);\n\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted as 0\n    dfs(0,0);\n    SparseTable st(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v, l, r; i < Q; i++){\n        scanf(\"%d%d\",&u,&v);\n\n        l = idx[u], r = idx[v]; if (l > r) swap(l,r);\n\n        int id = st.query(l,r+1);\n        printf(\"%d\\n\",path[id]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAX_V = 100000;\nconst int MAX_LOG_V = 17;\n\nvector<int> G[MAX_V];\nint root;\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v,int p,int d)\n{\n\tparent[0][v] = p;\n\tdepth[v] = d;\n\tfor(int i = 0;i < G[v].size();i++)\n\t{\n\t\tif(G[v][i] != p)dfs(G[v][i],v,d+1);\n\t}\n}\n\nvoid init(int V)\n{\n\tdfs(root,-1,0);\n\t//cout<<';'<<endl;\n\tfor(int k = 0;k + 1<MAX_LOG_V;k++)\n\t{\n\t\tfor(int v = 0;v < V;v++)\n\t\t{\n\t\t\tif(parent[k][v]<0)parent[k+1][v] = -1;\n\t\t\telse parent[k+1][v] = parent[k][parent[k][v]];\n\t\t}\n\t}\n}\n\nint lca(int u,int v)\n{\n\tif(depth[u]>depth[v])swap(u,v);\n\tfor(int k = 0;k < MAX_LOG_V;k++)\n\t{\n\t\tif((depth[v]-depth[u])>>k&1)\n\t\t{\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\tif(u==v)return u;\n\tfor(int k = MAX_LOG_V-1;k>=0;k--)\n\t{\n\t\tif(parent[k][u]!=parent[k][v])\n\t\t{\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0;i<n;i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 0;j<k;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tG[i].push_back(x);\n\t\t\tG[x].push_back(i);\n\t\t}\n\t}\n\n\tinit(n);\n\tint q;\n\tcin >> q;\n\twhile(q--)\n\t{\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tcout<< lca(l,r)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef VVI Graph;\nGraph G;\nconst int N = 100000;\nconst int LOG_N = 20;\nint depth[N];\nint parent[LOG_N][N];\nvoid dfs(int node ,int p = -1, int d = 0)\n{\n  if(depth[node] >= 0) return;\n  depth[node] = d;\n  parent[0][node] = p;\n  for(int i=0;i<SZ(G[node]);++i)\n\tdfs(G[node][i], node, d+1);\n}\n\nvoid init(int V){\n  fill(depth, depth+N, -1);\n  dfs(0);\n  for(int i=0;i+1<LOG_N;++i){\n\tfor(int v=0;v<V;++v){\n\t  if(parent[i][v] == -1) parent[i+1][v] = -1;\n\t  else parent[i+1][v] = parent[i][parent[i][v]];\n\t}\n  }\n}\n\nint LCA(int u, int v){\n  if(depth[u] > depth[v]) swap(u, v);\n  //depth[u] <= depth[v]\n  for(int i=0;i<LOG_N;++i)\n\tif((depth[v] - depth[u]) >> i & 1)\n\t  v = parent[i][v];\n  if(u == v) return u;\n\n  for(int i=LOG_N-1;i>=0;--i){\n\tif(parent[i][u] != parent[i][v]){\n\t  u = parent[i][u];\n\t  v = parent[i][v];\n\t}\n  }\n  return parent[0][u];\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V; cin >> V;\n  G.assign(V, VI());\n  REP(i,V){\n\tint k; cin >> k;\n\tREP(j,k){\n\t  int c; cin >> c;\n\t  G[i].PB(c);\n\t}\n  }\n  init(V);\n  int Q; cin >> Q;\n  while(Q--){\n\tint u, v; cin >> u >> v;\n\tcout << LCA(u,v) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nint main() {\n   Int n;\n   std::cin >> n;\n   Int m = log2(n) + 1.1;\n   std::vector<std::vector<Int>> xss(m, std::vector<Int>(n,0));\n   std::vector<Int> hs(n);\n   xss[0][0] = 0;\n   hs[0] = 0;\n   rep(i, n) {\n      Int a;\n      std::cin >> a;\n      rep(k, a) {\n         Int c;\n         std::cin >> c;\n         xss[0][c] = i;\n         hs[c] = hs[i] + 1;\n      }\n   }\n   for(Int i = 1; i < m; ++i) {\n      rep(k, n) {\n         xss[i][k] = xss[i-1][xss[i-1][k]];\n      }\n   }\n   Int q;\n   std::cin >> q;\n   rep(i, q) {\n      Int a, b;\n      std::cin >> a >> b;\n      if( hs[a] > hs[b] ) std::swap(a, b);\n      if( hs[a] < hs[b] ) {\n         Int diff = hs[b] - hs[a];\n         rep(k, m) {\n            guard( ( diff & ((Int)1 << k) ) != 0 );\n            b = xss[k][b];\n         }\n      }\n      assert( hs[a] == hs[b] );\n      if( a == b ) {\n         printf(\"%ld\\n\", a);\n         continue;\n      }\n      for(Int k = m - 1; k >= 0; --k) {\n         if( xss[k][a] != xss[k][b] ) {\n            a = xss[k][a];\n            b = xss[k][b];\n         }\n      }\n      assert( xss[0][a] == xss[0][b] );\n      printf(\"%ld\\n\", xss[0][a]);\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nint main() {\n   Int n;\n   std::cin >> n;\n   Int m = log2(n) + 1.1;\n   std::vector<std::vector<Int>> xss(m, std::vector<Int>(n,0));\n   std::vector<Int> hs(n);\n   xss[0][0] = 0;\n   hs[0] = 0;\n   rep(i, n) {\n      Int a;\n      std::cin >> a;\n      rep(k, a) {\n         Int c;\n         std::cin >> c;\n         xss[0][c] = i;\n         hs[c] = hs[i] + 1;\n      }\n   }\n   for(Int i = 1; i < m; ++i) {\n      rep(k, n) {\n         xss[i][k] = xss[i-1][xss[i-1][k]];\n      }\n   }\n   Int q;\n   std::cin >> q;\n   rep(i, q) {\n      Int a, b;\n      std::cin >> a >> b;\n      if( hs[a] > hs[b] ) std::swap(a, b);\n      if( hs[a] < hs[b] ) {\n         Int diff = hs[b] - hs[a];\n         rep(k, m) {\n            guard( ( diff & ((Int)1 << k) ) != 0 );\n            b = xss[k][b];\n         }\n      }\n      assert( hs[a] == hs[b] );\n      for(Int k = m - 1; k >= 0; --k) {\n         if( xss[k][a] != xss[k][b] ) {\n            a = xss[k][a];\n            b = xss[k][b];\n         }\n      }\n      assert( xss[0][a] == xss[0][b] );\n      printf(\"%ld\\n\", xss[0][a]);\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct tree {\n  int n;\n  tree(int n) : n(n) {}\n  vector<int> pos, tour, depth;\n  vector<vector<int>> table;\n  int argmin(int i, int j) { return depth[i] < depth[j] ? i : j; }\n  void rootify(int r, Graph &adj) {\n    pos.resize(n);\n    function<void (int,int,int)> dfs = [&](int u, int p, int d) {\n      pos[u] = depth.size();\n      tour.push_back(u);\n      depth.push_back(d);\n      for (auto &v: adj[u]) {\n        if (v.dst != p) {\n          dfs(v.dst, u, d+1);\n          tour.push_back(u);\n          depth.push_back(d);\n        }\n      }\n    }; dfs(r, r, 0);\n    int logn = sizeof(int)*__CHAR_BIT__-1-__builtin_clz(tour.size()); // log2\n    table.resize(logn+1, vector<int>(tour.size()));\n    iota(table[0].begin(), table[0].end(), 0);\n    for (int h = 0; h < logn; ++h) \n      for (int i = 0; i+(1<<h) < tour.size(); ++i)\n        table[h+1][i] = argmin(table[h][i], table[h][i+(1<<h)]);\n  }\n  int lca(int u, int v) {\n    int i = pos[u], j = pos[v]; if (i > j) swap(i, j);\n    int h = sizeof(int)*__CHAR_BIT__-1-__builtin_clz(j-i); // = log2\n    return i == j ? u : tour[argmin(table[h][i], table[h][j-(1<<h)])];\n  }\n};\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\ttree tr(V);tr.rootify(0,g);\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tprintf(\"%d\\n\",tr.lca(s,t));\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nstruct UnionFind{\n    vector<int> par,rank,ss;\n    int size;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);if(x==y)return;\n        if(rank[x]>rank[y])swap(x,y);\n        par[x] = y;ss[y]+=ss[x];\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\ntypedef vector<vector<int>> Graph;\nclass TarjanLCA{\npublic:\n\tGraph& g; UnionFind uf;\n\t\n\tvector<int> ancestor;vector<bool> passed;\n\n\tTarjanLCA(Graph &g):g(g),uf(UnionFind(g.size())){\n\t\tpassed=vector<bool>(g.size());ancestor=vector<int>(g.size());\n\t};\n\tvoid visit(int p,int s,vector<tuple<int,int,int>> &qs) {\n\t\tancestor[uf.root(s)] = s;\n\t\tfor(int t:g[s]) if(t != p) {\n\t\t\tvisit(s,t,qs);\n\t\t\tuf.unite(s,t);\n\t\t\tancestor[uf.root(s)] = s;\n\t\t}\n\t\tpassed[s] = true;\n\t\tfor(auto& q:qs){\n\t\t\tint w = (get<1>(q) == s ? get<0>(q) : get<0>(q) == s ? get<1>(q) : -1);\n\t\t\tif (w >= 0 && passed[w]){\n\t\t\t\tget<2>(q) = ancestor[uf.root(w)];\n\t\t\t}\n\t\t}\n\t}\n\tvoid leastCommonAncestor(int r,vector<tuple<int,int,int>>& qs){\n\t\tvisit(-1,r,qs);\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t);\n\t\t\t\tg[t].push_back(i);\n\t\t\t}\n\t\t}\n\t\tTarjanLCA lca(g);\n\t\tint q;cin >>q;\n\t\tvector<tuple<int,int,int>> qs(q);\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tqs[i]=make_tuple(u,v,-1);\n\t\t}\n\t\tlca.leastCommonAncestor(0,qs);\n\n\t\tREP(i,q){\n\t\t\tcout << get<2>(qs[i])<<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define MAX_V 10000\n\nvector<int> G[MAX_V];\nvector<int> depth,vs;\nint id[MAX_V]={};\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int a;\n            cin>>a;\n            G[i].pb(a);\n        }\n    }\n    \n    init();\n    segtree<pii> st(depth.size(),pii((1<<31)-1,(1<<31)-1));\n    rep(i,depth.size()){\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int q;\n    cin>>q;\n    rep(i,q){\n        int a,b;\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100000];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nvoid sub(int idx)\n{\n  sz[idx] = query[idx].size();\n  for(auto &to : g[idx]) {\n    sub(to);\n    sz[idx] += query[to].size();\n  }\n}\n\nvoid dfs(int idx, bool keep)\n{\n  int heavy = -1;\n  for(auto &to : g[idx]) {\n    if(heavy == -1 || sz[to] > sz[heavy]) heavy = to;\n  }\n  for(auto &to : g[idx]) {\n    dfs(to, false);\n  }\n  for(int &v : query[idx]) {\n    buf[v] = true;\n  }\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      if(buf[v]++) lca[v] = idx;\n      query[idx].push_back(v);\n    }\n  }\n  if(!keep) for(auto &v : query[idx]) buf[v] = false;\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    query[U].push_back(i);\n    query[V].push_back(i);\n  }\n  memset(lca, -1, sizeof(lca));\n  sub(0);\n  dfs(0, 0);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define FILL(Itr,n) fill((Itr).begin(),(Itr).end(),n)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\ntypedef long long ll;\n#define MOD 1000000007\n\nclass LCA {\nprivate:\n    int n,ln;\n    vector<vector<int> > parent;\n    vector< vector<int> > G;\npublic:\n    vector<int> depth;\n    \n    LCA(int _n) : n(_n), depth(_n){\n        ln=0;\n        while(n>(1<<ln)) ln++;\n        parent = vector<vector<int> >(ln, vector<int>(n));\n        G.resize(_n+10);\n    }\n    \n    void dfs(int v, int p, int d){\n        parent[0][v]=p;\n        depth[v]=d;\n        for(int i=0;i<G[v].size();i++) if(G[v][i]!=p) dfs(G[v][i], v, d+1);\n    }\n    \n    int dist(int a, int b){\n        int par=getParent(a,b);\n        return depth[a]+depth[b]-depth[par]*2;\n    }\n    \n    void init(int root){\n        dfs(root, -1, 0);\n        for(int k=0; k+1<ln; k++){\n            for(int v=0; v<n; v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n    \n    void add_edge(int a, int b){\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    int getParent(int u, int v){\n        if(depth[u] > depth[v]) swap(u,v);\n        for(int k=0; k<ln; k++){\n            if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n        }\n        if(u==v) return u;\n        \n        for(int k=ln-1; k>=0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\n\nint main(){\n    \n    int n; cin>>n;\n    \n    LCA inst(100010);\n    REP(i,n){\n        int k; cin>>k;\n        REP(j,k){\n            int t; cin>>t;\n            inst.add_edge(i,t);\n        }\n    }\n    \n    inst.init(0);\n    \n    int q; cin>>q;\n    REP(i,q){\n        int a,b; cin>>a>>b;\n        cout<<inst.getParent(a,b)<<endl;\n    }\n   \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 500;\nint color[100010], par[100010], depth[100010];\nint depthTop[100010];\nint goUp[100010];\nint vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    vector<int> q(n+1); int l = 0, r = 0;\n    q[r++] = root;\n    vector<int> tord;\n    while(l != r){\n        int v = q[l++];\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(!vis[c]){\n                q[r++] = c;\n                par[c] = v;\n                depth[c] = depth[v] + 1;\n            }\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        l = 0, r = 0;\n        if(vis[u]) continue;\n        q[r++] = u;\n        int k = 0;\n        while(l != r && k < B){\n            int v = q[l++];\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            depthTop[v] = depth[u];\n            k++;\n            for(int c : g[v]){\n                if(!vis[c]) q[r++] = c;\n            }\n        }\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depthTop[u] > depthTop[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\nclass Tree{\nprivate:\n  int n;//number of node\n  int m;//number of edge\n  int root;\n  const int max_log_n = 20;//if n = 10^5, max_log_n = 20.\n  bool flag;// if edge has cost, flag is true.\n  vector<vector<int>> edge;// edge does not have cost.\n  vector<vector<int>> par;//par[v][i] := vertex followed parent at 2^i times from vertex v.\n  vector<int> depth;//depth of the node\n  \n  vector<vector<pair<int,int>>> edge2;// edge has cost.\n  \n  void dfs(int v,int p,int d){//v...current vertex, p...parent of v, d...depth of v\n    par[v][0] = p;\n    depth[v] = d;\n    for(auto w:edge[v]){\n      if(w==p){\n\tcontinue;\n      }\n      dfs(w,v,d+1);\n    }\n  }\n  \n  void fill_table(){// fill parent table\n    rep(i,max_log_n-1){\n      rep(j,n){\n\tif(par[j][i] == -1){\n\t  par[j][i+1] = -1;\n\t}\n\telse{\n\t  par[j][i+1] = par[par[j][i]][i];\n\t}\n      }\n    }\n  }\n  \npublic:\n  //*****Constructor************\n  Tree(int n_){\n    n = n_;\n    edge.resize(n);\n  }\n\n  Tree(int n_,int m_,vector<int> a,vector<int> b){\n    flag = false;\n    n = n_;\n    m = m_;\n    edge.resize(n);\n    rep(i,m){\n      edge[a[i]].push_back(b[i]);\n      edge[b[i]].push_back(a[i]);\n    }\n  }\n\n  Tree(int n_,int m_,vector<int> a,vector<int> b,vector<int> c){\n    flag = true;\n    n = n_;\n    m = m_;\n    edge2.resize(n);\n    rep(i,m){\n      edge2[a[i]].push_back(make_pair(b[i],c[i]));\n      edge2[b[i]].push_back(make_pair(a[i],c[i]));\n    }\n  }  \n  //***************************\n\n  void add_edge(int from,int to){\n    edge[from].push_back(to);\n    edge[to].push_back(from);\n  }\n\n  //***************************\n  void init(){//initialize parent table and vector of depth\n    root = 0;\n    par.resize(n,vector<int>(max_log_n));\n    depth.resize(n);\n    dfs(root,-1,0);\n    fill_table();\n  }\n\n  int lca(int u,int v){//Lowest Common Ancestor of u and v\n    if(depth[u]>depth[v]) swap(u,v);\n    for(int i=max_log_n-1;i>=0;--i){\n      if( ((depth[v]-depth[u])>>i)&1 ){\n\tv = par[v][i];\n      }\n    }\n    if(u==v){\n      return u;\n    }\n\n    for(int i=max_log_n-1;i>=0;--i){\n      if(par[u][i]!=par[v][i]){\n\tu = par[u][i];\n\tv = par[v][i];\n      }\n    }\n    return par[u][0];\n  }\n\n  int distance(int u,int v){//shortest distance of u and v\n    int w = lca(u,v);\n    return depth[u]+depth[v]-depth[w]*2;\n  }\n\n  vector<int> get_pass(int u,int v){\n    int w = lca(u,v);\n    vector<int> res;\n    int x = depth[u]-depth[w];\n    int y = depth[v]-depth[w];\n    rep(i,x){\n      res.push_back(u);\n      u = par[u][0];\n    }\n    res.push_back(w);\n    vector<int> rev;\n    rep(i,y){\n      rev.push_back(v);\n      v = par[v][0];\n    }\n    for(int i=rev.size()-1;i>=0;--i){\n      res.push_back(rev[i]);\n    }\n    return res;\n  }\n  \n  //*********debag_function**************\n  void show_depth(){\n    rep(i,n){\n      cout << i << \":\" << depth[i] << \"\\n\";\n    }\n  }\n\n  void show_parent(){\n    rep(i,n){\n      cout << i << \":\" << par[i][0] << \"\\n\";\n    }\n  }\n\n  void show_pass(int u,int v){\n    vector<int> pass = get_pass(u,v);\n    rep(i,pass.size()){\n      cout << pass[i] << \"\\n\";\n    }\n  }\n  \n  //***************************************  \n};\n\n\n\nint main()\n{\n  int n;\n  cin >> n;\n  Tree tr(n);\n  rep(i,n){\n    int m;\n    cin >> m;\n    rep(j,m){\n      int k;\n      cin >> k;\n      tr.add_edge(i,k);\n    }\n  }\n  tr.init();\n  int q;\n  cin >> q;\n  vector<int> u(q),v(q);\n  rep(i,q){\n    cin >> u[i] >> v[i];\n  }\n\n  rep(i,q){\n    cout << tr.lca(u[i],v[i]) << \"\\n\";\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\nusing namespace std;\n\n#define MAX_N (100000)\nvector<int> g[MAX_N];\nint root,n;\nint par[17][MAX_N];//log_2(MAX_N)\nint depth[MAX_N];\nvoid dfs(int v,int p,int dep){\n    par[0][v]=p;\n    depth[v]=dep;\n    for(int i=0;i<g[v].size();++i){\n        if(g[v][i]!=p){\n            dfs(g[v][i],v,dep+1);\n    }\n  }\n}\nvoid lca_init(int n){\n    dfs(root,-1,0);\n    for(int k=0;k+1<17;++k){\n        for(int i=0;i<n;++i){\n            if(par[k][i]<0) par[k+1][i]=-1;\n            else par[k+1][i]=par[k][par[k][i]];\n        }\n    }\n}\nint lca(int a,int b){\n    if(depth[a]>depth[b]) swap(a,b);\n    for(int k=0;k<17;++k){\n        if((depth[b]-depth[a]) >> k & 1){\n            b=par[k][b];\n        }\n    }\n    if(a==b) return a;\n    for(int k=16;k>=0;--k){\n        if(par[k][a] !=par[k][b]){\n            a=par[k][a];\n            b=par[k][b];\n        }\n    }\n    return par[0][a];\n}\n\nint main(){\n    cin>>n;\n    root=0;\n    int k,c,q,u,v;\n    rep(i,n){\n        cin>>k;\n        while(k--){\n            cin>>c;\n            g[i].pb(c);\n        }\n    }\n    lca_init(n);\n    cin>>q;\n    rep(i,q){\n        cin>>u>>v;\n        cout<<lca(u,v)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\nconst int LOG_N = 17;\n\nvector<int> G[MAX_N];\n\nint par[LOG_N][MAX_N];\nint depth[MAX_N];\n\nvoid dfs(int u,int p,int d)\n{\n    par[0][u] = p;\n    depth[u] = d;\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            dfs(G[u][i],u,d+1);\n        }\n    }\n}\n\nint lca(int u,int v)\n{\n    if(depth[u] > depth[v]){\n        swap(u,v);\n    }\n    rep(i,LOG_N){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = par[i][v];\n        }\n    }\n    if(u == v){\n        return u;\n    }\n    for(int i=LOG_N-1;i>=0;i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,-1,0);\n    rep(i,LOG_N-1){\n        rep(j,n){\n            if(par[i][j] < 0){\n                par[i+1][j] = -1;\n            }else{\n                par[i+1][j] = par[i][par[i][j]];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        printf(\"%d\\n\",lca(x,y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define numa(x,a) for(auto x: a)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define pf push_front\n#define sec second\n#define sz(x) ((int)(x).size())\n#define ALL( c ) (c).begin(), (c).end()\n#define gcd(a,b) __gcd(a,b)\n#define endl \"\\n\"\nusing namespace std;\ntemplate <int POS, class TUPLE> void deploy(std::ostream &os, const TUPLE &tuple){}\ntemplate <int POS, class TUPLE, class H, class ...Ts> void deploy(std::ostream &os, const TUPLE &t){ os << (POS == 0 ? \"\" : \", \") << get<POS>(t); deploy<POS + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> &mp){ int remain = mp.size(); os << \"{\"; for(auto e: mp) os << \"(\" << e.first << \" -> \" << e.second << \")\" << (--remain == 0 ? \"}\" : \", \"); return os; }\n#define DEBUG1(var0) { std::cerr << (#var0) << \"=\" << (var0) << endl; }\n#define DEBUG2(var0, var1) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG1(var1); }\n#define DEBUG3(var0, var1, var2) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG2(var1,var2); }\n#define DEBUG4(var0, var1, var2, var3) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG3(var1,var2,var3); }\ntypedef long long ll;\n\n#define MAX_V 100100\n//*********************************\n//一度のクエリ処理だけならO(n)のLCA\nvector <int> edge[MAX_V];\nint root;\nint parent[MAX_V];\nint depth[MAX_V];\nint V;\nvoid dfs(int v,int p,int d){\n  parent[v] = p;\n  depth[v] = d;\n  for(int i = 0;i < sz(edge[v]);i++){\n    if(edge[v][i] != p){\n      dfs(edge[v][i],v,d+1);\n    }\n  }\n}\n\nvoid init(){\n  //parentとdepthを初期化\n  dfs(root,-1,0);\n}\n\nint LCA(int u,int v){//uとvのLCAを求める\n  while(depth[u] > depth[v]){\n    u = parent[u];\n  }\n  while(depth[v] > depth[u]){\n    v = parent[v];\n  }\n  while(u != v){\n    u = parent[u];\n    v = parent[v];\n  }\n  return u;\n}\n//*********************************\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cin >> V;\n  rep(i,V){\n    int x;\n    cin >> x;\n    rep(j,x){\n      int y;\n      cin >> y;\n      edge[i].pb(y);\n    }\n  }\n  init();\n  int Q;\n  cin >> Q;\n  rep(i,Q){\n    int x,y;\n    cin >> x >> y;\n    cout << LCA(x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, stop) FOR(i, 0, stop)\n#define FOR(i, start, stop) for (int i = start, i##_len = stop; i < i##_len; ++i)\n\nstruct InitCpp { InitCpp() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(10); } } initCpp;\n\ntemplate<typename G> class LCA { private: int n; int l; std::vector<std::vector<int>> P; std::vector<int> D; void dfs(const G &g, int v, int p, int d) { P[0][v] = p; D[v] = d; for (auto &to : g[v]) { if (to != p) dfs(g, to, v, d + 1); } } public: LCA(const G &g): n(g.size()), l(log2(n) + 1), P(l, std::vector<int>(n)), D(n) { dfs(g, 0, -1, 0); for (int k = 0; k + 1 < l; ++k) { for (int v = 0; v < g.size(); ++v) { if (P[k][v] < 0) P[k + 1][v] = -1; else P[k + 1][v] = P[k][P[k][v]]; } } } int query(int u, int v) { if (D[u] > D[v]) std::swap(u, v); for (int k = 0; k < l; ++k) { if ((D[v] - D[u]) >> k & 1) { v = P[k][v]; } } if (u == v) return u; for (int k = l - 1; k >= 0; --k) { if (P[k][u] != P[k][v]) { u = P[k][u]; v = P[k][v]; } } return P[0][u]; } };\n\nusing Graph = vector<vector<int>>;\nsigned main() {\n  int n;\n  cin >> n;\n  Graph G(n);\n  REP(i, n) {\n    int k;\n    cin >> k;\n    REP(_, k) {\n      int c;\n      cin >> c;\n      G[i].push_back(c);\n    }\n  }\n  LCA<Graph> lca(G);\n  int q;\n  cin >> q;\n  REP(_, q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.query(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nvector<int> chi[100000];\nint fir[100000], dep = 0;\nvector< pair<int, int> > et; //Euler Tour\n\nint min(int a, int b) {\n  return a < b ? a : b;\n}\n\nvoid dfs(int a) {\n   int i;\n   if(fir[a] == -1) fir[a] = et.size();\n   et.push_back(make_pair(a, dep));\n   for(i = 0; i < chi[a].size(); ++i) {\n     dep++;\n     dfs(chi[a][i]);\n     dep--;\n     et.push_back(make_pair(a, dep));\n   }\n}\n\nint main(void) {\n  int i, j, k, n, c, now, q, u, v;\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; ++i) fir[i] = -1;\n  for(i = 0; i < n; ++i) {\n    scanf(\"%d\", &k);\n    for(j = 0; j < k; ++j) {\n       scanf(\"%d\", &c);\n       chi[i].push_back(c);\n    }\n  }\n  dfs(0);\n  /*for(i = 0; i < et.size(); ++i) printf(\"%d %d\\n\", et[i].first, et[i].second);\n  return 0;*/\n  int sm = 1;\n  while(sm < et.size()) sm *= 2;\n  pair<int, int> seg[sm * 2];\n  int las[sm * 2];\n  for(i = sm; i < sm * 2; ++i) {\n    if(i < sm + et.size()) seg[i].first = et[i - sm].second, seg[i].second = et[i - sm].first;\n    else seg[i] = make_pair(1000000, 1000000);\n    if(i % 2) {\n      now = i / 2;\n      while(now) seg[now] = min(seg[now * 2], seg[now * 2 + 1]), now /= 2;\n    }\n  }\n  now = 1;\n  for(i = 1; i < sm * 2; ++i) {\n    if(now * 2 == i) now *= 2;\n    las[i] = (sm / now) * (i - now + 1) - 1;\n  }\n  scanf(\"%d\", &q);\n  for(i = 0; i < q; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    now = sm + fir[u];\n    pair<int, int> min = make_pair(1000000, 1000000);\n    while( 1 ) {\n      while(!(now % 2)) now /= 2;\n      while(las[now] > fir[v]) now *= 2;\n      if(min > seg[now]) min = seg[now];\n      if(las[now] == fir[v]) break;\n      now++;\n    }\n    printf(\"%d\\n\", min.second);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\ntemplate <class T, class S>\nT log_int(T x, S y) {\n    T ret = 0, tmp = y;\n    while (tmp <= x) {\n        tmp *= (T)y;\n        ret++;\n    }\n    return ret;\n}\n\nstruct LCA {\n    int root, n, nlog2;\n    vector<int> d;\n    vector<vector<int>> tree, parent;\n    LCA(vector<vector<int>>& t1, int t2) {\n        tree = t1;\n        root = t2, n = (int)tree.size();\n        nlog2 = log2(n);\n        d.assign(n, -1);\n        d[root] = 0;\n        int cnt = 0;\n        vector<int> q(1, root), qq;\n        while (q.size()) {\n            cnt++;\n            qq = {};\n            while (q.size()) {\n                int u = q.back();\n                q.pop_back();\n                for (int v : tree[u]) {\n                    if (d[v] == -1) {\n                        d[v] = cnt;\n                        qq.push_back(v);\n                    }\n                }\n            }\n            q = qq;\n        }\n        parent.assign(n, {});\n        for (int u = 0; u < n; u++) {\n            bool flag = true;\n            for (int v : tree[u]) {\n                if (d[u] > d[v]) {\n                    parent[u].push_back(v);\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) { parent[u].push_back(-1); }\n        }\n        for (int c = 0; c < nlog2; c++) {\n            for (int u = 0; u < n; u++) {\n                if (parent[u].back() == -1) {\n                    parent[u].push_back(-1);\n                } else {\n                    parent[u].push_back(parent[parent[u].back()][c]);\n                }\n            }\n        }\n    }\n\n    int log2(int x) {\n        int ret = 0, tmp = 2;\n        while (tmp <= x) {\n            tmp *= 2;\n            ret++;\n        }\n        return ret;\n    }\n\n    int lca(int a, int b) {\n        if (d[a] < d[b]) { swap(a, b); }\n        int rest = d[a] - d[b], rest_log;\n        while (rest > 0) {\n            rest_log = log2(rest);\n            a = parent[a][rest_log];\n            rest = rest - (int)pow(2, rest_log);\n        }\n        int i = nlog2;\n        while (i >= 0) {\n            if (parent[a][i] == parent[b][i]) {\n                i--;\n            } else {\n                a = parent[a][i];\n                b = parent[b][i];\n            }\n        }\n        if (a == b) {\n            return a;\n        } else {\n            return parent[a][0];\n        }\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int n, x, k, q;\n    INPUT(n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            cin >> x;\n            g[i].push_back(x);\n            g[x].push_back(i);\n        }\n    }\n    LCA lca(g, 0);\n    INPUT(q);\n    REP(i, q) {\n        INPUT(x, k);\n        PRINT(lca.lca(x, k));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n\n    vector<vector<int>> parent_pow2;\n\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n\n    int lca(int u,int v){\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            graph[i].push_back(c);\n        }\n    }\n    show(\"BBBBBB\");\n    lca_solver ls(graph,0);\n    show(\"AAAAAAA\");\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int u,v;\n        cin >> u >> v;\n        cout << ls.lca(u,v) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <unordered_map>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * RmQ\n * sparse table 使用\n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Hash=hash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=hash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=hash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=hash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T>\nauto reserve_vec(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename Hash=hash<T>, typename Eq=equal_to<T>>\nauto reserve_hash_set(i64 cap, f32 load_max=0.25) {\n    HashSet<T,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename K, typename V, typename Hash=hash<K>, typename Eq=equal_to<K>>\nauto reserve_hash_map(i64 cap, f32 load_max=0.25) {\n    HashMap<K,V,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename Hash=hash<T>, typename Eq=equal_to<T>>\nauto reserve_hash_multiset(i64 cap, f32 load_max=0.25) {\n    HashMultiset<T,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename K, typename V, typename Hash=hash<K>, typename Eq=equal_to<K>>\nauto reserve_hash_multimap(i64 cap, f32 load_max=0.25) {\n    HashMultimap<K,V,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = reserve_vec<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = reserve_vec<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    return Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = \";\n    dbg_write(cerr, make_tuple(value...));\n    cerr << \"\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 P>\nstruct ModPT {\n    static_assert(P >= 2, \"P must be a prime\");\n    i64 v_;  // [0,P)\n\n    ModPT() : v_(0) {}\n    ModPT(i64 v) {\n        i64 r = v % P;\n        v_ = r >= 0 ? r : r+P;\n    }\n\n    ModPT operator-() const {\n        return ModPT(-v_);\n    }\n    ModPT& operator+=(ModPT rhs) {\n        v_ += rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator-=(ModPT rhs) {\n        v_ += P;\n        v_ -= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator*=(ModPT rhs) {\n        v_ *= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n\n    ModPT& operator++() {\n        return *this += 1;\n    }\n    ModPT& operator--() {\n        return *this -= 1;\n    }\n    ModPT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModPT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n};\n\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) += lhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) -= lhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) *= lhs; }\n\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, ModPT<P> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, i64 rhs) { return lhs == ModPT<P>(rhs); }\ntemplate<i64 P>\nbool operator==(i64 lhs, ModPT<P> rhs) { return ModPT<P>(lhs) == rhs; }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, ModPT<P> rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(i64 lhs, ModPT<P> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 P>\nstruct Scan<ModPT<P>> {\n    static ModPT<P> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 P>\nstruct Fmt<ModPT<P>> {\n    static void fmt(ostream& out, ModPT<P> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 P>\nstruct Dbg<ModPT<P>> {\n    static void dbg(ostream& out, ModPT<P> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModP = ModPT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cin.exceptions(ios::failbit | ios::badbit);\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ni64 log2_ceil(i64 x) {\n    ASSERT(x > 0);\n    return x == 1 ? 63 : 64-__builtin_clzll(x-1);\n}\n\ni64 log2_floor(i64 x) {\n    ASSERT(x > 0);\n    return 63 - __builtin_clzll(x);\n}\n\nvoid solve() {\n    i64 N = RD();\n\n    vector<vector<i64>> children(N);\n    REP(v, N) {\n        i64 k = RD();\n        children[v] = RD_VEC(k);\n    }\n    DBG(children);\n\n    // オイラーツアー\n    // 値は (depth,v)\n    // N-1 本の辺を 2 回ずつ辿るので、頂点数は根と合わせて 2*N-1\n    auto dat = reserve_vec<pair<i64,i64>>(2*N-1);\n    vector<i64> indices(N);  // v が最初に dat に現れるインデックス\n    {\n        i64 idx = 0;\n        auto dfs = FIX([&children,&dat,&indices,&idx](auto&& self, i64 v, i64 depth) -> void {\n            dat.emplace_back(depth, v);\n            indices[v] = idx++;\n            for(auto child : children[v]) {\n                self(child, depth+1);\n                dat.emplace_back(depth, v);\n                ++idx;\n            }\n        });\n        dfs(0, 0);\n    }\n    DBG(dat);\n    DBG(indices);\n    ASSERT(SIZE(dat) == 2*N-1);\n\n    // sparse table\n    // 2ベキに拡張しなくても大丈夫なはず\n    i64 log2_max = log2_ceil(SIZE(dat));\n    auto table = vec_make<pair<i64,i64>>(log2_max+1, SIZE(dat), make_pair(INF,INF));\n    table[0] = dat;\n    FOR(i, 1, log2_max+1) {\n        REP(j, SIZE(dat)-(1LL<<i)+1) {\n            table[i][j] = min(table[i-1][j], table[i-1][j+(1LL<<(i-1))]);\n        }\n    }\n    DBG(table);\n\n    auto rmq = [&table](i64 l, i64 r) {\n        i64 k = log2_floor(r-l);\n        return min(table[k][l], table[k][r-(1LL<<k)]);\n    };\n\n    i64 Q = RD();\n    REP(_, Q) {\n        i64 s = RD();\n        i64 t = RD();\n        if(s == t) {\n            PRINTLN(s);\n            continue;\n        }\n\n        i64 is = indices[s];\n        i64 it = indices[t];\n        if(is > it) swap(is, it);\n        i64 ans = rmq(is, it).second;\n\n        PRINTLN(ans);\n    }\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<unordered_map>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF ((1<<30)-1)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n\n\nclass LCA {\npublic:\n\tLCA(int n, const vector<int> edge[], int root = 0): edge(edge), size(n), depth(n), heavy(n), prev(n) {\n\t\tdepth[root] = 0;\n\t\tdfs_sz(root);\n\t\tn_heavy = 0;\n\t\tdfs_hld(root, n_heavy++, -1);\n\t}\n\tint query(int u, int v) const {\n\t\twhile (heavy[u] != heavy[v]) {\n\t\t\tif (prev[u] == -1 || prev[v] != -1 && depth[prev[u]] < depth[prev[v]]) {\n\t\t\t\tv = prev[v];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tu = prev[u];\n\t\t\t}\n\t\t}\n\t\treturn depth[u] < depth[v] ? u : v;\n\t}\nprivate:\n\tvoid dfs_sz(int u) {\n\t\tsize[u] = 1;\n\t\tfor (int v : edge[u]) {\n\t\t\tdepth[v] = depth[u] + 1;\n\t\t\tdfs_sz(v);\n\t\t\tsize[u] += size[v];\n\t\t}\n\t}\n\tvoid dfs_hld(int u, int h, int p) {\n\t\tprev[u] = p;\n\t\theavy[u] = h;\n\t\tint ma = 0;\n\t\tfor (int v : edge[u]) {\n\t\t\tma = max(ma, size[v]);\n\t\t}\n\t\tfor (int v : edge[u]) {\n\t\t\tif (ma == size[v]) {\n\t\t\t\tdfs_hld(v, h, p);\n\t\t\t\tma = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdfs_hld(v, n_heavy++, u);\n\t\t\t}\n\t\t}\n\t}\n\tconst vector<int>* edge;\n\tvector<int> depth;\n\tvector<int> size;\n\tint n_heavy;\n\tvector<int> heavy, prev;\n};\n\n\nvector<int> edge[100000];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k, v;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tcin >> v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(n, edge, 0);\n\tint q, u, v;\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> u >> v;\n\t\tcout << lca.query(u, v) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vii> vvii;\ntypedef vector<int>::iterator vit;\n\nconst int MAXN = 100005;\n\nint idx[MAXN];          // i : index of node i in dfs path\nii path[MAXN << 1];\nvi adjList[MAXN];\n\nclass SparseTable {\t    // return index of minimum number\nprivate:\n    int n, h;\n    vvii t;\npublic:\n    SparseTable(int size){\n        n = size; h = ( n == 1 ? 1 : ceil(log2(n)));\n        t.assign(h, vii());\n\n        t[0].assign(n,ii(0,0));\n        for (int i = 0; i < n; i++) t[0][i] = path[i];\n        for (int i = 1, j = 0; i < h; i++, j = 0)\n            for (t[i].assign(n,ii(0,0)); j + (1<<i) <= n; j++)\n                t[i][j] = min(t[i-1][j],t[i-1][j+(1<<(i-1))]);\n    }\n    int query(int l, int r){      // query in range v[l,r)\n        int p = 31 - __builtin_clz(r-l);\n        return min(t[p][l],t[p][r-(1<<p)]).se;\n    }\n};\n\n// build dfs path, depth\nint cnt = 0;\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n\n    path[cnt++] = ii(d,curr);\n    for (vit it = adjList[curr].begin(); it != adjList[curr].end(); it++) {\n        dfs(*it,d+1);\n\n        path[cnt++] = ii(d,curr);\n    }\n}\n\nint N, M, Q, v;\n\nint main(){\n\n    scanf(\"%d\",&N);\n    for (int u = 0; u < N; u++){\n        scanf(\"%d\",&M);\n        for (int i = 0; i < M; i++){\n            scanf(\"%d\",&v);\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted as 0\n    dfs(0,0);\n    SparseTable st(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v, l, r; i < Q; i++){\n        scanf(\"%d%d\",&u,&v);\n\n        l = idx[u], r = idx[v]; if (l > r) swap(l,r);\n\n        printf(\"%d\\n\",st.query(l,r+1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint N, root;\nvector<int> g[101010];\nint depth[101010];\nint par[101010][30];\n\n//木の深さを求める\nvoid dfs(int v, int p, int d) {\n\tpar[v][0] = p;\n\tdepth[v] = d;\n\tfor (int i = 0; i<g[v].size(); i++) {\n\t\tif (g[v][i] == p)continue;\n\t\tdfs(g[v][i], v, d + 1);\n\t}\n}\n\n//par[v][i]:=頂点vから2^i回親をたどった頂点（無かったら-1）\n//vの親→par[v][0],vの親の親par[v][1]\n//par[v][i+1]=par[par[v][i]]よりpar[~][i]が計算できればpar[~][i+1]も求まる\nvoid fill_table() {\n\tfor (int i = 0; i<19; i++) {\n\t\tfor (int j = 0; j<N; j++) {\n\t\t\tif (par[j][i] == -1)par[j][i + 1] = -1;\n\t\t\telse par[j][i + 1] = par[par[j][i]][i];\n\t\t}\n\t}\n}\n\n\n//頂点u,vのLCAを求める\nint lca(int u, int v) {\n\n\tif (depth[u]>depth[v])swap(u, v);\n\t//深さをそろえるための処理\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (((depth[v] - depth[u]) >> i) & 1) {\n\t\t\tv = par[v][i];\n\t\t}\n\t}\n\n\tif (u == v)return u;\n\t//ダブリング\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (par[u][i] != par[v][i]) {\n\t\t\tu = par[u][i];\n\t\t\tv = par[v][i];\n\t\t}\n\t}\n\treturn par[u][0];\n}\n\n\nint main() {\n\tcin >> N;\n\tREP(i, N) {\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tg[i].emplace_back(c);\n\t\t\tg[c].emplace_back(i);\n\t\t}\n\t}\n\tdfs(root, -1, 0);\n\tfill_table();\n\n\tint q;\n\tcin >> q;\n\tREP(i, q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca(u, v) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nconstexpr long long INF = 1LL << 60;\nconstexpr long long MOD = 1000000007;\ndouble PI = acos(-1.0);\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define rep1(i, n) for (ll i = 1; i <= (n); ++i)\n#define rrep(i, n) for (ll i = (n - 1); i >= 0; --i)\n#define perm(c) sort(ALL(c));for(bool c##p=1;c##p;c##p=next_permutation(ALL(c)))\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define pb push_back\n#define to_s to_string\n#define len(v) (ll)v.size()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define print(x) cout << (x) << '\\n'\n#define drop(x) cout << (x) << '\\n', exit(0)\n#define debug(x) cout << #x << \": \" << (x) << '\\n'\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> tpl;\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> vec2;\ntypedef vector<vector<vector<ll>>> vec3;\ntemplate<class S, class T> inline bool chmax(S &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class S, class T> inline bool chmin(S &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline ll msb(ll v) { return 1 << (31 - __builtin_clzll(v)); }\ninline ll devc(ll x, ll y) { return (x + y - 1) / y; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a * (b / gcd(a, b)); }\n \nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n        cerr << fixed << setprecision(10);\n    }\n} iosetup;\n \ntemplate< typename T1, typename T2 >\nostream &operator << (ostream &os, const pair< T1, T2 > &p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\n \ntemplate< typename T1, typename T2 >\nistream &operator >> (istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nostream &operator << (ostream &os, const tuple< T1, T2, T3 > &t) {\n    os << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t);\n    return os;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nistream &operator >> (istream &is, tuple< T1, T2, T3 > &t) {\n    is >> get<0>(t) >> get<1>(t) >> get<2>(t);\n    return is;\n}\n \ntemplate< typename T >\nostream &operator << (ostream &os, const vector< T > &v){\n    for (int i = 0; i < (int)v.size(); ++i) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\n \ntemplate< typename T >\nistream &operator >>  (istream &is, vector< T > &v){\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate< typename T >\nostream &operator << (ostream &os, const set< T > &st){\n    int ct = 0;\n    for(auto& s : st) cout << s << (++ct != st.size() ? \" \" : \"\");\n    return os;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator|= (set<T> &st1, const set<T> &st2) { \n    for(auto& s : st2) st1.insert(s);\n    return st1; \n}\n\ntemplate <typename T>\nconstexpr set<T> &operator-= (set<T> &st1, const set<T> &st2) {\n    for(auto& s : st2) if(st1.count(s)) st1.erase(s);\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator&= (set<T> &st1, const set<T> &st2) {\n    auto itr = st1.begin();\n    while(itr != st1.end()){\n        if(!st2.count(*itr)) itr = st1.erase(itr);\n        else ++itr;\n    }\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator| (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res |= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator- (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res -= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator& (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res &= st2;\n    return res;\n}\n\n/*---------------------------------    Tools    ------------------------------------------*/\ntemplate< typename T >\nvector<T> cumsum(const vector<T> &X){\n    vector<T> res(X.size() + 1, 0);\n    for(int i = 0; i < X.size(); ++i) res[i + 1] += res[i] + X[i];\n    return res;\n}\n \ntemplate< typename S, typename T, typename F>\npair<T, T> bisearch(S left, T right, F f) {\n    while(abs(right - left) > 1){\n        T mid = (right + left) / 2;\n        if(f(mid)) right = mid;\n        else left = mid;\n    }\n    return {left, right};\n}\n \ntemplate< typename S, typename T, typename F>\ndouble trisearch(S left, T right, F f, int maxLoop = 90){\n    double low = left, high = right;\n    while(maxLoop--){\n        double mid_left = high / 3 + low * 2 / 3;\n        double mid_right = high * 2 / 3 + low / 3;\n        if(f(mid_left) >= f(mid_right)) low = mid_left;\n        else high = mid_right;\n    }\n    return (low + high) * 0.5;\n}\n\ntemplate< typename F >\nll ternarySearch(ll L, ll R, F f) { //[L, R)\n    ll lo = L - 1, hi = R - 1;\n    while (lo + 1 != hi) {\n        ll mi = (lo + hi) / 2;\n        if (f(mi) <= f(mi + 1)) hi = mi;\n        else lo = mi;\n    }\n    return hi;\n}\n\n/*---------------------------------    Graph    ------------------------------------------*/\nstruct Graph {\n    struct Edge {\n        ll from, to, weight;\n        Edge() : from(0), to(0), weight(0) {}\n        Edge(ll f, ll t, ll w) : from(f), to(t), weight(w) {}\n    };\n    using Edges = vector<Edge>;\n\n    vector<Edges> G;\n\n    Graph() : G() {};\n\n    Graph(int N) : G(N) {}\n\n    Graph(int N, vector<P>& Edges, bool directed = false) : G(N) {\n        for (auto e : Edges) {\n            if (directed) add_arrow(e.first, e.second);\n            else add_edge(e.first, e.second);\n        }\n    }\n\n    Graph(int N, vector<tuple<ll, ll, ll>>& Edges, bool directed = false) : G(N) {\n        for (auto e : Edges) {\n            if (directed) add_arrow(get<0>(e), get<1>(e), get<2>(e));\n            else add_edge(get<0>(e), get<1>(e), get<2>(e));\n        }\n    }\n\n    Edges operator[](int k) const{\n        return G[k];\n    }\n\n    int size() const{\n        return G.size();\n    }\n\n    void resize(int N){\n        G.resize(N);\n    }\n\n    void add_edge(int a, int b, ll w = 1){\n        G[a].emplace_back(a, b, w);\n        G[b].emplace_back(b, a, w);\n    }\n\n    void add_arrow(int a, int b, ll w = 1){\n        G[a].emplace_back(a, b, w);\n    }\n\n    //Topological_sort\n    //!!return empty, if not DAG\n    vector<ll> topological_sort() const;\n\n    //Dijkstra and related\n    vector<ll> dijkstra(ll s, bool restore = false) const;\n\n    vector<ll> shortest_path(ll start, ll goal) const;\n\n    //Bellman-Ford\n    //!!return empty, if negative loop exists\n    vector<ll> bellman_ford(ll s) const;\n\n    //Warshall-Floyd\n    vector<vector<ll>> Warshall_Floyd() const; \n\n    //Kruskal\n    //!!Required UnionFind\n    Graph Kruskal() const;\n};\n\n\nvector<ll> Graph::dijkstra(ll s, bool restore) const{\n    vector<ll> dist(G.size(), INF);\n    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> que;\n    dist[s] = 0;\n    que.emplace(dist[s], s);\n\n    vector<ll> prev(G.size(), -1);\n\n    while(!que.empty()){\n        ll cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(dist[idx] < cost) continue;\n        for(auto &e : G[idx]){\n            auto next_cost = cost + e.weight;\n            if(dist[e.to] <= next_cost) continue;\n            dist[e.to] = next_cost;\n\n            if(restore) prev[e.to] = e.from;\n            que.emplace(dist[e.to], e.to);\n        }\n    }\n    if(restore) return prev;\n    return dist;\n}\n\nvector<ll> Graph::shortest_path(ll start, ll goal) const{\n    vector<ll> prev = dijkstra(start, true);\n    vector<ll> path;\n    for (int cur = goal; cur != -1; cur = prev[cur]) path.push_back(cur);\n    reverse(path.begin(), path.end());\n    if (path.front() != start) return {};\n    return path;\n}\n\nvector<ll> Graph::bellman_ford(ll s) const{\n    vector<ll> dist(G.size(), INF);\n    dist[s] = 0;\n    for (ll i = 0; i < G.size(); ++i) {\n        for (ll j = 0; j < G.size(); ++j){\n            for (auto& e : G[j]) {\n                if(dist[e.from] == INF) continue;\n                bool res = chmin(dist[e.to], dist[e.from] + e.weight);\n                if (i == G.size() - 1 and res) return {};\n            }\n        }\n    }\n    return dist;\n}\n\nvector<vector<ll>> Graph::Warshall_Floyd() const {\n    int N = G.size();\n    vector<vector<ll>> d(N, vector<ll>(N));\n\n    rep(i, N) rep(j, N) {\n        if (i == j) d[i][j] = 0;\n        else d[i][j] = INF;\n    }\n\n    rep(i, N) for (auto &e : G[i]) d[i][e.to] = e.weight;\n    rep(k, N) rep(i, N) rep(j, N) {\n        if (d[i][k] == INF or d[k][j] == INF) continue;\n        d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n    }\n    return d;\n}\n\nvector<ll> Graph::topological_sort() const{\n    vector<ll> ans;\n    int N = G.size();\n    vector<int> ind(N);\n    rep(i, N) for (auto &e : G[i]) ind[e.to]++;\n    queue<int> que;\n    rep(i, N) if (!ind[i]) que.push(i);\n    while(!que.empty()){\n        int now  = que.front();\n        ans.pb(now);\n        que.pop();\n        for(auto& e : G[now]) {\n            ind [e.to]--;\n            if(!ind[e.to]) que.push(e.to);\n        }\n    }\n    if (ans.size() != N) return {};\n    return ans;\n}\n\n//最小共通祖先\n//前処理O(N log N)でグラフgの頂点rを根として構築\n//クエリO(log N)でグラフgの点u,vの最小共通祖先を取得\n//lca lca(g)で構築, lca.query(u, v)で取得\nclass LowestCommonAncestor {\npublic:\n    const int n = 0;\n    const int log2_n = 0;\n    std::vector<std::vector<int>> parent;\n    std::vector<int> depth;\n\n    LowestCommonAncestor() {}\n\n    LowestCommonAncestor(const Graph &g, int root) : n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n        dfs(g, root, -1, 0);\n        for (int k = 0; k + 1 < log2_n; k++) {\n            for (int v = 0; v < (int)g.size(); v++) {\n                if (parent[k][v] < 0) parent[k + 1][v] = -1;\n                else parent[k + 1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    void dfs(const Graph &g, int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (auto &e : g[v]) {\n            if (e.to != p) dfs(g, e.to, v, d + 1);\n        }\n    }\n\n    ll query(int u, int v) {\n        if (depth[u] > depth[v]) std::swap(u, v);\n        for (int k = 0; k < log2_n; k++) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n        if (u == v) return u;\n        for (int k = log2_n - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\n\n/*------------------------------- Main Code Here -----------------------------------------*/\n \nint main()\n{\n    ll N;\n    cin >> N;\n    Graph G(N);\n    rep(i, N){\n        ll k;\n        cin >> k;\n        rep(j, k){\n            ll c;\n            cin >> c;\n            G.add_edge(i, c);\n        }\n    }\n    LowestCommonAncestor LCA(G, 0);\n\n    ll Q;\n    cin >> Q;\n    rep(i, Q){\n        ll u, v;\n        cin >> u >> v;\n        print(LCA.query(u, v));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nclass HeavyLightDecomposition{\nprivate:\n\tstruct edge{int to,cost;};\n\tint n;\n\tvector<vector<edge>> g;\n\tvector<int> sub;//部分木のサイズ\n\tvector<int> par,depth;\n\tvector<int> head;//自分の所属するheavyパスの先頭\n\tvector<int> idx;//オイラーツアーの番号\n\tvoid dfs(int now){\n\t\tsub[now] = 1;\n\t\tint ma = 0;\n\t\tfor(auto& e: g[now])if(e.to != par[now]){\n\t\t\tpar[e.to] = now;\n\t\t\tdepth[e.to] = depth[now] + 1;\n\t\t\tdfs(e.to);\n\t\t\tsub[now] += sub[e.to];\n\t\t\tif(sub[g[now][0].to] < sub[e.to])swap(g[now][0],e);//g[now][0]に部分木が最大であるようなものが来る\n\t\t}\n\t}\n\tint et = 0;\n\tvoid dfs2(int now){\n\t\tidx[now] = et;\n\t\tet++;\n\t\trep(i,g[now].size())if(g[now][i].to != par[now]){\n\t\t\tedge e = g[now][i];\n\t\t\tif(i){\n\t\t\t\thead[e.to] = e.to;\n\t\t\t}else{\n\t\t\t\thead[e.to] = head[now];\n\t\t\t}\n\t\t\tdfs2(e.to);\n\t\t}\n\t}\npublic:\n\tHeavyLightDecomposition(int sz){\n\t\tn = sz;\n\t\tg.resize(n);\n\t\tsub.resize(n);\n\t\tpar.resize(n);\n\t\thead.resize(n);\n\t\tdepth.resize(n);\n\t\tidx.resize(n);\n\t}\n\tvoid add_edge(int a, int b, int c){\n\t\tg[a].push_back({b,c});\n\t\tg[b].push_back({a,c});\n\t}\n\tvoid build(int root){\n\t\tpar[root] = -1;\n\t\tdepth[root] = 1;\n\t\tdfs(root);\n\t\thead[root] = root;\n\t\tdfs2(root);\n\t}\n\tint lca(int u, int v){\n\t\tif(idx[u] > idx[v])swap(u,v);\n\t\t// u < v\n\t\tif(head[u] == head[v])return u;\n\t\treturn lca(u,par[head[v]]);\n\t}\n\t/*\n\tint query_sum(int u, int v){\n\t\tint x = lca(u,v);\n\n\n\t}\n\tvoid add(int v, int x){\n\n\t}\n\t*/\n};\n\nvoid grl5c(){\n\tint n;\n\tcin >> n;\n\tHeavyLightDecomposition hld(n);\n\trep(i,n){\n\t\tint k;\n\t\tcin >> k;\n\t\trep(_,k){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\thld.add_edge(i,t,1);\n\t\t}\n\t}\n\thld.build(0);\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tcout << hld.lca(u,v) << endl;\n\t}\n}\n\nint main(){\n\tgrl5c();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\n#define sz(x) ((int)x.size())\n\nstruct UnionFind {\n    vi data;\n    int comp;\n    UnionFind() {}\n    UnionFind(int size) {\n        init(size);\n    }\n    void init(int size) {\n        data.assign(size, -1);\n        comp = size;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        if (data[x] < 0) {\n            return x;\n        } else {\n            return data[x] = root(data[x]);\n        }\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() {\n        return comp;\n    }\n};\n\ntemplate <class Graph>\nstruct LCA {\n    using Query = pii;\n    Graph g;\n    vi color;\n    vi ancestor;\n    vector<vector<pair<int, Query>>> query_set;\n    vi res;\n    UnionFind uf;\n    LCA(const Graph &g, vector<Query> &query) :\n            g         (g),\n            color     (sz(g)),\n            ancestor  (sz(g)),\n            query_set (sz(g)),\n            res       (sz(query)),\n            uf        (sz(g))\n    {\n        int qs = sz(query);\n        rep(i, 0, qs) {\n            query_set[query[i].first ].emplace_back(i, query[i]);\n            query_set[query[i].second].emplace_back(i, query[i]);\n        }\n    }\n    void visit(int s, int prev) {\n        ancestor[uf.root(s)] = s;\n        for (auto &e : g[s]) {\n            if (e == prev) {\n                continue;\n            }\n            visit(e, s);\n            uf.unite(s, e);\n            ancestor[uf.root(s)] = s;\n        }\n        color[s] = 1;\n        for (auto &p : query_set[s]) {\n            Query q = p.second;\n            int w = (q.second == s ? q.first : (q.first == s ? q.second : -1));\n            if (w == -1 || !color[w]) {\n                continue;\n            }\n            res[p.first] = ancestor[uf.root(w)];\n        }\n    }\n    vi solve(int root) {\n        visit(root, -1);\n        return res;\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> G(N);\n    rep(i, 0, N) {\n        int K;\n        cin >> K;\n        rep(k, 0, K) {\n            int X;\n            cin >> X;\n            G[i].push_back(X);\n            G[X].push_back(i);\n        }\n    }\n    int Q;\n    cin >> Q;\n    vector<pii> queries;\n    rep(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        queries.emplace_back(U, V);\n    }\n    LCA<vvi> lca(G, queries);\n    vi res = lca.solve(0);\n\n    for (int ans : res) {\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <assert.h>\n\n#define LL long long\n#define VI vector<int>\n#define VL vector<long long>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\nusing namespace std;\n\n\nstruct Edge {\n    int src, dst, weight;\n    Edge(int src, int dst, int weight): src(src), dst(dst), weight(weight) {}\n};\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nstruct Query {\n    int u, v, w;\n    Query(int u, int v) : u(u), v(v), w(-1) { }\n};\n\nvoid visit(const vector<vector<Edge>> &g, int u, int w, vector<Query> &qs, vector<int> &color, vector<int> &ancestor, UnionFind &uf) {\n    ancestor[uf.root(u)] = u;\n    FOE(&e, g[u]) if (e.dst != w) {\n        visit(g, e.dst, u, qs, color, ancestor, uf);\n        uf.unionSet(e.src, e.dst);\n        ancestor[uf.root(u)] = u;\n    }\n    color[u] = 1;\n    FOE(&q, qs) {\n        int w = (q.v == u ? q.u : q.u == u ? q.v : -1);\n        if (w >= 0 && color[w]) q.w = ancestor[uf.root(w)];\n    }\n}\nvoid leastCommonAncestor(const vector<vector<Edge>> &g, int r, vector<Query> &qs) {\n    UnionFind uf(g.size());\n    vector<int> color(g.size()), ancestor(g.size());\n    visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(int argc, char *argv[]) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, c;\n    cin >> n;\n    vector<vector<Edge>> graph(n, vector<Edge>());\n    FOR(i, 0, n) {\n        cin >> k;\n        FOR(j, 0, k) {\n            cin >> c;\n            graph[i].push_back(Edge(i, c, 1));\n            graph[c].push_back(Edge(c, i, 1));\n        }\n    }\n\n    int q, u, v;\n    cin >> q;\n    vector<Query> queries;\n    FOR(i, 0, q) {\n        cin >> u >> v;\n        queries.push_back(Query(u, v));\n    }\n\n    leastCommonAncestor(graph, 0, queries);\n    FOE(q, queries) {\n        cout << q.w << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define swap(i,j) { int tmp = i; i = j; j = tmp; }\n\nint n;\nvector<int> tree[100010];\nint par[100010] = {};\nint num[100010] = {};\nint vid[100010];\nint head[100010];\nint team[100010];\nint b = 0;\n\n\nint setnum(int i){\n  if(tree[i].size() == 0) return num[i] = 1;\n\n  int ret = 0;\n  for(int j = 0;j < tree[i].size();j++){\n    ret += setnum(tree[i][j]);\n  }\n\n  return num[i] = ret;\n}\n\nvoid dis(int n){\n  memset(team,-1,sizeof(team));\n  int gnum = 0;\n  int next;\n  int pos = 0;\n  for(int i = 0;i < n;i++){\n    if(team[i] != -1) continue;\n    team[i] = gnum;\n    head[i] = i;\n    vid[i] = pos;\n    pos++;\n    next = i;\n    while(tree[next].size() != 0){\n      int maxi = 0;\n      for(int j = 1;j < tree[next].size();j++){\n        if(num[tree[next][maxi]] < num[tree[next][j]]){\n          maxi = j;\n        }\n      }\n      team[tree[next][maxi]] = gnum;\n      head[tree[next][maxi]] = i;\n      vid[tree[next][maxi]] = pos;\n      pos++;\n      next = tree[next][maxi];\n    }\n    gnum++;\n  }\n  return;\n}\n\nvoid build(int n){\n  setnum(0);\n  dis(n);\n  return;\n}\n\nint lca(int i, int j){\n  while(1){\n    if(vid[i] > vid[j]) swap(i, j);\n    if(head[i] == head[j]) return i;\n    j = par[head[j]];\n  }\n}\n\nint main(){\n  cin >> n;\n\n  int k;\n  int c;\n  for(int i = 0;i < n;i++){\n    cin >> k;\n    for(int j = 0;j < k;j++){\n      cin >> c;\n      par[c] = i;\n      tree[i].push_back(c);\n    }\n  }\n\n  build(n);\n\n  int q;\n  cin >> q;\n  int a, b;\n  for(int i = 0;i < q;i++){\n    cin >> a >> b;\n    cout << lca(a, b) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} fast;\n\nvoid yes() {\n    cout << \"Yes\" << endl;\n    exit(0);\n}\nvoid no() {\n    cout << \"No\" << endl;\n    exit(0);\n}\n#define REP(i, n) for (long long i = 0; i < (n); i++)\n\nlong long modpow(long long m, long long n) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long long t = modpow(m, n / 2);\n        return t * t;\n    } else {\n        return modpow(m, n - 1) * m;\n    }\n}\n\nsigned main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n), par(n, vector<int>(30));\n    vector<int> d(n);\n    REP(i, n) {\n        int k;\n        cin >> k;\n        REP(j, k) {\n            int c;\n            cin >> c;\n            graph[i].push_back(c);\n            graph[c].push_back(i);\n        }\n    }\n    function<void(int, int, int)> dfs = [&](int c, int p, int depth) {\n        d[c] = depth;\n        par[c][0] = p;\n        for (auto ch : graph[c]) {\n            if (ch != p) dfs(ch, c, depth + 1);\n        }\n    };\n    dfs(0, 0, 0);\n    int q;\n    cin >> q;\n    // cout << \"skeleton barrel\";\n    /*calc par*/\n    for (int j = 1; j < 30; j++) {\n        REP(i, n) { par[i][j] = par[par[i][j - 1]][j - 1]; }\n    }\n    REP(j, q) {\n        int u, v;\n        cin >> u >> v;\n        if (d[u] > d[v]) {\n            swap(u, v);\n        }\n        for (int i = 29; 0 <= i; i--) {\n            if (d[u] <= d[par[v][i]]) {\n                v = par[v][i];\n            }\n        }\n        /* LCA */\n        for (int i = 29; 0 <= i; i--) {\n            if (par[v][i] != par[u][i]) {\n                v = par[v][i];\n                u = par[u][i];\n            }\n        }\n        if (u == v) {\n            cout << u << endl;\n        } else {\n            cout << par[v][0] << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nunsigned int leftMostBit(unsigned int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    unsigned int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return node_[vl] < node_[vr] ? left_child(k) : right_child(k);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n\n// 根付き木\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int size() const {return node_.size();}\n    int lowest_common_ancestor(int u, int v) const {\n        RangeMinimumQuery rmq(size());\n        for(int i = 0; i < size(); ++i) rmq.update(i, depth(i));\n        return rmq.find_index(std::min(u, v), std::max(u, v)) - 1;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n\n\n/*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n//     int lowest_common_ancestor(int u, int v) const {\n//         while(depth(u) > depth(v)) u = parent(u);\n//         while(depth(u) < depth(v)) v = parent(v);\n//         while(u != v) {\n//             u = parent(u);\n//             v = parent(v);\n//         }\n//         return u;\n//     }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(u);\n            else                    u = parent(v);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\n\n\nclass RMQsub1{\n\tstd::vector<int> pattern;\n\tstd::vector<std::vector<int> > minpos;\n\tstd::vector<int> depth;\n\tSparseTableRMQ rmq;\n\tint blocksize;\n\tint n;\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tstd::vector<int> B;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k>>1;//log(n)/2\n\t\tif(blocksize==0)blocksize=1;\n\t\tint m=(n+blocksize-1)/blocksize;//num node\n\t\twhile(m&m-1)m+=m&-m;\n\t\tthis->n=m;\n\t\tpattern.resize(n,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tB.resize((n+blocksize-1)/blocksize);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tB[i]=depth[s+minpos[p][0+b-1]];\n\t\t}\n\t\trmq.build(B);\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\tb--;\n\t\tint ab=a/blocksize,bb=b/blocksize;\n\t\tif(ab==bb)return ab*blocksize + minpos[pattern[ab]][(a%blocksize)*blocksize+b%blocksize];\n\t\tint i,j;\n\t\ti=ab*blocksize + minpos[pattern[ab]][(a%blocksize)*blocksize+blocksize-1];\n\t\tj=bb*blocksize + minpos[pattern[bb]][0+b%blocksize];\n\t\tif(depth[i]>depth[j])i=j;\n\t\tif(ab+1==bb)return i;\n\t\tj=rmq.query(ab+1,bb);\n\t\tj=j*blocksize + minpos[pattern[j]][0+blocksize-1];\n\t\tif(depth[i]>depth[j])i=j;\n\t\treturn i;\n\t}\n};\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L;\n\n  std::vector<int> lg;\n  std::vector<BitIndex> small;\n  std::vector<std::vector<Index>> large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n\nprivate:\n  Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), lg(1 << S), small(N), large(L, std::vector<Index>(LG_L)) {\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li][0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li][0] = F(large[li][0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li][x + 1] = F(large[li][x], large[li + (1 << x)][x]);\n      }\n    }\n    std::vector<Index> st;\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      st.clear();\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (!st.empty() && f(i + si, st.back())) st.pop_back();\n        small[i + si] |= 1 << si;\n        if (!st.empty()) small[i + si] |= small[st.back()];\n        st.push_back(i + si);\n      }\n    }\n  }\n  int ntz(int x) const { return lg[x & -x]; }\n  int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l][x], large[r - (1 << x) + 1][x]);\n  }\n};\n#include <vector>\n#include <map>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::map<int, int> ord;\n\n  EulerTour(int N) : T(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct IoSetup { // {{{\n  IoSetup() {\n    std::ios::sync_with_stdio(0);\n    std::cin.tie(0);\n    std::cout.precision(20);\n    std::cout.setf(std::ios::fixed);\n  }\n} iosetup; //}}}\n\ninline int in(){ int x; cin >> x; return x; }\n\nint main() {\n  int N = in();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = in();\n    for (int j = 0; j < k; j++) {\n      et.add_edge(i, in());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = in();\n  for (int i = 0; i < Q; i++) {\n    int u = in(), v = in();\n    cout << lca.query(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int nmax=100010;\n\nvector<int> graph[nmax];\nint parent[nmax][20]; // all is -1\nint depth[nmax];\n\nvoid dfs(int v,int p,int d){\n\tparent[v][0]=p;\n\tdepth[v]=d;\n\tfor(auto &v2:graph[v]) if(v2!=p) dfs(v2,v,d+1);\n}\n\nint lca(int u,int v){\n\tif(depth[u] < depth[v]) swap(u,v);\n\tfor(int i=19;i>=0;--i) if((depth[u]-depth[v])>>i&1) u=parent[u][i];\n\tif(u==v) return u;\n\tfor(int i=19;i>=0;--i){\n\t\tif(parent[u][i]!=parent[v][i]){\n\t\t\tu=parent[u][i];\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\treturn parent[u][0];\n}\n\nint main(void){\n\tint n; cin >> n;\n\trep(i,n){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint v; cin >> v;\n\t\t\tgraph[i].push_back(v);\n\t\t}\n\t}\n\n\trep(i,n)rep(j,20) parent[i][j]=-1;\n\tdfs(0,-1,0);\n\trep(i,n)rep(j,19) parent[i][j+1]=parent[parent[i][j]][j];\n\n\tint q; cin >> q;\n\trep(i,q){\n\t\tint u,v; cin >> u >> v;\n\t\tcout << lca(u,v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_LOG_V = 16;\n\nvector<int> g[MAX_V]; //??°???????????£??\\?????????\nint root;\n\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i,g[v].size()){\n        if(g[v][i] != p) dfs(g[v][i], v, d + 1);\n    }\n}\n\nvoid init(int v){\n    dfs(root, -1, 0);\n    rep(i,MAX_LOG_V - 1){\n        rep(j,v){\n            if(parent[i][j] < 0) parent[i + 1][j] = -1;\n            else parent[i + 1][j] = parent[i][parent[i][j]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    rep(i,MAX_LOG_V){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = parent[i][v];\n        }\n    }\n    if(u == v) return u;\n\n    //????????¢?´¢\n    for(int i = MAX_LOG_V - 1; i >= 0; i--){\n        if(parent[i][u] != parent[i][v]){\n            u = parent[i][u];\n            v = parent[i][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    int n;\n    cin >> n;\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int v;\n            cin >> v;\n            g[i].emplace_back(v);\n            g[v].emplace_back(i);\n        }\n    }\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u, v;\n        cin >> u >> v;\n        init(n);\n        cout << lca(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef VVI Graph;\n\nGraph G;\nconst int N = 100000;\nconst int LOG_N = log2(N);\nint depth[N];\nint parent[LOG_N][N];\n// number graph with root. root is first given node\n// suppose depth < 0\nvoid dfs(int node ,int p = -1, int d = 0)\n{\n  if(depth[node] >= 0) return;\n  depth[node] = d;\n  parent[0][node] = p;\n  for(int i=0;i<SZ(G[node]);++i)\n\tdfs(G[node][i], node, d+1);\n}\n\nvoid init(int V){\n  fill(depth, depth+N, -1);\n  dfs(0);\n  for(int i=0;i+1<LOG_N;++i){\n\tfor(int v=0;v<V;++v){\n\t  if(parent[i][v] == -1) parent[i+1][v] = -1;\n\t  else parent[i+1][v] = parent[i][parent[i][v]];\n\t}\n  }\n}\n\nint LCA(int u, int v){\n  if(depth[u] > depth[v]) swap(u, v);\n  //depth[u] <= depth[v]\n  for(int i=0;i<LOG_N;++i)\n\tif((depth[v] - depth[u]) >> i & 1)\n\t  v = parent[i][v];\n  if(u == v) return u;\n\n  for(int i=LOG_N-1;i>=0;--i){\n\tif(parent[i][u] != parent[i][v]){\n\t  u = parent[i][u];\n\t  v = parent[i][v];\n\t}\n  }\n  return parent[0][u];\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V; cin >> V;\n  G.assign(V, VI());\n  REP(i,V){\n\tint k; cin >> k;\n\tREP(j,k){\n\t  int c; cin >> c;\n\t  G[i].PB(c);\n\t}\n  }\n  init(V);\n  int Q; cin >> Q;\n  while(Q--){\n\tint u, v; cin >> u >> v;\n\tcout << LCA(u,v) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n  vector<vector<int> >  tree;\n  \n  HeavyLight(vector<vector<int> >tree)\n    :n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n),tree(tree){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    /*\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Semigroup >\nstruct Node {\n  Node *l, *r, *p;\n  int idx;\n  Semigroup key, sum;\n  bool rev;\n  int sz;\n\n  Node() {}\n\n  Node(int idx, const Semigroup &v) {\n    init_node(idx, v);\n  }\n\n  void init_node(int idx, const Semigroup &v) {\n    this->idx = idx;\n    this->key = this->sum = v;\n    this->l = this->r = this->p = nullptr;\n    rev = false;\n    sz = 1;\n  }\n\n  void push() {\n    /*\n    if(rev) {\n      swap(l, r);\n      if(l) l->rev ^= true;\n      if(r) r->rev ^= true;\n    }\n     */\n  }\n\n  bool is_root() {\n    return !p || (p->l != this && p->r != this);\n  }\n\n  void update() {\n    sz = 1;\n    sum = key;\n    if(l) sz += l->sz, sum = l->sum + sum;\n    if(r) sz += r->sz, sum = sum + r->sum;\n  }\n\n  void rotr() { // 右回転\n    auto *x = p, *y = x->p;\n    if((x->l = r)) r->p = x;\n    r = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void rotl() { // 左回転\n    auto *x = p, *y = x->p;\n    if((x->r = l)) l->p = x;\n    l = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void splay() {\n    push();\n    while(!is_root()) {\n      auto *q = p;\n      if(q->is_root()) {\n        q->push(), push();\n        if(q->l == this) rotr();\n        else rotl();\n      } else {\n        auto *r = q->p;\n        r->push(), q->push(), push();\n        if(r->l == q) {\n          if(q->l == this) q->rotr(), rotr();\n          else rotl(), rotr();\n        } else {\n          if(q->r == this) q->rotl(), rotl();\n          else rotr(), rotl();\n        }\n      }\n    }\n  }\n\n  Node *expose() {\n    Node *rp = nullptr;\n    for(Node *cur = this; cur; cur = cur->p) {\n      cur->splay();\n      cur->r = rp;\n      cur->update();\n      rp = cur;\n    }\n    splay();\n    return rp;\n  }\n\n  void link(Node *parent) {\n    expose();\n    parent->expose();\n    p = parent;\n    parent->r = this;\n  }\n\n  void cut() {\n    expose();\n    auto *parent = l;\n    l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert() {\n    expose();\n    rev ^= true;\n    push();\n  }\n};\n\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n\n  Node< int > uku[100000];\n  for(int i = 0; i < N; i++) {\n    uku[i].init_node(i, 0);\n  }\n\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      uku[T].link(&uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    uku[U].expose();\n    printf(\"%d\\n\", uku[V].expose()->idx);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<typename M>\nclass LinkCutTree {\npublic:\n    using T = typename M::T;\n    using E = typename M::E;\n\n    struct node {\n        int sz, idx;\n        T val, sum;\n        E lazy;\n        node *left, *right, *par;\n        bool rev;\n        node(int idx) : sz(1), idx(idx), val(M::T0()), sum(M::T0()), lazy(M::E0()),\n            left(nullptr), right(nullptr), par(nullptr), rev(false) {}\n        node(T _val, int idx) : sz(1), idx(idx), val(_val), sum(_val), lazy(M::E0()),\n            left(nullptr), right(nullptr), par(nullptr), rev(false) {}\n        inline bool isRoot() const {\n            return (!par) || (par->left != this && par->right != this);\n        }\n        void push() {\n            if(lazy != M::E0()) {\n                val = M::g(val, lazy, 1), sum = M::g(sum, lazy, sz);\n                if(left) left->lazy = M::h(left->lazy, lazy);\n                if(right) right->lazy = M::h(right->lazy, lazy);\n                lazy = M::E0();\n            }\n            if(rev) {\n                swap(left, right);\n                sum = M::s(sum);\n                if(left) left->rev ^= true;\n                if(right) right->rev ^= true;\n                rev = false;\n            }\n        }\n        void eval() {\n            sz = 1, sum = val;\n            if(left) left->push(), sz += left->sz, sum = M::f(left->sum, sum);\n            if(right) right->push(), sz += right->sz, sum = M::f(sum, right->sum);\n        }\n    };\n \nprivate:\n    void rotate(node *u, bool right) {\n        node *p = u->par, *g = p->par;\n        if(right) {\n            if((p->left = u->right)) u->right->par = p;\n            u->right = p, p->par = u;\n        } else {\n            if((p->right = u->left)) u->left->par = p;\n            u->left = p, p->par = u;\n        }\n        p->eval(), u->eval(), u->par = g;\n        if(!g) return;\n        if(g->left == p) g->left = u;\n        if(g->right == p) g->right = u;\n        g->eval();\n    }\n    // uをsplay木の根にする\n    void splay(node *u) {\n        while(!u->isRoot()) {\n            node *p = u->par, *gp = p->par;\n            if(p->isRoot()) { // zig\n                p->push(), u->push();\n                rotate(u, (u == p->left));\n            } else {\n                gp->push(), p->push(), u->push();\n                bool flag = (u == p->left);\n                if((u == p->left) == (p == gp->left)) { // zig-zig\n                    rotate(p, flag), rotate(u, flag);\n                } else { // zig-zag\n                    rotate(u, flag), rotate(u, !flag);\n                }\n            }\n        }\n        u->push();\n    }\n    // 頂点uから根へのパスをつなげる\n    node* expose(node *u) {\n        node *last = nullptr;\n        for(node *v = u; v; v = v->par) {\n            // dump(v->val);\n            splay(v);\n            v->right = last;\n            v->eval();\n            last = v;\n            // dump(v->val);\n        }\n        splay(u);\n        return last;\n    }\n    void evert(node *u) {\n        expose(u), u->rev = !(u->rev), u->push();\n    }\n    bool connected(node *u, node *v) {\n        expose(u), expose(v);\n        return u == v || u->par;\n    }\n    void link(node *u, node *v) {\n        evert(u), u->par = v;\n    }\n    void cut(node *u) { // uと親の辺を切る\n        expose(u), u->left->par = nullptr, u->left = nullptr, u->eval();\n    }\n    void cut(node *u, node *v) {\n        expose(u), expose(v);\n        if(u->isRoot()) u->par = nullptr;\n        else v->left->par = nullptr, v->left = nullptr, v->eval();\n    }\n    node* lca(node *u, node *v) {\n        expose(u);\n        return expose(v);\n    }\n    int depth(node *u) {\n        expose(u);\n        return u->sz - 1;\n    }\n    void toRoot_range(node *u, const E x) {\n        expose(u);\n        u->lazy = M::h(u->lazy, x), u->push();\n    }\n    void range(node *u, node *v, const E x) {\n        evert(u), expose(v);\n        v->lazy = M::h(v->lazy, x), v->push();\n    }\n    void toRoot_query(node *u) {\n        expose(u);\n        return u->sum;\n    }\n    T query(node *u, node *v) {\n        evert(u), expose(v);\n        return v->sum;\n    }\n \npublic:\n    const int n;\n    node** arr;\n    LinkCutTree(const vector<T> &v) : n(v.size()) { \n        arr = new node*[n];\n        REP(i, n) arr[i] = new node(v[i], i);\n    }\n    // ~LinkCutTree(){\n    //     REP(i, n) delete arr[i];\n    //     delete[] arr;\n    // }\n    bool connected(int id1, int id2) { return connected(arr[id1], arr[id2]); }\n    void link(int id1, int id2) { return link(arr[id1], arr[id2]); }\n    void cut(int id) { return cut(arr[id]); } // uと親の辺を切る\n    void cut(int id1, int id2) { return cut(arr[id1], arr[id2]); }\n    int lca(int id1, int id2) { return lca(arr[id1], arr[id2])->idx; }\n    void evert(int id) { return evert(arr[id]); }\n    int depth(int id) { return depth(arr[id]); }\n    void toRoot_range(int id, const E x) { return toRoot_range(arr[id], x); }\n    void range(int id1, int id2, const E x) { return range(arr[id1], arr[id2], x); }\n    T toRoot_query(int id) { return toRoot_query(arr[id]); }\n    T query(int id1, int id2) { return query(arr[id1], arr[id2]); }\n};\n\nstruct sum_monoid {\n    using T = ll;\n    using E = ll;\n    static T T0() { return 0; }\n    static constexpr E E0() { return 0; }\n    static T f(const T &x, const T &y) { return x+y; }\n    static T g(const T &x, const E &y, int sz) { return x + y*sz; }\n    static E h(const E &x, const E &y) { return x+y; }\n    static T s(const T &x) { return x; }\n};\n\nint main(void) {\n    ll n;\n    cin >> n;\n    vector<ll> init(n);\n    iota(ALL(init), 0);\n    LinkCutTree<sum_monoid> lct(init);\n    REP(i, n) {\n        ll k;\n        cin >> k;\n        REP(j, k) {\n            ll c;\n            cin >> c;\n            lct.link(i, c);\n        }\n    }\n    lct.evert(0);\n\n    ll q;\n    cin >> q;\n    while(q--) {\n        ll u, v;\n        cin >> u >> v;\n        cout << lct.lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c = 0): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\nusing Graph =  vector< vector<Edge> >;\n\n\n// calc Lowest Common Ancestor\n// O(N logN)\nstruct LCA{\n  const Graph& G;\n  int N, R;\n  int LOG_MAX;\n  vector<int> depth;\n  vector<vector<int>> parent;\n\n  LCA(const Graph& G_, int N_, int R_):\n\tG(G_), N(N_), R(R_)\n  {\n\tLOG_MAX = log2(N) + 1;\n\tdepth.assign(N, -1);\n\tparent.resize(LOG_MAX);\n\tfor(int i=0;i<LOG_MAX;++i)\n\t  parent[i].resize(N);\n\n\tfunction<void(int,int,int)> dfs = [&](int u, int p, int d){\n\t  depth[u] = d;\n\t  parent[0][u] = p;\n\t  for(const auto& e: G[u])\n\t\tif(e.to != p)\n\t\t  dfs(e.to, u, d+1);\n\t};\n\tdfs(R, -1, 0);\n\t\n\tfor(int i=0;i+1<LOG_MAX;++i){\n\t  for(int v=0;v<N;++v){\n\t\tif(parent[i][v] == -1) parent[i+1][v] = -1;\n\t\telse parent[i+1][v] = parent[i][parent[i][v]];\n\t  }\n\t}\n  }\n\n\n  int query(int u, int v){\n\tif(depth[u] > depth[v]) swap(u, v);\n\t// assume: depth[u] <= depth[v]\n\tfor(int i=0;i<LOG_MAX;++i)\n\t  if((depth[v] - depth[u]) >> i & 1)\n\t\tv = parent[i][v];\n\tif(u == v) return u;\n\t\n\tfor(int i=LOG_MAX-1;i>=0;--i){\n\t  if(parent[i][u] != parent[i][v]){\n\t\tu = parent[i][u];\n\t\tv = parent[i][v];\n\t  }\n\t}\n\treturn parent[0][u];\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V; cin >> V;\n  Graph G(V);\n  REP(i,V){\n\tint k; cin >> k;\n\tREP(j,k){\n\t  int c; cin >> c;\n\t  G[i].PB(c);\n\t  G[c].PB(i);\n\t}\n  }\n  LCA lca(G, V, 0);\n\n  int Q; cin >> Q;\n  while(Q--){\n\tint u, v; cin >> u >> v;\n\tcout << lca.query(u,v) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) // cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n\nstruct segment_tree {\n    static const int INF = std::numeric_limits<int>::max();\n};\n\nclass lca {\npublic:\n    int n;\n    int ss;\n    vector<int> path, depth, in_order, out_order;\n    segment_tree st;\n    std::vector<pair<int,int>> dat;\n    const pair<int,int> INF = make_pair(1000000000, 1000000000);\n\n    lca(const Graph &g, int root)\n        : n(g.size()),\n          path(n*2 - 1),\n          depth(n*2 - 1),\n          in_order(n),\n          out_order(n) {\n        int k = 0;\n        dfs(g, root, -1, 0, k);\n        for (ss = 1; ss < n * 2 - 1; ss <<= 1);\n        dat.assign(ss * 2, INF);\n        for (int i = 0; i < (int)depth.size(); ++i){\n            dat[ss + i] = make_pair(depth[i], i);\n        }\n        for (int i = ss - 1; i >= 1; --i){\n            dat[i] = min(dat[i*2], dat[i*2+1]);\n        }\n    }\n\n    void dfs(Graph const &g, int v, int p, int d, int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : g[v]) {\n            if (e.dst != p) {\n                dfs(g, e.dst, v, d + 1, k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k - 1;\n    }\n\n    pair<int,int> range_min(int v, int w, int l, int r) const {\n        if (r <= l || w == 0) return INF;\n        if (r - l == w) return dat[v];\n        int m = w / 2;\n        return min(range_min(v * 2, m, l, std::min(r, m)),\n                   range_min(v * 2 + 1, m, std::max(0, l - m), r - m));\n    }\n\n    int get(int u, int v) {\n        int l = min(in_order[u], in_order[v]);\n        int r = max(in_order[u], in_order[v]) + 1;\n        auto res = range_min(1, ss, l, r);\n        return path[res.second];\n    }\n};\n\n#define int ll\n\nconst int B = 300;\n\nint N, Q;\nGraph g;\nvector<tuple<int, int, int, int>> query;\n\nint dist[100010];\nvector<pair<int, int>> add_at[100010];\nvector<int> stk;\n\nvoid make_dist(int v, int p, int s) {\n    dist[v] = s;\n    for (auto &e : g[v]) {\n        if (e.dst != p) {\n            make_dist(e.dst, v, dist[v] + e.weight);\n        }\n    }\n}\n\nvoid add_many(int v, int p) {\n    for (auto &aq : add_at[v]) {\n        int k = aq.first;\n        int x = aq.second;\n        if (k < (int)stk.size())\n            stk.rbegin()[k] += x;\n    }\n\n    int add = stk.back();\n    stk.pop_back();\n    for (auto &e : g[v]) {\n        if (e.dst != p) {\n            e.weight += add;\n            add_many(e.dst, v);\n        }\n    }\n    stk.push_back(add);\n\n    for (auto &aq : add_at[v]) {\n        int k = aq.first;\n        int x = aq.second;\n        if (k < (int)stk.size())\n            stk.rbegin()[k] -= x;\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    Graph g(n);\n    rep(i, n){\n        int k;\n        cin >> k;\n        rep(j, k){\n            int c;\n            cin >> c;\n            g[i].emplace_back(i, c, 1);\n        }\n    }\n    lca l(g, 0);\n    int q;\n    cin >> q;\n    rep(i, q){\n        int u, v;\n        cin >> u >> v;\n        cout << l.get(u, v) << '\\n';\n    }\n}\n\n// signed main() {\n//     ios::sync_with_stdio(0);\n//     cin.tie(0);\n\n//     cin >> N;\n//     g.assign(N, {});\n//     for (int i = 0; i < N - 1; i++) {\n//         int a, b, c;\n//         cin >> a >> b >> c;\n//         --a;\n//         --b;\n//         g[a].emplace_back(a, b, c);\n//         g[b].emplace_back(b, a, c);\n//     }\n\n//     lca lc(g, 0);\n\n//     auto is_parent = [&](int p, int c) {\n//         int l = lc.in_order[p], r = lc.out_order[p];\n//         int x = lc.in_order[c];\n//         return l <= x && x <= r;\n//     };\n\n//     cin >> Q;\n//     query.resize(Q);\n//     for (auto &q : query) {\n//         int t;\n//         cin >> t;\n//         if (t == 1) {\n//             int v, k, x;\n//             cin >> v >> k >> x;\n//             --v;\n//             --k;\n//             q = make_tuple(t, v, k, x);\n//         } else {\n//             int u, v;\n//             cin >> u >> v;\n//             --u;\n//             --v;\n//             q = make_tuple(t, u, v, -1);\n//         }\n//     }\n\n//     for (int i = 0; i < Q; i += B) {\n//         make_dist(0, -1, 0);\n\n//         int left = i, right = min(Q, i + B);\n\n//         for (int j = left; j < right; ++j) {\n//             auto f = [&](int v){\n//                 int res = 0;\n//                 for (int jj = left; jj < j; ++jj) {\n//                     int tt, add_at, k, x;\n//                     tie(tt, add_at, k, x) = query[jj];\n//                     if (tt == 1 && is_parent(add_at, v) &&\n//                         lc.depth[v] > lc.depth[add_at] + k) {\n//                         res += x;\n//                     }\n//                 }\n//                 return res + dist[v];\n//             };\n\n//             int t, u, v;\n//             tie(t, u, v, ignore) = query[j];\n\n//             if (t == 2) {\n//                 int l = lc.get(u, v);\n//                 cout << f(u) + f(v) - 2*f(l) << '\\n';\n//             }\n//         }\n\n//         for (int j = 0; j < N; ++j) {\n//             add_at[j].clear();\n//         }\n//         for (int j = left; j < right; ++j) {\n//             int t, v, k, x;\n//             tie(t, v, k, x) = query[j];\n//             if (t == 1)\n//                 add_at[v].push_back(make_pair(k, x));\n//         }\n//         stk.assign(N, 0);\n//         add_many(0, -1);\n//     }\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Semigroup >\nstruct Node {\n  Node *l, *r, *p;\n  int idx;\n  Semigroup key, sum;\n  bool rev;\n  int sz;\n\n  Node() = default;\n\n  Node(int idx, const Semigroup &v) {\n    init_node(idx, v);\n  }\n\n  void init_node(int idx, const Semigroup &v) {\n    this->idx = idx;\n    this->key = this->sum = v;\n    this->l = this->r = this->p = nullptr;\n    rev = false;\n    sz = 1;\n  }\n\n  void push() {\n    if(rev) {\n      swap(l, r);\n      if(l) l->rev ^= true;\n      if(r) r->rev ^= true;\n    }\n  }\n\n  bool is_root() {\n    return !p || (p->l != this && p->r != this);\n  }\n\n  void update() {\n    sz = 1;\n    sum = key;\n    if(l) sz += l->sz, sum = l->sum + sum;\n    if(r) sz += r->sz, sum = sum + r->sum;\n  }\n\n  void rotr() { // 右回転\n    auto *x = p, *y = x->p;\n    if((x->l = r)) r->p = x;\n    r = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void rotl() { // 左回転\n    auto *x = p, *y = x->p;\n    if((x->r = l)) l->p = x;\n    l = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void splay() {\n    push();\n    while(!is_root()) {\n      auto *q = p;\n      if(q->is_root()) {\n        q->push(), push();\n        if(q->l == this) rotr();\n        else rotl();\n      } else {\n        auto *r = q->p;\n        r->push(), q->push(), push();\n        if(r->l == q) {\n          if(q->l == this) q->rotr(), rotr();\n          else rotl(), rotr();\n        } else {\n          if(q->r == this) q->rotl(), rotl();\n          else rotr(), rotl();\n        }\n      }\n    }\n  }\n\n  Node *expose() {\n    Node *rp = nullptr;\n    for(Node *cur = this; cur; cur = cur->p) {\n      cur->splay();\n      cur->r = rp;\n      cur->update();\n      rp = cur;\n    }\n    splay();\n    return rp;\n  }\n\n  void link(Node *parent) {\n    expose();\n    parent->expose();\n    p = parent;\n    parent->r = this;\n  }\n\n  void cut() {\n    expose();\n    auto *parent = l;\n    l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert() {\n    expose();\n    rev ^= true;\n    push();\n  }\n\n  Node *lca(Node *t) {\n    t->expose();\n    return expose();\n  }\n};\n\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n\n  Node< int > uku[100000];\n  for(int i = 0; i < N; i++) {\n    uku[i].init_node(i, 0);\n  }\n\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      uku[T].link(&uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    printf(\"%d\\n\", uku[V].lca(&uku[U])->idx);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 50;\nvector<int> G[MAX_V];\nint root;\n\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    dfs(root, -1, 0);\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u]) >> k & (int)1){\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n}\n\nsigned main(){\n    int n, k, q, c;\n    root = 0;\n    cin >> n;\n    rep(i, 0, n){\n        cin >> k;\n        rep(j, 0, k){\n            cin >> c;\n            G[i]. push_back(c);\n            G[c]. push_back(i);\n        }\n    }\n    init(n);\n    cin >> q;\n    rep(i, 0, q){\n        int u, v;\n        cin >> u >> v;\n        int tmp = lca(u, v);\n        cout << tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> > t,int n)\n    :tree(t),n(n),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree,n);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1<<17,MAX_LOG=20,INF=1<<30;\nvector<pair<int,ll>> G[MAX];\nint N,par[MAX_LOG][MAX],depth[MAX];\nll dis[MAX];\n\nvoid BFS(int u){\n    for(int i=0;i<N;i++){\n        depth[i]=-1;\n        dis[i]=0;\n        for(int j=0;j<20;j++){\n            par[j][i]=-1;\n        }\n    }\n    queue<int> Q;\n    Q.push(u);\n    depth[u]=0;\n    dis[u]=0;\n    while(!Q.empty()){\n        int a=Q.front();\n        Q.pop();\n        for(int i=0;i<G[a].size();i++){\n            int b=G[a][i].first;\n            ll c=G[a][i].second;\n            if(depth[b]==-1){\n                depth[b]=depth[a]+1;\n                dis[b]=dis[a]+c;\n                par[0][b]=a;\n                Q.push(b);\n            }\n        }\n    }\n    return;\n}\n\nvoid init(){\n    for(int k=0;k+1<MAX_LOG;k++){\n        for(int i=0;i<N;i++){\n            if(par[k][i]<0) par[k+1][i]=-1;\n            else par[k+1][i]=par[k][par[k][i]];\n        }\n    }\n}\n\nint lca(int u,int v){\n    if(depth[u]>depth[v]) swap(u,v);\n    for(int i=0;i<20;i++){\n        if(((depth[v]-depth[u])>>i)&1) v=par[i][v];\n    }\n    if(u==v) return u;\n    \n    for(int i=19;i>=0;i--){\n        if(par[i][u]!=par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\n\nint main(){\n\n    cin>>N;\n    for(int i=0;i<N;i++){\n        int k;cin>>k;\n        for(int j=0;j<k;j++){\n            int a;cin>>a;\n            G[i].push_back({a,1});\n            G[a].push_back({i,1});\n        }\n    }\n    \n    BFS(0);\n    init();\n    \n    int Q;cin>>Q;\n    while(Q){\n        int a,b;cin>>a>>b;\n        cout<<lca(a,b)<<endl;\n        \n        Q--;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size) {for(int i=0;i<size;i++)data[i]=i;}\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    //if (x != y) {\n      //if (data[y] < data[x]) swap(x, y);\n      //data[x] += data[y];\n\t  data[y] = x;\n    //}\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x]==x ? x : (data[x] = root(data[x]));\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nclass TreeSqrtDecomp {\n    int n, B;\n    int size() const { return n; }\n    // block_id[v]: vが属するblock\n    vi block_id, parent, depth, roots, visited;\n    vvi adj;\npublic:\n    vector<set<int>> block_nodes;\n    TreeSqrtDecomp(int n_) : n(n_), adj(n) {\n        int l = 0, r = n;\n        while (l < r - 1) {\n            i64 m = (l + r) / 2;\n            if (m * m >= n) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        B = r;\n    }\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    void decomp(int root = 0) {\n        block_id.assign(n, -1);\n        parent.assign(n, -1);\n        depth.assign(n, 0);\n        visited.assign(n, 0);\n        vi q(n + 1);\n        int l = 0, r = 0;\n        q[r++] = root;\n        while (l != r) {\n            int v = q[l++];\n            visited[v] = 1;\n            roots.push_back(v);\n            for (int c : adj[v]) {\n                if (!visited[c]) {\n                    parent[c] = v;\n                    depth[c] = depth[v] + 1;\n                    q[r++] = c;\n                }\n            }\n        }\n        int c = 0;\n        for (int u : roots) {\n            if (block_id[u] != -1) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for (int i = 0; i < B && l != r; i++) {\n                int v = q[l++];\n                block_id[v] = c;\n                for (int c : adj[v]) {\n                    if (block_id[c] == -1) {\n                        q[r++] = c;\n                    }\n                }\n            }\n            c++;\n        }\n        block_nodes = vector<set<int>>(c);\n        for (int i = 0; i < n; i++) {\n            block_nodes[block_id[i]].insert(i);\n        }\n    }\n    int get_block_root_by_id(int block_id) {\n        return roots[block_id];\n    }\n    int get_block_root(int node) {\n        return get_block_root_by_id(get_block_id(node));\n    }\n    int lca(int u, int v) {\n        while (depth[get_block_root(u)] > depth[get_block_root(v)]) u = parent[get_block_root(u)];\n        while (depth[get_block_root(u)] < depth[get_block_root(v)]) v = parent[get_block_root(v)];\n        while (depth[u] > depth[v]) u = parent[u];\n        while (depth[u] < depth[v]) v = parent[v];\n        while (u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n    int block_cnt() {\n        return roots.size();\n    }\n    int dist(int u, int v) {\n        int w = lca(u, v);\n        return depth[u] - depth[w] + depth[v] - depth[w];\n    }\n    bool in_same_block(int u, int v) {\n        return get_block_root(u) == get_block_root(v);\n    }\n    int get_block_id(int node) {\n        return block_id[node];\n    }\n    int get_parent(int node) {\n        return parent[node];\n    }\n    int get_depth(int node) {\n        return depth[node];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    TreeSqrtDecomp tree(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a;\n            cin >> a;\n            tree.addEdge(i, a);\n        }\n    }\n    tree.decomp();\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    //buildPaths(0,newPath(0));\n    //len.resize(pathCount);\n    /*\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define all(c) (c).begin(),(c).end()\n\n#define maxv 100000\n\nusing namespace std;\n\nint n,len;\nvector<int> tree[maxv], in, out, up[100];\n\nvoid dfs(int u, int p, int &k){\n  in[u] = k++;\n  up[0][u] = p;\n  for(int i = 1; i < len; i++)\n    up[i][u] = up[i - 1][up[i - 1][u]];\n\n  for(int i = 0; i < tree[u].size(); i++){\n    if(tree[u][i] != p)dfs(tree[u][i],u,k);\n  }\n  out[u] = k++;\n}\n\nvoid init(int root){\n  len = 1;\n  while((1 << len) <= n)len++;\n  for(int i=0;i<len;i++){\n    up[i].resize(n);\n    fill(all(up[i]),0);\n  }\n  in.resize(n);\n  out.resize(n);\n  fill(all(in),0);\n  fill(all(out),0);\n  int k=0;\n  dfs(root,root,k);\n}\n\nbool isParent(int parent, int child){\n  return in[parent] <= in[child] && out[child] <= out[parent];\n}\n\nint lca(int a, int b){\n  if(isParent(a,b))return a;\n  if(isParent(b,a))return b;\n  for(int i = len - 1; i >= 0; i--){\n    if(!isParent(up[i][a],b))a = up[i][a];\n  }\n  return up[0][a];\n}\n\n\nint main(void){\n\n  cin >> n;\n  for(int i=0;i<n;i++){\n    int k,c;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> c;\n      tree[i].push_back(c);\n    }\n  }\n\n  init(0);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << lca(u,v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, ans, sum, last, cnt;\nstruct Edge { LL to,cost; };\nvector<Edge>vec[100010];\nstring str;\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node, num;\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tvec[u].erase(vec[u].begin()+j);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n\n\n\nclass LCA{\n\tint n;\n\tstd::vector<int> _depth,idx;\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tint minimum(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return _depth.size()-1;\n\t\tif(a<=l&&r<=b)return idx[k];\n\t\telse{\n\t\t\tint vl=minimum(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=minimum(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn _depth[vl]<_depth[vr]?vl:vr;\n\t\t}\n\t}\n\tvoid buildRMQ(){\n\t\tn=calcsize(_depth.size());\n\t\tidx.resize(2*n-1);\n\t\tfor(int i=0;i<(int)_depth.size();i++)idx[n-1+i]=i;\n\t\tfor(int i=_depth.size();i<n;i++)idx[n-1+i]=_depth.size();\n\t\t_depth.push_back(INT_MAX);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tidx[i]=_depth[idx[i*2+1]]<_depth[idx[i*2+2]]?idx[i*2+1]:idx[i*2+2];\n\t\t}\n\t}\n\t\n\tstd::vector<int> eulertour;\n\tstd::vector<int> in;\n\tvoid dfs(const std::vector<int> edge[],int d,int u){\n\t\tin[u]=eulertour.size();\t\n\t\teulertour.push_back(u);\n\t\t_depth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,d+1,edge[u][i]);\n\t\t\teulertour.push_back(u);\n\t\t\t_depth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const std::vector<int> edge[],int n,int root):in(n){\n\t\tdfs(edge,1,root);\n\t\teulertour.push_back(root);\n\t\t_depth.push_back(0);\n\t\tbuildRMQ();\n\t}\n\tint query(int u,int v)const{//uとvの最小共通祖先\n\t\tif(u==v)return u;\n\t\tif(in[u]>in[v])std::swap(u,v);\n\t\treturn eulertour[minimum(in[u], in[v],0,0,n)];\n\t}\n\tint depth(int u)const{//rootの深さが1\n\t\treturn _depth[in[u]];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end());\n#define MAX(vec) *max_element(vec.begin(), vec.end());\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end());\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define TO_INT(vec,s) REP(i,s.length()){vec.push_back(s[i] - ‘0’);}\n#define ENUM_v(vec) for (auto e : vec)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\nusing namespace std;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\n\ntemplate <typename T,typename D>\nclass Tree {\nprivate:\n\ttypedef struct {T node;D dist;T prev;} P;\n\ttypedef pair<T,D> pr;\n\ttypedef vector<pr> VP;\n\tvector<VP> E;\n\tT V;\n\tT root;\n\tT log_2;\n\tvector<vector<T>> parent;\n\tvector<T> depth;\npublic:\n\tTree() : V(0){}\n\tTree(T v) : V(v),E(v) {}\n\n\tvoid addEdgeDirected(T start,T goal,D weight){\n\t\tE[start].push_back(pr(goal,weight));\n\t}\n\n\tvoid addEdgeUndirected(T start,T goal,D weight){\n\t\tE[start].push_back(pr(goal,weight));\n\t\tE[goal].push_back(pr(start,weight));\n\t}\n\n\tpair<T,D> farthest(T node){ // nodeからの最遠点(頂点,距離)\n\t\tvector<T> Dis;\n\t\tcalcDist(node,Dis);\n\t\tT ret = (-1),dist = (-1);\n\t\tREP(i,V) {\n\t\t\tif (dist < Dis[i]) {\n\t\t\t\tret = i;\n            \tdist = Dis[i];\n\t\t\t}\n\t\t}\n\t\treturn (pair<T,D>(ret,dist));\n\t}\n\n\tvoid calcDist(T v, vector<D>& Dis) {\n    \tDis.clear(); Dis.resize(V,loINF);\n    \tDis[v] = 0;\n    \tqueue<T> Q;\n    \tQ.push(v);\n    \twhile (!Q.empty()) {\n        \tT c = Q.front(); Q.pop();\n        \tREP(i,E[c].size()) {\n            \tif (Dis[E[c][i].first] > Dis[c] + E[c][i].second) {\n                \tDis[E[c][i].first] = Dis[c] + E[c][i].second;\n                \tQ.push(E[c][i].first);\n            \t}\n            }\n        }\n    }\n\n\tvector<T> getHeight(void) { //全部のnodeの最遠距離。\n\t\tvector<T> Dis(V);\n\t\tT x = farthest(0).first;\n   \t\tT y = farthest(x).first;\n    \tvector<T> DX; calcDist(x, DX);\n    \tvector<T> DY; calcDist(y, DY);\n    \tREP(i,V) Dis[i] = max(DX[i],DY[i]);\n    \treturn Dis;\n\t}\n\n\tpair<T,D> getDiameter(void){\n\t\tstack<P> st;\n\t\tpair<T,D> farV(V-1,0);\n\t\tst.push(P {V-1,0,-1});\n\t\twhile (!st.empty()) {\n\t\t\tP e = st.top();\n\t\t\tst.pop();\n\t\t\tif (farV.second < e.dist) farV = pair<T,D> (e.node,e.dist);\n\t\t\tfor ( auto &p : E[e.node]) {\n\t\t\t\tif (p.first != e.prev) st.push(P {p.first,e.dist+p.second,e.node});\n\t\t\t}\n\t\t}\n\t\tpair<T,D> farV2(farV.first,0);\n\t\tst.push(P {farV.first,0,-1});\n\t\twhile (!st.empty()) {\n\t\t\tP e = st.top();\n\t\t\tst.pop();\n\t\t\tif (farV2.second < e.dist) farV2 = pair<T,D> (e.node,e.dist);\n\t\t\tfor ( auto &p : E[e.node]) {\n\t\t\t\tif (p.first != e.prev) st.push(P {p.first,e.dist+p.second,e.node});\n\t\t\t}\n\t\t}\n\t\treturn farV2;\n\t}\n\n\tvoid lca(T r) {\n\t\troot = r;log_2 = (log2(V) + 1);parent = vector<vector<T>>(log_2,vector<T>(V));depth = vector<T>(V);\n\t\tstack<P> st;\n\t\tst.push(P{root,0,-1});\n\t\twhile (!st.empty()) {\n\t\t\tP nd = st.top();st.pop();\n\t\t\tparent[0][nd.node] = nd.prev;\n\t\t\tdepth[nd.node] = nd.dist;\n\t\t\tREP(i,E[nd.node].size()) {\n\t\t\t\tif (E[nd.node][i].first != nd.prev){\n\t\t\t\t\tst.push(P{E[nd.node][i].first,nd.dist+E[nd.node][i].second,nd.node});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(k,log_2-1) {\n            REP(v,V) {\n                if (parent[k][v] < 0) parent[k + 1][v] = -1;\n                else parent[k + 1][v] = parent[k][parent[k][v]];\n            }\n        }\n        //dump2d_arr(parent);\n\t}\n\tT query(T n1,T n2) {\n\t\t\tif (depth[n1] > depth[n2]) std::swap(n1, n2);\n        \tfor (int k = 0; k < log_2; k++) {\n            \tif ((depth[n2] - depth[n1]) >> k & 1) {\n                \tn2 = parent[k][n2];\n            \t}\n        \t}\n        \tif (n1 == n2) return n1;\n        \tfor (int k = log_2 - 1; k >= 0; k--) {\n            \tif (parent[k][n1] != parent[k][n2]) {\n                \tn1 = parent[k][n1];\n                \tn2 = parent[k][n2];\n            \t}\n        \t}\n        return parent[0][n1];\n\t}\n};\n\nint main(void) {\n\tlong n,k,u,q,r,s;\n\tcin >> n;\n\tTree<long,long> tr(n);\n\tREP(i,n) {\n\t\tcin >> k;\n\t\tREP(j,k) {\n\t\t\tcin >> u;\n\t\t\ttr.addEdgeUndirected(i,u,1);\n\t\t}\n\t}\n\ttr.lca(0);\n\tcin >> q;\n\tREP(i,q) {\n\t\tcin >> r >> s;\n\t\tcout << tr.query(r,s) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100001;\nint N, k, cs, P[maxn], lca[maxn][17], L[maxn], Q;\nvector<int> A[maxn];\n\n\nvoid dfs( int v, int lvl ){\n\n\tL[v] = lvl;\n\tvector<int>::iterator x = A[v].begin();\n\tfor( ; x != A[v].end(); ++x )\n\t\tdfs( *x, lvl + 1 );\n}\n\n\nvoid preLCA(){\n\n\tfor( int i = 0; i < N; ++i )\n\t\tfor( int j = 0; ( 1 << j ) < N; ++j )\n\t\t\tlca[i][j] = -1;\n\n\t\t\t\n\tfor( int i = 0; i < N; ++i )\n\t\tlca[i][0] = P[i];\n\n\n\tfor( int i = 1; ( 1 << i) < N; ++i )\n\t\tfor( int j = 0; j < N; ++j )\n\t\t\tif(lca[i][j] != - 1)\n\t\t\t\tlca[i][j] = lca[lca[i][j - 1]][j - 1];\n}\n\nint findlca( int nx, int ny ){\n\n\tif( L[nx] < L[ny] )\n\t\tswap(nx, ny);\n\n\tint lg = 0;\n\n\tfor( ; (1 << lg) <= L[nx]; ++lg );\n\t--lg;\n\n\tfor( int i = lg; i >= 0; --i )\n\t\tif( L[nx] - ( 1 << i) >= L[ny] )\n\t\t\tnx = lca[nx][i];\n\n\tif( nx == ny )\n\t\treturn nx;\n\n\tfor( int i = lg; i >= 0; --i )\n\t\tif( lca[nx][i] != -1 && lca[nx][i]!=lca[ny][i] )\n\t\t\tnx = lca[nx][i], ny = lca[ny][i];\n\n\treturn P[nx];\n}               \n\n\n\n\n\n\nint main( void ){\n\n\t//freopen(\"input.in\", \"r\", stdin);\n    scanf(\"%d\", &N);\n\n    for( int i = 0; i < N; ++i ){\n    \tscanf(\"%d\", &k);\n    \tfor( int j = 0; j < k; ++j )\n    \t\tscanf(\"%d\", &cs), A[i].push_back(cs), P[cs] = i; \n    }\n\t\n\tdfs(0, 0);\n\tpreLCA();\n\tscanf(\"%d\", &Q);\n\tint a, b;\n\tfor( ; Q > 0; --Q ){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tprintf(\"%d\\n\", findlca(a, b));\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass LowestCommonAncestor\n{\nprivate:\n    vector<vector<int> > to; // ??????????????°\n    vector<int> depth;       // ??????????????±???\n    int climb(int curr, int dist)\n    {\n        int i = 0;\n        while(dist > 0){\n            if(dist % 2 == 1)\n                curr = to[curr][i];\n            dist /= 2;\n            ++ i;\n        }\n        return curr;\n    }\npublic:\n    LowestCommonAncestor(const vector<vector<int> >& edges, int root)\n    {\n        int n = edges.size();\n        to.assign(n, vector<int>());\n        depth.resize(n);\n\n        queue<pair<int, int> > q;\n        q.push(make_pair(root, -1));\n\n        int cnt = 0;\n        while(!q.empty()){\n            int m = q.size();\n            while(--m >= 0){\n                int curr, prev;\n                tie(curr, prev) = q.front();\n                q.pop();\n\n                depth[curr] = cnt;\n                if(prev != -1){\n                    to[curr].push_back(prev);\n                    int j = prev;\n                    for(unsigned k=0; k<to[j].size(); ++k){\n                        j = to[j][k];\n                        to[curr].push_back(j);\n                    }\n                }\n\n                for(int next : edges[curr]){\n                    if(next != prev)\n                        q.push(make_pair(next, curr));\n                }\n            }\n            ++ cnt;\n        }\n    }\n    // 2??????????????????????°???±????\\?????????????\n    int getAncestor(int a, int b)\n    {\n        int diff = depth[a] - depth[b];\n        if(diff < 0)\n            b = climb(b, -diff);\n        else\n            a = climb(a, diff);\n        if(a == b)\n            return a;\n\n        for(int i=to[a].size()-1; i>=0; --i){\n            if(i < (int)to[a].size() && to[a][i] != to[b][i]){\n                a = to[a][i];\n                b = to[b][i];\n            }\n        }\n        return to[a][0];\n    }\n    // ??????????????±????????????\n    int getDepth(int a)\n    {\n        return depth[a];\n    }\n    // 2???????????????????????¢?????????\n    int getDist(int a, int b)\n    {\n        int c = getAncestor(a, b);\n        return getDepth(a) + getDepth(b) - getDepth(c) * 2;\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int> > edges(n);\n    for(int i=0; i<n; ++i){\n        int k;\n        cin >> k;\n        while(--k >= 0){\n            int j;\n            cin >> j;\n            edges[i].push_back(j);\n        }\n    }\n\n    LowestCommonAncestor lca(edges, 0);\n\n    int q;\n    cin >> q;\n    while(--q >= 0){\n        int u, v;\n        cin >> u >> v;\n        cout << lca.getAncestor(u, v) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PI 4*atan(1.0)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int SIZE=100001;\n//int arr[SIZE]={};\n//???????????§???????????¬\nconst int MAX_V=100001;\nconst int MAX_LOGV=32;\n//??°???????????£??\\???????????¨???????????????v??¨???????????£????????????????????\\??£????????????\nvector<int> G[MAX_V];\n//??????2^k????????£????????????????????????\nint parent[MAX_LOGV][MAX_V]={};\n//??????????????±???\nint depth[MAX_V]={};\n//?????????????????????\nint root=0;\nvoid dfs(int v,int p,int d);\nvoid init(int v);\nint lca(int u,int v);\n \nint main(){\n\tint N;\n\tcin>>N;\n\tfor(int i=0;i<N;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tinit(N);\n\tint Q;\n\tcin>>Q;\n\tfor(int i=0;i<Q;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<lca(a,b)<<endl;\n\t}\n\treturn 0;\n}\n \n//?????°v,p,d?????????????????§??±???????????¢?´¢?????????\nvoid dfs(int v,int p,int d){\n\t//parent[0][v]????????????v??????1????????£??????????????????p?????£??\\\n\tparent[0][v]=p;\n\t//depth[v]????????????v?????±?????????d?????£??\\\n\tdepth[v]=d;\n\t//G[v]??????????????????G[v][i]???p??§????????????\n\t//dfs(G[v][i],v,d+1)????????¶\n\t//?????????????????????????????????????????£?????°??????????????????????????§??????\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tdfs(G[v][i],v,d+1);\n\t\t}\n\t}\n}\n//?????????\n//V?????????????????°\nvoid init(int V){\n\t//?????????dfs???????????????\n\t//????????????????????????????????????parent[0]??¨depth?????????\n\tdfs(root,-1,0);\n\t//parent????????????\n\tfor(int k=0;k+1<MAX_LOGV;k++){\n\t\tfor(int v=0;v<V;v++){\n\t\t\tif(parent[k][v]<0)\n\t\t\t\tparent[k+1][v]=-1;\n\t\t\telse\n\t\t\t\tparent[k+1][v]=parent[k][parent[k][v]];\n\t\t}\n\t}\n}\n//u??¨v???LCA????±???????\nint lca(int u,int v){\n\t//u??¨v?????±??????????????????????????§????????????\n\t//u??¨v??????????????????????????????????????????????????????????????????\n\tif(depth[u]>depth[v])\n\t\tswap(u,v);\n\tfor(int k=0;k<MAX_LOGV;k++){\n\t\tif(((depth[v]-depth[u])>>k)&1)\n\t\t\tv=parent[k][v];\n\t}\n\t//u=v??????????????????LCA??§????????????v?????????\n\tif(u==v)\n\t\treturn v;\n\t//???????????????????????¢?´¢??§LCA????±???????\n\t//u,v???????????????????????§??????\n\tfor(int k=MAX_LOGV-1;k>=0;k--){\n\t\tif(parent[k][u]!=parent[k][v]){\n\t\t\tu=parent[k][u];\n\t\t\tv=parent[k][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\n    template<class...T>\n    ostream & operator << (ostream &os, tuple<T...> const &t){\n        _ot<0>(os, t); return os;\n    }\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, last, next, prev, chain, at;\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(auto & e : es) addEdge(e >> 32, e & 0xFFFFFFFF);\n    }\n    // heavy edgeからなるパスの頂点列\n    vector<vector<int>> chains;\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // 属する頂点が刺さっている chain の付け根に移る．ないなら -1．\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        last.assign(size, 0);\n        next.assign(size, -1);\n        prev.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                last[v] = path.back();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                prev[v] = i != 0 ? path[i-1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nsigned main(){\n    fastios();\n    int N;\n    cin >> N;\n    Graph g(N);\n    rep(i,N){\n        int k;\n        cin >> k;\n        rep(kk,k){\n            int a;\n            cin >> a;\n            g[a].eb(i,a);\n        }\n    }\n    HeavyLightDecomposition hld(g);\n    hld.decompose();\n    int q;\n    cin >> q;\n    rep(qq,q){\n        int a,b;\n        cin >> a >> b;\n        cout << hld.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Lca {\n    int N;\n    int logN;\n    vector<int> depths;\n    vector<vector<int>> edge;\n\n    // dop[i][j]: 2^j th parent node from i th node\n    vector<vector<int>> dp;\n\n    void calc_depth(int cur, int par, int depth) {\n        depths[cur] = depth;\n        dp[cur][0] = par;\n        for (int ch : edge[cur]) {\n            if (ch == par) continue;\n            calc_depth(ch, cur, depth + 1);\n        }\n    }\n\n    void calc_dp() {\n        for (int k = 1; k < logN; k++) {\n            for (int i = 0; i < N; i++) {\n                if (dp[i][k - 1] == -1) {\n                    dp[i][k] = -1;\n                } else {\n                    dp[i][k] = dp[dp[i][k - 1]][k - 1];\n                }\n            }\n        }\n    }\n\npublic:\n    Lca(const vector<vector<int>> &edge, int root) : edge(edge) {\n        N = edge.size();\n        logN = (sizeof(int) * 8) - __builtin_clz(N);\n        depths.resize(N);\n        dp.resize(N);\n        for (int i = 0; i < N; i++) dp[i].resize(logN, -1);\n        calc_depth(root, -1, 0);\n        calc_dp();\n    }\n\n    // O(logN)\n    int lca(int u, int v) {\n        // assume depths[u] <= depths[v]\n        if (depths[u] > depths[v]) swap(u, v);\n\n        // equalize depth\n        int diff = depths[v] - depths[u];\n        for (int k = 0; k < logN; k++) {\n            if ((diff >> k) & 1) {\n                v = dp[v][k];\n            }\n        }\n\n        if (u == v) return u;\n\n        for (int k = logN - 1; k >= 0; k--) {\n            if (dp[u][k] != dp[v][k]) {\n                u = dp[u][k];\n                v = dp[v][k];\n            }\n        }\n\n        return dp[u][0];\n    }\n};\n\n\n// verified\n//  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=ja\nvoid AOJ_GRL_5_C() {\n    int n, k, c, q, u, v;\n    cin >> n;\n    vector<bool> is_root(n, true);\n    vector<vector<int>> edge(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            cin >> c;\n            is_root[c] = false;\n            edge[i].push_back(c);\n            edge[c].push_back(i);\n        }\n    }\n    int root = -1;\n    for (int i = 0; i < n; i++) if (is_root[i]) root = i;\n    Lca lca(edge, root);\n    cin >> q;\n    while (q--) {\n        cin >> u >> v;\n        cout << lca.lca(u, v) << '\\n';\n    }\n}\n\nint main() {\n    AOJ_GRL_5_C();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <unordered_map>\n#include <complex>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nstruct heavy_light_decomposition{\n\tstruct node{\n\t\tint chainid, index;\n\t};\n\tstruct chain{\n\t\tint parchain, parnode, depth, length;\n\t};\n\n\tint n;\n\tvector<node> nodes;\n\tvector<chain> chains;\n\tvector<int> size, par;\n\tvector<vector<int>> G;\n\n\theavy_light_decomposition(int _n):n(_n){\n\t\tG.resize(n);\n\t\tsize.resize(n);\n\t\tpar.resize(n);\n\t}\n\tvoid add_edge(int a, int b){\n\t\tG[a].emplace_back(b);\n\t\tG[b].emplace_back(a);\n\t}\n\n\tvoid build(int root = 0){\n\t\tstack<int> in, out;\n\t\tin.push(root);\n\t\tpar[root] = -1;\n\t\t// set parent\n\t\twhile (!in.empty()){\n\t\t\tint v = in.top(); in.pop();\n\t\t\tout.push(v);\n\t\t\tfor (auto &e : G[v]){\n\t\t\t\tif (e == par[v]) continue;\n\t\t\t\tpar[e] = v;\n\t\t\t\tin.push(e);\n\t\t\t}\n\t\t}\n\t\t// calculate size\n\t\twhile (!out.empty()){\n\t\t\tint v = out.top(); out.pop();\n\t\t\tsize[v] = 1;\n\t\t\tfor (auto &e : G[v]){\n\t\t\t\tif (e == par[v]) continue;\n\t\t\t\tsize[v] += size[e];\n\t\t\t}\n\t\t}\n\t\tdecomposition(root);\n\t}\n\n\tvoid decomposition(int root){\n\t\tnodes.assign(n, { -1, -1 });\n\t\tstack<int> in;\n\t\tin.push(root);\n\t\twhile (!in.empty()){\n\t\t\tint v = in.top(); in.pop();\n\t\t\tint &cid = nodes[v].chainid;\n\t\t\tif (cid < 0){\n\t\t\t\tint pid = par[v];\n\t\t\t\tint pcid = pid < 0 ? -1 : nodes[par[v]].chainid;\n\t\t\t\tcid = chains.size();\n\t\t\t\tchains.push_back({ pcid, pid, pcid < 0 ? 0 : chains[pcid].depth + 1, 1 });\n\t\t\t}\n\t\t\tnodes[v].index = chains[cid].length++;\n\n\t\t\tpair<int, int> heavy(-1, -1);\n\t\t\tfor (auto &e : G[v]){\n\t\t\t\tif (e == par[v]) continue;\n\t\t\t\theavy = max(heavy, make_pair(size[e], e));\n\t\t\t}\n\t\t\tif (heavy.first < 0) continue;\n\t\t\tfor (auto &e : G[v]){\n\t\t\t\tif (e == par[v]) continue;\n\t\t\t\tif (heavy.second == e) nodes[e].chainid = cid;\n\t\t\t\tin.push(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tint chain(int v){\n\t\treturn nodes[v].chainid;\n\t}\n\n\tint lca(int u, int v){\n\t\twhile (chain(u) != chain(v)){\n\t\t\tint &x = (chains[chain(u)].depth > chains[chain(v)].depth ? u : v);\n\t\t\tx = chains[chain(x)].parnode;\n\t\t}\n\t\treturn nodes[u].index < nodes[v].index ? u : v;\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\tint n;\n\tcin >> n;\n\n\theavy_light_decomposition hld(n);\n\n\trep(i, n){\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j, k){\n\t\t\tint ch;\n\t\t\tcin >> ch;\n\t\t\thld.add_edge(i, ch);\n\t\t}\n\t}\n\n\thld.build();\n\n\tint q;\n\tcin >> q;\n\twhile (q--){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << hld.lca(u, v) << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint n;\nvector<int> c[100005];\nconst int K = log2(100005);\nint parent[K][100005];\nint depth[100005];\n\nvoid dfs(int v, int p, int d) {\n  parent[0][v] = p;\n  depth[v] = d;\n  for (auto i: c[v]) {\n    dfs(i, v, d + 1);\n  }\n}\n\nvoid init() {\n  dfs(0, -1, 0);\n  for (int k = 0; k + 1 < K; k++) {\n    for (int v = 0; v < n; v++) {\n      if (parent[k][v] < 0) parent[k + 1][v] = -1;\n      else parent[k + 1][v] = parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u, int v) {\n  if (depth[u] > depth[v]) swap(u, v);\n  for (int k; k < K; k++) {\n    if ((depth[v] - depth[u] >> k & 1)) {\n      v = parent[k][v];\n    } \n    if (u == v) return u;\n  }\n  for (int k = K - 1; k >= 0; k--) {\n    if (parent[k][u] != parent[k][v]) {\n      u = parent[k][u];\n      v = parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      int cj;\n      cin >> cj;\n      c[i].push_back(cj);\n    }\n  }\n\n  init();\n\n  int q;\n  cin >> q;\n  rep(i, q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca(u, v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from = -1, int to = -1, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int from, int to, Cost cost = 1) {\n        path[from].push_back(Edge<Cost>(from, to, cost));\n    }\n    std::vector<Edge<Cost>>& operator[](int v) { return path[v]; }\n};\n\ntemplate <class Cost = int>\nclass HeavyLightDecomposition {\nprivate:\n    Graph<Cost> graph;\n    std::vector<int>\n        size,       // 部分木の頂点数\n        in, rev,    // 行きがけ順と復元\n        par, head;  // 1つ上とパスの根の頂点\n    int time;       // inを埋めるのに使う\n\n    // par, sizeを埋める\n    int sz_dfs(int v, int r) {\n        par[v] = r;\n        size[v] = 1;\n\n        // 先頭が親だと不便なので末尾と交換\n        if (!graph[v].empty() && graph[v].front().to == r) {\n            std::swap(graph[v].front(), graph[v].back());\n        }\n\n        for (auto& e : graph[v]) {\n            if (e.to == r) continue;\n            size[v] += sz_dfs(e.to, v);\n            // graph[v]の先頭に一番sizeが大きい子が来るようにする\n            if (size[graph[v][0].to] < size[e.to]) std::swap(graph[v][0], e);\n        }\n        return size[v];\n    }\n\n    // in, rev, headを埋める\n    void in_dfs(int v, int r) {\n        in[v] = time++;\n        rev[in[v]] = v;\n\n        for (auto& e : graph[v]) {\n            if (e.to == r) continue;\n            // 先にgraph[v]の先頭に一番sizeが大きい子が来るようにした\n            // よって先頭の子をvのパスに加える\n            head[e.to] = (graph[v][0].to == e.to ? head[v] : e.to);\n            in_dfs(e.to, v);\n        }\n    }\n\npublic:\n    HeavyLightDecomposition(const Graph<Cost>& g, int root)\n        : graph(g), size(g.size), in(g.size), rev(g.size), par(g.size), head(g.size) {\n        sz_dfs(root, -1);\n        time = 0;\n        in_dfs(root, -1);\n    }\n\n    int lca(int u, int v) {\n        while (true) {\n            if (in[u] > in[v]) std::swap(u, v);\n            if (head[u] == head[v]) break;\n            v = par[head[v]];\n        }\n        // u, vは同じパス上にある\n        // in[u] <= in[v]よりuはvより上にあるため、uがLCAとなる\n        return u;\n    }\n};\n\n\nint main() {\n    int N;\n    std::cin >> N;\n    Graph<> tree(N);\n    for (int v = 0; v < N; ++v) {\n        int k;\n        std::cin >> k;\n        for (int i = 0; i < k; ++i) {\n            int c;\n            std::cin >> c;\n            tree.span(v, c);\n        }\n    }\n\n    HeavyLightDecomposition<int> hld(tree, 0);\n\n    int Q;\n    std::cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int u, v;\n        std::cin >> u >> v;\n        std::cout << hld.lca(u, v) << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> >dp(100000,vector<int>(20,-1));\nvector<int>dep(100000);\nint lca(int u,int v){\n\tif(dep[u]>dep[v])swap(u,v);\n\tfor(int i=19;i>=0;i--){\n\t\tif(dp[v][i]!=-1&&dep[dp[v][i]]>=dep[u]){\n\t\t\tv=dp[v][i];\n\t\t}\n\t}\n\tif(u==v)return u;\n\tfor(int i=19;i>=0;i--){\n\t\tif(dp[u][i]!=dp[v][i]){\n\t\t\tu=dp[u][i];\n\t\t\tv=dp[v][i];\n\t\t}\n\t}\n\treturn dp[u][0];\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tdp[c][0]=i;\n\t\t\tdep[c]=dep[i]+1;\n\t\t}\n\t}\n\tfor(int j=1;j<20;j++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdp[i][j]=(dp[i][j-1]<0?-1:dp[dp[i][j-1]][j-1]);\n\t\t}\n\t}\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tcout<<lca(u,v)<<\"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nclass LCA{\n    int n;\n    vector<int> dep;\n    vector<vector<int>> par;\n    Graph g;\n    const int LOGN_MAX=100;\n    void setDep(int v,int d,Graph& tree){\n        dep[v]=d;\n        for(int i=0;i<tree[v].size();i++) setDep(tree[v][i],d+1,tree);\n    }\n    public:\n    LCA(Graph &tree):n(tree.size()){\n        dep=vector<int>(n);\n        par=vector<vector<int>>(min(LOGN_MAX,int(log(n))+1),vector<int>(n));\n        g=Graph(n);\n        for(int i=0;i<tree.size();i++){\n            for(int j=0;j<tree[i].size();j++){\n                g[tree[i][j]].push_back(i);\n            }\n        }\n\n        bool isTree=true;\n        int root=-1;\n        for(int i=0;i<g.size();i++){\n            if(g[i].size()){\n                isTree&=(g[i].size()==1);\n            }\n            else if(root==-1){\n                root=i;\n                if(g[i].size()==0){\n                setDep(i,0,tree);\n               }\n            }\n            else{\n                isTree=false;\n            }\n        }\n        assert(isTree);\n\n        for(int i=0;i<n;i++){\n            par[0][i]=(g[i].size() ? g[i][0] : i);\n        }\n        for(int i=0;i+1<par.size();i++){\n            for(int j=0;j<par[i].size();j++){\n                par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n\n    int lca(int a,int b){\n        if(dep[a]>dep[b]) swap(a,b);\n        int dist=dep[b]-dep[a];\n        for(int i=0;dist;i++,dist/=2){\n            if(dist%2) b=par[i][b];\n        }\n        assert(dep[a]==dep[b]);\n        while(true){\n            if(a==b) return a;\n            if(par[0][a]==par[0][b]) return par[0][a];\n            int lb=0;\n            int ub=LOGN_MAX;\n            //[ub,LOGN_MAX)->same anc\n            while(ub-lb>0){\n                int mid=(lb+ub)/2;\n                if(par[mid][a]==par[mid][b]) ub=mid;\n                else lb=mid;\n            }\n            a=par[lb][a];\n            b=par[lb][b];\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;j++){\n            int c;\n            cin>>c;\n            g[i].push_back(c);\n        }\n    }\n    LCA lg(g);\n    int q;\n    cin>>q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin>>u>>v;\n        cout<<lg.lca(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PI 4*atan(1.0)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int SIZE=100001;\n//int arr[SIZE]={};\n//???????????§???????????¬\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tGraph G;\n\tfor(int i=0;i<N;i++){\n\t\tEdges E;\n\t\tG.push_back(E);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint l;\n\t\t\tcin>>l;\n\t\t\tG[i].push_back(Edge(i,l,1));\n\t\t\tG[l].push_back(Edge(l,i,1));\n\t\t}\n\t}\n\tint Q;\n\tcin>>Q;\n\tvector<Query> VQ;\n\tfor(int i=0;i<Q;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tVQ.push_back(Query(a,b));\n\t}\n\n\tleastCommonAncestor(G,0,VQ);\n\n\tfor(int i=0;i<Q;i++){\n\t\tcout<<VQ[i].w<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nstruct UnionFindTree {\n    size_t n;\n    vector<int> tree;\n    UnionFindTree(size_t n): n(n) {\n        tree = vector<int>(n, -1);\n    }\n    int find_root(size_t v) {\n        if (tree[v] < 0) return v;\n        return tree[v] = find_root(tree[v]);\n    }\n    bool unite(size_t x, size_t y) {\n        x = find_root(x);\n        y = find_root(y);\n        if (x == y) return false;\n        if (rank(x) < rank(y)) swap(x, y);\n        tree[x] += tree[y];\n        tree[y] = x;\n        return true;\n    }\n    bool has_same_root(size_t x, size_t y) {\n        return find_root(x) == find_root(y);\n    }\n    size_t rank(size_t v) {\n        return -tree[find_root(v)];\n    }\n};\n\nstruct Query {\n    size_t u, v, w;\n    Query() {}\n    Query(size_t u, size_t v): u(u), v(v), w(-1) {}\n};\n\nvoid visit(\n    const Graph &g, size_t u, size_t w, vector<Query> &qs,\n    vector<size_t> &color, vector<size_t> &ancestor, UnionFindTree &tree\n) {\n    ancestor[tree.find_root(u)] = u;\n    for (const Edge &e: g[u]) if (e.dst != w) {\n        visit(g, e.dst, u, qs, color, ancestor, tree);\n        tree.unite(e.src, e.dst);\n        ancestor[tree.find_root(u)] = u;\n    }\n\n    color[u] = 1;\n    for (Query &q: qs) {\n        size_t w=(q.v==u? q.u : (q.u==u? q.v:-1));\n        if (~w && color[w])\n            q.w = ancestor[tree.find_root(w)];\n    }\n}\n\nvoid lcancestor(const Graph &g, vector<Query> &qs, size_t r=0) {\n    size_t V=g.size();\n    UnionFindTree tree(V);\n    vector<size_t> color(V), ancestor(V);\n    visit(g, r, -1, qs, color, ancestor, tree);\n}\n\nint main() {\n    size_t V;\n    scanf(\"%zu\", &V);\n\n    Graph g(V);\n    for (size_t i=0; i<V; ++i) {\n        size_t k;\n        scanf(\"%zu\", &k);\n        for (size_t j=0; j<k; ++j) {\n            size_t c;\n            scanf(\"%zu\", &c);\n\n            join(g, i, c);\n        }\n    }\n\n    size_t q;\n    scanf(\"%zu\", &q);\n\n    vector<Query> qs(q);\n    for (size_t i=0; i<q; ++i) {\n        size_t u, v;\n        scanf(\"%zu %zu\", &u, &v);\n\n        qs[i] = Query(u, v);\n    }\n\n    lcancestor(g, qs);\n    for (size_t i=0; i<q; ++i) \n        printf(\"%zd\\n\", qs[i].w);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val):\n      cnt(1),idx(idx),rev(0),val(val),dat(dat),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  LinkCutTree(F f,G g,H h,P p,T ti,E ei):\n    f(f),g(g),h(h),p(p),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,t->laz);\n    t->dat=g(t->dat,p(t->laz,t->cnt));\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(par);\n    expose(c);\n    par->r=c;\n    c->p=par;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n  \n};\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT::P p=[](int a,size_t b){b++;return a;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n\nsigned main(){\n  GRL_5_C();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\nusing namespace std;\n\n\n//初期化O(n log n) 区間最小値クエリO(1)\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\nclass LCA{\n\tvector<pair<int,int> > eulertour;\n\tvector<int> vertex;\n\tSparseTableRMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u].first=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t\tif(edge[u].empty()){\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,0,root);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u].first<eulertour[v].first && eulertour[v].second<eulertour[u].second)\n\t\t\treturn u;\n\t\tif(eulertour[v].first<eulertour[u].first && eulertour[u].second<eulertour[v].second)\n\t\t\treturn v;\n\t\tif(eulertour[u].first>eulertour[v].first)swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u].second, eulertour[v].first)];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct LowestCommonAncestor{\n  const int MAX_LOG_V = 50;\n  \n  vector<vector<int> > G,parent;\n  int root=0,V;\n  vector<int> depth;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int V):V(V){init();}\n\n  void init(){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    for(int i=0;i<(int)parent.size();i++) parent[i].clear();\n    parent.clear();\n    depth.clear();\n    G.resize(V);\n    parent.resize(MAX_LOG_V,vector<int>(V));\n    depth.resize(V);\n  }\n\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    for(int i=0;i<(int)G[v].size();i++){\n      if(G[v][i]!=p) dfs(G[v][i],v,d+1);\n    }\n  }\n  \n  void construct(){\n    dfs(root,-1,0);\n    for(int k=0;k+1<MAX_LOG_V;k++){\n      for(int v=0;v<V;v++){\n\tif(parent[k][v]<0) parent[k+1][v]=-1;\n\telse parent[k+1][v]=parent[k][parent[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(depth[u]>depth[v]) swap(u,v);\n    for(int k=0;k<MAX_LOG_V;k++){\n      if((depth[v]-depth[u])>>k&1){\n\tv=parent[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=MAX_LOG_V-1;k>=0;k--){\n      if(parent[k][u]!=parent[k][v]){\n\tu=parent[k][u];\n\tv=parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n;\n  LowestCommonAncestor lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.construct();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/06/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_A&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing datas=pair<ll,ll>;\nusing ddatas=pair<double,double>;\nusing tdata=pair<ll,datas>;\nusing vec=vector<ll>;\nusing mat=vector<vec>;\nusing pvec=vector<datas>;\nusing pmat=vector<pvec>;\n#define For(i,a,b) for(i=a;i<(ll)b;i++)\n#define bFor(i,a,b) for(i=a;i>=(ll)b;i--)\n#define rep(i,N) For(i,0,N)\n#define rep1(i,N) For(i,1,N)\n#define brep(i,N) bFor(i,N-1,0)\n#define all(v) (v).begin(),(v).end()\n#define allr(v) (v).rbegin(),(v).rend()\n#define vsort(v) sort(all(v))\n#define vrsort(v) sort(allr(v))\n#define endl \"\\n\"\n#define pb push_back\n#define print(v) cout<<v<<endl\n#define printyes cout<<\"Yes\"<<endl\n#define printno cout<<\"No\"<<endl\n#define output(v) do{bool f=0;for(auto outi:v){cout<<(f?\" \":\"\")<<outi;f=1;}cout<<endl;}while(0)\nconst ll mod=1000000007;\nconst ll inf=1LL<<60;\nconst double PI = acos(-1);\nconst double eps = 1e-9;\ntemplate<class T> inline bool chmax(T& a,T b){bool x=a<b;if(x)a=b;return x;} \ntemplate<class T> inline bool chmin(T& a,T b){bool x=a>b;if(x)a=b;return x;} \n\nvoid startupcpp(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(15);\n}\n\ndouble distance(ddatas& x,ddatas& y){\n  double a=x.first-y.first,b=x.second-y.second;\n  return sqrt(a*a+b*b);\n}\n\nll modinv(ll a) {\n  ll b=mod,u=1,v=0,t;\n  while(b){\n    t=a/b;\n    a-=t*b; swap(a,b);\n    u-=t*v; swap(u,v);\n  }\n  return (u+mod)%mod;\n}\n\nll moddevide(ll a,ll b){return (a*modinv(b))%mod;}\n\nvec modncrlistp,modncrlistm;\n\nll modncr(ll n,ll r){\n  ll i,size=modncrlistp.size();\n  if(size<=n){\n    modncrlistp.resize(n+1);\n    modncrlistm.resize(n+1);\n    if(!size){\n      modncrlistp[0]=modncrlistm[0]=1;\n      size++;\n    }\n    For(i,size,n+1){\n      modncrlistp[i]=modncrlistp[i-1]*i%mod;\n      modncrlistm[i]=modinv(modncrlistp[i]);\n    }\n  }\n  return modncrlistp[n]*modncrlistm[r]%mod*modncrlistm[n-r]%mod;\n}\n\nll modpow(ll a,ll n){\n  ll res=1;\n  while(n){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll gcd(ll a,ll b){if(!b)return a;return (a%b==0)?b:gcd(b,a%b);}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nll countdigits(ll n){\n  ll ans=0;\n  while(n){n/=10;ans++;}\n  return ans;\n}\n\nll sumdigits(ll n){\n  ll ans=0;\n  while(n){ans+=n%10;n/=10;}\n  return ans;\n}\nstruct LowestCommonAncestor{\n  ll N,K=0;\n  mat g,parlis;\n  vec dist,vis;\n  LowestCommonAncestor(mat& t){\n    g=t;\n    N=t.size();\n    dist.resize(N);\n    vis.resize(N,0);\n    while(N){N>>=1;K++;}\n    N=dist.size();\n    parlis.resize(N,vec(K));\n  }\n  void dfs(ll now,ll d){\n    dist[now]=d;\n    vis[now]=1;\n    for(auto x:g[now]){\n      if(vis[x])continue;\n      dfs(x,d+1);\n      parlis[x][0]=now;\n    }\n  }\n  void init(ll par){\n    dfs(par,0);\n    parlis[par][0]=-1;\n    ll i,j;\n    rep(i,N)rep1(j,K){\n      if(parlis[i][j-1]==-1){\n        parlis[i][j]=-1;\n        continue;\n      }\n      parlis[i][j]=parlis[parlis[i][j-1]][j-1];\n    }\n  }\n  ll lca(ll a,ll b){\n    if(dist[a]<dist[b])swap(a,b);\n    ll i;\n    if(dist[a]!=dist[b])brep(i,K){\n      if((dist[a]-dist[b])&(1<<i))a=parlis[a][i];\n    }\n    if(a==b)return a;\n    brep(i,K){\n      if(parlis[a][i]!=parlis[b][i]){\n        a=parlis[a][i];\n        b=parlis[b][i];\n      }\n    }\n    return parlis[a][0];\n  }\n};\nint main(){\n  startupcpp();\n  ll i,N,K,x,u,v;\n  cin>>N;\n  mat g(N);\n  rep(i,N){\n    cin>>K;\n    while(K--){\n      cin>>x;\n      g[i].pb(x);\n      g[x].pb(i);\n    }\n  }\n  LowestCommonAncestor tree(g);\n  tree.init(0);\n  cin>>N;\n  while(N--){\n    cin>>u>>v;\n    print(tree.lca(u,v));\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n \nusing namespace std;\n \n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define exist(container, item) (find(container.begin(),container.end(),item)!=container.end())\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFL 9e18\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n \ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\nstruct Edge {\n    int from, to, cost;\n    bool operator<(Edge e) {\n        return cost < e.cost;\n    }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n    return \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n \ntemplate<class T>\nstruct augEdge {\n    T from, to;\n    int cost;\n    bool operator<(augEdge e) { return cost < e.cost; }\n    bool operator>(augEdge e) { return cost > e.cost; }\n};\ntemplate<class T>\nusing augGraph = vector<augEdge<T>>;\n \nclass LCA {\npublic:\n    int N;\n    vi depth;\n    int maxdepth = 0;\n    vvi dblpar;\n \n    LCA(const Graph G) {\n        N = G.size();\n        depth = vi(N);\n        dfs1(G, 0);\n        int D = bindigit(maxdepth) + 1;\n        dblpar = vvi(D, vi(N));\n        rep(i, D) {\n            dfs2(G, 0, 0, i);\n        }\n    }\n \n    void dfs1(const Graph &G, int pos, int d = 0) {\n        depth[pos] = d;\n        maxdepth = max(maxdepth, d);\n        for (auto ch : G[pos]) {\n            dfs1(G, ch.to, d + 1);\n        }\n    }\n \n    void dfs2(const Graph &G, int pos, int par, int dbl) {\n        if (dbl == 0) {\n            dblpar[0][pos] = par;\n        }\n        else {\n            dblpar[dbl][pos] = dblpar[dbl - 1][dblpar[dbl - 1][pos]];\n        }\n        for (auto ch : G[pos]) {\n            dfs2(G, ch.to, pos, dbl);\n        }\n    }\n \n    int parent(int pos, int step) {\n        int ret = pos;\n        int dbl = 0;\n        while (step > 0) {\n            if ((step & 1) != 0) {\n                ret = dblpar[dbl][ret];\n            }\n            step >>= 1;\n            dbl++;\n        }\n        return ret;\n    }\n \n    int bindigit(int n) {\n        int ret = 0;\n        while (n > 0) {\n            ret++;\n            n >>= 1;\n        }\n        return ret;\n    }\n \n    int lca(int u, int v) {\n        if (depth[u] < depth[v]) {\n            swap(u, v);\n        }\n        u = parent(u, depth[u] - depth[v]);\n        int ng = -1, ok = depth[u];\n        while (ok - ng > 1) {\n            int mid = (ok + ng) / 2;\n            if (parent(u, mid) == parent(v, mid)) {\n                ok = mid;\n            }\n            else {\n                ng = mid;\n            }\n        }\n        return parent(u, ok);\n    }\n};\n \n \nint main(void) {\n    int N;\n    cin >> N;\n    Graph G(N);\n    rep(i, N) {\n        int num;\n        cin >> num;\n        rep(j, num) {\n            int ch;\n            cin >> ch;\n            G[i].push_back(Edge{ i,ch,1 });\n            G[ch].push_back(Edge{ ch,i,1 });\n        }\n    }\n \n    LCA lca(G);\n \n    int Q;\n    cin >> Q;\n    rep(q, Q) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.lca(u, v) << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 200005\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct data{ll x,a,b;};\n\nint N,Q;\nint a,b,c;\nvector<int> G[MAX_N];\nint p[MAX_N],d[MAX_N],cnt=0;\nvector<int> g,flg;\n\n\nvoid rec(int pos,int prev,int depth){\n  d[pos]=depth;\n  p[pos]=g.size();\n  g.push_back(pos);\n\n  for(int i=0;i<(int)G[pos].size();i++){\n    int w=G[pos][i];\n    if(w==prev)continue;\n    rec(w,pos,depth+1);\n    g.push_back(pos);\n  }\n\n}\n\nint Depth[MAX_N];\nP dp[MAX_N][30];\n\nint lca(int u,int v){\n\n  u=p[u];\n  v=p[v];\n  if(u>v)swap(u,v);\n  int dist=v-u+1;\n  int pos=u;\n  P res=P((1<<26),(1<<26));\n\n  for(int I=26;I>=0;I--){\n    int i=(1<<I);\n    if(dist>=i){\n      dist-=i;\n      res=min(res,dp[pos][I]);\n      pos+=i;\n    }\n  }\n\n  return g[res.second];\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&a);\n    for(int j=0;j<a;j++){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n    }\n  }\n\n  rec(0,-1,0);\n\n\n  for(int i=0;i<(int)g.size();i++)\n    dp[i][0]=P(d[g[i]],i);\n\n  int K=1;\n  for(int k=1;k<30;k++){\n    for(int i=0;i<(int)g.size();i++){\n      dp[i][k]=dp[i][k-1];\n      int j=i+K;\n      if(j>=(int)g.size())j=g.size()-1;\n      dp[i][k]=min(dp[i][k],dp[j][k-1]);\n    }\n    K*=2;\n  }\n  \n  cin>>Q;\n\n\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",lca(a,b));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100005;\nconst int MAX_N = 100005;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n + n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        bool used[MAX_V];\n        void dfs(int v, int d, int &k){\n            assert(v < MAX_V);\n            id[v] = k;\n            used[v] = true;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(used[G[v][i]] != 0){\n                    dfs(G[v][i], d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, 0, k);\n            rmqInit(depth,V * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, ans, sum, last, cnt;\nstruct Edge { LL to,cost; };\nvector<Edge>vec[100010];\nstring str;\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node, lazy, num;\n\tSeg(vector<LL>v) {\n\t\tn = 1; while (n < v.size())n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = v[i];\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//区間最小などの時\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\t//区間の和の遅延\n\tvoid eval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tnode[k] += lazy[k];\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2 + 1] += lazy[k] / 2;\n\t\t\t\tlazy[k * 2 + 2] += lazy[k] / 2;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\t//区間の最小の遅延\n\tvoid ceval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != -1) {\n\t\t\tnode[k] = lazy[k];\n\t\t\tif (r - l >= 1) {\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tvoid update(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\tceval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] = x;\n\t\t\tceval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tupdate(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tupdate(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\t//ceval(i, a, b);\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n\tvoid add(LL i, LL x) {\n\t\ti = i + n - 1;\n\t\tnode[i] += x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tnode[i] = (node[i * 2 + 1] + node[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid add(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] += (b - a + 1)*x;\n\t\t\teval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tadd(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tadd(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = node[i * 2 + 1] + node[i * 2 + 2];\n\t\t}\n\t}\n\tLL getsum(LL i, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b< l || r < a)return 0;\n\t\tif (l <= a&&b <= r)return node[i];\n\t\treturn (getsum(i * 2 + 1, a, (a + b) / 2, l, r) + getsum(i * 2 + 2, (a + b + 1) / 2, b, l, r));\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tvec[u].erase(vec[u].begin()+j);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct LinkCutTree {\n  vector<int>left,right,parent;\n\n  LinkCutTree(int n):left(n,-1),right(n,-1),parent(n,-1){}\n\n  inline bool is_root(int id){\n    return parent[id]<0 || (left[parent[id]]!=id && right[parent[id]]!=id);\n  }\n\n  void connect(int ch, int p, bool isL){\n    (isL ? left : right)[p] = ch;\n    if(ch >= 0)parent[ch] = p;\n  }\n\n  void rotate(int id){\n    int p = parent[id], q = parent[p];\n    bool isL = id==left[p], isRoot = is_root(p);\n\n    connect((isL ? right : left)[id], p, isL);\n    connect(p, id, !isL);\n\n    if(!isRoot)connect(id,q,p==left[q]);\n    else parent[id]=q;\n  }\n\n  void splay(int id){\n    while(!is_root(id)){\n      int p = parent[id];\n      if(!is_root(p))rotate( (id==left[p])^(p==left[parent[p]]) ? p : id );\n      rotate(id);\n    }\n  }\n\n  int expose(int id){\n    int last = -1;\n    for(int y=id; y>=0; y=parent[y])\n      splay(y), left[y]=last, last=y;\n    splay(id);\n    return last;\n  }\n\n  int find_root(int id){\n    expose(id);\n    while(right[id]!=-1)id=right[id];\n    return id;\n  }\n\n  void link(int ch, int p){\n    expose(ch);\n    if(right[ch]>=0)return;\n    parent[ch]=p;\n  }\n\n  void cut(int id){\n    expose(id);\n    if(right[id]<0)return;\n    parent[right[id]]=-1;\n    right[id]=-1;\n  }\n\n  int lca(int ch, int p){\n    if(find_root(ch)!=find_root(p))return -1;\n    expose(ch);\n    return expose(p);\n  }\n};\n\nint main(void){\n  int n;\n  cin >> n;\n\n  LinkCutTree tree(n);\n  \n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      tree.link(t,i);\n    }\n  }\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << tree.lca(u,v) << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????°???±????\\??????????\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define MAX_V 100000\n\nvector<int> G[MAX_V];\nvector<int> depth,vs;\nint id[MAX_V]={};\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int b;\n            cin>>b;\n            G[i].pb(b);\n        }\n    }\n    init();                                                         // aranging depth[] , vs[] and id[]\n    segtree<pii> st(depth.size(),pii((1<<31)-1,(1<<31)-1));         // the number of elements is depth.size()\n    rep(i,depth.size()){                                            //initialize\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int a,b;\n    int q;\n    cin>>q;\n    rep(i,q){\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;  // is equal to LCA(a,b)\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define SZ(v) ((int)v.size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define POPCNT(n) (__builtin_popcount(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nusing UnweightedGraph = vector<vector<int>>;\n\nstruct LowestCommonAncestorDoubling {\n    const UnweightedGraph &g;\n    vector<vector<int>> parent;\n    vector<int> depth;\n\n    LowestCommonAncestorDoubling(const UnweightedGraph &g, int root = 0) : g(g)\n    {\n        build(root);\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int u : g[v]) if (u != p) {\n            dfs(u, v, d + 1);\n        }\n    }\n\n    // 前処理\n    void build(int root = 0) {\n        const int n = g.size();\n        int h = 1;\n        while ((1 << h) < n) ++ h;\n        parent.assign(h, vector<int>(n, -1));\n        depth.assign(n, -1);\n        dfs(root, -1, 0);\n        for (int i = 0; i + 1 < h; ++i) {\n            for (int v = 0; v < n; ++v) {\n                if (parent[i][v] != -1)\n                    parent[i + 1][v] = parent[i][parent[i][v]];\n            }\n        }\n    }\n\n    // uとvのLCAを計算\n    int lca(int u, int v) {\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int i = 0; i < (int)parent.size(); ++i) {\n            if ((depth[v] - depth[u]) >> i & 1)\n                v = parent[i][v];\n        }\n        if (u == v) return u;\n        for (int i = (int)parent.size() - 1; i >= 0; --i) {\n            if (parent[i][u] != parent[i][v]) {\n                u = parent[i][u];\n                v = parent[i][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n    // u-v間の距離\n    int dist(int u, int v) {\n        int w = lca(u, v);\n        return abs(depth[u] - depth[w]) + abs(depth[v] - depth[w]);\n    }\n};\nusing LCA = LowestCommonAncestorDoubling;\n\nvoid _main() {\n    int n;\n    cin >> n;\n    UnweightedGraph g(n);\n    REP(i, n) {\n        int k;\n        cin >> k;\n        REP(j, k) {\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            g[c].push_back(i);\n        }\n    }\n    LCA lca(g);\n    int q;\n    cin >> q;\n    REP(i, q) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.lca(u, v) << endl;\n    }\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        if (strchr(argv[1], 'i'))\n            freopen(\"input.txt\", \"r\", stdin);\n        if (strchr(argv[1], 'o'))\n            freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    enum { B = 1000 };\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root){\n        color.assign(n, 0); parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(visited[c]) continue;\n                parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c;\n            }\n        }\n        visited.assign(n, false);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nconst int n=100010;\n\nvector<int> graph[n];\nint dep[n],p[20][n];\n\nvoid go(int now) {\n\tfor (int i=0;i< graph[now].size();i++){\n\t\tdep[graph[now][i]]=dep[now]+1;\n\t\tp[0][graph[now][i]]=now;\n\t\tgo(graph[now][i]);\n\t}\n\treturn;\n}\n\nint LCA(int l,int r){\n\tif(dep[l]<dep[r])swap(l,r);\n\tfor(int i=19;i>=0;i--){\n\t\tif(dep[p[i][l]]>=dep[r]){\n\t\t\tl=p[i][l];\n\t\t}\n\t}\n\t for(int i=19;i>=0;i--){\n\t \tif(p[i][l]!=p[i][r]){\n\t \t\tl=p[i][l];\n\t \t\tr=p[i][r];\n\t\t }\t\n\t }\n\tif(l!=r)return p[0][l];\n\telse return l;\n\t}\n\t\nint main(){\n\tint n,k,temp,q,l,r;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tgraph[i].resize(k);\n\t\tfor(int j=0;j<k;j++){\n\t\tscanf(\"%d\",&graph[i][j]);\n\t\t}\n\t}\n\tgo(0);\n\tfor(int i=1;i<20;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp[i][j]=p[i-1][p[i-1][j]];\n\t\t}\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\tscanf(\"%d%d\",&l,&r);\n\tprintf(\"%d\\n\",LCA(l,r));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 600){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    ll n, c0;\n    cin >> n;\n    vector<int> k(n), d(n);\n    vector<vector<int>> p(n, vector<int>(20, 0)), c(n);\n    rep(i, n) {\n        cin >> k[i];\n        rep(j, k[i]) {\n            cin >> c0;\n            p[c0][0] = i;\n            c[i].push_back(c0);\n        }\n    }\n    rep(i, 19) {\n        rep(j, n) {\n            p[j][i + 1] = p[p[j][i]][i];\n        }\n    }\n    queue<pair<int, int>> que;\n    que.push(make_pair(0, 0));\n    while (!que.empty()) {\n        auto p = que.front();\n        que.pop();\n        d[p.first] = p.second;\n        rep(i, k[p.first]) {\n            que.push(make_pair(c[p.first][i], p.second + 1));\n        }\n    }\n    //rep(i, n) cout << \"d[\" << i << \"]=\" << d[i] << \"\\n\";\n    int q, u, v;\n    cin >> q;\n    rep(i, q) {\n        cin >> u >> v;\n        //cout << u << \" \" << v;\n        if (d[u] > d[v]) swap(u, v);\n        int dif = d[v] - d[u], j = 0;\n        while (dif > 0) {\n            if (dif & 1) v = p[v][j];\n            dif /= 2;\n            j++;\n        }\n        //cout << \"-> \" << u << \" \" << v << \"\\n\";\n        if (u == v) {\n            cout << u << \"\\n\";\n            continue;\n        }\n        for (int j = 19; j >= 0; j--) {\n            if (p[u][j] != p[v][j]) {\n                u = p[u][j];\n                v = p[v][j];\n            }\n        }\n        cout << p[u][0] << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\nstruct DoublingLowestCommonAncestor {\n    const int LOG;\n    vector<int> dep;\n    const vector<vector<int>> &g;\n    vector<vector<int> > table;\n\n    DoublingLowestCommonAncestor(const vector<vector<int>> &g) : g(g), dep(g.size()),\n                                                                 LOG(32 - __builtin_clz(g.size())) {\n        table.assign(LOG, vector<int>(g.size(), -1));\n    }\n\n    void dfs(int idx, int par, int d) {\n        table[0][idx] = par;\n        dep[idx] = d;\n        for (auto &to : g[idx]) {\n            if (to != par) dfs(to, idx, d + 1);\n        }\n    }\n\n    void build() {\n        dfs(0, -1, 0);\n        for (int k = 0; k + 1 < LOG; k++) {\n            for (int i = 0; i < table[k].size(); i++) {\n                if (table[k][i] == -1) table[k + 1][i] = -1;\n                else table[k + 1][i] = table[k][table[k][i]];\n            }\n        }\n    }\n\n    int query(int u, int v) {\n        if (dep[u] > dep[v]) swap(u, v);\n        for (int i = LOG - 1; i >= 0; i--) {\n            if (((dep[v] - dep[u]) >> i) & 1) v = table[i][v];\n        }\n        if (u == v) return u;\n        for (int i = LOG - 1; i >= 0; i--) {\n            if (table[i][u] != table[i][v]) {\n                u = table[i][u];\n                v = table[i][v];\n            }\n        }\n        return table[0][u];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> g(n);\n\n    rep(i, n) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int t;\n            cin >> t;\n            g[i].push_back(t);\n            g[t].push_back(i);\n        }\n    }\n\n    DoublingLowestCommonAncestor lca(g);\n    lca.build();\n\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy4 = {0, -1, 0, 1}, dx4 = {1, 0, -1, 0};\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n// 木上のクエリを処理\n// ・作成(O(n log n))\n// ・ノード間の距離(O(log n))\n// ・直径・中心(O(log n))\n// ・最小共通素性(O(log n))\n// ・ノード間の最大の重み(O(log n))\nclass QueryOnTree {\nprivate:\n    std::unordered_map<int, std::vector<std::pair<int, int>>> tree;\n    int log_v = 0;\n    std::vector<std::unordered_map<int, int>> parent;        // 2^k個上の親\n//    std::vector<std::unordered_map<int, int>> max_weight;    // 2^k個上の親までにでてくる最大の重み\n    std::unordered_map<int, int> depth;                      // 各頂点についての根からの深さ\n//    std::unordered_map<int, long long> distance_from_root;   // 根からの距離\n    bool done = false;\n\npublic:\n    QueryOnTree() {\n\n    }\n\n    // 無向グラフの場合はu->vとv->uの両方をいれること\n    QueryOnTree(const std::unordered_map<int, std::vector<std::pair<int, int>>> &tree) : tree(tree) {\n\n    }\n\n    // 無向グラフの場合はu->vとv->uの両方をいれること\n    void add_edge(int u, int v, int w) {\n        assert(not done);\n        tree[u].emplace_back(std::make_pair(v, w));\n    }\n\n    void build(int root) {\n        this->done = true;\n\n        int n = tree.size();\n        if (n == 0) {\n            return ;\n        }\n\n        this->log_v = int(log2(n)) + 1;\n        this->parent = std::vector<std::unordered_map<int, int>>(log_v);\n//        this->max_weight = std::vector<std::unordered_map<int, int>>(log_v);\n//        this->distance_from_root[root] = 0;\n\n        dfs(root, -1, 0, 0);\n\n        for (int k = 0; k + 1 < this->log_v; k++) {\n            for (const auto &p : tree) {\n                int u = p.first;\n                if (parent[k][u] < 0) {\n                    parent[k + 1][u] = -1;\n                }\n                else {\n                    parent[k + 1][u] = parent[k][parent[k][u]]; // uの2^k個上のノードの2^k上のノードはuの2^(k+1)個上のノード\n                    if (parent[k + 1][u] >= 0) {\n//                        max_weight[k + 1][u] = std::max(max_weight[k][u], max_weight[k][parent[k][u]]);\n                    }\n                }\n            }\n        }\n    }\n\n    // uとvの距離\n//    long long distance(int u, int v) {\n//        return distance_from_root[u] + distance_from_root[v] - 2 * distance_from_root[lca(u, v)];\n//    }\n\n    // 木の直径，中心\n//    std::pair<int, long long> center_diameter() {\n//        // node 0から一番遠いnode\n//        int u = 0;\n//        long long max_distance = -1;\n//        for (const auto &p : tree) {\n//            auto node = p.first;\n//            auto dist = this->distance(0, node);\n//            if (dist > max_distance) {\n//                max_distance = dist;\n//                u = node;\n//            }\n//        }\n//\n//        // node uから一番遠いnode\n//        std::unordered_map<long long, int> distance_node;\n//        long long diameter = 0;\n//        for (const auto &p : tree) {\n//            auto node = p.first;\n//            auto dist = this->distance(u, node);\n//            distance_node[dist] = node;\n//            if (dist > diameter) {\n//                diameter = dist;\n//            }\n//        }\n//        assert(diameter != -1);\n//\n//        int center = distance_node[max_distance / 2];\n//\n//        return std::make_pair(center, diameter);\n//    }\n\n    // uとvの間で出現する最大の重み\n//    int maximum_weight(int u, int v) {\n//        int lca = this->lca(u, v);\n//        return std::max(this->maximum_weight_ancestor(u, lca), this->maximum_weight_ancestor(v, lca));\n//    }\n\n    // uとvの最近共通祖先(O(log n))\n    int lca(int u, int v) {\n        if (depth[u] > depth[v]) {\n            std::swap(u, v);\n        }\n        for (int k = 0; k < this->log_v; ++k) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n\n        if (u == v) {\n            return u;\n        }\n\n        for (int k = this->log_v - 1; k >= 0; --k) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\nprivate:\n    // 各頂点について，1つ上の親，1つ上の重み，根からの深さ，根からの距離を求める\n    void dfs(int u, int p, int d, int w) {\n        parent[0][u] = p;\n//        max_weight[0][u] = w;\n        depth[u] = d;\n\n        for (const auto &a : tree[u]) {\n            int v = a.first;\n            int dist = a.second;\n            if (v != p) {\n//                distance_from_root[v] = distance_from_root[u] + dist;\n                dfs(v, u, d + 1, dist);\n            }\n        }\n    }\n\n    // uとuの祖先の間の最大の重みを取得\n//    int maximum_weight_ancestor(int u, int ancestor) {\n//        int res = -INF;\n//        int d = depth[u] - depth[ancestor];\n//        for (int k = 0; k < log_v; k ++) {\n//            if ((d >> k) & 1) {\n//                res = std::max(res, max_weight[k][u]);\n//                u = parent[k][u];\n//            }\n//        }\n//        return res;\n//    }\n};\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    QueryOnTree qut;\n    FOR(i, 0, N) {\n        int K;\n        cin >> K;\n        FOR(j, 0, K) {\n            int C;\n            cin >> C;\n            qut.add_edge(i, C, 1);\n            qut.add_edge(C, i, 1);\n        }\n    }\n    qut.build(0);\n\n    int Q;\n    cin >> Q;\n    FOR(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        print(qut.lca(U, V));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_V 6010000\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n//RMQ\n\nint rn;\nii dat[2*MAX_V-1];\nvoid init(int n_){\n  rn = 1;\n  while(rn<n_)rn*=2;\n  for(int i=0;i<2*rn-1;i++)dat[i] = ii(IINF,IINF);//ii(depth,index)\n}\n \n// k番めの値(0-indexed)をaに変更\nvoid update(int k,ii a){\n  k += rn-1;\n  dat[k] = a;\n  while(k > 0){\n    k = (k-1)/2;\n    dat[k] = (dat[k*2+1].first>dat[k*2+2].first?dat[k*2+2]:dat[k*2+1]);\n  }\n}\n\nii _query(int a,int b,int k,int l,int r){\n  if(r<=a || b<=l)return ii(IINF,-1);\n  else if(a<=l && r<=b)return dat[k];\n  \n  ii vl = _query(a,b,k*2+1,l,(l+r)/2);\n  ii vr = _query(a,b,k*2+2,(l+r)/2,r);\n  \n  return min(vl,vr);\n}\n\n//nの範囲でミスしないように極力こっちを利用 \nii query(int a,int b){\n  return _query(a,b,0,0,rn);\n}\n\n//\n\nint V;\nvector<int> G[MAX_V];\nint root;\n\nint vs[MAX_V*2-1];\nint depth[MAX_V*2-1];\nint id[MAX_V];\n\nvoid dfs(int v,int p,int d,int &k){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  for(int i=0;i<G[v].size();i++){\n    if(G[v][i] != p){\n      dfs(G[v][i],v,d+1,k);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid RQMinit(){\n  int k = 0;\n  dfs(root,-1,0,k);\n  \n  init(k+1);  \n  rep(i,k)update(i,ii(depth[i],vs[i]));\n}\n\nint lca(int u,int v){\n  return query(min(id[u],id[v]),max(id[u],id[v])+1).second;\n}\n\n\nint main(){\n  int n;\n  cin >> n;\n  V = n;\n  rep(i,V){\n    int k,c;\n    cin >> k;\n    rep(j,k){\n      cin >> c;\n      G[i].push_back(c);\n      G[c].push_back(i);\n    }\n  }\n\n  RQMinit();\n  int q,u,v;\n  cin >> q;\n  rep(i,q){\n    cin >> u >> v;\n    cout << lca(u,v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// HL ????§£\n// ???????????? v ???????????? c_i ?????????????????????????????¨????????¨?????¨???????????°???\n// ?????§???????????? 1 ?????? c_h ??¨?????????????????¨????????? (v, c_h) ??? \"heavy\" ????????§????????¨?????????\n// ????????\\???????????? \"light\" ????????§????????¨?????????\n\n// ?????????????????? \"heavy\" ??¨ \"light\" ?????????????????¨?????¨??? \"heavy\" ??????????????????\n// (????????????????????¨ chain) ???????§£ (\"heavy\" ??§???????????£???????????????????????¨???????????¨??????) ??§?????????\n// ????????? HL ????§£??¨?????????\n\n// chain ???????´????????????¨?????¨???????????? O(log N) ??§?????????\n// ????????????\"heavy\" ?????????????????????????????? v ??¨ \"light\" ????????§?????°???????????? v ?????????????????????????????????\n// ??¨?????¨?????§????????? subsize(v) / 2 ??\\?????¨?????£??????????????¨???????°??????????\n// \"light\" ??????????????????????????¨?????¨???????????????????????\\???????????????????????±?????? O(log N) ??¨?????????\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\nstruct HLD {\n    int N;\n    const Graph<int> G;\n    // ???????????¨????????????\n    // ??????????????±????????????????????????????????????????????¨????????¨?????¨????????????\n    // ???????????????????????????????????? \"heavy\" ??????\n    vector<int> depth, parent, subsize, heavy;\n    // ???chain ????????????\n    // chain ?????????????´????????°?????´??????????????????? 1 ????¬??????????????´????chain ?????§?????????????????????\n    vector<int> head, last, prev, next, chain, idx;\n    // chain ????????± (?????? vector ????????????????´??????????????????? chain ????±???????)\n    vector< vector<int> > chains;\n\n    HLD(const Graph<int> &H, int r=-1) :\n        N(H.size()), G(H), depth(N, -1), parent(N, 0), subsize(N, 0), heavy(N, -1),\n        head(N), last(N), prev(N, -1), next(N, -1), chain(N, -1), idx(N, 0)\n    {\n        if(r != -1) decompose(r);\n    }\n\n    // root ????????¨??????????§£\n    void decompose(const int root) {\n        stack<int> st; st.push(root);\n        parent[root] = -1;\n        depth[root] = 0;        \n\n        while(st.size()) {\n            int cur_v = st.top(); st.pop();\n            // ?????????????????????????¨???????\n            if(cur_v >= 0) {\n                st.push(~cur_v);\n                for(auto e : G[cur_v]) {\n                    // ??????????????§???????????°????????´??°\n                    if(depth[e.to] != -1) continue;\n                    depth[e.to] = depth[cur_v] + 1;\n                    parent[e.to] = cur_v;\n                    st.push(e.to);\n                }\n            }\n            // ??°?????????\n            else {\n                int ma = 0;\n                cur_v = ~cur_v;\n                subsize[cur_v] = 1;\n                for(auto e : G[cur_v]) {\n                    if(parent[cur_v] == e.to) continue;\n                    subsize[cur_v] += subsize[e.to];\n                    if(ma < subsize[e.to]) {\n                        // cur_v ??¨??¨?????¨????????????????????§??????????????¶\n                        // (????????? \"heavy\" ??????)\n                        ma = subsize[e.to];\n                        next[cur_v] = e.to;\n                    }\n                }\n            }\n        }\n\n        st.push(root);\n        while(st.size()) {\n            int cur_v = st.top(); st.pop();\n            for(auto e : G[cur_v]) {\n                if(parent[cur_v] != e.to) st.push(e.to);\n            }\n\n            if(chain[cur_v] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> &path = chains.back();\n\n            for(int v=cur_v; v!=-1; v=next[v]) path.push_back(v);\n\n            for(size_t i=0; i<path.size(); i++) {\n                int v = path[i];\n                head[v] = path.front(), last[v] = path.back();\n                prev[v] = (i != 0 ? path[i-1] : -1);\n                next[v] = (i+1 != path.size() ? path[i+1] : -1);\n                chain[v] = (int)chains.size() - 1;\n                idx[v] = i;\n            }\n        }\n    }\n\n    // ?????? v ????????????????????? chain ????±?????????????\n    // ???????????? chain ????????§????????????????????????????????? pair ??§??????\n    pair<int, int> get_index(int v) {\n        return make_pair(chain[v], idx[v]);\n    }\n\n    // v ????±??????? chain ?????????????????? (head[v] ???????????? -1 ?????????)\n    int climb(int v) {\n        return parent[ head[v] ];\n    }\n\n    // ?????? u ??¨ v ???????°???±????\\????\n    int lca(int u, int v) {\n        while(chain[u] != chain[v]) {\n            if(depth[head[u]] < depth[head[v]]) v = climb(v);\n            else u = climb(u);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n};\n\nsigned main() {\n    int N; cin >> N;\n    Graph<int> G(N);\n    rep(i,0,N) {\n        int K; cin >> K;\n        while(K--) {\n            int child; cin >> child;\n            G[i].push_back(Edge<int>(child, 1));\n            G[child].push_back(Edge<int>(i, 1));\n        }\n    }\n\n    HLD hl(G, 0);\n    int Q; cin >> Q;\n\n    /*\n    rep(i,0,N) {\n        pii res = hl.get_index(i);\n        printf(\"vertex %lld: chain = %lld, index = %lld\\n\", i+1, res.first, res.second);\n    }\n    */\n\n    rep(i,0,Q) {\n        int u, v; cin >> u >> v;\n        cout << hl.lca(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by azidoazideazide(c2n14)\n#include<iostream>\n#include<vector>\nusing namespace std;\nusing ll=long long;\n#define pb push_back\n\nvector<int> adj[100005];\nint n,dep[100005], lomo[100005], dp[100005][20];\nconst int M=17;\n\nvoid init(){\n\tfor(int i=0;i<n;i++){\n\t\tdp[i][0]=lomo[i];\n\t\tfor(int j=1;j<=M;j++){\n\t\t\tif(dp[i][j-1]==-1) dp[i][j]=-1;\n\t\t\telse dp[i][j]=dp[dp[i][j-1]][j-1];\n\t\t}\n\t}\n}\n\nint lca(int a, int b){\n\tif(dep[a]>dep[b]) swap(a,b);\n\tfor(int j=M-1;j>=0;j--)\n\t\tif(dp[b][j]!=-1 && dep[dp[b][j]]>=dep[a]) \n\t\t\tb=dp[b][j];\n\t\n\tif(a==b) return a;\n\t\n\tfor(int j=M-1;j>=0;j--)\n\t\tif(dp[a][j]!=dp[b][j])\n\t\t\ta=dp[a][j], b=dp[b][j];\n\n\treturn lomo[a];\n}\n\nint main(){\n\tint q;\n\tcin>>n;\n\tfor(int i=0,k;i<n;i++){\n\t\tcin>>k;\n\t\tfor(int j=0,tt;j<k;j++){\n\t\t\tcin>>tt;\n\t\t\tlomo[tt]=i, dep[tt]=dep[i]+1;\n\t\t\tadj[i].pb(tt);\n\t\t}\n\t}\n\t\n\tinit();\n\t\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<lca(a,b)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, ans, sum, last, cnt = 25000, a[100000], d[200010];\nstruct Edge { LL to,cost; };\nvector<Edge>vec[100000];\nstring str[3];\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node, lazy, num;\n\tSeg(vector<LL>v) {\n\t\tn = 1; while (n < v.size())n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = v[i];\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//区間最小などの時\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\t//区間の和の遅延\n\tvoid eval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tnode[k] += lazy[k];\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2 + 1] += lazy[k] / 2;\n\t\t\t\tlazy[k * 2 + 2] += lazy[k] / 2;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\t//区間の最小の遅延\n\tvoid ceval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != -1) {\n\t\t\tnode[k] = lazy[k];\n\t\t\tif (r - l >= 1) {\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tvoid update(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\tceval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] = x;\n\t\t\tceval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tupdate(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tupdate(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\t//ceval(i, a, b);\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n\tvoid add(LL i, LL x) {\n\t\ti = i + n - 1;\n\t\tnode[i] += x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tnode[i] = (node[i * 2 + 1] + node[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid add(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] += (b - a + 1)*x;\n\t\t\teval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tadd(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tadd(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = node[i * 2 + 1] + node[i * 2 + 2];\n\t\t}\n\t}\n\tLL getsum(LL i, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b< l || r < a)return 0;\n\t\tif (l <= a&&b <= r)return node[i];\n\t\treturn (getsum(i * 2 + 1, a, (a + b) / 2, l, r) + getsum(i * 2 + 2, (a + b + 1) / 2, b, l, r));\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100000];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t\tvec[h].push_back(Edge{ i,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];//*\nint size[MAX];// *\nint par[MAX];// *\nint cur[MAX];// *\nint dep[MAX];// *\nint depth[MAX];\nint het[MAX];\nint parent[MAX];\n\nvoid idfs(int pos,int prev){\n  int m=-1;\n  parent[pos]=prev;\n  if(G[pos].size()==1)return;  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    depth[to]=depth[pos]+1;\n    idfs(to,pos);\n    size[pos]+=size[to];\n    het[pos]=max(het[pos],het[to]+1);\n    if(m==-1||size[m]<size[to]){\n      m=to;\n    }\n  }\n  cur[pos]=m;\n  par[m]=pos;\n  het[pos]=max(het[pos],het[m]);\n}\n\nint calc(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    par[x]=calc(par[x]);\n    return par[x];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n    size[i]=1;\n    par[i]=i;\n    cur[i]=-1;\n    dep[i]=0;\n    depth[i]=0;\n    het[i]=0;\n    parent[i]=0;\n  }\n  for(int i=0;i<n;i++){    \n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n      G[b].push_back(i);\n    }\n  }\n  for(int i=0;i<n;i++)    sort(G[i].begin(),G[i].end());\n  depth[0]=0;\n  idfs(0,-1);\n  for(int i=0;i<n;i++){\n    int root=calc(i);\n    het[i]=het[root];\n    int p=par[i];\n    while(p>0){\n      p= par[ parent[p] ];      \n      dep[i]++;\n    }\n    /*\n    cout<< (char)('A'+i) <<\"   -> \";\n    cout<< (char)('A'+par[i]) <<endl;    \n    cout<<\"size = \"<< size[i]<<\" , \";    \n    cout<<\"depth = \"<< depth[i]<<\" , \";\n    cout<<\"dep = \"<< dep[i]<<\" , \";\n    cout<<\"parent = \"<< (char)('A'+parent[i]) <<\" , \";\n    cout<<\"cur = \"<< (char)('A'+cur[i]) <<\" , \";\n    cout<<\"het = \"<< het[i] << endl;\n    \n    cout<<endl;\n    */\n  }\n\n  \n}\n\nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n      scanf(\"%d %d\",&a,&b);\n      if(par[a]==par[b])printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n      else{\n        while(par[a]!=par[b]){\n          if(dep[a]<dep[b])swap(a,b);\n          a=parent[par[a]];\n        }\n        printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n      }\n    }\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\n#define double long double\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\ntemplate<typename T, typename E, typename F, typename G> struct LinkCutTree{\n    struct Node{\n        Node *par_ptr, *left_ptr, *right_ptr;\n        int idx;\n        bool rev;\n        T val, sum;\n\n        Node(): idx(-1), par_ptr(nullptr), left_ptr(nullptr), right_ptr(nullptr),\n        rev(false), val(T{}), sum(T{}){}\n\n        bool is_root(){\n            return !par_ptr || (par_ptr->left_ptr != this && par_ptr->right_ptr != this);\n        }\n\n        void print_data(){\n            int p = par_ptr ? par_ptr->idx : -1;\n            int l = left_ptr ? left_ptr->idx : -1;\n            int r = right_ptr ? right_ptr->idx : -1;\n            printf(\"id=%d, p=%d, l=%d, r=%d, rev=%d, val=%lld, sum=%lld\\n\", idx, p, l ,r, rev, val, sum);\n        }\n    };\n    \n    int n;\n    vector<Node> nodes;\n    F f;\n    G g;\n\n    LinkCutTree(int n, T et, F f, G g): n(n), f(f), g(g){\n        nodes.resize(n);\n        rep(i, n){\n            nodes[i].idx = i;\n            nodes[i].val = nodes[i].sum = et;\n        }\n    }\n\n    void toggle(Node *node){\n        if(!node->rev) return;\n        if(node->left_ptr) node->left_ptr->rev ^= true;\n        if(node->right_ptr) node->right_ptr->rev ^= true;\n        swap(node->left_ptr, node->right_ptr);\n        node->rev = false;\n    }\n\n    void pull(Node *node){\n        node->sum = node->val;\n        if(node->left_ptr) node->sum = f(node->left_ptr->sum, node->sum);\n        if(node->right_ptr) node->sum = f(node->sum, node->right_ptr->sum);\n    }\n\n    void rotl(Node *node){\n        Node *par = node->par_ptr, *grand_par = par->par_ptr;\n        if((par->right_ptr = node->left_ptr)) node->left_ptr->par_ptr = par;\n        node->left_ptr = par; par->par_ptr = node;\n        pull(par); pull(node);\n        if((node->par_ptr = grand_par)){\n            if(grand_par->left_ptr == par) grand_par->left_ptr = node;\n            if(grand_par->right_ptr == par) grand_par->right_ptr = node;\n            pull(grand_par);\n        }\n    }\n\n    void rotr(Node *node){\n        Node *par = node->par_ptr, *grand_par = par->par_ptr;\n        if((par->left_ptr = node->right_ptr)) node->right_ptr->par_ptr = par;\n        node->right_ptr = par; par->par_ptr = node;\n        pull(par); pull(node);\n        if((node->par_ptr = grand_par)){\n            if(grand_par->left_ptr == par) grand_par->left_ptr = node;\n            if(grand_par->right_ptr == par) grand_par->right_ptr = node;\n            pull(grand_par);\n        }\n    }\n\n    void toggle_all(Node *node){\n        if(node->is_root()){\n            toggle(node);\n            return;\n        }\n        toggle_all(node->par_ptr);\n        toggle(node);\n    }\n\n    void splay(int i){\n        Node *node = &nodes[i];\n        toggle_all(node);\n        while(!node->is_root()){\n            Node *par = node->par_ptr;\n            if(par->is_root()){\n                if(par->right_ptr == node) rotl(node);\n                else rotr(node);\n                return; \n            }\n\n            Node *grand_par = par->par_ptr;\n            if(par->left_ptr == node){\n                if(grand_par->left_ptr == par) rotr(par), rotr(node);\n                else rotr(node), rotl(node);\n            }\n            else{\n                if(grand_par->right_ptr == par) rotl(par), rotl(node);\n                else rotl(node), rotr(node);\n            }\n        }\n    }\n\n    Node *expose(int i){\n        Node *child = nullptr;\n        for(Node *par=&nodes[i]; par; par=par->par_ptr){\n            splay(par->idx);\n            par->right_ptr = child;\n            pull(par);\n            child = par;\n        }\n        splay(i);\n        return child;\n    }\n\n    void link(int child, int par){\n        expose(child);\n        expose(par);\n        nodes[child].par_ptr = &nodes[par];\n        nodes[par].right_ptr = &nodes[child];\n        pull(&nodes[par]);\n    }\n\n    void cut(int child){\n        expose(child);\n        Node *par = nodes[child].left_ptr;\n        nodes[child].left_ptr = nullptr;\n        par->par_ptr = nullptr;\n        pull(&nodes[child]);\n    }\n\n    void evert(int i){\n        expose(i);\n        nodes[i].rev = true;\n        toggle(&nodes[i]);\n    }\n\n    void add_edge(int child, int par){\n        evert(par);\n        evert(child);\n        link(child, par);\n    }\n\n    void del_edge(int child, int par){\n        evert(par);\n        cut(child);\n    }\n\n    void update_val(int i, E x){\n        evert(i);\n        nodes[i].val = g(nodes[i].val, x);\n        pull(&nodes[i]);\n    }\n\n    T get_path_sum(int u, int v){\n        evert(u);\n        expose(v);\n        return nodes[v].sum;\n    }\n\n    int lca(int u, int v){\n        expose(u);\n        return expose(v)->idx;\n    }\n};\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    LinkCutTree<lint, lint, decltype(plus<>()), decltype(plus<>())> lct(n, 0LL, plus<>(), plus<>());\n    rep(i, n){\n        int K, c;\n        scanf(\"%d\", &K);\n        rep(_, K){\n            scanf(\"%d\", &c);\n            lct.add_edge(i, c);\n        }\n    }\n    lct.evert(0);\n\n    int q;\n    scanf(\"%d\", &q);\n    rep(_, q){\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        printf(\"%d\\n\", lct.lca(u, v));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100005;\nconst int MAX_N = 100005;\n\n\nvector<int> G[MAX_V];\n\n//?????°?????????????????????????????????\nint n, dat[4 * MAX_N];\nint min_id[4 * MAX_N];\npair<int, int> query(int a, int b, int k, int l, int r){\n    //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n    if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n    //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n    if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n    else{\n        //????????§???????????°??????????????????????°????\n        pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n        pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n        if(vl.first < vr.first) return vl;\n        else return vr;\n    }\n}\nvoid rmqInit(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    rep(i,2 * n) dat[i] = INT_MAX;\n}\nvoid rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = n; i < n + n; i++){\n        dat[i] = a[i - n];\n        min_id[i] = i - n;\n    }\n    for(int i = n - 1; i >= 1; i--){\n        if(dat[i * 2] < dat[i * 2 + 1]){\n            dat[i] = dat[i * 2];\n            min_id[i] = min_id[i * 2];\n        }else{\n            dat[i] = dat[i * 2 + 1];\n            min_id[i] = min_id[i * 2 + 1];\n        }\n    }\n}\nvoid update(int i, int x){\n    i += n; //????????????\n    dat[i] = x;\n    while(i > 0){ //?????????????????´??°\n        dat[i / 2] = min(dat[i], dat[i^1]);\n        i = i / 2;\n    }\n}\n//[a, b)???????°?????????????????????????\nint query(int a, int b){\n    return query(a,b,1,0,n).second;\n}\n\nint root = 0;\nint vs[MAX_V * 2]; //?????????????????¢???\nint depth[MAX_V * 2];\nint id[MAX_V];\nvoid dfs(int v, int d, int &k){\n    id[v] = k;\n    vs[k] = v;\n    depth[k++] = d;\n    rep(i,G[v].size()){\n        if(id[G[v][i]] == 0){\n            dfs(G[v][i], d + 1, k);\n            vs[k] = v;\n            depth[k++] = d;\n        }\n    }\n}\nvoid init(int V){\n    int k = 0;\n    dfs(root, 0, k);\n    rmqInit(depth,V * 2 - 1);\n}\nint lca(int u, int v){\n    return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            G[i].emplace_back(v);\n        }\n    }\n\n    init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct LCA {\n    vector<vector<long>> park;\n    vector<long> h;\n    long n, d;\n\n    LCA(vector<long> &par) {\n        // par[root] == -1\n        n = par.size();\n        h.assign(n, -1);\n        {\n            auto dfs = [&](auto dfs, long cur) -> long {\n                if(par[cur] == -1) return h[cur] = 0;\n                if(h[cur] != -1) return h[cur];\n                return h[cur] = 1 + dfs(dfs, par[cur]);\n            };\n            for(long i=0; i<n; i++)\n                dfs(dfs, i);\n        }\n\n        d=1;\n        while(1L<<d < n) d++;\n\n        park.assign(d, vector<long>(n));\n        copy(par.begin(), par.end(), park[0].begin());\n\n        for(long k=1; k<d; k++)\n            for(long i=0; i<n; i++) {\n                if(park[k-1][i] == -1) continue;\n                park[k][i] = park[k-1][park[k-1][i]];\n            }\n    }\n\n    long query(long u, long v) const {\n        if(h[u] > h[v])\n            swap(u, v);\n        for(long i=d-1; i>=0; i--)\n            if(h[v]-h[u] >= 1L<<i)\n                v = park[i][v];\n\n        if(v == u) return v;\n\n        for(long i=d-1; i>=0; i--)\n            if(park[i][v] != park[i][u])\n                v = park[i][v], u = park[i][u];\n        return park[0][v];\n    }\n};\n\nint main(void) {\n    /* long n, q; */\n    /* cin >> n >> q; */\n    long n;\n    cin >> n;\n    vector<long> par(n, -1);\n    /* for(int i=1; i<n; i++) */\n    /*     cin >> par[i]; */\n\n    for(int i=0; i<n; i++) {\n        long k;\n        cin >> k;\n        for(int j=0; j<k; j++) {\n            long c;\n            cin >> c;\n            par[c] = i;\n        }\n\n    }\n\n    LCA lca(par);\n\n    long q;\n    cin >> q;\n\n    for(long i=0; i<q; i++) {\n        long u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass HeavyLight{\n\tpublic:\n\tint pathCount,n;\n\tvi size,parent,in,out,path,pathRoot;\n\tvvi tree;\n\t\n\tHeavyLight(vvi t)\n\t\t:pathCount(0),n(t.size()),size(n),parent(n),in(n),out(n),\n\t\tpath(n),pathRoot(n),tree(t){\n\t\tint time=0;\n\t\tdfs(0,-1,time);\n\t\tbuildPaths(0,newPath(0));\n\t}\n\tvoid dfs(int u,int p,int &k){\n\t\tin[u]=k++,parent[u]=p,size[u]=1;\n\t\tfor(auto v=tree[u].begin();v!=tree[u].end();v++)if(*v!=p)\n\t\t\tdfs(*v,u,k),size[u]+=size[*v];\n\t\tout[u]=k++;\n\t}\n\tint newPath(int u){pathRoot[pathCount]=u;return pathCount++;}\n\tvoid buildPaths(int u,int pt){\n\t\tpath[u]=pt;\n\t\tfor(auto v=tree[u].begin();v!=tree[u].end();v++)if(*v!=parent[u]){\n\t\t\tbuildPaths(*v,2*size[*v]>=size[u]?pt:newPath(*v));\n\t\t}\n\t}\n\tbool inAncestor(int p,int ch){\n\t\treturn in[p]<=in[ch]&&out[ch]<=out[p];\n\t}\n\tint lca(int a,int b){\n\t\tfor(int root;!inAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n\t\tfor(int root;!inAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n\t\treturn inAncestor(a,b)?a:b;\n\t}\n};\nint main(){\n\tint n;\n\tcin>>n;\n\tvvi tree(n);\n\trep(i,n){\n\t\tint k;cin>>k;\n\t\trep(j,k){\n\t\t\tint ch;cin>>ch;\n\t\t\ttree[i].pb(ch);\n\t\t}\n\t}\n\tHeavyLight hl(tree);\n\t\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<hl.lca(a,b)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define V vector<long long>\n#define VV vector<vector<long long>>\n#define rep(i,n) for(ll (i)=0;(i)<(n);++(i))\nusing namespace std;\n\ntemplate<typename T>\nstruct lowest_common_ancestor{\n    T n,logn;\n    vector<T> depth;\n    vector<vector<T>> g,next;\n    lowest_common_ancestor(vector<vector<T>> const& g):g(g),n(g.size()),logn(floor(log2(g.size()))),depth(g.size()){\n        next.assign(n,vector<T>(logn+1));\n        dfs(0,-1,0);\n        for(T k=0;k<logn;++k){\n            for(T i=0;i<n;++i){\n                if(next[i][k]==-1)next[i][k+1]=-1;\n                else next[i][k+1]=next[next[i][k]][k];\n            }\n        }\n    }\n    void dfs(T now,T par,T dep){\n        depth[now]=dep;\n        next[now][0]=par;\n        for(T i=0;i<g[now].size();++i){\n            if(g[now][i]!=par){\n                dfs(g[now][i],now,dep+1);\n            }\n        }\n    }\n    T query(T a,T b){\n        if(depth[a]<depth[b])swap(a,b);\n            for(T k=logn;k>=0;--k){\n                if((1<<k) & depth[a]-depth[b]){\n                    a=next[a][k];\n                }\n            }\n        if(a==b)return a;\n            for(T k=logn;k>=0;--k){\n                if(next[a][k] != next[b][k]){\n                    a=next[a][k];\n                    b=next[b][k];\n                }\n            }\n        return next[a][0];\n    }\n    T distance(T a,T b){\n        return depth[a]+depth[b]-2*depth[query(a,b)];\n    }\n};\n\nint main(){\n    ll n;\n    cin>>n;\n    VV g(n,vector<ll>());\n    rep(i,n){\n        ll k;\n        cin>>k;\n        rep(j,k){\n            ll c;\n            cin>>c;\n            g[i].push_back(c);\n            g[c].push_back(i);\n        }\n    }\n    lowest_common_ancestor<ll> lca(g);\n    ll q;\n    cin>>q;\n    rep(i,q){\n        ll u,v;\n        cin>>u>>v;\n        cout<<lca.query(u, v)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\nusing namespace std;\nint binary[64][maxn];\nvector<int> v[maxn];\nint tuvshin[maxn];\n\nstring lol(int n) {\n    string s;\n    while(n > 0) {\n        s += to_string(n%2);\n        n /= 2;\n    }\n    return s;\n}\n\nint main() {\n    int n;\n    cin >>n;\n    memset(binary, -1, sizeof binary);\n    for(int i = 0; i < n; i++) {\n        int a;\n        cin >>a;\n        for(int j = 1; j <= a; j++) {\n            int x;\n            cin >>x;\n            v[i].push_back(x);\n            binary[0][x] = i;\n        }\n    }\n    \n    for(int i = 1; i <= 32; i++) \n        for(int j = 1; j < n; j++) \n            binary[i][j] = binary[i-1][binary[i-1][j]];\n    \n    queue<pair<int, int> > pq;\n    pq.push(make_pair(0, 0));\n    while(!pq.empty()) {\n        int x = pq.front().first;\n        int k = pq.front().second;\n        tuvshin[x] = k;\n        pq.pop();\n        for(int i = 0; i < v[x].size(); i++) {\n            pq.push(make_pair(v[x][i], k+1));\n        }\n    }\n    int t;\n    cin >>t;\n    while(t--) {\n        int a, b;\n        cin >>a >>b;\n        if(tuvshin[a] > tuvshin[b]) {\n            int k = tuvshin[a] - tuvshin[b];\n            string s = lol(k);\n            for(int i = 0; i < s.size(); i++)\n                if(s[i] == '1') \n                    a = binary[i][a];\n        }\n        if(tuvshin[b] > tuvshin[a]) {\n            int k = tuvshin[b] - tuvshin[a];\n            string s = lol(k);\n            for(int i = 0; i < s.size(); i++)\n                if(s[i] == '1') \n                    b = binary[i][b];\n        }\n        while(a != b) {\n            int l = 0, r = 64;\n            while(l <= r) {\n                int mid = (r+l)>>1;\n                if(binary[mid][a] == binary[mid][b]) {\n                    r = mid-1;\n                }\n                else l = mid+1;\n            }\n            if(l != 0)l--;\n            a = binary[l][a];\n            b = binary[l][b];\n        }\n        cout<<a<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Monoid = int, typename OperatorMonoid = Monoid >\nstruct LinkCutTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  struct Node {\n    Node *l, *r, *p;\n    int idx;\n    Monoid key, sum;\n    OperatorMonoid lazy;\n\n    bool rev;\n    int sz;\n\n    bool is_root() {\n      return !p || (p->l != this && p->r != this);\n    }\n\n    Node(int idx, const Monoid &key, const OperatorMonoid &om) :\n        idx(idx), key(key), sum(key), lazy(om), sz(1),\n        l(nullptr), r(nullptr), p(nullptr), rev(false) {}\n  };\n\n  const Monoid M1;\n  const OperatorMonoid OM0;\n  const F f;\n  const G g;\n  const H h;\n\n  LinkCutTree() : LinkCutTree([](Monoid a, Monoid b) { return a + b; }, Monoid()) {}\n\n  LinkCutTree(const F &f, const Monoid &M1) :\n      LinkCutTree(f, G(), H(), M1, OperatorMonoid()) {}\n\n  LinkCutTree(const F &f, const G &g, const H &h,\n              const Monoid &M1, const OperatorMonoid &OM0) :\n      f(f), g(g), h(h), M1(M1), OM0(OM0) {}\n\n  Node *make_node(int idx, const Monoid &v = Monoid()) {\n    return new Node(idx, v, OM0);\n  }\n\n  void propagete(Node *t, const OperatorMonoid &x) {\n    t->lazy = h(t->lazy, x);\n    t->key = g(t->key, x, 1);\n    t->sum = g(t->sum, x, t->sz);\n  }\n\n  void toggle(Node *t) {\n    assert(t);\n    swap(t->l, t->r);\n    /* note: ここに反転の処理 */\n    t->rev ^= true;\n  }\n\n  void push(Node *t) {\n    if(t->lazy != OM0) {\n      if(t->l) propagete(t->l, t->lazy);\n      if(t->r) propagete(t->r, t->lazy);\n      t->lazy = OM0;\n    }\n    if(t->rev) {\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev = false;\n    }\n  }\n\n  void update(Node *t) {\n    t->sz = 1;\n    t->sum = t->key;\n    if(t->l) t->sz += t->l->sz, t->sum = f(t->l->sum, t->sum);\n    if(t->r) t->sz += t->r->sz, t->sum = f(t->sum, t->r->sum);\n  }\n\n  void rotr(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void rotl(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t) {\n    push(t);\n    while(!t->is_root()) {\n      auto *q = t->p;\n      if(q->is_root()) {\n        push(q), push(t);\n        if(q->l == t) rotr(t);\n        else rotl(t);\n      } else {\n        auto *r = q->p;\n        push(r), push(q), push(t);\n        if(r->l == q) {\n          if(q->l == t) rotr(q), rotr(t);\n          else rotl(t), rotr(t);\n        } else {\n          if(q->r == t) rotl(q), rotl(t);\n          else rotr(t), rotl(t);\n        }\n      }\n    }\n  }\n\n  Node *expose(Node *t) {\n    Node *rp = nullptr;\n    for(Node *cur = t; cur; cur = cur->p) {\n      splay(cur);\n      cur->r = rp;\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert(Node *t) {\n    expose(t);\n    toggle(t);\n    push(t);\n  }\n\n  Node *lca(Node *u, Node *v) {\n    expose(u);\n    return expose(v);\n  }\n\n  vector< int > getpath(Node *x) {\n    vector< int > vs;\n    function< void(Node *) > dfs = [&](Node *cur) {\n      if(!cur) return;\n      dfs(cur->r);\n      vs.push_back(cur->idx);\n      dfs(cur->l);\n    };\n    expose(x);\n    dfs(x);\n    return vs;\n  }\n\n  void set_propagete(Node *t, const OperatorMonoid &x) {\n    expose(t);\n    propagete(t, x);\n    push(t);\n  }\n};\n\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  LinkCutTree<> lctree;\n  vector< LinkCutTree<>::Node * > uku(N);\n  for(int i = 0; i < N; i++) {\n    uku[i] = lctree.make_node(i);\n  }\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      lctree.link(uku[T], uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    printf(\"%d\\n\", lctree.lca(uku[V], uku[U])->idx);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// LCA: Doubling\n\n// ???????????????\n#include<iostream>\n#include<vector>\n#include<algorithm>\n// ?????????\nclass RootedTree {\npublic:\n  RootedTree(int n);\n  int size() const;\n  int parent(int v, int n = 1) const;\n  void join(int u, int v);\n  void initialize(int root);\n  int lca(int u, int v) const;\nprivate:\n  void initialize(int current, int previous, int depth);\n  std::vector<std::vector<int>> edge_;\n  std::vector<std::vector<int>> parent_;  // parent_[v][i]: ??????v???2^i????????????\n  std::vector<int> depth_;\npublic:   // ???????????°??¨\n  void print(int c, int p) {\n    std::cout<<c<<\":\";\n    for(auto i: parent_[c])std::cout<<\" \"<<i;\n    std::cout<<std::endl;\n    for(auto n: edge_[c])if(n!=p)print(n,c);\n  }\n};\n// ?????????????????????\nRootedTree::RootedTree(int n) : edge_(n) {}\n// ????????°\nint RootedTree::size() const {return edge_.size();}\n// ??????v???n????????????\nint RootedTree::parent(int v, int n) const {\n  if(!n) return v;\n  if(__builtin_popcount(n) == 1) return parent_[v][__builtin_ctz(n)];\n  for(int i = 31 - __builtin_clz(n); 0 <= i; --i) if((n >> i) & 1) v = parent_[v][i];\n  return v;\n}\n// ????????????\nvoid RootedTree::join(int u, int v) {\n  edge_[u].push_back(v);\n  edge_[v].push_back(u);\n}\n// ?????????\nvoid RootedTree::initialize(int root) {\n  parent_.assign(size(), std::vector<int>());\n  depth_.assign(size(), 0);\n  initialize(root, root, 0);\n}\nvoid RootedTree::initialize(int current, int previous, int depth) {\n  depth_[current] = depth;\n  parent_[current].push_back(previous);\n  for(int i = 1; (1 << i) <= depth; ++i) parent_[current].push_back(parent_[parent_[current][i - 1]][i - 1]);\n  for(const auto& next: edge_[current]) if(next != previous) initialize(next, current, depth + 1);\n}\n// LCA\nint RootedTree::lca(int u, int v) const {\n  // u, v???????????±????????????\n  if(depth_[u] > depth_[v]) std::swap(u, v);\n  v = parent(v, depth_[v] - depth_[u]);\n  // LCA????±???????\n  if(u == v) return u;\n  for(int i = 31 - __builtin_clz(depth_[u]); 0 <= i; --i) {\n    if(parent_[u][i] == parent_[v][i]) continue;\n    u = parent_[u][i];\n    v = parent_[v][i];\n    i = std::min(i, 31 - __builtin_clz(depth_[u]));\n  }\n  return parent_[u][0];\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  RootedTree tree(n);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      tree.join(i, c);\n    }\n  }\n  tree.initialize(0);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << tree.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, ans, sum, last, cnt = 25000, a[100000], d[200010];\nstruct Edge { LL to,cost; };\nvector<Edge>vec[100010];\nstring str[3];\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node, lazy, num;\n\tSeg(vector<LL>v) {\n\t\tn = 1; while (n < v.size())n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = v[i];\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//区間最小などの時\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\t//区間の和の遅延\n\tvoid eval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tnode[k] += lazy[k];\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2 + 1] += lazy[k] / 2;\n\t\t\t\tlazy[k * 2 + 2] += lazy[k] / 2;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\t//区間の最小の遅延\n\tvoid ceval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != -1) {\n\t\t\tnode[k] = lazy[k];\n\t\t\tif (r - l >= 1) {\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tvoid update(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\tceval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] = x;\n\t\t\tceval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tupdate(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tupdate(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\t//ceval(i, a, b);\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n\tvoid add(LL i, LL x) {\n\t\ti = i + n - 1;\n\t\tnode[i] += x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tnode[i] = (node[i * 2 + 1] + node[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid add(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] += (b - a + 1)*x;\n\t\t\teval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tadd(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tadd(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = node[i * 2 + 1] + node[i * 2 + 2];\n\t\t}\n\t}\n\tLL getsum(LL i, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b< l || r < a)return 0;\n\t\tif (l <= a&&b <= r)return node[i];\n\t\treturn (getsum(i * 2 + 1, a, (a + b) / 2, l, r) + getsum(i * 2 + 2, (a + b + 1) / 2, b, l, r));\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t\tvec[h].push_back(Edge{ i,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\n// graph by adjacency list\ntemplate <typename T>\nstruct Edge {\n  int dst; T weight;\n  Edge(int dst, T weight) : dst(dst), weight(weight) { }\n  bool operator < (const Edge<T> &e) const {\n    return weight > e.weight;\n  }\n};\n\ntemplate <typename T>\nstruct Graph {\n  int V;\n  vector<vector<Edge<T>>> E;\n  Graph(int V) : V(V) { E.resize(V); }\n  void add_edge(int src, int dst, T weight) {\n    E[src].emplace_back(dst, weight);\n  }\n};\n\ntemplate <typename T>\nstruct HeavyLightDecomposition {\n  const Graph<T> g;\n  vector<int> vid, head, heavy, parent;\n  HeavyLightDecomposition(const Graph<T> g, int root = 0) : g(g), vid(g.V, -1), head(g.V), heavy(g.V, -1), parent(g.V) {\n    dfs(root, -1);\n    bfs(root);\n  }\n\n  int dfs(int v, int par) {\n    parent[v] = par;\n    int sub = 1, max_sub = 0;\n    for (Edge<T> child : g.E[v]) {\n      if (child.dst != par) {\n        int child_sub = dfs(child.dst, v);\n        sub += child_sub;\n        if (child_sub > max_sub) {\n          max_sub = child_sub;\n          heavy[v] = child.dst;\n        }\n      }\n    }\n    return sub;\n  }\n\n  void bfs(int root = 0) {\n    int k = 0;\n    queue<int> que({root});\n    while (not que.empty()) {\n      int r = que.front(); que.pop();\n      for (int v = r; v != -1; v = heavy[v]) {\n        vid[v] = k++;\n        head[v] = r;\n        for (Edge<T> child : g.E[v]) {\n          if (child.dst != parent[v] and child.dst != heavy[v]) que.push(child.dst);\n        }\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    while(head[u] != head[v]) {\n      if (vid[u] > vid[v]) swap(u, v);\n      v = parent[head[v]];\n    }\n    if (vid[u] > vid[v]) swap(u, v);\n    return u;\n  }\n};\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  Graph<int> g(N);\n  REP(i, N) {\n    int k; cin >> k;\n    REP(_, k) {\n      int c; cin >> c;\n      g.add_edge(i, c, 1);\n      g.add_edge(c, i, 1);\n    }\n  }\n\n  HeavyLightDecomposition<int> hld(g);\n\n  int Q; cin >> Q;\n  REP(_, Q) {\n    int u, v; cin >> u >> v;\n    cout << hld.lca(u, v) << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100005;\nconst int MAX_N = 100005;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n + n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int d, int &k){\n            assert(v < MAX_V);\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(depth[G[v][i]] <= depth[v]){\n                    dfs(G[v][i], d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, 0, k);\n            rmqInit(depth,V * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <assert.h>\n\n#define LL long long\n#define VI vector<int>\n#define VL vector<long long>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\nusing namespace std;\n\nclass LowestCommonAncestor {\n\npublic:\n    // ??\\???\n    vector<vector<int>> graph;  // ??°???????????£??\\???????????¨???\n    int log_v;                  // log(??????????????°)\n    vector<vector<int>> parent; // ??????2^k????????£?????°???????????????(???????????????????????´??????-1??¨??????)\n    vector<int> depth;          // ??????????????±???\n\n    LowestCommonAncestor(const vector<vector<int>> &graph):graph(graph) {\n        int v = graph.size();\n        this->log_v = int(log2(v)) + 1;\n        parent = vector<vector<int>>(log_v, vector<int>(v));\n        depth = vector<int>(v);\n    }\n\n    // ?????????\n    void init(int root) {\n        // parent[0]??¨depth??????????????????\n        dfs(root, -1, 0);\n\n        // parent??????????????????\n        for (int k = 0; k + 1 < this->log_v; k++) {\n            for (int v = 0; v < this->graph.size(); v++) {\n                if (parent[k][v] < 0) parent[k + 1][v] = -1;\n                else parent[k + 1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    // u??¨v???LCA????±???????\n    int lca(int u, int v) {\n        // u??¨v?????±??????????????????????????§????????????\n        if (depth[u] > depth[v]) {\n            swap(u, v);\n        }\n        for (int k = 0; k < this->log_v; ++k) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n\n        }\n        if (u == v) {\n            return u;\n        }\n\n        // ????????¢?´¢??§LCA????±???????\n        for (int k = this->log_v - 1; k >= 0; --k) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\nprivate:\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < graph[v].size(); ++i) {\n            if (graph[v][i] != p) {\n                dfs(graph[v][i], v, d + 1);\n            }\n        }\n    }\n};\n\nvector<vector<int>> graph; // ??°???????????£??\\???????????¨???\nint main(int argc, char *argv[]) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, c;\n    cin >> n;\n    \n    graph = vector<vector<int>>(n);\n    FOR(i, 0, n) {\n        cin >> k;\n        FOR(j, 0, k) {\n            cin >> c;\n            graph[i].push_back(c);\n            graph[c].push_back(i);\n        }\n    }\n\n    LowestCommonAncestor lca(graph);\n    lca.init(0);\n\n    int q, u, v;\n    cin >> q;\n    FOR(i, 0, q) {\n        cin >> u >> v;\n        cout << lca.lca(u, v) << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nclass LCA {\n  int n = 0;\n  int log2_n = 0;\n  std::vector<std::vector<int>> _parent;\n  std::vector<int> _depth;\n\npublic:\n  LCA() {}\n\n  LCA(const Graph &g, int root = 0) : n(g.size()), log2_n(log2(n) + 1), _parent(log2_n, std::vector<int>(n)), _depth(n) {\n    dfs(g, root, -1, 0);\n    rep(k, log2_n - 1) rep(v, g.size()) _parent[k + 1][v] = _parent[k][v] < 0 ? -1 : _parent[k][_parent[k][v]];\n  }\n\n  void dfs(const Graph &g, int v, int p, int d) {\n    _parent[0][v] = p;\n    _depth[v] = d;\n    for (auto &e : g[v]) {\n      if (e.dst != p) dfs(g, e.dst, v, d + 1);\n    }\n  }\n\n  int get(int u, int v) {\n    if (_depth[u] > _depth[v]) std::swap(u, v);\n    rep(k, log2_n) if ((_depth[v] - _depth[u]) >> k & 1) v = _parent[k][v];\n    if (u == v) return u;\n    for (int k = log2_n - 1; k >= 0; k--) {\n      if (_parent[k][u] != _parent[k][v]) {\n        u = _parent[k][u];\n        v = _parent[k][v];\n      }\n    }\n    return _parent[0][u];\n  }\n\n  int depth(int v) { return _depth[v]; }\n};\n\nmain {\n  int n;\n  cin >> n;\n  Graph g(n);\n  rep(i, n) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int c;\n      cin >> c;\n      g.addEdge(i, c);\n    }\n  }\n  LCA lca(g, 0);\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.get(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nconst int INF = (1<<30)-1;\nconst long long LINF = (1LL<<62)-1;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nclass LCA {\n  vector<vector<int>> par;\n  vector<int> dep;\n  void dfs(int now, int prev, vector<vector<int>> &to) {\n    if (prev < 0)\n      dep[now] = 0;\n    else {\n      par[now][0] = prev;\n      dep[now] = dep[prev] + 1;\n    }\n    for (auto next : to[now]) {\n      if (next == prev)\n        continue;\n      dfs(next, now, to);\n    }\n  }\npublic:\n  LCA(vector<vector<int>> &to, int root = 0) {\n    int n = to.size(), lg = 1;\n    while (1 << lg < n) lg++;\n    par.resize(n, vector<int>(lg, -1));\n    dep.resize(n);\n    dfs(root, -1, to);\n    for (int i = 1; i < lg; i++) {\n      for (int j = 0; j < n; j++) {\n        if (par[j][i-1] < 0)\n          par[j][i] = -1;\n        else\n          par[j][i] = par[par[j][i - 1]][i - 1];\n      }\n    }\n  }\n  int query(int x, int y) {\n    if (dep[x] < dep[y]) swap(x, y);\n    int diff = dep[x] - dep[y], lg = par[x].size();\n    for (int i = 0; i < lg; i++) {\n      if (diff >> i & 1)\n        x = par[x][i];\n    }\n    if (x == y) return x;\n    for (int i = lg-1; i >= 0; i--) {\n      if (par[x][i] != par[y][i]) {\n        x = par[x][i];\n        y = par[y][i];\n      }\n    }\n    return par[x][0];\n  }\n};\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> to(n);\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      int c;\n      cin >> c;\n      to[i].push_back(c);\n      to[c].push_back(i);\n    }\n  }\n  LCA lca(to);\n  int q;\n  cin >> q;\n  rep(query, q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.query(u, v) << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/* Задано дерево с корнем, содержащее (1 ≤ n ≤ 100 000) вершин, пронумерованных от 0 до n-1.\n * Требуется ответить на m (1 ≤ m ≤ 10 000 000) запросов о наименьшем общем предке для пары вершин.\n * Запросы генерируются следующим образом. Заданы числа a1, a2 и числа x, y и z.\n * Числа a3, ..., a2m генерируются следующим образом: ai = (x ⋅ ai-2 + y ⋅ ai-1 + z) mod n.\n * Первый запрос имеет вид (a1, a2). Если ответ на i-1-й запрос равен v, то i-й запрос имеет вид ((a2i-1 + v) mod n, a2i).\n * Для решения задачи можно использовать метод двоичного подъёма.\n */\n\nusing namespace std;\n\n// Ячейка в дереве отрезков\nclass Node {\nprivate:\n    unsigned long long left, right;\n    unsigned long long value;\n    // [left, right) - отрезок, за который \"отвечает\" данная вершина\n    // значение на отрезке\n    const unsigned long long INF = 1e9 + 7;\n\npublic:\n    Node() {\n        left = 0;\n        right = 0;\n        value = INF;\n    }\n\n    unsigned long long get_left() {\n        return left;\n    }\n\n    unsigned long long get_right() {\n        return right;\n    }\n\n    unsigned long long get_value() {\n        return value;\n    }\n\n    unsigned long long set_left(unsigned long long _left) {\n        left = _left;\n    }\n\n    unsigned long long set_right(unsigned long long _right) {\n        right = _right;\n    }\n\n    unsigned long long set_value(unsigned long long _value) {\n        value = _value;\n    }\n\n    unsigned long long get_INF() {\n        return INF;\n    }\n};\n\nclass MyGraph {\nprivate:\n    vector<unsigned long long> order;\n    vector<unsigned long long> high, first;\n    vector<vector<unsigned long long> > gr;\n    unsigned long long n, root = 0, m;\n\npublic:\n    MyGraph() {}\n\n    vector<unsigned long long>& adjacent(unsigned long long v) {\n        return gr[v];\n    }\n\n    void dfs(unsigned long long v, unsigned long long h) {\n        order.push_back(v);\n        first[v] = order.size() - 1;\n        for (unsigned long long u : adjacent(v)) {\n//            cout << v << \" \" << u << endl;\n            if (high[u] == 0) {\n                dfs(u, h + 1);\n                order.push_back(v);\n                high[u] = h + 1;\n            }\n        }\n    }\n\n    unsigned long long get_root() {\n        return root;\n    }\n\n    vector<unsigned long long>& get_order() {\n        return order;\n    }\n\n    unsigned long long get_queries_num() {\n        return m;\n    }\n\n    unsigned long long get_high(unsigned long long v) {\n        return high[v];\n    }\n\n    unsigned long long get_first(unsigned long long v) {\n        return first[v];\n    }\n\n    unsigned long long get_order_size() {\n        return order.size();\n    }\n\n    unsigned long long get_size() {\n        return n;\n    }\n\n    friend istream& operator >>(istream&, MyGraph&);\n};\n\nistream& operator >>(istream& in, MyGraph& g){\n    in >> g.n;\n    g.high.resize(g.n, 0);\n    g.first.resize(g.n);\n    g.gr.resize(g.n, vector<unsigned long long>());\n\n    for (int i = 0; i < g.n; i++) {\n        unsigned long long k;\n        in >> k;\n        for (int j = 0; j < k; j++) {\n            unsigned long long c;\n            in >> c;\n            g.gr[i].push_back(c);\n        }\n    }\n\n    in >> g.m;\n}\n\nclass SegmentTree{\nprivate:\n    vector<Node> tree; // дерево\n    unsigned long long len, n;\n    const unsigned long long INF = 1e9 + 7;\n    unsigned long long ans = 0;\n\npublic:\n    SegmentTree() {};\n\n    unsigned long long find_min(MyGraph& g, unsigned long long x, unsigned long long y) {\n        if (g.get_high(x) < g.get_high(y))\n            return x;\n        else\n            return y;\n    }\n\n    // Находит индексы вершин, отвечающих за отрезки, входящие в запрос\n    unsigned long long find_ans(unsigned long long ind, unsigned long long ll, unsigned long long rr, MyGraph& g) {\n//        cout << ind << endl;\n\n        // Если индекс выходит за пределы дерева\n        if (ind >= len * 2)\n            return INF;\n\n        // Если вершина с данным индексом не отвечает за реальные данные\n        if (tree[ind].get_value() == tree[ind].get_INF())\n            return INF;\n\n        // Если вершина \"отвечает\" за отрезок, не входящий в запрос\n        if ((tree[ind].get_left() >= rr) || (tree[ind].get_right() <= ll))\n            return INF;\n\n//        cout << ind << \" \" << tree[ind].get_left() << \" \" << tree[ind].get_right() << endl;\n//        cout << \"  \" << ll << \" \" << rr << endl;\n\n        // Если вершина отвечает за отрезок, полностью лежащий в запросе\n        if ((tree[ind].get_left() >= ll) && (tree[ind].get_right() <= rr)) {\n//            cout << \"value \" << tree[ind].get_value() << endl;\n            return tree[ind].get_value();\n        }\n\n        unsigned long long x = find_ans(ind * 2, ll, rr, g);\n//        cout << x << endl;\n        unsigned long long y = find_ans(ind * 2 + 1, ll, rr, g);\n//        cout << y << endl;\n\n        if (y == INF)\n            return x;\n        if (x == INF)\n            return y;\n\n        return find_min(g, x, y);\n    }\n\n    // Выполняет запросы\n    void queries(MyGraph& g) {\n//        unsigned long long a1, a2, x, y, z;\n//        cin >> a1 >> a2 >> x >> y >> z;\n        unsigned long long a1, a2;\n\n        for (int i = 0; i < g.get_queries_num(); i++) {\n            cin >> a1 >> a2;\n//            cout << \"---query \" << i + 1 << \"---\\n\";\n            unsigned long long left = g.get_first(a1), right = g.get_first(a2);\n            if (right < left)\n                swap(left, right);\n//            cout << left << \" \" << r\n// << endl;\n            unsigned long long v = find_ans(1, left, right + 1, g);\n//            a1 = (x * a1 + y * a2 + z) % n;\n//            a2 = (x * a2 + y * a1 + z) % n;\n//            a1 = (a1 + v) % n;\n            ans += v;\n            cout << v << endl;\n        }\n    }\n\n    void build_tree(MyGraph& g) {\n        n = g.get_size();\n        unsigned long long len_log = (unsigned long long) trunc(log2((double) g.get_order_size())) + 1;\n        len = (1 << len_log);\n        tree.resize(len * 2);\n\n        vector<unsigned long long>& order1 = g.get_order();\n        for (int i = 0; i < len; ++i) {\n            if (i < g.get_order_size())\n                tree[i + len].set_value(order1[i]);\n            else\n                tree[i + len].set_value(INF);\n            tree[len + i].set_left(i);\n            tree[len + i].set_right(i + 1);\n        }\n\n        for (int i = len - 1; i > 0; --i) {\n            unsigned long long ind1 = 2 * i, ind2 = 2 * i + 1;\n            tree[i].set_left(tree[ind1].get_left());\n            tree[i].set_right(tree[ind2].get_right());\n            if (tree[ind2].get_value() == INF)\n                tree[i].set_value(tree[ind1].get_value());\n            else\n                tree[i].set_value(find_min(g, tree[ind1].get_value(), tree[ind2].get_value()));\n        }\n\n//        for (int i = 1; i < tree.size(); i++)\n//            cout << tree[i].get_value() << \" \";\n//        cout << endl;\n    }\n\n    friend ostream& operator <<(ostream&, SegmentTree&);\n};\n\nostream& operator <<(ostream& out, SegmentTree& t) {\n    out << t.ans << endl;\n}\n\nint main() {\n    MyGraph graph;\n    cin >> graph;\n//    cout << \"--dfs--\" << endl;\n    graph.dfs(graph.get_root(), 0);\n//    cout << graph.get_size() << endl;\n//    for (int i = 0; i < graph.get_size(); i++)\n//        cout << graph.get_high(i) << \" \";\n//    cout << endl;\n    SegmentTree st;\n//    cout << \"keka\\n\";\n    st.build_tree(graph);\n//    cout << \"peka\\n\";\n    st.queries(graph);\n//    cout << st;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Lowest Common Ancestor\n//最小共通先祖\n//二部探索を用いる方法\n/*\nint main(){\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    a = max(a, b);\n    a = max(max(a, b), max(c, d));\n\n}*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 10000\n#define MAX_LOG_V 100\nvector<int> G[MAX_V];                   //グラフの隣接リスト\nint root;                               //根の頂点番号\nint parent[MAX_LOG_V][MAX_V];           //parent[i][j] := 頂点jから2^i親をたどって到達する頂点\nint depth[MAX_V];                       //根からの深さ\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    //parent[0]とdepthを初期化する\n    dfs(root, -1, 0);\n    //parentを初期化する\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親をたどる\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u] >> k) & 1){    //これあテクい\n            v = parent[k][v];\n        }\n    }\n\n    if(u == v) return u;\n\n\n    //二部探索でLCAを求める\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n\n    return parent[0][u];      //uの親を返す\n}\n\nint main(){\n\n    //0-indexed\n    int V; cin >> V;\n    root = 0;\n    for(int i = 0; i < V; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    init(V);\n    int q; cin >> q;\n\n    for(int i = 0; i < q; i++){\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<utility>\n\nstruct min_monoid {\n    long long val;\n    min_monoid() : val(LLONG_MAX) {}\n    min_monoid(long long val) : val(val) {}\n    bool operator==(const min_monoid &rhs) const { return val == rhs.val; }\n    bool operator!=(const min_monoid &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    min_monoid &operator+=(const min_monoid &rhs) {\n        val = std::min(val, rhs.val);\n        return *this;\n    }\n    min_monoid operator+(const min_monoid rhs) const { return min_monoid(*this) += rhs; }\n    friend std::istream &operator>>(std::istream &is, min_monoid &rhs) {\n        long long v;\n        is >> v;\n        rhs = min_monoid(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const min_monoid &rhs) { return os << rhs.val; }\n};\n\n#include<vector>\n\ntemplate<typename T>\nstruct segment_tree {\n    int n;\n    T ZERO;\n    std::vector<T> data;\n    int get_size(int n_) const {\n        int ret = 1;\n        while (ret < n_) { ret <<= 1; }\n        return ret;\n    }\n    segment_tree(int n_, T ZERO = T()) : n(get_size(n_)), ZERO(ZERO), data(n << 1, ZERO) {}\n    segment_tree(const std::vector<T> &src, T ZERO = T()) : n(get_size(src.size())), ZERO(ZERO), data(n << 1) {\n        std::copy(src.begin(), src.end(), data.begin() + n);\n        for (int i = n - 1; i > 0; i--) { data[i] = data[i << 1] + data[(i << 1) + 1]; }\n    }\n    void set(int i, T x) {\n        i += n;\n        data[i] = x;\n        while (i > 1) {\n            i >>= 1;\n            data[i] = data[i << 1] + data[(i << 1) + 1];\n        }\n    }\n    T operator[](int i) const { return data[i + n]; }\n    T get_sum(int l, int r) const {\n        T ret = ZERO;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) { ret += data[l], l++; }\n            if (r & 1) { ret += data[r - 1]; }\n        }\n        return ret;\n    }\n};\n\n#include<vector>\n#include<functional>\n\nstruct heavy_light_decomposition {\n    int n;\n    std::vector<std::vector<int>> graph;\n    std::vector<int> par, size, in, out, head;\n    int idx;\n    heavy_light_decomposition(int n)\n        : n(n), graph(n), par(n), size(n), in(n), out(n), head(n) {}\n    void add_edge(int u, int v) {\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    void dfs_size(int v, int p) {\n        size[v] = 1;\n        par[v] = p;\n        for (int i = 0; i < graph[v].size(); i++) {\n            int &u = graph[v][i];\n            if (u == p) { continue; }\n            dfs_size(u, v);\n            size[v] += size[u];\n            if (size[u] > size[graph[v][0]]) { std::swap(u, graph[v][0]); }\n        }\n    }\n    void dfs_hld(int v) {\n        in[v] = idx++;\n        for (int i = 0; i < graph[v].size(); i++) {\n            int u = graph[v][i];\n            if (u == par[v]) { continue; }\n            head[u] = (i == 0 ? head[v] : u);\n            dfs_hld(u);\n        }\n        out[v] = idx;\n    }\n    std::vector<int> build(int root) {\n        idx = 0;\n        dfs_size(root, -1);\n        head[root] = root;\n        dfs_hld(root);\n        std::vector<int> ret(n);\n        for (int i = 0; i < n; i++) { ret[in[i]] = i; }\n        return ret;\n    }\n    int get_lca(int u, int v) {\n        while (true) {\n            if (in[u] > in[v]) { std::swap(u, v); }\n            if (head[u] == head[v]) { return u; }\n            v = par[head[v]];\n        }\n    }\n    void path_query(int u, int v, const std::function<void(int, int)> &f) {\n        while (true) {\n            if (in[u] > in[v]) { std::swap(u, v); }\n            f(std::max(in[head[v]], in[u]), in[v] + 1);\n            if (head[u] == head[v]) { return; }\n            v = par[head[v]];\n        }\n    }\n    void subtree_query(int v, const std::function<void(int, int)> &f) {\n        f(in[v], out[v]);\n    }\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    heavy_light_decomposition hld(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            hld.add_edge(i, c);\n        }\n    }\n    vector<int> v = hld.build(0);\n    vector<min_monoid> src(n);\n    for (int i = 0; i < n; i++) { src[i] = v[i]; }\n    segment_tree<min_monoid> st(src);\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        int a = hld.get_lca(u, v);\n        int b = INT_MAX;\n        hld.path_query(u, v, [&](int l, int r) { b = min(b, (int) st.get_sum(l, r).val); });\n        assert(a == b);\n        cout << a << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define INCLUDE_EULER_TOUR_HPP\n#include <stack>\n#include <vector>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> begin, end;\n  std::vector<int> id, depth;\n\n  EulerTour(int N) : T(N), begin(N), end(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) begin[f.u] = id.size();\n      end[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#define INCLUDE_RMQ_HPP\n#include <algorithm>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L;\n\n  std::vector<int> lg;\n  std::vector<BitIndex> small;\n  std::vector<std::vector<Index>> large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n\nprivate:\n  Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), lg(1 << S), small(N), large(L, std::vector<Index>(LG_L)) {\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li][0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li][0] = F(large[li][0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li][x + 1] = F(large[li][x], large[li + (1 << x)][x]);\n      }\n    }\n    std::vector<Index> st;\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      st.clear();\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (!st.empty() && f(i + si, st.back())) st.pop_back();\n        small[i + si] |= 1 << si;\n        if (!st.empty()) small[i + si] |= small[st.back()];\n        st.push_back(i + si);\n      }\n    }\n  }\n  int ntz(int x) const { return lg[x & -x]; }\n  int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l][x], large[r - (1 << x) + 1][x]);\n  }\n};\n#include <utility>\n\nstruct LCA {\n  EulerTour euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.begin[u];\n    int r = euler_tour.begin[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(std::move(et));\n\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct SparseTable {\n    vector<vector<T>> st;\n    vector<int> lookup;\n\n    SparseTable(const vector<T>& v) {\n        int b = 0;\n        while ((1 << b) <= v.size()) b++;\n        st.assign(b, vector<T>(1 << b));\n        for (int i = 0; i < v.size(); i++) {\n            st[0][i] = v[i];\n        }\n        for (int i = 1; i < b; i++) {\n            for (int j = 0; j + (1 << i) <= 1 << b; j++) {\n                st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n            }\n        }\n        lookup.resize(v.size() + 1);\n        for (int i = 2; i < lookup.size(); i++) {\n            lookup[i] = lookup[i >> 1] + 1;\n        }\n    }\n\n    T query(int l, int r) {\n        int b = lookup[r - l];\n        return min(st[b][l], st[b][r - (1 << b)]);\n    }\n};\n\nstruct LCA {\n    int n, k = 0;\n    vector<vector<int>> adj;\n    vector<int> vs, depth, id, D;\n    SparseTable<pair<int, int>> *st;\n\n    void dfs(int v, int p, int d) {\n        id[v] = k;\n        vs[k] = v;\n        depth[k++] = d;\n        D[v] = d;\n        for (int s : adj[v]) {\n            if (s != p) {\n                dfs(s, v, d + 1);\n                vs[k] = v;\n                depth[k++] = d;\n            }\n        }\n    }\n\n    LCA(const vector<vector<int>>& adj) : n(adj.size()), adj(adj), vs(2 * adj.size() - 1), depth(2 * adj.size() - 1), id(adj.size()), D(adj.size()) {\n        dfs(0, -1, 0);\n        vector<pair<int, int>> ds;\n        for (int i = 0; i < depth.size(); i++) {\n            ds.emplace_back(depth[i], i);\n        }\n        st = new SparseTable<pair<int, int>>(ds);\n    }\n\n    int lca(int u, int v) {\n        return vs[st->query(min(id[u], id[v]), max(id[u], id[v]) + 1).second];\n    }\n\n    int dist(int u, int v) {\n        return D[u] + D[v] - 2 * D[lca(u, v)];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a;\n            cin >> a;\n            adj[i].push_back(a);\n            adj[a].push_back(i);\n        }\n    }\n    LCA lca(adj);\n    int q;\n    cin >> q;\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n        cout << lca.lca(a, b) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 400){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]) parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c;\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return (node_[vl] < node_[vr] ? left_child(k) : right_child(k));\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    std::vector<Node> node_;\n};\n//*/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n\n    RangeMinimumQuery rmq(n);\n    for(int i = 0; i < n; ++i) rmq.update(i, t.depth(i));\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n        rmq.find(u, v);\n//         cout << rmq.find_index(u, v) - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n/*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n*/\n\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint N;\nvi depth;\nint maxdepth = 0;\nGraph G;\nvvi dblpar;\n\nvoid dfs1(int pos, int d = 0) {\n\tdepth[pos] = d;\n\tmaxdepth = max(maxdepth, d);\n\tfor (auto ch : G[pos]) {\n\t\tdfs1(ch.to, d + 1);\n\t}\n}\n\nvoid dfs2(int pos, int par, int dbl) {\n\tif (dbl == 0) {\n\t\tdblpar[0][pos] = par;\n\t}\n\telse {\n\t\tdblpar[dbl][pos] = dblpar[dbl - 1][dblpar[dbl - 1][pos]];\n\t}\n\tfor (auto ch : G[pos]) {\n\t\tdfs2(ch.to, pos, dbl);\n\t}\n}\n\nint parent(int pos, int step) {\n\tint ret = pos;\n\tint dbl = 0;\n\twhile (step > 0) {\n\t\tif ((step & 1) != 0) {\n\t\t\tret = dblpar[dbl][ret];\n\t\t}\n\t\tstep >>= 1;\n\t\tdbl++;\n\t}\n\treturn ret;\n}\n\nint bindigit(int n) {\n\tint ret = 0;\n\twhile (n > 0) {\n\t\tret++;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\tdepth = vi(N);\n\tG = Graph(N);\n\trep(i, N) {\n\t\tint num;\n\t\tcin >> num;\n\t\trep(j, num) {\n\t\t\tint ch;\n\t\t\tcin >> ch;\n\t\t\tG[i].push_back(Edge{ i,ch,1 });\n\t\t}\n\t}\n\n\tdfs1(0);\n\tint D = bindigit(maxdepth) + 1;\n\tdblpar = vvi(D, vi(N));\n\trep(i, D) {\n\t\tdfs2(0, 0, i);\n\t}\n\t/*\n\trep(i, N) {\n\t\tcout << depth[i] << \":\";\n\t\trep(j, D) {\n\t\t\tcout << dblpar[j][i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\tint Q;\n\tcin >> Q;\n\trep(q, Q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (depth[u] < depth[v]) {\n\t\t\tswap(u, v);\n\t\t}\n\t\tu = parent(u, depth[u] - depth[v]);\n\t\t// u,v???????????±???\n\t\t/*\n\t\tif (u == v) {\n\t\t\tcout << u << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t*/\n\t\tint ng = -1, ok = depth[u];\n\t\twhile (ok - ng > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (parent(u, mid) == parent(v, mid)) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\tcout << parent(u, ok) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, ans, sum, last, cnt = 25000, a[100000], d[200010];\nstruct Edge { LL to,cost; };\nvector<Edge>vec[100000];\nstring str[3];\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node, lazy, num;\n\tSeg(vector<LL>v) {\n\t\tn = 1; while (n < v.size())n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = v[i];\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//区間最小などの時\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\t//区間の和の遅延\n\tvoid eval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tnode[k] += lazy[k];\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2 + 1] += lazy[k] / 2;\n\t\t\t\tlazy[k * 2 + 2] += lazy[k] / 2;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\t//区間の最小の遅延\n\tvoid ceval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != -1) {\n\t\t\tnode[k] = lazy[k];\n\t\t\tif (r - l >= 1) {\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tvoid update(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\tceval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] = x;\n\t\t\tceval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tupdate(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tupdate(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\t//ceval(i, a, b);\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n\tvoid add(LL i, LL x) {\n\t\ti = i + n - 1;\n\t\tnode[i] += x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tnode[i] = (node[i * 2 + 1] + node[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid add(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] += (b - a + 1)*x;\n\t\t\teval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tadd(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tadd(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = node[i * 2 + 1] + node[i * 2 + 2];\n\t\t}\n\t}\n\tLL getsum(LL i, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b< l || r < a)return 0;\n\t\tif (l <= a&&b <= r)return node[i];\n\t\treturn (getsum(i * 2 + 1, a, (a + b) / 2, l, r) + getsum(i * 2 + 2, (a + b + 1) / 2, b, l, r));\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t\tvec[h].push_back(Edge{ i,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\n#define sz(x) ((int)x.size())\n\nstruct UnionFind {\n    vi data;\n    int comp;\n    UnionFind() {}\n    UnionFind(int size) {\n        init(size);\n    }\n    void init(int size) {\n        data.assign(size, -1);\n        comp = size;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        if (data[x] < 0) {\n            return x;\n        } else {\n            return data[x] = root(data[x]);\n        }\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() {\n        return comp;\n    }\n};\n\nstruct LCA {\n    using Query = pii;\n    Graph g;\n    vi color;\n    vi ancestor;\n    vector<vector<pair<int, Query>>> query_set;\n    vi res;\n    UnionFind uf;\n    LCA(const vvi &g, vector<Query> &query) :\n            g         (g),\n            color     (sz(g)),\n            ancestor  (sz(g)),\n            query_set (sz(g)),\n            res       (sz(query)),\n            uf        (sz(g))\n    {\n        int qs = sz(query);\n        rep(i, 0, qs) {\n            query_set[query[i].first ].emplace_back(i, query[i]);\n            query_set[query[i].second].emplace_back(i, query[i]);\n        }\n    }\n    void visit(int v, int prev) {\n        ancestor[uf.root(v)] = v;\n        for (auto &w : g[v]) {\n            if (w == prev) {\n                continue;\n            }\n            visit(w, v);\n            uf.unite(v, w);\n            ancestor[uf.root(v)] = v;\n        }\n        color[v] = 1;\n        for (auto &p : query_set[v]) {\n            Query q = p.second;\n            int w = (q.second == v ? q.first : (q.first == v ? q.second : -1));\n            if (w == -1 || !color[w]) {\n                continue;\n            }\n            res[p.first] = ancestor[uf.root(w)];\n        }\n    }\n    vi solve(int root) {\n        visit(root, -1);\n        return res;\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> G(N);\n    rep(v, 0, N) {\n        int K;\n        cin >> K;\n        rep(k, 0, K) {\n            int X;\n            cin >> X;\n            G[v].push_back(X);\n        }\n    }\n    int Q;\n    cin >> Q;\n    vector<pii> queries;\n    rep(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        queries.emplace_back(U, V);\n    }\n    LCA lca(G, queries);\n    vi res = lca.solve(0);\n\n    for (int ans : res) {\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int nmax=100010;\n\nvector<int> graph[nmax];\nint parent[nmax][20]; // all is -1\nint depth[nmax];\n\nvoid dfs(int v,int p,int d){\n\tparent[v][0]=p;\n\tdepth[v]=d;\n\tfor(auto &v2:graph[v]) if(v2!=p) dfs(v2,v,d+1);\n}\n\nint lca(int u,int v){\n\tif(depth[u] < depth[v]) swap(u,v);\n\tfor(int i=19;i>=0;--i) if((depth[u]-depth[v])>>i&1) u=parent[u][i];\n\tif(u==v) return u;\n\tfor(int i=19;i>=0;--i){\n\t\tif(parent[u][i]!=parent[v][i]){\n\t\t\tu=parent[u][i];\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\treturn parent[u][0];\n}\n\nint main(void){\n\tint n; cin >> n;\n\trep(i,n){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint v; cin >> v;\n\t\t\tgraph[i].push_back(v);\n\t\t}\n\t}\n\trep(i,n)rep(j,20) parent[i][j]=-1;\n\tdfs(0,-1,0);\n\trep(i,n)rep(j,18) parent[i][j+1]=parent[parent[i][j]][j];\n\tint q; cin >> q;\n\trep(i,q){\n\t\tint u,v; cin >> u >> v;\n\t\tcout << lca(u,v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdint>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::uint_fast32_t;\n\nprivate:\n\tstd::vector<std::pair<bool, size_type>> tree;\n\npublic:\n\tUnionFind(const size_type size) : tree(size, std::make_pair(1, 1)) {}\n\tsize_type find(const size_type x) {\n\t\tassert(x < size());\n\t\tif (tree[x].first)\n\t\t\treturn x;\n\t\treturn tree[x].second = find(tree[x].second);\n\t}\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (tree[x].second < tree[y].second)\n\t\t\tstd::swap(x, y);\n\t\ttree[x].second += tree[y].second;\n\t\ttree[y] = std::make_pair(0, x);\n\t\treturn true;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn tree[find(x)].second;\n\t}\n\tsize_type size() const noexcept { return tree.size(); }\n\tbool empty() const noexcept { return tree.empty(); }\n};\n\n#include <cstddef>\n#include <functional>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\n\ntemplate <class GraphContainer, class UnionFindDataStructure>\nstd::vector<typename GraphContainer::size_type> TarjansOfflineLCA(\n\tconst GraphContainer &graph, const typename GraphContainer::size_type root,\n\tconst std::vector<std::pair<typename GraphContainer::size_type,\n\ttypename GraphContainer::size_type>> &queries) {\n\tusing size_type = typename GraphContainer::size_type;\n\tconst size_type size_ = graph.size();\n\tUnionFindDataStructure uft(size_);\n\tstd::vector<size_type> ret(queries.size(), size_), anc(size_);\n\tstd::vector<std::vector<std::size_t>> qset(size_);\n\tstd::stack<std::pair<size_type, size_type>> st;\n\n\tfor (std::size_t i = 0; i < queries.size(); ++i) {\n\t\tqset[queries[i].first].emplace_back(i);\n\t\tqset[queries[i].second].emplace_back(i);\n\t}\n\n\tst.emplace(root, 0);\n\n\tstd::function<void(const size_type, const size_type)> dfs =\n\t\t[&](const size_type v, const size_type prev) {\n\t\tanc[v] = v;\n\t\tfor (const auto e : graph[v]) {\n\t\t\tif (e.to != prev) {\n\t\t\t\tdfs(e.to,v);\n\t\t\t\tuft.unite(v, e.to);\n\t\t\t\tanc[uft.find(v)] = v;\n\t\t\t}\n\t\t}\n\t\tfor (const auto e : qset[v])\n\t\t\tif (ret[e] == size_)\n\t\t\t\tret[e] = v;\n\t\t\telse\n\t\t\t\tret[e] = anc[uft.find(ret[e])];\n\t};\n\tdfs(root, size_);\n\treturn ret;\n}\n\n#include <cstddef>\n#include <vector>\n\nstruct edge {\n\tusing cost_type = int;\n\tusing size_type = std::size_t;\n\n\tstd::size_t to;\n};\n\ntemplate <class Edge> using Graph = std::vector<std::vector<Edge>>;\n\n#include<cstdio>\nint main() {\n\tusing uint = unsigned int;\n\tuint n;\n\tscanf(\"%u\", &n);\n\tGraph<edge> g(n);\n\tfor (uint i = 0;i < n;++i) {\n\t\tuint k, c;\n\t\tscanf(\"%u\", &k);\n\t\twhile (k--) {\n\t\t\tscanf(\"%u\", &c);\n\t\t\tg[i].push_back({ c });\n\t\t}\n\t}\n\tuint q;\n\tscanf(\"%u\", &q);\n\tusing S = typename Graph<edge>::size_type;\n\tstd::vector<std::pair<S, S>> Q;\n\twhile (q--) {\n\t\tuint u, v;\n\t\tscanf(\"%u%u\", &u, &v);\n\t\tQ.emplace_back(u, v);\n\t}\n\tconst auto &&ans=TarjansOfflineLCA<Graph<edge>, UnionFind>(g, 0, Q);\n\tfor (const auto e : ans)\n\t\tprintf(\"%u\\n\", e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n#include <random>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//const ll mod = 998244353;\nconst ll mod = 1000000007;\nconst int inf = 1e9;\nconst ll linf = 1e18;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\n\n#define REP(i, n) for (ll i = 0; i < (n); ++i)\n#define REP_FROM(i, j, n) for (ll i = (j); i < (n); ++i)\n#define REP_REV(i, n) for (ll i = n-1; i >= 0; --i)\n#define REP_FROM_REV(i, j, n) for (ll i = n-1; i >= j; --i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ll(x.size())\n\ntemplate<typename T>\ninline T chmax(T &a, const T b) { return a = (a < b) ? b : a; }\n\ntemplate<typename T>\ninline T chmin(T &a, const T b) { return a = (a > b) ? b : a; }\n\nll power(ll base, ll exponent) {\n  if (exponent % 2) {\n    return power(base, exponent - 1) * base % mod;\n  } else if (exponent) {\n    ll root_ans = power(base, exponent / 2);\n    return root_ans * root_ans % mod;\n  } else { return 1; }\n}\n\nll inverse(ll x) { return power(x, mod - 2); }\n\nll gcd(ll a, ll b) {\n  if (a < b) gcd(b, a);\n  ll r;\n  while (r = a % b) {\n    a = b;\n    b = r;\n  }\n  return b;\n}\n\ntemplate<typename T>\nll sum(T begin, T end) { return accumulate(begin, end, 0ll); }\n\nstruct combination {\n    vector<ll> fact, inv;\n\n    combination(int sz) : fact(sz + 1), inv(sz + 1) {\n      fact[0] = 1;\n      for (int i = 1; i <= sz; i++) { fact[i] = fact[i - 1] * i % mod; }\n      inv[sz] = power(fact[sz], mod - 2);\n      for (int i = sz - 1; i >= 0; i--) { inv[i] = inv[i + 1] * (i + 1) % mod; }\n    }\n\n    ll C(int p, int q) const {\n      if (q < 0 || p < q) return 0;\n      return (fact[p] * inv[q] % mod * inv[p - q] % mod);\n    }\n};\n\nusing Pair = pair<int, int>;\nusing LPair = pair<ll, ll>;\n\ntemplate<ll Modulus>\nstruct ModInt {\n    ll a;\n\n    constexpr ModInt(const ll x = 0) noexcept: a((x % mod + mod) % mod) {}\n\n    constexpr ll &value() noexcept { return a; }\n\n    constexpr const ll &value() const noexcept { return a; }\n\n    constexpr ModInt operator+(const ModInt x) const noexcept {\n      return ModInt(*this) += x;\n    }\n\n    constexpr ModInt operator-(const ModInt x) const noexcept {\n      return ModInt(*this) -= x;\n    }\n\n    constexpr ModInt operator*(const ModInt x) const noexcept {\n      return ModInt(*this) *= x;\n    }\n\n    constexpr ModInt operator/(const ModInt x) const noexcept {\n      return ModInt(*this) /= x;\n    }\n\n    constexpr ModInt &operator+=(const ModInt x) noexcept {\n      a += x.a;\n      if (a >= Modulus) {\n        a -= Modulus;\n      }\n      return *this;\n    }\n\n    constexpr ModInt &operator-=(const ModInt x) noexcept {\n      if (a < x.a) {\n        a += Modulus;\n      }\n      a -= x.a;\n      return *this;\n    }\n\n    constexpr ModInt &operator*=(const ModInt x) noexcept {\n      a = a * x.a % Modulus;\n      return *this;\n    }\n\n    constexpr ModInt &operator/=(ModInt x) noexcept {\n      ll exp = Modulus - 2;\n      while (exp) {\n        if (exp % 2) {\n          *this *= x;\n        }\n        x *= x;\n        exp /= 2;\n      }\n      return *this;\n    }\n\n    constexpr ModInt operator-() noexcept {\n      return ModInt(-a);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &m) {\n      os << m.a;\n      return os;\n    }\n};\n\nusing mint = ModInt<mod>;\n\nstruct DoublingLCA {\n    int root;\n    vector<vector<int>> children;\n    vector<vector<int>> d_parents;\n    vector<int> depth;\n\n    DoublingLCA(const vector<vector<int>> &children, const int root) noexcept: root(root), children(children) {}\n\n    void build() {\n      vector<int> path(1, root);\n      d_parents.resize(31, vector<int>(sz(children), -1));\n      depth.resize(sz(children), inf);\n      dfs(path);\n    }\n\n    int get_parent(int node, int length) {\n      for(int i = 0; length; i++) {\n        if(length & 1<<i) {\n          length -= 1<<i;\n          node = d_parents[i][node];\n        }\n      }\n      return node;\n    }\n\n    int lca(int n1, int n2) {\n      if(depth[n1] < depth[n2]) swap(n1, n2);\n      n1 = get_parent(n1, depth[n1] - depth[n2]);\n      if(n1 == n2) return n1;\n      REP_REV(i, 31) {\n        if(1<<i > depth[n1]) continue;\n        if (d_parents[i][n1] != d_parents[i][n2] ) {\n          n1 = d_parents[i][n1];\n          n2 = d_parents[i][n2];\n        }\n      }\n      return d_parents[0][n1];\n    }\n\nprivate:\n    void dfs(vector<int> &path) {\n      int cur = path[sz(path)-1];\n      depth[cur] = path.size()-1;\n      for(int i = 1, j = 0; i < sz(path);i*=2,j++) {\n        d_parents[j][cur] = path[sz(path)-1-i];\n      }\n      for(int child: children[cur]) {\n        if(depth[child] != inf) continue;\n        path.push_back(child);\n        dfs(path);\n        path.erase(--path.end());\n      }\n    }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(15);\n  combination tree(2e6 + 10);\n  int n;\n  cin >> n;\n  vector<vector<int>> c(n);\n  REP(i, n) {\n    int k;\n    cin >> k;\n    REP(j, k) {\n      int x;\n      cin >> x;\n      c[i].push_back(x);\n    }\n  }\n  DoublingLCA lca(c, 0);\n  lca.build();\n  int q;\n  cin >> q;\n  REP(_, q) {\n    int x, y;\n    cin >> x >> y;\n    cout << lca.lca(x, y) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n \ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n \nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size) {for(int i=0;i<size;i++)data[i]=i;}\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x]==x ? x : (data[x] = root(data[x]));\n  }\n};\n \nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n \nint main(){\n    int k,i,V,E,s,t,e;\n    //for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n        scanf(\"%d\",&V);\n        Graph g(V);\n        for(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n            scanf(\"%d\",&t),g[i].push_back(Edge(i,t,1));\n        vector<Query>qs;\n        for(scanf(\"%d\",&k),i=0;i<k;i++){\n            scanf(\"%d%d\",&s,&t);\n            qs.push_back(Query(s,t));\n        }\n        leastCommonAncestor(g,0,qs);\n        for(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n    //}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 100000\nusing namespace std;\nusing pi = pair<int, int>;\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) const {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {}\n\tSegmentTree(const vector<T>& data_, T id_, func_t merge_) :\n\t\tn(size(data_.size())), id(id_), merge(merge_), data(size(data_.size()) * 2, id_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int l, int r) const {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n\tT operator[](int i) const {\n\t\treturn data[i + n];\n\t}\n};\n\nint N, rt;\nvector<int> G[MAX];\nint depth[MAX], used[MAX], id[MAX];\nvector<int> vs, de;\n\nvoid Add(int a, int b) {\n\tG[a].push_back(b);\n\tG[b].push_back(a);\n}\n\nvoid dfs(int s, int d) {\n\tused[s] = 1;\n\n\tvs.push_back(s);\n\tde.push_back(d);\n\tfor (int v : G[s]) {\n\t\tif (!used[v]) {\n\t\t\tdfs(v, d + 1);\n\n\t\t\tvs.push_back(s);\n\t\t\tde.push_back(d);\n\t\t}\n\t}\n}\n\nSegmentTree<pi> Init() {\n\tfill(used, used + N, 0);\n\tfill(id, id + N, -1);\n\tdfs(rt, 0);\n\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\tif (id[vs[i]] == -1) {\n\t\t\tid[vs[i]] = i;\n\t\t}\n\t}\n\tvector<pi> r((int)vs.size());\n\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\tr[i] = pi(de[i], vs[i]);\n\t}\n\tSegmentTree<pi> res(r, pi(N, -1), [](pi a, pi b) { return a.first <= b.first ? a : b; });\n\tfor (int i = 0; i < N; i++) {\n\t\tdepth[i] = res[id[i]].first;\n\t}\n\treturn res;\n}\n\nint LCA(const SegmentTree<pi>& st, int a, int b) {\n\treturn st.Find(min(id[a], id[b]), max(id[a], id[b])).second;\n}\n\nint main()\n{\n\tcin >> N;\n\tfor (int i = 0, k; i < N; i++) {\n\t\tcin >> k;\n\t\tfor (int j = 0, c; j < k; j++) {\n\t\t\tcin >> c;\n\t\t\tAdd(i, c);\n\t\t}\n\t}\n\tint Q, a, b;\n\tauto st = Init();\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> a >> b;\n\t\tcout << LCA(st, a, b) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ??¨\n\n#include<algorithm>\n#include<functional>\n#include<vector>\n\nusing Size = int;\nusing Vertex = int;\nusing Weight = long long;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// ????????? O(|V| + |E|)\nVertex farthest(const Graph& G, Vertex v) {\n  std::vector<Weight> d(G.size());\n  std::function<Vertex(Vertex, Vertex)> dfs = [&](Vertex cur, Vertex pre) {\n    auto res = cur;\n    for(const auto& e: G[cur]) if(e.to != pre) {\n      auto nex = dfs(e.to, e.from);\n      auto w = e.weight + d[e.to];\n      if(w <= d[cur]) continue;\n      d[cur] = w;\n      res = nex;\n    }\n    return res;\n  };\n  return dfs(v, -1);\n}\n\n// ???????????? O(|V| + |E|)\nstd::pair<Vertex, Vertex> farthest(const Graph& G) {\n  auto v = farthest(G, 0);\n  return std::make_pair(v, farthest(G, v));\n}\n\n// ?????? (????????????????????§????????¢) O(|V| + |E|)\nWeight height(const Graph& G, Vertex v) {\n  std::vector<Weight> d(G.size());\n  std::function<Weight(Vertex, Vertex)> dfs = [&](Vertex cur, Vertex pre) {\n    for(const auto& e: G[cur]) if(e.to != pre) d[cur] = std::max(d[cur], e.weight + dfs(e.to, e.from));\n    return d[cur];\n  };\n  return dfs(v, -1);\n}\n\n// ??´??? O(|V| + |E|)\nWeight diameter(const Graph& G) {\n  return height(G, farthest(G, 0));\n}\n\n// ?????§??¬????????? O(|V| + |E|)\n//   (??????) source ??¨????????£?????????????????????, ?????§??¬????????????????????°?????????\nSize maximum_independent_set(const Graph& G, Vertex source = 0) {\n  std::vector<std::vector<Size>> dp(2, std::vector<Size>(G.size(), -1));\n  std::function<Size(bool, Vertex, Vertex)> dfs = [&](bool opt, Vertex cur, Vertex pre) {\n    if(~dp[opt][cur]) return dp[opt][cur];\n    dp[opt][cur] = opt ? 1 : 0;\n    for(const auto& e: G[cur]) if(e.to != pre) {\n      if(opt) dp[opt][cur] += dfs(false, e.to, e.from);\n      else    dp[opt][cur] += std::max(dfs(false, e.to, e.from), dfs(true, e.to, e.from));\n    }\n    return dp[opt][cur];\n  };\n  return std::max(dfs(false, source, -1), dfs(true, source, -1));\n}\n\n// Heavy Light Decomposition\n//   ??????: https://blog.anudeep2011.com/heavy-light-decomposition/\n//   ?§????: O(|V| + |E|)\n//   LCA:  O(log |V|)\nclass HeavyLightDecomposition {\n public:\n  HeavyLightDecomposition(const Graph& G, Vertex root) : chain(G.size()), position(G.size()), parent(G.size(), NIL), depth(G.size(), NIL), subsize(G.size()) {\n    // construct a tree\n    std::function<Size(Vertex, Size)> dfs = [&](Vertex cur, Size d) {\n      depth[cur] = d;\n      subsize[cur] = 1;\n      for(const auto& e: G[cur]) if(depth[e.to] == NIL) {\n        parent[e.to] = e.from;\n        subsize[cur] += dfs(e.to, d+1);\n      }\n      return subsize[cur];\n    };\n    // HLD\n    std::function<Size(Vertex, Size)> HLD = [&](Vertex cur, Size id) {\n      // add to a chain\n      if(head.size() <= id) {\n        head.emplace_back(cur);\n        size.emplace_back(0);\n      }\n      chain[cur] = id;\n      position[cur] = size[id];\n      ++size[id];\n      // find the special child\n      auto max = 0, nex = 0;\n      for(const auto& e: G[cur]) if(e.from == parent[e.to]) if(subsize[e.to] > max) {\n        max = std::max(max, subsize[e.to]);\n        nex = e.to;\n      }\n      // if cur is not a leaf\n      if(max > 0) id = HLD(nex, id);\n      // normal childs\n      for(const auto& e: G[cur]) if(e.from == parent[e.to]) if(e.to != nex) id = HLD(e.to, id+1);\n      return id;\n    };\n    // initialize\n    dfs(root, 0);\n    HLD(root, 0);\n  }\n  Vertex lca(Vertex u, Vertex v) const {\n    while(head[chain[u]] != head[chain[v]]) {\n      if(depth[head[chain[u]]] > depth[head[chain[v]]]) std::swap(u, v);\n      v = parent[head[chain[v]]];\n    }\n    return depth[u] < depth[v] ? u : v;\n  }\n private:\n  const Size NIL = -1;\n  std::vector<Vertex> head;\n  std::vector<Size> chain, position, size;\n  std::vector<Vertex> parent;\n  std::vector<Size> depth, subsize;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n// ?????? (????????????????????§????????¢) (?????¢???) O(|V| |E|)\nWeight height(const Graph& G, Vertex u, auto i, auto& memo) {\n  if(~memo[u][i]) return memo[u][i];\n  memo[u][i] = G[u][i].weight;\n  auto v = G[u][i].to;\n  for(auto j = 0; j < G[v].size(); ++j) if(G[v][j].to != u) {\n    memo[u][i] = max(memo[u][i], G[u][i].weight + height(G, v, j, memo));\n  }\n  return memo[u][i];\n}\nvoid GRL_5_B(const Graph& G) {\n  vector<vector<Weight>> memo;\n  for(auto i: G) memo.emplace_back(i.size(), -1);\n  vector<Weight> res(G.size());\n  for(auto u = 0; u < G.size(); ++u) {\n    for(auto i = 0; i < G[u].size(); ++i) res[u] = max(res[u], height(G, u, i, memo));\n    cout << res[u] << endl;\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  Graph G(n);\n  for(auto i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(auto j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      G[i].push_back({i, c, 0});\n      G[c].push_back({c, i, 0});\n    }\n  }\n  HeavyLightDecomposition HLD(G, 0);\n  int q;\n   cin >> q;\n  for(auto i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << HLD.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\n#define sz(x) ((int)x.size())\n\nstruct UnionFind {\n    vi data;\n    int comp;\n    UnionFind() {}\n    UnionFind(int size) {\n        init(size);\n    }\n    void init(int size) {\n        data.assign(size, -1);\n        comp = size;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        if (data[x] < 0) {\n            return x;\n        } else {\n            return data[x] = root(data[x]);\n        }\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() {\n        return comp;\n    }\n};\n\nstruct LCA {\n    using Query = pii;\n    vvi g;\n    vi color;\n    vi ancestor;\n    vector<vector<pair<int, Query>>> query_set;\n    vi res;\n    UnionFind uf;\n    LCA(const vvi &g, vector<Query> &query) :\n            g         (g),\n            color     (sz(g)),\n            ancestor  (sz(g)),\n            query_set (sz(g)),\n            res       (sz(query)),\n            uf        (sz(g))\n    {\n        int qs = sz(query);\n        rep(i, 0, qs) {\n            query_set[query[i].first ].emplace_back(i, query[i]);\n            query_set[query[i].second].emplace_back(i, query[i]);\n        }\n    }\n    void visit(int v, int prev) {\n        ancestor[uf.root(v)] = v;\n        for (auto &w : g[v]) {\n            if (w == prev) {\n                continue;\n            }\n            visit(w, v);\n            uf.unite(v, w);\n            ancestor[uf.root(v)] = v;\n        }\n        color[v] = 1;\n        for (auto &p : query_set[v]) {\n            Query q = p.second;\n            int w = (q.second == v ? q.first : (q.first == v ? q.second : -1));\n            if (w == -1 || !color[w]) {\n                continue;\n            }\n            res[p.first] = ancestor[uf.root(w)];\n        }\n    }\n    vi solve(int root) {\n        visit(root, -1);\n        return res;\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> G(N);\n    rep(v, 0, N) {\n        int K;\n        cin >> K;\n        rep(k, 0, K) {\n            int X;\n            cin >> X;\n            G[v].push_back(X);\n        }\n    }\n    int Q;\n    cin >> Q;\n    vector<pii> queries;\n    rep(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        queries.emplace_back(U, V);\n    }\n    LCA lca(G, queries);\n    vi res = lca.solve(0);\n\n    for (int ans : res) {\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct LinkCutTree {\n  vector<int>left,right,parent;\n\n  LinkCutTree(int n):left(n,-1),right(n,-1),parent(n,-1){}\n\n  bool is_root(int id){\n    return parent[id]<0 || (left[parent[id]]!=id && right[parent[id]]!=id);\n  }\n\n  void connect(int ch, int p, bool isL){\n    (isL ? left : right)[p] = ch;\n    if(ch >= 0)parent[ch] = p;\n  }\n\n  void rotate(int id){\n    int p = parent[id], q = parent[p];\n    bool isL = id==left[p], isRoot = is_root(p);\n\n    connect((isL ? right : left)[id], p, isL);\n    connect(p, id, !isL);\n\n    if(!isRoot)connect(id,q,p==left[q]);\n    else parent[id]=q;\n  }\n\n  void splay(int id){\n    while(!is_root(id)){\n      int p = parent[id];\n      if(!is_root(p))rotate( (id==left[p])^(p==left[parent[p]]) ? p : id );\n      rotate(id);\n    }\n  }\n\n  int expose(int id){\n    int last = -1;\n    for(int y=id; y>=0; y=parent[y])\n      splay(y), left[y]=last, last=y;\n    splay(id);\n    return last;\n  }\n\n  int find_root(int id){\n    expose(id);\n    while(right[id]!=-1)id=right[id];\n    return id;\n  }\n\n  void link(int ch, int p){\n    expose(ch);\n    if(right[ch]>=0)return;\n    parent[ch]=p;\n  }\n\n  void cut(int id){\n    expose(id);\n    if(right[id]<0)return;\n    parent[right[id]]=-1;\n    right[id]=-1;\n  }\n\n  int lca(int ch, int p){\n    //if(find_root(ch)!=find_root(p))return -1;\n    expose(ch);\n    return expose(p);\n  }\n};\n\nint main(void){\n  int n;\n  cin >> n;\n\n  LinkCutTree tree(n);\n  \n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      tree.link(t,i);\n    }\n  }\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << tree.lca(u,v) << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<vector<int> > G;\n\nclass Doubling{\n\tpublic:\n\tvector<vector<int> > parent;\n\tvector<int> depth;\n\tvoid dfs(int v, int p, int d){\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(G[v][i] == p) continue;\n\t\t\tdfs(G[v][i], v, d + 1);\n\t\t}\n\t}\n\tDoubling(int V, int def_root){\n\t\tint log_v = 1;\n\t\tint pow_2 = 1;\n\t\twhile(pow_2 < V){\n\t\t\tpow_2 *= 2;\n\t\t\tlog_v++;\n\t\t}\n\t\tparent.assign(log_v, vector<int>(V, -1));\n\t\tdepth.resize(V);\n\t\tdfs(def_root, -1, 0);\n\t\tfor(int k = 0; k + 1 < parent.size(); k++){\n\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\tif(parent[k][v] < 0) parent[k + 1][v] = -1;\n\t\t\t\telse parent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tfor(int k = 0; k < parent.size(); k++){\n\t\t\tif((depth[v] - depth[u]) & (1 << k)){\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int k = parent.size() - 1; k >= 0; k--){\n\t\t\tif(parent[k][u] != parent[k][v]){\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tG.resize(n);\n\tfor(int i = 0; i < n; i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tDoubling T(n, 0);\n\tint q;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << T.lca(u, v) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\nconst int LOG_N = 17;\n\nvector<int> G[MAX_N];\n\nint par[LOG_N][MAX_N];\nint depth[MAX_N];\n\nvoid dfs(int u,int p,int d)\n{\n    par[0][u] = p;\n    depth[u] = d;\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            dfs(G[u][i],u,d+1);\n        }\n    }\n}\n\nint lca(int u,int v)\n{\n    if(depth[u] > depth[v]){\n        swap(u,v);\n    }\n    rep(i,LOG_N){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = par[i][v];\n        }\n    }\n    if(u == v){\n        return u;\n    }\n    for(int i=LOG_N-1;i>=0;i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,-1,0);\n    rep(i,LOG_N-1){\n        rep(j,n){\n            if(par[i][j] < 0){\n                par[i+1][j] = -1;\n            }else{\n                par[i+1][j] = par[i][par[i][j]];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        printf(\"%d\\n\",lca(x,y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint n;\n\tint segn;\n\tST(int v,int k):n(v)\n\t{\n\t\tfor (segn = 1; segn < (n * 2 - 1); segn *= 2);\n\t\tdata.assign(2 * segn, make_pair(INF, -1));\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tdata[segn + i] = make_pair(depth[i], et[i]);\n\t\t}\n\t\tfor (int i = segn - 1; i >= 1; --i)\n\t\t{\n\t\t\tdata[i] = min(data[i * 2], data[i * 2 + 1]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = segn;\n\t\t}\n\t\tif (t <= s || r == 0)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (t - s == r)\n\t\t{\n\t\t\treturn data[l];\n\t\t}\n\n\t\treturn min(find(s, min(t, r / 2), l * 2, r / 2), find(max(0, s - (r / 2)), t - (r / 2), l * 2 + 1, r / 2));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(n,eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 1, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool chmax(T &a, const T &b) { if (a < b) {\ta = b; return true;\t}\treturn false; }\n#define rep0(N) for (int COUNTER = 0; COUNTER < (int)(N); COUNTER++)\n#define rep(i, N) for (int i = 0; i < (int)(N); i++)\n#define rep1(i, N) for (int i = 0; i < (int)(N); i++)\n#define rep2(i, START, GOAL) for (int i = (int)(START); i < (int)(GOAL); i++)\n#define rep3(i, START, GOAL) for (int i = (int)(START); i > (int)(GOAL); i--)\n#define all(CONTAINER) CONTAINER.begin(), CONTAINER.end()\n#define rall(CONTAINER) CONTAINER.rbegin(), CONTAINER.rend()\n#define from1(CONTAINER) CONTAINER.begin() + 1, CONTAINER.end()\n#define rfrom1(CONTAINER) CONTAINER.rbegin(), CONTAINER.rend() - 1\n#define pout(X) cout << X << \" \"\n#define print(X) cout << X << \"\\n\"\n#define output(X) cout << X << \"\\n\"\n#define dbe(X) cerr << X << \" \"\n#define dbel(X) cerr << X << \"\\n\"\n#define dberr(X) cerr << X << \" \"\n#define dberrl(X) cerr << X << \"\\n\"\n#define db(X) cerr << #X << \":\" << (X) << \" \"\n#define dbl(X) cerr << #X << \":\" << (X) << \"\\n\"\n#define db2(X, Y) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \" \"\n#define db2l(X, Y) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \"\\n\"\n#define dbl2(X, Y) cerr << #X << \":\" << (X) << \"\\n\" << #Y << \":\" << (Y) << \"\\n\"\n#define db3(X, Y, Z) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \" \" << #Z << \":\" << (Z) << \" \"\n#define db3l(X, Y, Z) cerr << #X << \":\" << (X) << \", \" << #Y << \":\" << (Y) << \", \" << #Z << \":\" << (Z) << \"\\n\"\n#define dbl3(X, Y, Z) cerr << #X << \":\" << (X) << \"\\n\" << #Y << \":\" << (Y) << \"\\n\" << #Z << \":\" << (Z) << \"\\n\"\n#define dbp(PAIR) cerr << #PAIR << \":(\" << PAIR.first << \", \" << PAIR.second << \") \"\n#define dbpl(PAIR) cerr << #PAIR << \":(\" << PAIR.first << \", \" << PAIR.second << \")\\n\"\n#define dbt3(TUPLE3) cerr << #TUPLE3 << \":(\" << get<0>(TUPLE3) << \", \" << get<1>(TUPLE3) << \", \" << get<2>(TUPLE3) << \") \"\n#define dbt3l(TUPLE3) cerr << #TUPLE3 << \":(\" << get<0>(TUPLE3) << \", \" << get<1>(TUPLE3) << \", \" << get<2>(TUPLE3) << \")\\n\"\n#define dbt4(TUPLE4) cerr << #TUPLE4 << \":(\" << get<0>(TUPLE4) << \", \" << get<1>(TUPLE4) << \", \" << get<2>(TUPLE4) << \", \" << get<3>(TUPLE4) << \") \"\n#define dbt4l(TUPLE4) cerr << #TUPLE4 << \":(\" << get<0>(TUPLE4) << \", \" << get<1>(TUPLE4) << \", \" << get<2>(TUPLE4) << \", \" << get<3>(TUPLE4) << \")\\n\"\n#define dbv(VEC) cerr << #VEC << \":{ \"; for (auto ELEM : VEC) cerr << ELEM << \", \"; cerr << \"}\\n\"\n#define dbvp(VP) cerr << #VP << \":{ \"; for (auto PAIR : VP) cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; cerr << \"}\\n\"\n#define dbvv(VV) cerr << #VV << \":{\\n\"; for (auto VEC : VV) { cerr << \"{ \"; for (auto ELEM : VEC) cerr << ELEM << \", \"; cerr << \"},\\n\"; } cerr << \"}\\n\"\n#define dbvvp(VVP) cerr << #VVP <<\":{\\n\"; for (auto VP : VVP) { cerr << \"{ \"; for (auto PAIR : VP) { cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; } cerr << \"},\\n\"; } cerr << \"}\\n\";\n#define dbs(SET) cerr << #SET << \"{ \"; for (auto ELEM : SET) cerr << ELEM << \", \"; cerr << \"}\\n\";\n#define dbsp(SP) cerr << #SP << \"{ \"; for (auto PAIR : SP) cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; \"}\\n\";\n#define dbm(MAP) cerr << #MAP << \":{ \"; for (auto PAIR : MAP) cerr << \"(\" << PAIR.first << \", \" << PAIR.second << \"), \"; cerr << \"}\\n\"\n#define YN(f) cout << (f ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(f) cout << (f ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(f) cout << (f ? \"yes\" : \"no\") << \"\\n\"\nusing ll = long long;\nusing pii = pair<int, int>;using pll = pair<ll, ll>;using pdd = pair<double, double>;\nusing ti3 = tuple<int, int, int>;using tl3 = tuple<ll, ll, ll>;using td3 = tuple<double, double, double>;\nusing ti4 = tuple<int, int, int, int>;using tl4 = tuple<ll, ll, ll, ll>;using td4 = tuple<double, double, double, double>;\nusing vi = vector<int>;using vl = vector<ll>;using vd = vector<double>;using vs = vector<string>;using vb = vector<bool>;\nusing vvi = vector<vi>;using vvl = vector<vl>;using vvd = vector<vd>;using vvb = vector<vb>;\nusing vpii = vector<pii>;using vpll = vector<pll>;using vpdd = vector<pdd>;\nusing mii = map<int, int>;using mll = map<ll, ll>;\nusing si = set<int>;using sl = set<ll>;using ss = set<string>;\nusing spii = set<pii>;using spll = set<pll>;using spdd = set<pdd>;\n\n// db\n\nvvi dbling_table(vi v) { // v[i]:iの親(なければ-1)\n\tvvi res; res.push_back(v);\n\tfor (int k = 1; (1 << k) <= v.size(); k++) { // これから追加する行\n\t\tvi temp(v.size(), -1);\n\t\trep(i, v.size()) {\n\t\t\ttemp[i] = res[k - 1][i];\n\t\t\tif (temp[i] != -1) temp[i] = res[k - 1][temp[i]];\n\t\t}\n\t\tres.push_back(temp);\n\t}\n\treturn res;\n}\n\nint dbling(int i, int x, vvi &nxt) { // iのx個上の要素\n\tint res = i;\n\tfor (int k = 0; (1 << k) <= x and res != -1; k++) {\n\t\tif (x & (1 << k)) res = nxt[k][res];\n\t}\n\treturn res;\n}\n\nvoid dfs(int u, vvi &ch, vi &d) {\n\tfor (int v : ch[u]) {\n\t\tif (d[v] != -1) continue;\n\t\td[v] = d[u] + 1;\n\t\tdfs(v, ch, d);\n\t}\n}\n\nvoid solve(int u, int v, vi &d, vvi &nxt) {\n\tif (d[u] < d[v]) v = dbling(v, d[v] - d[u], nxt);\n\telse if (d[u] > d[v]) u = dbling(u, d[u] - d[v], nxt);\n\tif (u == v) { print(u); return; }\n\tint ng = 0, ok = d.size() - 1;\n\twhile (ok - ng > 1) {\n\t\tint mid = (ng + ok) / 2;\n\t\tif (dbling(u, mid, nxt) == dbling(v, mid, nxt)) ok = mid;\n\t\telse ng = mid;\n\t}\n\tprint(dbling(u, ok, nxt));\n}\n\nint main() {\n\tint n; cin >> n;\t\n\tvvi ch(n);\n\tvi par(n, -1);\n\trep(i, n) {\n\t\tint k; cin >> k;\n\t\trep0(k) {\n\t\t\tint c; cin >> c;\n\t\t\tch[i].push_back(c);\n\t\t\tpar[c] = i;\t\n\t\t}\n\t}\n\t\n\tint root = -1;\n\trep(i, n) { if (par[i] == -1) root = i; break; }\n\tvi d(n, -1);\t\n\td[root] = 0;\n\tdfs(root, ch, d);\n\t// dbv(par); dbvv(ch); dbl(root); dbv(d);\n\n\tvvi nxt = dbling_table(par);\n\t// dbvv(nxt);\n\t/*\n\trep(x, n) {\n\t\trep(i, n) cout << dbling(i, x, nxt) << \" \"; cout << endl;\n\t}\n\t*/\n\tint q; cin >> q;\n\trep0(q) {\n\t\tint u, v; cin >> u >> v;\n\t\tsolve(u, v, d, nxt);\t\t\n\t}\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\n\nstruct LowestCommonAncestor {\n    int n, sn;\n    vector<int> id, vs, depth;\n    vector<pair<int, int>> node;\n    LowestCommonAncestor(vector<vector<int>> g)\n        : n(sz(g)), id(n), vs(n * 2 - 1), depth(n * 2 - 1) {\n        int k = 0;\n        dfs(0, -1, 0, k, g);\n        sn = 1;\n        while (sn < sz(depth)) {\n            sn *= 2;\n        }\n        node.assign(2 * sn - 1, make_pair(INF, INF));\n        for (int i = 0; i < sz(depth); i++) {\n            node[sn + i - 1] = make_pair(depth[i], i);\n        }\n        for (int i = sn - 1; i >= 1; i--) {\n            node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n    void dfs(int now, int pre, int dep, int &k, const vector<vector<int>> &g) {\n        id[now] = k;\n        vs[k] = now;\n        depth[k++] = dep;\n        for (int nxt : g[now]) {\n            if (nxt == pre) continue;\n            dfs(nxt, now, dep + 1, k, g);\n            vs[k] = now;\n            depth[k++] = dep;\n        }\n    }\n    pair<int, int> query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = sn;\n        if (r <= a || b <= l) return make_pair(INF, INF);\n        if (a <= l && r <= b) return node[k];\n        auto vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        auto vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n    int get(int u, int v) {\n        int l = min(id[u], id[v]);\n        int r = max(id[u], id[v]) + 1;\n        return vs[query(l, r).second];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    rep(i, n) {\n        int k;\n        cin >> k;\n        while (k--) {\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            g[c].push_back(i);\n        }\n    }\n    LowestCommonAncestor lca(g);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.get(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\nconst int LOG_N = 17;\n\nvector<int> G[MAX_N];\n\nint par[LOG_N][MAX_N];\nint depth[MAX_N];\n\nvoid dfs(int u,int p,int d)\n{\n    par[0][u] = p;\n    depth[u] = d;\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            dfs(G[u][i],u,d+1);\n        }\n    }\n}\n\nint lca(int u,int v)\n{\n    if(depth[u] > depth[v]){\n        swap(u,v);\n    }\n    rep(i,LOG_N){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = par[i][v];\n        }\n    }\n    if(u == v){\n        return u;\n    }\n    for(int i=LOG_N-1;i>=0;i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,-1,0);\n    rep(i,LOG_N-1){\n        rep(j,n){\n            if(par[i][j] < 0){\n                par[i+1][j] = -1;\n            }else{\n                par[i+1][j] = par[i][par[i][j]];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        printf(\"%d\\n\",lca(x,y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 20;\nint color[100010],  par[100010], depth[100010];\nint top[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(!vis[c]){\n                q.push(c);\n                par[c] = v;\n                depth[c] = depth[v] + 1;\n            }\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            top[v] = u;\n            k++;\n            for(int c : g[v]){\n                if(!vis[c]) q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n    // rep(i,n) printf(\"v:%d col:%d dep:%d\\n\", i, color[i], depth[i]);\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        // cout << u << \" \" << v << endl;\n        assert(u != -1 && v != -1);\n        if(depth[top[u]] > depth[top[v]]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//????°???±????\\??????????\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define MAX_V 100000\n\nvector<int> G[MAX_V];\nvector<int> depth,vs;\nint id[MAX_V]={};\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int b;\n            cin>>b;\n            G[i].pb(b);\n        }\n    }\n    init();                                                         // aranging depth[] , vs[] and id[]\n    segtree<pii> st(depth.size(),pii((1ULL<<31)-1,(1ULL<<31)-1));         // the number of elements is depth.size()\n    rep(i,depth.size()){                                            //initialize\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int a,b;\n    int q;\n    cin>>q;\n    rep(i,q){\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;  // is equal to LCA(a,b)\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nこのコード、と～おれ!\nBe accepted!\n∧＿∧　\n（｡･ω･｡)つ━☆・*。\n⊂　　 ノ 　　　・゜+.\n　しーＪ　　　°。+ *´¨)\n 　　　　　　　　　.· ´¸.·*´¨) ¸.·*¨)\n\t\t  　　　　　　　　　　(¸.·´ (¸.·'* ☆\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <random>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <regex>\n#include <functional>\n#include <complex>\n#include <list>\n#include <cassert>\n#include <iomanip>\n#include <set>\n#include <stack>\n/*多倍長整数/cpp_intで宣言\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace boost::multiprecision;\n*/\n\n#pragma gcc target (\"avx2\")\n#pragma gcc optimization (\"o3\")\n#pragma gcc optimization (\"unroll-loops\")\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, n) for(int i = 1; i <= (n); ++i)\n#define rep2(i, n) for(int i = 2; i < (n); ++i)\n#define repr(i, n) for(int i = n; i >= 0; --i)\n#define reprm(i, n) for(int i = n - 1; i >= 0; --i)\n#define printynl(a) printf(a ? \"yes\\n\" : \"no\\n\")\n#define printyn(a) printf(a ? \"Yes\\n\" : \"No\\n\")\n#define printYN(a) printf(a ? \"YES\\n\" : \"NO\\n\")\n#define printim(a) printf(a ? \"possible\\n\" : \"imposible\\n\")\n#define printdb(a) printf(\"%.50lf\\n\", a) //少数出力\n#define printdbd(a) printf(\"%.16lf\\n\", a) //少数出力(桁少なめ)\n#define prints(s) printf(\"%s\\n\", s.c_str()) //string出力\n#define all(x) (x).begin(), (x).end()\n#define allsum(a, b, c) ((a + b) * c / 2.0) //等差数列の和、初項,末項,項数\n#define pb push_back\n#define priq priority_queue\n#define rpriq priq<int, vector<int>, greater<int>>\n#define deg_to_rad(deg) (((deg)/360.0)*2.0*PI)\n#define rad_to_deg(rad) (((rad)/2.0/PI)*360.0)\n#define Please return\n#define AC 0\n#define addf(T) [](T a, T b){return (a + b);}\n#define minf(T) [](T a, T b){return min(a, b);}\n#define maxf(T) [](T a, T b){return max(a, b);}\n#define nopf(T) [](T a){return a;}\n#define manhattan_dist(a, b, c, d) (abs(a - c) + abs(b - d)) /*(a, b) から (c, d) のマンハッタン距離 */\n\n\nusing ll = long long;\n\nconstexpr int INF = 1073741823;\nconstexpr int MINF = -1073741823;\nconstexpr ll LINF = ll(4661686018427387903);\nconstexpr ll MOD = 1000000007;\nconst long double PI = acos(-1.0L);\n\nusing namespace std;\n\nvoid scans(string& str) {\n\tchar c;\n\tstr = \"\";\n\tscanf(\"%c\", &c);\n\tif (c == '\\n')scanf(\"%c\", &c);\n\twhile (c != '\\n' && c != -1 && c != ' ') {\n\t\tstr += c;\n\t\tscanf(\"%c\", &c);\n\t}\n}\n\nvoid scanc(char& str) {\n\tchar c;\n\tscanf(\"%c\", &c);\n\tif (c == -1)return;\n\twhile (c == '\\n') {\n\t\tscanf(\"%c\", &c);\n\t}\n\tstr = c;\n}\n\ndouble acot(double x) {\n\treturn PI / 2 - atan(x);\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll number1, ll number2) {\n\treturn number1 / gcd(number1, number2) * number2;\n}\n\nll LSB(ll n) { return (n & (-n)); }\n\n/*-----------------------------------------ここからコード-----------------------------------------*/\n\n//RMQ <O(n log n), O(1)>\ntemplate<typename T>\nstruct sparsetable {\n\n\tvector<vector<T>> table;\n\tvector<int> logtable;\n\tvector<int> a;\n\tint n;\n\n\t// 渡す配列, サイズ\n\tsparsetable(const vector<T> a, int siz) : n(siz), a(a) {\n\t\tlogtable.assign(n + 1, 0);\n\t\tfor (int i = 2; i <= n; ++i)logtable[i] = logtable[i >> 1] + 1;\n\t\ttable.assign(n, vector<T>(logtable[n] + 1, 0));\n\t}\n\n\t//リストバージョン\n\tsparsetable(initializer_list<T> init) {\n\t\ta = init[0];\n\t\tn = init[1];\n\t\tlogtable.assign(n + 1, 0);\n\t\tfor (int i = 2; i <= n; ++i)logtable[i] = logtable[i >> 1] + 1;\n\t\ttable.assign(n, vector<T>(logtable[n] + 1, 0));\n\t}\n\n\t//配列と大きさを渡して初期化\n\tvoid init(const vector<T> aa, int siz) {\n\t\ta = aa;\n\t\tn = siz;\n\t\tlogtable.assign(n + 1, 0);\n\t\tfor (int i = 2; i <= n; ++i)logtable[i] = logtable[i >> 1] + 1;\n\t\ttable.assign(n, vector<T>(logtable[n] + 1, 0));\n\t}\n\n\t//構築 O(n log n)\n\tvoid build() {\n\t\tfor (int k = 0; (1 << k) <= n; ++k) {\n\t\t\tfor (int i = 0; i + (1 << k) <= n; ++i) {\n\t\t\t\tif (k) table[i][k] = (a[table[i][k - 1]] < a[table[i + (1 << (k - 1))][k - 1]] ? table[i][k - 1] : table[i + (1 << (k - 1))][k - 1]);\n\t\t\t\telse table[i][k] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t//[l, r) の RMQ O(1)\n\tint query(int l, int r) {\n\t\tint k = logtable[r - l];\n\t\treturn (a[table[l][k]] < a[table[r - (1 << k)][k]] ? table[l][k] : table[r - (1 << k)][k]);\n\t}\n\n};\n\n//depends on SparseTable\n\n//euler tour を行う。O(n)\nvoid eulertour(const int& now, const int& bef, int& cnt, const vector<vector<int>>& graph, const int& d, vector<int>& vs, vector<int>& depth, vector<int>& id) {\n\tdepth.emplace_back(d);\n\tvs.emplace_back(now);\n\tid[now] = min(id[now], cnt);\n\tfor (const auto& aa : graph[now]) {\n\t\tif (aa != bef) {\n\t\t\t++cnt;\n\t\t\teulertour(aa, now, cnt, graph, d + 1, vs, depth, id);\n\t\t\t++cnt;\n\t\t\tdepth.emplace_back(d);\n\t\t\tvs.emplace_back(now);\n\t\t}\n\t}\n}\n\n//LCA <O(n log n), O(1)>\nstruct LCA {\n\n\tvector<int> vs, depth, id, tmp = { 0 };\n\tvector<vector<int>> tree;\n\tsparsetable<int> table{ tmp, 0 };\n\tint n, root;\n\n\t//木,　大きさ, 根で初期化\n\tLCA(vector<vector<int>> tree, int n, int root) : tree(tree), n(n), root(root) {\n\t\tid.assign(n, INF);\n\t}\n\n\t//構築 O(n) + O(n log n)\n\tvoid build() {\n\t\tint cnt = 0, d = 0;\n\t\teulertour(root, -1, cnt, tree, d, vs, depth, id);\n\t\ttable.init(depth, depth.size());\n\t\ttable.build();\n\t}\n\n\t//LCA である頂点を返す O(1)\n\tint query(int l, int r) {\n\t\tif (id[l] > id[r])swap(l, r);\n\t\treturn vs[table.query(id[l], id[r] + 1)];\n\t}\n\n\t//頂点 n の深さを返す O(1)\n\tint depthq(int n) {\n\t\treturn depth[id[n]];\n\t}\n};\n\nint main() {\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<vector<int>> tree(n);\n\tint k, c;\n\trep(i, n) {\n\t\tscanf(\"%d\", &k);\n\t\trep(j, k) {\n\t\t\tscanf(\"%d\", &c);\n\t\t\ttree[i].emplace_back(c);\n\t\t}\n\t}\n\tLCA lca(tree, n, 0);\n\tlca.build();\n\tint q;\n\tscanf(\"%d\", &q);\n\trep(i, q) {\n\t\tscanf(\"%d%d\", &k, &c);\n\t\tprintf(\"%d\\n\", lca.query(k, c));\n\t}\n\n\tPlease AC;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NOP 20\t\t//Number Of Fathers\nusing namespace std;\n\nstruct nodo\n{\n\tint lv;\n\tset<int>Fx;\n\tvector<int>Pb;\n\tnodo()\n\t{\n\t\tlv = 0;\n\t\tPb.assign(NOP,0);\n\t}\n};\n\nclass tree\n{\n\tprivate:\n\t\tvector<nodo> v;\n\t\tint root;\n\tpublic:\t\n\ttree(int n)\n\t{\n\t\tv.assign(n,nodo());\n\t\troot = 0;\n\t}\n\ttree(int n , int r)\n\t{\n\t\tv.assign(n,nodo());\n\t\troot = r;\n\t\tv[r].Pb[0] = r;\n\t}\n\tvoid conect(int x , int y)\n\t{\n\t\tv[x].Fx.insert(y);\n\t\tv[y].Fx.insert(x);\n\t\tv[y].Pb[0] = x;\n\t}\n\tvoid LV(int x , int l , int p)\n\t{\n//\t\tcout << x << \" , \" << l << '\\n';\n\t\tv[x].lv = l;\n\t\tset<int>::iterator it;\n\t\tfor(it = v[x].Fx.begin() ; it != v[x].Fx.end() ; it++)\n\t\t\tif(*it != p)\n\t\t\t\tLV(*it , l + 1 , x);\n\t}\n\tvoid BinaryP()\n\t{\n\t\tfor(int i = 1 ; i < NOP ; i++)\n\t\t\tfor(int j = 0 ; j < v.size() ; j++)\n\t\t\t\tv[j].Pb[i] = v[j].Pb[i-1];\n\t}\n\tint LCA(int x , int y)\n\t{\n\t\tint dif = abs(v[x].lv - v[y].lv);\n\t\tint p1 , p2;\n\t\tif(v[x].lv > v[y].lv)\n\t\t{\n\t\t\tp1 = x;\n\t\t\tp2 = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = y;\n\t\t\tp2 = x;\n\t\t}\n//\t\tcout<< '\\n' << dif << \" , \" << p1 << \" , \" << p2 << \" DIF\\n\";\n\t\tif(dif > 0)\n\t\t{\n\t\t\tfor(int i = 0 ; (1<<i) <= dif ; i++)\n\t\t\t{\n\t\t\t\tif(((1<<i)&dif) != 0)\n\t\t\t\t\tp1 = v[p1].Pb[i];\n\t\t\t}\n\t\t}\n//\t\tcout << p1 << \" , \" << p2 << \" PS\\n\";\n\t\tif(p1 == p2)\n\t\t\treturn p1;\n\t\telse\n\t\t{\n\t\t\tfor(int i = NOP - 1 ; i >= 0 ; i--)\n\t\t\t{\n\t\t//\t\tcout << v[p1].Pb[i] << \" , \" << v[p2].Pb[i] << \" FIND\\n\";\n\t\t\t\tif(v[p1].Pb[i] != v[p2].Pb[i])\n\t\t\t\t{\n\t\t\t\t\tp1 = v[p1].Pb[i];\n\t\t\t\t\tp2 = v[p2].Pb[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn v[p1].Pb[0];\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n , q , a , b;\n\tcin >> n;\n\ttree tr(n);\n\tfor(int i = 0 ; i < n ; i++)\n\t{\n\t\tcin >> a;\n\t\tfor(int j = 0 ; j < a ; j++)\n\t\t{\n\t\t\tcin >> b;\n\t\t\ttr.conect(i,b);\n\t\t}\n\t}\n\ttr.LV(0,0,0);\n\ttr.BinaryP();\n\tcin >> q;\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t\tcin >> a >> b;\n\t\tcout << tr.LCA(a,b) << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n\nclass RMQsub1{//隣接差が±1だけのRMQ\n\tstd::vector<int> pattern;//ブロックがどのパターンか\n\tstd::vector<std::vector<int> > minpos;//バイナリパターンに対する最小位置\n\tstd::vector<int> dat;//葉でないノード\n\tstd::vector<int> depth;\n\tint blocksize;\n\tint n;\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return -1;\n\t\tif(n-1<=k){//leaf\n\t\t\tif(pattern[k-(n-1)]==-1)return -1;\n\t\t\tint s=l<a?a%blocksize:0;\n\t\t\tint t=r<=b?blocksize:b%blocksize;\n\t\t\treturn (k-(n-1))*blocksize+minpos[pattern[k-(n-1)]][s*blocksize+t-1];\n\t\t}else{\n\t\t\tif(a<=l&&r<=b)return dat[k];\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\tif(vl==-1)return vr;\n\t\t\treturn vr==-1||depth[vl]<depth[vr]?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k-1;//log(n)/2\n\t\tif(blocksize==0)blocksize=1;\n\t\tint m=(n+blocksize-1)/blocksize;//num node\n\t\twhile(m&m-1)m+=m&-m;\n\t\tthis->n=m;\n\t\tdat.resize(m-1,-1);\n\t\tpattern.resize(n,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m==1)break;\n\t\t\tint par=(m-1+i-1)/2;\n\t\t\tif(dat[par]==-1 || a[i*blocksize+minpos[p][0+b-1]]<a[dat[par]])\n\t\t\t\tdat[par]=i*blocksize+minpos[p][0+b-1];\n\t\t}\n\t\tdat.resize(m-1);\n\t\tfor(int i=(m-2)/2-1;i>=0;i--){\n\t\t\tint vl,vr;\n\t\t\tvl=dat[2*i+1];\n\t\t\tvr=dat[2*i+2];\n\t\t\tdat[i]=vr==-1||a[vl]<a[vr]?vl:vr;\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n*blocksize);\n\t}\n};\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n \nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n \n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(max(logN, 1), vector<int>(N));\n  }\n \n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n \n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n \n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n \nint main() {\n  cin.tie(nullptr);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_LOG_V = 16;\n\nvector<int> g[MAX_V]; //??°???????????£??\\?????????\nint root;\n\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i,g[v].size()){\n        if(g[v][i] != p) dfs(g[v][i], v, d + 1);\n    }\n}\n\nvoid init(int v){\n    dfs(root, -1, 0);\n    rep(i,MAX_LOG_V - 1){\n        rep(j,v){\n            if(parent[i][j] < 0) parent[i + 1][j] = -1;\n            else parent[i + 1][j] = parent[i][parent[i][j]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    rep(i,MAX_LOG_V){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = parent[i][v];\n        }\n    }\n    if(u == v) return u;\n\n    //????????¢?´¢\n    for(int i = MAX_LOG_V - 1; i >= 0; i--){\n        if(parent[i][u] != parent[i][v]){\n            u = parent[i][u];\n            v = parent[i][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    int n;\n    cin >> n;\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int v;\n            cin >> v;\n            g[i].emplace_back(v);\n            g[v].emplace_back(i);\n        }\n    }\n\n    init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\ntemplate <typename T>\nclass SparseTable {\n\tconst int n, h;\n\tvector<vector<T>> t;\npublic:\n\tSparseTable(const vector<T>& b)\n\t\t: n(b.size()), h(31 - __builtin_clz(n)), t(h + 1, vector<T>(b.size())) {\n\t\tt[0] = b;\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int k = 0; k + (1 << i) < n; k++)\n\t\t\t\tt[i + 1][k] = min(t[i][k], t[i][k + (1 << i)]);\n\t}\n\tT find(int l, int r) {\n\t\tint b = 31 - __builtin_clz(r - l);\n\t\treturn min(t[b][l], t[b][r - (1 << b)]);\n\t}\n\tT operator[](int id) {\n\t\treturn t[0][id];\n\t}\n};\n\nclass LCA {\n\tusing pii = pair<int, int>;\n\tvector<int> depth, id;\n\tSparseTable<pii> st;\n\tvoid dfs(int v, int prev, const graph& G, vector<pii>& res) {\n\t\tdepth[v] = prev != -1 ? depth[prev] + 1 : 0;\n\t\tid[v] = res.size();\n\t\tres.emplace_back(depth[v], v);\n\t\tfor (auto to : G[v]) if (to != prev) {\n\t\t\tdfs(to, v, G, res);\n\t\t\tres.emplace_back(depth[v], v);\n\t\t}\n\t}\n\tvector<pii> init(const graph& G, int rt) {\n\t\tvector<pii> res;\n\t\tres.reserve(G.size() * 2 - 1);\n\t\tdfs(rt, -1, G, res);\n\t\treturn res;\n\t}\npublic:\n\tLCA(const graph& G, int rt = 0) : depth(G.size()), id(G.size()), st(init(G, rt)) {}\n\tint calc(int a, int b) {\n\t\tif (id[a] > id[b]) swap(a, b);\n\t\treturn st.find(id[a], id[b] + 1).second;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph G(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tLCA lca(G);\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <map>\n#include <utility>\n\n#define MAXN 100000\n\nusing namespace std;\n\nint pre[MAXN] = {-1};\nint st[MAXN];\n\n//int seek[MAXN][MAXN];\n\nvector<pair<int,int>> vp;\nmap<pair<int,int>,int> mans;\n\nvoid swap(int &i,int &j){\n    int t = i;\n    i = j;\n    j = t;\n}\n\n\nclass Edge{\npublic:\n    int s;\n    int t;\n    Edge(int si,int ti):s(si),t(ti){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    vector<forward_list<int>> adj;\n    Graph(int v):V(v){\n        adj.resize(v);\n        for(int i = 0; i < V;i++) {st[i] = i;pre[i] = -1;}\n        }\n    void addEdge(int i,int j){adj[i].push_front(j);}\n    void tarjanR(Edge e);\n};\n\nint root(int v){\n    while(st[v] != v) v = st[v];\n    return v;\n}\n\nvoid Graph::tarjanR(Edge e){\n    int t = e.t;\n    int s = e.s;\n    pre[t] = 0;\n\n    for(auto a = adj[t].begin();a != adj[t].end();++a){\n        int v = *a;\n        if(pre[v] == -1){\n            tarjanR(Edge(t,v));\n        }\n    }\n    for(int i = 0; i < V;i++){\n        int mi = i,ma = t;\n        if(mi > ma) swap(mi,ma);\n        pair<int,int> p = make_pair(mi,ma);\n        if(pre[i] != -1 && mans.find(p) != mans.end() && mans[p] == -1){\n            mans[p] = root(i);\n        }\n    }\n    st[t] = s;\n}\n\n\nint main()\n{\n    int V,j,q,tt;\n    scanf(\"%d\",&V);\n    Graph G(V);\n    for(int i = 0; i < V; i++){\n        scanf(\"%d\",&j);\n        for(int k = 0; k < j;k++)\n        {\n            scanf(\"%d\",&tt);\n            G.addEdge(i,tt);\n        }\n    }\n\n    int s,t;\n\n    scanf(\"%d\",&q);\n    for(int i = 0; i < q;i++){\n        scanf(\"%d %d\",&s,&t);\n        if(s > t){swap(s,t);}\n        vp.push_back(make_pair(s,t));\n        mans[make_pair(s,t)] = -1;\n    }\n\n    G.tarjanR(Edge(0,0));\n\n    for(int i = 0; i < q;i++){\n        printf(\"%d\\n\",mans[vp[i]]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return NIL;\n        if(a <= l && r <= b) return k;\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        vl = vl == NIL ? INF : node_[vl];\n        vr = vr == NIL ? INF : node_[vr];\n        return (vl < vr ? left_child(k) : right_child(k));\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    std::vector<Node> node_;\n};\n//*/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n\n    RangeMinimumQuery rmq(n);\n    for(int i = 0; i < n; ++i) rmq.update(i, t.depth(i));\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n//         cout << t.lowest_common_ancestor(u, v) << endl;\n//         rmq.find(u, v);\n        cout << rmq.find_index(u, v) - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n  vector<vector<int> >  tree;\n  \n  HeavyLight(vector<vector<int> >tree)\n    :n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n),tree(tree){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    /*\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt;//, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nvector<int> et, depth, id;\n\nstruct ST\n{\n\tvector<pii> data;\n\tint n;\n\tint segn;\n\n\tST(int v,int k):n(v)\n\t{\n\t\tfor (segn = 1; segn < (n * 2 - 1); segn *= 2);\n\t\tdata.assign(2 * segn, make_pair(INF, -1));\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tdata[segn + i] = make_pair(depth[i], et[i]);\n\t\t}\n\t\tfor (int i = segn - 1; i >= 1; --i)\n\t\t{\n\t\t\tdata[i] = min(data[i * 2], data[i * 2 + 1]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = segn;\n\t\t}\n\t\tif (t <= s || r == 0)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (t - s == r)\n\t\t{\n\t\t\treturn data[l];\n\t\t}\n\n\t\treturn min(find(s, min(t, r / 2), l * 2, r / 2), find(max(0, s - (r / 2)), t - (r / 2), l * 2 + 1, r / 2));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tid[n] = eti;\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tet = vector<int>(n * 2 - 1);\n\tdepth = vector<int>(n * 2 - 1);\n\tid = vector<int>(n);\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(n,eti);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 1, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\ntemplate <typename T>\nclass SparseTable {\n\tusing func_t = function<T(T, T)>;\n\tint n;\n\tfunc_t merge;\n\tvector<vector<T>> t;\n\tint clz(unsigned int w) {\n\t\treturn (w & 0xffff0000) ? (w & 0xff000000) ? (w & 0xf0000000) ? (w & 0xc0000000) ? (w & 0x80000000) ? 0 : 1 : (w & 0xe0000000) ? 2 : 3 : (w & 0xfc000000) ? (w & 0xf8000000) ? 4 : 5 : (w & 0xfe000000) ? 6 : 7 : (w & 0xfff00000) ? (w & 0xffc00000) ? (w & 0xff800000) ? 8 : 9 : (w & 0xffe00000) ? 10 : 11 : (w & 0xfffc0000) ? (w & 0xfff80000) ? 12 : 13 : (w & 0xfffe0000) ? 14 : 15 : (w & 0xffffff00) ? (w & 0xfffff000) ? (w & 0xffffc000) ? (w & 0xffff8000) ? 16 : 17 : (w & 0xffffe000) ? 18 : 19 : (w & 0xfffffc00) ? (w & 0xfffff800) ? 20 : 21 : (w & 0xfffffe00) ? 22 : 23 : (w & 0xfffffff0) ? (w & 0xffffffc0) ? (w & 0xffffff80) ? 24 : 25 : (w & 0xffffffe0) ? 26 : 27 : (w & 0xfffffffc) ? (w & 0xfffffff8) ? 28 : 29 : (w & 0xfffffffe) ? 30 : 31;\n\t}\npublic:\n\tSparseTable(const vector<T>& b, func_t mq = [](T l, T r) { return min(l, r); }) : merge(mq) {\n\t\tn = b.size();\n\t\tt.push_back(b);\n\t\tfor (int i = 2, j = 1; i <= n; i <<= 1, j++) {\n\t\t\tt.push_back(vector<T>());\n\t\t\tfor (int k = 0; k + i <= n; k++) {\n\t\t\t\tt[j].push_back(merge(t[j - 1][k], t[j - 1][k + i / 2]));\n\t\t\t}\n\t\t}\n\t}\n\tT find(int l, int r) {\n\t\tr++;\n\t\tassert(l < r);\n\t\tunsigned int w = r - l;\n\t\tint i = 31 - clz(w);\n\t\treturn merge(t[i][l], t[i][r - (1 << i)]);\n\t}\n\tT operator[](int id) {\n\t\treturn t[0][id];\n\t}\n};\n\nclass LCA {\n\tint V, rt;\n\tvector<vector<int>> G;\n\tvector<int> depth, used, id;\n\tvector<int> vs, de;\n\tSparseTable<pii> st;\n\tvoid dfs(int s, int d) {\n\t\tused[s] = 1;\n\t\tvs.push_back(s);\n\t\tde.push_back(d);\n\t\tfor (int v : G[s]) {\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t\tvs.push_back(s);\n\t\t\t\tde.push_back(d);\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> init() {\n\t\tdfs(rt, 0);\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tif (id[vs[i]] == -1) id[vs[i]] = i;\n\t\t}\n\t\tvector<pii> r((int)vs.size());\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tr[i] = pii(de[i], vs[i]);\n\t\t}\n\t\treturn r;\n\t}\npublic:\n\tLCA(vector<vector<int>> G_, int rt_ = 0)\n\t\t: V(G_.size()), rt(rt_), G(G_), depth(V), used(V), id(V, -1), st(init()) {\n\t\tfor (int i = 0; i < V; i++) depth[i] = st[id[i]].first;\n\t}\n\tint calc(int a, int b) {\n\t\treturn st.find(min(id[a], id[b]), max(id[a], id[b])).second;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n;\n\tvector<vector<int>> G(n);\n\tfor (int i = 0, k; i < n; i++) {\n\t\tcin >> k;\n\t\tfor (int j = 0, c; j < k; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c > i) {\n\t\t\t\tG[i].push_back(c);\n\t\t\t\tG[c].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tLCA lca(G);\n\tcin >> q;\n\tfor (int i = 0, u, v; i < q; i++) {\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint LOG = 20;\nstruct lowest_common_ancestor{\n\tint N;\n\tvector<int> d;\n\tvector<vector<int>> p;\n\tlowest_common_ancestor(vector<int> &P, vector<vector<int>> &C){\n\t\tN = P.size();\n\t\td = vector<int>(N, 0);\n\t\tqueue<int> Q;\n\t\tQ.push(0);\n\t\twhile (!Q.empty()){\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int w : C[v]){\n\t\t\t\td[w] = d[v] + 1;\n\t\t\t\tQ.push(w);\n\t\t\t}\n\t\t}\n\t\tp = vector<vector<int>>(N, vector<int>(LOG, -1));\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tp[i][0] = P[i];\n\t\t}\n\t\tfor (int i = 1; i < LOG; i++){\n\t\t\tfor (int j = 0; j < N; j++){\n\t\t\t\tif (p[j][i - 1] != -1){\n\t\t\t\t\tp[j][i] = p[p[j][i - 1]][i - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint query(int u, int v){\n\t\tif (d[u] > d[v]){\n\t\t\tswap(u, v);\n\t\t}\n\t\tfor (int k = 0; k < LOG; k++){\n\t\t\tif ((d[v] - d[u]) >> k & 1){\n\t\t\t\tv = p[v][k];\n\t\t\t}\n\t\t}\n\t\tif (u == v){\n\t\t    return u;\n\t\t}\n\t\tfor (int k = LOG - 1; k >= 0; k--){\n\t\t\tif (p[u][k] != p[v][k]){\n\t\t\t\tu = p[u][k];\n\t\t\t\tv = p[v][k];\n\t\t\t\tassert(u != -1);\n\t\t\t\tassert(v != -1);\n\t\t\t}\n\t\t}\n\t\treturn p[u][0];\n\t}\n};\nint main(){\n  int n;\n  cin >> n;\n  vector<int> parent(n, -1);\n  vector<vector<int>> child(n);\n  for (int i = 0; i < n; i++){\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; j++){\n      int c;\n      cin >> c;\n      child[i].push_back(c);\n      parent[c] = i;\n    }\n  }\n  lowest_common_ancestor T(parent, child);\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    int u, v;\n    cin >> u >> v;\n    cout << T.query(u, v) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\nusing namespace std;\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-10;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n\n\n//ここから編集\n\n//RMQ + LCA\ntemplate<typename T = int> struct SegmentTree{\nprivate:\n  // [val, index]\n  vector<pair<T, int>> node;\n  int n, sz;\n\npublic:\n  void resize(vector<T>& v){\n    sz = v.size();\n    n = 1;\n    while(n < sz) n*=2;\n    node.resize(2*n);\n    for(int i=0; i<sz; i++){\n      node[i+n] = make_pair(v[i], i);\n    }\n    for(int i=n-1; i>=1; i--){\n      node[i] = min(node[2*i], node[2*i+1]);\n    }\n  }\n\n  void update(int k, T a){\n    k += n;\n    \n    node[k] = make_pair(a, k);\n    while(k >>= 1){\n      node[k] = min(node[2*k], node[2*k+1]);\n    }\n  }\n\n  // [a, b)について求める\n  pair<T, int> query(int a, int b){\n\n    pair<T, int> res1 = make_pair(numeric_limits<T>::max(), -1);\n    pair<T, int> res2 = make_pair(numeric_limits<T>::max(), -1);\n\n    a += n, b += n;\n    while(a != b){\n      if(a % 2) res1 = min(res1, node[a++]);\n      if(b % 2) res2 = min(res2, node[--b]);\n      a >>= 1, b >>= 1;\n    }\n    return min(res1, res2);\n  }\n};\n\nstruct LCA{\nprivate:\n  int V;\n  vector<vector<int>> G;\n  vector<int> ord, depth, id;\n  SegmentTree<int> st;\n  \n  void dfs(int u, int p, int k){\n    id[u] = (int)ord.size();\n    ord.push_back(u);\n    depth[u] = k;\n    for(int v: G[u]){\n      if(v != p){\n        dfs(v, u, k+1);\n        ord.push_back(u);\n      }\n    }\n  }\npublic:\n\n  LCA(int node_size) : V(node_size), G(V), depth(V), id(V, -1){}\n\n  void add_edge(int from, int to){\n    G[from].push_back(to);\n    G[to].push_back(from);\n  }\n\n  void build(){\n    ord.reserve(2*V-2);\n    for(int i=0; i<V; i++){\n      if(id[i] < 0){\n        dfs(i, -1, 0);\n      }\n    }\n\n    vector<int> stvec(2*V-2);\n    for(int i=0; i<2*V-2; i++){\n      stvec[i] = depth[ord[i]];\n    }\n    st.resize(stvec);\n  }\n\n  int lca(int u, int v){\n    return ord[st.query(min(id[u], id[v]), max(id[u], id[v])+1).second];\n  }\n\n  int dist(int u, int v){\n    int z = lca(u, v);\n    return depth[u] + depth[v] - 2 * depth[z];\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int n; cin >> n;\n  LCA lca(n);\n  REP(i,n){\n    int k; cin >> k;\n    REP(j,k){\n      int a; cin >> a;\n      lca.add_edge(i,a);\n    }\n  }\n  lca.build();\n  int q;\n  cin >> q;\n  while(q--){\n    int a, b; cin >> a >> b;\n    cout << lca.lca(a, b) << endl;\n  }\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\n#define INF (1 << 30)\nusing namespace std;\n\nvector<int> Index_(100010);  \nvector<bool> f(100010, false);\nvector<vector<int>> T(100010); //??°??????\nvector<P> ET;              //??????????????¨\n\n//??°???????????????????????¨????????????index?????¨??????????´??????????????????¨?????????????????????????????????????????????\n//ET : 2n - 1 ?????????????????¨??? (??±??????????´???????????????????\nvoid dfs(int n,int dep) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tIndex_[n] = ET.size() - 1;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1);\n\t\tET.emplace_back(make_pair(dep,n));\n\t}\n}\n\nP RMQ(int a, int b, int k, int l, int r,vector<P>& node) {\n\tif (r <= a || b <= l)return make_pair(INF, 0);\n\tif (a <= l && r <= b) { return node[k]; }\n\tP vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);\n\tP vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r,node);\n\n\tif (vl.first > vr.first) {\n\t\treturn vr;\n\t}\n\telse { return vl; }\n}\n\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n_; cin >> n_;\n\tvector<int> v(n_);\n\tfor (int i = 0; i < n_; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\n\tdfs(0,0);\n\n\tn_ = ET.size();\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<P> node(2 * n - 1,make_pair(INF,0));\n\tfor (int i = 0; i < n_;i++) {\n\t\tnode[n - 1 + i] = ET[i];\n\t}\t\n\tfor (int i = n - 2; i >= 0; i--) {\n\t\tif (node[2 * i + 1].first > node[2 * i + 2].first) {\n\t\t\tnode[i] = node[2 * i + 2];\n\t\t}\n\t\telse { \n\t\t\tnode[i] = node[2 * i + 1];\n\t\t}\n\t}\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tint a = Index_[u], b = Index_[v];\n\t\tif (a > b) swap(a, b);\n\t\tcout << RMQ(a, b, 0, 0, n_, node).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\n#define sz(x) ((int)x.size())\n\nstruct UnionFind {\n    vi data;\n    int comp;\n    UnionFind() {}\n    UnionFind(int size) {\n        init(size);\n    }\n    void init(int size) {\n        data.assign(size, -1);\n        comp = size;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        if (data[x] < 0) {\n            return x;\n        } else {\n            return data[x] = root(data[x]);\n        }\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() {\n        return comp;\n    }\n};\n\ntemplate <class Graph>\nstruct LCA {\n    using Query = pii;\n    Graph g;\n    vi color;\n    vi ancestor;\n    vector<vector<pair<int, Query>>> query_set;\n    vi res;\n    UnionFind uf;\n    LCA(const Graph &g, vector<Query> &query) :\n            g         (g),\n            color     (sz(g)),\n            ancestor  (sz(g)),\n            query_set (sz(query)),\n            res       (sz(query)),\n            uf        (sz(g))\n    {\n        int qs = sz(query);\n        rep(i, 0, qs) {\n            query_set[query[i].first ].emplace_back(i, query[i]);\n            query_set[query[i].second].emplace_back(i, query[i]);\n        }\n    }\n    void visit(int s, int prev) {\n        ancestor[uf.root(s)] = s;\n        for (auto &e : g[s]) {\n            if (e == prev) {\n                continue;\n            }\n            visit(e, s);\n            uf.unite(s, e);\n            ancestor[uf.root(s)] = s;\n        }\n        color[s] = 1;\n        for (auto &p : query_set[s]) {\n            Query q = p.second;\n            int w = (q.second == s ? q.first : (q.first == s ? q.second : -1));\n            if (w == -1 || !color[w]) {\n                continue;\n            }\n            res[p.first] = ancestor[uf.root(w)];\n        }\n    }\n    vi solve(int root) {\n        visit(root, -1);\n        return res;\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> G(N);\n    rep(i, 0, N) {\n        int K;\n        cin >> K;\n        rep(k, 0, K) {\n            int X;\n            cin >> X;\n            G[i].push_back(X);\n            G[X].push_back(i);\n        }\n    }\n    int Q;\n    cin >> Q;\n    vector<pii> queries;\n    rep(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        queries.emplace_back(U, V);\n    }\n    LCA<vvi> lca(G, queries);\n    vi res = lca.solve(0);\n\n    for (int ans : res) {\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// LCA: Doubling\n\n// ???????????????\n#include<iostream>\n#include<vector>\n#include<algorithm>\n// ?????????\nclass RootedTree {\npublic:\n  RootedTree(int n);\n  int size() const;\n  int parent(int v, int n = 1) const;\n  void join(int u, int v);\n  void initialize(int root);\n  int lca(int u, int v) const;\nprivate:\n  void initialize(int current, int previous, int depth);\n  std::vector<std::vector<int>> edge_;\n  std::vector<std::vector<int>> parent_;  // parent_[v][i]: ??????v???2^i????????????\n  std::vector<int> depth_;\npublic:   // ???????????°??¨\n  void print(int c, int p) {\n    std::cout<<c<<\":\";\n    for(auto i: parent_[c])std::cout<<\" \"<<i;\n    std::cout<<std::endl;\n    for(auto n: edge_[c])if(n!=p)print(n,c);\n  }\n};\n// ?????????????????????\nRootedTree::RootedTree(int n) : edge_(n) {}\n// ????????°\nint RootedTree::size() const {return edge_.size();}\n// ??????v???n????????????\nint RootedTree::parent(int v, int n) const {\n  if(!n) return v;\n  if(__builtin_popcount(n) == 1) return parent_[v][__builtin_ctz(n)];\n  for(int i = 31 - __builtin_clz(n); 0 <= i; --i) if((n >> i) & 1) v = parent_[v][i];\n  return v;\n}\n// ????????????\nvoid RootedTree::join(int u, int v) {\n  edge_[u].push_back(v);\n  edge_[v].push_back(u);\n}\n// ?????????\nvoid RootedTree::initialize(int root) {\n  parent_.assign(size(), std::vector<int>());\n  depth_.assign(size(), 0);\n  initialize(root, root, 0);\n}\nvoid RootedTree::initialize(int current, int previous, int depth) {\n  depth_[current] = depth;\n  parent_[current].push_back(previous);\n  for(int i = 1; (1 << i) <= depth; ++i) parent_[current].push_back(parent_[parent_[current][i - 1]][i - 1]);\n  for(const auto& next: edge_[current]) if(next != previous) initialize(next, current, depth + 1);\n}\n// LCA\nint RootedTree::lca(int u, int v) const {\n  // u, v???????????±????????????\n  if(depth_[u] > depth_[v]) std::swap(u, v);\n  v = parent(v, depth_[v] - depth_[u]);\n  // LCA????±???????\n  if(u == v) return u;\n  for(int i = 31 - __builtin_clz(depth_[u]); 0 <= i; --i) {\n    if(parent_[u][i] == parent_[v][i]) continue;\n    u = parent_[u][i];\n    v = parent_[v][i];\n    i = std::min(i, 31 - __builtin_clz(depth_[u]) + 1);\n  }\n  return parent_[u][0];\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  RootedTree tree(n);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      tree.join(i, c);\n    }\n  }\n  tree.initialize(0);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << tree.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\n\nclass LCA{\n\tint log,n;\n\tstd::vector<int> depth,par;\n\tint dfs(const int parent[],int u){\n\t\tif(parent[u]==-1)return depth[u]=1;\n\t\tif(depth[u]!=0)return depth[u];\n\t\treturn depth[u]=dfs(parent,parent[u])+1;\n\t}\npublic:\n\tLCA(const int parent[],int n):n(n),depth(n,0){\n\t\tlog=1;\n\t\twhile((1<<log)<n)log++;\n\t\tlog++;\n\t\tfor(int i=0;i<n;i++)dfs(parent,i);\n\t\tpar.resize(n*log);\t\n\t\tfor(int i=0;i<n;i++)par[i]=parent[i];\n\t\tfor(int i=1;i<log;i++)\n\t\t\tfor(int v=0;v<n;v++)\n\t\t\t\tpar[i*n+v]=par[(i-1)*n+par[(i-1)*n+v]];\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(depth[u] > depth[v])std::swap(u,v);\n\t\tfor(int i=log-1;i>=0;i--)\n\t\t\tif(depth[u] <= depth[v]-(1<<i))\n\t\t\t\tv=par[i*n+v];\n\t\tfor(int i=log-1;i>=0;i--){\n\t\t\tif(par[i*n+u]!=par[i*n+v]){\n\t\t\t\tu=par[i*n+u];\n\t\t\t\tv=par[i*n+v];\n\t\t\t}\n\t\t}\n\t\treturn par[u];\n\t}\n};\n\nusing namespace std;\n\nint par[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)par[i]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tpar[v]=i;\n\t\t}\n\t}\n\tLCA lca(par,n);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t{\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n  bool rev;\n\n  node_t(int id,int v):id(id),val(v),mini(v){\n    pp=lp=rp=NULL;\n    rev=false; \n    lazy=0; \n    update();\n  }\n   \n  void update(){\n    mini=val,minId=id;\n    push();\n    if(lp)lp->push();\n    if(rp)rp->push();\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  void push(){\n    if(rev){\n      rev=false;\n      swap(lp,rp);\n      if(lp)lp->rev^=true;\n      if(rp)rp->rev^=true;\n    }\n    if(lp)lp->lazy+=lazy;\n    if(rp)rp->lazy+=lazy;\n\n    val+=lazy,mini+=lazy,lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      node_t *r=q->pp;\n      if(!q->is_root())r->push();\n      q->push();\n      push();\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    rp=p;\n  }\n  x->splay();\n  return rp;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nbool isConnected(node_t *x, node_t *y){\n  if(x->id==y->id)return true;\n  expose(x);\n  //assert(x->pp==NULL);\n  expose(y);\n  return (x->pp != NULL);\n}\n\n//Verified.\nvoid evert(node_t *p){\n  expose(p);\n  p->rev^=true;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n}\n\nvoid link(node_t *c,node_t *p){\n  if(isConnected(c,p))return;\n  evert(c);\n  c->pp=p;\n}\n\n//Verified.\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->lazy=val; }\n\n//Verified. AOJ GRL_5_C\nnode_t *lca(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\n//Verified.\nint min(node_t *from, node_t *to){\n  evert(from);\n  expose(to);\n  return to->mini;\n}\n\n//Verified.\nvoid add(node_t *from, node_t *to,int v){\n  evert(from);\n  expose(to);\n  to->lazy+=v;\n}\n\n\n//AOJ GRL_5_C\nnode_t *node[100001];\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << lca(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass SparseTable{\nprivate:\n    int N;\n    int H;\n    vector<vector<int>> data;\n    vector<int> rdata;\n    \npublic:\n    SparseTable(vector<int> rdata): rdata(rdata){\n        N = rdata.size();\n        H = log2(N);\n        \n        data.resize(H+1);\n        for(int i=0; i<N; i++){\n            data[0].push_back(i);\n        }\n        int l = 1;\n        for(int h=1; h<=H; h++){\n            for(int i=0; i+l*2<=N; i++){\n                int idx = -1;\n                if(rdata[data[h-1][i]] < rdata[data[h-1][i+l]])\n                    idx = data[h-1][i];\n                else\n                    idx = data[h-1][i+l];\n                data[h].push_back(idx);\n            }\n            l <<= 1;\n        }\n    }\n    int find(int a, int b){\n        int h = log2(b-a);\n        if(rdata[data[h][a]] < rdata[data[h][b-(1<<h)]])\n            return data[h][a];\n        else\n            return data[h][b-(1<<h)];\n    }\n};\n\nvoid euler_tour(vector<vector<int>> &G, int u, int d, vector<int> &tour, vector<int> &depth){\n    tour.push_back(u);\n    depth.push_back(d);\n    for(auto v: G[u]){\n        euler_tour(G, v, d+1, tour, depth);\n        tour.push_back(u);\n        depth.push_back(d);\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    \n    for(int i=0; i<N; i++){\n        int k; cin >> k;\n        for(int j=0; j<k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    \n    vector<int> tour, depth;\n    euler_tour(G, 0, 0, tour, depth);\n    vector<int> rightmsot(N);\n    for(int i=0; i<tour.size(); i++)\n        rightmsot[tour[i]] = i;\n    \n    SparseTable st(tour);\n    \n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++){\n        int u, v; cin >> u >> v;\n        int ru = rightmsot[u], rv = rightmsot[v];\n        if(ru > rv)\n            swap(ru, rv);\n        rv++;\n        int d = st.find(ru, rv);\n        cout << tour[d] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    /*\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <functional>\n#include <cmath>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n#define dbg(...) fprintf(stderr,__VA_ARGS__);\nstruct range{\n\tint e,b=0,s=1;range(int b,int e,int s):e(e),b(b),s(s){} range(int b,int e): e(e), b(b){} range(int e):e(e){}\n\tstruct it{int v,s; it(int v,int s):v(v),s(s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\n_T using V = vector<T>;\n\ninline int log2(int n) {\n\treturn 31 - __builtin_clz(n);\n}\n\nstruct RMQ {\n\tV<V<int>> st;\n\tRMQ(V<int> &v) : st(log2(v.size()) + 1, vector<int>(v.size())) {\n\t\tst[0] = v;\n\t\tfor (size_t i : range(1, st.size()))\n\t\t\tfor (size_t j {}; j + (1 << i) <= v.size(); j++)\n\t\t\t\tst[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t}\n\tint query(int l, int r) {\n\t\tint a = log2(r - l);\n\t\treturn min(st[a][l], st[a][r - (1 << a)]);\n\t}\n};\n\nint main() {\n\tint n {in};\n\tV<V<int>> t(n);\n\tV<int> eu(n), n_o(n), v;\n\tfor (int i: range(n))\n\t\ttimes(j, in)\n\t\t\tt[i].push_back(in);\n\tint a {};\n\tfunction<void(int, int)> e = [&] (int i, int p){\n\t\tint n {a++};\n\t\tn_o[n] = i;\n\t\teu[i] = v.size();\n\t\tv.push_back(n);\n\t\tfor (int j: t[i])\n\t\t\tif (j != p) {\n\t\t\t\te(j, i);\n\t\t\t\tv.push_back(n);\n\t\t\t}\n\t};\n\te(0, -1);\n\tRMQ rmq(v);\n\ttimes(i, in) {\n\t\tint a {eu[(int) in]}, b {eu[(int) in]};\n\t\tif (a > b)\n\t\t\tswap(a, b);\n\t\toutl(n_o[rmq.query(a, b + 1)]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t{\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n  bool rev;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL;\n    rev=false; \n    lazy=0; \n    update();\n  }\n   \n  void update(){\n    mini=val,minId=id;\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>=rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  void apply(int v){ lazy+=v, val+=v, mini+=v; }\n   \n  void push(){\n    if(rev){\n      rev=false;\n      swap(lp,rp);\n      if(lp)lp->rev^=true;\n      if(rp)rp->rev^=true;\n    }\n    if(lp)lp->apply(lazy);\n    if(rp)rp->apply(lazy);\n    lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  x->splay();\n  return rp;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nbool isConnected(node_t *x, node_t *y){\n  if(x==y)return true;\n  expose(x),expose(y);\n  return (x->pp != NULL);\n}\n/*\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n  c->update();\n}\n*/\n\n//Unverified.\nvoid evert(node_t *p){\n  expose(p);\n  p->rev^=true;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  if(isConnected(c,p))return;\n  evert(c);\n  c->pp=p;\n}\n\n\n//Verified.\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->apply(val); }\n\n//Verified. AOJ GRL_5_C\nnode_t *LCA(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\nint min(node_t *from, node_t *to){\n  evert(from);\n  expose(to);\n  return to->mini;\n}\n\nvoid add(node_t *from, node_t *to,int v){\n  evert(from);\n  expose(to);\n  to->lazy+=v;\n}\n\n\n//AOJ GRL_5_C\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << LCA(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 200005\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct data{ll x,a,b;};\n\nint N,Q;\nint a,b,c;\nvector<int> G[MAX_N];\nint p[MAX_N],d[MAX_N],cnt=0;\nvector<int> g,flg;\n\n\nvoid rec(int pos,int prev,int depth){\n  d[pos]=depth;\n  p[pos]=g.size();\n  g.push_back(pos);\n\n  for(int i=0;i<(int)G[pos].size();i++){\n    int w=G[pos][i];\n    if(w==prev)continue;\n    rec(w,pos,depth+1);\n    g.push_back(pos);\n  }\n\n}\n\nP dp[MAX_N][26];\n\nint lca(int u,int v){\n\n  u=p[u];\n  v=p[v];\n  if(u>v)swap(u,v);\n  int dist=v-u+1;\n  int pos=u;\n  P res=P((1<<26),(1<<26));\n\n  for(int I=26;I>=0;I--){\n    int i=(1<<I);\n    if(dist>=i){\n      dist-=i;\n      res=min(res,dp[pos][I]);\n      pos+=i;\n    }\n  }\n\n  return g[res.second];\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&a);\n    for(int j=0;j<a;j++){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n    }\n  }\n\n  rec(0,-1,0);\n\n\n  for(int i=0;i<(int)g.size();i++)\n    dp[i][0]=P(d[g[i]],i);\n\n  int K=1;\n  for(int k=1;k<26;k++){\n    for(int i=0;i<(int)g.size();i++){\n      dp[i][k]=dp[i][k-1];\n      int j=i+K;\n      if(j>=(int)g.size())j=g.size()-1;\n      dp[i][k]=min(dp[i][k],dp[j][k-1]);\n    }\n    K*=2;\n  }\n  \n  cin>>Q;\n\n\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",lca(a,b));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define L class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<L T>void pr1(T a){cout<<a;ln;}\ntemplate<L T,L T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<L T,L T2,L T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<L T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nstruct HL {\n  static const int MD=20;\n  int N,NE;\n  vector<vector<int> > E,Cs;\n  vector<int> D,S,B,C,Ci;\n  vector<vector<int> > Q;\n  void init(int N){this->N=N,NE=0,E.clear(),E.resize(N);Cs.clear(),Cs.resize(N);D=S=B=C=Ci=vector<int>(N,0);Q.clear();rep(i,MD+1)Q.pb(vector<int>(N,0));}\n  void add_edge(int a,int b){E[a].pb(b),E[b].pb(a);NE++;}\n  void dfs(int cur,int pre) {\n    Q[0][cur]=pre;S[cur]=1;C[cur]=Ci[cur]=-1;B[cur]=cur;D[cur]=(pre==-1)?0:(D[pre]+1);\n    rep(i,E[cur].size())if(E[cur][i]!=pre){int r=E[cur][i];dfs(r,cur);S[cur]+=S[r];if(C[cur]==-1||S[r]>S[C[cur]])C[cur]=r,Ci[cur]=i;}\n  }\n  void dfs2(int cur,int pre) {\n    if(pre!=-1&&C[pre]==cur)B[cur]=B[pre];Cs[B[cur]].pb(cur);\n    rep(i,E[cur].size())if(E[cur][i]!=pre)dfs2(E[cur][i],cur);\n  }\n  P lca(int a,int b) {\n    int aa=a,bb=b;if(D[aa]>D[bb])swap(aa,bb);\n    rrep(i,20)if(D[bb]-D[aa]>=1<<i)bb=Q[i][bb];\n    rrep(i,20)if(Q[i][aa]!=Q[i][bb])aa=Q[i][aa],bb=Q[i][bb];\n    return P((aa==bb)?aa:Q[0][aa],D[a]+D[b]-2*D[(aa==bb)?aa:Q[0][aa]]);\n  }\n  void decomp(int root=0){dfs(root,root);dfs2(root,root);rep(i,MD)rep(x,N)Q[i+1][x]=Q[i][Q[i][x]];}\n};\n\nvoid Main() {\n  int n;\n  R n;\n  HL hl;\n  hl.init(n);\n  rep(i,n) {\n    int k;\n    R k;\n    rep(j,k) {\n      int x;\n      R x;\n      hl.add_edge(i,x);\n    }\n  }\n  hl.decomp();\n  int m;\n  R m;\n  while(m--) {\n    int x,y;\n    cin >> x >> y;\n    pr(hl.lca(x,y).F);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass tree{\npublic:\n\tint n;\n\tvector<vector<int>> g;\n\ttree(int _n){\n\t\tn = _n;\n\t\tg.resize(n, vector<int>());\n\t}\n\n\tvoid add_edge(int v, int w){\n\t\tg[v].push_back(w);\n\t\tg[w].push_back(v);\n\t}\n};\nclass rooted_tree : public tree{\npublic:\n\tusing tree::tree;\n\tint r;\n\tint ln = 1;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\tvoid set_root(int _r){\n\t\tr = _r;\n\t\twhile((1<<ln) <= n) ++ln;\n\t\tparent.resize(n, vector<int>(ln, -1));\n\t\tdepth.resize(n);\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(r, -2));\n\t\tdepth[r] = 0;\n\t\twhile(!q.empty()){\n\t\t\tpair<int, int> p = q.front(); q.pop();\n\t\t\tint v = p.first, pr = p.second;\n\t\t\tfor(int i=0; i<(int)g[v].size(); ++i){\n\t\t\t\tint to = g[v][i];\n\t\t\t\tif(to != pr){\n\t\t\t\t\tparent[to][0] = v;\n\t\t\t\t\tdepth[to] = depth[v]+1;\n\t\t\t\t\tq.push(make_pair(to, v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid doubling(){\n\t\tfor(int i=0; i+1<ln; ++i){\n\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\tif(parent[j][i] < 0) parent[j][i+1] = -1;\n\t\t\t\telse parent[j][i+1] = parent[parent[j][i]][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tint lowest_common_ancestor(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tfor(int i=0; i<ln; ++i)\n\t\t\tif((depth[v] - depth[u]) >> i & 1)\n\t\t\t\tv = parent[v][i];\n\t\tif(u == v) return u;\n\t\tfor(int i=ln-1; i>=0; --i){\n\t\t\tif(parent[u][i] != parent[v][i]){\n\t\t\t\tu = parent[u][i];\n\t\t\t\tv = parent[v][i];\n\t\t\t}\n\t\t}\n\t\treturn parent[u][0];\n\t}\n};\n\nint main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\trooted_tree rt(n);\n\tfor(int i=0; i<n; ++i){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0; j<k; ++j){\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\trt.add_edge(i, c);\n\t\t}\n\t}\n\trt.set_root(0);\n\trt.doubling();\n/*\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; (1<<j)<=n; ++j)\n\t\t\tcout << rt.parent[i][j] << \" \\n\"[(1<<(j+1))>n];\n*/\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << rt.lowest_common_ancestor(u, v) << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\n\nstruct LCA {\nprivate:\n  vector<vector<int>> G;\n  size_t n, m;\n  vector<vector<int>> A;\n  vector<int> D;\n  void dfs(int v, int p){\n    for(auto v_ : G[v]){\n      if(v_ == p) continue;\n      A[v_][0] = v;\n      D[v_] = D[v]+1;\n      dfs(v_,v);\n    }\n  }\n  void build(int r){\n    dfs(r,-1);\n    A[r][0] = r;\n    for(size_t i = 1; i < m; ++i){\n      for(size_t j = 0; j < n; ++j){\n        A[j][i] = A[A[j][i-1]][i-1];\n      }\n    }\n  }\npublic:\n  LCA(const vector<vector<int>>& Tree, int r) : G(Tree), n(Tree.size()), m(1), D(n,0) {\n    size_t t = 1;\n    while(t < n) ++m, t *= 2;\n    A = vector<vector<int>>(n,vector<int>(m,-1));\n    build(r);\n  }\n  size_t query(int u, int v){\n    if(D[u] < D[v]) swap(u,v);\n\n    for(size_t i = m-1; i < m; --i){\n      size_t u_ = A[u][i];\n      if(D[u_] < D[v]) continue;\n      u = u_;\n    }\n\n    if(u == v) return u;\n    assert(D[u] == D[v]);\n    for(size_t i = m-1; i < m; --i){\n      if(A[u][i] != A[v][i])\n        u = A[u][i], v = A[v][i];\n    }\n    return A[u][0];\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<vector<int>> G(n);\n  for(int i = 0; i < n; ++i){\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j){\n      int c;\n      cin >> c;\n      G[i].push_back(c);\n      G[c].push_back(i);\n    }\n  }\n  LCA lca(G,0);\n  int q;\n  cin >> q;\n  while(q--){\n    int u, v;\n    cin >> u >> v;\n    cout << lca.query(u,v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<vector>\n#include<cmath>\n#include<utility>\n\ntemplate<typename Label>\nclass RootedTree {\npublic:\n  void join(const Label& u, const Label& v) {\n    edge_[u].push_back(v);\n    edge_[v].push_back(u);\n  }\n  void initialize(const Label& root) {initialize(root, root, 0);}\n  int depth(const Label& v) const {return depth_.at(v);}\n  // v の d 番目の祖先を求める O(log(d))\n  Label ancestor(Label v, int d = 1) const {\n    for(int i = 1; i <= d; i <<= 1) if(d & i) v = ancestor_.at(v).at(i);\n    return v;\n  }\n  Label lca(Label u, Label v) const {\n    // u, v の深さを一致させる O(log(深さの差))\n    if(depth(v) < depth(u)) std::swap(u, v);\n    v = ancestor(v, depth(v) - depth(u));\n    // lca を求める O(log(深さ))\n    if(u == v) return u;\n    int bits = log2(depth(u));\n    for(int i = 1 << bits; 0 < i; i >>= 1) {\n      if(i > depth(u)) continue;\n      if(ancestor(u, i) == ancestor(v, i)) continue;\n      u = ancestor(u, i);\n      v = ancestor(v, i);\n    }\n    return ancestor(u, 1);\n  }\nprivate:\n  void initialize(const Label& current, const Label& previous, int depth) {\n    depth_[current] = depth;\n    for(int i = 2; i <= depth; i <<= 1) {ancestor_[current][i] = ancestor_[ancestor_[current][i >> 1]][i >> 1];}\n    for(const auto& v: edge_[current]) {\n      if(v == previous) continue;\n      ancestor_[v][1] = current;\n      initialize(v, current, depth + 1);\n    }\n  }\n  std::unordered_map<Label, int> depth_;\n  std::unordered_map<Label, std::vector<Label>> edge_;\n  std::unordered_map<Label, std::unordered_map<int, Label>> ancestor_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  RootedTree<int> t;\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      t.join(i, c);\n    }\n  }\n  t.initialize(0);\n\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << t.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n} \nstruct Edge {\n    long long to;\n    //long long w;\n};\nusing Graph = vector<vector<Edge>>;\n/* LCA(G, root): 木 G に対する根を root として Lowest Common Ancestor を求める構造体\n    query(u,v): u と v の LCA を求める。計算量 O(logn)\n    前処理: O(nlogn)時間, O(nlogn)空間\n*/\nstruct LCA {\n    vector<vector<int>> parent;  // parent[k][u]:= u の 2^k 先の親\n    vector<int> dist;            // root からの距離\n    //vector<vector<ll>> sumcost;\n    LCA(const Graph &G, int root = 0) { init(G, root); }\n    // 初期化\n    void init(const Graph &G, int root = 0) {\n        int V = G.size();\n        int K = 1;\n        while ((1 << K) < V) K++;\n        parent.assign(K, vector<int>(V, -1));\n        dist.assign(V, -1);\n        //sumcost.assign(K, vector<ll>(V, 0));\n        dfs(G, root, -1, 0);\n        for (int k = 0; k + 1 < K; k++) {\n            for (int v = 0; v < V; v++) {\n                if (parent[k][v] >= 0) {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                    //sumcost[k + 1][v] = sumcost[k][v]+sumcost[k][parent[k][v]];\n                }\n            }\n        }\n    }\n    // 根からの距離と1つ先の頂点を求める\n    void dfs(const Graph &G, int v, int p, int d) {\n        parent[0][v] = p;\n        dist[v] = d;\n        for (auto e : G[v]) {\n            if (e.to != p) {\n                //sumcost[0][e.to]=e.w;\n                dfs(G, e.to, v, d + 1);\n            }\n        }\n    }\n    int query(int u, int v) {\n        if (dist[u] < dist[v]) swap(u, v);  // u の方が深いとする\n        int K = parent.size();\n        // LCA までの距離を同じにする\n        for (int k = 0; k < K; k++) {\n            if ((dist[u] - dist[v])&(1<<k) ){\n                u = parent[k][u];\n            }\n        }\n        // 二分探索で LCA を求める\n        if (u == v) return u;\n        for (int k = K - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /*ll getsumcost(int u, int v) {\n        if (dist[u] < dist[v]) swap(u, v);  // u の方が深いとする\n        int K = parent.size();\n        ll ret=0;\n        // LCA までの距離を同じにする\n        for (int k = 0; k < K; k++) {\n            if ((dist[u] - dist[v])  &  (1<<k) ) {\n                ret=ret+sumcost[k][u];\n                u = parent[k][u];\n            }\n        }\n        // 二分探索で LCA を求める\n        if (u == v) return ret;\n        for (int k = K - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                ret=ret+sumcost[k][u]+sumcost[k][v];\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        ret=ret+sumcost[0][u]+sumcost[0][v];\n        return ret;\n    }*/\n    int length(int u, int v) { return dist[u] + dist[v] - 2 * dist[query(u, v)]; }\n    bool is_in(int u, int v, int a) { return length(u, a) + length(a, v) == length(u, v); }\n};\nint main(){\n    ll n;cin >> n;\n    Graph g(n);\n    rep(i,n){\n        ll k;cin >> k;\n        rep(j,k){\n            Edge t;cin >> t.to;\n            Edge x;x.to=i;\n            g[i].pb(t);g[t.to].pb(x);\n        }\n    }\n    LCA l(g,0);\n    ll q;cin >> q;\n    rep(i,q){\n        ll u,v;cin >> u >> v;\n        cout << l.query(u,v) <<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int MAX = 1e5;\npii table[18][MAX * 2 - 1];\n\nint n;\nvector<int> G[MAX];\nint id[MAX];\n\nint it = 0;\n\nvoid dfs(int v, int d) {\n\tid[v] = it;\n\ttable[0][it++] = { d, v };\n\tfor (auto to : G[v]) {\n\t\tdfs(to, d + 1);\n\t\ttable[0][it++] = { d, v };\n\t}\n}\n\nvoid init() {\n\tdfs(0, 0);\n\tint m = (n << 1) - 1;\n\tint h = 31 - __builtin_clz(m);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j + (1 << i) < m; j++) {\n\t\t\ttable[i + 1][j] = min(table[i][j], table[i][j + (1 << i)]);\n\t\t}\n\t}\n}\n\nint lca(int u, int v) {\n\tu = id[u], v = id[v];\n\tif (u > v) swap(u, v);\n\tint b = 31 - __builtin_clz(v + 1 - u);\n\treturn min(table[b][u], table[b][v + 1 - (1 << b)]).second;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<long long, long long> P;\nstruct edge{long long to,cost;};\nconst int inf = 1 << 27;\nconst long long INF = 1LL << 60;\nconst int COMBMAX = 1001001;\nconst long long MOD = 1000000007;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define eachdo(v, e) for(const auto& e : (v))\n#define all(v) (v).begin(), (v).end()\n#define lower_index(v, e) (long long)distance((v).begin(), lower_bound((v).begin(), (v).end(), e))\n#define upper_index(v, e) (long long)distance((v).begin(), upper_bound((v).begin(), (v).end(), e))\nlong long mpow(long long a, long long n, long long mod = MOD){long long res = 1; while(n > 0){if(n & 1)res = res * a % mod; a = a * a % mod; n >>= 1;} return res;}\nvoid yn(bool j){cout << (j ? \"Yes\" : \"No\") << endl; return;}\ntemplate<class Head> void pt(Head&& head){cout << head << endl; return;}\ntemplate<class Head, class... Tail> void pt(Head&& head, Tail&&... tail){cout << head << \" \"; pt(forward<Tail>(tail)...);}\ntemplate<class T> void debug(T v){rep(i, v.size()) cout << v[i] << \" \" ; cout << endl;}\ntemplate<class T> void debug2(T v){rep(i, v.size()){rep(j, v[i].size()) cout << v[i][j] << \" \" ; cout << endl;}}\ntemplate<class T1, class T2> long long bcount(T1 v, T2 a){return upper_index(v, a) - lower_index(v, a);} \ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b){if(a > b){a = b; return true;} return false;}\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b){if(a < b){a = b; return true;} return false;}\n\nstruct Graph{\npublic:\nll V, logV;\nvector<vector<edge>> Glist;\nvector<vector<ll>> Gmatrix;\nvector<ll> LCA_dist;\nvector<vector<ll>> LCA_doubling;\n\nGraph(ll NodeNum){\n    V = NodeNum;\n    Glist.resize(V);\n}\n    void add(ll from,ll to,ll cost = 1){\n        Glist[from].push_back({to,cost});\n    }\n\n    void express(){\n        for(ll i = 0; i < Glist.size(); i++){\n            cout << i << \" => {\";\n            eachdo(Glist[i], e){\n                cout << \" \" << e.to;\n            } \n            cout << \" }\" << endl;\n        }\n        return;\n    }\n\n    void UpdateGmatrix() {\n        Gmatrix.resize(V);\n        rep(i,V){\n            Gmatrix[i].resize(V,INF);\n            eachdo(Glist[i],e){\n                Gmatrix[i][e.to] = e.cost;\n            }\n        }\n    }\n\n    vector<vector<ll>> WarshallFloyd(){\n        UpdateGmatrix();\n        vector<vector<ll>> dist = Gmatrix;\n        rep(i,V) dist[i][i] = 0;\n        rep(k,V)rep(i,V)rep(j,V) chmin(dist[i][j],dist[i][k]+dist[k][j]);\n        return dist;\n    }\n\n    vector<bool> hasNegativeLoop(){\n        vector<bool> ret(V,false);\n        vector<ll> dist(V,0);\n        rep(loop,2*V-1){\n            rep(i,V)eachdo(Glist[i],e){\n                if(dist[i] + e.cost < dist[e.to]){\n                    dist[e.to] = dist[i] + e.cost;\n                    if(V-1 <= loop) ret[e.to] = true;        \n                }\n            }\n        }\n        return ret;\n    }\n\n    vector<ll> BellmanFord(ll start){\n        vector<ll> dist(V,INF);\n        dist[start] = 0;\n        rep(loop,V-1){\n            rep(i,V)eachdo(Glist[i],e){\n                if(dist[i] + e.cost < dist[e.to]){\n                    dist[e.to] = dist[i] + e.cost;        \n                }\n            }\n        }\n        return dist;\n    }\n\n    vector<ll> Dijkstra(ll start){\n        vector<ll> dist(V,INF);\n        priority_queue<P,vector<P>,greater<P>> que;\n        dist[start] = 0;\n        que.push(P(0,start)); \n        while(!que.empty()){\n            P p = que.top();que.pop();\n            ll v = p.second;\n            if(dist[v]<p.first) continue;\n            rep(i,Glist[v].size()){\n                edge e = Glist[v][i];\n                if(dist[v] + e.cost < dist[e.to]){\n                    dist[e.to] = dist[v]+e.cost;\n                    que.push(P(dist[e.to],e.to));\n                }\n            }\n        }\n        return dist;\n    }\n\n    // Graph needs to be undirected tree.\n\n    void dfs_in_build_LCA(ll node, ll parent = -1){\n        if (parent != -1) LCA_dist[node] = LCA_dist[parent] + 1;\n        LCA_doubling[0][node] = parent;\n        for(auto e : Glist[node]){\n            if (e.to == parent) continue;\n            dfs_in_build_LCA(e.to, node);\n        }\n    }\n\n    void build_LCA(ll root){\n        LCA_dist.assign(V, INF);\n        logV = 2;\n        while(1 << logV < V) logV++;\n        LCA_dist.assign(V, INF);\n        LCA_doubling.assign(logV, vector<ll>(V, -1));\n        LCA_dist[root] = 0;\n        dfs_in_build_LCA(root);\n        for(ll i = 1; i < logV; i++){\n            for(ll j = 0; j < V; j++){\n                if (LCA_doubling[i - 1][j] == -1){\n                    LCA_doubling[i][j] = -1;\n                    continue;\n                }\n                LCA_doubling[i][j] = LCA_doubling[i - 1][LCA_doubling[i - 1][j]];\n            }\n        }\n    }\n\n    ll LCA_query(ll u, ll v){\n        if (LCA_dist[v] < LCA_dist[u]) swap(u, v);\n        ll upstream = LCA_dist[v] - LCA_dist[u];\n        for(ll i = 0; i < logV; i++){\n            if (upstream >> i & 1) v = LCA_doubling[i][v]; \n        }\n        // pt(upstream, u + 1, v + 1);\n        // cout << endl;\n        ll ng = -1, ok = V;\n        while(ok - ng > 1){\n            ll half = (ng + ok) / 2;\n            ll ua = u, va = v;\n            for(ll i = 0; i < logV; i++){\n                if (half >> i & 1){\n                    if (ua == -1 || va == -1){\n                        ua = -1;\n                        va = -1;\n                        break;\n                    }\n                    ua = LCA_doubling[i][ua];\n                    va = LCA_doubling[i][va];\n                }\n            }\n\n            if (ua == va) ok = half;\n            else ng = half;\n        }\n        ll ret = u;\n        for(ll i = 0; i < logV; i++){\n            if (ok >> i & 1) ret = LCA_doubling[i][ret]; \n        }\n        return ret;\n    }\n};\n\nint main(){\n    ll N; cin >> N;\n    Graph g(N);\n    rep(i, N){\n        ll k; cin >> k;\n        rep(j, k){\n            ll v; cin >> v;\n            g.add(i, v);\n            g.add(v, i);\n        }\n    }\n    g.build_LCA(0);\n    ll Q; cin >> Q;\n    while(Q--){\n        ll u, v; cin >> u >> v;\n        pt(g.LCA_query(u, v));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 3000005\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct data{ll x,a,b;};\n\nint N,Q;\nint a,b,c;\nvector<int> G[MAX_N];\nint p[MAX_N],l[MAX_N],r[MAX_N],d[MAX_N],cnt=0;\nvector<int> g,flg;\n\n\nvoid rec(int pos,int prev,int depth){\n  d[pos]=depth;\n  l[pos]=g.size();\n  p[pos]=g.size();\n  g.push_back(pos);\n  if(G[pos].size()==0)l[pos]=r[pos]=cnt++;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int w=G[pos][i];\n    if(w==prev)continue;\n    rec(w,pos,depth+1);\n    g.push_back(pos);\n  }\n  r[pos]=g.size()-1;\n}\n\nint Depth[MAX_N];\nP dp[MAX_N][30];\n\nint lca(int u,int v){\n\n  u=p[u];\n  v=p[v];\n  if(u>v)swap(u,v);\n  int dist=v-u+1;\n  int pos=u;\n  P res=P((1<<26),(1<<26));\n\n  for(int I=26;I>=0;I--){\n    int i=(1<<I);\n    if(dist>=i){\n      dist-=i;\n      res=min(res,dp[pos][I]);\n      pos+=i;\n    }\n  }\n\n  return g[res.second];\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&a);\n    for(int j=0;j<a;j++){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n    }\n  }\n\n  rec(0,-1,0);\n\n\n  for(int i=0;i<(int)g.size();i++)\n    dp[i][0]=P(d[g[i]],i);\n\n  int K=1;\n  for(int k=1;k<30;k++){\n    for(int i=0;i<(int)g.size();i++){\n      dp[i][k]=dp[i][k-1];\n      int j=i+K;\n      if(j>=(int)g.size())j=g.size()-1;\n      dp[i][k]=min(dp[i][k],dp[j][k-1]);\n    }\n    K*=2;\n  }\n  \n  cin>>Q;\n\n\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",lca(a,b));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 700){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\n// struct sqrt_decomp_tree {\n//     int n, B;\n//     int size() const {\n//         return n;\n//     }\n    \n//     vi parent, // 親のノード\n//     depth, // ノードの深さ\n//     block, // ノードが属するブロック\n//     block_depth, // ノードが属するブロックの根の深さ\n//     block_parent, // ノードが属するブロックの根の親ノード\n//     visited;\n    \n//     vvi adj;\n//     sqrt_decomp_tree(int n) : n(n), adj(n), parent(n, -1), depth(n), block(n, -1), block_depth(n, -1), block_parent(n, -1), visited(n) {\n//         int l = 0, r = n;\n//         while (l < r - 1) {\n//             i64 m = (l + r) / 2;\n//             if (m * m >= n) {\n//                 r = m;\n//             } else {\n//                 l = m;\n//             }\n//         }\n//         B = r;\n//     }\n    \n//     void addEdge(int a, int b) {\n//         adj[a].push_back(b);\n//         adj[b].push_back(a);\n//     }\n    \n//     void decomp(int root = 0) {\n//         vi tord;\n//         vi q(n + 1);\n//         int l = 0, r = 0;\n//         q[r++] = root;\n//         while (l != r) {\n//             int v = q[l++];\n//             visited[v] = 1;\n//             tord.push_back(v);\n//             for (int s: adj[v]) {\n//                 if (!visited[s]) {\n//                     parent[s] = v;\n//                     depth[s] = depth[v] + 1;\n//                     q[r++] = s;\n//                 }\n//             }\n//         }\n//         visited.assign(n, 0);\n//         int c = 0;\n//         for (int u: tord) {\n//             if (block[u] != -1) continue;\n//             l = 0;\n//             r = 0;\n//             q[r++] = u;\n//             for (int i = 0; i < B && l != r; i++) {\n//                 int v = q[l++];\n//                 block[v] = c;\n//                 block_parent[v] = parent[u];\n//                 block_depth[v] = depth[u];\n//                 for (int s: adj[v]) {\n//                     if (block[s] == -1) q[r++] = s;\n//                 }\n//             }\n//             c++;\n//         }\n//     }\n    \n//     int lca(int u, int v) {\n//         while (block_depth[u] > block_depth[v]) {\n//             u = block_parent[u];\n//         }\n//         while (block_depth[u] < block_depth[v]) {\n//             v = block_parent[v];\n//         }\n//         while (depth[u] > depth[v]) {\n//             u = parent[u];\n//         }\n//         while (depth[u] < depth[v]) {\n//             v = parent[v];\n//         }\n//         if (u != v) {\n//             u = parent[u];\n//             v = parent[v];\n//         }\n//         return u;\n//     }\n// };\n\nconst int B = 512;\n\nstruct sqrt_decomp_tree {\n    int n;\n    int size() const { return n; }\n    std::vector<int> color, parent, depth, root_depth, go_up, visited;\n    std::vector<std::vector<int>> g;\n    sqrt_decomp_tree(int n_) : n(n_), g(n) {}\n    void addEdge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    void decomp(int root = 0) {\n        parent.assign(n, -1);\n        depth.assign(n, 0);\n        root_depth.assign(n, 0);\n        go_up.assign(n, -1);\n        visited.assign(n, false);\n        std::vector<int> tord;\n        std::vector<int> q(n + 1);\n        int l = 0, r = 0;\n        q[r++] = root;\n        while (l != r) {\n            int v = q[l++];\n            visited[v] = true;\n            tord.push_back(v);\n            for (int c : g[v]) {\n                if (!visited[c]) {\n                    parent[c] = v;\n                    depth[c] = depth[v] + 1;\n                    q[r++] = c;\n                }\n            }\n        }\n        std::swap(color, visited);  // メモリをケチる\n        color.assign(n, -1);\n        int c = 0;\n        for (int u : tord) {\n            if (color[u] != -1) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for (int i = 0; i < B && l != r; i++) {\n                int v = q[l++];\n                color[v] = c;\n                go_up[v] = parent[u];\n                root_depth[v] = depth[u];\n                for (int c : g[v])\n                    if (color[c] == -1) q[r++] = c;\n            }\n            c++;\n        }\n    }\n    int lca(int u, int v) {\n        while (root_depth[u] > root_depth[v]) u = go_up[u];\n        while (root_depth[u] < root_depth[v]) v = go_up[v];\n        while (depth[u] > depth[v]) u = parent[u];\n        while (depth[u] < depth[v]) v = parent[v];\n        while (u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    sqrt_decomp_tree tree(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int u;\n            cin >> u;\n            tree.addEdge(i, u);\n        }\n    }\n    \n    tree.decomp();\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 99999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\nconst int N=1e5+10;\n\n#define PB push_back\nint max(int a,int b){return a>b?a:b;}\n\nint hev[N],top[N],dep[N],p[N];\nvector<int>des[N];\nint init(int now){\n    if(des[now].empty())return 0;\n    int ans=0,temp;\n    for(int i=0;i<des[now].size();i++){\n        dep[des[now][i]]=dep[now]+1;\n        p[des[now][i]]=now;\n        temp=init(des[now][i])+1;\n        if(temp>ans){\n            ans=temp;\n            hev[now]=i;\n        }\n    }\n    return ans;\n}\nvoid built(int now,int from){\n    top[now]=from;\n    for(int i=0;i<des[now].size();i++){\n        if(hev[now]==i)built(des[now][i],from);\n        else built(des[now][i],des[now][i]);\n    }\n    return ;\n}\nint lca(int a,int b){\n    while(a!=b){\n        if(dep[top[a]]>dep[top[b]])swap(a,b);\n        if(top[a]==top[b]){\n            if(dep[b]<dep[a])a=b;\n            break;\n        }\n        b=p[top[b]];\n    }\n    return a;\n}\nint main(){\n    int n,k,l,r;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        while(k--){\n            scanf(\"%d\",&l);\n            des[i].PB(l);\n        }\n    }\n    init(0);\n    built(0,0);\n    scanf(\"%d\",&n);\n    while(n--){\n        scanf(\"%d%d\",&l,&r);\n        printf(\"%d\\n\",lca(l,r));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\n//const ll MOD = 998244353;\n//const ll MOD = ;\nll mod(ll A, ll M) {return (A % M + M) % M;}\nconst ll INF = 1LL << 60;\ntemplate<class T> bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}\ntemplate<class T> bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}\nll divceil(ll A, ll B) {return (A + (B - 1)) / B;}\nll myctoi(char C) {return C - '0';}\nchar myitoc(ll N) {return '0' + N;}\n#define FINALANS(A) do {cout << (A) << '\\n'; exit(0);} while (false)\n\nint main()\n{\n  ll N;\n  cin >> N;\n\n  vector<vector<ll>> G(N);\n  vector<vector<ll>> next(1, vector<ll>(N));\n  next.at(0).at(0) = -1;\n  for (ll i = 0; i < N; i++)\n  {\n    ll K;\n    cin >> K;\n    for (ll j = 0; j < K; j++)\n    {\n      ll c;\n      cin >> c;\n      G.at(i).push_back(c);\n      next.at(0).at(c) = i;\n    }\n  }\n\n  vector<ll> depth(N, -1);\n  depth.at(0) = 0;\n  queue<ll> que;\n  que.push(0);\n  while (!que.empty())\n  {\n    ll v = que.front();\n    que.pop();\n\n    for (auto nv : G.at(v))\n    {\n      if (depth.at(nv) != -1)\n        continue;\n\n      depth.at(nv) = depth.at(v) + 1;\n      que.push(nv);\n    }\n  }\n\n  for (ll i = 0;; i++)\n  {\n    next.push_back(vector<ll>(N));\n    bool fin = true;\n    for (ll j = 0; j < N; j++)\n    {\n      ll tmp = next.at(i).at(j);\n      if (tmp == -1)\n        next.back().at(j) = -1;\n      else\n        next.back().at(j) = next.at(i).at(tmp);\n      \n      if (next.back().at(j) != -1)\n        fin = false;\n    }\n\n    if (fin)\n      break;\n  }\n  ll M = next.size();\n\n  ll Q;\n  cin >> Q;\n  for (ll q = 0; q < Q; q++)\n  {\n    ll u, v;\n    cin >> u >> v;\n\n    if (depth.at(u) > depth.at(v))\n      swap(u, v);\n\n    ll x = depth.at(v) - depth.at(u);\n    for (ll k = 0; k < M; k++)\n    {\n      if (x % 2 == 1)\n        v = next.at(k).at(v);\n\n      x /= 2;\n    }\n    if (u == v)\n    {\n      cout << u << endl;\n      continue;\n    }\n\n    for (ll k = M - 1; k >= 0; k--)\n    {\n      if (next.at(k).at(u) != next.at(k).at(v))\n      {\n        u = next.at(k).at(u);\n        v = next.at(k).at(v);\n      }\n    }\n    ll ans = next.at(0).at(u);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing Graph = vector<vector<int> >;\n\nclass LCA {\npublic:\n    vector<vector<int> > parent; // parent[d][v] := 2^d-th parent of v\n    vector<int> depth;\n    \n    LCA() { }\n    \n    LCA(const Graph &G, int r = 0) { init(G, r); }\n    \n    void init(const Graph &G, int r = 0) {\n        \n        int V = (int)G.size();\n        int h = 1;\n        \n        while ((1<<h) < V) ++h;\n        \n        parent.assign(h, vector<int>(V, -1));\n        depth.assign(V, -1);\n        \n        dfs(G, r, -1, 0);\n        \n        for (int i = 0; i+1 < (int)parent.size(); ++i)\n            for (int v = 0; v < V; ++v)\n                if (parent[i][v] != -1)\n                    parent[i+1][v] = parent[i][parent[i][v]];\n    }\n    \n    \n    void dfs(const Graph &G, int v, int p, int d) {\n        \n        parent[0][v] = p;\n        depth[v] = d;\n        for (auto e : G[v]) if (e != p) dfs(G, e, v, d+1);\n    }\n    \n    \n    int getLCA(int u, int v) {\n        \n        if (depth[u] > depth[v]) swap(u, v);\n        for (int i = 0; i < (int)parent.size(); ++i)\n            if ( (depth[v] - depth[u]) & (1<<i) )\n                v = parent[i][v];\n        if (u == v) return u;\n        for (int i = (int)parent.size()-1; i >= 0; --i) {\n            if (parent[i][u] != parent[i][v]) {\n                u = parent[i][u];\n                v = parent[i][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\nint main() {\n    int N; cin >> N;\n    Graph G(N);\n    \n    for (int i = 0; i < N; ++i) {\n        int num; cin >> num;\n        \n        for (int j = 0; j < num; ++j) {\n            \n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    \n    LCA lca(G);\n    \n    int Q; cin >> Q;\n    \n    for (int q = 0; q < Q; ++q) {\n        int u, v; cin >> u >> v;\n        cout << lca.getLCA(u, v) << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n// c++11\n#include <array>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n\n#define mp make_pair\n#define mt make_tuple\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\nconst int INF = 1 << 29;\nconst ll LL_INF = 1LL << 60;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nint N, M;\nint Q;\nconst int MAX_N = 100010;\nvector<vector<int>> edges;\n//LowestCommonAncestor\n//init -> lca(a, b)\ntemplate <typename T>\nclass LowestCommonAncestor\n{\n  public:\n    static const int MAX_LOG_V = 30;\n    static const int NONE_NODE = -1;\n    vector<int> parents[MAX_LOG_V]; // follow parents 2^k times node index (ex parents[k][v] start v follow parents 2^k times)\n    vector<int> depths;             //the depth from root.\n    T edges;\n    void dfs(int pos, int pre, int depth = 0)\n    {\n        parents[0][pos] = pre;\n        depths[pos] = depth;\n        for (const auto &nxt : edges[pos])\n        {\n            if (nxt != pre)\n            {\n                dfs(nxt, pos, depth + 1);\n            }\n        }\n    }\n\n    void init(int root_idx, int V, const T &edges)\n    {\n        this->depths.resize(V);\n        this->edges = edges;\n        for (int i = 0; i < MAX_LOG_V; i++)\n        {\n            parents[i].resize(V);\n        }\n        dfs(root_idx, NONE_NODE, 0);\n        for (int k = 0; k + 1 < MAX_LOG_V; k++)\n        {\n            for (int v = 0; v < V; v++)\n            {\n                if (parents[k][v] == NONE_NODE)\n                {\n                    parents[k + 1][v] = NONE_NODE;\n                }\n                else\n                {\n                    parents[k + 1][v] = parents[k][parents[k][v]];\n                }\n            }\n        }\n    }\n    //O(logN)\n    int lca(int u, int v)\n    {\n\n        if (depths[u] > depths[v])\n        {\n            swap(u, v);\n        }\n        \n        //follow parents by same level.\n        for (int k = 0; k < MAX_LOG_V; k++)\n        {\n            int diff = depths[v] - depths[u];\n            if ((diff >> k) & 1)\n            {\n                v = parents[k][v];\n                // cerr << \"depth = \" << depths[v] << endl;\n            }\n        }\n        if (u == v)\n        {\n            return u;\n        }\n\n        //binary search to find lcm(u, v)\n        for (int k = MAX_LOG_V - 1; k >= 0; k--)\n        {\n            if (parents[k][u] != parents[k][v])\n            {\n                u = parents[k][u];\n                v = parents[k][v];\n            }\n        }\n        return parents[0][v];\n    }\n};\nint main()\n{\n    edges.resize(MAX_N);\n    cin >> N;\n\n    for (int i = 0; i < N; i++)\n    {\n        int K;\n        cin >> K;\n        for (int k = 0; k < K; k++)\n        {\n            int c;\n            cin >> c;\n            edges[i].push_back(c);\n            edges[c].push_back(i);\n        }\n    }\n\n    LowestCommonAncestor<vector<vector<int>>> lca;\n    lca.init(0, N, edges);\n    cin >> Q;\n    for (int i = 0; i < Q; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        int res = lca.lca(u, v);\n        cout << res << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n\nclass SparseTable {\n  private:\n\ttypedef pair<size_t, size_t> Pair;\n\tvector<vector<Pair> > table;\n\n  public:\n\tvoid Setup (const vector<size_t> &sequence) {\n\t\tconst size_t length = sequence.size();\n\t\tconst size_t height = static_cast<size_t>(log2(sequence.size())) + 1;\n\t\ttable.resize(height);\n\n\t\tfor (size_t i = 0; i < length; i ++) {\n\t\t\ttable[0].push_back(make_pair(sequence[i], i));\n\t\t}\n\n\t\tfor (size_t i = 1; i < height; i ++) {\n\t\t\tconst size_t currentLength = length - pow(2, i) + 1;\n\t\t\ttable[i].resize(currentLength);\n\n\t\t\tfor (size_t j = 0; j < currentLength; j ++) {\n\t\t\t\ttable[i][j] = min<Pair>(table[i - 1][j], table[i - 1][j + pow(2, i - 1)]);\n\t\t\t\t\t\t\t}\n\t\t}\n\t}\n\n\tPair RangeMinimumQuery (const size_t left, const size_t right) {\n\t\tconst size_t length = right - left + 1;\n\t\tconst size_t power = static_cast<size_t>(log2(length));\n\t\tconst size_t flooredLength = pow(2, power);\n\n\t\tconst Pair leftValue = table[power][left];\n\t\tconst size_t padding = length - flooredLength;\n\t\tconst Pair rightValue = table[power][left + padding];\n\n\t\treturn min<Pair>(leftValue, rightValue);\n\t}\n};\n\nclass Tree {\n\tprivate:\n\t\tvector<vector<size_t> > children;\n\t\tvector<size_t> depthList;\n\t\tvector<size_t> verticesList;\n\t\tvector<size_t> indexes;\n\t\tSparseTable sparseTable;\n\t\tbool locked;\n\n\t\tvoid DFS (const size_t &vertex = 0, const size_t &depth = 0) {\n\t\t\tdepthList.push_back(depth);\n\t\t\tverticesList.push_back(vertex);\n\t\t\tindexes[vertex] = verticesList.size() - 1;\n\n\t\t\tfor (const size_t &child: children[vertex]) {\n\t\t\t\tDFS(child, depth + 1);\n\t\t\t\tdepthList.push_back(depth);\n\t\t\t\tverticesList.push_back(vertex);\n\t\t\t\tindexes[vertex] = verticesList.size() - 1;\n\t\t\t}\n\t\t}\n\n\tpublic:\n\t\tTree (const size_t &verticesCount) {\n\t\t\tchildren.resize(verticesCount);\n\t\t\tdepthList.resize(0);\n\t\t\tverticesList.resize(0);\n\t\t\tindexes.resize(verticesCount);\n\t\t\tlocked = false;\n\t\t}\n\n\t\tvoid addEdge (const size_t &parent, const size_t &child) {\n\t\t\tif (locked)\n\t\t\t\treturn;\n\n\t\t\tchildren[parent].push_back(child);\n\t\t}\n\n\t\tvoid lockTreeAndStartProcessingQueries () {\n\t\t\tif (locked)\n\t\t\t\treturn;\n\n\t\t\tlocked = true;\n\t\t\tDFS();\n\t\t\tsparseTable.Setup(depthList);\n\t\t}\n\n\t\tsize_t leastCommonAncestor (const size_t &firstVertex, const size_t &secondVertex) {\n\t\t\tif (!locked)\n\t\t\t\treturn -1;\n\n\t\t\tconst size_t firstIndex = indexes[firstVertex];\n\t\t\tconst size_t secondIndex = indexes[secondVertex];\n\t\t\tconst size_t minIndex = min<size_t>(firstIndex, secondIndex);\n\t\t\tconst size_t maxIndex = max<size_t>(firstIndex, secondIndex);\n\t\t\tconst size_t index = sparseTable.RangeMinimumQuery(minIndex, maxIndex).second;\n\t\t\tconst size_t vertex = verticesList[index];\n\t\t\treturn vertex;\n\t\t}\n};\n\n\n\nint main () {\n\tsize_t verticesCount;\n\tcin >> verticesCount;\n\n\t// Build tree:\n\tTree tree(verticesCount);\n\n\tfor (size_t parent = 0; parent < verticesCount; parent ++) {\n\t\tsize_t count;\n\t\tcin >> count;\n\n\t\tfor (size_t j = 0; j < count; j ++) {\n\t\t\tsize_t child;\n\t\t\tcin >> child;\n\t\t\ttree.addEdge(parent, child);\n\t\t}\n\t}\n\n\t// Process queries:\n\tsize_t queriesCount;\n\tcin >> queriesCount;\n\n\ttree.lockTreeAndStartProcessingQueries();\n\n\t// Processing queries:\n\tfor (size_t i = 0; i < queriesCount; i ++) {\n\t\tsize_t firstVertex, secondVertex;\n\t\tcin >> firstVertex >> secondVertex;\n\t\tcout << tree.leastCommonAncestor(firstVertex, secondVertex) << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100000\n#define MAX_LOG 30\nvector<int>G[MAX];\nint depth[MAX];\nint parent[MAX_LOG][MAX];\nint root;\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0;i<G[v].size();i++){\n    if(G[v][i]!=p)dfs(G[v][i],v,d+i);\n  }\n}\nvoid init(int V){\n  //parent??¨dfs??????????????????\n  dfs(root,-1,0);\n  //parent??????????????????\n  for(int k=0;k+1<MAX_LOG;k++){\n    for(int v=0;v<V;v++){\n      if(parent[k][v]<0)parent[k+1][v]=-1;\n      else parent[k+1][v]=parent[k][parent[k][v]];\n    }\n  }\n}\nint lca(int u,int v){\n  if(depth[u]>depth[v])swap(u,v);\n  for(int k=0;k<MAX_LOG;k++){\n    if((depth[v]-depth[u])>>k&1){\n      v=parent[k][v];\n    }\n  }\n  if(u==v)return u;\n  for(int k=MAX_LOG-1;k>=0;k--){\n    if(parent[k][u]!=parent[k][v]){\n    u=parent[k][u];\n    v=parent[k][v];\n  }\n  }\n  return parent[0][u];\n}\nint main(){\n  root=0;\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    int p=0;\n    cin>>p;\n    while(p--){\n      int t;\n      cin>>t;\n      G[i].push_back(t);\n    }\n  }\n  init(n);\n  int p;\n  cin>>p;\n  while(p--){\n    int q,w;\n    cin>>q>>w;\n    cout<<lca(q,w)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nusing Weight = int;\nstruct Edge {\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (set_size(x) < set_size(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint set_size(int x) { return -parent[root(x)]; }\n};\n\n//Tarjan's off-line lowest common ancestors\nstruct Query {\n\tint u, v;\n\tQuery(int u, int v) :u(u), v(v) {}\n};\nstruct LeastCommonAncestor {\n\tvector<vector<pair<int, Query>>> query_set;\n\tGraph g;\n\tvector<int> color;\n\tvector<int> ancestor;\n\tvector<int> res;\n\tUnionFind uf;\n\tLeastCommonAncestor(const Graph &g, vector<Query> query) :g(g), color(g.size()), ancestor(g.size()), uf(g.size()), res(query.size()), query_set(g.size()) {\n\t\tint n = query.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tquery_set[query[i].u].emplace_back(i, query[i]);\n\t\t\tquery_set[query[i].v].emplace_back(i, query[i]);\n\t\t}\n\t}\n\tvoid visit(int s, int prev) {\n\t\tancestor[uf.root(s)] = s;\n\t\tfor (auto &e : g[s]) {\n\t\t\tif (e.d == prev)continue;\n\t\t\tvisit(e.d, s);\n\t\t\tuf.unite(e.s, e.d);\n\t\t\tancestor[uf.root(s)] = s;\n\t\t}\n\t\tcolor[s] = 1;\n\t\tfor (auto &p : query_set[s]) {\n\t\t\tQuery q = p.second;\n\t\t\tint w = (q.v == s ? q.u : q.u == s ? q.v : -1);\n\t\t\tif (w == -1 || !color[w])continue;\n\t\t\tres[p.first] = ancestor[uf.root(w)];\n\t\t}\n\t}\n\tvector<int> solve(int root) {\n\t\tint n = g.size();\n\t\tUnionFind uf(n);\n\t\tvector<int> color(n), ancestor(n);\n\t\tvisit(root, -1);\n\t\treturn res;\n\t}\n\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tGraph g(n);\n\trep(i, 0, n) {\n\t\tint k; cin >> k;\n\t\trep(j, 0, k) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(i, c);\n\t\t\tg[c].emplace_back(c, i);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tvector<Query> query;\n\trep(i, 0, q) {\n\t\tint u, v; cin >> u >> v;\n\t\tquery.emplace_back(u, v);\n\t}\n\tLeastCommonAncestor lca(g, query);\n\tvector<int> res = lca.solve(0);\n\tfor (auto &e : res)\n\t\tcout << e << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\nusing namespace std;\n\nint Count;\nvoid dfs(int n,int dep,vector<vector<int>>& T,vector<P>& ET,vector<bool>& f,vector<int>& index) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tindex[n] = Count; Count++;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1, T, ET, f,index);\n\t\tET.emplace_back(make_pair(dep,n));\n\t\tCount++;\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<int> index(n);\n\tvector<bool> f(n,false);\n\tvector<vector<int>> T(n);\n\tvector<P> ET;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\n\tdfs(0,0, T, ET, f,index);\n\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tvector<P>::iterator minIt;\n\t\tif (index[u] < index[v]) { minIt = min_element(ET.begin() + index[u], ET.begin() + index[v]); }\n\t\telse { minIt = min_element(ET.begin() + index[v], ET.begin() + index[u]); }\n\t\tauto minIndex = distance(ET.begin(), minIt);\n\t\tcout << ET[minIndex].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> > t)\n    :tree(t),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int nmax=100010;\n\nvector<int> graph[nmax];\nint parent[nmax][20]; // all is -1\nint depth[nmax];\n\nvoid dfs(int v,int p,int d){\n\tparent[v][0]=p;\n\tdepth[v]=d;\n\tfor(auto &v2:graph[v]) if(v2!=p) dfs(v2,v,d+1);\n}\n\nint lca(int u,int v){\n\tif(depth[u] < depth[v]) swap(u,v);\n\tfor(int i=19;i>=0;--i) if((depth[u]-depth[v])>>i&1) u=parent[u][i];\n\tif(u==v) return u;\n\tfor(int i=19;i>=0;--i){\n\t\tif(parent[u][i]!=parent[v][i]){\n\t\t\tu=parent[u][i];\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\treturn parent[u][0];\n}\n\nint main(void){\n\tint n; cin >> n;\n\trep(i,n){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint v; cin >> v;\n\t\t\tgraph[i].push_back(v);\n\t\t}\n\t}\n\n\t// rep(i,n)rep(j,20) parent[i][j]=-1;\n\tdfs(0,-1,0);\n\trep(j,19)rep(i,n){\n\t\tif(parent[i][j]==-1)\n\t\t\tparent[i][j+1]=-1;\n\t\telse\n\t\t\tparent[i][j+1]=parent[parent[i][j]][j];\n\t}\n\n\tint q; cin >> q;\n\trep(i,q){\n\t\tint u,v; cin >> u >> v;\n\t\tcout << lca(u,v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(const vector<vector<int> > &t)\n    :tree(t),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n  int ParIdx, ParDepth, Deep; // Deep: HeavyEdge?????§?????±???\n  int Size;\n};\ntypedef vector< vector< int > > Graph;\n\nint N, Q;\nGraph graph;\nint treesz[100000], sz;\nNode nodes[100000];\nvector< int > Nodes[100000];\nint nowtreeIdx[100000], nowtreeDepth[100000]; \n\nint sizeDFS(int idx, int prev) {\n  treesz[idx] = 1;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) treesz[idx] += sizeDFS(graph[idx][i], idx);\n  }\n  return(treesz[idx]);\n}\nvoid makeDFS(int idx, int prev, int treeIdx, int treeDepth, int ParDepth) {\n  nodes[treeIdx].Size++;\n  Nodes[treeIdx].push_back(idx);\n  nowtreeIdx[idx] = treeIdx;\n  nowtreeDepth[idx] = treeDepth;\n  int ret = 0;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) ret = max(ret, treesz[graph[idx][i]]);\n  }\n  bool done = false;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) {\n      if(treesz[graph[idx][i]] == ret && !done++) {\n        makeDFS(graph[idx][i], idx, treeIdx, treeDepth + 1, ParDepth);\n      } else {\n        nodes[sz++] = (Node){ treeIdx, treeDepth, ParDepth + 1, 0};\n        makeDFS(graph[idx][i], idx, sz - 1, 0, ParDepth + 1);\n      }\n    }\n  }\n}\nvoid HL() { // ??????????§£\n  sizeDFS(0, -1);\n  sz = 0;\n  nodes[sz++] = (Node){ -1, -1, 0, 0};\n  makeDFS(0, -1, 0, 0, 0);\n}\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  graph.resize(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      graph[i].push_back(c);\n    }\n  }\n  HL();\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n\n    int TreeIdxA = nowtreeIdx[u], TreeDepthA = nowtreeDepth[u];\n    int TreeIdxB = nowtreeIdx[v], TreeDepthB = nowtreeDepth[v];\n    while(TreeIdxA != TreeIdxB) {\n      if(nodes[TreeIdxA].Deep > nodes[TreeIdxB].Deep) {\n        TreeDepthA = nodes[TreeIdxA].ParDepth;\n        TreeIdxA   = nodes[TreeIdxA].ParIdx;\n      } else {\n        TreeDepthB = nodes[TreeIdxB].ParDepth;\n        TreeIdxB   = nodes[TreeIdxB].ParIdx;\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    printf(\"%d\\n\", Nodes[TreeIdxA][TreeDepthA]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src_, int dst_, Weight weight_) :\n        src(src_), dst(dst_), weight(weight_) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint const MAX_V = 1000010;\n\ntypedef int dat_t;\ndat_t const inf = (1LL<<31)-1;\ndat_t const init = (1LL<<31)-1;\nstruct segment_tree {\n    vector<pair<dat_t,int>> dat;\n    int n;\n    segment_tree(int n_){\n        n = 1;\n        while(n < n_) n<<=1;\n        dat.resize(n*2);\n        for(int i=n; i<n+n; i++){\n            dat[i] = make_pair(init,i); // -infをdat[i]にするとvectorからのコンストラクタになる\n        }\n        for(int i=n-1; i>=1; i--){\n            dat[i] = min(dat[i<<1], dat[i<<1|1]);\n        }\n    }\n    // bottom-up\n    void set(int k, dat_t x){\n        int i = n+k; // leaf\n        dat[i] = make_pair(x,k);\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i], dat[i^1]);\n            i>>=1;\n        }\n    }\n    // top-down\n    pair<dat_t,int> get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return make_pair(inf,0);\n        if(a <= l && r <= b) return dat[k];\n        pair<dat_t,int> v1 = get(a,b,k<<1,l,(l+r)/2);\n        pair<dat_t,int> v2 = get(a,b,k<<1|1,(l+r)/2,r);\n        return min(v1,v2);\n    }\n    pair<dat_t,int> get(int a, int b){\n        return get(a,b,1,0,n);\n    }\n};\n\nstruct LowestCommonAncestor {\n    int n;\n    Graph g;\n    vector<int> visit_ord; // DFSでの訪問順に埋めていく\n    vector<int> depth; // 根からの深さ\n    vector<int> id; // 各頂点がeに初めて登場するインデックス\n    segment_tree * rmq;\n    LowestCommonAncestor(int n_)\n        : n(n_), g(n), visit_ord(n*2), depth(n*2), id(n), rmq(nullptr) {\n    }\n    void add_edge(int a, int b){\n        g[a].eb(a,b,0);\n    }\n    void compile(int root = 0){\n        int k = 0;\n        dfs(root,-1,0,k);\n        rmq = new segment_tree(k);\n        for(int i=0;i<k;i++){\n            rmq->set(i,depth[i]);\n        }\n    }\n    int ask(int u, int v){\n        int a = id[u], b = id[v];\n        return visit_ord[rmq->get(min(a,b), max(a,b)+1).second];\n    }\n    void dfs(int v, int p, int d, int & k){\n        id[v] = k;\n        visit_ord[k] = v;\n        depth[k] = d;\n        k++;\n        for(auto & e : g[v]){\n            if(e.dst != p){\n                dump(e.src, e.dst);\n                dfs(e.dst, v, d+1, k);\n                visit_ord[k] = v;\n                depth[k] = d;\n                k++;\n            }\n        }\n    }\n\n};\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k; cin >> k;\n        for(int j=0;j<k;j++){\n            int to; cin >> to;\n            g.add_edge(i,to);\n            g.add_edge(to,i);\n        }\n    }\n    g.compile();\n    int q;\n    cin >> q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin >> u >> v;\n        cout << g.ask(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 1 << 17;\nconst int MAX_N = 1 << 18;\nconst int def = 1 << 25;\n\ntypedef pair<int, int> Node;\nstruct MinSegTree {\n\tint n;\n\tNode node[2 * MAX_N - 1];\n\tint dat[2 * MAX_N - 1];\n\tint minIdx[2 * MAX_N - 1];\n\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) node[i] = make_pair(def, def);\n\t}\n\n\tNode merge(Node l, Node r) {\n\t\tif(l.first <= r.first) return l;\n\t\treturn r;\n\t}\n\n\tvoid update(int k, int a) {\n\t\tk += n - 1;\n\t\tnode[k] = make_pair(a, k - (n - 1));\n\t\tdat[k] = a;\n\t\tminIdx[k] = k - (n - 1);\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\n\tNode query(int a, int b) { return query(a, b, 0, 0, n); }\n\n\tNode query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return make_pair(def, def);\n\t\tif(a <= l && r <= b) return node[k];\n\t\tNode vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tNode vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn merge(vl, vr);\n\t}\n\n\tvoid show() {\n\t\tfor(int i = 0; i < n; i++) cout << dat[i + n - 1] << \" \";\n\t\tcout << endl;\n\t}\n};\n\nMinSegTree st;\n\nvector<int> G[MAX_V];\nint root;\n\nint vs[MAX_V * 2 - 1];\nint depth[MAX_V * 2 - 1];\nint id[MAX_V];\n\nvoid dfs(int v, int p, int d, int& k) {\n\tid[v] = k;\n\tvs[k] = v;\n\tdepth[k++] = d;\n\tfor(int i = 0; i < G[v].size(); i++) {\n\t\tif(G[v][i] != p) {\n\t\t\tdfs(G[v][i], v, d + 1, k);\n\t\t\tvs[k] = v;\n\t\t\tdepth[k++] = d;\n\t\t}\n\t}\n}\n\nvoid init(int V) {\n\tint k = 0;\n\tdfs(root, -1, 0, k);\n\tst.init(2 * V - 1);\n\tfor(int i = 0; i < 2 * V - 1; i++) {\n\t\tst.update(i, depth[i]);\n\t}\n}\n\nint lca(int u, int v) {\n\tint l = min(id[u], id[v]);\n\tint r = max(id[u], id[v]);\n\treturn vs[st.query(l, r + 1).second];\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\n\n\tfor(int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\twhile(k--) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\n\tinit(n);\n\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca(u, v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cwchar>\n#include <cwctype>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <codecvt>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <shared_mutex>\n\n#ifdef DEBUG\n#include \"libs/debug.cpp\"\n#define DEBUG 1\n#else\n#define DEBUG 0\n#endif\n\n#define rep(i, n) repr((i), 0, (n))\n#define repr(i, a, t) reps((i), (a), (t), 1)\n#define reps(i, a, t, s) for (long long (i) = (a); (i) < (long long)(t); (i) += (s))\n#define rrep(i, n) rrepr((i), (n), 0)\n#define rrepr(i, a, t) rreps((i), (a), (t), 1)\n#define rreps(i, a, t, s) for (long long (i) = (a) - 1; (i) >= (long long)(t); (i) -= (s))\n#define each(v, c) for (auto &&(v) : (c))\n#define all(c) (c).begin(), (c).end()\n\nusing namespace std;\n\n// コンテナのメンバ関数を使わないと O(N) おぼえたらけす\ntemplate<typename T>\ntypename set<T>::iterator lower_bound(typename set<T>::iterator l, typename set<T>::iterator r, const T &v);\ntemplate<typename T>\ntypename set<T>::iterator upper_bound(typename set<T>::iterator l, typename set<T>::iterator r, const T &v);\ntemplate<typename S, typename T>\ntypename map<S, T>::iterator lower_bound(typename map<S, T>::iterator l, typename map<S, T>::iterator r, const T &v);\ntemplate<typename S, typename T>\ntypename map<S, T>::iterator upper_bound(typename map<S, T>::iterator l, typename map<S, T>::iterator r, const T &v);\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\n\n/**\n * LCA ダブリング版\n * 構築 O(NlogN)、クエリ O(logN)\n */\nclass LCA {\n private:\n  vector<vector<ll>> graph;\n  ll root;\n  // 何回ダブリングするか\n  ll height;\n  // depths[v]: v の root からの距離\n  vector<ll> depths;\n  // parents[k][v]: 親に 2^k たどった頂点\n  vector<vector<ll>> parents;\n\n  void _init() {\n    vector<bool> seen(graph.size(), false);\n    _init_dfs(root, -1, 0, seen);\n\n    // parents を初期化\n    rep (k, height - 1) {\n      rep (v, graph.size()) {\n        if (parents[k][v] < 0) {\n          // 親がなければ -1\n          parents[k + 1][v] = -1;\n        } else {\n          parents[k + 1][v] = parents[k][parents[k][v]];\n        }\n      }\n    }\n  }\n\n  // depths と parents[0] を初期化\n  void _init_dfs(ll v, ll p, ll d, vector<bool> &seen) {\n    parents[0][v] = p;\n    depths[v] = d;\n    seen[v] = true;\n    each (u, graph[v]) {\n      if (!seen[u]) {\n        _init_dfs(u, v, d + 1, seen);\n      }\n    }\n  }\n\n public:\n  LCA(const vector<vector<ll>> &graph, ll root) : graph(graph), root(root) {\n    height = 0;\n    ll sz = graph.size();\n    while (sz > 0) {\n      sz /= 2;\n      height += 1;\n    }\n\n    depths = vector<ll>(graph.size(), -1);\n    parents = vector<vector<ll>>(height, vector<ll>(graph.size(), -1));\n\n    _init();\n  };\n\n  /**\n   * v と u の LCA\n   * @param v\n   * @param u\n   */\n  auto lca(ll v, ll u) -> ll {\n    if (depths[u] > depths[v]) {\n      swap(v, u);\n    }\n    rep (k, height) {\n      if ((depths[v] - depths[u]) >> k & 1) {\n        v = parents[k][v];\n      }\n    }\n    if (v == u) return v;\n\n    rrep (k, height) {\n      if (parents[k][v] != parents[k][u]) {\n        v = parents[k][v];\n        u = parents[k][u];\n      }\n    }\n    return parents[0][v];\n  }\n\n  /**\n   * 2 頂点間の距離\n   * @param v\n   * @param u\n   */\n  ll distance(ll v, ll u) {\n    return depths[v] + depths[u] - depths[lca(v, u)] * 2;\n  }\n};\n\nint main() {\n  cout << fixed << setprecision(10);\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  std::ifstream ifs;\n  if (DEBUG) {\n    ifs.open(\"src/_in.txt\");\n    cin.rdbuf(ifs.rdbuf());\n  }\n\n  ll N;\n  cin >> N;\n  vector<vector<ll>> graph(N, vector<ll>());\n  rep (v, N) {\n    ll k;\n    cin >> k;\n    vector<ll> children;\n    rep (i, k) {\n      ll v0;\n      cin >> v0;\n      children.push_back(v0);\n    }\n    each (u, children) {\n      graph[v].push_back(u);\n      graph[u].push_back(v);\n    }\n  }\n  ll Q;\n  cin >> Q;\n  vector<tuple<ll, ll>> VU(Q);\n  rep (i, Q) {\n    cin >> get<0>(VU[i]) >> get<1>(VU[i]);\n  }\n\n  auto lca = LCA(graph, 0ll);\n\n  each (vu, VU) {\n    ll v, u;\n    tie(v, u) = vu;\n    cout << lca.lca(v, u) << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n//by NeighThorn\nusing namespace std;\nconst int maxn=100000+5;\nint n,q,hd[maxn],to[maxn*2],nxt[maxn*2],cnt,vis[maxn],fa[maxn],ta[maxn];\nstruct M{\n\tint y,ans;\n\tM(int a=0,int b=0){\n\t\ty=a,ans=b;\n\t}\n};\nstruct L{\n\tint x,y;\n}s[maxn];\nvector<M> v[maxn];\ninline int find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\t\n}\ninline void add(int x,int y){\n\tto[cnt]=y;nxt[cnt]=hd[x];hd[x]=cnt++;\t\n}\ninline void tarjan(int root){\n\tvis[root]=1;\n\tfor(int i=0;i<(int)v[root].size();i++)\n\t\tif(vis[v[root][i].y]){\n\t\t\tM tmp;tmp.y=v[root][i].y;tmp.ans=find(tmp.y);\n\t\t\tv[root][i]=tmp;\n\t\t}\n\tfor(int i=hd[root];i!=-1;i=nxt[i])\n\t\tif(!vis[to[i]])\n\t\t\ttarjan(to[i]),fa[to[i]]=root;\n}\nsigned main(void){\n\tscanf(\"%d\",&n);cnt=0;\n\tmemset(hd,-1,sizeof(hd));\n\tfor(int i=0,k;i<n;i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t\tscanf(\"%d\",&x),add(i,x),add(x,i);\n\t}scanf(\"%d\",&q);\n\tfor(int i=0;i<n;i++)\n\t\tfa[i]=i,vis[i]=0,ta[i]=0;\n\tfor(int i=1,x,y;i<=q;i++)\n\t\tscanf(\"%d%d\",&x,&y),v[x].push_back(M(y,0)),v[y].push_back(M(x,0)),s[i].x=x,s[i].y=y;\n\ttarjan(0);\n\tfor(int i=1;i<=q;i++)\n\t\tprintf(\"%d\\n\",v[s[i].x][ta[s[i].x]].ans),ta[s[i].x]++,ta[s[i].y]++;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親\n\tvector<int> sz; // 数\n\t// 初期化\n\tUF(int n):par(n),sz(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;\n\t\t}\n\t}\n\t// 木の根を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[x] += sz[y];\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int n){return sz[find(n)];}\n};\n\n//普通のLCA(UFと一緒に) \nstruct LCA\n{\n\t//隣接リスト、(相手、重み)\n\tvector<vector<pair<int,int> > > g;\n\t//親\n\tvector<vector<int> > parent;\n\t//深さ\n\tvector<int> depth;\n\tUF uf;\n\tint sz;\n\tvector<bool> inited;\n\t\t\n\tLCA(int n):g(n),parent(20,vector<int>(n)),\n\tinited(n,false),depth(n),uf(n){sz = n;}\n\t\n\t//辺の追加(点、点、重み)\n\tvoid add_edge(int u,int v,int w = 1)\n\t{\n\t\tif(uf.same(u,v))return;\n\t\tg[v].PB(MP(u,w));\n\t\tg[u].PB(MP(v,w));\n\t\tuf.unite(v,u);\n\t}\n\t\t\n\tvoid dfs(int v,int p,int d)\n\t{\n\t\tinited[v] = true;\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tREP(i,g[v].size())\n\t\t{\n\t\t\tif(g[v][i].FI != p)dfs(g[v][i].FI,v,d+1);\n\t\t}\n\t}\n\t\n\t//初期化、LCA構築(一通り辺を張ってから)\n\tvoid init()\n\t{\n\t\tREP(i,sz)if(!inited[i])dfs(uf.find(i),-1,0);\n\t\tREP(k,19)\n\t\t{\n\t\t\tREP(i,sz)\n\t\t\t{\n\t\t\t\tif(parent[k][i] < 0)parent[k+1][i] = -1;\n\t\t\t\telse parent[k+1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//LCAを求めるパート\n\tint ret_lca(int a,int b)\n\t{\n\t\t\n\t\tif(!uf.same(a,b))return -1;\n\t\t\n\t\tif(depth[a] > depth[b])swap(a,b);\n\t\tREP(k,20)\n\t\t{\n\t\t\tif((depth[b] - depth[a])>>k&1)b = parent[k][b];\n\t\t}\n\t\tif(a == b)return a;\n\t\t\n\t\tfor(int k = 19;k >= 0;k--)\n\t\t{\n\t\t\tif(parent[k][a] != parent[k][b])\n\t\t\t{\n\t\t\t\ta = parent[k][a];\n\t\t\t\tb = parent[k][b];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][a];\n\t}\n\t\n};\n\n\nint main()\n{\n\tint n;cin >> n;\n\tLCA lca(n);\n\tREP(i,n)\n\t{\n\t\tint num;cin >> num;\n\t\tREP(j,num)\n\t\t{\n\t\t\tint a;cin >> a;\n\t\t\tlca.add_edge(i,a);\n\t\t}\n\t}\n\t\n\tlca.init();\n\t\n\tint q;cin >> q;\n\tREP(i,q)\n\t{\n\t\tint a,b;cin >> a >> b;\n\t\tcout << lca.ret_lca(a,b) << endl;\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\n\nstruct LowestCommonAncestor{\n    int n,h;\n    vector<vector<int>> G,par;\n    vector<int> dep;\n    LowestCommonAncestor(int n):n(n),G(n),dep(n){\n        h=1;\n        while((1<<h)<=n) ++h;\n        par.assign(h,vector<int>(n,-1));\n    }\n    void add_edge(int u,int v){\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    void dfs(int v,int p,int d){\n        par[0][v]=p;\n        dep[v]=d;\n        for (int u:G[v]){\n            if (u!=p) dfs(u,v,d+1);\n        }\n    }\n    void build(int r=0){\n        dfs(r,-1,0);\n        for (int k=0;k<h-1;++k) for (int v=0;v<n;++v){\n            if (par[k][v]>=0) par[k+1][v]=par[k][par[k][v]];\n        }\n    }\n    int lca(int u,int v){\n        if (dep[u]>dep[v]) swap(u,v);\n        for (int k=0;k<h;++k){\n            if ((dep[v]-dep[u])&1<<k) v=par[k][v];\n        }\n        if (u==v) return u;\n        for (int k=h-1;k>=0;--k){\n            if (par[k][u]!=par[k][v]) u=par[k][u],v=par[k][v];\n        }\n        return par[0][u];\n    }\n    int distance(int u,int v){\n        return dep[u]+dep[v]-dep[lca(u,v)]*2;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    LowestCommonAncestor LCA(n);\n    rep(i,n){\n        int k; cin >> k;\n        rep(j,k){\n            int c; cin >> c;\n            LCA.add_edge(i,c);\n        }\n    }\n    LCA.build();\n    int q; cin >> q;\n    rep(i,q){\n        int u,v; cin >> u >> v;\n        cout << LCA.lca(u,v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// \n// Least common ancestor by heavy-light decomposition\n//\n// Description:\n//   For a rooted tree T, LCA(u,v) is a vertex u\n//   that is the deepest node that is a common ancestor of u and v.\n//\n// Algorithm:\n//   A heavy-light decomposition finds a partition of a tree into\n//   a set of paths that is recursively defined as follows:\n//   1) root is contained in a \"heavy\" path that spans root-to-child\n//   2) other childs are linked by \"light\" edges and the subtrees are\n//      recursively decomposed by the heavy-light decomposition.\n//      Here, all subtrees have fewer nodes than the \"heavy\" path.\n//\n//   If two nodes u and v are located in the same heavy-path, LCA is\n//   immediately obtained (shallower node is the LCA). Otherwise,\n//   climbing light links until these are located in the same heavy-path.\n//   By construction, only O(log n) light-link-climb is enough to reach\n//   the root of the tree; thus it gives O(log n) algorithm.\n//\n// Complexity:\n//   O(n) for preprocessing,\n//   O(log n) for query\n//\n// Verified:\n//   AOJ GRL_5C\n//\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\n\nstruct tree {\n  int n;\n  vector<vector<int>> adj;\n  tree(int n) : n(n), adj(n) { }\n  void add_edge(int s, int t) {\n    adj[s].push_back(t);\n    adj[t].push_back(s);\n  }\n  vector<int> size, depth, head, parent;\n  void rootify(int r) {\n    size = depth = parent = head = vector<int>(n, -1);\n    function<int (int,int)> dfs = [&](int u, int p) {\n      parent[u] = p;\n      depth[u] = depth[p]+1;\n      for (int v: adj[u]) \n        if (v != p) size[u] += dfs(v, u);\n      return ++size[u];\n    }; dfs(r, r);\n    function<void (int,int)> dec = [&](int u, int s) {\n      head[u] = s;\n      int z = -1;\n      for (int v: adj[u]) \n        if (head[v] < 0 && (z < 0 || size[z] < size[v])) z = v;\n      for (int v: adj[u]) \n        if (head[v] < 0) dec(v, v == z ? s : v);\n    }; dec(r, r);\n  }\n  int lca(int u, int v) {\n    while (head[u] != head[v]) \n      if (depth[head[u]] < depth[head[v]]) v = parent[head[v]];\n      else                                 u = parent[head[u]];\n    return depth[u] < depth[v] ? u : v;\n  }\n};\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  tree T(n);\n  for (int u = 0; u < n ; ++u) {\n    int k; \n    scanf(\"%d\", &k);\n    for (int j = 0; j < k; ++j) {\n      int v;\n      scanf(\"%d\", &v);\n      T.add_edge(u, v);\n    }\n  }\n  T.rootify(0);\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", T.lca(u, v));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 200;\nint color[100010],  par[100010], depth[100010];\nint colorTop[100010/B];\nint goUp[100010/B];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = 0, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    assert(q.size() == 0);\n    rep(i,n) vis[i] = 0;\n    int c = 0;\n    rep(i,n){\n        if(vis[i]) continue;\n        q.push(tord[i]);\n        colorTop[c] = i;\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[i];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree{\nprivate:\n    int n,sz; vector<V> node; vector<int> node_id;\npublic:\n    void resize(vector<V> v){\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1),node_id.resize(2*n-1);\n        rep(i,sz){\n            node[i+n-1] = v[i];\n            node_id[i+n-1] = i;\n        }\n        for(int i=n-2; i>=0; i--){\n            if(node[2*i+1] > node[2*i+2]){\n                node[i] = node[2*i+2];\n                node_id[i] = node_id[2*i+2];\n            }else{\n                node[i] = node[2*i+1];\n                node_id[i] = node_id[2*i+1];\n            }\n        }\n    }\n    void update(int k,int a){\n    \tk += n-1;\n    \tnode[k] = a,node_id[k] = k-(n-1);\n    \twhile(k>0){\n    \t\tk = (k-1)/2;\n    \t\tif(node[2*k+1] < node[2*k+2]){\n                node[k] = node[2*k+1],node_id[k] = node_id[2*k+1];\n            }else{\n                node[k] = node[2*k+2],node_id[k] = node_id[2*k+2];\n            }\n    \t}\n    }\n    pair<V,int> query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r < 0) r = n;\n    \tif(r <= a || b <= l) return pair<V,int>(INT_MAX,-1);\n    \tif(a <= l && r <= b){\n    \t\treturn pair<V,int>(node[k],node_id[k]);\n    \t}else{\n    \t\tpair<V,int> vl = query(a,b,2*k+1,l,(l+r)/2);\n    \t\tpair<V,int> vr = query(a,b,2*k+2,(l+r)/2,r);\n    \t\treturn min(vl,vr);\n    \t}\n    }\n    void print(){\n        rep(i,sz){\n            pair<V,int> p;\n            p = query(i,i+1);\n            cout << \"st[\" << i << \"]: \" << p.fi << \" \" << p.se << endl;\n        }\n    }\n};\n\nclass LCA{\npublic:\n    vector<int> ord,depth,id;\n    vector<vector<int> > G;\n    segtree<int> st;\n    int V;\n    LCA(int node_size){\n        V = node_size;\n        G.resize(V),depth.resize(V),id.resize(V,-1);\n    }\n    void add_edge(int from,int to){\n        G[from].push_back(to),G[to].push_back(from);\n    }\n    void dfs(int u,int p,int k){\n        id[u] = (int)ord.size();\n        ord.push_back(u);\n        depth[u] = k;\n        rep(i,G[u].size()){\n            if(G[u][i] != p){\n                dfs(G[u][i],u,k+1);\n                ord.push_back(u);\n            }\n        }\n    }\n    void build(){\n        rep(i,V){\n            if(id[i] < 0){\n                dfs(i,-1,0);\n            }\n        }\n        vector<int> stvec((int)ord.size());\n    \trep(i,ord.size()){\n    \t\tstvec[i] = depth[ord[i]];\n    \t}\n        st.resize(stvec);\n    }\n    int solve(int u,int v){\n        return ord[st.query(min(id[u],id[v]),max(id[u],id[v])+1).second];\n    }\n    int dist(int u,int v){\n        int lca = solve(u,v);\n        return depth[u] + depth[v] - 2*depth[lca];\n    }\n};\n\nvector<int> G[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\tLCA lca(n);\n\trep(i,n){\n\t\tint cnt;\n\t\tcin >> cnt;\n\t\trep(j,cnt){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tlca.add_edge(i,a);\n\t\t}\n\t}\n\tlca.build();\n\tint q;\n\tcin >> q;\n\trep(i,q){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcout << lca.solve(a,b) << \"\\n\";\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 20;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(!vis[c]){\n                q.push(c);\n                par[c] = v;\n                depth[c] = depth[v] + 1;\n            }\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(!vis[c]) q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        // assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdint>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::uint_fast32_t;\n\nprivate:\n\tstd::vector<std::pair<bool, size_type>> tree;\n\npublic:\n\tUnionFind(const size_type size) : tree(size, std::make_pair(1, 1)) {}\n\tsize_type find(const size_type x) {\n\t\tassert(x < size());\n\t\tif (tree[x].first)\n\t\t\treturn x;\n\t\treturn tree[x].second = find(tree[x].second);\n\t}\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (tree[x].second < tree[y].second)\n\t\t\tstd::swap(x, y);\n\t\ttree[x].second += tree[y].second;\n\t\ttree[y] = std::make_pair(0, x);\n\t\treturn true;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn tree[find(x)].second;\n\t}\n\tsize_type size() const noexcept { return tree.size(); }\n\tbool empty() const noexcept { return tree.empty(); }\n};\n\n#include <cstddef>\n#include <functional>\n#include <utility>\n#include <vector>\n\ntemplate <class GraphContainer, class UnionFindDataStructure>\nstd::vector<typename GraphContainer::size_type> TarjansOfflineLCA(\n\tconst GraphContainer &graph, const typename GraphContainer::size_type root,\n\tconst std::vector<std::pair<typename GraphContainer::size_type,\n\ttypename GraphContainer::size_type>> &queries) {\n\tusing size_type = typename GraphContainer::size_type;\n\tconst size_type size_ = graph.size();\n\tUnionFindDataStructure uft(size_);\n\tstd::vector<size_type> ret(queries.size(), size_), anc(size_);\n\tstd::vector<std::vector<std::size_t>> qset(size_);\n\n\tfor (std::size_t i = 0; i < queries.size(); ++i) {\n\t\tqset[queries[i].first].emplace_back(i);\n\t\tqset[queries[i].second].emplace_back(i);\n\t}\n\n\tstd::function<void(const size_type, const size_type)> dfs =\n\t\t[&](const size_type v, const size_type prev) {\n\t\tanc[v] = v;\n\t\tfor (const auto &e : graph[v]) {\n\t\t\tif (e.to != prev) {\n\t\t\t\tdfs(e.to, v);\n\t\t\t\tuft.unite(v, e.to);\n\t\t\t\tanc[uft.find(v)] = v;\n\t\t\t}\n\t\t}\n\t\tfor (const auto e : qset[v])\n\t\t\tif (ret[e] == size_)\n\t\t\t\tret[e] = v;\n\t\t\telse\n\t\t\t\tret[e] = anc[uft.find(ret[e])];\n\t};\n\tdfs(root, size_);\n\treturn ret;\n}\n\n\n#include <cstddef>\n#include <vector>\n\nstruct edge {\n\tusing cost_type = int;\n\tusing size_type = std::size_t;\n\n\tstd::size_t to;\n\tedge(size_type t):to(t){}\n};\n\ntemplate <class Edge> using Graph = std::vector<std::vector<Edge>>;\n\n#include<cstdio>\nint main() {\n\tusing uint = unsigned int;\n\tuint n;\n\tscanf(\"%u\", &n);\n\tGraph<edge> g(n);\n\tfor (uint i = 0;i < n;++i) {\n\t\tuint k, c;\n\t\tscanf(\"%u\", &k);\n\t\twhile (k--) {\n\t\t\tscanf(\"%u\", &c);\n\t\t\tg[i].emplace_back(c);\n\t\t}\n\t}\n\tuint q;\n\tscanf(\"%u\", &q);\n\tusing S = typename Graph<edge>::size_type;\n\tstd::vector<std::pair<S, S>> Q;\n\tQ.reserve(q);\n\twhile (q--) {\n\t\tuint u, v;\n\t\tscanf(\"%u%u\", &u, &v);\n\t\tQ.emplace_back(u, v);\n\t}\n\tconst auto &&ans=TarjansOfflineLCA<Graph<edge>, UnionFind>(g, 0, Q);\n\tfor (const auto e : ans)\n\t\tprintf(\"%u\\n\", e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_V 101000\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n//RMQ\n\ntemplate<class T>\nclass RMQ{\nprivate:\n  int n;\n  T dat[2*MAX_V-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = ii(IINF,IINF);//ii(depth,index)\n  }\n \n  // k番めの値(0-indexed)をaに変更\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = (dat[k*2+1].first>dat[k*2+2].first?dat[k*2+2]:dat[k*2+1]);\n    }\n  }\n \n  T _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return ii(IINF,-1);\n    else if(a<=l && r<=b)return dat[k];\n     \n      T vl = _query(a,b,k*2+1,l,(l+r)/2);\n      T vr = _query(a,b,k*2+2,(l+r)/2,r);\n\n      return min(vl,vr);\n  }\n\n//nの範囲でミスしないように極力こっちを利用 \n  T query(int a,int b){\n    return _query(a,b,0,0,n);\n  }\n};\n\n//\n\nint V,query;\nvector<int> G[MAX_V];\nint root;\n\nint vs[MAX_V*2-1];\nint depth[MAX_V*2-1];\nint id[MAX_V];\n\nvoid dfs(int v,int p,int d,int &k){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  for(int i=0;i<G[v].size();i++){\n    if(G[v][i] != p){\n      dfs(G[v][i],v,d+1,k);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid init(RMQ<ii> &rmq){\n  int k = 0;\n  dfs(root,-1,0,k);\n\n  rmq.init(k+1);  \n  rep(i,k)rmq.update(i,ii(depth[i],vs[i]));\n}\n\nint lca(int u,int v,RMQ<ii> &rmq){\n  return rmq.query(min(id[u],id[v]),max(id[u],id[v])+1).second;\n}\n\n\nint main(){\n  int n;\n  cin >> n;\n  V = n;\n  rep(i,V){\n    int k,c;\n    cin >> k;\n    rep(j,k){\n      cin >> c;\n      G[i].push_back(c);\n      G[c].push_back(i);\n    }\n  }\n\n  RMQ<ii> rmq;\n  init(rmq);\n  int q,u,v;\n  cin >> q;\n  rep(i,q){\n    cin >> u >> v;\n    cout << lca(u,v,rmq) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\nstruct LCA {\n  const vector<vector<int>>& g;\n  vector<vector<int>> parent;\n  vector<int> depth;\n  int k;\n\n  LCA(const vector<vector<int>>& g) : g(g) {}\n\n  void dfs(int v, int p, int d) {\n    parent[v][0] = p;\n    depth[v] = d;\n    for(auto to : g[v]) {\n      if(to != p) dfs(to,v,d+1);\n    }\n  }\n\n  void build() {\n    int x = 1; k = 0;\n    while(x <= g.size()) {x *= 2, k++;}\n    parent = vector<vector<int>>(g.size(),vector<int>(k));\n    depth = vector<int>(g.size());\n    dfs(0,-1,0);\n    rep(i,k-1) {\n      rep(v,g.size()) {\n        if(parent[v][i] < 0) parent[v][i+1] = -1;\n        else parent[v][i+1] = parent[parent[v][i]][i];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u,v);\n    rep(i,k) {\n      if((depth[v] - depth[u]) & (1<<i)) v = parent[v][i];\n    }\n    if(u == v) return u;\n    for(int i = k-1; i >= 0; i--){\n      if(parent[u][i] != parent[v][i]) {\n        u = parent[u][i]; v = parent[v][i];\n      }\n    }\n    return parent[u][0];\n  }\n\n  int dist(int u, int v) {\n    return depth[u] + depth[v] - 2*depth[lca(u,v)];\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  rep(i,n) {\n    int k;\n    cin >> k;\n    rep(j,k) {\n      int c;\n      cin >> c;\n      g[i].push_back(c);\n      g[c].push_back(i);\n    }\n  }\n  LCA lca(g);\n  lca.build();\n  int q;\n  cin >> q;\n  vector<int> ans(q);\n  rep(i,q) {\n    int u, v;\n    cin >> u >> v;\n    ans[i] = lca.lca(u,v);\n  }\n  for(auto x : ans) cout << x << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N, Q;\nint T[MAXN], L[MAXN], P[MAXN][20];  // direct parent, depth, ancestor\nvector<int> adjList[MAXN];\n\nvoid dfs(int node = 0, int depth = 0) {\n    L[node] = depth;\n    for (int i = 0; i < adjList[node].size(); i++) {\n        int child = adjList[node][i];\n        dfs(child,depth+1);\n    }\n}\n\nint query(int u, int v) {\n    if (L[u] < L[v])\n        swap(u,v);\n\n    int LOG2;\n    for (LOG2 = 1; 1 << LOG2 <= L[u]; LOG2++); LOG2--;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (L[u] - (1 << i) >= L[v])\n            u = P[u][i];\n\n    if (u == v)\n        return u;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (P[u][i] != -1 && P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n\n    return T[u];\n}\n\nint main() {\n\n    scanf(\"%d\",&N);\n    for (int u = 0, M; u < N; u++) {\n        scanf(\"%d\",&M);\n        for (int i = 0, v; i < M; i++) {\n            scanf(\"%d\",&v);\n\n            T[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted at 0\n    dfs();\n\n    for (int i = 1; i <= N; i++)\n        P[i][0] = T[i];\n    for (int j = 1; 1 << j < N; j++)\n        for (int i = 1; i <= N; i++)\n            P[i][j] = P[P[i][j-1]][j-1];\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v; i < Q; i++) {\n        scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\", query(u,v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MON 1000000007\n#define INF (1<<29)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\nvector<Int> children[108000];\nInt parent[108000][20];\nInt dep[108000];\nInt u, v, w, n, k, c, q;\nvoid dfs_dep(Int x){\n  for(auto c:children[x]){\n    dep[c] = dep[x]+1;\n    dfs_dep(c);\n  }\n}\n\nint lca(int u, int v, int check = 19){\n  while(check >= 0 && parent[u][check] == parent[v][check])check--;\n  if(check == -1)return parent[u][0];\n  return lca(parent[u][check], parent[v][check]);\n}\n\nint ancestor(int u, int height){\n  for(int check = 19;check >= 0;check--){\n    if((1<<check) > height)continue;\n    u = parent[u][check];\n    height -= (1<<check);\n  }\n  return u;\n}\n\nint main(){\n  cin >> n;\n  for(Int i = 0;i < n;i++){\n    cin >> k;\n    for(Int j = 0;j < k;j++){\n      cin >> c;\n      children[i].push_back(c);\n      parent[c][0] = i;\n    }\n  }\n  dfs_dep(0);\n  for(int i = 1;i < 20;i++){\n    for(int j = 0;j < n;j++){\n      parent[j][i] = parent[parent[j][i-1]][i-1];\n    }\n  }\n  cin >> q;\n  while(q--){\n    cin >> u >> v;\n    if(dep[u] < dep[v])swap(u, v);\n    if(dep[u] != dep[v])u = ancestor(u, dep[u] - dep[v]);\n    if(u == v)cout << u << endl;\n    else cout << lca(u, v) << endl;\n  }  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nclass LCA {\n\tusing pii = pair<int, int>;\n\tconst int n;\n\tvector<int> depth, par, heavy, head;\n\tint dfs(int v, int prev, const graph& G) {\n\t\tpar[v] = prev;\n\t\tdepth[v] = prev != -1 ? depth[prev] + 1 : 0;\n\t\tint ma = 0, cnt = 1;\n\t\tfor (auto to : G[v]) if (to != prev) {\n\t\t\tint c = dfs(to, v, G);\n\t\t\tif (c > ma) {\n\t\t\t\tma = c;\n\t\t\t\theavy[v] = to;\n\t\t\t}\n\t\t\tcnt += c;\n\t\t}\n\t\treturn cnt;\n\t}\npublic:\n\tLCA(const graph& G, int rt = 0) : n(G.size()), depth(n), par(n), heavy(n, -1), head(n) {\n\t\tdfs(rt, -1, G);\n\t\tqueue<int> q;\n\t\tq.push(rt);\n\t\twhile (!q.empty()) {\n\t\t\tint h = q.front(); q.pop();\n\t\t\tfor (int v = h; v != -1; v = heavy[v]) {\n\t\t\t\thead[v] = h;\n\t\t\t\tfor (auto to : G[v]) if (to != par[v] && to != heavy[v]) {\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint calc(int u, int v) {\n\t\twhile (head[u] != head[v]) {\n\t\t\tif (depth[head[u]] < depth[head[v]]) v = par[head[v]];\n\t\t\telse u = par[head[u]];\n\t\t}\n\t\treturn depth[u] < depth[v] ? u : v;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph G(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tLCA lca(G);\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXV 1000000\n#define MAXLV 20\nusing namespace std;\n\nvector<int> e[MAXV];\nint n,root=0;\n\nint parent[MAXLV][MAXV];\nint depth[MAXV];\n\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0;i<e[v].size();i++){\n    if(e[v][i]!=p)dfs(e[v][i],v,d+1);\n  }\n}\n\nvoid init(){\n  dfs(root,-1,0);\n  for(int k=0;k+1<MAXLV;k++){\n    for(int v=0;v<n;v++){\n      if(parent[k][v]<0)parent[k+1][v]=-1;\n      else parent[k+1][v]=parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u,int v){\n  if(depth[u]>depth[v])swap(u,v);\n  for(int k=0;k<MAXLV;k++){\n    if((depth[v]-depth[u])>>k&1){\n      v=parent[k][v];\n    }\n  }\n  if(u==v)return u;\n  for(int k=MAXLV-1;k>=0;k--){\n    if(parent[k][u]!=parent[k][v]){\n      u=parent[k][u];\n      v=parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint main()\n{\n  int q,u,v,k,c;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>k;\n    for(int j=0;j<k;j++){\n      cin>>c;\n      e[i].push_back(c);\n    }\n  }\n  init();\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>u>>v;\n    cout<<lca(u,v)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\nconst int logn=17;\n\nint n,q,l,sec,st[maxn],ed[maxn];\nint up[maxn][logn];\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n\tst[u]=sec++;\n\tup[u][0]=p;\n\tfor (int i=1;i<=l;i++)\n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\tfor (int v:G[u])\n\t\tif (v!=p) dfs(v,u);\n\ted[u]=sec;\n}\n\nbool upper(int u,int v) {\n\treturn st[u]<st[v] && ed[u]>=ed[v];\n}\n\nint lca(int u,int v) {\n\tif (u==v) return u;\n\tif (upper(u,v)) return u;\n\tif (upper(v,u)) return v;\n\tfor (int i=l;i>=0;i--) \n\t\tif (!upper(up[u][i],v))\n\t\t\tu=up[u][i];\n\treturn up[u][0];\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i=0;i<n;i++) {\n\t\tint m; cin>>m;\n\t\tfor (int j=0;j<m;j++) {\n\t\t\tint v; cin>>v;\n\t\t\tG[i].pb(v);\n\t\t}\n\t}\n\twhile ((1<<l)<=n) l++;\n\tdfs(0,0);\n\tcin>>q;\n\tfor (int i=0;i<q;i++) {\n\t\tint u,v; cin>>u>>v;\n\t\tcout<<lca(u,v)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) // cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n \nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n \nclass lca {\npublic:\n  int n;\n  int log2_n;\n  vector<vector<int>> parent;\n  vector<int> depth;\n \n  lca() {}\n \n  lca(const Graph &g, int root)\n      : n(g.size()), log2_n(log2(n) + 1), parent(log2_n, vector<int>(n)),\n        depth(n) {\n    dfs(g, root, -1, 0);\n    for (int k = 0; k + 1 < log2_n; k++) {\n      for (int v = 0; v < (int)g.size(); v++) {\n        if (parent[k][v] < 0)\n          parent[k + 1][v] = -1;\n        else\n          parent[k + 1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n \n  void dfs(const Graph &g, int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (auto &e : g[v]) {\n      if (e.dst != p)\n        dfs(g, e.dst, v, d + 1);\n    }\n  }\n \n  int get(int u, int v) {\n    if (depth[u] > depth[v])\n      swap(u, v);\n    for (int k = 0; k < log2_n; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    if (u == v)\n      return u;\n    for (int k = log2_n - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n \nconst int B = 300;\n \nint N, Q;\nGraph g;\nvector<tuple<int, int, int, int>> query;\n \nint dist[100010];\nvector<pair<int, int>> add_at[100010];\nvector<int> stk;\n \nvoid make_dist(int v, int p, int s) {\n  dist[v] = s;\n  for (auto &e : g[v]) {\n    if (e.dst != p) {\n      make_dist(e.dst, v, dist[v] + e.weight);\n    }\n  }\n}\n \nvoid add_many(int v, int p) {\n  for (auto &aq : add_at[v]) {\n    int k = aq.first;\n    int x = aq.second;\n    if (k < (int)stk.size())\n      stk.rbegin()[k] += x;\n  }\n \n  int add = stk.back();\n  stk.pop_back();\n  for (auto &e : g[v]) {\n    if (e.dst != p) {\n      e.weight += add;\n      add_many(e.dst, v);\n    }\n  }\n  stk.push_back(add);\n \n  for (auto &aq : add_at[v]) {\n    int k = aq.first;\n    int x = aq.second;\n    if (k < (int)stk.size())\n      stk.rbegin()[k] -= x;\n  }\n}\n \nsigned main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    Graph g(n);\n    rep(i, n){\n        int k;\n        cin >> k;\n        rep(j, k){\n            int c;\n            cin >> c;\n            g[i].emplace_back(i, c, 1);\n        }\n    }\n    lca l(g, 0);\n    int q;\n    cin >> q;\n    rep(i, q){\n        int u, v;\n        cin >> u >> v;\n        cout << l.get(u, v) << '\\n';\n    }\n}\n \n// signed main() {\n//   ios::sync_with_stdio(0);\n//   cin.tie(0);\n \n//   cin >> N;\n//   g.assign(N, {});\n//   for (int i = 0; i < N - 1; i++) {\n//     int a, b, c;\n//     cin >> a >> b >> c;\n//     --a;\n//     --b;\n//     g[a].emplace_back(a, b, c);\n//     g[b].emplace_back(b, a, c);\n//   }\n \n//   lca lc(g, 0);\n \n//   cin >> Q;\n//   query.resize(Q);\n//   for (auto &q : query) {\n//     int t;\n//     cin >> t;\n//     if (t == 1) {\n//       int v, k, x;\n//       cin >> v >> k >> x;\n//       --v;\n//       --k;\n//       q = make_tuple(t, v, k, x);\n//     } else {\n//       int u, v;\n//       cin >> u >> v;\n//       --u;\n//       --v;\n//       q = make_tuple(t, u, v, -1);\n//     }\n//   }\n \n//   for (int i = 0; i < Q; i += B) {\n//     make_dist(0, -1, 0);\n \n//     int left = i, right = min(Q, i + B);\n \n//     for (int j = left; j < right; ++j) {\n//       int t, u, v;\n//       tie(t, u, v, ignore) = query[j];\n//       if (t == 2) {\n//         int add = 0;\n//         for (auto &path_v : {u, v}) {\n//           for (int jj = left; jj < j; ++jj) {\n//             int tt, add_v, k, x;\n//             tie(tt, add_v, k, x) = query[jj];\n//             if (tt == 1 && lc.get(add_v, path_v) == add_v &&\n//                 lc.depth[path_v] > lc.depth[add_v] + k) {\n//               add += x;\n//             }\n//           }\n//         }\n//         dump(add);\n//         int l = lc.get(u, v);\n//         cout << dist[u] + dist[v] - 2 * dist[l] + add << '\\n';\n//       }\n//     }\n \n//     for (int j = left; j < right; ++j) {\n//       int t, v, k, x;\n//       tie(t, v, k, x) = query[j];\n//       if (t == 1)\n//         add_at[v].push_back(make_pair(k, x));\n//     }\n//     stk.assign(N, 0);\n//     add_many(0, -1);\n//   }\n// }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\n#define INF (1<<30)\nusing namespace std;\n\nvector<int> Ind(100010);\t\t//Ind[n]  ??\\???n???euler tour??¨??§???????????°?????????\nvector<bool> f(100010, false);\t//\nvector<vector<int>> T(100010);\t//??°??????\nvector<P> ET;                   //????????¢?´¢??¨\n\nvoid dfs(int n,int dep) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tInd[n] = ET.size() - 1;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1);\n\t\tET.emplace_back(make_pair(dep,n));\n\t}\n}\n\nP RMQ(int a, int b, int k, int l, int r, vector<P>& node) {\n\tif (r <= a || b <= l) {return P(INF, INF); }\n\tif (a <= l && r <= b) return node[k];\n\n\tP vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);\n\tP vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r, node);\n\treturn min(vl, vr);\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\t//Graph initialize\n\tint n_; cin >> n_;\n\tfor (int i = 0; i < n_; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\t//ET??¨?????????\n\tdfs(0,0);\n\n\t//RMQ initialize\n\tn_ = ET.size();\n\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<P> node(2 * n - 1, P(INF, INF));\n\n\tfor (int i = 0; i < n_;i++) { node[n - 1 + i] = ET[i]; }\n\tfor (int i = n - 2; i >= 0; i--) { node[i] = min(node[2 * i + 1], node[2 * i + 2]); }\n\n\t//Answer\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tint a = Ind[u], b = Ind[v];\n\t\tif (a > b) { swap(a, b); }\n\t\tif (a == b) { cout << u << endl; continue; }\n\t\tcout << RMQ(a,b+1, 0, 0, n, node).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate <int B> // (1 << B) >= MAX_LEN\nstruct lowest_common_ancestor {\n    vector<vector<int>> graph;\n    int N, root;\n    int parent[B][1 << B], depth[1 << B];\n\n    lowest_common_ancestor() {}\n    void init(vector<vector<int>>& _graph, int _root) {\n        graph = _graph;\n        root = _root;\n\n        N = graph.size();\n\n        // set ancestors\n        set_parent(root, -1, 0);\n        for (int b = 1; b < B; ++b) {\n            for (int i = 0; i < N; ++i) {\n                if (parent[b-1][i] == -1) {\n                    parent[b][i] = -1;\n                } else {\n                    parent[b][i] = parent[b-1][parent[b-1][i]];\n                }\n            }\n        }\n    }\n\n    int query(int u, int v) {\n        if (depth[u] > depth[v]) {\n            int t = u; u = v; v = t;\n        }\n\n        for (int i = 0; i < B; ++i) {\n            if ((((depth[v] - depth[u]) >> i) & 1) != 0) {\n                v = parent[i][v];\n            }\n        } // depth[u] == depth[v]\n\n        for (int b = B-1; b >= 0; --b) {\n            if (parent[b][u] != parent[b][v]) {\n                u = parent[b][u];\n                v = parent[b][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\nprivate:\n    void set_parent(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (const int& e : graph[v]) {\n            if (e != p) {\n                set_parent(e, v, d+1);\n            }\n        }\n    }\n};\n\nint N;\nvector<vector<int>> g;\nlowest_common_ancestor<17> lca;\n\nint main() {\n    cin >> N; g.resize(N);\n    for (int j = 0; j < N; ++j) {\n        int k; cin >> k;\n        for (int x = 0; x < k; ++x) {\n            int c; cin >> c;\n            g[j].push_back(c);\n        }\n    }\n\n    lca.init(g, 0);\n    int Q; cin >> Q;\n    for (int j = 0; j < Q; ++j) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < N; i++) { sort(D[i].begin(), D[i].end()); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\tif (W == 0 || (Depth[b[A]] == 1 && Depth[b[B]] == 1 && A != B)) { cout << \"0\" << endl; continue; }\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rrep(i,x) for(int i=(int)x-1;i>=0;--i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\ninline int in(){int a;scanf(\"%d\",&a);return a;}\ninline ll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvi G[100010];\n\nint depth[100010];\nint par[100010][22];\n\nvoid lca_dfs(int v, int p, int d)\n{\n    depth[v] = d;\n    par[v][0] = p;\n\n    for (int ch : G[v]) {\n        if (ch == p) continue;\n        lca_dfs(ch, v, d + 1);\n    }\n}\n\nvoid lca_init(int root = 0)\n{\n    lca_dfs(root, -1, 0);\n\n    rep(i, 20) {\n        rep(j, 100010) {\n            par[j][i + 1] = par[j][i] == -1 ? -1 : par[par[j][i]][i];\n        }\n    }\n}\n\nint lca(int u, int v)\n{\n    if (depth[u] > depth[v]) swap(u, v);\n\n    int diff = depth[v] - depth[u];\n\n    rep(i, 20) {\n        if (diff >> i & 1) v = par[v][i];\n    }\n\n    if (u == v) return u;\n\n    rrep(i, 20) {\n        if (par[u][i] != par[v][i]) {\n            u = par[u][i];\n            v = par[v][i];\n        }\n    }\n\n    return par[u][0];\n}\n\nint main()\n{\n    int n = in();\n\n    rep(i, n) {\n        int k = in();\n\n        rep(j, k) {\n            int c = in();\n\n            G[i].PB(c);\n            G[c].PB(i);\n        }\n    }\n\n    lca_init();\n\n    int q = in();\n\n    rep(_, q) {\n        int u = in(), v = in();\n\n        printf(\"%d\\n\", lca(u, v));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\nclass LCA {\npublic:\n    int NV, logNV;\n    vector<int> D;\n    vector<vector<int>> P;\n    vector<vector<int>> E;\n\n    LCA() {}\n    void init(int N) {\n        NV = N;\n        logNV = 0;\n        while (NV > (1LL << logNV)) logNV++;\n        D = vector<int>(NV);\n        P = vector<vector<int> >(logNV, vector<int>(NV));\n        E = vector<vector<int>>(N);\n    }\n\n    void add_edge(int a, int b) {\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    void make() {\n        dfs(0, -1, 0);\n        build();\n    }\n\n    void dfs(int v, int par, int d) {\n        D[v] = d;\n        P[0][v] = par;\n        for (int i : E[v]) if (i != par) dfs(i, v, d + 1);\n    }\n\n    void build() {\n        for (int k = 0; k < logNV - 1; k++) for (int v = 0; v < NV; v++) {\n            if (P[k][v] < 0)\n                P[k + 1][v] = -1;\n            else\n                P[k + 1][v] = P[k][P[k][v]];\n        }\n    }\n\n    int lca(int u, int v) {\n        if (D[u] > D[v]) swap(u, v);\n        for(int k = 0;k < logNV;k++) if ((D[v] - D[u]) >> k & 1) v = P[k][v];\n        if (u == v) return u;\n\n        for (int k = logNV - 1; k >= 0; k--) {\n            if (P[k][u] != P[k][v]) {\n                u = P[k][u];\n                v = P[k][v];\n            }\n        }\n        return P[0][u];\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    int N; cin >> N;\n    LCA lca;\n    lca.init(N);\n    rep(i, 0, N) {\n        int K; cin >> K;\n        rep(j, 0, K) {\n            int c; cin >> c;\n            lca.add_edge(i, c);\n        }\n    }\n    lca.make();\n\n    int Q; cin >> Q;\n    rep(q, 0, Q) {\n        int a, b; cin >> a >> b;\n        int ans = lca.lca(a, b);\n        printf(\"%d\\n\", ans);\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nusing pii = pair<ll, int>;\n\nvector<int> G[100000];\nvector<int> et, depth, id;\n\nstruct ST\n{\n\tvector<pii> data;\n\tint n;\n\tint segn;\n\n\tST(int v,int k):n(v)\n\t{\n\t\tfor (segn = 1; segn < (n * 2 - 1); segn *= 2);\n\t\tdata.assign(2 * segn, make_pair(INF, -1));\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tdata[segn + i] = make_pair(depth[i], et[i]);\n\t\t}\n\t\tfor (int i = segn - 1; i >= 1; --i)\n\t\t{\n\t\t\tdata[i] = min(data[i * 2], data[i * 2 + 1]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = segn;\n\t\t}\n\t\tif (t <= s || r == 0)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (t - s == r)\n\t\t{\n\t\t\treturn data[l];\n\t\t}\n\n\t\treturn min(find(s, min(t, r / 2), l * 2, r / 2), find(max(0, s - (r / 2)), t - (r / 2), l * 2 + 1, r / 2));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tid[n] = eti;\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tet = vector<int>(n * 2 - 1);\n\tdepth = vector<int>(n * 2 - 1);\n\tid = vector<int>(n);\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(n,eti);\n\n\tint q;\n\tcin >> q;\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 1, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 30;\n\nclass LCA {\npublic:\n\tvector<int> G[MAX_V];\n\tint root;\n\n\tint parent[MAX_LOG_V][MAX_V];\n\tint depth[MAX_V];\n\n\tvoid dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tif(G[v][i] != p) dfs(G[v][i], v, d + 1);\n\t\t}\n\t}\n\n\tvoid add_edge(int a, int b) {\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tvoid init(int V, int root = 0) {\n\t\tthis->root = root;\n\t\tdfs(root, -1, 0);\n\t\tfor(int k = 0; k + 1 < MAX_LOG_V; k++) {\n\t\t\tfor(int v = 0; v < V; v++) {\n\t\t\t\tif(parent[k][v] < 0) parent[k + 1][v] = -1;\n\t\t\t\telse parent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint lca(int u, int v) {\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tfor(int k = 0; k < MAX_LOG_V; k++) {\n\t\t\tif((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int k = MAX_LOG_V - 1; k >= 0; k--) {\n\t\t\tif(parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nLCA lca;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\twhile(k--) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tlca.add_edge(i, c);\n\t\t}\n\t}\n\n\tlca.init(n);\n\n\tint q;\n\tcin >> q;\n\twhile(q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.lca(u, v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int MAX_N = 1e5 + 10;\nconst int MAX_M = (MAX_N << 1) - 1;\nconst int LSIZE = (MAX_M + 7) >> 3;\n\npii table[15][LSIZE];\npii mini[9][1 << 7];\nint buck[LSIZE];\nint off[LSIZE];\n\n\nint it = 0;\n\nint vs[MAX_M];\nint id[MAX_N];\n\nint n;\nvector<int> G[MAX_N];\n\nvoid dfs(int v) {\n\tid[v] = it;\n\tif (it) {\n\t\tbuck[(it - 1) >> 3] |= 1 << ((it - 1) & 7);\n\t}\n\tvs[it++] = v;\n\tfor (auto to : G[v]) {\n\t\tdfs(to);\n\t\tvs[it++] = v;\n\t}\n}\n\nvoid bitDP() {\n\tmini[0][0] = { 1e9, -100 };\n\tfor (int b = 0; b < 8; b++) {\n\t\tfor (int i = 0; i < (1 << b); i++) {\n\t\t\tint mi = 0, id = 0, t = 0;\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\tt += (((i >> j) & 1) << 1) - 1;\n\t\t\t\tif (t < mi) {\n\t\t\t\t\tmi = t;\n\t\t\t\t\tid = j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmini[b + 1][i] = { mi, id };\n\t\t}\n\t}\n}\n\nvoid init() {\n\tbitDP();\n\tint m = (n << 1) - 1;\n\tint l = (m + 7) >> 3;\n\tdfs(0);\n\toff[0] = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tpii tmp = mini[min(m - (i << 3), 8)][buck[i] & ((1 << 7) - 1)];\n\t\ttable[0][i] = { tmp.first + off[i], tmp.second + (i << 3) };\n\t\toff[i + 1] = off[i] + (__builtin_popcount(buck[i]) << 1) - 8;\n\t}\n\tint h = 31 - __builtin_clz(l);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j + (1 << i) < l; j++) {\n\t\t\ttable[i + 1][j] = min(table[i][j], table[i][j + (1 << i)]);\n\t\t}\n\t}\n}\n\npii get_buck(int l, int r) {\n\tpii tmp = mini[r - l][(buck[l >> 3] & ((1 << ((r - 1) & 7)) - 1)) >> (l & 7)];\n\treturn pii(off[l >> 3] + (__builtin_popcount(buck[l >> 3] & ((1 << (l & 7)) - 1)) << 1) - (l & 7) + tmp.first, l + tmp.second);\n}\n\nint lca(int u, int v) {\n\tu = id[u], v = id[v];\n\tif (u > v) swap(u, v);\n\tv++;\n\tif (((u + 7) >> 3) > (v >> 3)) {\n\t\treturn vs[u + mini[v - u][(buck[u >> 3] & ((1 << ((v - 1) & 7)) - 1)) >> (u & 7)].second];\n\t}\n\tpii left = get_buck(u, (u + 7) & (~7));\n\tpii right = get_buck(v & (~7), v);\n\tu = (u + 7) >> 3;\n\tv >>= 3;\n\tif (u == v) {\n\t\treturn vs[min(left, right).second];\n\t}\n\tint b = 31 - __builtin_clz(v - u);\n\treturn vs[min(min(left, right), min(table[b][u], table[b][v - (1 << b)])).second];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate <int B> // (1 << B) >= MAX_LEN\nstruct lowest_common_ancestor {\n    vector<vector<int>> graph;\n    int N, root;\n    int parent[B][1 << B], depth[1 << B];\n\n    lowest_common_ancestor() {}\n    void init(int _root) {\n        root = _root;\n\n        N = graph.size();\n\n        // set ancestors\n        set_parent(root, -1, 0);\n        for (int b = 1; b < B; ++b) {\n            for (int i = 0; i < N; ++i) {\n                if (parent[b-1][i] == -1) {\n                    parent[b][i] = -1;\n                } else {\n                    parent[b][i] = parent[b-1][parent[b-1][i]];\n                }\n            }\n        }\n    }\n\n    int query(int u, int v) {\n        if (depth[u] > depth[v]) {\n            int t = u; u = v; v = t;\n        }\n\n        for (int i = 0; i < B; ++i) {\n            if ((((depth[v] - depth[u]) >> i) & 1) != 0) {\n                v = parent[i][v];\n            }\n        } // depth[u] == depth[v]\n\n        if (u == v) return u;\n\n        for (int b = B-1; b >= 0; --b) {\n            if (parent[b][u] != parent[b][v]) {\n                u = parent[b][u];\n                v = parent[b][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\nprivate:\n    void set_parent(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (const int& e : graph[v]) {\n            if (e != p) {\n                set_parent(e, v, d+1);\n            }\n        }\n    }\n};\n\nint N;\nvector<vector<int>> g;\nlowest_common_ancestor<17> lca;\n\nint main() {\n    cin >> N; lca.graph.resize(N);\n    for (int j = 0; j < N; ++j) {\n        int k; cin >> k;\n        for (int x = 0; x < k; ++x) {\n            int c; cin >> c;\n            lca.graph[j].push_back(c);\n        }\n    }\n\n    lca.init(0);\n\n    int Q; cin >> Q;\n    for (int j = 0; j < Q; ++j) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\nstruct rmqsegtree{\n  vector< pair<int, int> > t; //<data, at>\n  pair<int, int> re;\n  int n;\n  void dflt(void){ re.first = INT_MAX; re.second = -1; return; }\n  void use(void){\n    int i; dflt();\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0].first = 1 << (i - 1); t[0].second = 1 << i;\n    for(i = 1;i < t[0].second;++i)t[i] = re;\n    for(i = 0;i < n;++i)t[i + t[0].first].second = i;\n    return;\n  }\n  void build(vector<int> a){  //???????¨?\n    for(n = 1;;n <<= 1)if(n >= a.size())break;\n    t.resize(n << 1); dflt();\n    t[0].first = n; t[0].second = t[0].first << 1; n = a.size();\n    for(int i = 1;i < t[0].second;++i)t[i] = re;\n    for(int i = 0;i < n;++i){\n      t[t[0].first + i].first = a[i]; t[t[0].first + i].second = i;\n    }\n    for(int i = t[0].first - 1;i >= 1;--i)\n      t[i] = (t[i << 1] <= t[(i << 1) + 1]) ? t[i << 1] : t[(i << 1) + 1];\n    return;\n  }\n  void update(int at, int data){\n    t[t[0].first + at].first = data;\n    for(int x = t[0].first + at;x > 1;){\n      x >>= 1;\n      if(t[x << 1].first <= t[(x << 1) + 1].first)t[x] = t[x << 1];\n      else t[x] = t[(x << 1) + 1];\n    }\n    return;\n  }\n  pair<int, int> query(int l, int r, int k, int kl, int kr){\n    //printf(\"%d %d %d %d %d\\n\", l, r, k, kl, kr);\n    if(l <= t[k].second && t[k].second < r)return t[k];\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    pair<int, int> a = query(l, r, k << 1, kl, (kl + kr) >> 1);\n    pair<int, int> b = query(l, r, (k << 1) + 1, (kl + kr) >> 1, kr);\n    return (a.first < b.first) ? a : b;\n  }\n  pair<int, int> find(int l, int r){ return query(l, r, 1, 0, t[0].first); }\n  void deb(void){\n    int x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].first);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].second);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    return;\n  }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nstruct tree{\n  vector< vector<edge> > t;\n  int v;\n  void nexttree(int x){ //x-indexed\n    scanf(\"%d\", &v);  t.resize(v);\n    int from, to, cost = 1;\n    for(int i = 1;i < v;++i){\n      scanf(\"%d %d\", &from, &to);\n      t[from - x].push_back((edge){to - x, cost});\n      t[to - x].push_back((edge){from - x, cost});\n    }\n    return;\n  }\n  void nexttree2(int x){\n    scanf(\"%d\", &v); t.resize(v);\n    int k, to, cost = 1;\n    for(int i = 0;i < v;++i){\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;++j){\n        scanf(\"%d\", &to);\n        t[i - x].push_back((edge){to - x, cost});\n        t[to - x].push_back((edge){i - x, cost});\n      }\n    }\n    return;\n  }\n  rmqsegtree S;\n  vector<int> vst, dpth, id;\n  void lcarmqdfs(int now, int dep){\n    id[now] = vst.size();\n    vst.push_back(now); dpth.push_back(dep);\n    for(int i = 0;i < t[now].size();++i)if(id[t[now][i].to] == -1){\n      lcarmqdfs(t[now][i].to, dep + 1);\n      vst.push_back(now); dpth.push_back(dep);\n    }\n    return;\n  }\n  void lcarmq(void){\n    if(vst.size() > v)return;\n    id.resize(v); for(int i = 0;i < v;++i)id[i] = -1;\n    lcarmqdfs(0, 0);\n    S.build(vst);\n    return;\n  }\n  int lca(int a, int b){\n    if(id[a] > id[b])swap(a, b);\n    return vst[S.find(id[a], id[b] + 1).second];\n  }\n};\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    tree T; T.nexttree2(0);\n    T.lcarmq();\n\n    int(q);\n    for(;q--;){\n      int2(a, b);\n      int x = T.lca(a, b);\n      pri(x);\n    }\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\nint N, k, cs, P[maxn], lca[maxn][17], L[maxn], Q;\nvector<int> A[maxn];\n\n\nvoid dfs( int v, int lvl ){\n\n\tL[v] = lvl;\n\tvector<int>::iterator x = A[v].begin();\n\tfor( ; x != A[v].end(); ++x )\n\t\tdfs( *x, lvl + 1 );\n}\n\n\nvoid preLCA(){\n\n\tfor( int i = 0; i < N; ++i )\n\t\tfor( int j = 0; ( 1 << j ) < N; ++j )\n\t\t\tlca[i][j] = -1;\n\n\t\t\t\n\tfor( int i = 0; i < N; ++i )\n\t\tlca[i][0] = P[i];\n\n\n\tfor( int i = 1; ( 1 << i ) < N; ++i )\n\t\tfor( int j = 0; j < N; ++j )\n\t\t\tif(lca[j][i-1] != - 1)\n\t\t\t\tlca[j][i] = lca[lca[j][i - 1]][i - 1];\n}\n\nint findlca( int nx, int ny ){\n\n\tif( L[nx] < L[ny] )\n\t\tswap(nx, ny);\n\n\tint lg = 1;\n\n\tfor( ; (1 << lg) <= L[nx]; ++lg );\n\t--lg;\n\n\tfor( int i = lg; i >= 0; --i )\n\t\tif( L[nx] - ( 1 << i ) >= L[ny] )\n\t\t\tnx = lca[nx][i];\n\n\tif( nx == ny )\n\t\treturn nx;\n\t\n\tfor( int i = lg; i >= 0; --i )\n\t\tif( lca[nx][i] != -1 && lca[nx][i] != lca[ny][i] )\n\t\t\tnx = lca[nx][i], ny = lca[ny][i];\n\t                     \n\treturn P[nx];\n}               \n\nint main( void ){\n\n\t//freopen(\"input.in\", \"r\", stdin);\n    scanf(\"%d\", &N);\n\n    for( int i = 0; i < N; ++i ){\n    \tscanf(\"%d\", &k);\n    \tfor( int j = 0; j < k; ++j )\n    \t\tscanf(\"%d\", &cs), \n    \t\tA[i].push_back(cs), \n    \t\tP[cs] = i; \n    }\n\t\n\tdfs( 0, 0 );\n\tpreLCA();\n\tscanf(\"%d\", &Q);\n\tint a, b;\n\tfor( ; Q > 0; --Q ){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tprintf(\"%d\\n\", findlca(a, b));\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct LowestCommonAncestor{\n  const int MAX_LOG_V = 50;\n  \n  int n;\n  vector<vector<int> > G,par;\n  vector<int> depth;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int sz):\n    n(sz),G(sz),par(MAX_LOG_V,vector<int>(n)),depth(sz){}\n\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    for(int i=0;i<(int)G[v].size();i++){\n      if(G[v][i]!=p) dfs(G[v][i],v,d+1);\n    }\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<MAX_LOG_V;k++){\n      for(int v=0;v<n;v++){\n\tif(par[k][v]<0) par[k+1][v]=-1;\n\telse par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(depth[u]>depth[v]) swap(u,v);\n    for(int k=0;k<MAX_LOG_V;k++){\n      if((depth[v]-depth[u])>>k&1){\n\tv=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=MAX_LOG_V-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n\tu=par[k][u];\n\tv=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return depth[u]+depth[v]-depth[lca(u,v)]*2;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n;\n  cin>>n;\n  LowestCommonAncestor lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/11/20\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n//-------------------------------------------------------------------------\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define prv(v) for (auto i : v) { cout << i << \" \";}\n#define prmat(v) for (auto i : v) { prv(i); cout << \"\\n\";}\n#define cout(x) cout << fixed << setprecision(x)\n#define read(v) for (int i_ = 0; i_ < v.size(); i_++) { cin >> v[i_];}\n#define fast_io ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define all(v) (v.begin()), (v.end())\n#define rall(v) (v.rbegin()), (v.rend())\n#define pii pair<int, int>\n//------------------------------------------------------------------------\nstruct lca{\n    vector<vector<int>> g;\n    vector<pii> t;\n    int n, on;\n    int timer = 0;\n    vector<int> order, vorder, h, tin;\n    void dfs0(int v, int p = -1){\n        for(auto to : g[v]){\n            if(to != p){\n                h[to] = h[v] + 1;\n                dfs0(to, v);\n            }\n        }\n    }\n    void dfs(int v, int p = -1){\n        order.push_back(h[v]);\n        vorder.push_back(v);\n        for(auto to : g[v]){\n            if(to != p){\n                dfs(to, v);\n                order.push_back(h[v]);\n                vorder.push_back(v);\n            }\n        }\n    }\n    \n    void build(int v, int tl, int tr){\n        if(tl == tr){\n            t[v] = {order[tl], tl};\n            return;\n        }\n        int tm = (tl + tr) / 2;\n        build(v * 2, tl, tm);\n        build(v * 2 + 1, tm + 1, tr);\n        t[v] = min(t[v * 2], t[v * 2 + 1]);\n    }\n    \n    pii get(int v, int tl, int tr, int l, int r){\n        if(tl > r || tr < l){\n            return pii{1e9, 1e9};\n        }\n        if(tl >= l && tr <= r){\n            return t[v];\n        }\n        int tm = (tl + tr) / 2;\n        return min(get(v * 2, tl, tm, l, r), get(v * 2 + 1, tm + 1, tr, l, r));\n    }\n    lca(vector<vector<int>> &tt){\n        g = tt;\n        n = (int)tt.size();\n        tin.resize(n, 1e9);\n        h.resize(n);\n        dfs0(0);\n        dfs(0);\n        on = (int)order.size();\n        for(int i = 0; i < vorder.size(); i++){\n            tin[vorder[i]] = min(tin[vorder[i]], i);\n        }\n        t.resize(on * 4);\n        build(1, 0, on - 1);\n    }\n    int get(int i, int j){\n        \n        int x = tin[i];\n        int y = tin[j];\n        if(x > y){\n            swap(x, y);\n        }\n        pii a = get(1, 0, on - 1, x, y);\n        return vorder[a.second];\n    }\n};\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n; i++){\n        int m;\n        cin >> m;\n        for(int j = 0; j < m; j++){\n            int x;\n            cin >> x;\n            g[i].push_back(x);\n            g[x].push_back(i);\n        }\n    }\n    lca x(g);\n    int q;\n    cin >> q;\n    while(q--){\n        int a, b;\n        cin >> a >> b;\n        cout << x.get(a, b) << \"\\n\";\n    }\n}\nint main() {\n    fast_io;\n#ifdef LOCALKA\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n#endif\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\n\nclass LCA{\n\tint log,n;\n\tstd::vector<int> depth,par;\n\tint dfs(const int parent[],int u){\n\t\tif(parent[u]==-1)return depth[u]=1;\n\t\tif(depth[u]!=0)return depth[u];\n\t\treturn depth[u]=dfs(parent,parent[u])+1;\n\t}\npublic:\n\tLCA(const int parent[],int n):n(n),depth(n,0){\n\t\tlog=1;\n\t\twhile((1<<log)<n)log++;\n\t\tlog++;\n\t\tfor(int i=0;i<n;i++)dfs(parent,i);\n\t\tpar.resize(n*log);\t\n\t\tfor(int i=0;i<n;i++)par[i]=parent[i];\n\t\tfor(int i=1;i<log;i++)\n\t\t\tfor(int v=0;v<n;v++)\n\t\t\t\tpar[i*n+v]=par[(i-1)*n+par[(i-1)*n+v]];\n\t}\n\tint query(int u,int v)const{\n\t\tif(depth[u] > depth[v])std::swap(u,v);\n\t\tfor(int i=log-1;i>=0;i--)\n\t\t\tif(depth[u] <= depth[v]-(1<<i))\n\t\t\t\tv=par[i*n+v];\n\t\tif(u==v)return u;\n\t\tfor(int i=log-1;i>=0;i--){\n\t\t\tif(par[i*n+u]!=par[i*n+v]){\n\t\t\t\tu=par[i*n+u];\n\t\t\t\tv=par[i*n+v];\n\t\t\t}\n\t\t}\n\t\treturn par[u];\n\t}\n};\n\nusing namespace std;\n\nint par[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)par[i]=-1;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tpar[v]=i;\n\t\t}\n\t}\n\tLCA lca(par,n);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    UL P[100000][17];\n    UL D[100000];\n    vector<UL> E[100000];\n\n    UL UP(UL u, UL d) {\n        for (UL i = 16; i != -1; i--) if (d & (1 << i)) u = P[u][i];\n        return u;\n    }\n\n    UL LCS(UL u, UL v) {\n        if (D[u] > D[v]) u = UP(u, D[u] - D[v]);\n        else if (D[u] < D[v]) v = UP(v, D[v] - D[u]);\n        for (UL i = 16; i != -1; i--) {\n            if (P[u][i] != P[v][i]) { u = P[u][i]; v = P[v][i]; }\n        }\n        if (u == v) return u;\n        return P[u][0];\n    }\n\n    void Solve() {\n        UL N; scanf(\"%d\", &N);\n        P[0][0] = 0;\n        rep(u, N) {\n            UL K; scanf(\"%d\", &K);\n            while (K--) {\n                UL v; scanf(\"%d\", &v);\n                E[u].push_back(v); P[v][0] = u;\n            }\n        }\n        {\n            vector<UL> Q; Q.push_back(0); D[0] = 0;\n            while (Q.size()) {\n                UL p = Q.back(); Q.pop_back();\n                for (UL e : E[p]) { D[e] = D[p] + 1; Q.push_back(e); }\n            }\n        }\n        rep(i, 16) rep(v, N) P[v][i + 1] = P[P[v][i]][i];\n        UL Q; scanf(\"%d\", &Q);\n        while (Q--) {\n            UL u, v; scanf(\"%d%d\", &u, &v);\n            printf(\"%d\\n\", LCS(u, v));\n        }\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    //cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type, ps, pt;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n),ps(n),pt(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int, int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v=st.top().first;\n      int &i=st.top().second;\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tfor(int j=0;j<(int)G[v].size();j++){\n\t  int &u=G[v][j];\n\t  if(u==par[v]){\n\t    swap(u,G[v].back());\n\t    continue;\n\t  }\n\t  sub[v]+=sub[u];\n\t  if(sub[u]>sub[G[v].front()]) swap(u,G[v].front());\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=pos++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n        hvy[i]=(G[i].empty()?-1:G[i][0]);\n\tif(hvy[i]==par[i]) hvy[i]=-1;\n\tfor(int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\nsigned AOJ_GRL5C(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned YUKI_529(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/12/31\nhttps://yukicoder.me/problems/no/529\n*/\n\nsigned main(){\n  AOJ_GRL5C();\n  //YUKI_529();\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<vector<int> > tree;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :n(tree.size()),tree(tree),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate <int B> // (1 << B) >= MAX_LEN\nstruct lowest_common_ancestor {\n    vector<vector<int> > graph;\n    int N, root;  int parent[B][1 << B], depth[1 << B];\n\n    lowest_common_ancestor() {}\n    void init(int _root) {\n        root = _root;\n        N = graph.size();\n\n        set_parent(root, -1, 0);\n        for (int b = 1; b < B; ++b) {\n            for (int i = 0; i < N; ++i) {\n                parent[b][i] = parent[b-1][i] == -1 ? -1 : parent[b-1][parent[b-1][i]];\n            }\n        }\n    }\n\n    int query(int u, int v) {\n        if (depth[u] > depth[v]) {\n            int t = u; u = v; v = t;\n        }\n\n        for (int i = 0; i < B; ++i) {\n            if ((((depth[v] - depth[u]) >> i) & 1) != 0)\n                v = parent[i][v];\n        } // depth[u] == depth[v]\n\n        if (u == v) return u;\n        for (int b = B-1; b >= 0; --b) {\n            if (parent[b][u] != parent[b][v]) {\n                u = parent[b][u];  v = parent[b][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\nprivate:\n    void set_parent(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < graph[v].size(); ++i) {\n            int e = graph[v][i];\n            if (e != p) set_parent(e, v, d+1);\n        }\n    }\n};\n\nint N;\nlowest_common_ancestor<17> lca;\n\nint main() {\n    cin >> N; lca.graph.resize(N);\n    for (int j = 0; j < N; ++j) {\n        int k; cin >> k;\n        for (int x = 0; x < k; ++x) {\n            int c; cin >> c;\n            lca.graph[j].push_back(c);\n        }\n    }\n\n    lca.init(0);\n\n    int Q; cin >> Q;\n    for (int j = 0; j < Q; ++j) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nstruct Edge {\n  ll to;\n  Edge(ll to) : to(to) {}\n};\n\nusing Graph = vector<vector<Edge>>;\n/* LCA(G, root): 木 G に対する根を root として Lowest Common Ancestor\n   を求める構造体 query(u,v): u と v の LCA を求める。計算量 O(logn) 前処理:\n   O(nlogn)時間, O(nlogn)空間\n*/\nstruct LCA {\n  vector<vector<int>> parent;  // parent[k][u]:= u の 2^k 先の親\n  vector<int> dist;            // root からの距離\n\n  LCA(const Graph &G, int root = 0) { init(G, root); }\n  // 初期化\n  void init(const Graph &G, int root = 0) {\n    int V = G.size();\n    int K = 1;\n    while ((1 << K) < V) K++;\n    parent.assign(K, vector<int>(V, -1));\n    dist.assign(V, -1);\n    dfs(G, root, -1, 0);\n    for (int k = 0; k + 1 < K; k++) {\n      for (int v = 0; v < V; v++) {\n        if (parent[k][v] < 0) {\n          parent[k + 1][v] = -1;\n        } else {\n          parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n      }\n    }\n  }\n\n  // 根からの距離と1つ先の頂点を求める\n  void dfs(const Graph &G, int v, int p, int d) {\n    parent[0][v] = p;\n    dist[v] = d;\n    for (auto e : G[v]) {\n      if (e.to != p) dfs(G, e.to, v, d + 1);\n    }\n  }\n\n  int query(int u, int v) {\n    if (dist[u] < dist[v]) swap(u, v);  // u の方が深いとする\n    int K = parent.size();\n    // LCA までの距離を同じにする\n    for (int k = 0; k < K; k++) {\n      if ((dist[u] - dist[v]) >> k & 1) {\n        u = parent[k][u];\n      }\n    }\n    // 二分探索で LCA を求める\n    if (u == v) return u;\n    for (int k = K - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n;\n  Graph g(n);\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      ll c;\n      cin >> c;\n      Edge edge(c);\n      g[i].push_back(edge);\n    }\n  }\n\n  cin >> q;\n  LCA lca(g);\n  vector<int> ans(q);\n  rep(i, q) {\n    int u, v;\n    cin >> u >> v;\n    ans[i] = lca.query(u, v);\n  }\n\n  rep(i, q) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\nclass RMQ{//RangeMinimumQuery\n\tint n;\n\tstd::vector<int> dat,idx;\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return dat.size()-1;\n\t\tif(a<=l&&r<=b)return idx[k];\n\t\telse{\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn dat[vl]<dat[vr]?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQ(){}\n\t~RMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tn=calcsize(a.size());\n\t\tidx.resize(2*n-1);\n\t\tfor(int i=0;i<(int)a.size();i++)idx[n-1+i]=i;\n\t\tfor(int i=a.size();i<n;i++)idx[n-1+i]=a.size();\n\t\tdat=a;\n\t\tdat.push_back(INT_MAX);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tidx[i]=dat[idx[i*2+1]]<dat[idx[i*2+2]]?idx[i*2+1]:idx[i*2+2];\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\nclass LCA{\n\tvector<pair<int,int> > eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\tRMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u].first=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t\tif(edge[u].empty()){\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,0,root);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u].first<eulertour[v].first && eulertour[v].second<eulertour[u].second)\n\t\t\treturn u;\n\t\tif(eulertour[v].first<eulertour[u].first && eulertour[u].second<eulertour[v].second)\n\t\t\treturn v;\n\t\tif(eulertour[u].first>eulertour[v].first)swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u].second, eulertour[v].first)];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint root = 0;\nint n;\nvector<int> c[100005];\nconst int K = 20;\nint parent[K][100005];\nint depth[100005];\n\nvoid bfs(int v, int p, int d) {\n  queue<tuple<int, int, int>> que;\n  que.push(make_tuple(v, p, d));\n  while (!que.empty()) {\n    auto ele = que.front(); que.pop();\n    int vv = get<0>(ele), pp = get<1>(ele), dd = get<2>(ele);\n    parent[0][vv] = pp;\n    depth[vv] = dd;\n    for (auto i: c[vv]) {\n      que.push(make_tuple(i, vv, dd + 1));\n    }\n  }\n}\n\nvoid init() {\n  bfs(root, -1, 0);\n  for (int k = 0; k + 1 < K; k++) {\n    for (int v = 0; v < n; v++) {\n      if (parent[k][v] < 0) parent[k + 1][v] = -1;\n      else parent[k + 1][v] = parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u, int v) {\n  if (depth[u] > depth[v]) swap(u, v);\n  for (int k; k < K; k++) {\n    if ((depth[v] - depth[u] >> k & 1)) {\n      v = parent[k][v];\n    } \n    if (u == v) return u;\n  }\n  for (int k = K - 1; k >= 0; k--) {\n    if (parent[k][u] != parent[k][v]) {\n      u = parent[k][u];\n      v = parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      int cj;\n      cin >> cj;\n      c[i].push_back(cj);\n    }\n  }\n\n  init();\n\n  int q;\n  cin >> q;\n  rep(i, q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca(u, v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_REP(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_REP(__VA_ARGS__, irep, _rep)(__VA_ARGS__)\n#define rep1(...) GET_REP(__VA_ARGS__, irep1, _rep1)(__VA_ARGS__)\n#define _rep(i, n) irep (i, 0, n)\n#define _rep1(i, n) irep1(i, 1, n)\n#define irep(i, a, n) for (int i = a; i < (int)(n); ++i)\n#define irep1(i, a, n) for (int i = a; i <= (int)(n); ++i)\n#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define rrep1(i, n) for (int i = (int)(n); i >= 1; --i)\n#define allrep(X, x) for (auto &&X : x)\n#define all(x) (x).begin(), (x).end()\n#ifdef LOCAL\n  #include \"../../Lib/cout_container.hpp\"\n  #define debug(x) cerr << #x \" => \" << x << endl\n#else\n  #define debug(x) 0\n#endif\nusing lint = long long;\nconstexpr int    INF  = 1 << 30;\nconstexpr lint   INFL = 1LL << 62;\nconstexpr int    MOD  = (int)1e9 + 7;\nconstexpr double EPS  = 1e-9;\nusing namespace std;\nnamespace { struct INIT { INIT() { cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } INIT; }\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(void) {}\n  Edge(int src, int dst) : src(src), dst(dst) {}\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid edges_to_graph(Graph &graph, const Edges &edges, const int vertices, const bool directed = true) {\n  graph.resize(vertices);\n  for (const auto &e : edges) {\n    graph[e.src].push_back(e);\n    if (!directed) graph[e.dst].emplace_back(Edge(e.dst, e.src, e.weight));\n  }\n}\n\nclass EulerTour {\n  int num = 0;\n  void et_dfs(const Graph &graph, const int v, const int p, const int dep) {\n    tour.push_back(v);\n    in[v] = num++;\n    depth_tour.push_back(dep);\n    depth[v] = dep;\n    for (const auto &e : graph[v]) {\n      if (e.dst == p) continue;\n      et_dfs(graph, e.dst, v, dep + 1);\n      tour.push_back(v);\n      depth_tour.push_back(dep);\n      ++num;\n    }\n    out[v] = num - 1;\n  }\n\n  public:\n  vector<int> tour, depth_tour, in, out, depth;\n  EulerTour(void) {}\n  EulerTour(const Graph &graph, const int v) { init(graph, v); }\n  void init(const Graph &graph, const int v) {\n    tour.clear();\n    depth_tour.clear();\n    in.assign(graph.size(), 0);\n    out.assign(graph.size(), 0);\n    depth.assign(graph.size(), 0);\n    et_dfs(graph, v, -1, 0);\n  }\n};\n\ntemplate <typename T>\nclass SparseTable {\n  vector<vector<int>> st;\n  vector<int> lookup;\n  vector<T>   origin;\n\n  public:\n  SparseTable(void) {}\n  SparseTable(const vector<T> &v) { init(v); }\n  void init(const vector<T> &v) {\n    origin = v;\n    int lg_size = 0, v_size = origin.size();\n    while ((1 << lg_size) <= v_size) ++lg_size;\n    st.assign((1 << lg_size), vector<int>(lg_size));\n    for (int i = 0; i < v_size; ++i) st[i][0] = i;\n    for (int j = 1; j < lg_size; ++j) {\n      for (int i = 0; i + (1 << j) <= (1 << lg_size); ++i) {\n        int l = st[i][j - 1], r = st[i + (1 << (j - 1))][j - 1];\n        st[i][j] = origin[l] <= origin[r] ? l : r;\n      }\n    }\n    lookup.assign(v_size + 1, 0);\n    for (int i = 2; i <= v_size; ++i) lookup[i] = lookup[i >> 1] + 1;\n  }\n  T query(int l, int r) {\n    int lgsize = lookup[r - l];\n    return min(origin[st[l][lgsize]], origin[st[r - (1 << lgsize)][lgsize]]);\n  }\n  int query_index(int l, int r) {\n    int lgsize = lookup[r - l];\n    T   lv = origin[st[l][lgsize]], rv = origin[st[r - (1 << lgsize)][lgsize]];\n    if (lv < rv) return st[l][lgsize];\n    else if (lv > rv) return st[r - (1 << lgsize)][lgsize];\n    else return min(st[l][lgsize], st[r - (1 << lgsize)][lgsize]);\n  }\n};\n\nclass LowestCommonAncestor {\n  class PM1RangeMinimumQuery {\n    int bl_size, bl_num;\n    vector<int> origin, bl_bit;\n    vector<vector<vector<int>>> lookup;\n    SparseTable<pair<int, int>> st;\n\n    public:\n    PM1RangeMinimumQuery(void) {}\n    void init(const vector<int> &v) {\n      origin = v;\n      int vsize = origin.size();\n      bl_size = 0;\n      while ((1 << bl_size) < vsize) ++bl_size;\n      bl_size = max(1, (bl_size >> 1));\n      while (vsize % bl_size) {\n        origin.push_back(origin.back() + 1);\n        ++vsize;\n      }\n      bl_num = vsize / bl_size;\n      vector<pair<int, int>> block_min(bl_num, {INT_MAX, INT_MAX});\n      for (int i = 0; i < vsize; ++i) block_min[i / bl_size] = min(block_min[i / bl_size], {origin[i], i});\n      st.init(block_min);\n      bl_bit.assign(bl_num, 0);\n      for (int i = 0; i < bl_num; ++i) {\n        int left = bl_size * i;\n        for (int j = 0; j < bl_size - 1; ++j) {\n          if (origin[left + j] < origin[left + j + 1]) bl_bit[i] |= (1 << j);\n        }\n      }\n      int bit_all = 1 << (bl_size - 1);\n      lookup.assign(bit_all, vector<vector<int>>(bl_size, vector<int>(bl_size)));\n      for (int b = 0; b < bit_all; ++b) {\n        for (int i = 0; i < bl_size; ++i) {\n          int mini = 0, now = 0;\n          for (int j = i + 1; j < bl_size; ++j) {\n            b&(1 << (j - 1)) ? ++now : --now;\n            if (mini > now) {\n              mini = now;\n              lookup[b][i][j] = j - i;\n            } else {\n              lookup[b][i][j] = lookup[b][i][j - 1];\n            }\n          }\n        }\n      }\n    }\n    int query_index(int l, int r) {\n      int lb = l / bl_size, rb = r / bl_size;\n      int lbpos = l % bl_size, rbpos = r % bl_size;\n      if (lb == rb) return l + lookup[bl_bit[lb]][lbpos][rbpos];\n      int lbmini = l, rbmini = r;\n      if (lbpos != 0) {\n        lbmini = l + lookup[bl_bit[lb]][lbpos][bl_size - 1];\n        ++lb;\n      }\n      if (rbpos != bl_size - 1) {\n        rbmini = r - rbpos + lookup[bl_bit[rb]][0][rbpos];\n        --rb;\n      }\n      int mini = origin[lbmini] < origin[rbmini] ? lbmini : rbmini;\n      if (lb <= rb) {\n        pair<int, int> stpair = st.query(lb, rb + 1);\n        if (stpair.first < origin[mini]) mini = stpair.second;\n      }\n      return mini;\n    }\n  };\n  PM1RangeMinimumQuery rmq;\n\n  public:\n  EulerTour et;\n  LowestCommonAncestor(void) {}\n  LowestCommonAncestor(const Graph &graph, const int v) { init(graph, v); }\n  void init(const Graph &graph, const int v) {\n    et.init(graph, v);\n    rmq.init(et.depth_tour);\n  }\n  int query(const int a, const int b) {\n    int l = et.in[a], r = et.in[b];\n    if (l > r) swap(l, r);\n    int idx = rmq.query_index(l, r);\n    return et.tour[idx];\n  }\n};\n\nvector<vector<int>> c;\nGraph graph;\nint main(void) {\n  int n;\n  cin >> n;\n  c.resize(n);\n  rep (i, n) {\n    int k;\n    cin >> k;\n    rep (j, k) {\n      int x;\n      cin >> x;\n      c[i].push_back(x);\n    }\n  }\n  int q;\n  cin >> q;\n  vector<int> u(q), v(q);\n  rep (i, q) cin >> u[i] >> v[i];\n  graph.resize(n);\n  rep (i, n) {\n    allrep (C, c[i]) {\n      graph[i].emplace_back(Edge(i, C));\n    }\n  }\n  LowestCommonAncestor lca(graph, 0);\n  vector<int> ans(q);\n  rep (i, q) ans[i] = lca.query(u[i], v[i]);\n  rep (i, q) cout << ans[i] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass LowestCommonAncestor\n{\npublic:\n    LowestCommonAncestor(const Graph& g, const int root = 0) : left(g.V, 0)  // 無向根付き木\n    {\n        vector<bool> used(g.V, false);\n        auto dfs = fix([&](auto&& self, const pair<int, int>& s) -> void {\n            used[s.second] = true;\n            const int pos = s.second;\n            left[pos] = depth.size();\n            depth.push_back(s);\n            for (const int to : g.edge[pos]) {\n                if (used[to]) { continue; }\n                self(self, {s.first + 1, to});\n                depth.push_back(s);\n            }\n        });\n        dfs(make_pair(0, root));\n    }\n    int LCA(const int u, const int v) const\n    {\n        static const SparseTable<DepthMin> st{depth};\n        const int ul = left[u];\n        const int vl = left[v];\n        return st.accumulate(min(ul, vl), max(ul, vl) + 1).second;\n    }\n\nprivate:\n    struct DepthMin\n    {\n        using T = pair<int, int>;\n        T operator()(const T& a, const T& b) const { return min(a, b); }\n    };\n    vector<int> left;\n    vector<pair<int, int>> depth;\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n// Status: Accepted\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g.addEdge(i, c);\n        }\n    }\n\n    LowestCommonAncestor lca{g};\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.LCA(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//lca\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\n/*\nlca(u,v)????????¨???O(logN)??§?±???????\n?????????O(NlogN)\np??¨depth???????????£????????°????????????genlca????????§????????????,?????¬?????°??????G???????????¶????????¨\n??????dfs+genlca??????????????????\n\npath???????§£????????¨??????[u,z) + [v,z) + z ?????????????????????, ???????????????????????????(depth-1???????????????)??¨ok\n\n*/\n\nint bsr(int x){\t//4~7 -> 2\n\tif(x==0) return -1;\n\treturn 31 ^ __builtin_clz(x);\n}\nstruct LCA{\n\tint N,n;\n\tvector<int> depth;\n\tvector<vector<int>> par;\n\n\tvoid dfs(int v,int p,const vector<vector<int>>& G){\n\t\tif(p<0) depth[v]=0;\n\t\telse depth[v]=depth[p]+1;\n\t\tpar[v][0]=p;\n\t\tfor(int u:G[v]){\n\t\t\tif(u!=p) dfs(u,v,G);\n\t\t}\n\t}\n\n\tLCA(const vector<vector<int>>& G){\n\t\tN = G.size();\n\t\tn = bsr(N);\n\t\tdepth = vector<int>(N,0);\n\t\tpar = vector<vector<int>>(N,vector<int>(n+1,0));\n\n\t\tdfs(0,-1,G);\n\t\trep1(i,n){\n\t\t\trep(v,N){\n\t\t\t\tif(par[v][i-1]==-1){\n\t\t\t\t\tpar[v][i]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tpar[v][i]=par[par[v][i-1]][i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint lca(int u,int v){\n\t\tif(depth[u]<depth[v]){\n\t\t\tswap(u,v);\n\t\t}\n\t\tint d=depth[u]-depth[v];\n\t\trep(i,n+1){\n\t\t\tif((d>>i)&1) u=par[u][i];\n\t\t}\n\t\tif(u==v) return u;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(par[u][i]!=par[v][i]){\n\t\t\t\tu=par[u][i];\n\t\t\t\tv=par[v][i];\n\t\t\t}\n\t\t}\n\t\treturn par[v][0];\n\t}\n\n\tint distance(int u,int v){\n\t\treturn depth[u] + depth[v] - 2*depth[lca(u,v)];\n\t}\n};\n\n\nint main(){\n\tint N,Q;\n\tcin>>N;\n\tvector<vector<int>> G(N);\n\trep(i,N){\n\t\tint n;\n\t\tcin>>n;\n\t\trep(j,n){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tG[i].pb(x);\n\t\t\tG[x].pb(i);\n\t\t}\n\t}\n\tLCA lca(G);\n\tcin>>Q;\n\trep(q,Q){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tcout<<lca.lca(x,y)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\n\nstruct LCA{\n  const int MAX_LOG_V = 50;\n\n  vector<vector<int> > G,parent;\n  int root=0,V;\n  vector<int> depth;\n  LCA(){}\n  LCA(int V):V(V){init();}\n  LCA(int V,WG<int> es):V(V){init();rep(i,V){for(auto e:es[i]){G[i].PB(e.to);}}}\n\n  void init(){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    for(int i=0;i<(int)parent.size();i++) parent[i].clear();\n    parent.clear();\n    depth.clear();\n    G.resize(V);\n    parent.resize(MAX_LOG_V,vector<int>(V));\n    depth.resize(V);\n  }\n\n  void add(int u,int v){\n    G[u].PB(v);\n  }\n\n  void dfs(int v,int p,int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    for(int i=0;i<(int)G[v].size();i++){\n      if(G[v][i]!=p) dfs(G[v][i],v,d+1);\n    }\n  }\n\n  void construct(){\n    dfs(root,-1,0);\n    for(int k=0;k+1<MAX_LOG_V;k++){\n      for(int v=0;v<V;v++){\n        if(parent[k][v]<0) parent[k+1][v]=-1;\n        else parent[k+1][v]=parent[k][parent[k][v]];\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    if(depth[u]>depth[v]) swap(u,v);\n    for(int k=0;k<MAX_LOG_V;k++){\n      if((depth[v]-depth[u])>>k&1){\n        v=parent[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=MAX_LOG_V-1;k>=0;k--){\n      if(parent[k][u]!=parent[k][v]){\n        u=parent[k][u];\n        v=parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n;\n  cin>>n;\n  WG<int> es(n);\n  rep(i,n){\n    int k;\n    cin>>k;\n    rep(j,k){\n      int x;\n      cin>>x;\n      es[i].PB(edge<int>(x,1));\n    }\n  }\n\n  LCA lca(n,es);\n  lca.construct();\n  int q;\n  cin>>q;\n  while(q--){\n    int x,y;\n    cin>>x>>y;\n    cout<<lca.lca(x,y)<<endl;\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\n// tree\nvector<int> adjList[MAXN];\nint size[MAXN];         // [i] = size of subtree rooted as node i\nint par[MAXN];          // [i] = parent node of node i\nint height[MAXN];       // [i] = distance of root to node i\n\nint segcount;                // number of segments\nint seg[MAXN];               // [i] = segment of node i\nint segroot[MAXN];           // [s] = root node of segment s\nint segdepth[MAXN];          // [i] = number of segments node i has to pass to reach root\nint segitempos[MAXN];        // [i] = position of node i in its segment\nvector<int> segitem[MAXN];   // [s] = list of node in segment s;\n\nint get_size(int x, int p) {\n    par[x] = p, size[x] = 1;\n    \n    for (vector<int>::iterator it = adjList[x].begin(); it != adjList[x].end(); ++it) {\n        if (*it == p) continue;\n        \n        size[x] += get_size(*it, x);\n    }\n\n    return size[x];\n}\n\nvoid build(int x, int _seg, int _depth = 0, int _height = 0) {\n    height[x] = _height;\n    \n    seg[x] = _seg;\n    segdepth[x] = _depth;\n    \n    segitempos[x] = segitem[_seg].size(); segitem[_seg].push_back(x);\n    \n    // find special child\n    int largest = -1;\n    for (vector<int>::iterator it = adjList[x].begin(); it != adjList[x].end(); ++it) {\n        if (*it == par[x]) continue;\n        if (largest == -1 || size[largest] < size[*it]) largest = *it;\n    }\n    if (largest == -1) return;\n    \n    build(largest, _seg, _depth, _height + 1);\n    \n    for (vector<int>::iterator it = adjList[x].begin(); it != adjList[x].end(); ++it) {\n        if (*it == largest || *it == par[x]) continue;\n        \n        segroot[++segcount] = x;\n        build(*it, segcount, _depth + 1, _height + 1);\n    }\n}\n\nint lca (int a, int b) {\n    if (a == b) return a;\n\n    if (seg[a] == seg[b]) {         // same segment\n        if (height[a] < height[b])\n            return a;\n        else\n            return b;\n    }\n\n    if (segdepth[a] > segdepth[b])          // segment a is above segment b\n        return lca(segroot[seg[a]], b);\n    else if (segdepth[a] < segdepth[b])     // segment a is under segment b\n        return lca(a, segroot[seg[b]]);\n    else                                    // same depth\n        return lca(segroot[seg[a]], segroot[seg[b]]);\n}\n\nint main () {\n\n    int N, Q;\n    scanf(\"%d\",&N);\n\n    for (int u = 0, M; u < N; u++) {\n        scanf(\"%d\",&M);\n        for (int i = 0, v; i < M; i++) {\n            scanf(\"%d\",&v);\n            adjList[u].push_back(v);\n        }\n    }\n    \n    int root = 0;\n    get_size(root, -1);\n    build(root, segcount);\n    \n    scanf(\"%d\", &Q);\n    for (int i = 0, u, v; i < Q; ++i) {\n        scanf(\"%d%d\", &u, &v);\n\n        printf(\"%d\\n\",lca(u,v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nsigned main(){\n    // cout << fixed << setprecision(10) << flush;\n\n    int n;\n    cin >> n;\n    \n    // par[i] は i のすぐ上の親\n    vector<int> par(n);\n    par[0] = -1;\n    // dep[i] は 0 を 0 としたときの i の深さ\n    vector<int> dep(n);\n    dep[0] = 0;\n    for(int i=0; i<n; i++){\n        int k;\n        cin >> k;\n        for(int j=0; j<k; j++){\n            int c;\n            cin >> c;\n            par[c] = i;\n            dep[c] = dep[i] + 1;\n        }\n    }\n\n    int klim = (int)log2(n)+1;\n    // kpar[k][i] は i の 2^k 上の親、kpar[0][i] = par[i]\n    vector<vector<int>> kpar(klim, vector<int>(n, -1));\n    for(int i=0; i<n; i++){\n        kpar[0][i] = par[i];\n    }\n    \n    for(int k=1; k<klim; k++){\n        for(int i=0; i<n; i++){\n            if(kpar[k-1][i] != -1){\n                kpar[k][i] = kpar[k-1][kpar[k-1][i]];\n            }\n        }\n    }\n\n    int q;\n    cin >> q;\n    vector<int> ans(q);\n    for(int qu=0; qu<q; qu++){\n        int u, v;\n        cin >> u >> v;\n        if(dep[u] < dep[v]){\n            int t = u;\n            u = v;\n            v = t;\n        }\n        // u を v と同じ高さまで持ち上げる\n        int dd = dep[u] - dep[v];\n        for(int k=0; k<klim; k++){\n            if((dd & (1<<k)) == (1<<k)){\n                u = kpar[k][u];\n            }\n        }\n\n        if(u == v){\n            ans[qu] = u;\n        }\n        // 二分探索\n        else{\n            for(int k=klim-1; k>=0; k--){\n                int pu = kpar[k][u];\n                int pv = kpar[k][v];\n                if(pu != pv){\n                    u = pu;\n                    v = pv;\n                }\n            }\n            ans[qu] = par[u];\n        }\n    }\n    \n    for(int i=0; i<q; i++){\n        cout << ans[i] << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**C++**/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pint;\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n#define rep(i, n) for(ll i = ll(0); i < ll(n); i++)\n#define Rep(i, n) for(ll i = ll(1); i < ll(n); i++)\n#define ALL(a)  (a).begin(),(a).end()\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define PI 3.14159265358979323846\n#define ifYN(x) cout<<(x?\"Yes\":\"No\")<<\"\\n\" \nll fac[MAX], finv[MAX], inv[MAX];\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool palindrome(string s){\n  bool flag=true;\n  rep(i,(ll)s.size()) if(s[i]!=s[s.size()-1-i]) flag=false;\n  return flag;\n}\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n\n}\nll Len(ll n) {\n  ll s=0;\n  while(n!=0) s++, n/=10;\n  return s;\n}\n\n\nll Sint(ll n) {\n  ll ans=0;\n  while(n!=0) ans+=n%10,n/=10;\n  return ans;\n}\n\nll Svec(vector<ll> v){\n  ll n=0;\n  rep(i,(ll)v.size()) n+=v[i];\n  return n;\n}\n\n\nll GCD(ll a,ll b) {\n  return b ? GCD(b,a%b) : a;\n}\n\n\nll LCM(ll a,ll b){\n  return a/GCD(a,b)*b;\n}\n\n\nll Factorial(ll n){\n  ll m=1;\n  while(n>=1) m*=n,n--;\n  return m;\n}\n\nvoid runlength(string s,vector<pair<char,ll>> &p){\n  ll x=1;\n  if(s.size()==1){\n    p.push_back(pair<char,ll>(s[0],1));\n  }\n  rep(i,(ll)s.size()-1){\n    if(s[i]==s[i+1]){\n      x++;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[i],x));\n      }\n    }else{\n      p.push_back(pair<char,ll>(s[i],x));\n      x=1;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[s.size()-1],x));\n      }\n    }\n  }\n}\n\nll COM(ll n,ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstring Toupper(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('a'<=s[i] && s[i]<='z') ans+=(char)s[i]-32;\n    else ans+=s[i];\n  }\n  return ans;\n}\nstring Tolower(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('A'<=s[i] && s[i]<='Z') ans+=(char)s[i]+32;\n    else ans+=s[i];\n  }\n  return ans;\n}\n\nvoid dis(vector<ll> v){ rep(i,v.size()) cout<<v[i]<<endl; }\n\nvoid dis2(vector<vector<ll>> v){\n  rep(i,v.size()){\n    rep(j,v[0].size()) cout<<v[i][j]<<' ';\n    cout<<endl;\n  }\n}\n\nconst int MAX_N=100010;\nvector<bool> sieve_of_eratosthenes(){\n  vector<bool> isPrime(MAX_N+1,true);\n  /* isPrime[1]=false; */\n  for(int i=2;i<=MAX_N;i++){\n    if(isPrime[i]){\n      for(int j=2*i;j<=MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n  return isPrime;\n}\n\nvector<pint> prime_factorize(ll n){\n  vector<pint> ans;\n  for(ll p=2;p<=sqrt(n);p++){\n    if(n%p!=0) continue;\n    ll cnt=0;\n    while(n%p==0){\n      n/=p;\n      cnt++;\n    }\n    ans.push_back(make_pair(p,cnt));\n  }\n  if(n!=1) ans.push_back(make_pair(n,1));\n  return ans;\n}\n\n/*bool cmp(pint a, pint b) { return a.second < b.second; }*/\nvector<ll> g[100010];\nll parent[40][100010];\nll depth[100010];\n\nvoid dfs(ll n,ll p,ll d){\n  parent[0][n]=p;\n  depth[n]=d;\n  for(auto c:g[n]) if(c!=p) dfs(c,n,d+1);\n}\n\nvoid init(ll n){\n  dfs(0,-1,0);\n  rep(i,39) rep(j,n){\n    if(parent[i][j]<0) parent[i+1][j]=-1;\n    else parent[i+1][j]=parent[i][parent[i][j]];  \n  }\n}\n\nll lca(ll u,ll v){\n  if(depth[u]>depth[v]) swap(u,v);\n  rep(i,40) if((depth[v]-depth[u])>>i&1) v=parent[i][v];\n  if(u==v) return u;\n  for(ll i=39;i>=0;i--){\n    if(parent[i][u]!=parent[i][v]){\n      u=parent[i][u];\n      v=parent[i][v];\n    }\n  }\n  return parent[0][u];\n}\n\n/*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/\nint main() {\n  IOS;\n  ll n;cin>>n;\n  rep(i,n){\n    ll a;cin>>a;\n    rep(j,a){\n      ll b;cin>>b;\n      g[i].push_back(b);\n    }\n  }\n  init(n);\n  ll q;cin>>q;\n  rep(i,q){\n    ll a,b;cin>>a>>b;\n    cout<<lca(a,b)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\ntemplate <typename T>\nclass SparseTable {\n\tint n;\n\tvector<vector<T>> t;\n\tT merge(const T& l, const T& r) {\n\t\treturn min(l, r);\n\t}\npublic:\n\tSparseTable(const vector<T>& b) {\n\t\tn = b.size();\n\t\tt.push_back(b);\n\t\tfor (int i = 2, j = 1; i <= n; i <<= 1, j++) {\n\t\t\tt.push_back(vector<T>());\n\t\t\tfor (int k = 0; k + i <= n; k++) {\n\t\t\t\tt[j].push_back(merge(t[j - 1][k], t[j - 1][k + i / 2]));\n\t\t\t}\n\t\t}\n\t}\n\tT find(int l, int r) {\n\t\tr++;\n\t\tassert(0 <= l && l < r && r <= n);\n\t\tunsigned int w = r - l;\n\t\tint i = 31 - __builtin_clz(w);\n\t\treturn merge(t[i][l], t[i][r - (1 << i)]);\n\t}\n\tT operator[](int id) {\n\t\treturn t[0][id];\n\t}\n};\n\nclass LCA {\n\tint V, rt;\n\tvector<vector<int>> G;\n\tvector<int> depth, used, id;\n\tvector<int> vs, de;\n\tSparseTable<pii> st;\n\tvoid dfs(int s, int d) {\n\t\tused[s] = 1;\n\t\tvs.push_back(s);\n\t\tde.push_back(d);\n\t\tfor (int v : G[s]) {\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t\tvs.push_back(s);\n\t\t\t\tde.push_back(d);\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> init() {\n\t\tdfs(rt, 0);\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tif (id[vs[i]] == -1) id[vs[i]] = i;\n\t\t}\n\t\tvector<pii> r((int)vs.size());\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tr[i] = pii(de[i], vs[i]);\n\t\t}\n\t\treturn r;\n\t}\npublic:\n\tLCA(vector<vector<int>> G_, int rt_ = 0)\n\t\t: V(G_.size()), rt(rt_), G(G_), depth(V), used(V), id(V, -1), st(init()) {\n\t\tfor (int i = 0; i < V; i++) depth[i] = st[id[i]].first;\n\t}\n\tint calc(int a, int b) {\n\t\treturn st.find(min(id[a], id[b]), max(id[a], id[b])).second;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n;\n\tvector<vector<int>> G(n);\n\tfor (int i = 0, k; i < n; i++) {\n\t\tcin >> k;\n\t\tfor (int j = 0, c; j < k; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c > i) {\n\t\t\t\tG[i].push_back(c);\n\t\t\t\tG[c].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tLCA lca(G);\n\tcin >> q;\n\tfor (int i = 0, u, v; i < q; i++) {\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_V 1010000\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n//RMQ\n\nint rn;\nii dat[2*MAX_V-1];\nvoid init(int n_){\n  rn = 1;\n  while(rn<n_)rn*=2;\n  for(int i=0;i<2*rn-1;i++)dat[i] = ii(IINF,IINF);//ii(depth,index)\n}\n \n// k番めの値(0-indexed)をaに変更\nvoid update(int k,ii a){\n  k += rn-1;\n  dat[k] = a;\n  while(k > 0){\n    k = (k-1)/2;\n    dat[k] = (dat[k*2+1].first>dat[k*2+2].first?dat[k*2+2]:dat[k*2+1]);\n  }\n}\n\nii _query(int a,int b,int k,int l,int r){\n  if(r<=a || b<=l)return ii(IINF,-1);\n  else if(a<=l && r<=b)return dat[k];\n  \n  ii vl = _query(a,b,k*2+1,l,(l+r)/2);\n  ii vr = _query(a,b,k*2+2,(l+r)/2,r);\n  \n  return min(vl,vr);\n}\n\n//nの範囲でミスしないように極力こっちを利用 \nii query(int a,int b){\n  return _query(a,b,0,0,rn);\n}\n\n//\n\nint V;\nvector<int> G[MAX_V];\nint root;\n\nint vs[MAX_V*2-1];\nint depth[MAX_V*2-1];\nint id[MAX_V];\n\nvoid dfs(int v,int p,int d,int &k){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  for(int i=0;i<G[v].size();i++){\n    if(G[v][i] != p){\n      dfs(G[v][i],v,d+1,k);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid RQMinit(){\n  int k = 0;\n  dfs(root,-1,0,k);\n  \n  init(k+1);  \n  rep(i,k)update(i,ii(depth[i],vs[i]));\n}\n\nint lca(int u,int v){\n  return query(min(id[u],id[v]),max(id[u],id[v])+1).second;\n}\n\n\nint main(){\n  int n;\n  cin >> n;\n  V = n;\n  rep(i,V){\n    int k,c;\n    cin >> k;\n    rep(j,k){\n      cin >> c;\n      G[i].push_back(c);\n      G[c].push_back(i);\n    }\n  }\n\n  RQMinit();\n  int q,u,v;\n  cin >> q;\n  rep(i,q){\n    cin >> u >> v;\n    cout << lca(u,v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 310;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        // assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")\n// #pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nstruct HeavyLightDecomposition{\n    int n;\n    vector<int> size, par, in, in_rev, heavy_root, depth, heavy_depth;\n    vector<vector<int>> childs;\n    HeavyLightDecomposition(vector<vector<int>>& edges, int root = 0) : n(edges.size()), size(n, 1), par(n, -2), depth(n, 0), childs(n), in(n), in_rev(n), heavy_root(n), heavy_depth(n, 0){\n        function<void(int)> swap_dfs = [&](int x){\n            int size_max = 0;\n            int max_idx = 0;\n            for(int i = 0; i < edges[x].size(); ++i){\n                int y = edges[x][i];\n                if(par[y] == -2){\n                    par[y] = x;\n                    depth[y] = depth[x] + 1;\n                    childs[x].push_back(y);\n                    swap_dfs(y);\n                    size[x] += size[y];\n                    if(chmax(size_max, size[y])){\n                        max_idx = childs[x].size() - 1;\n                    }\n                }\n            }\n            if(max_idx){\n                swap(childs[x][0], childs[x][max_idx]);\n            }\n        };\n        par[root] = -1;\n        swap_dfs(root);\n\n        int cnt = 0;\n        function<void(int,int)> dfs = [&](int x, int segment_root){\n            heavy_root[x] = segment_root;\n            in_rev[cnt] = x;\n            in[x] = ++cnt;\n            for(int i = 0; i < childs[x].size(); ++i){\n                int y = childs[x][i];\n                if(i == 0){\n                    dfs(y, segment_root);\n                }\n                else{\n                    heavy_depth[y] = heavy_depth[segment_root] + 1;\n                    dfs(y, y);\n                }\n            }\n        };\n        dfs(root, root);\n    }\n    int lca(int x, int y){\n        while(heavy_root[x] != heavy_root[y]){\n            if(get_heavy_depth(x) > get_heavy_depth(y))\n                swap(x, y);\n            y = par[heavy_root[y]];\n        }\n        return depth[x] < depth[y] ? x : y;\n    }\n    // 頂点xがEuler-Tour上で何番目に位置するかを返す\n    // in[元の頂点index] = 内部でのindex\n    // in_rev[内部でのindex] = 元の頂点index\n    int get_idx(int x){\n        return in[x];\n    }\n    // xが属するHeavy-Pathの深さを返す\n    int get_heavy_depth(int x){\n        return heavy_depth[heavy_root[x]];\n    }\n};\n\nsigned main(){\n\n    int n;\n    cin >> n;\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < n; ++i){\n        int cnt;\n        cin >> cnt;\n        for(int j = 0; j < cnt; ++j){\n            int k;\n            cin >> k;\n            edges[i].push_back(k);\n            edges[k].push_back(i);\n        }\n    }\n    HeavyLightDecomposition hld(edges);\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        int a, b;\n        cin >> a >> b;\n        cout << hld.lca(a, b) << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X)\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto xXx:v)cerr<<xXx<<' ';cerr<<endl;\n#define INF 1000000007\n#define LINF 1000000000000000007\n#define Yes(X) if(X){cout<<\"Yes\"<<endl;}else{cout<<\"No\"<<endl;}\n#define YES(X) if(X){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define ctoi(C) (C-'0')\ntypedef long long ll;\ntypedef long double ld;\nlong long dx[] = {1,0,-1,0};\nlong long dy[] = {0,1,0,-1};\nlong long dx8[] = {1,1,0,-1,-1,-1,0,1};\nlong long dy8[] = {0,1,1,1,0,-1,-1,-1};\nlong long dx9[] = {1,1,0,-1,-1,-1,0,1,0};\n\nstruct Graph{\n  long long V;\n  long long E;\n  //u,v,weight,cap\n  vector<tuple<long long,long long,long long,long long>> edges;\n  void add(long long u,long long v){edges.push_back(make_tuple(u,v,1,1));}\n  void add(long long u,long long v,long long weight){edges.push_back(make_tuple(u,v,weight,1));}\n  void add(long long u,long long v,long long weight,long long capacity){edges.push_back(make_tuple(u,v,weight,capacity));}\n};\n\nstruct HLD{\n    Graph G;\n    ll root;\n    vector<ll> DFS;\n    vector<ll> subtree;\n    vector<ll> pre;\n\n    ll dfs(ll n,const vector<vector<pair<ll,ll>>> &adj){\n        DFS[n] = 0;\n        ll ans = 1;\n        for(auto p:adj[n]){\n            if(DFS[p.first] == -1){\n                ans += dfs(p.first,adj);\n                pre[p.first] = n;\n            }\n        }\n        return DFS[n] = ans;\n    }\n\n    void HLdfs(ll n,ll r,const vector<vector<pair<ll,ll>>> &adj){\n        subtree[n] = r;\n        ll MAX = 0;\n        bool flag = true;\n        for(auto p:adj[n]){\n            if(DFS[p.first] < DFS[n]){\n                MAX = max(DFS[p.first],MAX);\n            }\n        }\n        for(auto p:adj[n]){\n            if(MAX == DFS[p.first] && flag){\n                HLdfs(p.first,r,adj);\n                flag = false;\n            }\n            else if(DFS[p.first] < DFS[n]){\n                HLdfs(p.first,p.first,adj);\n            }\n        }\n    }\n\n    void depthdfs(ll n,ll pre,ll depth,const vector<vector<pair<ll,ll>>> &adj){\n        DFS[n] = depth;\n        for(auto p:adj[n]){\n            if(p.first != pre){\n                depthdfs(p.first,n,depth+p.second,adj);\n            }\n        }\n    }\n\n    ll lca(ll u,ll v){\n        while(subtree[u] != subtree[v]){\n            if(DFS[subtree[u]] < DFS[subtree[v]]){\n                v = pre[subtree[v]];\n            }\n            else{\n                u = pre[subtree[u]];\n            }\n        }\n        return (DFS[u] < DFS[v] ? u : v);\n    }\n\n    ll dist(ll u,ll v){\n        ll LCA = lca(u,v);\n        return DFS[u]+DFS[v]-2*DFS[LCA];\n    }\n\n    HLD(Graph G,ll root = 0) : G(G),root(root) {\n        vector<vector<pair<ll,ll>>> adj;\n        adj.resize(G.V);\n        DFS.resize(G.V);\n        pre.resize(G.V);\n        subtree.resize(G.V);\n        fill(ALL(DFS),-1);\n        for(auto t:G.edges)adj[get<0>(t)].push_back(make_pair(get<1>(t),get<2>(t)));\n        dfs(root,adj);\n        HLdfs(root,root,adj);\n        depthdfs(root,root,1,adj);\n    }\n};\n\nsigned main(){\n    int n;\n    cin >> n;\n    Graph G;\n    G.V = n;\n    FOR(i,0,n){\n        int k;\n        cin >> k;\n        FOR(j,0,k){\n            int c;\n            cin >> c;\n            G.add(i,c);\n            G.add(c,i);\n        }\n    }\n    HLD hld(G);\n    int q;\n    cin >> q;\n    FOR(i,0,q){\n        int u,v;\n        cin >> u >> v;\n        cout << hld.lca(u,v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nstruct min_index_monoid {\n    using P = pair<T, int>;\n    using value_type = P;\n    P identity() { return make_pair(numeric_limits<T>::max(), INT_MAX); }\n    P merge(P a, P b) { return min(a, b); }\n};\n\ntemplate <typename Monoid>\nstruct SegmentTree {\n    using T = typename Monoid::value_type;\n\n    int n;\n    vector<T> data;\n    Monoid monoid;\n\n    SegmentTree() {}\n    SegmentTree(int _n, const Monoid& _monoid = Monoid()) : monoid(_monoid) {\n        n = 1;\n        while (n < _n) n <<= 1;\n        data.assign(n << 1, monoid.identity());\n    }\n    // with initialization of given data\n    template <class InputIterator>\n    SegmentTree(InputIterator first, InputIterator last,\n                const Monoid& _monoid = Monoid())\n        : monoid(_monoid) {\n        int size = distance(first, last);\n        n = 1;\n        while (n < size) n <<= 1;\n        data.assign(n << 1, monoid.identity());\n        copy(first, last, begin(data) + n);\n        for (int i = n - 1; i > 0; i--) {\n            data[i] = monoid.merge(data[i << 1], data[i << 1 | 1]);\n        }\n    }\n\n    void update(int k, T x) {\n        assert(0 <= k && k < n);\n        k += n;\n        data[k] = x;\n        for (int i = k >> 1; i > 0; i >>= 1) {\n            data[i] = monoid.merge(data[i << 1], data[i << 1 | 1]);\n        }\n    }\n    // [a, b)\n    T query(int a, int b) {\n        assert(0 <= a && a <= b && b <= n);\n        a += n;\n        b += n - 1;\n        T vl = monoid.identity(), vr = monoid.identity();\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) vl = monoid.merge(vl, data[l++]);\n            if (r & 1) vr = monoid.merge(data[--r], vr);\n        }\n        return monoid.merge(vl, vr);\n    }\n};\n\nstruct LowestCommonAncestor {\n    using P = pair<int, int>;\n\n    int n;\n    vector<int> idx;\n    vector<P> euler_tour;\n    vector<vector<int>> g;\n    SegmentTree<min_index_monoid<int>> seg;\n\n    LowestCommonAncestor(int _n) : n(_n), idx(_n), g(_n) {}\n\n    void add_edge(int s, int t) {\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    void build(int r) {\n        dfs(r, -1, 0);\n        seg = SegmentTree<min_index_monoid<int>>(begin(euler_tour), end(euler_tour));\n    }\n    void dfs(int u, int par, int dep) {\n        idx[u] = euler_tour.size();\n        euler_tour.push_back({dep, u});\n        for (auto&& v : g[u]) {\n            if (v == par) continue;\n            dfs(v, u, dep + 1);\n            euler_tour.push_back({dep, u});\n        }\n    }\n    int query(int u, int v) {\n        assert(0 <= u && u < n);\n        assert(0 <= v && v < n);\n        int i = idx[u];\n        int j = idx[v];\n        if (i > j) swap(i, j);\n        return seg.query(i, j + 1).second;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        while (k--) {\n            int c;\n            cin >> c;\n            g.add_edge(i, c);\n        }\n    }\n    g.build(0);\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << g.query(u, v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pinf 0x7FFFFFFF\nusing namespace std;\n\nclass Graph {\n  private:\n    int V;\n    vector <vector <int>> adj;\n    vector <int> first;\n    vector <int> height;\n    vector <int> euler;\n    void eulerUtil(int u, bool visited[], int h);\n    vector <int> seg;\n    void build(int idx, int ss, int se);\n    int lca_query(int idx, int ss, int se, int qs, int qe);\n  public:\n    Graph(int n);\n    void addEdge(int u, int v);    \n    void euler_tour();\n    void buildrmq();\n    int lca(int u, int v);\n};\n\nGraph::Graph(int n) {\n  this->V = n;\n  adj.resize(n);\n  first.resize(n);\n  height.resize(n);\n}\n\nvoid Graph::addEdge(int u, int v) {\n  adj[u].push_back(v);\n}\n\nvoid Graph::eulerUtil(int u, bool visited[], int h) {\n  visited[u] = true;\n  first[u] = euler.size();\n  height[u] = h;\n  euler.push_back(u);\n\n  for (int i = 0; i < (int) adj[u].size(); i++) {\n    int v = adj[u][i];\n    if (!visited[v]) {\n      eulerUtil(v, visited, h + 1);\n      euler.push_back(u);\n    }\n  }\n}\n\nvoid Graph::euler_tour() {\n  bool visited[V];\n  fill(visited, visited + V, false);\n  eulerUtil(0, visited, 0);\n}\n\n\nvoid Graph::build(int idx, int ss, int se) {\n  if (ss == se) {\n    seg[idx] = euler[ss];\n    return;\n  }\n\n  int m = (ss + se) / 2;\n  build(2 * idx, ss, m);\n  build(2 * idx + 1, m + 1, se);\n  //..store information based on the depth to be minimum in range\n\n  seg[idx] = height[seg[2 * idx]] < height[seg[2 * idx + 1]] ? seg[2 * idx] : seg[2 * idx + 1];\n}\n\nvoid Graph::buildrmq() {\n  int n = euler.size();\n  seg.resize(4 * n);\n  build(1, 0, n - 1);  \n} \n\nint Graph::lca_query(int idx, int ss, int se, int qs, int qe) {\n  if (qs > qe) {\n    return pinf;\n  }\n  if (ss == qs && se == qe) {\n    return seg[idx];\n  }\n  int m = (ss + se) / 2;\n  int l = lca_query(2 * idx, ss, m, qs, min(m, qe));\n  int r = lca_query(2 * idx + 1, m + 1, se, max(m + 1, qs), qe);\n  if (l == pinf) {\n    return r;\n  } else if (r == pinf) {\n    return l;\n  } else {\n    return height[l] < height[r] ? l : r;\n  }\n}\n\nint Graph::lca(int u, int v) {\n  int qs = first[u];\n  int qe = first[v];\n  if (qs > qe) {\n    swap(qs, qe);\n  }   \n  int n = euler.size();\n  return lca_query(1, 0, n - 1, qs, qe);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  Graph g(n);\n  int k, v;\n  for (int u = 0; u < n; u++) {\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      cin >> v;\n      //..v is children of u and 0 is the root of this tree\n      g.addEdge(u, v);   \n    } \n  }\n  g.euler_tour();\n  g.buildrmq();\n\n  int q, ui, vi;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    cin >> ui >> vi;\n    cout << g.lca(ui, vi) << '\\n';\n  } \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, ans, sum, last, cnt;\nstruct Edge { LL to,cost; };\nvector<Edge>vec[100010];\nstring str;\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node, num;\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tvec[u].erase(vec[u].begin()+j);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n\nclass RMQ{//RangeMinimumQuery\n\tint n;\n\tstd::vector<int> dat,idx;\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return dat.size()-1;\n\t\tif(a<=l&&r<=b)return idx[k];\n\t\telse{\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn dat[vl]<dat[vr]?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQ(){}\n\t~RMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tn=calcsize(a.size());\n\t\tidx.resize(2*n-1);\n\t\tfor(int i=0;i<(int)a.size();i++)idx[n-1+i]=i;\n\t\tfor(int i=a.size();i<n;i++)idx[n-1+i]=a.size();\n\t\tdat=a;\n\t\tdat.push_back(INT_MAX);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tidx[i]=dat[idx[i*2+1]]<dat[idx[i*2+2]]?idx[i*2+1]:idx[i*2+2];\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\nclass LCA{\n\tvector<pair<int,int> > eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\tRMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u].first=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\teulertour[edge[u][i]].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\teulertour[root].second=vertex.size();\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u].first<eulertour[v].first && eulertour[v].second<eulertour[u].second)\n\t\t\treturn u;\n\t\tif(eulertour[v].first<eulertour[u].first && eulertour[u].second<eulertour[v].second)\n\t\t\treturn v;\n\t\tif(eulertour[u].first>eulertour[v].first)swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u].second, eulertour[v].first)];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nint h, w, n, m, k, s, t, q, ans, sum, last, cnt;\nstruct Edge { int to,cost; };\nvector<Edge>vec[100010];\nstring str;\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<int>node, num;\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tvec[u].erase(vec[u].begin()+j);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst int MAX_N = 100010;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n * n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int par, int d, int &k){\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(G[v][i] != par){\n                    dfs(G[v][i], v, d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, -1, 0, k);\n            rmqInit(depth,k * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass LCA {\nprivate:\n    static const int MAX_LOG = 20;\n    const int n;\n    Graph G;\n    V depth;\n    VV par;\n    V cnt; // ?????????????????£????????°\npublic:\n    LCA(int _n) : n(_n), G(_n), par(MAX_LOG, V(_n)), depth(_n), cnt(_n) {}\n    // undirected\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n    // ??????????????±?????¨???1????????????????±???????\n    void dfs(int v, int p, int d) {\n        cerr << v << \" \" << p << \" \" << d << endl;\n        par[0][v] = p;\n        depth[v] = d;\n        for (auto nxt : G[v]) {\n            if (nxt != p) {\n                dfs(nxt, v, d + 1);\n            }\n        }\n    }\n    // ????????????2^k????????????????±?????????????\n    void setPar() {\n        // 0????????¨??????1????????????????±???????\n        dfs(0, -1, 0);\n\n        // 2^i????????????????±???????\n        rep(i, MAX_LOG - 1) {\n            rep(j, n) {\n                if (par[i][j] == -1) {\n                    par[i + 1][j] = -1;\n                } else {\n                    par[i + 1][j] = par[i][par[i][j]];\n                }\n            }\n        }\n    }\n    int lca(int a, int b) {\n        // ??????a??¨b?????±???????????????\n        if (depth[a] > depth[b]) {\n            swap(a, b);\n        }\n        rep(i, MAX_LOG) {\n            if ((depth[b] - depth[a]) >> i & 1) {\n                b = par[i][b];\n            }\n        }\n        if (a == b) return a;\n\n        // ??¶???????????´????????§a, b????????????\n        rrep(i, MAX_LOG) {\n            if (par[i][a] != par[i][b]) {\n                a = par[i][a];\n                b = par[i][b];\n            }\n        }\n        // a??¨b???1????????????????????´????????????\n        return par[0][a];\n    }\n\n    void updateCnt(int u, int v) {\n        cnt[u]++;\n        cnt[v]++;\n        int w = lca(u, v);\n        cnt[w]--;\n        if (par[0][w] != -1) cnt[par[0][w]]--;\n    }\n    int imosFinal(int v, int p) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            t += imosFinal(nxt, v);\n        }\n        cnt[v] += t;\n        return cnt[v];\n    }\n    int answer() {\n        imosFinal(0, -1);\n        int ans = 0;\n        for (auto&& x : cnt) {\n            ans += (x + 1) * x / 2;\n        }\n        return ans;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    scanf(\"%lld\", &n);\n    LCA lca(n);\n    rep(i, n) {\n        int k;\n        scanf(\"%lld\", &k);\n        rep(j, k) {\n            int c;\n            scanf(\"%lld\", &c);\n            lca.addEdge(i, c);\n        }\n    }\n\n    lca.setPar();\n\n    int Q;\n    scanf(\"%lld\", &Q);\n    rep(i, Q) {\n        int u, v;\n        scanf(\"%lld%lld\", &u, &v);\n        printf(\"%lld\\n\", lca.lca(u, v));\n    }\n}\n\n// signed main() {\n//     std::ios::sync_with_stdio(false);\n//     std::cin.tie(0);\n//\n//     int N;\n//     cin >> N;\n//     LCA lca(N);\n//     rep(i, N) {\n//         int u, v;\n//         cin >> u >> v;\n//         u--, v--;\n//         lca.addEdge(u, v);\n//     }\n//\n//     cerr << \"hey!\" << endl;\n//\n//     lca.setPar();\n//\n//     cerr << \"hey!\" << endl;\n//\n//     int Q;\n//     cin >> Q;\n//     rep(i, Q) {\n//         int u, v;\n//         cin >> u >> v;\n//         u--, v--;\n//         lca.updateCnt(u, v);\n//     }\n//\n//     cerr << \"hey!\" << endl;\n//\n//     cout << lca.answer() << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n\n\n\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n//*/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\n#define INF (1 << 30)\nusing namespace std;\n\nvector<int> index(100010);  \nvector<bool> f(100010, false);\nvector<vector<int>> T(100010); //??°??????\nvector<P> ET;              //??????????????¨\n\n//??°???????????????????????¨????????????index?????¨??????????´??????????????????¨?????????????????????????????????????????????\n//ET : 2n - 1 ?????????????????¨??? (??±??????????´???????????????????\nvoid dfs(int n,int dep) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tindex[n] = ET.size() - 1;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1);\n\t\tET.emplace_back(make_pair(dep,n));\n\t}\n}\n\nP RMQ(int a, int b, int k, int l, int r,vector<P>& node) {\n\tif (r <= a || b <= l)return make_pair(INF, 0);\n\tif (a <= l && r <= b) { return node[k]; }\n\tP vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);\n\tP vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r,node);\n\n\tif (vl.first > vr.first) {\n\t\treturn vr;\n\t}\n\telse { return vl; }\n}\n\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n_; cin >> n_;\n\tvector<int> v(n_);\n\tfor (int i = 0; i < n_; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n  LowestCommonAncestor(size_t size) : size(size), MaxlgV(32 - __builtin_clz(size - 1)), G(size), dep(size), par(MaxlgV, vector<int>(size)) {}\n\n  size_t size, MaxlgV;\n  int root;\n  vector<vector<int>> G, par;\n  vector<int> dep;\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int u, int d) {\n    dep[v] = d;\n    par[0][v] = u;\n    for (int e : G[v])\n      if (e != u) dfs(e, v, d + 1);\n  }\n\n  void build(int r) {\n    dfs(root = r, -1, 0);\n    for (int k = 0; k + 1 < MaxlgV; k++) {\n      for (int v = 0; v < size; v++) {\n        if (par[k][v] < 0)\n          par[k + 1][v] = -1;\n        else\n          par[k + 1][v] = par[k][par[k][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (dep[u] > dep[v]) swap(u, v);\n    for (int k = 0; k < MaxlgV; k++) {\n      if ((dep[v] - dep[u]) >> k & 1) {\n        v = par[k][v];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int k = MaxlgV - 1; k >= 0; k--) {\n      if (par[k][u] != par[k][v]) {\n        u = par[k][u];\n        v = par[k][v];\n      }\n    }\n\n    return par[0][u];\n  }\n\n  int dist(int u, int v) {\n    int z = lca(u, v);\n    return dep[u] + dep[v] - 2 * dep[z];\n  }\n};\n\n// https://onlinejudge.u-aizu.ac.jp/#/courses/library/5/GRL/5/GRL_5_C\nint main() {\n  int N;\n  cin >> N;\n\n  LowestCommonAncestor tree(N);\n  for (int i = 0; i < N; ++i) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int c;\n      cin >> c;\n\n      tree.add_edge(i, c);\n    }\n  }\n\n  tree.build(0);\n\n  int q;\n  cin >> q;\n\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n\n    cout << tree.lca(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(logN+1, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// I SELL YOU...! \n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<chrono>\n#include<iomanip>\n#include<map>\n#include<set>\n#include<bitset>\n#define MAX_N 1100000\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll,ll>;\nvector<ll> vs(MAX_N*2),depth(MAX_N*2,-1),id(MAX_N),par(MAX_N,-1);\nvector<ll> sum(MAX_N),rm(MAX_N);\nvector<ll> G[MAX_N];\nvoid init_io(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(10);\n}\ntemplate <typename Monoid >\nstruct SegmentTree{\n  using F = function< Monoid(Monoid,Monoid) >;\n\n  ll sz;\n  vector<Monoid> seg;\n\n  const F f;\n  const Monoid M;\n\n  SegmentTree(ll n,const F f,const Monoid &M) : f(f),M(M){\n    sz = 1;\n    while(sz<n) sz<<=1;\n    seg.assign(sz*2,M);\n  }\n  void set(ll k,const Monoid &v){\n    seg[k+sz] = v;\n  }\n  void build(){\n    for(ll k=sz-1;k>0;k--){\n      seg[k] = f(seg[2*k],seg[2*k+1]);\n    }\n  }\n  void update(ll k,const Monoid &v){\n    k += sz;\n    seg[k] = v;\n    while(k >>= 1){\n      seg[k] = f(seg[2*k],seg[2*k+1]);\n    }\n  }\n  Monoid que(ll a,ll b){\n    Monoid L=M,R=M;\n    for(a+=sz, b+=sz;a<b;a>>=1,b>>=1){\n      if(a&1) L = f(L,seg[a++]);\n      if(b&1) R = f(seg[--b],R);\n    }\n    return f(L,R);\n  }\n  Monoid operator[](const ll &k) const{\n    return seg[k+sz];\n  }\n};\nll tmp;\nvoid dfs(ll v,ll prev,ll d,ll &c){\n  par[v] = prev;\n  id[v] = c;\n  vs[c] = v;\n  depth[c] = d;\n  c++;\n  for(auto nv:G[v]){\n    if(nv!=prev){\n      dfs(nv,v,d+1,c);\n      vs[c] = v;\n      depth[c] = d;\n      c++;\n    }\n  }\n}\nsigned main(){\n  init_io();\n  ll n,ans=1;\n  cin >> n;\n  ll q;\n  vector<ll> a(n-1),b(n-1),reaf;\n  SegmentTree<P> seg(n*2,[](P a,P b)\n      {\n      if(a.first<b.first) return a;\n      else return b;\n      },P(10000000,-1));\n  for(int i=0;i<n-1;i++){\n    ans *= 2;\n  }\n  for(ll i=0;i<n;i++){\n    ll k,x;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> x;\n      G[i].push_back(x);\n      G[x].push_back(i);\n    }\n  }\n  cin >> q;\n  vector<ll> v(q),u(q);\n  for(ll i=0;i<q;i++){\n    cin >> u[i] >> v[i];\n  }\n  ll c=0;\n  dfs(0,-1,0,c);\n  for(ll i=0;i<2*n-1;i++){\n    seg.update(i,P(depth[i],i));\n  }\n  for(int i=0;i<q;i++){\n    ll a,b;\n    a = id[u[i]],b=id[v[i]];\n    if(a>=b) swap(a,b);\n    P idx = seg.que(a,b+1);\n    cout << vs[idx.second]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n  LowestCommonAncestor(size_t size) : size(size), G(size), dep(size), par(MaxlgV, vector<int>(size)) {}\n\n  size_t size, MaxlgV = 30;\n  int root;\n  vector<vector<int>> G, par;\n  vector<int> dep;\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int u, int d) {\n    dep[v] = d;\n    par[0][v] = u;\n    for (int e : G[v])\n      if (e != u) dfs(e, v, d + 1);\n  }\n\n  void build(int r) {\n    dfs(root = r, -1, 0);\n    for (int k = 0; k + 1 < MaxlgV; k++) {\n      for (int v = 0; v < size; v++) {\n        if (par[k][v] < 0)\n          par[k + 1][v] = -1;\n        else\n          par[k + 1][v] = par[k][par[k][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (dep[u] > dep[v]) swap(u, v);\n    for (int k = 0; k < MaxlgV; k++) {\n      if ((dep[v] - dep[u]) >> k & 1) {\n        v = par[k][v];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int k = MaxlgV - 1; k >= 0; k--) {\n      if (par[k][u] != par[k][v]) {\n        u = par[k][u];\n        v = par[k][v];\n      }\n    }\n\n    return par[0][u];\n  }\n\n  int dist(int u, int v) {\n    int z = lca(u, v);\n    return dep[u] + dep[v] - 2 * dep[z];\n  }\n};\n\n// https://onlinejudge.u-aizu.ac.jp/#/courses/library/5/GRL/5/GRL_5_C\nint main() {\n  int N;\n  cin >> N;\n\n  LowestCommonAncestor tree(N);\n  for (int i = 0; i < N; ++i) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int c;\n      cin >> c;\n\n      tree.add_edge(i, c);\n    }\n  }\n\n  tree.build(0);\n\n  int q;\n  cin >> q;\n\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n\n    cout << tree.lca(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nvector<int> G[100001];\nint N;\nint root;\nint MAX_LOG_V = 17;\nint POW[18];\n\nint** parent;\nint* depth;\n\nvoid dfs(int node_id,int parent_id,int d){\n\tparent[0][node_id] = parent_id;\n\tdepth[node_id] = d;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i] != parent_id)dfs(G[node_id][i],node_id,d+1);\n\t}\n}\n\nvoid init(){\n\n\tdfs(root,-1,0);\n\n\tfor(int k = 0; k + 1 < MAX_LOG_V; k++){\n\t\tfor(int node_id = 0; node_id < N; node_id++){\n\t\t\tif(parent[k][node_id] < 0)parent[k+1][node_id] = -1;\n\t\t\telse{\n\t\t\t\tparent[k+1][node_id] = parent[k][parent[k][node_id]];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint lca(int left,int right){\n\n\tif(depth[left] > depth[right])swap(left,right);\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(depth[right]-depth[left] >= POW[k]){\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\n\tif(left == right)return left;\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(parent[k][left] != parent[k][right]){\n\t\t\tleft = parent[k][left];\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\treturn parent[0][left];\n}\n\n\n\nint main(){\n\n\tfor(int i = 0; i <= 17; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d\",&N);\n\n\tint num,child;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&child);\n\t\t\tG[i].push_back(child);\n\t\t}\n\t}\n\n\tparent = new int*[MAX_LOG_V];\n\tfor(int i = 0; i < MAX_LOG_V;i++)parent[i] = new int[N];\n\tdepth = new int[N];\n\troot = 0;\n\tinit();\n\n\tint Q;\n\tscanf(\"%d\",&Q);\n\n\tint left,right;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\",&left,&right);\n\t\tprintf(\"%d\\n\",lca(left,right));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<int> tree[100005];\n\nclass LCA {\npublic:\n  int n,ln; // number of nodes and log n\n  vector<vector<int>> parent;\n  vector<int> depth;\n  LCA(int _n, int root=-1) : n(_n), depth(_n){\n    ln=0;\n    while(n>(1<<ln)) ln++;  // calc log n\n    parent = vector<vector<int>>(ln, vector<int>(n));\n    if(root!=-1) init(root);\n  }\n  void dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i,tree[v].size()) if(tree[v][i]!=p) dfs(tree[v][i], v, d+1);\n  }\n  void init(int root){\n    dfs(root, -1, 0);\n    for(int k=0; k+1<ln; k++){\n      for(int v=0; v<n; v++){\n        if(parent[k][v] < 0) parent[k+1][v] = -1;\n        else parent[k+1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n  int query(int u, int v){\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<ln; k++){\n      if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    for(int k=ln-1; k>=0; k--){\n      if(parent[k][u] != parent[k][v]){\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n){\n    int k;\n    cin>>k;\n    rep(j,k){\n      int d;\n      cin>>d;\n      tree[i].pb(d);\n    }\n  }\n\n  LCA lca(n, 0);\n\n  int q;\n  cin>>q;\n  rep(_,q){\n    int a,b;\n    cin>>a>>b;\n    cout << lca.query(a,b) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_LOG_V = 16;\n\nvector<int> g[MAX_V]; //??°???????????£??\\?????????\nint root;\n\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i,g[v].size()){\n        if(g[v][i] != p) dfs(g[v][i], v, d + 1);\n    }\n}\n\nvoid init(int v){\n    dfs(root, -1, 0);\n    rep(i,MAX_LOG_V - 1){\n        rep(j,v){\n            if(parent[i][j] < 0) parent[i + 1][j] = -1;\n            else parent[i + 1][j] = parent[i][parent[i][j]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    rep(i,MAX_LOG_V){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = parent[i][v];\n        }\n    }\n    if(u == v) return u;\n\n    //????????¢?´¢\n    for(int i = MAX_LOG_V - 1; i >= 0; i--){\n        if(parent[i][u] != parent[i][v]){\n            u = parent[i][u];\n            v = parent[i][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    int n;\n    cin >> n;\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int v;\n            cin >> v;\n            g[i].emplace_back(v);\n            g[v].emplace_back(i);\n        }\n    }\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u, v;\n        cin >> u >> v;\n        init(n);\n        cout << lca(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<iterator>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nclass Graph{\n    public:\n    typedef struct Edge{\n        ll from, to, cost;\n        Edge(ll f, ll t, ll c): from(f),to(t),cost(c){}\n    } Edge;\n\n    bool isDirected;\n    ll INF = 1LL << 62;\n    ll v; // 頂点数\n    std::vector<Edge> edges;  // 辺のリスト\n    std::vector<std::vector<std::pair<ll,ll>>> list;  // 隣接リスト v,cost\n    //std::vector<std::vector<ll>> matrix; // 隣接行列\n\n    Graph() : isDirected(false){ init(0); }\n    Graph(ll n, bool isDirected=false) : isDirected(isDirected) { init(n); }\n    void init(ll n){\n        v=n;\n        edges.clear();\n        list.assign(n, std::vector<std::pair<ll,ll>>());\n        //matrix.assign(n, std::vector<ll>(n, INF));\n    }\n    void connect(ll from, ll to){\n        con(from, to, 1);\n        if(!isDirected) con(to, from, 1);\n    }\n    void connect(ll from, ll to, ll cost){\n        con(from, to, cost);\n        if(!isDirected) con(to, from, cost);\n    }\n    void con(ll from, ll to, ll cost){\n        edges.push_back(Edge(from,to,cost));\n        list[from].push_back(std::make_pair(to, cost));\n        //matrix[from][to] = cost;\n    }\n};\n\nclass LowestCommonAncestor{ // 根付き木の最小共通祖先(ダブリング) 構築O(VlogV) query O(logV)\n    public:\n    int LOG = 1;\n    Graph G;\n    std::vector<ll> depth;\n    std::vector<std::vector<ll>> table; // table[k][v] : vから2^k回親をたどったnode\n\n    LowestCommonAncestor(Graph G) : G(G), depth(G.v, 0){\n        ll val = 1;\n        while(val < G.v) {val <<= 1; LOG++;}\n        table.assign(LOG, std::vector<ll>(G.v, -1));\n    }\n    void dfs(ll idx, ll parent, ll dep){\n        table[0][idx] = parent;\n        depth[idx] = dep;\n        for(auto to : G.list[idx]){\n            if(to.first != parent) dfs(to.first, idx, dep+1);\n        }\n    }\n    void build(){\n        dfs(0, -1, 0);\n        for(ll k=0; k+1<LOG; k++){\n            for(ll i=0; i<table[k].size(); i++){\n                if(table[k][i] == -1) table[k+1][i] = -1;\n                else table[k+1][i] = table[k][table[k][i]];\n            }\n        }\n    }\n    ll query(ll u, ll v){\n        if(depth[u] > depth[v]) std::swap(u,v);\n        for(ll i=LOG-1; i>=0; i--){\n            if(((depth[v] - depth[u]) >> i ) & 1) v = table[i][v];\n        }\n        if(u==v) return u;\n        for(ll i=LOG-1; i>=0; i--){\n            if(table[i][u] != table[i][v]){\n                u = table[i][u];\n                v = table[i][v];\n            }\n        }\n        return table[0][u];\n    }\n};\n\nint main(){\n    ll n,q,k,c,u,v;\n    cin >> n;\n    Graph G(n, false);\n    REP(i,n){\n        cin >> k;\n        REP(j,k){\n            cin >> c;\n            G.connect(i, c);\n        }\n    }\n    LowestCommonAncestor lca(G);\n    lca.build();\n    cin >> q;\n    REP(i,q){\n        cin >> u >> v;\n        cout << lca.query(u,v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <map>\n#include <utility>\n\n#define MAXN 100000\n\nusing namespace std;\n\nint pre[MAXN] = {-1};\nint st[MAXN];\n\nvector<pair<int,int>> vp;\nmap<pair<int,int>,int> mans;\n\nvoid swap(int &i,int &j){\n    int t = i;\n    i = j;\n    j = t;\n}\n\n\nclass Edge{\npublic:\n    int s;\n    int t;\n    Edge(int si,int ti):s(si),t(ti){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    vector<forward_list<int>> adj;\n    Graph(int v):V(v){\n        adj.resize(v);\n        for(int i = 0; i < V;i++) {st[i] = i;pre[i] = -1;}\n        }\n    void addEdge(int i,int j){adj[i].push_front(j);}\n    void tarjanR(Edge e);\n};\n\nint root(int v){\n    while(st[v] != v) v = st[v];\n    return v;\n}\n\nvoid Graph::tarjanR(Edge e){\n    int t = e.t;\n    int s = e.s;\n    pre[t] = 0;\n\n    for(auto a = adj[t].begin();a != adj[t].end();++a){\n        int v = *a;\n        if(pre[v] == -1){\n            tarjanR(Edge(t,v));\n        }\n    }\n    for(int i = 0; i < V;i++){\n        int mi = i,ma = t;\n        if(mi > ma) swap(mi,ma);\n        pair<int,int> p = make_pair(mi,ma);\n        if(pre[i] != -1 && mans.find(p) != mans.end() && mans[p] == -1){\n            mans[p] = root(i);\n        }\n    }\n    st[t] = s;\n}\n\n\nint main()\n{\n    int V,j,q,tt;\n    scanf(\"%d\",&V);\n    Graph G(V);\n    for(int i = 0; i < V; i++){\n        scanf(\"%d\",&j);\n        for(int k = 0; k < j;k++)\n        {\n            scanf(\"%d\",&tt);\n            G.addEdge(i,tt);\n        }\n    }\n\n    int s,t;\n\n    scanf(\"%d\",&q);\n    for(int i = 0; i < q;i++){\n        scanf(\"%d %d\",&s,&t);\n        if(s > t){swap(s,t);}\n        vp.push_back(make_pair(s,t));\n        mans[make_pair(s,t)] = -1;\n    }\n\n    G.tarjanR(Edge(0,0));\n\n    for(int i = 0; i < q;i++){\n        printf(\"%d\\n\",mans[vp[i]]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\n// Least Common Ancestor (Doubling)\nstruct LCA\n{\n  vector< vector<int> > tree, parent;\n  vector<int> depth;\n  int log_V;\n  LCA(int V)\n  {\n    log_V = 1;\n    while((1 << log_V) <= V) log_V++;\n    tree.resize(V);\n    parent.resize(log_V, vector<int>(V, -1));    \n    depth.resize(V);\n  }\n  void add_edge(int f, int t)\n  {\n    tree[f].emplace_back(t);\n    tree[t].emplace_back(f);    \n  }\n  void dfs(int u, int p, int d)\n  {\n    parent[0][u] = p;\n    depth[u] = d;\n    for(auto v : tree[u]) {\n      if(v != p) dfs(v, u, d + 1);\n    }\n  }\n  void init(int root = 0)\n  {\n    dfs(root, -1, 0);\n    for(int i = 0; i + 1 < log_V; i++) {\n      for(int v = 0; v < parent[i].size(); v++) {\n\tif(parent[i][v] < 0) parent[i + 1][v] = -1;\n\telse parent[i + 1][v] = parent[i][parent[i][v]];\n      }\n    }\n  }\n  int trace(int u, int v)\n  {\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int i = 0; i < log_V; i++) {\n      if((depth[v] - depth[u]) >> i & 1) v = parent[i][v];\n    }\n    if(u == v) return u;\n    for(int i = log_V-1; i >= 0; i--) {\n      if(parent[i][u] != parent[i][v]) u = parent[i][u], v = parent[i][v];\n    }\n    return parent[0][u];\n  }\n  int dist(int u, int v) {\n    return depth[u] + depth[v] - 2*depth[trace(u, v)];\n  }\n};\n\n\nint main()\n{\n  int n; cin >> n;\n  LCA lca(n);\n  rep(i, n) {\n    int k; cin >> k;\n    while(k--) {\n      int c; cin >> c;\n      lca.add_edge(i, c);\n    }\n  }\n  lca.init();\n  int q; cin >> q;\n  while(q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.trace(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\t\tusing LL = long long;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using pq = priority_queue<T>;\ntemplate<class T>using pqs = priority_queue<T, vector<T>, greater<T>>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\nconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\nusing Weight = long long;\nconstexpr Weight INF = numeric_limits<Weight>::max();\nstruct Edge {\n\tint to; Weight cost;\n\tEdge() :to(-1), cost(-1) {}\n\tEdge(int _to, Weight _cost = 1) :to(_to), cost(_cost) {}\n};\nbool operator>(const Edge& e1, const Edge& e2) { return e1.cost > e2.cost; }\nstruct Edge2 {\n\tint u, v; Weight cost;\n\tEdge2() :u(-1), v(-1), cost(0) {}\n\tEdge2(int _u, int _v, Weight _cost) :u(_u), v(_v), cost(_cost) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\nusing UnWeightedGraph = vector<vector<int>>;\n\nstruct LCA {\n\tconst int V, LOG;\n\tvector<int> dist;\n\tvector<vector<int>> table;\n\n\tLCA(const UnWeightedGraph& g, const int root)\n\t\t: V(g.size()), LOG(log2(g.size()) + 1)\n\t\t, dist(g.size()), table(LOG, vector<int>(g.size())) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG; ++k) {\n\t\t\tfor (int v = 0; v < V; ++v) {\n\t\t\t\tif (table[k][v] < 0) {\n\t\t\t\t\ttable[k + 1][v] = -1;\n\t\t\t\t} else {\n\t\t\t\t\ttable[k + 1][v] = table[k][table[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(const UnWeightedGraph& g, int v, int p, int d) {\n\t\ttable[0][v] = p;\n\t\tdist[v] = d;\n\t\tfor (auto e : g[v])if (e != p) {\n\t\t\tdfs(g, e, v, d + 1);\n\t\t}\n\t}\n\tint get(int u, int v) {\n\t\tif (dist[u] > dist[v])swap(u, v);\n\t\tfor (int k = 0; k < LOG; ++k) {\n\t\t\tif ((dist[v] - dist[u]) >> k & 1) {\n\t\t\t\tv = table[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int k = LOG - 1; k >= 0; --k) {\n\t\t\tif (table[k][u] != table[k][v]) {\n\t\t\t\tu = table[k][u];\n\t\t\t\tv = table[k][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\nint main() {\n\tint n = in;\n\tUnWeightedGraph g(n);\n\trep(i, n) {\n\t\tint k = in;\n\t\trep(j, k) {\n\t\t\tint x = in;\n\t\t\tg[i].pb(x);\n\t\t\tg[x].pb(i);\n\t\t}\n\t}\n\n\tLCA lca(g, 0);\n\tint q = in;\n\trep(i, q) {\n\t\tint a = in, b = in;\n\t\tout(lca.get(a, b));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rndf(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define rnddiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) * 2 >= (ll)(b) ? 1 : 0))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\ntypedef ll nodeval_t;\ntypedef ll edgeval_t;\n\nstruct tree_t {\n\tint n;           // |V|, index begins with 0\n\tvector<P> edges; // E\n\tvector<nodeval_t> vals; // value of nodes\n\tvector<edgeval_t> costs; // cost, distance, or weight of edges\n};\n\nclass Tree {\nprivate:\n\tstruct node {\n\t\tint id; vi childs; int parent = -1;\n\t\tint deg = -1; // the number of edges of the path to the root\n\t\tint eid = -1; // edge id of the edge connected by its parent and itself\n\t\tint subtree_n = -1; // the number of nodes of the partial tree rooted by itself\n\t\tint visited = -1; // time stamp of visiting on DFS\n\t\tint departed = -1; // time stamp of departure on DFS\n\t\tnodeval_t val; // value of the node itself\n\t\tedgeval_t cost; // cost of the edge connected by its parent and itself\n\t\tbool operator<(const node & another) const {\n\t\t\treturn deg != another.deg ? deg < another.deg : id < another.id;\n\t\t}\n\t};\n\tstruct edgeinfo {\n\t\tint eid; int to; edgeval_t cost;\n\t};\n\tint n;\n\tstatic const nodeval_t init_val = 0;\n\tstatic const edgeval_t init_cost = 1;\n\tvector<vector<edgeinfo>> edges;\n\tvvi sparse_ancestors;\n\tvoid tree_construction() {\n\t\tleaves = {};\n\t\tqueue<int> que;\n\t\tque.push(root);\n\t\twhile (que.size()) {\n\t\t\tint a = que.front(); que.pop();\n\t\t\tdeg_order.push_back(a);\n\t\t\tif (a == Tree::root) nodes[a].deg = 0;\n\t\t\tint leaf_flag = true;\n\t\t\tLoop(i, edges[a].size()) {\n\t\t\t\tint b = edges[a][i].to;\n\t\t\t\tif (nodes[b].deg != -1) {\n\t\t\t\t\tnodes[a].parent = b;\n\t\t\t\t\tnodes[a].eid = edges[a][i].eid;\n\t\t\t\t\tnodes[a].cost = edges[a][i].cost;\n\t\t\t\t\tnodes[a].deg = nodes[b].deg + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleaf_flag = false;\n\t\t\t\t\tnodes[a].childs.push_back(b);\n\t\t\t\t\tque.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (leaf_flag) leaves.push_back(a);\n\t\t}\n\t\tLoopr(i, n) {\n\t\t\tint a = deg_order[i];\n\t\t\tLoop(j, nodes[a].childs.size()) {\n\t\t\t\tint b = nodes[a].childs[j];\n\t\t\t\tnodes[a].subtree_n += nodes[b].subtree_n;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvector<node> nodes;\n\tvi deg_order; // node ids, sorted by deg\n\tvi leaves;\n\tint root;\n\t// T should be non-empty tree\n\tTree(tree_t T, int root = -1) {\n\t\tn = T.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tnodes[i].id = i;\n\t\t\tnodes[i].val = T.vals.size() > i ? T.vals[i] : 0;\n\t\t\tnodes[i].cost = init_cost;\n\t\t}\n\t\tedges.resize(n);\n\t\tLoop(i, n - 1) {\n\t\t\tedges[T.edges[i].first].push_back({ i, T.edges[i].second, (T.costs.size() > i ? T.costs[i] : init_cost) });\n\t\t\tedges[T.edges[i].second].push_back({ i, T.edges[i].first, (T.costs.size() > i ? T.costs[i] : init_cost) });\n\t\t}\n\t\t// the node which has the greatest degree will automatically decided as the root\n\t\tif (root < 0) {\n\t\t\tint max_d = -1;\n\t\t\tLoop(i, n) {\n\t\t\t\tif (edges[i].size() > max_d) {\n\t\t\t\t\tTree::root = i;\n\t\t\t\t\tmax_d = edges[i].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis->root = min(root, n - 1);\n\t\t}\n\t\ttree_construction();\n\t\treturn;\n\t}\n\tpair<int, vi> solve_center_of_gravity() {\n\t\tpair<int, vi> ret = { INT_MAX,{} };\n\t\tvector<node> c_nodes = nodes;\n\t\tsort(c_nodes.begin(), c_nodes.end());\n\t\tvi record(n, 1);\n\t\tLoopr(i, n) {\n\t\t\tint x = n - 1, max_x = INT_MIN;\n\t\t\tLoop(j, c_nodes[i].childs.size()) {\n\t\t\t\tint b = c_nodes[i].childs[j];\n\t\t\t\tmax_x = max(max_x, record[b]);\n\t\t\t\tx -= record[b];\n\t\t\t\trecord[c_nodes[i].id] += record[b];\n\t\t\t}\n\t\t\tmax_x = max(max_x, x);\n\t\t\tif (max_x < ret.first) ret = { max_x,{ c_nodes[i].id } };\n\t\t\telse if (max_x == ret.first) ret.second.push_back(c_nodes[i].id);\n\t\t}\n\t\tsort(ret.second.begin(), ret.second.end());\n\t\treturn ret;\n\t}\n\tvi solve_node_inclusion_cnt_in_all_path(bool enable_single_node_path) {\n\t\tvi ret(n, 0);\n\t\tLoop(i, n) {\n\t\t\tint a = i;\n\t\t\t// desendants to desendants\n\t\t\tLoop(j, nodes[a].childs.size()) {\n\t\t\t\tint b = nodes[a].childs[j];\n\t\t\t\tret[i] += nodes[b].subtree_n * (nodes[a].subtree_n - nodes[b].subtree_n - 1);\n\t\t\t}\n\t\t\tret[i] /= 2; // because of double counting\n\t\t\tret[i] += (nodes[a].subtree_n - 1) * (n - nodes[a].subtree_n); // desendants to the others except for itself\n\t\t\tret[i] += n - 1; // itself to the others\n\t\t\tif (enable_single_node_path) ret[i]++; // itself\n\t\t}\n\t\treturn ret;\n\t}\n\tvi solve_edge_inclusion_cnt_in_all_path() {\n\t\tvi ret(n - 1, 0);\n\t\tLoop(i, n) {\n\t\t\tint eid = nodes[i].eid;\n\t\t\tif (eid < 0) continue;\n\t\t\tret[eid] = nodes[i].subtree_n * (n - nodes[i].subtree_n); // members in the partial tree to the others\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid solve_sparse_ancestors() {\n\t\tsparse_ancestors.resize(n);\n\t\tvector<int> current_ancestors;\n\t\tstack<int> stk;\n\t\tstk.push(Tree::root);\n\t\tint time_stamp = 1;\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tnodes[a].visited = time_stamp++;\n\t\t\tfor (int i = 1; i <= current_ancestors.size(); i *= 2) {\n\t\t\t\tsparse_ancestors[a].push_back(current_ancestors[current_ancestors.size() - i]);\n\t\t\t}\n\t\t\tif (nodes[a].childs.size()) {\n\t\t\t\tLoop(i, nodes[a].childs.size()) {\n\t\t\t\t\tstk.push(nodes[a].childs[i]);\n\t\t\t\t}\n\t\t\t\tcurrent_ancestors.push_back(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (current_ancestors.size() && (stk.empty() || nodes[stk.top()].parent != current_ancestors.back())) {\n\t\t\t\t\tnodes[current_ancestors.back()].departed = time_stamp++;\n\t\t\t\t\tcurrent_ancestors.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbool is_ancestor(int descendant, int ancestor) {\n\t\treturn nodes[ancestor].visited < nodes[descendant].visited\n\t\t\t&& nodes[descendant].departed < nodes[ancestor].departed;\n\t}\n\tint get_lowest_common_ancestor(int u, int v) {\n\t\tif (is_ancestor(u, v)) return v;\n\t\tif (is_ancestor(v, u)) return u;\n\t\tint a = u;\n\t\twhile (!is_ancestor(v, sparse_ancestors[a][0])) {\n\t\t\tint b = sparse_ancestors[a][0];\n\t\t\tLoop1(i, sparse_ancestors[a].size() - 1) {\n\t\t\t\tif (is_ancestor(v, sparse_ancestors[a][i])) break;\n\t\t\t\telse b = sparse_ancestors[a][i - 1];\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\treturn sparse_ancestors[a][0];\n\t}\n};\n\nint main() {\n\ttree_t T;\n\tcin >> T.n;\n\tLoop(i, T.n) {\n\t\tint m; cin >> m;\n\t\tLoop(j, m) {\n\t\t\tint t; cin >> t;\n\t\t\tT.edges.push_back({ i, t });\n\t\t}\n\t}\n\tTree tree(T, 0);\n\ttree.solve_sparse_ancestors();\n\tint q; cin >> q;\n\tLoop(i, q) {\n\t\tint s, t; cin >> s >> t;\n\t\tcout << tree.get_lowest_common_ancestor(s, t) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n#define all(_) begin(_), end(_)\n#define rall(_) rbegin(_), rend(_)\n\ntemplate <class T>\nclass graph {\n public:\n  graph(int n) : n_(n) { data_.resize(n_); }\n  struct edge {\n    int from, to;\n    T cost;\n  };\n  int n_;\n  std::vector<std::vector<int>> data_;\n  std::vector<edge> edges_;\n\n  virtual void add(int from, int to, T cost) = 0;\n};\n\ntemplate <class T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::n_;\n  using graph<T>::data_;\n  using graph<T>::edges_;\n\n  forest(int n) : graph<T>(n) {}\n\n  void add(int from, int to, T cost = 1) {\n    int id = edges_.size();\n    assert(id < n_ - 1);\n    data_[from].emplace_back(id);\n    data_[to].emplace_back(id);\n    edges_.push_back({from, to, cost});\n  }\n};\n\ntemplate <class T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::n_;\n  using graph<T>::data_;\n  using graph<T>::edges_;\n\n  digraph(int n) : graph<T>(n) {}\n\n  void add(int from, int to, T cost = 1) {\n    int id = edges_.size();\n    data_[from].emplace_back(id);\n    edges_.push_back({from, to, cost});\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n_);\n    for (auto& e : edges_) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <class T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::n_;\n  using graph<T>::data_;\n  using graph<T>::edges_;\n\n  undigraph(int n) : graph<T>(n) {}\n\n  void add(int from, int to, T cost = 1) {\n    int id = edges_.size();\n    data_[from].emplace_back(id);\n    data_[to].emplace_back(id);\n    edges_.push_back({from, to, cost});\n  }\n};\n\ntemplate <class T>\nclass lca_forest : public forest<T> {\n public:\n  using forest<T>::n_;\n  using forest<T>::data_;\n  using forest<T>::edges_;\n\n  lca_forest(int n)\n      : forest<T>(n), lg_(32 - __builtin_clz(n)) {\n    init();\n  }\n/*\n  void add(int from, int to, T cost = 1) {\n    int id = edges_.size();\n    data_[from].emplace_back(id);\n    data_[to].emplace_back(id);\n    edges_.push_back({from, to, cost});\n  }\n*/\n  void build(int r = 0) {\n    dfs(r, -1, 0);\n    for (int i = 0; i + 1 < lg_; ++i) {\n      for (int j = 0; j < n_; ++j) {\n        if (par_[i][j] < 0) {\n          par_[i + 1][j] = -1;\n        } else {\n          par_[i + 1][j] = par_[i][par_[i][j]];\n        }\n      }\n    }\n  }\n\n  // use after build()\n  int lca(int u, int v) {\n    assert(0 <= u && u < n_ && 0 <= v && v < n_);\n    if (dep_[u] > dep_[v]) std::swap(u, v);\n    for (int i = 0; i < lg_; ++i) {\n      if ((dep_[v] - dep_[u]) >> i & 1) {\n        v = par_[i][v];\n      }\n    }\n    if (u == v) return u;\n    for (int i = lg_ - 1; i >= 0; --i) {\n      if (par_[i][u] != par_[i][v]) {\n        u = par_[i][u];\n        v = par_[i][v];\n      }\n    }\n    return par_[0][u];\n  }\n\n  int dist(int u, int v) {\n    assert(0 <= u && u < n_ && 0 <= v && v < n_);\n    return dep_[u] + dep_[v] - 2 * dep_[lca(u, v)];\n  }\n\n private:\n  int lg_;\n  std::vector<std::vector<int>> par_;\n  std::vector<int> dep_;\n\n  void dfs(int cur, int pre, int d) {\n    par_[0][cur] = pre;\n    dep_[cur] = d;\n    for (int id : data_[cur]) {\n      auto& e = edges_[id];\n      int nxt = e.to ^ e.from ^ cur;\n      if (nxt == pre) continue;\n      dfs(nxt, cur, d + 1);\n    }\n  }\n\n  void init() {\n    dep_.resize(n_);\n    par_.assign(lg_, std::vector<int>(n_, -1));\n  }\n};\n\nvoid GRL_5_C() {\n  int n;\n  cin >> n;\n  lca_forest<int> lca(n);\n  for (int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      lca.add(i, c);\n    }\n  }\n  lca.build();\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.lca(u, v) << '\\n';\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  GRL_5_C();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nstruct LCT {\n#define l ch[0]\n#define r ch[1]\n\tstruct Node {\n\t\tNode *p;\n\t\tNode *ch[2];\n\t\tbool rev;\n\t\tint64_t sum;\n\t\tint64_t val;\n\t\tint size;\n\t\tvoid fetch() {\n\t\t\tif (l != LCT::NONE) l->flush();\n\t\t\tif (r != LCT::NONE) r->flush();\n\t\t\tsum = val + l->sum + r->sum;\n\t\t\tsize = 1 + l->size + r->size;\n\t\t}\n\t\tvoid flush() {\n\t\t\tif (rev) {\n\t\t\t\tl->rev ^= 1;\n\t\t\t\tr->rev ^= 1;\n\t\t\t\tstd::swap(l, r);\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\t\tbool is_root() {\n\t\t\treturn p == LCT::NONE || (p->l != this && p->r != this);\n\t\t}\n\t\tvoid rotate(int dir) {\n\t\t\tNode *new_root = ch[!dir], *par = p;\n\t\t\tch[!dir] = new_root->ch[dir];\n\t\t\tch[!dir]->p = this;\n\t\t\tnew_root->ch[dir] = this;\n\t\t\tp = new_root;\n\t\t\tfetch(), new_root->fetch();\n\t\t\tnew_root->p = par;\n\t\t\tif (par->l == this) par->l = new_root;\n\t\t\telse if (par->r == this) par->r = new_root;\n\t\t}\n\t};\n\tvoid splay(Node *node) {\n\t\tnode->flush();\n\t\twhile (!node->is_root()) {\n\t\t\tNode *p = node->p;\n\t\t\tif (p->is_root()) {\n\t\t\t\tp->flush(), node->flush();\n\t\t\t\tp->rotate(p->l == node);\n\t\t\t} else {\n\t\t\t\tNode *pp = p->p;\n\t\t\t\tpp->flush(), p->flush(), node->flush();\n\t\t\t\tbool flag1 = p->r == node;\n\t\t\t\tbool flag2 = pp->r == p;\n\t\t\t\tif (flag1 == flag2) pp->rotate(!flag2);\n\t\t\t\tp->rotate(!flag1);\n\t\t\t\tif (flag1 != flag2) pp->rotate(!flag2);\n\t\t\t}\n\t\t}\n\t}\n\tstatic Node *nodes, *NONE;\n\tstatic int head;\n\tLCT () {\n\t\tif (!head) nodes[head++] = {NONE, {NONE, NONE}, false, 0, 0, 0};\n\t}\n\tNode *expose(Node *start) {\n\t\tNode *prev = NONE;\n\t\tfor (Node *cur = start; cur != NONE; cur = cur->p) {\n\t\t\tsplay(cur);\n\t\t\tcur->r = prev;\n\t\t\tcur->fetch();\n\t\t\tprev = cur;\n\t\t}\n\t\tsplay(start);\n\t\treturn prev;\n\t}\n\tvoid link(Node *child, Node *parent) {\n\t\texpose(child), expose(parent);\n\t\tparent->r = child;\n\t\tchild->p = parent;\n\t\tparent->fetch();\n\t}\n\tvoid cut(Node *child) {\n\t\texpose(child);\n\t\tNode *parent = child->l;\n\t\tparent->p = NONE;\n\t\tchild->l = NONE;\n\t\tchild->fetch();\n\t}\n\tvoid reroot(Node *node) {\n\t\texpose(node);\n\t\tnode->rev ^= 1;\n\t\tnode->flush();\n\t}\n\tNode *new_node(int val) {\n\t\treturn &(nodes[head++] = {NONE, {NONE, NONE}, false, val, val, 1});\n\t}\n\tNode *get_root(Node *node) {\n\t\texpose(node);\n\t\tfor (; node->flush(), (node->l != NONE); node = node->l);\n\t\treturn node;\n\t}\n\tNode *lca(Node *a, Node *b) {\n\t\texpose(a);\n\t\treturn expose(b);\n\t}\n\tvoid debug(Node *node, int indent = 0, int dir = 0) {\n\t\tif (node == NONE) return;\n\t\tfor (int i = 0; i < indent; i++) fprintf(stderr, \" \");\n\t\tif (dir) fprintf(stderr, dir > 0 ? \"R \" : \"L \");\n\t\tfprintf(stderr, \"%d : val:%lld sz:%d p:%d rev:%d\\n\", (int) (node - nodes), (long long) node->val, node->size, (int) (node->p - nodes), node->rev);\n\t\t\n\t\tdebug(node->l, indent + 1, -1);\n\t\tdebug(node->r, indent + 1, 1);\n\t}\n#undef l\n#undef r\n};\nLCT::Node *LCT::nodes = (Node *) malloc(sizeof(Node) * 1000000), *LCT::NONE = nodes;\nint LCT::head = 0;\n\n// verify LCT\n\nint main() {\n\t//*\n\tint n = ri();\n\tLCT tree;\n\tLCT::Node *nodes[n];\n\tfor (int i = 0; i < n; i++) nodes[i] = tree.new_node(i);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tint k = ri();\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint t = ri();\n\t\t\ttree.reroot(nodes[t]);\n\t\t\ttree.reroot(nodes[i]);\n\t\t\ttree.link(nodes[t], nodes[i]);\n\t\t}\n\t}\n\ttree.reroot(nodes[0]);\n\tint q = ri();\n\tfor (int i = 0; i < q; i++) {\n\t\tint a = ri(), b = ri();\n\t\tprintf(\"%d\\n\", (int) tree.lca(nodes[a], nodes[b])->val);\n\t}\n\t//*/\n\t\n\t/*\n\tconstexpr int n = 100;\n\tstd::set<std::pair<int, int> > hens;\n\tLCT tree;\n\tLCT::Node *nodes[n];\n\tfor (int i = 0; i < n; i++) nodes[i] = tree.new_node(i);\n\tfor (; ;) {\n\t\tstd::string command;\n\t\tstd::cin >> command;\n\t\tif (command == \"add\") {\n\t\t\tint a = ri(), b = ri();\n\t\t\tif (a > b) std::swap(a, b);\n\t\t\thens.insert({a, b});\n\t\t\ttree.reroot(nodes[a]);\n\t\t\ttree.link(nodes[a], nodes[b]);\n\t\t} else if (command == \"remove\") {\n\t\t\tint a = ri(), b = ri();\n\t\t\tif (a > b) std::swap(a, b);\n\t\t\tif (!hens.count({a, b})) {\n\t\t\t\tstd::cerr << \"not in the hens\" << std::endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thens.erase({a, b});\n\t\t\ttree.reroot(nodes[b]);\n\t\t\ttree.cut(nodes[a]);\n\t\t} else if (command == \"root\") {\n\t\t\tint x = ri();\n\t\t\tstd::cout << (tree.get_root(nodes[x]) - tree.nodes - 1) << std::endl;\n\t\t\t\n\t\t\t\n\t\t} else if (command == \"reroot\") {\n\t\t\ttree.reroot(nodes[ri()]);\n\t\t}\n\t}\n\t//*/\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100001;\nconst int MAX_N = 100001;\n\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n + n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int par, int d, int &k){\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(G[v][i] != par){\n                    dfs(G[v][i], v, d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, -1, 0, k);\n            rmqInit(depth,V * 2 - 1);\n        }\n        int lca(int u, int v){\n            int tmp = vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n            assert(tmp < MAX_V * 2);\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define si(i) scanf(\"%d\", &i)\n#define sll(i) scanf(\"%lld\", &i)\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define nl '\\n'\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair< int, int > pii;\n\nint n, l[100005];\nint f[100005][17];\nvector< vector<int> >v;\n\nint main(){\n    memset( f[0], -1, sizeof f[0]);\n    si(n);\n    v.resize(n);\n    int nn = 32 - __builtin_clz(n);\n    for( int i = 0 ; i < n ; i++ ){\n        int k; si(k);\n        for( int j = 0 ; j < k ; j++ ){\n            int c; si(c);\n            v[i].pb(c);\n            f[0][c] = i;\n        }\n    }\n    queue < int >q;\n    l[0] = 0;\n    q.push(0);\n    while( q.size() ){\n        int x = q.front();\n        q.pop();\n        for( int i = 0 ; i < v[x].size() ; i++ ){\n            l[v[x][i]] = l[x] + 1;\n            q.push(v[x][i]);\n        }\n    }\n    \n    for( int i = 1 ; i <= nn ; i++ ){\n        for( int j = 0 ; j < n ; j++ ){\n            int x = f[i - 1][j];\n            if( x == -1 ){\n                f[i][j] = -1;\n                continue;\n            }\n            int y = f[i - 1][x];\n            f[i][j] = y;\n        }\n    }\n    int _q; si(_q);\n    while( _q-- ){\n        int u, v;\n        si(u); si(v);\n        if( l[u] < l[v] ) swap( u, v );\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( ( 1 << i ) <= l[u] - l[v] ){\n                u = f[i][u];\n            }\n        }\n        if( u == v ){\n            cout << u << nl;\n            continue;\n        }\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( f[i][u] == f[i][v] ) continue;\n            u = f[i][u];\n            v = f[i][v];\n        }\n        cout << f[0][u] << nl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- <O(nlgn),O(1)> --- */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\n\nconst int MAXN = 100005;\nconst int LOGN = 20;\n\nint H[MAXN];        // index of node i in dfs path\nii path[MAXN<<1];\nvi adjList[MAXN];\n\nii ST[LOGN][MAXN<<1];\n\nvoid build(int n) {\n    int h = ceil(log2(n+1));\n\n    for (int i = 0; i < n; i++) ST[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n        ST[i][j] = min(ST[i-1][j], ST[i-1][j+(1<<(i-1))]);\n}\n\nint RMQ(int l, int r) {     // range [l,r)\n    int p = 31 - __builtin_clz(r-l);\n    return min(ST[p][l],ST[p][r-(1<<p)]).se;\n}\n\nint cnt = 0;\nvoid dfs(int node = 0, int depth = 0){\n    H[node] = cnt;\n\n    path[cnt++] = ii(depth,node);\n    for (int i = 0; i < adjList[node].size(); i++) {\n        dfs(adjList[node][i],depth+1);\n\n        path[cnt++] = ii(depth,node);\n    }\n}\n\nint N, Q;\n\nint main(){\n\n    scanf(\"%d\",&N);\n    for (int u = 0, M; u < N; u++) {\n        scanf(\"%d\",&M);\n        for (int i = 0, v; i < M; i++) {\n            scanf(\"%d\",&v);\n            \n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted at 0\n    dfs();\n    build(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v, l, r; i < Q; i++){\n        scanf(\"%d%d\",&u,&v);\n\n        l = H[u], r = H[v]; if (l > r) swap(l,r);\n\n        printf(\"%d\\n\",RMQ(l,r+1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX=100000;\n\nvector<int> G[MAX];\nint root;\nint V;\n\nint vs[MAX*2-1];\nint depth[MAX*2-1];\nint id[MAX];\n\nint n;\nint dat[MAX*4-1];//0-indexed\n\nvoid rmq_init(int V)\n{\n\tn=1;\n\twhile(n<V)n<<=1;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=-1;\n\treturn;\n}\n\nvoid update(int k,int a)\n{\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0)\n\t{\n\t\tk=(k-1)/2;\n\t\tint b1=dat[k*2+1],b2=dat[k*2+2];\n\t\tif(b1!=-1&&b2!=-1)dat[k]=(depth[b1]<=depth[b2]?b1:b2);\n\t\telse if(b2!=-1)dat[k]=b2;\n\t\telse dat[k]=b1;\n\t}\n\treturn;\n}\n\nint getmin(int a,int b,int k,int l,int r)//[a,b),vertex-number(0),k's range[l,r)\n{\n\tif(r<=a||b<=l)return -1;\n\t\n\tif(a<=l&&r<=b)return dat[k];\n\telse\n\t{\n\t\tint vl=getmin(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=getmin(a,b,k*2+2,(l+r)/2,r);\n\t\tif(vl!=-1&&vr!=-1)return (depth[vl]<=depth[vr]?vl:vr);\n\t\telse if(vr!=-1)return vr;\n\t\telse return vl;\n\t}\n}\n\nvoid dfs(int v,int p,int d,int &k)\n{\n\tid[v]=k;\n\tvs[k]=v;\n\tdepth[k]=d;\n\tk++;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tif(G[v][i]!=p)\n\t\t{\n\t\t\tdfs(G[v][i],v,d+1,k);\n\t\t\tvs[k]=v;\n\t\t\tdepth[k]=d;\n\t\t\tk++;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid init()\n{\n\tint k=0;\n\troot=0;\n\tdfs(root,-1,0,k);\n\trmq_init(V*2-1);\n\tfor(int i=0;i<V*2-1;i++)update(i,i);\n\treturn;\n}\n\nint lca(int u,int v)\n{\n\tif(id[u]>id[v])swap(u,v);\n\treturn vs[getmin(id[u],id[v]+1,0,0,n)];\n}\n\nint main()\n{\n\tcin>>V;\n\tint k,c;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tcin>>c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin>>q;\n\tint u,v;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tcout<<lca(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nusing Weight = int;\nstruct Edge {\n\tint s, d; Weight w;\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//lowest common ancestor (??????????????° + dfs?????°)\n//?§????O(NlogN) ?????¨???O(logN)\nstruct LowestCommonAncestor {\n\tconst int n, log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\tconst Graph &g;\n\tLowestCommonAncestor(const Graph &g, int root)\n\t\t:g(g), n(g.size()), log2_n(log2(n) + 1), parent(log2_n, vector<int>(n)), depth(n) {\n\t\tdfs(root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int s, int p, int d) {\n\t\tparent[0][s] = p;\n\t\tdepth[s] = d;\n\t\tfor (auto &e : g[s]) {\n\t\t\tif (e.d == p)continue;\n\t\t\tdfs(e.d, s, d + 1);\n\t\t}\n\t}\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tGraph g(n);\n\trep(i, 0, n) {\n\t\tint k; cin >> k;\n\t\trep(j, 0, k) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(i, c);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tLowestCommonAncestor lca(g, 0);\n\trep(i, 0, q) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << lca.get(u, v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// verified: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n    static const int BITLEN_MAX = 31;\n    vector<int> parent[BITLEN_MAX];\n    vector<int> depth;\n    int bitlen;  // (1 << (bitlen - 1)) < N <= (1 << bitlen)\n\n    void init(int N, const vector<vector<int>> &edges) {\n        int root = 0;\n        bitlen = 1;\n        while((1 << bitlen) < N) ++bitlen;\n        for(int i = 0; i < bitlen; ++i) parent[i].resize(N);\n        depth.resize(N, -1);\n\n        dfs(root, -1, 0, edges);\n        for(int k = 0; k + 1 < bitlen; ++k) {\n            for(int v = 0; v < N; ++v) {\n                if(depth[v] == -1) continue;\n                if(parent[k][v] < 0) {\n                    parent[k + 1][v] = -1;\n                } else {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n\n    void dfs(int v, int p, int d, const vector<vector<int>> &edges) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for(int u : edges[v]) {\n            if(u != p) dfs(u, v, d + 1, edges);\n        }\n    }\n\n    int query_lca(int u, int v) {\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int k = 0; k < bitlen; ++k) {\n            if(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\n        }\n        if(u == v) return u;\n        for(int k = bitlen - 1; k >= 0; --k) {\n            if(parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n    int query_dist(int u, int v) {\n        int l = query_lca(u, v);\n        return depth[u] + depth[v] - 2 * depth[l];\n    }\n};\n\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> edges(N, vector<int>(0));\n    for(int i=0; i<N; ++i) {\n        int k;\n        cin >> k;\n        for(int j=0; j<k; ++j) {\n            int c;\n            cin >> c;\n            edges[i].push_back(c);\n        }\n    }\n\n    // preperation O(N logN)\n    LCA lca;\n    lca.init(N, edges);\n\n    // O(logN) for each query\n    int q;\n    cin >> q;\n    while(q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query_lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef VVI Graph;\n\nGraph G;\nconst int N = 100000;\nconst int LOG_N = (int)log2(N);\nint depth[N];\nint parent[LOG_N][N];\nvoid dfs(int node ,int p = -1, int d = 0)\n{\n  if(depth[node] >= 0) return;\n  depth[node] = d;\n  parent[0][node] = p;\n  for(int i=0;i<SZ(G[node]);++i)\n\tdfs(G[node][i], node, d+1);\n}\n\nvoid init(int V){\n  fill(depth, depth+N, -1);\n  dfs(0);\n  for(int i=0;i+1<LOG_N;++i){\n\tfor(int v=0;v<V;++v){\n\t  if(parent[i][v] == -1) parent[i+1][v] = -1;\n\t  else parent[i+1][v] = parent[i][parent[i][v]];\n\t}\n  }\n}\n\nint LCA(int u, int v){\n  if(depth[u] > depth[v]) swap(u, v);\n  //depth[u] <= depth[v]\n  for(int i=0;i<LOG_N;++i)\n\tif((depth[v] - depth[u]) >> i & 1)\n\t  v = parent[i][v];\n  if(u == v) return u;\n\n  for(int i=LOG_N-1;i>=0;--i){\n\tif(parent[i][u] != parent[i][v]){\n\t  u = parent[i][u];\n\t  v = parent[i][v];\n\t}\n  }\n  return parent[0][u];\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V; cin >> V;\n  G.assign(V, VI());\n  REP(i,V){\n\tint k; cin >> k;\n\tREP(j,k){\n\t  int c; cin >> c;\n\t  G[i].PB(c);\n\t}\n  }\n  init(V);\n  int Q; cin >> Q;\n  while(Q--){\n\tint u, v; cin >> u >> v;\n\tcout << LCA(u,v) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nvoid warshall_floyd(Matrix< T > &g, T INF) {\n  for(int k = 0; k < g.size(); k++) {\n    for(int i = 0; i < g.size(); i++) {\n      for(int j = 0; j < g.size(); j++) {\n        if(g[i][k] == INF || g[k][j] == INF) continue;\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n}\n\n\nusing int64 = long long;\nconst int64 INF = 1LL << 58;\n\nint main() {\n  int V, E;\n  scanf(\"%d %d\", &V, &E);\n  Matrix< int64 > mat(V, vector< int64 >(V, INF));\n  for(int i = 0; i < V; i++) mat[i][i] = 0;\n  for(int i = 0; i < E; i++) {\n    int x, y, z;\n    scanf(\"%d %d %d\", &x, &y, &z);\n    mat[x][y] = z;\n  }\n  warshall_floyd(mat, INF);\n  for(int i = 0; i < V; i++) {\n    if(mat[i][i] < 0) {\n      puts(\"NEGATIVE CYCLE\");\n      return 0;\n    }\n  }\n  for(int i = 0; i < V; i++) {\n    for(int j = 0; j < V; j++) {\n      if(j > 0) putchar(' ');\n      if(mat[i][j] == INF) printf(\"INF\");\n      else printf(\"%lld\", mat[i][j]);\n    }\n    putchar('\\n');\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass HLDecomposition {\n\tvector<vector<int>> g;\n\tvector<int> vid, head, heavy, parent, depth, inv;\n\tint dfs(int curr, int prev) {\n\t\tparent[curr] = prev;\n\t\tint sub = 1, max_sub = 0;\n\t\tfor (int next : g[curr]) if (next != prev) {\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tint sub_next = dfs(next, curr);\n\t\t\tsub += sub_next;\n\t\t\tif (max_sub < sub_next) max_sub = sub_next, heavy[curr] = next;\n\t\t}\n\t\treturn sub;\n\t}\n\tvoid bfs() {\n\t\tint k = 0;\n\t\tqueue<int> q({ 0 });\n\t\twhile (!q.empty()) {\n\t\t\tint h = q.front(); q.pop();\n\t\t\tfor (int i = h; i != -1; i = heavy[i]) {\n\t\t\t\tvid[i] = k++;\n\t\t\t\tinv[vid[i]] = i;\n\t\t\t\thead[i] = h;\n\t\t\t\tfor (int j : g[i]) if (j != parent[i] && j != heavy[i]) q.push(j);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tHLDecomposition(int n)\n\t\t: g(n), vid(n, -1), head(n), heavy(n, -1), parent(n), depth(n), inv(n) {}\n\n\tvoid add(int u, int v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvoid build() {\n\t\tdfs(0, -1);\n\t\tbfs();\n\t}\n\tint lca(int u, int v) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tif (head[u] == head[v]) return u;\n\t\treturn lca(u, parent[head[v]]);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, q;\n\tcin >> n;\n\tHLDecomposition hl(n);\n\tfor (int i = 0, k; i < n; i++) {\n\t\tcin >> k;\n\t\tfor (int j = 0, c; j < k; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c > i) hl.add(i, c);\n\t\t}\n\t}\n\thl.build();\n\tcin >> q;\n\tfor (int i = 0, u, v; i < q; i++) {\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", hl.lca(u, v));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nclass LCA{\npublic:\n    ll V; // ????????°\n    vector<vector<ll>> T; // Tree\n    vector<pll> ET; // Euler Tour ET(dep, n)\n    vector<int> visited;\n    vector<ll> Ind; // ????????????????????????ET???index?????????\n    \n    ll N; // SegTree???????´???°\n    vector<pll> node; // SegTree\n    \n    LCA(ll V):V(V){\n        T.resize(V); Ind.resize(V);\n    }\n    \n    void add_edge(ll u,ll v){\n        T[u].emplace_back(v);\n        T[v].emplace_back(u);\n    }\n    \n    void fit(){\n        visited.clear(); visited.assign(V,0);\n        dfs(0,0);\n        ll N_ = ET.size();\n        N = 1;\n        while(N < N_) N*=2;\n        node.clear(); node.assign(2*N - 1,make_pair(INF,INF));\n        for(int i = 0; i < N_;i++) node[N-1+i] = ET[i];\n        for(int k = N - 2; k>=0;k--) node[k] = min(node[2*k+1],node[2*k+2]);\n    }\n    \n    void dfs(ll n,ll dep){\n        visited[n] = 1;\n        ET.emplace_back(make_pair(dep, n));\n        Ind[n] = (int)ET.size() - 1;\n        for(auto next:T[n]){\n            if(visited[next] == 1)continue;\n            dfs(next,dep +1);\n            ET.emplace_back(make_pair(dep,n));\n        }\n    }\n    \n    \n    pll RMQ(ll a,ll b){ return RMQ(a,b,0,0,N); }\n    pll RMQ(ll a,ll b,ll k,ll l, ll r){\n        if(r <= a || b <= l)return make_pair(INF,INF);\n        if(a <= l && r <= b)return node[k];\n        auto vl = RMQ(a,b,2*k+1,l,(l+r)/2);\n        auto vr = RMQ(a,b,2*k+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n    \n    ll solve(ll s,ll t){\n        ll idx1 = Ind[s],idx2 = Ind[t];\n        if(idx1 > idx2) swap(idx1,idx2);\n        \n        return RMQ(idx1,idx2+1).second;\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    \n    LCA lca(n);\n    \n    for(int i = 0; i < n;i++){\n        ll k; cin >> k;\n        for(int j = 0; j < k;j++){\n            ll c; cin >> c;\n            lca.add_edge(i, c);\n        }\n    }\n    \n    lca.fit();\n    \n    ll q; cin >> q;\n    for(int i = 0; i < q;i++){\n        ll u, v; cin >> u >> v;\n        cout << lca.solve(u,v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nvi MSB;\nvoid initMSB(int n){\n  MSB = vi(n+1,0);\n  int k = 2;\n  rep(i,n){\n    if(i+1==k)MSB[i+1] = MSB[i] + 1, k<<=1;\n    else MSB[i+1] = MSB[i];\n  }\n}\n\nstruct SparseTable{\n  vi val;\n  vector<vi> table;\n\n  SparseTable(void){}\n  SparseTable(const vi a):val(a){\n    int n = a.size();\n    initMSB(n);\n    table = vector<vi>(n,vi(MSB[n]+1,0));\n    rep(i,n)table[i][0] = i;\n\n    int k = 1;\n    rep(j,MSB[n]){\n      rep(i,n){\n\tint id1 = table[i][j], id2 = (i+k<n)?table[i+k][j]:id1;\n\ttable[i][j+1] = (val[id1]<=val[id2])?id1:id2;\n      }\n      k <<= 1;\n    }\n  }\n\n  int rmqi(int l, int r){\n    int ln = MSB[r-l];\n    int id1 = table[l][ln], id2 = table[r-(1<<ln)][ln];\n    return (val[id1]<=val[id2])?id1:id2;\n  }\n\n  int rmq(int l, int r){ return val[rmqi(l,r)]; }\n};\n\nstruct dif1RMQ{\n  int s;\n  vi val, subval, subid, bit;\n  SparseTable st;\n  vector< vector<vi> > lookup_table;\n\n  dif1RMQ(void){}\n  dif1RMQ(const vi a):val(a){\n    int n = a.size();\n    initMSB(n);\n    s = max(1,MSB[n]/2);\n    int m = (n+s-1)/s;\n\n    subval.resize(m); subid.resize(m); bit.resize(m);\n    rep(i,m){\n      subval[i] = val[s*i]; subid[i] = s*i;\n      int lim = min(s*(i+1),n);\n      for(int j=s*i;j<lim;j++){\n\tif(subval[i] > val[j]){ subval[i] = val[j]; subid[i] = j; }\n      }\n      bit[i] = 0;\n      for(int j=s*i;j<lim-1;j++){\n\tif(val[j]<val[j+1])bit[i] |= 1<<(j-s*i+1);\n      }\n    }\n    st = SparseTable(subval);\n\n    lookup_table.resize(1<<s);\n    rep(i,1<<s)lookup_table[i] = vector<vi>(s, vi(s,0));\n      \n    rep(i,1<<s)rep(j,s){\n      int cur = 0, minv = 0, minid = j;\n      lookup_table[i][j][j] = j;\n      for(int k=j+1;k<s;k++){\n\tif( (i>>k)&1 )cur++;\n\telse cur--;\n\tif(minv > cur){ minv = cur; minid = k; }\n\tlookup_table[i][j][k] = minid;\n      }\n    }\n  }\n\n  int rmqi(int l, int r){\n    //cerr << l << \" \" << r << endl;\n    r--;\n    int bl = l/s, br = r/s;\n    if(bl == br)return lookup_table[bit[bl]][l-bl*s][r-br*s] + bl*s;\n    else{\n      //cerr << bit[bl] << \" \"<< l-bl*s << \" \" << s << endl;\n      int res = lookup_table[bit[bl]][l-bl*s][s-1] + bl*s;\n      int tmp = lookup_table[bit[br]][0][r-br*s] + br*s;\n\n      //cerr << res << \" \" << tmp << endl;\n      if(val[res] > val[tmp])res = tmp;\n      if(br-bl>0){\n\ttmp = subid[st.rmqi(bl+1,br)];\n\tif(val[res] > val[tmp])res = tmp;\n      }\n      return res;\n    }\n  }\n\n  int rmq(int l, int r){ return val[rmqi(l,r)]; }\n};\n\nstruct LCA{\n  vi tour, depth, id;\n  dif1RMQ dr;\n  \n  LCA(void){}\n  LCA(const vector<vi> t,int root){\n    int n = t.size(), k = 0;\n    tour.resize(2*n-1); depth.resize(2*n-1); id.resize(n);\n    dfs(root,-1,0,k,t);\n    dr = dif1RMQ(depth);\n  }\n\n  void dfs(int v,int p, int d, int &k, const vector<vi> &t){\n    id[v] = k; tour[k] = v;\n    depth[k++] = d;\n    for(int u : t[v]){\n      if(u != p){\n\tdfs(u,v,d+1,k,t);\n\ttour[k] = v;\n\tdepth[k++] = d;\n      }\n    }\n  }\n\n  int lca(int u, int v){\n    int a = min(id[u],id[v]), b = max(id[u],id[v]);\n    return tour[dr.rmqi(a,b)];\n  }\n  int dep(int v){ return depth[id[v]]; }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<vi> g(n);\n  rep(i,n){\n    int k;\n    cin >> k;\n    rep(j,k){\n      int c;\n      cin >> c;\n      g[i].push_back(c);\n    }\n  }\n  LCA lca(g,0);\n  \n  int q;\n  cin >> q;\n  rep(i,q){\n    int a,b;\n    cin >> a >> b;\n    int x = lca.lca(a,b);\n    cout << x << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_V 501000\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n//RMQ\n\ntemplate<class T>\nclass RMQ{\nprivate:\n  int n;\n  T dat[2*MAX_V-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = ii(IINF,IINF);//ii(depth,index)\n  }\n \n  // k番めの値(0-indexed)をaに変更\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = (dat[k*2+1].first>dat[k*2+2].first?dat[k*2+2]:dat[k*2+1]);\n    }\n  }\n \n  T _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return ii(IINF,-1);\n    else if(a<=l && r<=b)return dat[k];\n     \n      T vl = _query(a,b,k*2+1,l,(l+r)/2);\n      T vr = _query(a,b,k*2+2,(l+r)/2,r);\n\n      return min(vl,vr);\n  }\n\n//nの範囲でミスしないように極力こっちを利用 \n  T query(int a,int b){\n    return _query(a,b,0,0,n);\n  }\n};\n\n//\n\nint V,query;\nvector<int> G[MAX_V];\nint root;\n\nint vs[MAX_V*2-1];\nint depth[MAX_V*2-1];\nint id[MAX_V];\n\nvoid dfs(int v,int p,int d,int &k){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  for(int i=0;i<G[v].size();i++){\n    if(G[v][i] != p){\n      dfs(G[v][i],v,d+1,k);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid init(RMQ<ii> &rmq){\n  int k = 0;\n  dfs(root,-1,0,k);\n\n  rmq.init(k+1);  \n  rep(i,k)rmq.update(i,ii(depth[i],vs[i]));\n}\n\nint lca(int u,int v,RMQ<ii> &rmq){\n  return rmq.query(min(id[u],id[v]),max(id[u],id[v])+1).second;\n}\n\n\nint main(){\n  int n;\n  cin >> n;\n  V = n;\n  rep(i,V){\n    int k,c;\n    cin >> k;\n    rep(j,k){\n      cin >> c;\n      G[i].push_back(c);\n      G[c].push_back(i);\n    }\n  }\n\n  RMQ<ii> rmq;\n  init(rmq);\n  int q,u,v;\n  cin >> q;\n  rep(i,q){\n    cin >> u >> v;\n    cout << lca(u,v,rmq) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define mod 1000000007ll\n#define setbit bitset<8>\n#define flagcount __builtin_popcount\n#define flag(x) (1 << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1 << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define count2way(v, x) high2way(v, x) - low2way(v, x)\n#define lower(v, x) low2way(v, x) - v.begin()       //1番左が0、もし見つから無いならｎを出力\n#define higher(v, x) high2way(v, x) - v.begin() - 1 //1番左が0、もし見つからないならn-1を出力（注意）\n#define putout(a) cout << a << endl\n#define putout2(a, b) \\\n    putout(a);        \\\n    putout(b)\n#define putout3(a, b, c) \\\n    putout(a);           \\\n    putout(b);           \\\n    putout(c)\n#define putout4(a, b, c, d) \\\n    putout(a);              \\\n    putout(b);              \\\n    putout(c);              \\\n    putout(d)\n#define putout5(a, b, c, d, e) \\\n    putout(a);                 \\\n    putout(b);                 \\\n    putout(c);                 \\\n    putout(d);                 \\\n    putout(e)\n#define Gput(a, b) G[a].push_back(b)\n#define cin1(a) cin >> a\n#define cin2(a, b) cin >> a >> b\n#define cin3(a, b, c) cin >> a >> b >> c\n#define cin4(a, b, c, d) cin >> a >> b >> c >> d\n#define cin5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\n#define Sum(v) accumulate(all(v), 0ll)\n#define gcd(x, y) __gcd(x, y)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return 0;\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nT modinv(T a, T m)\n{\n    T b = m, u = 1, v = 0;\n    while (b)\n    {\n        T t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//多次元配列の宣言法\n//vector<vector<ll>> field(h, vector<ll>(w));\ntemplate <class T>\ninline void chmax(T &a, T b)\n{\n    if (a < b)\n        a = b;\n}\ntemplate <class T>\ninline void chmin(T &a, T b)\n{\n    if (a > b)\n        a = b;\n}\n/*\nライブラリをここに置いてコメントを削除\n*/\nstruct lca_Edge\n{\n    long long to;\n};\nusing lca_Graph = vector<vector<lca_Edge>>;\n\n/* LCA(G, root): 木 G に対する根を root として Lowest Common Ancestor を求める構造体\n    query(u,v): u と v の LCA を求める。計算量 O(logn)\n    前処理: O(nlogn)時間, O(nlogn)空間\n*/\nstruct LCA\n{\n    vector<vector<ll>> parent; // parent[k][u]:= u の 2^k 先の親\n    vector<ll> dist;           // root からの距離\n    LCA(const lca_Graph &G, ll root = 0) { init(G, root); }\n\n    // 初期化\n    void init(const lca_Graph &G, ll root = 0)\n    {\n        ll V = G.size();\n        ll K = 1;\n        while ((1 << K) < V)\n            K++;\n        parent.assign(K, vector<ll>(V, -1));\n        dist.assign(V, -1);\n        lca_dfs(G, root, -1, 0);\n        for (int k = 0; k + 1 < K; k++)\n        {\n            for (int v = 0; v < V; v++)\n            {\n                if (parent[k][v] < 0)\n                {\n                    parent[k + 1][v] = -1;\n                }\n                else\n                {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n\n    // 根からの距離と1つ先の頂点を求める\n    void lca_dfs(const lca_Graph &G, ll v, ll p, ll d)\n    {\n        parent[0][v] = p;\n        dist[v] = d;\n        for (auto e : G[v])\n        {\n            if (e.to != p)\n                lca_dfs(G, e.to, v, d + 1);\n        }\n    }\n\n    ll query(ll u, ll v)\n    {\n        if (dist[u] < dist[v])\n            swap(u, v); // u の方が深いとする\n        ll K = parent.size();\n        // LCA までの距離を同じにする\n        for (ll k = 0; k < K; k++)\n        {\n            if ((dist[u] - dist[v]) >> k & 1)\n            {\n                u = parent[k][u];\n            }\n        }\n        // 二分探索で LCA を求める\n        if (u == v)\n            return u;\n        for (ll k = K - 1; k >= 0; k--)\n        {\n            if (parent[k][u] != parent[k][v])\n            {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    ll get_dist(ll u, ll v)\n    {\n        return dist[u] + dist[v] - 2 * dist[query(u, v)];\n    }\n\n    bool is_on_path(ll u, ll v, ll a)\n    {\n        return get_dist(u, a) + get_dist(a, v) == get_dist(u, v);\n    }\n};\n\nint main()\n{\n    cout << fixed << setprecision(30);\n    ll n;\n    cin >> n;\n    lca_Graph G(n);\n    loop(i, n)\n    {\n        ll k;\n        cin >> k;\n        loop(j, k)\n        {\n            ll x;\n            cin >> x;\n            lca_Edge e;\n            e.to = x;\n            G[i].push_back(e);\n        }\n    }\n    ll q;\n    cin >> q;\n    LCA tree(G);\n    loop(i, q)\n    {\n        ll u, v;\n        cin >> u >> v;\n        ll par = tree.query(u, v);\n        putout(par);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// LCA\ntemplate<typename T>\nstruct lca {\n  int n, root, l;\n  vector< vector<int> > to;\n  vector< vector<T> > co; // co[i][j] .. costs between i - to[i][j]\n  vector<int> dep; // depth from root.\n  vector<T> costs; // cumulative cost from root.\n  vector< vector<int> > par; // par[i][j] .. i's anccestor. The distance from i is 2**j.\n\n  lca(int n) : n(n), to(n), co(n), dep(n), costs(n) {\n    l = 0;\n    while ((1<<l) < n) { ++l; }\n    par = vector< vector<int> >(n+1, vector<int>(l, n));\n  }\n  void addedge(int a, int b, T c) {\n    to[a].push_back(b);\n    co[a].push_back(c);\n    to[b].push_back(a);\n    co[b].push_back(c);\n  }\n  void init(int _root) {\n    root = _root;\n    dfs(root);\n    rep(i, l-1) {\n      rep(v, n) {\n        par[v][i+1] = par[par[v][i]][i];\n      }\n    }\n  }\n  void dfs(int v, int d = 0, T c = 0, int p = -1) {\n    if (p != -1) { par[v][0] = p; }\n    dep[v] = d;\n    costs[v] = c;\n    rep(i, to[v].size()) {\n      int u = to[v][i];\n      if (u == p) { continue; }\n      dfs(u, d + 1, c + co[v][i], v);\n    }\n  }\n  int operator()(int a, int b) { // lca between a and b\n    if (dep[a] > dep[b]) { swap(a, b); }\n    int gap = dep[b] - dep[a];\n    for (int i = l-1; i >= 0; --i) {\n      int len = 1<<i;\n      if (gap >= len) {\n        gap -= len;\n        b = par[b][i];\n      }\n    }\n    if (a == b) { return a; }\n    for (int i = l-1; i>=0; --i) {\n      int na = par[a][i];\n      int nb = par[b][i];\n      if (na != nb) {\n        a = na;\n        b = nb;\n      }\n    }\n    return par[a][0];\n  }\n  int length(int a, int b) {\n    int c = lca(a, b);\n    return dep[a] + dep[b] - dep[c]*2;\n  }\n  int cost(int a, int b) {\n    int c = lca(a, b);\n    return costs[a] + costs[b] - costs[c]*2;\n  }\n};\n\n// int main(int argc, char** argv) {\n//   int N, Q;\n//   cin >> N >> Q;\n//\n//   lca<ll> g(N);\n//\n//   rep(i, N-1) {\n//     int a, b, d;\n//     cin >> a >> b >> d;\n//     --a; --b;\n//     g.addedge(a, b, d);\n//   }\n//   g.init(0);\n//\n//   rep(i, Q) {\n//     int a, b;\n//     cin >> a >> b;\n//     --a; --b;\n//     int c = g(a, b); // c is the lowest common ancestor of a and b.\n//     int ans = g.costs[a] + g.costs[b] - g.costs[c] * 2; // The distance between a and b.\n//     cout << a + 1 << \"-\" << b + 1 << \": \" << ans << endl; // e.g. 1-4: 40\n//   }\n// }\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  ll n;\n  cin >> n;\n  lca<ll> g(n);\n  rep(u,n) {\n    ll k;\n    cin >> k;\n    rep(i,k) {\n      ll v;\n      cin >> v;\n      g.addedge(u, v, 0); // Here, we don't need cost\n    }\n  }\n  g.init(0);\n\n  ll q;\n  cin >> q;\n  rep(iter, q) {\n    ll u, v;\n    cin >> u >> v;\n    cout << g(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\nclass LCA {\npublic:\n    int NV, logNV;\n    vector<int> D;\n    vector<vector<int>> P;\n    vector<vector<int>> E;\n\n    LCA() {}\n    void init(int N) {\n        NV = N;\n        logNV = 1;\n        while (NV > (1LL << logNV)) logNV++;\n        D = vector<int>(NV);\n        P = vector<vector<int> >(logNV, vector<int>(NV));\n        E = vector<vector<int>>(N);\n    }\n\n    void add_edge(int a, int b) {\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n\n    void make() {\n        dfs(0, -1, 0);\n        build();\n    }\n\n    void dfs(int v, int par, int d) {\n        D[v] = d;\n        P[0][v] = par;\n        for (int i : E[v]) if (i != par) dfs(i, v, d + 1);\n    }\n\n    void build() {\n        for (int k = 0; k < logNV - 1; k++) for (int v = 0; v < NV; v++) {\n            if (P[k][v] < 0)\n                P[k + 1][v] = -1;\n            else\n                P[k + 1][v] = P[k][P[k][v]];\n        }\n    }\n\n    int lca(int u, int v) {\n        if (D[u] > D[v]) swap(u, v);\n        for(int k = 0;k < logNV;k++) if ((D[v] - D[u]) >> k & 1) v = P[k][v];\n        if (u == v) return u;\n\n        for (int k = logNV - 1; k >= 0; k--) {\n            if (P[k][u] != P[k][v]) {\n                u = P[k][u];\n                v = P[k][v];\n            }\n        }\n        return P[0][u];\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    int N; cin >> N;\n    LCA lca;\n    lca.init(N);\n    rep(i, 0, N) {\n        int K; cin >> K;\n        rep(j, 0, K) {\n            int c; cin >> c;\n            lca.add_edge(i, c);\n        }\n    }\n    lca.make();\n\n    int Q; cin >> Q;\n    rep(q, 0, Q) {\n        int a, b; cin >> a >> b;\n        int ans = lca.lca(a, b);\n        printf(\"%d\\n\", ans);\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nstruct sqrt_decomp_tree {\n    int n, B;\n    int size() const {\n        return n;\n    }\n    \n    vi parent, // 親のノード\n    depth, // ノードの深さ\n    block, // ノードが属するブロック\n    block_depth, // ノードが属するブロックの根の深さ\n    block_parent, // ノードが属するブロックの根の親ノード\n    visited;\n    \n    vvi adj;\n    sqrt_decomp_tree(int n) : n(n), adj(n), parent(n, -1), depth(n), block(n, -1), block_depth(n, -1), block_parent(n, -1), visited(n) {\n        int l = 0, r = n;\n        while (l < r - 1) {\n            i64 m = (l + r) / 2;\n            if (m * m >= n) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        B = r;\n    }\n    \n    void addEdge(int a, int b) {\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    void decomp(int root = 0) {\n        vi tord;\n        vi q(n + 1);\n        int l = 0, r = 0;\n        q[r++] = root;\n        while (l != r) {\n            int v = q[l++];\n            visited[v] = 1;\n            tord.push_back(v);\n            for (int s: adj[v]) {\n                if (!visited[s]) {\n                    parent[s] = v;\n                    depth[s] = depth[v] + 1;\n                    q[r++] = s;\n                }\n            }\n        }\n        visited.assign(n, 0);\n        int c = 0;\n        for (int u: tord) {\n            if (block[u] != -1) continue;\n            l = 0;\n            r = 0;\n            q[r++] = u;\n            for (int i = 0; i < B && l != r; i++) {\n                int v = q[l++];\n                block[v] = c;\n                block_parent[v] = parent[u];\n                block_depth[v] = depth[u];\n                for (int s: adj[v]) {\n                    if (block[s] == -1) q[r++] = s;\n                }\n            }\n            c++;\n        }\n    }\n    \n    int lca(int u, int v) {\n        while (block_depth[u] > block_depth[v]) {\n            u = block_parent[u];\n        }\n        while (block_depth[u] < block_depth[v]) {\n            v = block_parent[v];\n        }\n        while (depth[u] > depth[v]) {\n            u = parent[u];\n        }\n        while (depth[u] < depth[v]) {\n            v = parent[v];\n        }\n        if (u != v) {\n            u = parent[u];\n            v = parent[v];\n        }\n        return u;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    sqrt_decomp_tree tree(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int u;\n            cin >> u;\n            tree.addEdge(i, u);\n        }\n    }\n    \n    tree.decomp();\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PI 4*atan(1.0)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int SIZE=100001;\n//int arr[SIZE]={};\n//???????????§???????????¬\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tGraph G;\n\tfor(int i=0;i<N;i++){\n\t\tEdges E;\n\t\tG.push_back(E);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint l;\n\t\t\tcin>>l;\n\t\t\tG[i].push_back(Edge(i,l,1));\n\t\t\tG[l].push_back(Edge(l,i,1));\n\t\t}\n\t}\n\tint Q;\n\tcin>>Q;\n\tvector<Query> VQ;\n\tfor(int i=0;i<Q;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tVQ.push_back(Query(a,b));\n\t}\n\n\tleastCommonAncestor(G,0,VQ);\n\n\tfor(int i=0;i<Q;i++){\n\t\tcout<<VQ[i].w<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define all(vec) vec.begin(),vec.end()\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<60;\nconst double eps=1e-9;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value==0>::type fill_v(T& t,const V& v){t=v;}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value!=0>::type fill_v(T& t,const V& v){for(auto &e:t)fill_v(e,v);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nvector<vector<int>> G,par;\nvector<int> dep;\nint n;\nvoid dfs(int i,int p){\n\tfor(auto e:G[i]){\n\t\tif(e==p)continue;\n\t\tpar[e][0]=i;\n\t\tdep[e]=dep[i]+1;\n\t\tdfs(e,i);\n\t}\n}\nvoid build(){\n\tpar[0][0]=-1;\n\tdep[0]=0;\n\tdfs(0,-1);\n\tfor(int j=1;j<20;j++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(par[i][j-1]==-1){\n\t\t\t\tpar[i][j]=-1;\n\t\t\t}else{\n\t\t\t\tpar[i][j]=par[par[i][j-1]][j-1];\n\t\t\t}\n\t\t}\n\t}\n}\nint lca(int u,int v){\n\tif(dep[u]>dep[v])swap(u,v);\n\tfor(int i=19;i>=0;i--){\n\t\tif(((dep[v]-dep[u])>>i)&1)v=par[v][i];\n\t}\n\tif(u==v)return u;\n\tfor(int i=19;i>=0;i--){\n\t\tif(par[u][i]!=par[v][i]){\n\t\t\tu=par[u][i];\n\t\t\tv=par[v][i];\n\t\t}\n\t}\n\treturn par[u][0];\n}\nint main(){\n\tcin>>n;\n\tG.resize(n);\n\tpar.resize(n);\n\tdep.resize(n);\n\tfor(int i=0;i<n;i++){\n\t\tint c;cin>>c;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint ch;cin>>ch;\n\t\t\tG[i].push_back(ch);\n\t\t}\n\t\tpar[i].resize(30);\n\t}\n\tint q;cin>>q;\n\tbuild();\n\twhile(q--){\n\t\tint u,v;cin>>u>>v;\n\t\tcout<<lca(u,v)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\n\nint n,q;\nvector<int>G[maxn];\nint fa[maxn],dep[maxn],size[maxn],son[maxn],top[maxn];\n\nvoid dfs1(int u,int p) {\n    size[u]=1;\n    for (int v:G[u]) {\n        if (v==p) continue;\n        fa[v]=u;\n        dep[v]=dep[u]+1;\n        dfs1(v,u);\n        size[u]+=size[v];\n        if (size[son[u]]<size[v]) son[u]=v;\n    }\n}\n\nvoid dfs2(int u,int t) {\n    top[u]=t;\n    if (son[u]) dfs2(son[u],t);\n    for (int v:G[u])\n        if (v!=fa[u] && v!=son[u])\n            dfs2(v,v);\n}\n\nint lca(int u,int v) {\n    while (top[u]!=top[v]) {\n        if (dep[top[v]]<dep[top[u]]) swap(u,v);\n        v=fa[top[v]];\n    }\n    return dep[u]<dep[v]?u:v;\n}\n\nint main() {\n    cin>>n;\n    for (int i=1;i<=n;i++) {\n        int m; cin>>m;\n        for (int j=0;j<m;j++) {\n            int v; cin>>v; ++v;\n            G[i].pb(v);\n            G[v].pb(i);\n        }\n    }\n    dfs1(1,0);\n    dfs2(1,1);\n    cin>>q;\n    while (q--) {\n        int u,v; cin>>u>>v; ++u; ++v;\n        cout<<lca(u,v)-1<<'\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathRoot;\n\n  HeavyLight(vector<vector<int> >t)\n    :tree(t),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n  LowestCommonAncestor(size_t size) : size(size), MaxlgV(1 << (32 - __builtin_clz(size - 1))), G(size), dep(size), par(MaxlgV, vector<int>(size)) {}\n\n  size_t size, MaxlgV;\n  int root;\n  vector<vector<int>> G, par;\n  vector<int> dep;\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int u, int d) {\n    dep[v] = d;\n    par[0][v] = u;\n    for (int e : G[v])\n      if (e != u) dfs(e, v, d + 1);\n  }\n\n  void build(int r) {\n    dfs(root = r, -1, 0);\n    for (int k = 0; k + 1 < MaxlgV; k++) {\n      for (int v = 0; v < size; v++) {\n        if (par[k][v] < 0)\n          par[k + 1][v] = -1;\n        else\n          par[k + 1][v] = par[k][par[k][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (dep[u] > dep[v]) swap(u, v);\n    for (int k = 0; k < MaxlgV; k++) {\n      if ((dep[v] - dep[u]) >> k & 1) {\n        v = par[k][v];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int k = MaxlgV - 1; k >= 0; k--) {\n      if (par[k][u] != par[k][v]) {\n        u = par[k][u];\n        v = par[k][v];\n      }\n    }\n\n    return par[0][u];\n  }\n\n  int dist(int u, int v) {\n    int z = lca(u, v);\n    return dep[u] + dep[v] - 2 * dep[z];\n  }\n};\n\n// https://onlinejudge.u-aizu.ac.jp/#/courses/library/5/GRL/5/GRL_5_C\nint main() {\n  int N;\n  cin >> N;\n\n  LowestCommonAncestor tree(N);\n  for (int i = 0; i < N; ++i) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int c;\n      cin >> c;\n\n      tree.add_edge(i, c);\n    }\n  }\n\n  tree.build(0);\n\n  int q;\n  cin >> q;\n\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n\n    cout << tree.lca(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    enum { B = 1000 };\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(visited[c]) continue;\n                parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c;\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <utility>\n#include <cassert>\n#include <stack>\n\nstruct HeavyLightDecomposition {\npublic:\n\tusing value_type = int;\n\tusing const_reference = const value_type &;\n\tusing size_type = std::size_t;\n\t\n\tHeavyLightDecomposition(const std::vector<std::vector<size_type>> &g, size_type root_num = 0) {\n\t\tbuild(g, root_num);\n\t}\n\t\n\tsize_type size() const noexcept {\n\t\treturn size_;\n\t}\n\t\n\tsize_type lca(size_type x, size_type y) const {\n\t\tassert(x < size() && y < size());\n\t\tif (node_idx[x] == node_idx[y]) return ver_num[node_idx[x]][std::max(path_idx[x], path_idx[y])];\n\t\tstd::stack<size_type> stk[2];\n\t\tfor (size_type i = 0; i < 2; ++i) {\n\t\t\tstk[i].emplace(-1);\n\t\t\tstk[i].emplace(i == 0 ? x : y);\n\t\t\twhile (true) {\n\t\t\t\tsize_type top_num = ver_num[node_idx[stk[i].top()]].back();\n\t\t\t\tsize_type par = par_num[top_num];\n\t\t\t\tif (top_num == par) break;\n\t\t\t\tstk[i].emplace(par);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsize_type lca_pred[2];\n\t\twhile (node_idx[stk[0].top()] == node_idx[stk[1].top()]) {\n\t\t\tfor (size_type i = 0; i < 2; ++i) {\n\t\t\t\tlca_pred[i] = stk[i].top();\n\t\t\t\tstk[i].pop();\n\t\t\t}\n\t\t}\n\t\treturn ver_num[node_idx[lca_pred[0]]][std::max(path_idx[lca_pred[0]], path_idx[lca_pred[1]])];\n\t}\n\t\nprivate:\n\tsize_type size_;\n\tstd::vector<size_type> node_idx; // node_idx[i] := 頂点 i が属する分解後の列の index\n\tstd::vector<size_type> path_idx; // path_idx[i] := 頂点 i が属する分解後の列での頂点 i の index\n\tstd::vector<std::vector<size_type>> ver_num; // [i][j] := 分解後の列 i の j 番目の要素の分解前の頂点番号\n\t\n\tstd::vector<size_type> par_num; // par_num[i] := 頂点 i の親の頂点番号\n\tstd::vector<std::vector<size_type>> childs; // childs[i] := 頂点 i の子の頂点番号\n\tstd::vector<value_type> value; // <<<未実装>>>, 頂点や辺の値\n\t\n\tvoid build(const std::vector<std::vector<size_type>> &g, size_type root_num = 0) {\n\t\tsize_ = g.size();\n\t\tnode_idx.resize(size());\n\t\tpath_idx.resize(size());\n\t\tpar_num.resize(size());\n\t\tchilds.resize(size());\n\t\t\n\t\tstd::vector<bool> done(size(), 0);\n\t\tstd::vector<size_type> sub_size(size(), 0);\n\t\t\n\t\tstd::stack<std::pair<size_type, size_type>> stk;\n\t\tstk.emplace(root_num, 0);\n\t\tpar_num[root_num] = root_num;\n\t\tdone[root_num] = true;\n\t\t\n\t\twhile (!stk.empty()) {\n\t\t\tint u = stk.top().first;\n\t\t\tint idx = stk.top().second;\n\t\t\tstk.pop();\n\t\t\t\n\t\t\tif (idx < g[u].size()) {\n\t\t\t\tstk.emplace(u, idx + 1);\n\t\t\t\t\n\t\t\t\tint v = g[u][idx];\n\t\t\t\tif (!done[v]) {\n\t\t\t\t\tdone[v] = true;\n\t\t\t\t\tpar_num[v] = u;\n\t\t\t\t\tchilds[u].push_back(v);\n\t\t\t\t\tstk.emplace(v, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsize_type mx_idx, mx_size = 0, size_cnt = 1;\n\t\t\t\tfor (size_type child : childs[u]) {\n\t\t\t\t\tsize_cnt += sub_size[child];\n\t\t\t\t\tif (mx_size < sub_size[child]) {\n\t\t\t\t\t\tmx_size = sub_size[child];\n\t\t\t\t\t\tmx_idx = child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (size_cnt == 1) ver_num.emplace_back();\n\t\t\t\tsize_type cur_node_idx = size_cnt == 1 ? ver_num.size() - 1 : node_idx[mx_idx];\n\t\t\t\tsub_size[u] = size_cnt;\n\t\t\t\tnode_idx[u] = cur_node_idx;\n\t\t\t\tpath_idx[u] = ver_num[node_idx[u]].size();\n\t\t\t\tver_num[node_idx[u]].emplace_back(u);\n\t\t\t}\n\t\t}\n\t}\n};\n\n#include <cstdio>\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\t\n\tusing HLD = HeavyLightDecomposition;\n\tstd::vector<std::vector<HLD::size_type>> g(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tg[i].emplace_back(c);\n\t\t\tg[c].emplace_back(i);\n\t\t}\n\t}\n\t\n\tHLD hld(g);\n\t\n\t// if (1) {\n\t// \tfor (int i = 0; i < hld.ver_num.size(); ++i) {\n\t// \t\tprintf(\": \");\n\t// \t\tfor (int j = 0; j < hld.ver_num[i].size(); ++j) {\n\t// \t\t\tprintf(\"%d \", hld.ver_num[i][j]);\n\t// \t\t}\n\t// \t\tputs(\"\");\n\t// \t}\n\t\t\n\t// \tputs(\"-- childs information --\");\n\t// \tfor (int i = 0; i < N; ++i) {\n\t// \t\tif (hld.childs[i].size() == 0) continue;\n\t// \t\tprintf(\"i=%d : \", i);\n\t// \t\tfor (int j : hld.childs[i]) {\n\t// \t\t\tprintf(\"%d \", j);\n\t// \t\t}\n\t// \t\tputs(\"\");\n\t// \t}\n\t\t\n\t// \tputs(\"-- node_index information --\");\n\t// \tfor (int i = 0; i < hld.size(); ++i) {\n\t// \t\tprintf(\"%d \", hld.node_idx[i]);\n\t// \t}\n\t// \tputs(\"\");\n\t// \tputs(\"-- path_index information --\");\n\t// \tfor (int i = 0; i < hld.size(); ++i) {\n\t// \t\tprintf(\"%d \", hld.path_idx[i]);\n\t// \t}\n\t// \tputs(\"\");\n\t// \tputs(\"-- par_num information --\");\n\t// \tfor (int i = 0; i < hld.size(); ++i) {\n\t// \t\tprintf(\"%d \", hld.par_num[i]);\n\t// \t}\n\t// \tputs(\"\");\n\t// }\n\t\n\tint Q;\n\tscanf(\"%d\", &Q);\n\twhile (Q--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tprintf(\"%d\\n\", hld.lca(u, v));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nstruct LCA{\n    vector<vector<int>>& g;\n    const int V;\n    vector<int> depth;\n    vector<vector<int>> table;\n    const int ub_log;\n\n    LCA(vector<vector<int>>& g) : g(g), V(g.size()), ub_log(32 - __builtin_clz(g.size())) {\n        depth.resize(V);\n        table.resize(ub_log, vector<int>(V));\n    }\n\n    void dfs(int from, int d = 0, int par = -1){\n        table[0][from] = par;\n        depth[from] = d;\n        for(int to : g[from]){\n            if(to == par)   continue;\n            dfs(to, d + 1, from);\n        }\n        return;\n    }\n\n    void build(int root = 0){\n        dfs(root);\n        for(int k = 0; k + 1 < ub_log; ++k){\n            for(int i = 0; i < V; ++i){\n                if(table[k][i] == -1)   table[k + 1][i] = -1;\n                else    table[k + 1][i] = table[k][table[k][i]];\n            }\n        }\n    }\n\n    int query(int u, int v){\n        if(depth[u] > depth[v]) swap(u, v);\n        int d = depth[v] - depth[u];\n        for(int i = ub_log - 1; i >= 0; --i){\n            if(d >> i & 1)  v = table[i][v];\n        }\n        if(u == v)  return u;\n        for(int i = ub_log - 1; i >= 0; --i){\n            if(table[i][u] != table[i][v]){\n                u = table[i][u];\n                v = table[i][v];\n            }\n        }\n        return table[0][u];\n    }\n\n    int dist(int u, int v){\n        return depth[u] + depth[v] - depth[query(u, v)] * 2;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n);\n    for(int i = 0; i < n; ++i){\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j){\n            int v;\n            cin >> v;\n            graph[i].emplace_back(v);\n            graph[v].emplace_back(i);\n        }\n    }\n    LCA lca(graph);\n    lca.build();\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >t)\n    :tree(t),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<vector>\n#include<cmath>\n#include<utility>\n\ntemplate<typename Label>\nclass RootedTree {\npublic:\n  RootedTree(const Label& root) : root_(root) {}\n  void add(const Label& p, const Label& c) {child_[p].push_back(c);}\n  void init() {init(root_, 0);}\n  Label lca(Label u, Label v) {\n    // u, v を同じ深さにする O(log(深さの差))\n    if(depth_[v] < depth_[u]) std::swap(u, v);\n    int difference = depth_[v] - depth_[u];\n    for(int i = 1; i <= difference; i <<= 1)\n      if(difference & i)\n        v = parent_[v][i];\n    // lca を求める O(log(深さ))\n    if(u == v) return u;\n    int bits = log2(depth_[u]);\n    for(int i = 1 << bits; 0 < i; i >>= 1) {\n      if(parent_[u][i] == parent_[v][i]) continue;\n      u = parent_[u][i];\n      v = parent_[v][i];\n    }\n    return parent_[u][1];\n  }\nprivate:\n  void init(const Label& current, int depth) {\n    depth_[current] = depth;\n    for(int i = 2; i <= depth; i <<= 1) parent_[current][i] = parent_[parent_[current][i >> 1]][i >> 1];\n    for(const auto& v: child_[current]) {\n      parent_[v][1] = current;\n      init(v, depth + 1);\n    }\n  }\n  Label root_;\n  std::unordered_map<Label, int> depth_;\n  std::unordered_map<Label, std::vector<Label>> child_;\n  std::unordered_map<Label, std::unordered_map<int, Label>> parent_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  RootedTree<int> t(0);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      t.add(i, c);\n    }\n  }\n  t.init();\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << t.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconst int MAX_N = 200001;\n\n\n\nint D[MAX_N];// (HL分解後にあるnodeとあるnodeが同じHeavyPathに含まれているかどうか)\nint find(int a){return a-D[a]?(D[a]=find(D[a])):a; }\n  \nstruct node{\n  int id;\n  vector<int> to;\n  int h;//深さ\n  node(){ h = -1; }\n  bool operator<(const node& n) const{\n    return h < n.h;\n  }\n};\n  \nstruct HL_node{\n  int h;\n  vector<int> v;//sortされる\n  int np;//Light-edgeで結ばれた親\n};\n  \nbool used[MAX_N];\nint vid[MAX_N];\nnode G[MAX_N];//子への辺をもつ\nHL_node HL[MAX_N];\nint V;//頂点数\n\n  \nint dfs(int id,int h){\n  if( G[id].h>-1 ) return 0;\n  G[id].h = h;\n  vector<int> cs; int sum =1;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    cs.push_back(dfs(G[id].to[i],h+1)); sum+=cs.back();\n  }\n  if( sum == 1 ) return sum;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    if( sum/2 <= cs[i] ){\n      D[G[id].to[i]] = find(id);break;    \n    }\n  }\n  return sum;\n}\n\nvoid HeavyLightDecomposition(int root){\n  for(int i=0;i<V;i++) D[i] = i;\n  memset(used,0,sizeof(used));\n  dfs(root,0);\n  sort(G,G+V);\n  vector<int> vs;//after_hl\n  for(int i=0;i<V;i++) vid[G[i].id] = i;\n  for(int i=0;i<V;i++){\n    int now = G[i].id;\n    used[now] = true;\n    HL[find(now)].v.push_back(now);\n    for(int j=0;j<(int)G[vid[now]].to.size();j++){\n      int to = G[vid[now]].to[j];\n      if( used[to] ) continue;\n      if( find(to) == find(now) ) continue;\n      HL[find(to)].np = now;\n      HL[find(to)].h = HL[find(now)].h+1;\n    }  \n  }\n\n}\n  \nint HeavyLightLCA(int a, int b){\n  for(; HL[find(a)].h != HL[find(b)].h ; HL[find(a)].h>HL[find(b)].h?(a=HL[find(a)].np):(b=HL[find(b)].np) );\n  for(; find(a) != find(b) ; a = HL[find(a)].np, b = HL[find(b)].np );\n  return vid[a]<vid[b]?a:b;\n}\n\nint main(){\n  cin >> V;\n  for(int i=0;i<V;i++){\n    G[i].id = i;\n    int k; cin >> k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin >> c;\n      G[i].to.push_back( c );\n    }\n  }\n  HeavyLightDecomposition(0);\n  int Q;\n  cin >> Q;\n  for(int i=0;i<Q;i++){ \n    int u,v; cin >> u>> v;\n    cout << HeavyLightLCA(u,v) << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nstruct UnionFind{\n    vector<int> par,rank,ss;\n    int size;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);if(x==y)return;\n        if(rank[x]>rank[y])swap(x,y);\n        par[x] = y;ss[y]+=ss[x];\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\ntypedef vector<vector<int>> Graph;\nclass TarjanLCA{\npublic:\n\tGraph& g; UnionFind uf;\n\t\n\tvector<int> ancestor;vector<bool> passed;\n\n\tTarjanLCA(Graph &g):g(g),uf(UnionFind(g.size())){\n\t\tpassed=vector<bool>(g.size());ancestor=vector<int>(g.size());\n\t};\n\tvoid visit(int p,int s,vector<tuple<int,int,int>> &qs) {\n\t\tancestor[uf.root(s)] = s;\n\t\tfor(int t:g[s]) if(t != p) {\n\t\t\tvisit(s,t,qs);\n\t\t\tuf.unite(s,t);\n\t\t\tancestor[uf.root(s)] = s;\n\t\t}\n\t\tpassed[s] = true;\n\t\tfor(auto& q:qs){\n\t\t\tint w = (get<1>(q) == s ? get<0>(q) : get<0>(q) == s ? get<1>(q) : -1);\n\t\t\tif (w >= 0 && passed[w]){\n\t\t\t\tget<2>(q) = ancestor[uf.root(w)];\n\t\t\t}\n\t\t}\n\t}\n\tvoid leastCommonAncestor(int r,vector<tuple<int,int,int>>& qs){\n\t\tvisit(-1,r,qs);\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t);\n\t\t\t\tg[t].push_back(i);\n\t\t\t}\n\t\t}\n\t\tTarjanLCA lca(g);\n\t\tint q;cin >>q;\n\t\tvector<tuple<int,int,int>> qs(q);\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tqs[i]={u,v,-1};\n\t\t}\n\t\tlca.leastCommonAncestor(0,qs);\n\n\t\tREP(i,q){\n\t\t\tcout << get<2>(qs[i])<<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// LCA: Doubling\n//   ?????????: O(n * log n)\n//   ?????¨???: O(log n)\n\n// ???????????????\n#include<unordered_map>\n#include<vector>\n#include<algorithm>\n// ?????????\ntemplate<typename Label>\nclass RootedTree {\npublic:\n  void join(const Label& u, const Label& v);\n  void initialize(const Label& root);\n  const Label parent(Label v, int n) const;\n  const Label lca(Label u, Label v) const;\nprivate:\n  void initialize(const Label& current, const Label& previous, int depth);\n  std::unordered_map<Label, std::vector<Label>> edge_;\n  std::unordered_map<Label, std::vector<Label>> parent_;\n  std::unordered_map<Label, int> depth_;\n};\n// ????????????\ntemplate<typename Label>\nvoid RootedTree<Label>::join(const Label& u, const Label& v) {\n  edge_[u].push_back(v);\n  edge_[v].push_back(u);\n}\n// ??????v???n????????????\ntemplate<typename Label>\nconst Label RootedTree<Label>::parent(Label v, int n) const {\n  if(!n) return v;\n  if(__builtin_popcount(n) == 1) return parent_.at(v).at(__builtin_ctz(n));\n  for(int i = 31 - __builtin_clz(n); 0 <= i; --i) if((n >> i) & 1) v = parent_.at(v).at(i);\n  return v;\n}\n// ?????????\ntemplate<typename Label>\nvoid RootedTree<Label>::initialize(const Label& root) {initialize(root, root, 0);}\ntemplate<typename Label>\nvoid RootedTree<Label>::initialize(const Label& current, const Label& previous, int depth) {\n  depth_[current] = depth;\n  parent_[current].push_back(previous);\n  for(int i = 1; (1 << i) <= depth; ++i) parent_[current].push_back(parent_[parent_[current][i - 1]][i - 1]);\n  for(const auto& next: edge_[current]) if(next != previous) initialize(next, current, depth + 1);\n}\n// LCA\ntemplate<typename Label>\nconst Label RootedTree<Label>::lca(Label u, Label v) const {\n  // u, v???????????±????????????\n  if(depth_.at(u) > depth_.at(v)) std::swap(u, v);\n  v = parent(v, depth_.at(v) - depth_.at(u));\n  // LCA????±???????\n  if(u == v) return u;\n  for(int i = 31 - __builtin_clz(depth_.at(u)); 0 <= i; --i) {\n    if(parent_.at(u).at(i) == parent_.at(v).at(i)) continue;\n    u = parent_.at(u).at(i);\n    v = parent_.at(v).at(i);\n    i = std::min(i, 31 - __builtin_clz(depth_.at(u)) + 1);\n  }\n  return parent_.at(u).at(0);\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  RootedTree<int> tree;\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      tree.join(i, c);\n    }\n  }\n  tree.initialize(0);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << tree.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nstruct LCA {\n    int V;//頂点数\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    int MAX_LOG_V = 1;\n    int root = 0;//根ノードの番号\n\n    vector<vector<int>> parent;//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1とする)\n    vector<int> depth;//根からの深さ\n\n    LCA(int V) {\n        this->V = V;\n        while (1 << MAX_LOG_V < V) {//バグが怖い\n            MAX_LOG_V++;\n        }\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n\n    /**\n     * 辺を追加した後に初期化をする\n     */\n    void init() {\n        //parentとdepthの初期化\n        dfs(root, -1, 0);\n        //parentを初期化する\n        for(int k = 0; k + 1 < MAX_LOG_V; k++){\n            for(int v = 0; v < V; v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n\n    /**\n     * uとvのlcaを求める\n     * @param u 頂点\n     * @param v 頂点\n     * @return lcaとなる頂点\n     */\n    int lca(int u, int v) {\n        //uとvの高さが同じになるまで親を辿る\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k < MAX_LOG_V; k++) {\n            if((depth[v] - depth[u]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        //二分探索でLCAを求める\n        for (int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /**\n     * 辺を追加する\n     * @param from 元\n     * @param to 先\n     */\n    void add_edge(int from,int to){\n        G[from].push_back(to);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.init();\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n//    cout << \"---\" << endl;\n//    rep(i,0,lca.G.size()){\n//        rep(j,0,lca.G[i].size()){\n//            cout << i << \" \" << lca.G[i][j] << endl;\n//        }\n//    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\nconstexpr int INF = 0x3f3f3f3f; constexpr ll BINF = 0x3f3f3f3f3f3f3f3fLL;\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n\nint solve() {\n\tint n; cin >> n;\n\tvvi g(n);\n\tfor (int i=0;i<n;i++) {\n\t\tint k; cin >> k; g[i].resize(k);\n\t\tcin >> g[i];\n\t}\n\tvi par(n, -1), dep(n);\n\tfunction<void(int, int)> dfs = [&] (int u, int p) {\n\t\tfor (int v : g[u]) if (v - p) {\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tpar[v] = u;\n\t\t\tdfs(v, u);\n\t\t}\n\t};\n\tdfs(0, -1);\n\tconst int M = 20;\n\tvvi dp(n, vi(M, -1));\n\tfor (int i=0;i<n;i++) dp[i][0] = par[i];\n\tfor (int j=1;j<M;j++) for (int i=0;i<n;i++)\n\t\tif (dp[i][j - 1] != -1) dp[i][j] = dp[dp[i][j - 1]][j - 1];\n\tauto lca = [&] (int u, int v) {\n\t\tif (dep[u] > dep[v]) swap(u, v);\n\t\tfor (int j=M-1;j>=0;j--) if (dp[v][j] != -1 && dep[dp[v][j]] >= dep[u]) v = dp[v][j];\n\t\tif (u == v) return u;\n\t\tfor (int j=M-1;j>=0;j--) if (dp[u][j] != dp[v][j]) u = dp[u][j], v = dp[v][j];\n\t\treturn par[u];\n\t};\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << lca(u, v) << endl;\n\t}\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << (solve() ? \"YES\" : \"NO\") << endl;\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val,E laz):\n      cnt(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  using S = function<T(T)>;\n  F f;\n  G g;\n  H h;\n  P p;\n  S s;\n  T ti;\n  E ei;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  \n  LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n    p=[](E a,size_t b){b++;return a;};\n    s=[](T a){return a;};\n  }\n  \n  LinkCutTree(F f,G g,H h,P p,T ti,E ei):\n    f(f),g(g),h(h),p(p),ti(ti),ei(ei),pool(LIM),ptr(0){s=[](T a){return a;};}\n  \n  LinkCutTree(F f,G g,H h,P p,S s,T ti,E ei):\n    f(f),g(g),h(h),p(p),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v,ei));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,v);\n    t->dat=g(t->dat,p(v,t->cnt));\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->dat=s(t->dat);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    eval(t);\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\teval(q);eval(t);\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\teval(r);eval(q);eval(t);\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(c);\n    expose(par);\n    c->p=par;\n    par->r=c;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=nullptr;\n    par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  bool is_connected(Node *a,Node *b){\n    expose(a);\n    while(a->l) a=a->l;\n    expose(b);\n    while(b->l) b=b->l;\n    return a==b;\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n\n  void set_propagate(Node *t,E v){\n    expose(t);\n    propagate(t,v);\n    eval(t);\n  }\n};\n\n//END CUT HERE\n//INSERT ABOVE HERE\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_C\n*/\n\nsigned GRL_5_D(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return a+b;};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.expose(v[a]);\n      v[a]->val=f(v[a]->val,b);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_D\n*/\n\n\nsigned GRL_5_E(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<Int,Int>;\n  LCT::F f=[](Int a,Int b){return a+b;};\n  LCT::P p=[](Int a,size_t b){return a*b;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  Int c=0;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.set_propagate(v[a],b);\n      c+=b;\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat-c<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_E\n*/\n\nsigned JOISC2013_DAY4_3(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  \n  using LCT = LinkCutTree<int, int>;\n  auto f=[](int a,int b){return a+b;};\n  LCT lct(f,f,f,0,0);\n  vector<LCT::Node*> vs(n);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,0);\n\n  for(int i=0;i<q;i++){\n    int t,a,b=0;\n    scanf(\"%d %d\",&t,&a);\n    if(t!=2) scanf(\"%d\",&b);\n    a--;b--;\n    if(t==1) lct.link(vs[b],vs[a]);\n    if(t==2) lct.cut(vs[a]);\n    if(t==3){\n      if(!lct.is_connected(vs[a],vs[b])) puts(\"-1\");\n      else printf(\"%d\\n\",lct.lca(vs[a],vs[b])->idx+1);\n    }\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  https://beta.atcoder.jp/contests/joisc2013-day4/tasks/joisc2013_spaceships\n*/\n\nsigned AOJ_2450(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n\n  using T = tuple<int,int,int,int,int,int,int>;\n  using P = pair<int,int>;\n  using LCT = LinkCutTree<T, P>;\n\n  vector<vector<int> > G(n); \n  T d1(-1,-1,-1,-1,-1,-1,-1);\n  P d0(-1,-114514);\n  \n  vector<LCT::Node* > vs(n);\n  vector<int> ps(n,-1);\n  \n  auto f=[&](T a,T b){\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int bl,br,bs,bva,bvi,bvl,bvr;\n    tie(bl,br,bs,bva,bvi,bvl,bvr)=b;\n    int cl=al,cr=br,cs=as+bs;\n    int cva=ava+bva,cvi=max(avi,bvi),cvl=avl,cvr=bvr;\n    cvi=max(cvi,avr+bvl);\n    cvl=max(cvl,ava+bvl);\n    cvr=max(cvr,avr+bva);\n    return T(cl,cr,cs,cva,cvi,cvl,cvr);\n  };\n  \n  auto g=[&](T a,P p){\n    if(p==d0) return a;\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int v=p.first,b=p.second;\n    if(~v) al=ar=v,as=1;\n    if(b>=0) return T(al,ar,as,b*as,b*as,b*as,b*as);\n    return T(al,ar,as,b*as,b,b,b);\n  };\n  \n  auto h=[&](P a,P b){a.first++;return b;};\n  auto p=[&](P a,size_t b){b++;return a;};\n  auto s=\n    [&](T a){      \n      int al,ar,as,ava,avi,avl,avr;\n      tie(al,ar,as,ava,avi,avl,avr)=a;\n      swap(al,ar);\n      swap(avl,avr);\n      return T(al,ar,as,ava,avi,avl,avr);\n    };\n  \n  LCT lct(f,g,h,p,s,d1,d0);\n  \n  \n  vector<int> w(n);\n  for(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,g(d1,P(i,w[i])));\n  \n  for(int i=0;i<n-1;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n\n  for(int i=0;i<n;i++)\n    sort(G[i].begin(),G[i].end());\n\n  {\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    }\n  }\n  \n  while(q--){\n    int t,a,b,c;\n    scanf(\"%d %d %d %d\",&t,&a,&b,&c);\n    a--;b--;\n    if(t==1){\n      lct.evert(vs[a]);\n      lct.set_propagate(vs[b],P(-1,c));      \n    }\n    if(t==2){\n      lct.evert(vs[a]);\n      lct.expose(vs[b]);\n      int vva,vvi,vvl,vvr;\n      tie(ignore,ignore,ignore,vva,vvi,vvl,vvr)=vs[b]->dat;\n      printf(\"%d\\n\",max({vva,vvi,vvl,vvr}));\n    }\n  }\n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2450\n*/\n\nsigned AOJ_0367(){\n  int n,k;\n  cin>>n>>k;\n  \n  vector<vector<int> > G(n); \n  vector<map<Int, Int> > m(n);\n  for(Int i=0;i<n-1;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n    m[a][b]=m[b][a]=c;\n  }\n  \n  vector<Int> w(n,0);\n  vector<int> ps(n,-1);\n  using T = tuple<Int, Int, Int>;\n  auto mget=[&](Int a,Int b){\n\t      if(ps[a]!=b&&ps[b]!=a) return 0LL;\n\t      Int res=w[a]+w[b]+m[a][b];\n\t      if(res%k) return res;\n\t      return 0LL;\n\t    };\n  \n  auto f=[&](T a,T b){\n\t   if(a>b) swap(a,b);\n\t   Int al,ar,av;\n\t   tie(al,ar,av)=a;\n\t   Int bl,br,bv;\n\t   tie(bl,br,bv)=b;\n\t   if(al<0||ar<0) return b;\n\t   Int cl,cr,cv=av+bv;\n\t   if(m[al].count(bl)){\n\t     cl=ar;cr=br;\n\t     cv+=mget(al,bl);\n\t   }else if(m[al].count(br)){\n\t     cl=ar;cr=bl;\n\t     cv+=mget(al,br);\n\t   }else if(m[ar].count(bl)){\n\t     cl=al;cr=br;\n\t     cv+=mget(ar,bl);\n\t   }else if(m[ar].count(br)){\n\t     cl=al;cr=bl;\n\t     cv+=mget(ar,br);\n\t   }else{\n\t     cl=cr=cv=-1;\n\t   }\n\t   return T(cl,cr,cv);\n\t };\n  \n  auto g=[&](T a,Int b){b++;return a;};\n  auto h=[&](Int a,Int b){b++;return a;};\n  \n  using LCT = LinkCutTree<T, Int>;\n  LCT lct(f,g,h,T(-1,-1,0),0);  \n  vector<LCT::Node* > vs(n);\n  for(Int i=0;i<n;i++) vs[i]=lct.create(i,T(i,i,0));\n  \n  {\n    using P = pair<Int, Int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    } \n  }\n  \n  Int q;\n  cin>>q;\n  while(q--){\n    string op;\n    cin>>op;\n    if(op==\"add\"){\n      Int x,d;\n      cin>>x>>d;\n      lct.expose(vs[x]);\n      w[x]+=d;\n      lct.update(vs[x]);\n    }\n    if(op==\"send\"){\n      Int s,t;\n      cin>>s>>t;\n      lct.evert(vs[s]);\n      lct.expose(vs[t]);\n      cout<<get<2>(vs[t]->dat)<<endl;\n    }\n  }  \n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0367\n*/\n\n\n\nstruct M{\n  Int a,b,c,d;\n  M():a(1),b(0),c(0),d(1){}\n  M(Int a,Int b,Int c,Int d):a(a),b(b),c(c),d(d){}\n  //M(const M &v):a(v.a),b(v.b),c(v.c),d(v.d){}\n  bool operator!=(const M &x)const{\n    return a!=x.a||b!=x.b||c!=x.c||d!=x.d;\n  }\n  bool operator==(const M &x)const{\n    return !(*this!=x);\n  }\n};\n\nsigned YUKI_650(){\n  const int MOD=1e9+7;\n  using M2 = pair<M, M>;\n  using LCT = LinkCutTree<M2, M2>;\n  auto f=[MOD](M x,M y){\n\t   M r(0,0,0,0);\n\t   r.a=x.a*y.a+x.b*y.c;\n\t   r.b=x.a*y.b+x.b*y.d;\n\t   r.c=x.c*y.a+x.d*y.c;\n\t   r.d=x.c*y.b+x.d*y.d;\t   \n\t   r.a%=MOD;r.b%=MOD;r.c%=MOD;r.d%=MOD;\n\t   return r;\n\t };\n  auto f2=[&](M2 x,M2 y){\n\t    return M2(f(x.first,y.first),f(y.second,x.second));\n\t  };\n  auto g=[](M2 x,M2 y){x.first.a++;return y;};\n  auto p=[](M2 x,size_t y){y++;return x;};\n  auto s=[](M2 x){swap(x.first,x.second);return x;};\n  \n  int n;\n  cin>>n;\n  vector<vector<int> > G(n);\n  vector<int> X,Y;\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    X.emplace_back(a);\n    Y.emplace_back(b);\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  M ti=M();\n  M ei(-1,-1,-1,-1);\n  LCT lct(f2,g,g,p,s,M2(ti,ti),M2(ei,ei));\n\n  \n  vector<LCT::Node*> vs(n*2-1);\n  for(int i=0;i<(int)vs.size();i++) vs[i]=lct.create(i,M2(ti,ti));\n  \n  vector<map<int, int> > rev(n);\n  int idx=n;\n  {\n    using P = pair<int, int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p){\n\tlct.link(vs[p],vs[idx]);\n\tlct.link(vs[idx],vs[v]);\n\trev[p][v]=rev[v][p]=idx++;\n      }\n      for(int u:G[v])\n\tif(u!=p) q.emplace(u,v);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    char c;\n    cin>>c;\n    if(c=='x'){\n      Int v,a,b,c,d;\n      cin>>v>>a>>b>>c>>d;\n      int z=rev[X[v]][Y[v]];\n      lct.expose(vs[z]);\n      vs[z]->val=M2(M(a,b,c,d),M(a,b,c,d));      \n      lct.expose(vs[z]);\n    }\n    if(c=='g'){\n      Int x,y;\n      cin>>x>>y;\n      lct.evert(vs[x]);\n      lct.expose(vs[y]);\n      M ans=vs[y]->dat.first;\n      cout<<ans.a<<\" \"<<ans.b<<\" \"<<ans.c<<\" \"<<ans.d<<endl;\n    }\n  }\n  \n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://yukicoder.me/problems/no/650\n*/\n\n\nsigned main(){\n  GRL_5_C();\n  //GRL_5_D();\n  //GRL_5_E();\n  //JOISC2013_DAY4_3();\n  //AOJ_2450();\n  //AOJ_0367();\n  //YUKI_650();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <cmath>\n#include <numeric>\nusing namespace std;\n\nint parent[17][100000];\nvector <int> child[100000];\nint depth[100000];\n\nint MAX_LOG_N = 17;\n\nvoid set_depth(int v, int prev_depth){\n    depth[v] = prev_depth + 1;\n    for(int i = 0; i < child[v].size(); i++){\n        set_depth(child[v][i], prev_depth + 1);\n    }\n}\n\nvoid set_parents(int N){\n    for(int i = 1; i < MAX_LOG_N; i++){\n        for(int j = 0; j < N; j++){\n            parent[i][j] = parent[i - 1][parent[i - 1][j]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]){\n        return lca(v, u);\n    }\n    for(int k = 0; k < MAX_LOG_N; k++){\n        if((((depth[u] - depth[v]) >> k) & 1) == 1){\n            v = parent[k][v];\n        }\n    }\n    if(u == v){\n        return u;\n    }\n\n    for(int k = MAX_LOG_N - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    int N;\n    cin >> N;\n\n    for(int i = 0; i < N; i++){\n        int k;\n\n        cin >> k;\n        for(int j = 0; j < k; j++){\n            int c;\n            cin >> c;\n            child[i].push_back(c);\n            parent[0][c] = i;\n        }\n    }\n    parent[0][0] = 0;\n\n    set_depth(0, -1);\n    set_parents(N);\n\n    int q;\n    cin >> q;\n\n    for(int i = 0; i < q; i++){\n        \n        int u;\n        int v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(40) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,n,a) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,n,0)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\nconst static int MAX_V = 100000;\n\nvector<int> G[MAX_V];\nint root = 0;\n\nint vs[MAX_V * 2 - 1];\nint depth[MAX_V * 2 - 1];\nint id[MAX_V];\n\n//?????????????????????????????????????±?????????????????????°???????????¨\n//int double ??¨??????numeric???????????£?????????????????????\n//n ????´???°\n//invalid_value ???????????°???????????????a????????????marge(a,invalidvalue) = a, marge(invalid_value, a) = a?????¨??????????????????\nclass SegmentTreeInt {\npublic:\n\tSegmentTreeInt(int n, int invalid_value);\n\t~SegmentTreeInt();\n\tvoid SetElem(int k, int val);\n\tint GetCount();\n\tint quary(int a, int b);\n\tint GetElem(int k);\n\n\t//?????????????????¢??°???????????????????????????\n\t//invalid_value??????????????£?????°????????????????????????\n\tbool IsInvalidValue(int value) {\n\t\treturn value == mInvalidValue;\n\t}\n\t//a??¨b?????? a???b????±?????????¢??°???????????§?¨?????????????????????§?±???????\n\tint Marge(int a, int b) {\n\t\tif (IsInvalidValue(a))return b;\n\t\tif (IsInvalidValue(b)) return a;\n\t\tif (depth[a] >= depth[b]) return b;\n\t\treturn a;\n\t}\nprivate:\n\tvector<int>\n\t\tmTree;\n\tint mCount;\n\tint mInvalidValue;\n\tvoid Update(int k, int val);\n\tint InternalQuary(int a, int b, int k, int l, int r);\n};\n\n//?????´??????????????????(??????????????¨???????????´??????)\nSegmentTreeInt::SegmentTreeInt(int n, int invalid_value) {\n\tint bin_n = 1;\n\twhile (bin_n < n) bin_n *= 2;\n\tmTree.resize(2 * bin_n);\n\tmInvalidValue = invalid_value;\n\tmCount = bin_n;\n\tfor (int i = 0; i < 2 * bin_n - 1; i++) {\n\t\tmTree[i] = invalid_value;\n\t}\n}\nSegmentTreeInt::~SegmentTreeInt() {\n}\nvoid SegmentTreeInt::SetElem(int k, int val) { Update(k, val); }\nint SegmentTreeInt::GetElem(int k) { return mTree[mCount - 1 + k]; }\nint SegmentTreeInt::GetCount() { return mCount; }\n//????????´??°\nvoid SegmentTreeInt::Update(int k, int val) {\n\tk += mCount - 1;\n\tmTree[k] = val;\n\twhile (k > 0) {\n\t\tk = ( k - 1 ) / 2;\n\t\tmTree[k] = Marge(mTree[2 * k + 1], mTree[2 * k + 2]);\n\t}\n}\n//??????[a,b]?????????O(ln(Count))??§?±??????? b < GetCount??¨???????????¨\n//ex. a = 0 , b = 2 ?????? 0,1,2?????????\nint SegmentTreeInt::quary(int a, int b) {\n\treturn InternalQuary(a, b + 1, 0, 0, mCount);\n}\n//?????¨?????????\nint SegmentTreeInt::InternalQuary(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return mInvalidValue;\n\tif (a <= l && r <= b)return mTree[k];\n\telse {\n\t\tint vl = InternalQuary(a, b, k * 2 + 1, l, ( l + r ) / 2);\n\t\tint vr = InternalQuary(a, b, k * 2 + 2, ( l + r ) / 2, r);\n\t\treturn Marge(vl, vr);\n\t}\n}\n//???????????§?????´??????\n\nSegmentTreeInt rmq(2*MAX_V-1,INF);\n\nvoid dfs(int v, int p, int d, int &k) {\n\tid[v] = k;\n\tvs[k] = v;\n\tdepth[k++] = d;\n\trep(i, G[v].size()) {\n\t\tif (G[v][i] != p) {\n\t\t\tdfs(G[v][i], v, d + 1, k);\n\t\t\tvs[k] = v;\n\t\t\tdepth[k++] = d;\n\t\t}\n\t}\n}\n//\nvoid init(int V) {\n\tint k = 0;\n\tdfs(root,-1,0,k);\n\trep(i, V * 2) {\n\t\trmq.SetElem(i,i);\n\t}\n}\n\nint LCA(int u, int v) {\n\treturn vs[rmq.quary(min(id[u], id[v]), max(id[u], id[v]))];\n}\n\nint main() {\n\tint n; put n;\n\trep(i, n) {\n\t\tint k; put k;\n\t\trep(j, k) {\n\t\t\tint c; put c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tint q; put q;\n\tinit(n);\n\trep(i, q) {\n\t\tint u, v; put u >> v;\n\t\tcout << LCA(u,v) << endl;\n\t}\nEND:\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define MAX_V 100010\n#define MAX_LOG_V 20\n\nvector<int> edge[MAX_V];\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nstruct LCA{\n  int root;\n\n  LCA(int r): root(r){}\n\n  void add_edge(int a, int b) {\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  \n  void dfs(int v, int par, int dep) {\n    parent[0][v] = par;\n    depth[v] = dep;\n    for (auto child : edge[v]) {\n      if (child != par) dfs(child, v, dep + 1);\n    }\n  }\n\n  void init(int V) {\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n      for (int v = 0; v < V; v++) {\n\tif (parent[k][v] < 0) {\n\t  parent[k+1][v] = -1;\n\t} else {\n\t  parent[k+1][v] = parent[k][parent[k][v]];\n\t}\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n\tv = parent[k][v];\n      }\n    }\n    if (u == v) return u;\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n\tu = parent[k][u];\n\tv = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  int N;\n  LCA lca(0);\n  \n  scanf(\"%d\", &N);\n  REP(i, N) {\n    int k;\n    scanf(\"%d\", &k);\n    REP(j, k) {\n      int c;\n      scanf(\"%d\", &c);\n      lca.add_edge(i, c);\n    }\n  }\n  lca.init(N);\n  int Q;\n  scanf(\"%d\", &Q);\n  REP(i, Q) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", lca.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T> struct SegmentTree {\n  using F = function<T(T, T)>;\n\n  int n;\n  T init;\n  F f;\n  vector<T> data;\n\n  SegmentTree() {}\n  SegmentTree(int n_, vector<T> v = vector<T>(),\n      F f = [](T a, T b) { return min(a, b); }, T init = INT_MAX)\n      : f(f), init(init) {\n    n = 1;\n    while(n < n_) n *= 2;\n    data.assign(2 * n - 1, init);\n    if(n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void update(int k, T x) {\n    k += n - 1;\n    data[k] = x;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      data[k] = f(data[k * 2 + 1], data[k * 2 + 2]);\n    }\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    if (b <= l || r <= a) return init;\n    if (a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n};\n\nstruct Tree {\n  int n;\n  vector<vector<int>> g;\n  vector<int> num, depth;\n  vector<int> eulerTour;\n  SegmentTree<int> seg;\n\n  Tree(int n) : n(n), g(n), num(n) {}\n\n  void init(int r) {\n    dfs(r, r, 0);\n    seg = SegmentTree<int>(2 * n - 1, depth);\n  }\n  void addEdge(int s, int t) {\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  void dfs(int u, int p, int d) {\n    num[u] = depth.size();\n    eulerTour.push_back(u);\n    depth.push_back(d);\n    for (auto&& v : g[u]) {\n      if (v != p) {\n        dfs(v, u, d + 1);\n        eulerTour.push_back(v);\n        depth.push_back(d);\n      }\n    }\n  }\n  int lowestCommonAncestor(int u, int v) {\n    int i = num[u];\n    int j = num[v];\n    return eulerTour[seg.query(min(i, j), max(i, j) + 1)];\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n; cin >> n;\n  Tree t(n);\n  for (int i = 0; i < n; ++i) {\n    int k; cin >> k;\n    while (k--) {\n      int c; cin >> c;\n      t.addEdge(i, c);\n    }\n  }\n\n  t.init(0);\n  int q; cin >> q;\n  while (q--) {\n    int u, v; cin >> u >> v;\n    cout << t.lowestCommonAncestor(u, v) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define rep(i,a,b) for(int i=a;i<(b);++i)\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\nconstexpr int INF = 1 << 30;\nconstexpr int MOD = 1e9 + 7;\n\nstruct Edge {\n  int src, dst, cost;\n  Edge(int s, int d, int c = 1) : src(s), dst(d), cost(c) {}\n  bool operator<(const Edge &e){ return cost < e.cost;}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nstruct EulerTour {\n  int N, cnt = 0;\n  Graph g;\n  vector<int> cost, rnk, ord;\n  vector<pair<int,int>> depth;\n\n  EulerTour (int n, Graph &g) : g(g), rnk(n), cost(n*2), ord(n*2) {\n    for(N = 1; N < n * 2; N<<=1);\n    depth.resize(N * 2 - 1);\n\n    dfs();\n    \n    for(int i = N - 2; i >= 0; --i) depth[i] = min(depth[i * 2 + 1], depth[i * 2 + 2]);\n  }\n\n  void dfs(int v = 0, int p = -1, int d = 0, int c = 0) {\n    rnk[v] = cnt;\n    depth[cnt + N - 1] = make_pair(d, cnt), cost[cnt] = c, ord[cnt] = v;\n    ++cnt;\n\n    for(Edge e : g[v]) {\n      if(e.dst == p) continue;\n      dfs(e.dst, v, d + 1, c + e.cost);\n      depth[cnt + N - 1] = make_pair(d, cnt), cost[cnt] = c, ord[cnt] = v;\n      ++cnt;\n    }\n  }\n\n  pair<int, int> rmq(int a, int  b, int i = 0, int l = 0, int r = -1) {\n    if(r == -1) r = N;\n    if(r <= a || b <= l) return make_pair(INF, 0);\n    if(a <= l && r <= b) return depth[i];\n\n    auto L = rmq(a, b, i * 2 + 1, l, (l + r) / 2);\n    auto R = rmq(a, b, i * 2 + 2, (l + r) / 2, r);\n    return min(L, R);\n  }\n\n  int lca(int x, int y) { return ord[ rmq( min(rnk[x], rnk[y]), max(rnk[x], rnk[y]) + 1).second ]; }\n  int dist(int x, int y) { return cost[x] + cost[y] - cost[lca(x, y)] * 2; }\n};\n\nint n,m,a,q,x,y;\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cin >> n;\n    Graph g(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> m;\n      for(int j = 0; j < m; ++j) {\n        cin >> a;\n        g[i].emplace_back(i, a);\n      }\n    }\n\n    EulerTour et(n, g);\n    cin >> q;\n    for(int i = 0 ; i < q; ++i) {\n      cin >> x >> y;\n      cout << et.lca(x, y) << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100001];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nint sub(int idx)\n{\n  sz[idx] = int(query[idx].size());\n  for(auto &to : g[idx]) sz[idx] += sub(to);\n  return (sz[idx]);\n}\n\nvoid dfs(int idx, bool keep)\n{\n  if(g[idx].empty()) {\n    if(keep) for(int &v : query[idx]) buf[v] = true;\n    return;\n  }\n\n  int heavy = g[idx][0];\n  for(auto &to : g[idx]) if(sz[to] > sz[heavy]) heavy = to;\n  for(auto &to : g[idx]) if(heavy != to) dfs(to, false);\n  dfs(heavy, true);\n  query[idx].swap(query[heavy]);\n\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(buf[v]) lca[v] = idx;\n    }\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      buf[v] = true;\n      query[idx].push_back(v);\n    }\n  }\n\n  if(!keep) {\n    for(auto &v : query[idx]) buf[v] = false;\n  }\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n\n  memset(lca, -1, sizeof(lca));\n\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n\n  sub(0);\n  dfs(0, false);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1e5+10;\nvector<int> G[N];\nint dep[N];\nint parent[N][20];\n\nvoid init(int n)\n{\n    for(int i=1;i<20;i++)\n    {\n        for(int v=0;v<n;v++)\n        {\n            parent[v][i]=parent[v][i-1]==-1?-1:parent[parent[v][i-1]][i-1];\n        }\n    }\n}\n\nint lca(int u,int v)\n{\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int i=19;i>=0;i--)\n    {\n        if(parent[v][i]!=-1&&dep[parent[v][i]]>=dep[u])\n        {\n            v=parent[v][i];\n        }\n    }\n    if(u==v) return u;\n    for(int i=19;i>=0;i--)\n    {\n        if(parent[u][i]!=parent[v][i])\n        {\n            u=parent[u][i];\n            v=parent[v][i];\n        }\n    }\n    return parent[u][0];\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n\n    parent[0][0]=-1;\n    for(int i=0;i<n;i++)\n    {\n        int k;\n        cin>>k;\n        while(k--)\n        {\n            int c;\n            cin>>c;\n            parent[c][0]=i;\n            dep[c]=dep[i]+1;\n        }\n    }\n\n    init(n);\n\n    int q;\n    cin>>q;\n    while(q--)\n    {\n        int u,v;\n        cin>>u>>v;\n        cout<<lca(u,v)<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef call_from_test\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename Vertex, typename Cluster, size_t LIM>\nstruct TopTree{\n  enum Type { Compress, Rake, Edge, None };\n  struct Node{\n    Vertex* vs[2];\n    Cluster dat,inv;\n    Node* p;\n    Node* q;\n    Node* ch[2];\n    bool rev,guard;\n    Type type;\n    Node():p(nullptr),q(nullptr),rev(false),guard(false),type(Type::None){}\n  };\n\n  static array<Node, LIM> pool;\n  size_t ptr;\n\n  TopTree():ptr(0){}\n\n  inline Node* create(Vertex* u,Cluster w,Vertex* v){\n    auto t=&(pool[ptr++]);\n    t->vs[0]=u;t->vs[1]=v;t->dat=w;t->type=Type::Edge;\n    t->inv=w;t->inv.toggle();\n    return pushup(t);\n  }\n\n  inline Node* compress(Node* l,Node* r){\n    auto t=&(pool[ptr++]);\n    t->ch[0]=l;t->ch[1]=r;t->type=Type::Compress;\n    return pushup(t);\n  }\n\n  inline Node* rake(Node* l,Node* r){\n    auto t=&(pool[ptr++]);\n    t->ch[0]=l;t->ch[1]=r;t->type=Type::Rake;\n    return pushup(t);\n  }\n\n  int parent_dir(Node* t){\n    Node* p=t->p;\n    if(!p) return -1;\n    if(p->guard) return -1;\n    if(p->ch[0]==t) return 0;\n    if(p->ch[1]==t) return 1;\n    return -1;\n  }\n\n  inline Node* pushup(Node* const t){\n    Node* const l=t->ch[0];\n    Node* const r=t->ch[1];\n\n    if(t->type==Type::Edge){\n      if(!t->p){\n\tt->vs[0]->handle=t;\n\tt->vs[1]->handle=t;\n      }else if(t->p->type==Type::Compress){\n\tif(parent_dir(t)==-1)\n\t  t->vs[0]->handle=t;\n      }else if(t->p->type==Type::Rake){\n\tt->vs[0]->handle=t;\n      }\n    }else if(t->type==Type::Compress){\n      assert(l->vs[1]==r->vs[0]);\n      t->vs[0]=l->vs[0];\n      t->vs[1]=r->vs[1];\n\n      Cluster lf=l->dat;\n      Cluster rg=r->inv;\n      if(t->q){\n\tNode* q=t->q;\n\tassert(l->vs[1]==q->vs[1]);\n\tlf=Cluster::rake(l->dat,q->dat,q->vs[0]);\n\trg=Cluster::rake(r->inv,q->dat,q->vs[0]);\n      }\n      t->dat=Cluster::compress(lf,r->vs[0],r->dat);\n      t->inv=Cluster::compress(rg,r->vs[0],l->inv);\n\n      l->vs[1]->handle=t;\n      if(!t->p){\n\tt->vs[0]->handle=t;\n\tt->vs[1]->handle=t;\n      }else if(t->p->type==Type::Compress){\n\tif(parent_dir(t)==-1)\n\t  t->vs[0]->handle=t;\n      }else if(t->p->type==Type::Rake){\n\tt->vs[0]->handle=t;\n      }\n    }else if(t->type==Type::Rake){\n      propagate(t);\n      assert(l->vs[1]==r->vs[1]);\n      t->vs[0]=l->vs[0];\n      t->vs[1]=l->vs[1];\n      t->dat=Cluster::rake(l->dat,r->dat,r->vs[0]);\n    }else abort();\n    return t;\n  }\n\n  void rotate(Node* t,Node* x,size_t dir){\n    Node* y=x->p;\n    int par=parent_dir_guard(x);\n    propagate(t->ch[dir]);\n    x->ch[dir^1]=t->ch[dir];\n    t->ch[dir]->p=x;\n    t->ch[dir]=x;\n    x->p=t;\n    t->p=y;\n    if(~par) y->ch[par]=t;\n    else if(y and y->type==Type::Compress) y->q=t;\n    pushup(x);pushup(t);\n    if(y and !y->guard) pushup(y);\n  }\n\n  inline void propagate(Node* t){\n    if(t->type==Type::Compress){\n      if(t->rev){\n\tassert(t->ch[0] and t->ch[1]);\n\tswap(t->ch[0],t->ch[1]);\n\ttoggle(t->ch[0]);\n\ttoggle(t->ch[1]);\n\tt->rev=false;\n      }\n    }\n  }\n\n  inline void toggle(Node* t){\n    if(t->type==Type::Edge){\n      swap(t->vs[0],t->vs[1]);\n      swap(t->dat,t->inv);\n    }else if(t->type==Type::Compress){\n      swap(t->vs[0],t->vs[1]);\n      swap(t->dat,t->inv);\n      t->rev^=true;\n    }else if(t->type==Type::Rake){\n    }else abort();\n  }\n\n  void splay(Node* t){\n    assert(t->type!=Type::Edge);\n    propagate(t);\n\n    while(~parent_dir(t)){\n      Node* q=t->p;\n      if(q->type!=t->type) break;\n      if(~parent_dir(q) and q->p and q->p->type==q->type){\n\tNode* r=q->p;\n\tif(r->p) propagate(r->p);\n\tpropagate(r);propagate(q);propagate(t);\n\tint qt_dir=parent_dir(t);\n\tint rq_dir=parent_dir(q);\n\tif(rq_dir==qt_dir){\n\t  rotate(q,r,rq_dir^1);\n\t  rotate(t,q,qt_dir^1);\n\t}else{\n\t  rotate(t,q,qt_dir^1);\n\t  rotate(t,r,rq_dir^1);\n\t}\n      }else{\n\tif(q->p) propagate(q->p);\n\tpropagate(q);propagate(t);\n\tint qt_dir=parent_dir(t);\n\trotate(t,q,qt_dir^1);\n      }\n    }\n  }\n\n  void pusher(Node* t){\n    if(!t) return;\n    pusher(t->p);\n    propagate(t);\n  }\n\n  int parent_dir_guard(Node* t){\n    Node* p=t->p;\n    if(!p) return -1;\n    if(p->ch[0]==t) return 0;\n    if(p->ch[1]==t) return 1;\n    return -1;\n  }\n\n  Node* expose(Node* t){\n    pusher(t);\n    while(true){\n      assert(t->type!=Type::Rake);\n      if(t->type==Type::Compress) splay(t);\n      Node* n=nullptr;\n      {\n\tNode* p=t->p;\n\tif(!p) break;\n\tif(p->type==Type::Rake){\n\t  propagate(p);\n\t  splay(p);\n\t  n=p->p;\n\t}else if(p->type==Type::Compress){\n\t  propagate(p);\n\t  if(p->guard and ~parent_dir_guard(t)) break;\n\t  n=p;\n\t}else abort();\n      }\n      splay(n);\n      int dir=parent_dir_guard(n);\n      if(dir==-1 or n->p->type==Type::Rake) dir=0;\n      if(dir==1){\n\ttoggle(n->ch[dir]);\n\tpropagate(n->ch[dir]);\n\ttoggle(t);\n\tpropagate(t);\n      }\n      int n_dir=parent_dir(t);\n      if(~n_dir){\n\tNode* c=n->ch[dir];\n\tpropagate(c);\n\tNode* r=t->p;\n\tpropagate(r);\n\tr->ch[n_dir]=c;\n\tc->p=r;\n\tn->ch[dir]=t;\n\tt->p=n;\n\tpushup(c);pushup(r);pushup(t);pushup(n);\n\tsplay(r);\n      }else{\n\tNode* c=n->ch[dir];\n\tpropagate(c);\n\tn->q=c;\n\tc->p=n;\n\tn->ch[dir]=t;\n\tt->p=n;\n\tpushup(c);pushup(t);pushup(n);\n      }\n      if(t->type==Type::Edge) t=n;\n    }\n    return t;\n  }\n\n  Node* link(Vertex* u,Cluster w,Vertex* v){\n    if(!u->handle and !v->handle) return create(u,w,v);\n\n    Node* nnu=(Node*)u->handle;\n    Node* nnv=(Node*)v->handle;\n    Node* ee=create(u,w,v);\n    Node* ll=nullptr;\n\n    if(!nnv) ll=ee;\n    else{\n      Node* vv=expose(nnv);\n      propagate(vv);\n      if(vv->vs[1]==v){\n\ttoggle(vv);\n\tpropagate(vv);\n      }\n      if(vv->vs[0]==v){\n\tNode* nv=compress(ee,vv);\n\tee->p=nv;\n\tpushup(ee);\n\tvv->p=nv;\n\tpushup(vv);pushup(nv);\n\tll=nv;\n      }else{\n\tNode* nv=vv;\n\tNode* ch=nv->ch[0];\n\tpropagate(ch);\n\tnv->ch[0]=ee;\n\tee->p=nv;\n\tpushup(ee);\n\n\tNode* bt=nv->q;\n\tNode* rk=nullptr;\n\tif(bt){\n\t  propagate(bt);\n\t  rk=rake(bt,ch);\n\t  bt->p=rk;\n\t  ch->p=rk;\n\t  pushup(bt);pushup(ch);\n\t}else{\n\t  rk=ch;\n\t}\n\tnv->q=rk;\n\trk->p=nv;\n\tpushup(rk);pushup(nv);\n\tll=nv;\n      }\n    }\n\n    if(nnu){\n      Node* uu=expose(nnu);\n      propagate(uu);\n      if(uu->vs[0]==u){\n\ttoggle(uu);\n\tpropagate(uu);\n      }\n      if(uu->vs[1]==u){\n\tNode* tp=compress(uu,ll);\n\tuu->p=tp;\n\tll->p=tp;\n\tpushup(uu);pushup(ll);pushup(tp);\n      }else{\n\tNode* nu=uu;\n\tNode* ch=nu->ch[1];\n\ttoggle(ch);\n\tpropagate(ch);\n\n\tnu->ch[1]=ll;\n\tll->p=nu;\n\tpushup(ll);\n\n\tNode* al=nu->q;\n\tNode* rk=nullptr;\n\tif(al){\n\t  propagate(al);\n\t  rk=rake(al,ch);\n\t  al->p=rk;\n\t  ch->p=rk;\n\t  pushup(al);pushup(ch);\n\t}else{\n\t  rk=ch;\n\t}\n\tnu->q=rk;\n\trk->p=nu;\n\tpushup(rk);pushup(nu);\n      }\n    }\n    return ee;\n  }\n\n  void set_toggle(Node* v){\n    toggle(v);propagate(v);pushup(v);\n  }\n\n  void soft_expose(Vertex* u,Vertex* v){\n    pusher((Node*)u->handle);\n    pusher((Node*)v->handle);\n    Node* root=expose((Node*)u->handle);\n\n    if(u->handle==v->handle){\n      if(root->vs[1]==u or root->vs[0]==v){\n\tset_toggle(root);\n      }\n      return;\n    }\n\n    root->guard=true;\n    Node* soft=expose((Node*)v->handle);\n    root->guard=false;\n\n    pushup(root);\n    if(parent_dir(soft)==0) set_toggle(root);\n  }\n\n  Cluster query(Vertex* u,Vertex* v){\n    soft_expose(u,v);\n    Node* root=(Node*)u->handle;\n    propagate(root);\n\n    if(root->vs[0]==u and root->vs[1]==v) return root->dat;\n    if(root->vs[0]==u) return root->ch[0]->dat;\n    if(root->vs[1]==v) return root->ch[1]->dat;\n    propagate(root->ch[1]);\n    return root->ch[1]->ch[0]->dat;\n  }\n\n  Cluster leaf(Vertex* v){\n    Node* root=expose((Node*)v->handle);\n    assert(root->vs[0]==v or root->vs[1]==v);\n    assert(!root->p);\n    if(root->vs[0]==v) set_toggle(root);\n    return root->dat;\n  }\n\n  void print(){\n    string name[]={\"Compress\", \"Rake\", \"Edge\", \"None\"};\n    for(int i=0;i<(int)ptr;i++){\n      auto t=&pool[i];\n      cout<<i<<\":\"<<name[t->type]<<\" \"<<t->rev<<endl;\n      cout<<(t->vs[0]->idx+1)<<\" \"<<(t->vs[1]->idx+1)<<endl;\n      cout<<(t->ch[0]-(&pool[0]))<<\" \"<<(t->ch[1]-(&pool[0]))<<endl;\n      cout<<\":\"<<t->dat.v<<endl;\n      cout<<endl;\n    }\n  }\n\n};\ntemplate<typename Vertex, typename Cluster, size_t LIM>\narray<typename TopTree<Vertex, Cluster, LIM>::Node, LIM>\nTopTree<Vertex, Cluster, LIM>::pool;\n\nstruct Vertex{\n  void* handle;\n  int idx;\n  Vertex(int idx=-1):handle(nullptr),idx(idx){}\n};\n\nstruct Cluster{\n  int v;\n  Cluster(int v=0):v(v){}\n  void toggle(){}\n  static Cluster compress(Cluster x,Vertex*,Cluster y){\n    return Cluster(x.v+y.v);\n  }\n  static Cluster rake(Cluster x,Cluster y,Vertex*){\n    return x;\n    return Cluster(max(x.v,y.v));\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n\nstruct LowestCommonAncestor{\n  int n,h;\n  vector< vector<int> > G,par;\n  vector<int> dep;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int n):n(n),G(n),dep(n){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n  }\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    for(int u:G[v])\n      if(u!=p) dfs(u,v,d+1);\n  }\n\n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<h;k++)\n      for(int v=0;v<n;v++)\n        if(~par[k][v])\n          par[k+1][v]=par[k][par[k][v]];\n  }\n\n  int lca(int u,int v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int k=0;k<h;k++)\n      if((dep[v]-dep[u])>>k&1)\n        v=par[k][v];\n\n    if(u==v) return u;\n\n    for(int k=h-1;k>=0;k--)\n      if(par[k][u]!=par[k][v])\n        u=par[k][u],v=par[k][v];\n\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n\n//INSERT ABOVE HERE\nconst size_t LIM = 1e6;\nTopTree<Vertex, Cluster, LIM> T;\nusing Node = TopTree<Vertex, Cluster, LIM>::Node;\n\nVertex vs[LIM];\nsigned AOJ_1595(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    vs[i]=Vertex(i);\n    vs[n+i]=Vertex(-(i+1)-1);\n    T.link(vs+i,Cluster(0),vs+n+i);\n  }\n\n  for(int i=1;i<n;i++){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    T.link(vs+u,Cluster(1),vs+v);\n  }\n\n  for(int i=0;i<n;i++)\n    cout<<(n-1)*2-T.leaf(vs+n+i).v<<\"\\n\";\n\n  return 0;\n}\n\nsigned AOJ_GRL_5_C(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    vs[i]=Vertex(i);\n    vs[n+i]=Vertex(-(i+1)-1);\n    T.link(vs+i,Cluster(0),vs+n+i);\n  }\n\n  LowestCommonAncestor lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n      T.link(vs+i,Cluster(1),vs+c);\n    }\n  }\n  lca.build();\n\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<\"\\n\";\n    if(u==v) continue;\n    // cout<<u<<\" \"<<v<<\":\"<<lca.distance(u,v)<<\" \"<<T.query(vs+u,vs+v).v<<endl;\n    assert(lca.distance(u,v)==T.query(vs+u,vs+v).v);\n  }\n\n  return 0;\n}\n\nsigned main(){\n  //AOJ_1595();\n  AOJ_GRL_5_C();\n  return 0;\n}\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\ntemplate <class T> void corner(bool flg, T hoge) {\n    if(flg) {\n        cout << hoge << endl;\n        exit(0);\n    }\n}\n#define all(v) v.begin(), v.end()\n#define inputv(v, n)                                                           \\\n    vl v;                                                                      \\\n    rep(i, n) {                                                                \\\n        ll x;                                                                  \\\n        cin >> x;                                                              \\\n        v.push_back(x);                                                        \\\n    }\nconst ll INF = 999999999999999;\nconst ll MOD = 1000000007;\nconst ll MAX_N=500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\nvl par(MAX_N, -1);\nclass LCA {\npublic:\n\tll LOG_N = floor(log2(n)) + 1;\n\tvector<vl> NEXT;\n\tvl DEPTH;\n\n\n\tvoid init() {\n\t\tDEPTH = vl(n, -1);\n\t\tNEXT = vector<vl>(LOG_N + 2, vector<ll>(n));\n\t\tfor (ll i = 0; i < n; ++i) {\n\t\t\tNEXT[0][i] = par[i];\n\t\t}\n\n\t\tfor (ll k = 0; k < LOG_N; k++) {\n\t\t\tfor (ll i = 0; i < n; i++) {\n\t\t\t\tif (NEXT[k][i] == -1) {\n\t\t\t\t\tNEXT[k + 1][i] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tNEXT[k + 1][i] = NEXT[k][NEXT[k][i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll vertex(ll p, ll Q) {\n\t\tfor (ll k = LOG_N - 1; k >= 0; --k) {\n\t\t\tif (p == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((Q >> k) & 1) {\n\t\t\t\tp = NEXT[k][p];\n\t\t\t}\n\t\t}\n\n\t\treturn p;\n\t}\n\n\tll depth(ll x) {\n\t\tif (DEPTH[x] == -1) {\n\t\t\tll ok = n, ng = -1;\n\t\t\twhile (ok - ng > 1) {\n\t\t\t\tif (this->vertex(x, (ok + ng) / 2) > -1)ng = (ok + ng) / 2;\n\t\t\t\telse ok = (ok + ng) / 2;\n\t\t\t}\n\t\t\tDEPTH[x] = ok;\n\t\t\treturn ok;\n\t\t}\n\t\telse return DEPTH[x];\n\t}\n\n\tll kyoutuu(ll x, ll y) {\n\t\tll a = this->depth(x);\n\t\tll b = this->depth(y);\n\t\tif (a > b) {\n\t\t\tswap(x, y);\n\t\t\tswap(a, b);\n\t\t}\n\t\tll t = this->vertex(y, b - a);\n\n\t\tll ok = n, ng = -1;\n\t\twhile (ok - ng > 1) {\n\t\t\tll mid = (ok + ng) / 2;\n\t\t\tif (this->vertex(x, mid) == this->vertex(t, mid))ok = (ok + ng) / 2;\n\t\t\telse ng = (ok + ng) / 2;\n\t\t}\n\n\t\treturn this->vertex(x, ok); \n\t\t\t//return b - a + ok * 2 + 1;\n\t}\n\n};\nint main() {\n    cin >> n;\n\trep(i, n) {\n\t\tcin >> x;\n\t\trep(j, x) {\n\t\t\tcin >> a;\n\t\t\tpar[a] = i;\n\t\t}\n\t}\n\n\tLCA L;\n\tL.init();\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> a >> b;\n\t\tcout << L.kyoutuu(a, b) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PI 4*atan(1.0)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int SIZE=100001;\n//int arr[SIZE]={};\n//???????????§???????????¬\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tGraph G;\n\tfor(int i=0;i<N;i++){\n\t\tEdges E;\n\t\tG.push_back(E);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint l;\n\t\t\tcin>>l;\n\t\t\tG[i].push_back(Edge(i,l,1));\n\t\t\tG[l].push_back(Edge(l,i,1));\n\t\t}\n\t}\n\tint Q;\n\tcin>>Q;\n\tvector<Query> VQ;\n\tfor(int i=0;i<Q;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tVQ.push_back(Query(a,b));\n\t}\n\n\tleastCommonAncestor(G,0,VQ);\n\n\tfor(int i=0;i<Q;i++){\n\t\tcout<<VQ[i].w<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 200;\nint color[100010],  par[100010], depth[100010];\nint depthTop[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(!vis[c]){\n                q.push(c);\n                par[c] = v;\n                depth[c] = depth[v] + 1;\n            }\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            depthTop[v] = depth[u];\n            k++;\n            for(int c : g[v]){\n                if(!vis[c]) q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depthTop[u] > depthTop[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    len.resize(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 50;\nvector<int> G[MAX_V];\nint root;\n\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    dfs(root, -1, 0);\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u]) >> k & 1){\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n}\n\nsigned main(){\n    int n, k, q, c;\n    root = 0;\n    cin >> n;\n    rep(i, 0, n){\n        cin >> k;\n        rep(j, 0, k){\n            cin >> c;\n            G[i]. push_back(c);\n            G[c]. push_back(i);\n        }\n    }\n    init(n);\n    cin >> q;\n    rep(i, 0, q){\n        int u, v;\n        cin >> u >> v;\n        int tmp = lca(u, v);\n        cout << tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define MOD 1000000007\n#define maxn 100010\n\nvector<int> g[maxn];\nconst int l = 17;\nint tin[maxn], tout[maxn], timer;\nint up[20][maxn];\n\nvoid dfs(int u, int p = 0) {\n    tin[u] = timer++;\n    up[0][u] = p;\n    for (int i = 1; i <= l; i++) {\n        up[i][u] = up[i - 1][up[i - 1][u]];\n    }\n    for (auto x : g[u]) {\n        if (x != p) {\n            dfs(x, u);\n        }\n    }\n    tout[u] = timer++;\n}\n\nbool isAncestor(int a, int b) {\n    return tin[a] <= tin[b] and tout[a] >= tout[b];\n}\n\nint lca(int a, int b) {\n    if (isAncestor(a, b))\n        return a;\n    if (isAncestor(b, a))\n        return b;\n\n    for (int i = l; i >= 0; i--) {\n        if (!(isAncestor(up[i][a], b)))\n            a = up[i][a];\n    }\n    return up[0][a];\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n\n        for(int j = 0; j < k;j++){\n            int p;\n            cin >> p;\n\n            g[i].push_back(p);\n            g[p].push_back(i);\n        }\n    }\n\n    dfs(0 , 0);\n\n    int q;\n    cin >> q;\n\n    while (q--) {\n        int a, b;\n        cin >> a >> b;\n\n        cout << lca(a, b) << endl;\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst int sqrtN = 512;\nconst int logN = 32;\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nstruct LowestCommonAncestor{\n\tvector<vector<int>> g, parent;\n\tvector<int> depth;\n\tbool built = false;\n\tint N;\n\t\n\tLowestCommonAncestor(int n) : N(n) {\n\t\tg.resize(N);\n\t\tparent.resize(logN, vector<int>(N));\n\t\tdepth.resize(N);\n\t}\n\t\n\tvoid add_edge(int u, int v){\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int par = -1, int d = 0){\n\t\tparent[0][v] = par;\n\t\tdepth[v] = d;\n\t\t\n\t\tfor(auto e:g[v]){\n\t\t\tif(e == par) continue;\n\t\t\tdfs(e, v, d + 1);\n\t\t}\n\t}\n\t\n\tvoid build(){\n\t\tdfs(0);\n\t\tREP(k, 0, logN - 1){\n\t\t\tREP(i, 0, N){\n\t\t\t\tif(parent[k][i] < 0) parent[k + 1][i] = -1;\n\t\t\t\telse parent[k + 1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint get(int u, int v){\n\t\tif(!built) build(); built = true;\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\t\n\t\tREP(k, 0, logN) if(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\t\n\t\tif(u == v) return u;\n\t\t\n\t\tRREP(k, logN - 1, 0){\n\t\t\tif(parent[k][u] == parent[k][v]) continue;\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\t\t\t\n\t\t}\n\t\t\n\t\treturn parent[0][u];\n\t}\n};\n\nint main(){\n\tint n; cin >> n;\n\tLowestCommonAncestor lca(n);\n\tREP(i, 0, n){\n\t\tint k; cin >> k;\n\t\tREP(j, 0, k){\n\t\t\tint a; cin >> a;\n\t\t\tlca.add_edge(i, a);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tREP(i, 0, q){\n\t\tint a, b; cin >> a >> b;\n\t\t\n\t\tcout << lca.get(a, b) << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nstruct UnionFind{\n    vector<int> par,rank,ss;\n    int size;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);ss=vector<int>(n,1);size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);if(x==y)return;\n        if(rank[x]>rank[y])swap(x,y);\n        par[x] = y;ss[y]+=ss[x];\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){\n        return ss[root(x)];\n    }\n};\n\ntypedef vector<vector<int>> Graph;\nclass TarjanLCA{\npublic:\n\tGraph& g; UnionFind uf;\n\t\n\tvector<int> ancestor;vector<bool> passed;\n\n\tTarjanLCA(Graph &g):g(g),uf(UnionFind(g.size())){\n\t\tpassed=vector<bool>(g.size());ancestor=vector<int>(g.size());\n\t};\n\tvoid visit(int p,int s,vector<tuple<int,int,int>> &qs) {\n\t\tancestor[uf.root(s)] = s;\n\t\tfor(int t:g[s]) if(t != p) {\n\t\t\tvisit(s,t,qs);\n\t\t\tuf.unite(s,t);\n\t\t\tancestor[uf.root(s)] = s;\n\t\t}\n\t\tpassed[s] = true;\n\t\tfor(auto& q:qs){\n\t\t\tint w = (get<1>(q) == s ? get<0>(q) : get<0>(q) == s ? get<1>(q) : -1);\n\t\t\tif (w >= 0 && passed[w]){\n\t\t\t\tget<2>(q) = ancestor[uf.root(w)];\n\t\t\t}\n\t\t}\n\t}\n\tvoid leastCommonAncestor(int r,vector<tuple<int,int,int>>& qs){\n\t\tvisit(-1,r,qs);\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t);\n\t\t\t\tg[t].push_back(i);\n\t\t\t}\n\t\t}\n\t\tTarjanLCA lca(g);\n\t\tint q;cin >>q;\n\t\tvector<tuple<int,int,int>> qs(q);\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tqs[i]=make_tuple(u,v,-1);\n\t\t}\n\t\tlca.leastCommonAncestor(0,qs);\n\n\t\tREP(i,q){\n\t\t\tcout << get<2>(qs[i])<<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\n\nvector<int> G[V_MAX];\nvector<bool> used(V_MAX,false);\nvector<int> visit;\nvector<int> first_visit(V_MAX,-1);\nvector<int> dat(20*V_MAX,INT_MAX);\nint counter=0;\nint n;\n\nvoid vector_out(vector<int> &vec,int k){\n\tfor (int i=0;i<k;i++){\n\t\tcout << vec[i] << endl;\n\t}\n}\n\nvoid dfs(int s){\n\tif(used[s]==true){return;}\n\tused[s]=true;\n\tvisit.push_back(s);\n\tfirst_visit[s]=counter;\n\tcounter++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(used[G[s][i]]==false){\n\t\t\tdfs(G[s][i]);\n\t\t\tvisit.push_back(s);\n\t\t\tcounter++;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid update(int k, int a){\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int l,int r,int k){\n\tif(r<=a || b<=l){\n\t\treturn INT_MAX;\n\t}\n\tif(a<=l && r<=b){\n\t\treturn dat[k];\n\t}else{\n\t\treturn min(query(a,b,l,(l+r)/2,2*k+1),query(a,b,(l+r)/2,r,2*k+2));\n\t}\n}\n\nint LCA(int u,int v,int n){\n\tu=first_visit[u];\n\tv=first_visit[v];\n\tint x = min(u,v);\n\tint y = max(u,v);\n\treturn query(x,y+1,0,n+1,0);\n}\n\nint main(){\n\tint V,deg,to;\n\tcin>> V ;\n\tfor (int i=0;i<V;i++){\n\t\tcin >> deg;\n\t\tfor(int j=0;j<deg;j++){\n\t\t\tcin >> to;\n\t\t\tG[i].push_back(to);\n\t\t}\n\t}\n\tdfs(0);\n\t\n\tint R = visit.size();\n\t\n\tn=1;\n\twhile(n<R){\n\t\tn=2*n;\n\t}\n\t\n\tfor(int i=0;i<R;i++){\n\t\tupdate(i,visit[i]);\n\t}\n\t\n\tint Q;\n\tcin >> Q ;\n\t\n\tfor (int i=0;i<Q;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tcout << LCA(x,y,n) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> struct LowestCommonAncestor {\n    using Graph = vector<vector<pair<int, T>>>;\n    const T t_inf = numeric_limits<T>::max();\n    pair<T, int> id = make_pair(t_inf, INT_MAX);\n    int n;\n    vector<pair<T, int>> data;\n    vector<int> idx;\n    \n    LowestCommonAncestor(Graph G, int s = 0) : idx(G.size(), -1), n(1) {\n        vector<pair<T, int>> p;\n        EulerTour(G, s, s, 0, p);\n        int sz = p.size();\n        for (int i = sz-1; i >= 0; i--) idx[p[i].second] = i;\n        while (n < sz) { n *= 2; }\n        data.resize(2*n-1, id);\n        for (int i = 0; i < sz; i++) data[i+n-1] = p[i];\n        for (int i = n-2; i >= 0; i--) data[i] = min(data[i*2+1], data[i*2+2]);\n    }\n    void EulerTour(const Graph &G, int now, int par, T dep, vector<pair<T, int>> &path) {\n        path.emplace_back(dep, now);\n        for (auto nxt : G[now]) if (nxt.first != par) {\n            EulerTour(G, nxt.first, now, dep+nxt.second, path);\n            path.emplace_back(dep, now);\n        }\n    }\n    \n    pair<T, int> query (int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return id;\n        if (a <= l && r <= b) return data[k];\n        pair<T, int> vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        pair<T, int> vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n    \n    int ancestor (int a, int b) {\n        int l = min(idx[a], idx[b]), r = max(idx[a], idx[b]);\n        return query(l, r + 1).second;\n    }\n    \n    T distance(int a, int b) {\n        int l = min(idx[a], idx[b]), r = max(idx[a], idx[b]);\n        T an = query(l, r + 1).first;\n        T d1 = data[idx[a]+n-1].first, d2 = data[idx[b]+n-1].first;\n        return (d1 + d2 - an*2);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n;\n    vector<vector<pair<int, int>>> G(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        scanf(\"%d\", &k);\n        for (int j = 0; j < k; j++) {\n            int c;\n            scanf(\"%d\", &c);\n            G[i].emplace_back(c, 1);\n        }\n    }\n    \n    LowestCommonAncestor<int> lca(G, 0);\n    \n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        int anc = lca.ancestor(u, v);\n        printf(\"%d\\n\", anc);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nclass UnionFind{\n\tint *parent,*rank,n;\npublic:\n\tint root(int a){return parent[a]==a?a:(parent[a]=root(parent[a]));}\n\tUnionFind(int _n){n=_n;parent=new int[n];rank=new int[n];for(int i=0;i<n;i++)parent[i]=i,rank[i]=0;}\n\t~UnionFind(){delete []parent;delete []rank;}\n\tint unionSet(int a,int b){\n\t\tint x=root(a),y=root(b);if(x==y)return 0;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t}else{\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvector<int> color;\nvector<int> ancestor;\nvector<Query>qs;\n\nvoid visit(const Graph &g, int u, int w,\n    UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  color.resize(g.size()), ancestor.resize(g.size());\n  visit(g, r, -1, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100000];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nvoid sub(int idx)\n{\n  sz[idx] = query[idx].size();\n  for(auto &to : g[idx]) {\n    sub(to);\n    sz[idx] += query[to].size();\n  }\n}\n\nvoid dfs(int idx, bool keep)\n{\n  int heavy = -1;\n  for(auto &to : g[idx]) {\n    if(heavy == -1 || sz[to] > sz[heavy]) heavy = to;\n  }\n  for(auto &to : g[idx]) {\n    dfs(to, false);\n  }\n  for(int &v : query[idx]) {\n    buf[v] = true;\n  }\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      if(buf[v]++) lca[v] = idx;\n      query[idx].push_back(v);\n    }\n  }\n  if(!keep) for(auto &v : query[idx]) buf[v] = false;\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n\n  memset(lca, -1, sizeof(lca));\n\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n\n  sub(0);\n  dfs(0, 0);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * LCA (Lowest Common Ancestor)\n * ??????????????°\n *\n * ??????:\n *   * ??¨?????????????????¬???????????????\n *     https://www.npca.jp/works/magazine/2015_5/\n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef DEBUG\n#include <fmt/format.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  s8 =   int8_t;\nusing  u8 =  uint8_t;\nusing s16 =  int16_t;\nusing u16 = uint16_t;\nusing s32 =  int32_t;\nusing u32 = uint32_t;\nusing s64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// ???????????´\n//#define int s64\nconstexpr bool IOS_SYNCSTDIO = false;\nconstexpr int  IOS_PREC      = 10;\n\nconstexpr int    INF = numeric_limits<int>::max();\nconstexpr double EPS = 1e-9;\n\n// util {{{\ntemplate<typename T>\nconstexpr int sgn(T x)\n{\n    return (x > T(0)) - (x < T(0));\n}\n\ntemplate<typename T>\nconstexpr typename enable_if<is_signed<T>::value,T>::type modulo(T a, T b)\n{\n    assert(b > 0);\n    T r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi)\n{\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(x > hi)\n        return hi;\n    else\n        return x;\n}\n\nint sqrti(int x)\n{\n    assert(x >= 0);\n    return static_cast<int>(sqrt(x));\n}\n\ns64 sqrtl(s64 x)\n{\n    assert(x >= 0);\n    return static_cast<s64>(sqrtl(x));\n}\n\ntemplate<typename T>\nbool max_update(T& xmax, const T& x)\n{\n    if(x > xmax) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nbool min_update(T& xmin, const T& x)\n{\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c)\n{\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N])\n{\n    return static_cast<int>(N);\n}\n\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args)\n{\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args)\n{\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last)\n{\n    for(InputIt it = first; it != last; ++it) {\n        if(it != first) out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N])\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2])\n{\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args)\n{\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args)\n{\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last)\n{\n    return FPRINTSEQ(cout, first, last);\n}\n\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N])\n{\n    return FPRINTARRAY1(cout, c);\n}\n\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2])\n{\n    return FPRINTARRAY2(cout, c);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args)\n{\n    return FPRINT(cerr, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args)\n{\n    return FPRINTLN(cerr, args...);\n}\n\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last)\n{\n    return FPRINTSEQ(cerr, first, last);\n}\n\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N])\n{\n    return FPRINTARRAY1(cerr, c);\n}\n\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2])\n{\n    return FPRINTARRAY2(cerr, c);\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p)\n{\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c)\n{\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c)\n{\n    return out << set<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last)\n{\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last)\n{\n    return FPRINTMAP(cout, first, last);\n}\n\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last)\n{\n    return FPRINTMAP(cerr, first, last);\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c)\n{\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c)\n{\n    return out << map<K,V>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c)\n{\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c)\n{\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c)\n{\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\nstruct IosIni {\n    IosIni()\n    {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(IOS_SYNCSTDIO);\n        cout << fixed << setprecision(IOS_PREC);\n    }\n} IOSINI;\n\n#define FOR(i, start, end) for(int i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,cc,...) ([&](decltype((cc)) c) { return (f)(begin(c), end(c), ## __VA_ARGS__); })(cc)\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n// }}}\n\nint N;\nvector<vector<int>> T;\n\nvector<int> D; // ??????????????±???\nvector<vector<int>> P; // P[v][i]: v??????2^i????????£?????????\nint P_NI;\n\nvoid dfs(int v, int p, int d)\n{\n    D[v] = d;\n    P[v][0] = p;\n\n    for(int c : T[v]) {\n        if(c == p) continue;\n        dfs(c, v, d+1);\n    }\n}\n\nvoid make_p()\n{\n    REP(v, N) {\n        REP(i, P_NI-1) {\n            if(P[v][i] == -1) {\n                P[v][i+1] = -1;\n            }\n            else {\n                P[v][i+1] = P[P[v][i]][i];\n            }\n        }\n    }\n}\n\nint lca(int u, int v)\n{\n    // ?°????????????? D[u] <= D[v] ??¨??????\n    if(D[u] > D[v]) swap(u,v);\n\n    // u,v ?????±???????????????\n    int d = D[v] - D[u];\n    REP(i, P_NI) {\n        if((d>>i)&1) v = P[v][i];\n    }\n\n    // ?????´??????????????????LCA\n    // (v ??? u ????\\?????????£?????´???)\n    if(u == v) return u;\n\n    // ????????¢?´¢\n    for(int i = P_NI-1; i >= 0; --i) {\n        if(P[u][i] != P[v][i]) {\n            u = P[u][i];\n            v = P[v][i];\n        }\n    }\n    return P[u][0];\n}\n\nvoid solve()\n{\n    D.resize(N);\n\n    P_NI = 1 + static_cast<int>(log2(N));\n    P.assign(N, vector<int>(P_NI));\n\n    dfs(0, -1, 0);\n\n    make_p();\n\n#ifdef DEBUG\n    DBG(D);\n    DBG(P);\n#endif\n\n    int Q; cin >> Q;\n    REP(_, Q) {\n        int u, v; cin >> u >> v;\n        PRINTLN(lca(u,v));\n    }\n}\n\nsigned main(signed /*argc*/, char** /*argv*/)\n{\n    cin >> N;\n    T.resize(N);\n\n    REP(v, N) {\n        int k; cin >> k;\n        REP(_, k) {\n            int c; cin >> c;\n            T[v].push_back(c);\n            T[c].push_back(v);\n        }\n    }\n#ifdef DEBUG\n    DBG(T);\n#endif\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1L << (x))\nusing ll = long long;\nusing namespace std;\n\ntemplate<class Monoid>\nclass SegmentTree{\nprivate:\n  using T = typename Monoid::T;\n  const size_t n;\n  vector<T> d;\n\n  void build(){\n    for(size_t b = n - 1; b > 0; b--) d[b] = Monoid::op(d[b << 1], d[b << 1 | 1]);\n  }\n\npublic:\n  SegmentTree() {}\n\n  SegmentTree(size_t n)\n    : n(n), d(2 * n, Monoid::identify()) {}\n\n  template<typename InputItr>\n  SegmentTree(InputItr first, InputItr last)\n    : n(distance(first, last)), d(2 * n, Monoid::identify()){\n    copy(first, last, next(d.begin(), n));\n    build();\n  }\n\n  /* set one value */\n  void modify(size_t k, T v){\n    for(d[k += n] = v; k > 1; k >>= 1) d[k >> 1] = Monoid::op(d[k], d[k ^ 1]);\n  }\n\n  /* return [l, r) value */\n  T query(size_t l, size_t r){\n    T res {Monoid::identify()};\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l&1) res = Monoid::op(res, d[l++]);\n      if (r&1) res = Monoid::op(res, d[--r]);\n    }\n    return res;\n  }\n  \n  void dump(){\n    REP(i, 2 * n) cout << i << \": \" << d[i].first << \", \" << d[i].second << \" \" << endl;\n  }\n};\n\n/* Range Min Query */\ntemplate<typename U = ll>\nstruct RMQ{\n  using T = pair<U, U>;\n  static T op(const T& a, const T& b){ return min<T>(a, b); };\n  static constexpr T identify(){ return make_pair(numeric_limits<U>::max(), numeric_limits<U>::max()); };\n};\n\nusing graph = vector<vector<int>>;\n\n/* for tree, not graph */\nclass LCA{\nprivate:\n  const int n;\n  const graph g;\n  vector<int> vs, depth, id;\n  SegmentTree<RMQ<int>> tree;\n\n  /* init vs, depth, id */\n  void dfs(int v, int pv, int d, int& k){\n    vs.push_back(v);\n    depth.push_back(d);\n    id[v] = vs.size() - 1;\n\n    for(const int u: g[v]){\n      if(u != pv){\n        k++;\n        dfs(u, v, d+1, k);\n        vs.push_back(v);\n        depth.push_back(d);\n      }\n    }\n  }\n\n  /* build SegmentTree */\n  void build_rmq(){\n    REP(i, 2 * n - 1){\n      tree.modify(i, {depth[i], vs[i]});\n    }\n  }\n\npublic:\n  LCA(int n, const graph& g)\n    : n(n), g(g), id(n, 2*n), tree(2*n-1){\n    int k = 0;\n    dfs(0, -1, 0, k);\n    \n    build_rmq();\n  }\n  \n  int query(int u, int v){\n    if(id[u] > id[v]) swap(u, v);\n    auto res = tree.query(id[u], id[v] + 1);\n\n    return res.second;\n  }\n\n};\n\nint main() {\n  int n; cin >> n;\n  graph g(n);\n  \n  REP(u, n){\n    int k; cin >> k;\n    REP(j, k){\n      int v; cin >> v;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  }\n\n  LCA lca(n, g);\n\n  int q; cin >> q;\n  while(q--){\n    int x, y; cin >> x >> y;\n    \n    cout << lca.query(x, y) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//????°???±????\\??????????\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define MAX_V 100000\n\nvector<int> G[MAX_V];\nvector<int> depth,vs;\nint id[MAX_V]={};\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int b;\n            cin>>b;\n            G[i].pb(b);\n        }\n    }\n    init();                                                         // aranging depth[] , vs[] and id[]\n    segtree<pii> st(depth.size(),pii((1<<31)-1,(1<<31)-1));         // the number of elements is depth.size()\n    rep(i,depth.size()){                                            //initialize\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int a,b;\n    int q;\n    cin>>q;\n    rep(i,q){\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;  // is equal to LCA(a,b)\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nvector<int> ord;\nint depth[MAX_N];\nint id[MAX_N];\nbool flag[MAX_N];\n\n//?????????????????????0?§???????\n//????°????????±???????????????°??????(RMQ)\nconst int N = 1 << 18;\t//10^5?¨????\n\n//?????°???????????¨???????????°??????????????????\n\nint n_;\nint dat[2*N-1];\nint idx[2*N-1];\n\n//?????????\n//n_???x??\\??????????°????2????????????\nvoid init(int x)\n{\n\t//?°????????????????????´???°???2???????????????\n\tn_=1;\n\twhile(n_<x){\n\t\tn_*=2;\n\t}\n\trep(i,2*n_-1){\n\t\tdat[i] = INF;\n        idx[i] = -1;\n\t}\n}\n\n//k???????????????a????????´??????\nvoid update(int k,int a)\n{\n\t//????????????\n\tk += n_-1;\n\tdat[k] = a;\n    idx[k] = k - (n_-1);\n\t//?????????????????´??°\n\twhile(k>0){\n\t\tk = (k-1)/2;\n\t\tif(dat[2*k+1] < dat[2*k+2]){\n            dat[k] = dat[2*k+1];\n            idx[k] = idx[2*k+1];\n        }else{\n            dat[k] = dat[2*k+2];\n            idx[k] = idx[2*k+2];\n        }\n\t}\n}\n\nP query(int a,int b,int k=0,int l=0,int r=n_)\n{\n\tif(r <= a || b <= l){\n\t\treturn P(INF,-1);\n\t}\n\tif(a <= l && r <= b){\n\t\treturn P(dat[k],idx[k]);\n\t}else{\n\t\tP vl = query(a,b,2*k+1,l,(l+r)/2);\n\t\tP vr = query(a,b,2*k+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nvoid dfs(int u,int k)\n{\n    id[u] = ord.size();\n    ord.pb(u);\n    flag[u] = true;\n    depth[u] = k;\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],k+1);\n            ord.pb(u);\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,0);\n    init(ord.size());\n    rep(i,ord.size()){\n        update(i,depth[ord[i]]);\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\",ord[query(min(id[u],id[v]),max(id[u],id[v])+1).se]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\n\nint N,Q;\nvector<int> g[MAX_N+5];\nint root;\nint depth[MAX_N+5];\nint par[20][MAX_N];\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    for(int u=0;u<g[v].size();++u){\n        if(g[v][u]!=p)dfs(g[v][u],v,d+1);\n    }\n}\n\nvoid fill_table(){\n    for(int i=0;i<19;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nint LCA(int u,int v){\n    if(depth[u]>depth[v])swap(u,v);\n    for(int i=0;i<19;++i){\n        if((depth[v]-depth[u])>>i&1)v=par[i][v];\n    }\n    if(v==u)return u;\n    for(int i=19;i>=0;--i){\n        if(par[i][v]!=par[i][v]){\n            u=par[i][u];\n            v=par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;++j){\n            int c;\n            cin>>c;\n            g[i].PB(c);\n        }\n    }\n    dfs(root,-1,0);\n    fill_table();\n    cin>>Q;\n    while(Q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<LCA(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\nconstexpr int MAX_LOG_V = 50;\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b){a = b; return true;} return false;}\n\nstruct Edge{\n    int to,weight;\n    Edge(int t,int w) : to(t), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nclass Tree{\n    public:\n        Tree(int size) : mGraph(size), mMemo(size) {}\n        void add_edge(int s, int t, int w = 1){\n            mGraph[s].emplace_back(t,w);\n            mGraph[t].emplace_back(s,w);\n        }\n\n        // diameter of a tree\n        pair<int,int> dfs(int v, int pv){\n            pair<int,int> ret(0,v);\n            for(Edge nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                pair<int,int> tmp = dfs(nv.to,v);\n                if(chmax(ret.first,tmp.first + nv.weight)){\n                    ret.second = tmp.second;\n                }\n            }\n            return ret;\n        }\n\n        int diameter(){\n            pair<int,int> s = dfs(0,-1);\n            pair<int,int> t = dfs(s.second,-1);\n            return t.first;\n        }\n        //\n\n        // height of a tree\n        int dfs_memo(int v,int e){\n            if(mMemo[v][e].weight >= 0) return mMemo[v][e].weight;\n            mMemo[v][e].weight = mGraph[v][e].weight;\n            int nv = mMemo[v][e].to;\n            for(int ne = 0; ne < mMemo[nv].size(); ++ne){\n                if(mMemo[nv][ne].to == v) continue;\n                mMemo[v][e].weight = max(mMemo[v][e].weight, dfs_memo(nv,ne) + mGraph[v][e].weight);\n            }\n            return mMemo[v][e].weight;\n        }\n\n        vector<int> height(){\n            mMemo = mGraph;\n            // init memo\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    mMemo[i][j].weight = -1;\n                }\n            }\n            //\n            for(int i = 0; i < mMemo.size(); ++i){\n                for(int j = 0; j < mMemo[i].size(); ++j){\n                    if(mMemo[i][j].weight < 0){\n                        mMemo[i][j].weight = dfs_memo(i,j);\n                    }\n                }\n            }\n\n           // calc result\n           vector<int> ret(mMemo.size());\n           for(int i = 0; i < mMemo.size(); ++i){\n               for(int j = 0; j < mMemo[i].size(); ++j){\n                   ret[i] = max(ret[i],mMemo[i][j].weight);\n               }\n           }\n           return ret;\n        }\n        //\n        \n        // Lowest Common Ancester\n        void SetParentAndDepth(int v,int pv, int d){\n            mPar[0][v] = pv; // v is pv's 2^0 parent\n            mDepth[v] = d;\n            for(auto nv : mGraph[v]){\n                if(nv.to == pv) continue;\n                SetParentAndDepth(nv.to,v,d+1);\n            }\n        }\n\n        void Init(int root){\n            mPar.resize(MAX_LOG_V,vector<int>(mGraph.size()));\n            mDepth.resize(mGraph.size());\n            SetParentAndDepth(root,-1,0);\n            // calc 2^k parent of each vert\n            for(int k = 0; k + 1 < MAX_LOG_V; ++k){\n                for(int v = 0; v < mGraph.size(); ++v){\n                    if(mPar[k][v] < 0) mPar[k+1][v] = -1; // not having parent\n                    else mPar[k+1][v] = mPar[k][mPar[k][v]];\n                }\n            }\n        }\n\n        int GetLca(int u,int v){\n            while(mDepth[u] > mDepth[v]) swap(u,v);\n            for(int k = 0; k < MAX_LOG_V; ++k){\n                if((mDepth[v] - mDepth[u]) >> k & 1){\n                    v = mPar[k][v];\n                }\n            }\n            if(u==v) return u;\n            for(int k = MAX_LOG_V - 1; k >= 0; --k){\n                if(mPar[k][u] != mPar[k][v]) {\n                    u = mPar[k][u];\n                    v = mPar[k][v];\n                }\n            }\n            return mPar[0][u];\n        }\n        //\n\n\n    private:\n        Graph mGraph;\n        Graph mMemo;\n        \n        // LCA\n        vector<vector<int> > mPar;\n        vector<int> mDepth;\n};\n\nint main(){\n    int n,q,k,x,y;\n    cin >> n;\n    Tree tree(n);\n    for(int i = 0; i < n; ++i){\n        cin >> k;\n        for(int j = 0; j < k; ++j){\n            cin >> x;\n            tree.add_edge(i,x);\n        }\n    }\n    tree.Init(0);\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        cin >> x >> y;\n        cout << tree.GetLca(x,y) << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\nconst int logn=20;\n\nint n,q,l;\nint dep[maxn];\nint up[maxn][logn];\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n    dep[u]=dep[p]+1;\n    up[u][0]=p;\n    for (int i=0;i<l;i++) up[u][i+1]=up[up[u][i]][i];\n    for (int v:G[u])\n        if (v!=p) dfs(v,u);\n}\n\nint lca(int u,int v) {\n    if (dep[u]<dep[v]) swap(u,v);\n    for (int i=l;i>=0;i--) {\n        if (dep[up[u][i]]>=dep[v]) u=up[u][i];\n        if (u==v) return u;\n    }\n    for (int i=l;i>=0;i--)\n        if (up[u][i]!=up[v][i]) {\n            u=up[u][i];\n            v=up[v][i];\n        }\n    return up[u][0];\n}\n\nint main() {\n    cin>>n;\n    for (int i=0;i<n;i++) {\n        int m; cin>>m;\n        for (int j=0;j<m;j++) {\n            int v; cin>>v;\n            G[i].pb(v);\n        }\n    }\n    while ((1<<l)<=n) ++l;\n    dfs(0,0);\n    cin>>q;\n    for (int i=0;i<q;i++) {\n        int u,v; cin>>u>>v;\n        cout<<lca(u,v)<<'\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  //{{{\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) std::cerr << #x << ':' << x << '\\n';\n\ntypedef long long ll;\n// clang-format off\ntemplate<typename T,typename U>inline bool chmax(T&x,U a){if(x>=a)return 0;x=a;return 1;}\ntemplate<typename T,typename U>inline bool chmin(T&x,U a){if(x<=a)return 0;x=a;return 1;}\ninline int in(){int x;scanf(\"%d\", &x);return x;}\n// clang-format on\n// }}}\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\n#include <climits>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  typedef int weight_type;\n  static constexpr weight_type INF =\n      std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\ntypedef Edge::weight_type Weight;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Weights;\ntypedef std::vector<int> Path;\n}\ntypedef std::vector<graph::Edges> Graph;\n}\n#endif\n//}}}\n//{{{ hl_decomposition.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n\nnamespace orliv {\nnamespace graph {\n\nstruct HLDecomposition {\n  const Graph& g;\n  const int V;\n  std::vector<int> par, ord, depth;\n  std::vector<int> cluster;\n  std::vector<Path> pathes;\n  std::vector<int> path_idx;\n\n  HLDecomposition(const Graph& g) : g(g), V(g.size()) {}\n\n  void build(int root = 0) {\n    ord.clear();\n    ord.reserve(V);\n    pathes.clear();\n    par.assign(V, 0);\n    depth.assign(V, 0);\n\n    ord.emplace_back(root);\n    par[root] = -1;\n    for (int i = 0; i < ord.size(); i++) {\n      int u = ord[i];\n      for (const auto& e : g[u]) {\n        int v = e.to;\n        if (par[u] == v) continue;\n        par[v] = u;\n        depth[v] = depth[u] + 1;\n        ord.emplace_back(v);\n      }\n    }\n    decomposition();\n  }\n  int lca(int u, int v) const {\n    while (cluster[u] != cluster[v]) {\n      int head_u = pathes[cluster[u]][0];\n      int head_v = pathes[cluster[v]][0];\n      if (depth[head_u] > depth[head_v]) {\n        std::swap(u, v);\n        std::swap(head_v, head_u);\n      }\n      v = par[head_v];\n    }\n    return depth[u] < depth[v] ? u : v;\n  }\n\n private:\n  void decomposition() {\n    std::vector<int> subtree_size(V, 1);\n    for (int i = V - 1; i > 0; i--) {\n      subtree_size[par[ord[i]]] += subtree_size[ord[i]];\n    }\n    cluster.assign(V, -1);\n    for (int u : ord) {\n      if (cluster[u] == -1) {\n        cluster[u] = pathes.size();\n        pathes.emplace_back();\n      }\n      pathes[cluster[u]].emplace_back(u);\n\n      int max_subsize = -1, selected = -1;\n      for (const auto& e : g[u]) {\n        int v = e.to;\n        if (par[u] == v) continue;\n        if (max_subsize >= subtree_size[v]) continue;\n        max_subsize = subtree_size[v];\n        selected = v;\n      }\n      if (selected != -1) cluster[selected] = cluster[u];\n    }\n    path_idx.resize(V);\n    for (const auto& path : pathes) {\n      for (int i = 0; i < path.size(); i++) path_idx[path[i]] = i;\n    }\n  }\n};\n}\n}\n//}}}\n\nusing namespace std;\n\nint main() {\n  int N = in();\n  orliv::Graph g(N);\n  for (int i = 0; i < N; i++) {\n    int k = in();\n    for (int j = 0; j < k; j++) {\n      int c = in();\n      g[i].emplace_back(i, c);\n      g[c].emplace_back(c, i);\n    }\n  }\n  orliv::graph::HLDecomposition hl(g);\n  hl.build(0);\n  int q = in();\n  for (int i = 0; i < q; i++) {\n    int u = in(), v = in();\n    cout << hl.lca(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst int MAX_N = 100010;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int min_id[4 * MAX_N];\n        pair<int, int> query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return make_pair(INT_MAX,INT_MAX);\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return make_pair(dat[k],min_id[k]);\n            else{\n                //????????§???????????°??????????????????????°????\n                pair<int, int> vl = query(a, b, k * 2, l, ( l + r) / 2);\n                pair<int, int> vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                if(vl.first < vr.first) return vl;\n                else return vr;\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n * n; i++){\n                dat[i] = a[i - n];\n                min_id[i] = i - n;\n            }\n            for(int i = n - 1; i >= 1; i--){\n                if(dat[i * 2] < dat[i * 2 + 1]){\n                    dat[i] = dat[i * 2];\n                    min_id[i] = min_id[i * 2];\n                }else{\n                    dat[i] = dat[i * 2 + 1];\n                    min_id[i] = min_id[i * 2 + 1];\n                }\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°?????????????????????????\n        int query(int a, int b){\n            return query(a,b,1,0,n).second;\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int par, int d, int &k){\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(G[v][i] != par){\n                    dfs(G[v][i], v, d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, -1, 0, k);\n            rmqInit(depth,V * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nint n;\nvector<int> vs[100005];\n\nint ans[100005];\n\nset<int> s[100005];\n\nvoid dfs(){\n\tvector<int> stc;\n\tstc.push_back(0);\n\t{\n\t\tfor(int i=0;i!=stc.size();i++){\n\t\t\tint no=stc[i];\n\t\t\trep(j,vs[no].size()){\n\t\t\t\tstc.push_back(vs[no][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tirep(k,stc.size()){\n\t\tint no=stc[k];\n\t\n\t\trep(i,vs[no].size()){\n\t\t\tint to=vs[no][i];\n\t\t\tif(s[to].size()>s[no].size())swap(s[no],s[to]);\n\t\t\t\n\t\t\tfor(set<int>::iterator ite=s[to].begin(); ite!=s[to].end(); ite++){\n\t\t\t\tint p=*ite;\n\t\t\t\tif(s[no].count(p)>=1){\n\t\t\t\t\ts[no].erase(p);\n\t\t\t\t\tans[p]=no;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts[no].insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\trep(j,k){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tvs[i].push_back(a);\n\t\t}\n\t}\n\t\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a==b)ans[i]=a;\n\t\telse{\n\t\t\ts[a].insert(i);\n\t\t\ts[b].insert(i);\n\t\t}\n\t}\n\t\n\tdfs();\n\t\n\trep(i,q){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 100010;\nconst int INF = 2147483647;\n\nint n;\nP v[2 * MAX_N - 1];\n\nvoid init(int _n){\n  n = 1;\n  while(n < _n) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(INF, INF);\n}\n\nvoid update(int k, P a){\n  k += n - 1;\n  v[k] = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = v[k * 2 + 1].first < v[k * 2 + 2].first ? v[k * 2 + 1] : v[k * 2 + 2];\n  }\n}\n\nP query(int a, int b, int k, int l, int r){\n  if(b <= l || a >= r) return P(INF, INF);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return min(vl, vr);\n}\n\nint id[MAX_N], vs[MAX_N * 2 - 1], depth[MAX_N * 2 - 1];\nvector< vector<int> > G(MAX_N);\n\nvoid dfs(int v, int prev, int d, int &k){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  REP(i, G[v].size()){\n    if(G[v][i] != prev){\n      dfs(G[v][i], v, d + 1, k);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid lca_init(int N, int root){\n  int k = 0;\n  dfs(root, -1, 0, k);\n  init(k + 1);\n  REP(i, k) update(i, P(depth[i], vs[i]));\n}\n\nint lca(int a, int b){\n  return query(min(id[a], id[b]), max(id[a], id[b]) + 1, 0, 0, n).second;\n}\n\n\nint main() {\n  int N; cin >>N;\n  REP(i, N){\n    int k; cin >>k;\n    REP(j, k){\n      int c; cin >>c;\n      G[i].push_back(c);\n    }\n  }\n  lca_init(N, 0);\n  int Q; cin >>Q;\n  REP(q, Q){\n    int a, b; cin >>a >>b;\n    cout <<lca(a, b) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cstdio>\nusing namespace std;\nmap<int,int>m;\nvoid dfs(set<int>&v,int cur){\n\tv.insert(cur);\n\tif(cur)dfs(v,m[cur]);\n}\nmain(){\n\tint n,i=0,j,x;\n\tfor(scanf(\"%d\",&n);i<n;i++)for(scanf(\"%d\",&j);j--;)scanf(\"%d\",&x),m[x]=i;\n\tfor(scanf(\"%d\",&n);n--;){\n\t\tscanf(\"%d%d\",&i,&j);\n\t\tset<int>v;\n\t\tdfs(v,i);\n\t\tfor(;v.find(j)==v.end();)j=m[j];\n\t\tprintf(\"%d\\n\",j);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass HeavyLight{\n\tpublic:\n\tint pathCount,n;\n\tvi size,parent,in,out,path,pathRoot;\n\tvvi tree;\n\t\n\tHeavyLight(vvi t)\n\t\t:pathCount(0),n(t.size()),size(n),parent(n),in(n),out(n),\n\t\tpath(n),pathRoot(n),tree(t){\n\t\tint time=0;\n\t\tdfs(0,-1,time);\n\t\tbuildPaths(0,newPath(0));\n\t}\n\tvoid dfs(int u,int p,int &k){\n\t\tin[u]=k++,parent[u]=p,size[u]=1;\n\t\tfor(auto v=tree[u].begin();v!=tree[u].end();v++)if(*v!=p)\n\t\t\tdfs(*v,u,k),size[u]+=size[*v];\n\t\tout[u]=k++;\n\t}\n\tint newPath(int u){pathRoot[pathCount]=u;return pathCount++;}\n\tvoid buildPaths(int u,int pt){\n\t\tpath[u]=pt;\n\t\tfor(auto v=tree[u].begin();v!=tree[u].end();v++)if(*v!=parent[u]){\n\t\t\tbuildPaths(*v,2*size[*v]>=size[u]?pt:newPath(*v));\n\t\t}\n\t}\n\tbool inAncestor(int p,int ch){\n\t\treturn in[p]<=in[ch]&&out[ch]<=out[p];\n\t}\n\tint lca(int a,int b){\n\t\tfor(int root;!inAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n\t\tfor(int root;!inAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n\t\treturn inAncestor(a,b)?a:b;\n\t}\n};\nint main(){\n\tint n;\n\tcin>>n;\n\tvvi tree(n);\n\trep(i,n){\n\t\tint k;cin>>k;\n\t\trep(j,k){\n\t\t\tint ch;cin>>ch;\n\t\t\ttree[i].pb(ch);\n\t\t}\n\t}\n\tHeavyLight hl(tree);\n\t\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<hl.lca(a,b)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <functional>\n#include <vector>\n\nstruct HLDecomposition {\n  const int N;\n  std::vector<std::vector<int>> tree;\n  std::vector<int> cluster, par, depth, ord, head, offset;\n\n  // ord[head[cluster[u]] + offset[u]] == u\n\n  HLDecomposition(int N) : N(N), tree(N), cluster(N, -1), par(N, -1), depth(N), ord(N), offset(N) {}\n\n  void add_edge(int u, int v) {\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n  void build(int root = 0) {\n    std::vector<int> Q;\n    Q.reserve(N);\n    Q.push_back(root);\n    for (int i = 0; i < N; i++) {\n      int u = Q[i];\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        par[v] = u;\n        depth[v] = depth[u] + 1;\n        Q.push_back(v);\n      }\n    }\n    std::vector<int> subtree_size(N, 1);\n    for (int i = N - 1; i > 0; i--) {\n      subtree_size[par[Q[i]]] += subtree_size[Q[i]];\n    }\n\n    std::vector<std::vector<int>> pathes;\n    for (int u : Q) {\n      if (cluster[u] == -1) {\n        cluster[u] = pathes.size();\n        pathes.emplace_back();\n      }\n      pathes[cluster[u]].push_back(u);\n\n      int max_subsize = -1, selected = -1;\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        if (max_subsize >= subtree_size[v]) continue;\n        max_subsize = subtree_size[v];\n        selected = v;\n      }\n      if (selected != -1) cluster[selected] = u;\n    }\n\n    int P = pathes.size();\n    head.resize(P + 1);\n    for (int p = 0; p < P; p++) {\n      int H = head[p];\n      int L = pathes[p].size();\n      head[p + 1] = H + L;\n      for (int i = 0; i < L; i++) {\n        int v = pathes[p][i];\n        offset[v] = i;\n        ord[H + i] = v;\n      }\n    }\n  }\n  void for_each(int u, int v, std::function<void(int, int)> f) const {\n    while (cluster[u] != cluster[v]) {\n      if (depth[head[cluster[u]]] > depth[head[cluster[v]]]) std::swap(u, v);\n      int h = head[cluster[v]];\n      f(h, h + offset[v] + 1);\n      v = par[h];\n    }\n    if (offset[u] > offset[v]) std::swap(u, v);\n    f(head[cluster[u]] + offset[u], head[cluster[v]] + offset[v] + 1);\n  }\n  int lca(int u, int v) const {\n    int x;\n    for_each(u, v, [&](int l, int r) { x = ord[l]; });\n    return x;\n  }\n  std::vector<std::vector<int>> build_pathes() const {\n    const int P = head.size() - 1;\n    std::vector<std::vector<int>> pathes(P);\n    for (int i = 0; i < P; i++) {\n      pathes[i].reserve(head[i + 1] - head[i]);\n      for (int j = head[i]; j < head[i + 1]; j++) {\n        pathes[i].push_back(ord[j]);\n      }\n    }\n    return pathes;\n  }\n};\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n// clang-format off\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}if(m)x=-x;return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n\nint main() {\n  int N = rd();\n  HLDecomposition hl(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    for (int j = 0; j < k; j++) {\n      hl.add_edge(i, rd());\n    }\n  }\n  hl.build();\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(hl.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdint>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::uint_fast32_t;\n\nprivate:\n\tstd::vector<std::pair<bool, size_type>> tree;\n\npublic:\n\tUnionFind(const size_type size) : tree(size, std::make_pair(1, 1)) {}\n\tsize_type find(const size_type x) {\n\t\tassert(x < size());\n\t\tif (tree[x].first)\n\t\t\treturn x;\n\t\treturn tree[x].second = find(tree[x].second);\n\t}\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (tree[x].second < tree[y].second)\n\t\t\tstd::swap(x, y);\n\t\ttree[x].second += tree[y].second;\n\t\ttree[y] = std::make_pair(0, x);\n\t\treturn true;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn tree[find(x)].second;\n\t}\n\tsize_type size() const noexcept { return tree.size(); }\n\tbool empty() const noexcept { return tree.empty(); }\n};\n\n#include <cstddef>\n#include <functional>\n#include <utility>\n#include <vector>\n\ntemplate <class GraphContainer, class UnionFindDataStructure>\nstd::vector<typename GraphContainer::size_type> TarjansOfflineLCA(\n\tconst GraphContainer &graph, const typename GraphContainer::size_type root,\n\tconst std::vector<std::pair<typename GraphContainer::size_type,\n\ttypename GraphContainer::size_type>> &queries) {\n\tusing size_type = typename GraphContainer::size_type;\n\tconst size_type size_ = graph.size();\n\tUnionFindDataStructure uft(size_);\n\tstd::vector<size_type> ret(queries.size(), size_), anc(size_);\n\tstd::vector<std::vector<std::size_t>> qset(size_);\n\n\tfor (std::size_t i = 0; i < queries.size(); ++i) {\n\t\tqset[queries[i].first].emplace_back(i);\n\t\tqset[queries[i].second].emplace_back(i);\n\t}\n\n\tstd::function<void(const size_type, const size_type)> dfs =\n\t\t[&](const size_type v, const size_type prev) {\n\t\tanc[v] = v;\n\t\tfor (const auto &e : graph[v]) {\n\t\t\tif (e.to != prev) {\n\t\t\t\tdfs(e.to, v);\n\t\t\t\tuft.unite(v, e.to);\n\t\t\t\tanc[uft.find(v)] = v;\n\t\t\t}\n\t\t}\n\t\tfor (const auto e : qset[v])\n\t\t\tif (ret[e] == size_)\n\t\t\t\tret[e] = v;\n\t\t\telse\n\t\t\t\tret[e] = anc[uft.find(ret[e])];\n\t};\n\tdfs(root, size_);\n\treturn ret;\n}\n\n\n#include <cstddef>\n#include <vector>\n\nstruct edge {\n\tusing cost_type = int;\n\tusing size_type = std::size_t;\n\n\tstd::size_t to;\n\tedge(size_type t):to(t){}\n};\n\ntemplate <class Edge> using Graph = std::vector<std::vector<Edge>>;\n\n#include<cstdio>\nint main() {\n\tusing uint = unsigned int;\n\tuint n;\n\tscanf(\"%u\", &n);\n\tGraph<edge> g(n);\n\tfor (uint i = 0;i < n;++i) {\n\t\tuint k, c;\n\t\tscanf(\"%u\", &k);\n\t\twhile (k--) {\n\t\t\tscanf(\"%u\", &c);\n\t\t\tg[i].emplace_back(c);\n\t\t}\n\t}\n\tuint q;\n\tscanf(\"%u\", &q);\n\tusing S = typename Graph<edge>::size_type;\n\tstd::vector<std::pair<S, S>> Q;\n\tQ.reserve(q);\n\twhile (q--) {\n\t\tuint u, v;\n\t\tscanf(\"%u%u\", &u, &v);\n\t\tQ.emplace_back(u, v);\n\t}\n\tconst auto &&ans=TarjansOfflineLCA<Graph<edge>, UnionFind>(g, 0, Q);\n\tfor (const auto e : ans)\n\t\tprintf(\"%u\\n\", e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nstruct LCA\n{\n    int i,j;\n    vector<vector<int>> parent;\n    vector<int> dist;\n    LCA(const vector<vector<ll>> &graph, int root = 0){\n        init(graph, root);\n    }\n\n    void init(const vector<vector<ll>> &graph, int root = 0){\n        int v = graph.size();\n        int k = 1;\n        while((1ll << k) < v) ++k;\n        parent.assign(k, vector<int>(v, -1));\n        dist.assign(v, -1);\n        dfs(graph, root, -1, 0);\n        for(i = 0;i < k-1;++i){\n            rep(j,v){\n                if(parent.at(i).at(j) < 0){\n                    parent.at(i+1).at(j) = -1;\n                }else{\n                    parent.at(i+1).at(j) = parent.at(i).at(parent.at(i).at(j));\n                }\n            }\n        }\n    }\n\n    void dfs(const vector<vector<ll>> &graph, int v, int p, int d){\n        parent.at(0).at(v) = p; //戻る方向?\n        dist.at(v) = d;\n        for(auto next:graph.at(v)){\n            if(next != p) dfs(graph, next, v, d+1);\n        }\n    }\n\n    int query(int u, int v){\n        if(dist.at(u) < dist.at(v)) swap(u, v);\n        int n = parent.size();\n        for(i = 0;i < n;++i){\n            if((dist.at(u) - dist.at(v)) >> i & 1) u = parent.at(i).at(u);\n        }\n\n        if(u == v) return u;\n        for(i = n-1;i >= 0;--i){\n            if(parent.at(i).at(u) != parent.at(i).at(v)){\n                u = parent.at(i).at(u);\n                v = parent.at(i).at(v);\n            }\n        }\n        return parent.at(0).at(u);\n    }\n\n    int get_dist(int u, int v){\n        return dist.at(u) + dist.at(v) - 2*dist.at(query(u, v));\n    }\n\n    bool is_on_path(int u, int v, int a){\n        return get_dist(u, a) + get_dist(a, v) == get_dist(u, v);\n    }\n\n};\n\nint main()\n{\n    ll i,j;\n    ll n;\n    cin >> n;\n    vector<vector<ll>> graph(n);\n    for(i = 0;i < n;++i){\n        ll k;\n        cin >> k;\n        rep(j,k){\n            ll c;\n            cin >> c;\n            graph.at(i).push_back(c);\n            graph.at(c).push_back(i);\n        }\n    }\n\n    LCA lca(graph, 0);\n    ll q;\n    cin >> q;\n    for(i = 0;i < q;++i){\n        ll u,v;\n        cin >> u >> v;\n        cout << lca.query(u,v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#include <iterator>\n#define BIT(nr) (1UL << (nr))\n#define int long long\n//#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t//ない環境用\n#define LL_HALFMAX 9223372036854775807 / 2\t//ない環境用\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\n\nusing namespace std;\n\n//デバッグ用カッコの有無\n#ifdef DEBUG\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\to << \"{\"; for (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\tfor (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \" \" : \"\") << v[i]; return o;\n}\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nint dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)\nint dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n// 辺がメンバに src と dst を持つ隣接リスト表記のグラフをダンプ(https://hello-world-494ec.firebaseapp.com/) に投げることを想定\ntemplate <typename T>\nvoid dump_graph(T G) {\n\tint V = G.size();\n\tint E = 0;\n\tostringstream os;\n\n\tfor (auto es : G) {\n\t\tfor (auto e : es) {\n\t\t\tE++;\n\t\t\tos << e.src << \" \" << e.dst << \"\\n\";\n\t\t}\n\t}\n\tcout << V << \" \" << E << \"\\n\";\n\tcout << os.str() << \"\\n\";\n}\n\n// グリッドからグラフを構築\n// @pre: gはノード数H*Wのグラフ\nvoid create_from_grid(Graph& g, int h, int w, vector<string>& mapData, char wall) {\n\t//グラフ構築 O(HW)\n\trep(y, h) {\n\t\trep(x, w) {\n\t\t\tif (mapData[y][x] == wall) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint id = y * w + x;\n\t\t\t//右と下(変位が正)のみ見る(辺の重複を回避するため)\n\t\t\trep(i, 2) {\n\t\t\t\tint nx = x + dxp[i];\n\t\t\t\tint ny = y + dyp[i];\n\t\t\t\tint nid = ny * w + nx;\n\t\t\t\tif (nx < 0 || nx >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (mapData[ny][nx] != wall) {\n\t\t\t\t\tadd_edge(g, id, nid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// グリッドにおいて座標をグラフのノード番号に変換する\nint point_to_node_num(int x, int y, int W) {\n\treturn y * W + x;\n}\n\nstruct uf_tree {\n\tstd::vector<int> parent;\n\tint __size;\n\tuf_tree(int size_) : parent(size_, -1), __size(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif ((x = find(x)) != (y = find(y))) {\n\t\t\tif (parent[y] < parent[x]) std::swap(x, y);\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\t__size--;\n\t\t}\n\t}\n\tbool is_same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return parent[x] < 0 ? x : parent[x] = find(parent[x]); }\n\tint size(int x) { return -parent[find(x)]; }\n\tint size() { return __size; }\n};\n\n\n\n\n/*\n行列積と行列累乗\n行列積\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL)\n行列累乗\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL)\nT:\t\t\t考える集合(競プロにおいてはたぶんほぼ整数)\nl:\t\t\t左からかける行列\nr:\t\t\t右からかける行列\nplus:\t\t加法演算\nmultiple:\t乗法演算\neplus:\t\t加法の単位元\nemultiple:\t乗法の単位元\n*/\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL) {\n\tint rx = r[0].size();\n\tint ry = r.size();\n\tvector<vector<T> > ret;\n\n\tfor (int y = 0; y < ry; y++) {\n\t\tvector<T> add;\n\t\tfor (int x = 0; x < rx; x++) {\n\t\t\tT cell = eplus;\n\t\t\tfor (int i = 0; i < ry; i++) {\n\t\t\t\tT mul = multiple(l[y][i], r[i][x]);\n\t\t\t\tcell = plus(cell, mul);\n\t\t\t}\n\t\t\tadd.push_back(cell);\n\t\t}\n\t\tret.push_back(add);\n\t}\n\treturn ret;\n}\n\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL) {\n\tint k = m.size();\n\tif (n == 0) {\n\t\tvector<vector<T> > E;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\t// 単位行列は対角成分を乗法単位元、非対角成分をゼロ元で埋める\n\t\t\tvector<T> v(k, eplus);\n\t\t\tv[i] = emultiple;\n\t\t\tE.push_back(v);\n\t\t}\n\t\treturn E;\n\t}\n\tvector<vector<T>> ret = matrixPower(matrixMultiplies(m, m, plus, multiple, eplus), n / 2, plus, multiple, eplus, emultiple);\n\tif (n % 2 == 1) {\n\t\tret = matrixMultiplies(m, ret, plus, multiple);\n\t}\n\treturn ret;\n}\n\n// フロー系のアルゴリズム\n// 最大流\n/*\nFord-Fulkerson法(蟻本) O(F|E|)\nF: 最大流量\nE: 辺数\nコンストラクタ引数でノード数nを受け取り初期化し、add_edge で辺と逆辺を追加していく\n*/\nclass Ford_Fulkerson {\nprivate:\n\tstruct Edge {\n\t\tint src, dst;\n\n\t\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\t\tint rev;\n\t\tint cap;\n\t\tEdge(int s, int d, int c, int r) : src(s), dst(d), cap(c), rev(r) {}\n\t};\n\tvector<vector<Edge> > G;\n\tvector<bool> used;\npublic:\n\tFord_Fulkerson(int n) :\n\t\tG(n),\n\t\tused(n, false)\n\t{}\n\n\tvoid add_edge(int s, int d, int cap) {\n\t\tG[s].emplace_back(s, d, cap, G[d].size());\n\t\tG[d].emplace_back(d, s, 0, G[s].size() - 1);\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) {\n\t\t\treturn f;\n\t\t}\n\t\tused[v] = true;\n\t\tfor (Edge& e : G[v]) {\n\t\t\tif (!used[e.dst] && e.cap > 0) {\n\t\t\t\t// 流せる辺があったら流す\n\t\t\t\tint d = dfs(e.dst, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\t// 辺の残り容量を減らす\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\t// 逆辺の容量を増やす\n\t\t\t\t\tG[e.dst][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t にたどり着けなかったら0\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < used.size(); i++) {\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tint f = dfs(s, t, LL_HALFMAX);\n\t\t\tif (f == 0) {\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t\tflow += f;\n\t\t}\n\t}\n\n};\n\n/*\nDinic法 From libalgo O(V^2 * E)\ndinic::solve(s, t) : s -> t の最大流を求める\ndinic;;flow[u][v] : 辺(u, v)の流量\n*/\nstruct dinic {\n\tint n, s, t;\n\tstd::vector<int> level, prog, que;\n\tstd::vector<std::vector<Flow>> cap, flow;\n\tstd::vector<std::vector<int>> g;\n\tFlow inf;\n\tdinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, std::vector<Flow>(n)),\n\t\tflow(n, std::vector<Flow>(n)),\n\t\tg(n, std::vector<int>()),\n\t\tinf(std::numeric_limits<Flow>::max() / 8) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tFlow c = e.cap;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\t// 残りを求める\n\tinline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\n\t// 実際に最大流問題を解く\n\tFlow solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tFlow res = 0;\n\t\t// levelize() == false: bfs で s から t に到達できなかった\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\t// bfs でレベルグラフをつくる\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v]) {\n\t\t\t\t// まだレベルが決まっておらず、v -> dの辺に流せるならlevel[d] = level[v] + 1\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t に到達できるなら true を返す\n\t\treturn level[t] != -1;\n\t}\n\t// dfs で実際に流してみる\n\tFlow augment(int v, Flow lim) {\n\t\tFlow res = 0;\n\t\tif (v == t) return lim;\n\t\t// prog[v]: dfs において、vを展開する際、vの子の何番目まで展開したかを覚えておく\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\t// v -> d に流せない or v(流す側) の方がレベルが大きい(=深い)場合NG\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\t// 流せるなら、流せるだけ流す\n\t\t\tconst Flow aug = augment(d, std::min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\t// ノードvに来ている流量を使い切ったら終わり\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n/*\nPrimal-Dual法(蟻本版 / ベルマンフォード)\n*/\n\nclass Primal_Dual_BellmanFord {\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint src, dst;\n\n\t\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\t\tint rev;\n\t\tCost cost;\n\t\tFlow cap;\n\t\tEdge(int s, int d, int aRev, Cost aCost, Flow aCap) : src(s), dst(d), rev(aRev), cost(aCost), cap(aCap) {}\n\t};\n\n\tint V;\t\t\t\t\t\t\t//頂点数\n\tvector<vector<Edge>> G;\t\t\t// 隣接リスト\n\tvector<int> dist;\t\t\t\t// 最短距離\n\tvector<int> prevv;\t\t\t\t// 直前の頂点\n\tvector<int> preve;\t\t\t\t// 直前の辺\n\tconst int INF;\n\npublic:\n\t// 頂点数 n を引数にとって初期化\n\tPrimal_Dual_BellmanFord(int n) :\n\t\tV(n),\n\t\tG(n),\n\t\tdist(n, 0),\n\t\tprevv(n, 0),\n\t\tpreve(n, 0),\n\t\tINF(std::numeric_limits<int>::max() / 8) {}\n\tvoid add_edge(int src, int dst, int cap, int cost) {\n\t\t// cost は weight に入れる\n\t\tG[src].emplace_back(src, dst, G[dst].size(), cost, cap);\n\t\tG[dst].emplace_back(dst, src, G[src].size() - 1, -cost, 0);\n\t}\n\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\twhile (f > 0) {\n\t\t\t// ベルマンフォードによりs-t最短路をもとめる\n\t\t\tdist.assign(V, INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tEdge& e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.dst] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// これ以上流せない\n\t\t\tif (dist[t] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// 復元したs-t最短路に沿って流せるだけ流す\n\t\t\tint d = f;\n\t\t\t// 尻からprevvを辿っていき、流せる量を求める\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\t// 一つ手前に戻るための辺\n\t\t\t\tEdge &e = G[prevv[v]][preve[v]];\n\t\t\t\tchmin(d, e.cap);\n\t\t\t}\n\n\t\t\tf -= d;\n\n\t\t\t// ここでの dist はコスト和なので、それに流す量をかけると今回見つけた最短パスに流すコストとなる。\n\t\t\tres += d * dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n/*\nダイクストラ版 Primal-Dual\n出典: https://ei1333.github.io/luzhiled/snippets/graph/primal-dual.html\n*/\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n\tconst cost_t INF;\n\n\tstruct edge {\n\t\tint to;\n\t\tflow_t cap;\n\t\tcost_t cost;\n\t\tint rev;\n\t\tbool isrev;\n\t\tedge(int aTo, flow_t aCap, cost_t aCost, int aRev, bool aIsRev) : to(aTo), cap(aCap), cost(aCost), rev(aRev), isrev(aIsRev) {}\n\t};\n\tvector< vector< edge > > graph;\n\tvector< cost_t > potential, min_cost;\n\tvector< int > prevv, preve;\n\n\tPrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n\tvoid add_edge(int from, int to, flow_t cap, cost_t cost) {\n\t\tgraph[from].emplace_back(to, cap, cost, (int)graph[to].size(), false);\n\t\tgraph[to].emplace_back(from, 0, -cost, (int)graph[from].size() - 1, true);\n\t}\n\n\tcost_t min_cost_flow(int s, int t, flow_t f) {\n\t\tint V = (int)graph.size();\n\t\tcost_t ret = 0;\n\t\tusing Pi = pair< cost_t, int >;\n\t\tpriority_queue< Pi, vector< Pi >, greater< Pi > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, INF);\n\t\t\tque.emplace(0, s);\n\t\t\tmin_cost[s] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPi p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tcost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.emplace(min_cost[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tflow_t addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid output() {\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tif (e.isrev) continue;\n\t\t\t\tauto &rev_e = graph[e.to][e.rev];\n\t\t\t\tcout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass lca {\npublic:\n\tint n, segn;\n\tvector<int> path;\t\t// 蟻本の vs、オイラーツアーを保持\n\tvector<int> depth;\t\t// 蟻本の depth、path[i] であるノードの深さを保持\n\tvector<int> in_order;\t// 蟻本の id、ノードiがオイラーツアーで最初に出てくるインデックスを保持\n\tvector<pair<int, int>> dat;\n\tconst std::pair<int, int> INF = std::make_pair(1000000000, 1000000000);\n\n\tlca(const Graph& g, int root) : n(g.size()), path(n*2-1), depth(n*2-1), in_order(n) {\n\t\tint k = 0;\n\t\tdfs(g, root, -1, 0, k);\n\n\t\t// セグ木を構築、持つのはpair(depth, index) => depth が最小となる index がわかる \n\t\tfor (segn = 1; segn < n * 2 - 1; segn <<= 1);\n\n\t\tdat.assign(segn * 2, INF);\n\t\tfor (int i = 0; i < (int)depth.size(); ++i) dat[segn + i] = std::make_pair(depth[i], i);\n\t\tfor (int i = segn - 1; i >= 1; --i) dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n\t}\n\n\tint get(int u, int v) const {\n\t\tint l = std::min(in_order[u], in_order[v]);\n\t\tint r = std::max(in_order[u], in_order[v]) + 1;\n\t\treturn path[range_min(1, segn, l, r).second];\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d, int& k) {\n\t\t// k: オイラーツアーの何番目かを保持する変数\n\t\tin_order[v] = k;\n\t\tpath[k] = v;\n\t\tdepth[k++] = d;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (e.dst != p) {\n\t\t\t\tdfs(g, e.dst, v, d + 1, k);\n\t\t\t\t// ここに来た時はノードvの子であるe.dstを展開し終わってvに戻ってきたときなので、再度 path と depth に記録する\n\t\t\t\tpath[k] = v;\n\t\t\t\tdepth[k++] = d;\n\t\t\t}\n\t\t}\n\t}\n\n\tpair<int, int> range_min(int v, int w, int l, int r) const {\n\t\tif (r <= l || w == 0) return INF;\n\t\tif (r - l == w) return dat[v];\n\n\t\tint m = w / 2;\n\t\tauto rmin = range_min(v * 2, m, l, std::min(r, m));\n\t\tauto lmin = range_min(v * 2 + 1, m, std::max(0LL, l - m), r - m);\n\n\t\treturn min(rmin, lmin);\n\t}\n};\n\nvoid solve(){\n\n}\n\nvoid solve_TLE(ostringstream& aout, long long N, std::vector<long long> A) {\n\n}\n\nsigned main() {\n\tint n;\n\tcin >> n;\n\n\tGraph G(n);\n\n\trep(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tadd_edge(G, i, c);\n\t\t}\n\t}\n\n\tlca Lca(G, 0);\n\n\tint q;\n\tcin >> q;\n\n\trep(i, q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << Lca.get(u, v) << \"\\n\";\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 310;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<vector<int> > tree;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :n(tree.size()),tree(tree),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< vector< int > > graph;\n\nstruct CentroidPathDecomposition\n{\n  struct Centroid\n  {\n    int ParIndex, ParDepth, Deep;\n    vector< int > node;\n\n    inline int size()\n    {\n      return (node.size());\n    }\n\n    inline int& operator[](int k)\n    {\n      return (node[k]);\n    }\n\n    inline pair< int, int > Up()\n    {\n      return (make_pair(ParIndex, ParDepth));\n    }\n  };\n\n  vector< int > SubTreeSize, NextPath;\n  vector< int > TreeIndex, TreeDepth, depth;\n  vector< Centroid > Centroids;\n\n  void dfs(int idx, int par = -1)\n  {\n    if(~par) depth[idx] = depth[par] + 1;\n    for(auto& to : graph[idx]) {\n      if(to != par) dfs(to, idx);\n    }\n  }\n\n  void BuildSubTreeSize()\n  {\n    stack< pair< int, int > > s;\n    s.emplace(0, -1);\n\n    depth[0] = 0;\n    dfs(0);\n\n    while(!s.empty()) {\n      auto p = s.top();\n      if(~SubTreeSize[p.first]) {\n        if(~p.second) {\n          if(NextPath[p.second] == -1 || SubTreeSize[p.first] > SubTreeSize[NextPath[p.second]]) {\n            NextPath[p.second] = p.first;\n          }\n          SubTreeSize[p.second] += SubTreeSize[p.first];\n        }\n        s.pop();\n      } else {\n        SubTreeSize[p.first] = 1;\n        for(int& to : graph[p.first]) {\n          if(p.second != to) {\n            s.emplace(to, p.first);\n          }\n        }\n      }\n    }\n  }\n\n  void BuildPath()\n  {\n    stack< pair< int, int > > s;\n    Centroids.push_back((Centroid) {-1, -1, 0});\n    s.emplace(0, -1);\n    TreeIndex[0] = 0;\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      TreeDepth[p.first] = Centroids[TreeIndex[p.first]].size();\n      for(auto& to : graph[p.first]) {\n        if(p.second != to) {\n          if(to == NextPath[p.first]) {\n            TreeIndex[to] = TreeIndex[p.first];\n          } else {\n            TreeIndex[to] = Centroids.size();\n            Centroids.push_back(\n              (Centroid) {TreeIndex[p.first], TreeDepth[p.first], Centroids[TreeIndex[p.first]].Deep + 1});\n          }\n          s.emplace(to, p.first);\n        }\n      }\n      Centroids[TreeIndex[p.first]].node.push_back(p.first);\n    }\n  }\n\n  void AddEdge(int x, int y)\n  {\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n\n  void Build()\n  {\n    BuildSubTreeSize();\n    BuildPath();\n  }\n\n  inline int size()\n  {\n    return (Centroids.size());\n  }\n\n  inline pair< int, int > Information(int idx)\n  {\n    return (make_pair(TreeIndex[idx], TreeDepth[idx]));\n  }\n\n  inline Centroid& operator[](int k)\n  {\n    return (Centroids[k]);\n  }\n\n  inline int LCA(int a, int b) // ??????????????¨??????\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    return (Centroids[TreeIdxA][TreeDepthA]);\n  }\n\n  CentroidPathDecomposition(int SZ)\n  {\n    graph.resize(SZ);\n    SubTreeSize.resize(SZ, -1);\n    NextPath.resize(SZ, -1);\n    TreeIndex.resize(SZ);\n    TreeDepth.resize(SZ);\n    depth.resize(SZ);\n  }\n\n  int getDist(int a, int b);\n};\n\nint CentroidPathDecomposition::getDist(int a, int b)\n{\n  return (depth[a] + depth[b] - 2 * depth[LCA(a, b)]);\n}\n\nint main()\n{\n  int N, Q;\n  scanf(\"%d\", &N);\n  CentroidPathDecomposition tree(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      graph[i].push_back(c);\n    }\n  }\n  tree.Build();\n\n\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", tree.LCA(u, v));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    //cout << \"Path Count = \" << pathCount << \"\\n\";\n    len.resize(pathCount,vector<int>());\n    /*\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <complex>\n#include <stdlib.h>\n#include <stdio.h>\n#include <functional>\n#include <cfloat>\n#include <math.h>\n#include <numeric>\n#include <string.h>\n#include <sys/time.h>\n#include <random>\n\n\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\n\n\nclass Graph{\n    struct edge{\n        int vertice;\n        ll weight;\n    };\n\n    vector<vector<edge>> g;\n    unsigned int n;\n\npublic:\n    Graph(unsigned int n): n{n}{\n        g.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        g[u].emplace_back(edge{v, 1});\n    };\n\n    void add_edge(int u, int v, ll w){\n        g[u].emplace_back(edge{v, w});\n    }\n\n    vector<edge>& get_edge(int v){\n        return g[v];\n    }\n\n    unsigned int get_num_vertices(){\n        return n;\n    }\n\n    unsigned int size(){\n        return n;\n    }\n\n    vector<edge>& operator[](int v){\n        return get_edge(v);\n    }\n};\n\n\nclass LCA{\n    Graph g{0};\n    int root;\n    vector<vector<int>> parent;\n    vector<int> depth;\n    int n, log_n;\n\npublic:\n    LCA(Graph& g2){\n        g = g2;\n        n = g2.size();\n        root = 0;\n        log_n = 2;\n        int tmp_n = 1;\n        while(tmp_n < n){\n            tmp_n *= 2;\n            log_n++;\n        }\n        init(n);\n    }\n\n    LCA(Graph& g2, int root): root(root){\n        g = g2;\n        int n = g2.size();\n        init(n);\n    }\n\n    void dfs(int v, int p, int d){\n        parent[0][v] = p;\n        depth[v] = d;\n        for(auto u: g[v]){\n            if(u.vertice != p){\n                dfs(u.vertice, v, d+1);\n            }\n        }\n    }\n\n    void init(int n){\n        parent = vector<vector<int>>(log_n, vector<int>(n, 0));\n        depth = vector<int>(n, 0);\n\n        dfs(root, -1, 0);\n        for(int k = 0; k + 1 < log_n; k++){\n            for(int v = 0; v < n; v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    /**\n     *\n     * @param u\n     * @param v\n     * @return 頂点uと頂点vのLCA\n     */\n    int lca(int u, int v){\n        if(depth[u] > depth[v]){\n            swap(u, v);\n        }\n//        cout << u << \" \" << v << endl;\n\n        for(int k = 0; k < log_n; k++) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n        if(u == v){\n            return u;\n        }\n        for(int k = log_n-1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\n    int getDepth(int v){\n        return depth[v];\n    }\n\n};\n\n\nint main(){\n    uint n, q;   cin >> n;\n    Graph g{n};\n    for(int i = 0; i < n; i++){\n        int k;  cin >> k;\n        for(int j = 0; j < k; j++){\n            int c;  cin >> c;\n            g.add_edge(i, c);\n            g.add_edge(c, i);\n        }\n    }\n//    for(int i = 1; i < n; i++){\n//        int p;   cin >> p;\n//        g.add_edge(i, p);\n//        g.add_edge(p, i);\n//    }\n\n    LCA lca(g);\n    cin >> q;\n    for(int i = 0; i < q; i++){\n        int u, v;   cin >> u >> v;\n        cout << lca.lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ft first\n#define sd second\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nstruct tree{\n    size_t n,r,m,md;\n    vector<vector<int>> e;\n    vector<int> pa,d;\n    vector<vector<int>> lc;\n    explicit tree(int n_){\n        n=n_;\n        e.resize(n);\n    }\n    void add(int a,int b){\n        e[a].emplace_back(b);\n    }\n    void r_dfs(int i,int p=-1,int D=0){\n        pa[i]=p;d[i]=D;md=max(md,(size_t)D);++D;\n        for(auto j:e[i]) r_dfs(j,i,D);\n    }\n    void r_i(int r_){\n        pa.resize(n);d.resize(n);r=r_;md=0;\n        r_dfs(r);\n    }\n    void b_lca(int r_){\n        r_i(r_);\n        m=1;int c=1;\n        while(c<=md) ++m,c*=2;\n        lc.resize(n,vector<int>(m,-1));\n        fr(i,n) lc[i][0]=pa[i];\n        fr(i,n) fr(j,m-1) if(lc[i][j]!=-1) lc[i][j+1]=lc[lc[i][j]][j];\n    }\n    int lca(int a,int b){\n        if(a==b) return a;\n        if(d[a]>d[b]) swap(a,b);\n        if(d[a]!=d[b]) ifr(i,m) if((lc[b][i]!=-1)&&(d[a]<d[lc[b][i]])) b=lc[b][i];\n        if(d[a]!=d[b]) b=pa[b];\n        if(a==b) return a;\n        ifr(i,m) if(lc[a][i]!=lc[b][i]) a=lc[a][i],b=lc[b][i];\n        if(a!=b) a=pa[a];\n        return a;\n    }\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,k,c;\n    cin>>n;\n    tree t(n);\n    fr(i,n){\n        cin>>k;\n        fr(j,k) cin>>c,t.add(i,c);\n    }\n    t.b_lca(0);\n    cin>>n;\n    fr(_,n) cin>>k>>c,cout<<t.lca(k,c)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct edge{int to,cap,rev;};\n\nstruct node_t{\n\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n  edge *e;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL; lazy=0; update();\n  }\n   \n  inline void update(){\n    mini=val,minId=id;\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>=rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  inline void apply(int v){ lazy+=v, val+=v, mini+=v; }\n   \n  inline void push(){\n    if(lp)lp->apply(lazy);\n    if(rp)rp->apply(lazy);\n    lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  x->splay();\n  return x;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n}\n\nvoid link(node_t *c,node_t *p,int val,edge *e){\n  link(c,p);\n  c->val=val;\n  c->update();\n  c->e=e;\n}\n\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->apply(val); }\n\nnode_t *lowestCommonAncestor(node_t *x,node_t* y){\n  expose(x);\n  node_t *rp=NULL;\n  for(node_t *p=y;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  return rp;\n}\n\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << lowestCommonAncestor(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100001];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nint sub(int idx)\n{\n  sz[idx] = 1;\n  for(auto &to : g[idx]) sz[idx] += sub(to);\n  return (sz[idx]);\n}\n\nvoid dfs(int idx, bool keep)\n{\n  if(g[idx].empty()) {\n    if(keep) for(int &v : query[idx]) buf[v] = true;\n    return;\n  }\n\n  int heavy = g[idx][0];\n  for(auto &to : g[idx]) if(sz[to] > sz[heavy]) heavy = to;\n  for(auto &to : g[idx]) if(heavy != to) dfs(to, false);\n  dfs(heavy, true);\n  query[idx].swap(query[heavy]);\n\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(buf[v]) lca[v] = idx;\n    }\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      buf[v] = true;\n      query[idx].push_back(v);\n    }\n  }\n\n  if(!keep) {\n    for(auto &v : query[idx]) buf[v] = false;\n  }\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n\n  memset(lca, -1, sizeof(lca));\n\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n\n  sub(0);\n  dfs(0, false);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < N; i++) { sort(D[i].begin(), D[i].end()); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\tif (W == 0) { cout << \"0\" << endl; continue; }\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass LowestCommonAncestor\n{\nprivate:\n    vector<vector<int> > to; // ??????????????°\n    vector<int> depth;       // ??????????????±???\n    int climb(int curr, int dist)\n    {\n        int i = 0;\n        while(dist > 0){\n            if(dist % 2 == 1)\n                curr = to[curr][i];\n            dist /= 2;\n            ++ i;\n        }\n        return curr;\n    }\npublic:\n    LowestCommonAncestor(const vector<vector<int> >& edges, int root)\n    {\n        int n = edges.size();\n        to.assign(n, vector<int>());\n        depth.resize(n);\n\n        queue<pair<int, int> > q;\n        q.push(make_pair(root, -1));\n\n        int cnt = 0;\n        while(!q.empty()){\n            int m = q.size();\n            while(--m >= 0){\n                int curr, prev;\n                tie(curr, prev) = q.front();\n                q.pop();\n\n                depth[curr] = cnt;\n                if(prev != -1){\n                    to[curr].push_back(prev);\n                    int j = prev;\n                    for(unsigned k=0; k<to[j].size(); ++k){\n                        j = to[j][k];\n                        to[curr].push_back(j);\n                    }\n                }\n\n                for(int next : edges[curr]){\n                    if(next != prev)\n                        q.push(make_pair(next, curr));\n                }\n            }\n            ++ cnt;\n        }\n    }\n    // 2??????????????????????°???±????\\?????????????\n    int getAncestor(int a, int b)\n    {\n        int diff = depth[a] - depth[b];\n        if(diff < 0)\n            b = climb(b, -diff);\n        else\n            a = climb(a, diff);\n        if(a == b)\n            return a;\n\n        for(int i=to[a].size()-1; i>=0; --i){\n            if(i < (int)to[a].size() && to[a][i] != to[b][i]){\n                a = to[a][i];\n                b = to[b][i];\n            }\n        }\n        return to[a][0];\n    }\n    // ??????????????±????????????\n    int getDepth(int a)\n    {\n        return depth[a];\n    }\n    // 2???????????????????????¢?????????\n    int getDist(int a, int b)\n    {\n        int c = getAncestor(a, b);\n        return getDepth(a) + getDepth(b) - getDepth(c) * 2;\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int> > edges(n);\n    for(int i=0; i<n; ++i){\n        int k;\n        cin >> k;\n        while(--k >= 0){\n            int j;\n            cin >> j;\n            edges[i].push_back(j);\n            edges[j].push_back(i);\n        }\n    }\n\n    LowestCommonAncestor lca(edges, 0);\n\n    int q;\n    cin >> q;\n    while(--q >= 0){\n        int u, v;\n        cin >> u >> v;\n        cout << lca.getAncestor(u, v) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/*\n*/\nstruct LCA {\n    int v;\n    int root;\n    int h;\n    vector< vector< int > > parent;\n    vector< int > depth;\n    vector< vector< int > > g;\n    LCA(int v, int root) : v(v), root(root), depth(v, -1), g(v) {\n        h = 1;\n        while ((1 << h) < v) ++h;\n        parent.assign(h, vector< int >(v, -1));\n    }\n    void add_edge(int start, int to) {\n        g[start].push_back(to);\n    }\n    void build() {\n        dfs(root, -1, 0);\n        for (int i = 0; i + 1 < parent.size(); ++i) {\n            for (int j = 0; j < v; ++j) {\n                if (parent[i][j] != -1) parent[i + 1][j] = parent[i][parent[i][j]];\n            }\n        }\n    }\n    int get(int u, int v) {\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int i = 0; i < parent.size(); ++i) {\n            if ((depth[v] - depth[u]) & (1 << i)) v = parent[i][v];\n        }\n        if (u == v) return u;\n        for (int i = parent.size() - 1; i >= 0; --i) {\n            if (parent[i][u] != parent[i][v]) {\n                u = parent[i][u];\n                v = parent[i][v];\n            }\n        }\n        return parent[0][u];\n    }\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int e : g[v]) if (e != p) dfs(e, v, d + 1);\n    }\n};\n\n/*\n    verified https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_C\n*/\nint main() {\n    int n; cin >> n;\n    LCA lca(n, 0);\n    for (int i = 0; i < n; ++i) {\n        int k; cin >> k;\n        for (int j = 0; j < k; ++j) {\n            int c; cin >> c;\n            lca.add_edge(i, c);\n            lca.add_edge(c, i);\n        }\n    }\n    lca.build();\n    int q; cin >> q;\n    vector< int > ress;\n    for (int i = 0; i < q; ++i) {\n        int u, v; cin >> u >> v;\n        ress.push_back(lca.get(u, v));\n    }\n    for (int res : ress) cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nvector<int> G[100001];\nint N;\nint root;\nint MAX_LOG_V = 17;\nint POW[18];\n\nint** parent;\nint* depth;\n\nvoid dfs(int node_id,int parent_id,int d){\n\tparent[0][node_id] = parent_id;\n\tdepth[node_id] = d;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i] != parent_id)dfs(G[node_id][i],node_id,d+1);\n\t}\n}\n\nvoid init(){\n\n\tdfs(root,-1,0);\n\n\tfor(int k = 0; k + 1 < MAX_LOG_V; k++){\n\t\tfor(int node_id = 0; node_id < N; node_id++){\n\t\t\tif(parent[k][node_id] < 0)parent[k+1][node_id] = -1;\n\t\t\telse{\n\t\t\t\tparent[k+1][node_id] = parent[k][parent[k][node_id]];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint lca(int left,int right){\n\n\tif(depth[left] > depth[right])swap(left,right);\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(depth[right]-depth[left] >= POW[k]){\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\n\tif(left == right)return left;\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(parent[k][left] == parent[k][right]){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tleft = parent[k][left];\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\treturn parent[0][left];\n}\n\n\n\nint main(){\n\n\tfor(int i = 0; i <= 17; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d\",&N);\n\n\tint num,child;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&child);\n\t\t\tG[i].push_back(child);\n\t\t}\n\t}\n\n\tparent = new int*[MAX_LOG_V];\n\tfor(int i = 0; i < MAX_LOG_V;i++)parent[i] = new int[N];\n\tdepth = new int[N];\n\troot = 0;\n\tinit();\n\n\tint Q;\n\tscanf(\"%d\",&Q);\n\n\tint left,right;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\",&left,&right);\n\t\tprintf(\"%d\\n\",lca(left,right));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nclass UnionFind{\n\tint *parent,*rank,n;\npublic:\n\tint root(int a){return parent[a]==a?a:(parent[a]=root(parent[a]));}\n\tUnionFind(int _n){n=_n;parent=new int[n];rank=new int[n];for(int i=0;i<n;i++)parent[i]=i,rank[i]=0;}\n\t~UnionFind(){delete []parent;delete []rank;}\n\tint unionSet(int a,int b){\n\t\tint x=root(a),y=root(b);if(x==y)return 0;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t}else{\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\n//template<typename Data>\nclass HLDecomposition {\npublic:\n    //Data data;\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        //data = b;\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a,int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now,int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr,backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = (1 << 31) - 1, R = (1 << 31) - 1; //\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int long long\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int a = 0;\n    HLDecomposition hl(n);\n    REP(i, n) {\n        int k;\n        cin >> k;\n        REP(q, k) {\n            int a;\n            cin >> a;\n            hl.add_edge(i, a);\n        }\n    }\n    hl.build();\n    int query;\n    cin >> query;\n    REP(i, query) {\n        int a, b;\n        cin >> a >> b;\n        cout << hl.lca(a, b) << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n  LowestCommonAncestor() {}\n  LowestCommonAncestor(int V) : V(V) { init(); }\n  LowestCommonAncestor(int V, int root) : V(V), root(root) { init(); }\n\n  struct edge {\n    edge () {}\n    edge (int to, long long cost) : to(to), cost(cost) {}\n\n    int to;\n    long long cost;\n  };\n\n  const int MAX_LOG_V = 30;\n\n  int V, root = 0;\n  vector<vector<edge>> G;\n  vector<long long> depth, length;\n  vector<vector<int> > parent;\n\n\n  void init() {\n    G.resize(V);\n    depth.resize(V);\n    length.resize(V);\n    parent.resize(MAX_LOG_V, vector<int>(V));\n  }\n\n  void add_edge(int u, int v, long long c) {\n    G[u].push_back(edge(v, c));\n    G[v].push_back(edge(u, c));\n  }\n\n  void add_edge(int u, int v) {\n    add_edge(u, v, 1ll);\n  }\n\n  void dfs(int v, int u, int d, long long l){\n    depth[v] = d;\n    length[v] = l;\n    parent[0][v] = u;\n    for (edge e : G[v]) if (e.to != u) {\n      dfs(e.to, v, d + 1, l + e.cost);\n    }\n  }\n\n  void build() {\n    dfs(root, -1, 0, 0ll);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n      for (int v = 0; v < V; v++) {\n        if (parent[k][v] < 0) parent[k + 1][v] = -1;\n        else parent[k + 1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n\n    return parent[0][u];\n  }\n\n  long long dist(int u, int v) {\n    int z = lca(u, v);\n    return length[u] + length[v] - 2 * length[z];\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n\n  LowestCommonAncestor lca(n);\n\n  for (int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n\n    for (int j = 0; j < k; ++j) {\n      int u;\n      cin >> u;\n\n      lca.add_edge(i, u);\n    }\n  }\n\n  lca.build();\n\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\n#define MAX_N 100100\n#define MAX_LOG_N 20\nint N, root;\nvector<int> g[MAX_N];\nint depth[MAX_N];\nint par[MAX_N][MAX_LOG_N];\n\nvoid dfs(int v, int p, int d)\n{\n\tpar[v][0] = p;\n\tdepth[v] = d;\n\tfor (int i = 0; i < g[v].size(); i++)\n\t{\n\t\tif (g[v][i] == p)continue;\n\t\tdfs(g[v][i], v, d + 1);\n\t}\n}\n\nvoid fill_table()\n{\n\tfor (int i = 0; i < 19; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (par[j][i] == -1)par[j][i + 1] = -1;\n\t\t\telse par[j][i + 1] = par[par[j][i]][i];\n\t\t}\n\t}\n}\n\nint lca(int u, int v)\n{\n\tif (depth[u] > depth[v])swap(u, v);\n\tfor (int i = 19; i >= 0; i--)\n\t{\n\t\tif (((depth[v] - depth[u]) >> i) & 1)v = par[v][i];\n\t}\n\tif (u == v)return u;\n\tfor (int i = 19; i >= 0; i--)\n\t{\n\t\tif (par[u][i] != par[v][i])\n\t\t{\n\t\t\tu = par[u][i];\n\t\t\tv = par[v][i];\n\t\t}\n\t}\n\treturn par[u][0];\n}\n\nint main()\n{\n\tint q;\n\tcin >> N;\n\n\trep(i, N) {\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tg[i].push_back(c);\n\t\t}\n\t}\n\troot = 0;\n\tdfs(root, -1, 0);\n\tfill_table();\n\n\tcin >> q;\n\trep(i, q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca(u, v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, root, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int n_, int root_) : N(n_), root(root_), G(n_), depth(n_) {\n    logN = 0;\n    for(int x = 1; x < n_; x *= 2) logN++;\n    parent.assign(logN, vector<int>(n_));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init() {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      int pu = parent[k][u], pv = parent[k][v];\n      if(pu != pv) {\n        u = pu, v = pv;\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N, 0);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init();\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,-1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs=vector<int>(1,0)) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int,int>;\n    stack<T> st;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v,i;\n      tie(v,i) = st.top();\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tint res=0;\n\tfor(int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if (vid[u] > vid[v]) swap(u, v);\n      f(max(vid[head[v]], vid[u]), vid[v]);\n      if (head[u] != head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] != head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/11/07\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n/*\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned main(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/11/07\nhttps://yukicoder.me/problems/no/529\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<bitset>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i)=0;(i)<(n);(i)++)\n#define rep(i,j,n) for(ll (i)=(j);(i)<(n);(i)++)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define en '\\n'\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\nconst long long MOD = 1e9 + 7;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nconst int loose = 0;\nconst int tight = 1;\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//グラフ関連\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\t//深さを求める＋一個上の親を保存\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\t//LCA(最小共通祖先)をえる\n\tint get(int u, int v) {\n\t\t//頂点の深さをあわせるために、深さが浅い法を遡らせる\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\n\t\t//降順で親が一致しない場合は遡る\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\n\tint d(int u, int v) {\n\t\treturn depth[u] + depth[v] - 2 * depth[get(u, v)];\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tll n;\n\tcin >> n;\n\tGraph g(n);\n\n\tREP(i, n) {\n\t\tll k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tll c;\n\t\t\tcin >> c;\n\t\t\tadd_edge(g, i, c, 1, false, 0);\n\t\t}\n\t}\n\tlca lc(g, 0);\n\tll q;\n\tcin >> q;\n\twhile (q--) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tcout << lc.get(u, v) << en;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1000000000\n#define mod 1000000007\n#define debug(n,v) cout<<#v<<\":\";for(int i=0;i<n;i++)cout<<v[i]<<\" \";cout<<endl; \ntypedef long long ll;\nconst ll LINF = 1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\n\n//G : vector<vector<int>> ...\ntemplate<typename G>\nstruct DoublingLowestCommonAncestor{\n    const int LOG;\n    vector<int> dep;\n    const G &g;\n    vector<vector<int>> table;\n\n    //__builtin_clz:2進表記の際左側にいくつ0を埋めるか\n    //32bit intで111(2)なら返す値は29\n    DoublingLowestCommonAncestor(const G &g):g(g),dep(g.size()),LOG(32-__builtin_clz(g.size())){\n        table.assign(LOG,vector<int>(g.size(),-1));\n    }\n\n    void dfs(int idx,int par,int d){\n        table[0][idx]=par;\n        dep[idx]=d;\n        for(auto &to:g[idx]){\n            if(to!=par) dfs(to,idx,d+1);\n        }\n    }\n\n    void build(){\n        dfs(0,-1,0);\n        for(int k=0;k+1<LOG;k++){\n            for(int i=0;i<table[k].size();i++){\n                if(table[k][i]==-1) table[k+1][i]=-1;\n                else table[k+1][i]=table[k][table[k][i]];\n            }\n        }\n    }\n    int query(int u,int v){\n        //dep[u]>dep[v]として進める\n        if(dep[u]>dep[v]) swap(u,v);\n        //深さをそろえる\n        for(int i=LOG-1;i>=0;i--){\n            if(((dep[v]-dep[u])>>i)&1) v=table[i][v];\n        }\n        if(u==v) return u;\n        for(int i=LOG-1;i>=0;i--){\n            if(table[i][u]!=table[i][v]){\n                u=table[i][u];\n                v=table[i][v];\n            }\n        }\n        return table[0][u];\n    }\n};\n\nint main(){\n    int n;cin>>n;\n    vector<vector<int>> g(n);\n    rep(i,n){\n        int k;cin>>k;\n        rep(j,k){\n            int tmp;cin>>tmp;\n            g[i].push_back(tmp);\n            g[tmp].push_back(i);\n        }\n    }\n    DoublingLowestCommonAncestor< vector<vector<int>> > lca(g);\n    lca.build();\n    int q;cin>>q;vector<int> ans;\n    while(q--){\n        int u,v;cin>>u>>v;\n        ans.push_back(lca.query(u,v));\n    }\n    rep(i,ans.size()){cout<<ans[i]<<endl;}\n\n    // //debug\n    // cout<<endl;\n    // rep(i,lca.table.size()){\n    //     rep(j,lca.table[i].size()){\n    //         cout<<lca.table[i][j]<<\"  \";\n    //     }cout<<endl;\n    // }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <fstream>\n#include <unordered_map>\n\nusing namespace std;\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF (ll)1 << 60\n#define MINF (-1 * INF)\n#define ALL(n) n.begin(),n.end()\n#define MOD 1000000007\n#define P pair<ll, ll>\n\n\nstruct HLD {\n\tvector<ll> g[110000];\n\tvector<ll> sz, in, out, head, rev, par; //rev = in -> index\n\tHLD(ll n) : sz(n), in(n), out(n), head(n), rev(n), par(n) {};\n\tvoid dfs_sz(ll a, ll p) { \n\t\tpar[a] = p;\n\t\tsz[a] = 1;\n\t\tfor (auto& to : g[a]) {\n\t\t\tif (to == p)continue;\n\t\t\tdfs_sz(to, a);\n\t\t\tsz[a] += sz[to];\n\t\t\tif (sz[g[a][0]] < sz[to])swap(g[a][0], to);\n\t\t}\n\t}\n\tvoid dfs_hld(ll a, ll p, ll& t) {\n\t\tin[a] = t++;\n\t\trev[in[a]] = a;\n\t\tfor (auto& to : g[a]) {\n\t\t\tif (to == p)continue;\n\t\t\thead[to] = (g[a][0] == to ? head[a] : to);\n\t\t\tdfs_hld(to, a, t);\n\t\t}\n\t\tout[a] = t;\n\t}\n\tvoid edgeset(ll a, ll b) {\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvoid build() {\n\t\tdfs_sz(0, -1);\n\t\tll t = 0;\n\t\tdfs_hld(0, -1, t);\n\t}\n\tll la(ll a, ll x) {\n\t\twhile (1) {\n\t\t\tll h = head[a];\n\t\t\tif (in[a] - x >= in[h])return rev[in[a] - x];\n\t\t\ta = par[head[a]];\n\t\t\tx -= in[a] - in[h] + 1;\n\t\t}\n\t}\n\tll lca(ll a, ll b) { //a < b\n\t\tfor (;; b = par[head[b]]) {\n\t\t\tif (in[a] > in[b])swap(a, b);\n\t\t\tif (head[a] == head[b])return a;\n\t\t}\n\t}\n};\n\nint main() {\n\tll n;\n\tcin >> n;\n\tHLD tree(n);\n\tREP(i, n) {\n\t\tll k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tll a;\n\t\t\tcin >> a;\n\t\t\ttree.edgeset(i, a);\n\t\t}\n\t}\n\ttree.build();\n\tll q;\n\tcin >> q;\n\tREP(i, q) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tcout << tree.lca(a, b) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int from;\n    int to;\n    int weight;\n    Edge(int from, int to, int weight) : from(from), to(to), weight(weight) {\n    }\n    \n    int other(int u) {\n        return u == from ? to : from;\n    }\n};\n\nstruct LCA {\n    int n;\n    vector<vector<int>> g;\n    vector<Edge> edges;\n    vector<int> depth;\n    vector<int> parent;\n    vector<vector<int>> points;\n    \n    int height;\n    int logHeight;\n    \n    LCA(int n) : n(n) {\n        g.assign(n, vector<int>());\n        depth.assign(n, 0);\n        parent.assign(n, -1);\n    }\n    \n    void addEdge(int from, int to, int w) {\n        edges.push_back(Edge(from, to, w));\n        g[from].push_back(edges.size() - 1);\n        g[to].push_back(edges.size() - 1);\n    }\n    \n    void init(int root) {\n        dfs(root, -1, 0);\n        logHeight = (int) (log(height) / log(2)) + 1;\n        initJumpTable();\n    }\n     \n    void dfs(int u, int p, int d) {\n        height = max(height, d);\n        depth[u] = d;\n        parent[u] = p; \n        for (int e : g[u]) {\n            Edge edge = edges[e];\n            int v = edges[e].other(u);\n            if (v != p) {\n                dfs(v, u, d + 1);\n            }\n        }\n    }\n    \n    void initJumpTable() {\n        points.assign(n, vector<int>(logHeight, -1));\n        \n        for (int i = 0; i < n; i++) {\n            points[i][0] = parent[i];\n        }\n        for (int j = 1; j < logHeight; j++) {\n            for (int i = 0; i < n; i++) {\n                if (points[i][j - 1] != -1) {\n                    points[i][j] = points[points[i][j - 1]][j - 1];\n                }\n            }\n        }\n    }\n    \n    int lca(int p, int q) {\n        if (depth[p] < depth[q]) {\n            swap(p, q);\n        }\n\n        int logP = (int) (log(depth[p]) / log(2));\n\n        for (int i = logP; i >= 0; i--) {\n            if ((depth[p] - (1 << i)) >= depth[q]) {\n                p = points[p][i];\n            }\n        }\n\n        if (p == q) {\n            return p;\n        }\n\n        for (int i = logP; i >= 0; i--) {\n            if (points[p][i] != -1 && points[q][i] != points[p][i]) {\n                p = points[p][i];\n                q = points[q][i];\n            }\n        }\n        return parent[p];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    LCA d(n);\n    for (int i = 0; i < n; i++) {\n        int count;\n        cin >> count;\n        for (int j = 0; j < count; j++) {\n            int to;\n            cin >> to;\n            d.addEdge(i, to, 1);\n        }\n    }\n    d.init(0);\n    //cout << \"continue\" << endl; \n    int q;\n    cin >> q;\n    //cout << \"num of q \" << q << endl;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << d.lca(u, v) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nvector<int> G[100001];\nint N;\nint root;\nint MAX_LOG_V = 17;\nint POW[18];\n\nint** parent;\nint* depth;\n\nvoid dfs(int node_id,int parent_id,int d){\n\tparent[0][node_id] = parent_id;\n\tdepth[node_id] = d;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i] != parent_id)dfs(G[node_id][i],node_id,d+1);\n\t}\n}\n\nvoid init(){\n\n\tdfs(root,-1,0);\n\n\tfor(int k = 0; k + 1 < MAX_LOG_V; k++){\n\t\tfor(int node_id = 0; node_id < N; node_id++){\n\t\t\tif(parent[k][node_id] < 0)parent[k+1][node_id] = -1;\n\t\t\telse{\n\t\t\t\tparent[k+1][node_id] = parent[k][parent[k][node_id]];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint lca(int left,int right){\n\n\tif(depth[left] > depth[right])swap(left,right);\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(depth[right]-depth[left] >= POW[k]){\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\n\tif(left == right)return left;\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(parent[k][left] != parent[k][right]){\n\t\t\tleft = parent[k][left];\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\treturn parent[0][left];\n}\n\n\n\nint main(){\n\n\tfor(int i = 0; i <= 17; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d\",&N);\n\n\tint num,child;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&child);\n\t\t\tG[i].push_back(child);\n\t\t}\n\t}\n\n\tparent = new int*[MAX_LOG_V];\n\tfor(int i = 0; i < MAX_LOG_V;i++)parent[i] = new int[N];\n\tdepth = new int[N];\n\troot = 0;\n\tinit();\n\n\tint Q;\n\tscanf(\"%d\",&Q);\n\n\tint left,right;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\",&left,&right);\n\t\tprintf(\"%d\\n\",lca(left,right));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX=1<<17;\n\nvector<int> G[MAX];\nint root;\nint V;\n\nint vs[MAX*2-1];\nint depth[MAX*2-1];\nint id[MAX];\n\nint n;\nint dat[MAX*4-1];//0-indexed\n\nvoid rmq_init(int V)\n{\n\tn=1;\n\twhile(n<V)n<<=1;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=-1;\n\treturn;\n}\n\nvoid update(int k,int a)\n{\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0)\n\t{\n\t\tk=(k-1)/2;\n\t\tint b1=dat[k*2+1],b2=dat[k*2+2];\n\t\tif(b1!=-1&&b2!=-1)dat[k]=(depth[b1]<=depth[b2]?b1:b2);\n\t\telse if(b2!=-1)dat[k]=b2;\n\t\telse dat[k]=b1;\n\t}\n\treturn;\n}\n\nint getmin(int a,int b,int k,int l,int r)//[a,b),vertex-number(0),k's range[l,r)\n{\n\tif(r<=a||b<=l)return -1;\n\t\n\tif(a<=l&&r<=b)return dat[k];\n\telse\n\t{\n\t\tint vl=getmin(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=getmin(a,b,k*2+2,(l+r)/2,r);\n\t\tif(vl!=-1&&vr!=-1)return (depth[vl]<=depth[vr]?vl:vr);\n\t\telse if(vr!=-1)return vr;\n\t\telse return vl;\n\t}\n}\n\nvoid dfs(int v,int p,int d,int &k)\n{\n\tid[v]=k;\n\tvs[k]=v;\n\tdepth[k]=d;\n\tk++;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tif(G[v][i]!=p)\n\t\t{\n\t\t\tdfs(G[v][i],v,d+1,k);\n\t\t\tvs[k]=v;\n\t\t\tdepth[k]=d;\n\t\t\tk++;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid init()\n{\n\tint k=0;\n\troot=0;\n\tdfs(root,-1,0,k);\n\trmq_init(V*2-1);\n\tfor(int i=0;i<V*2-1;i++)update(i,i);\n\treturn;\n}\n\nint lca(int u,int v)\n{\n\tif(id[u]>id[v])swap(u,v);\n\treturn vs[getmin(id[u],id[v]+1,0,0,n)];\n}\n\nint main()\n{\n\tcin>>V;\n\tint k,c;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tcin>>c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin>>q;\n\tint u,v;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tcout<<lca(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 310;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010/B];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass SparseTable{\nprivate:\n    int N;\n    int H;\n    vector<vector<int>> data;\n    vector<int> rdata;\n    \npublic:\n    SparseTable(vector<int> rdata): rdata(rdata){\n        N = rdata.size();\n        H = log2(N);\n        \n        data.resize(H+1);\n        for(int i=0; i<N; i++){\n            data[0].push_back(i);\n        }\n        int l = 1;\n        for(int h=1; h<=H; h++){\n            for(int i=0; i+l*2<=N; i++){\n                int idx = -1;\n                if(rdata[data[h-1][i]] < rdata[data[h-1][i+l]])\n                    idx = data[h-1][i];\n                else\n                    idx = data[h-1][i+l];\n                data[h].push_back(idx);\n            }\n            l <<= 1;\n        }\n    }\n    int find(int a, int b){\n        int h = log2(b-a);\n        if(rdata[data[h][a]] < rdata[data[h][b-(1<<h)]])\n            return data[h][a];\n        else\n            return data[h][b-(1<<h)];\n    }\n};\n\nvoid euler_tour(vector<vector<int>> &G, int u, int d, vector<int> &tour, vector<int> &depth){\n    tour.push_back(u);\n    depth.push_back(d);\n    for(auto v: G[u]){\n        euler_tour(G, v, d+1, tour, depth);\n        tour.push_back(u);\n        depth.push_back(d);\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    \n    for(int i=0; i<N; i++){\n        int k; cin >> k;\n        for(int j=0; j<k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    \n    vector<int> tour, depth;\n    euler_tour(G, 0, 0, tour, depth);\n    vector<int> rightmsot(N);\n    for(int i=0; i<tour.size(); i++)\n        rightmsot[tour[i]] = i;\n    \n    SparseTable st(tour);\n    \n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++){\n        int u, v; cin >> u >> v;\n        int ru = rightmsot[u], rv = rightmsot[v];\n        if(ru > rv)\n            swap(ru, rv);\n//        rv++;\n        int d = st.find(ru, rv);\n        cout << depth[d] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing cost_t=int;\n\nstruct Edge {\n    int from, to;\n    cost_t cost;\n    Edge(int from, int to, cost_t cost) : from(from), to(to), cost(cost) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nstruct LCA{\n    static const int LOGN=20;\n    array<vector<int>,LOGN+1> par;\n    vector<int> dep;\n    void dfs(int v,int pre,Graph& g){\n        for(auto& e:g[v]){\n            if(e.to==pre) continue;\n            par[0][e.to]=v;\n            dep[e.to]=dep[v]+1;\n            dfs(e.to,v,g);\n        }\n    }\n\n    LCA(Graph& g,int root):dep(g.size()){\n        int n=g.size();\n        for(int i=0;i<=LOGN;i++) par[i].assign(n,-1);\n        dep[root]=0;\n        par[0][root]=root;\n        dfs(root,-1,g);\n        for(int i=0;i<LOGN;i++){\n            for(int j=0;j<n;j++){\n                par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n\n    int query(int u,int v){\n        if(dep[u]<dep[v]) swap(u,v);\n        int d = dep[u]-dep[v];\n        for(int i=LOGN;i>=0;i--){\n            if((d>>i)&1){\n                u = par[i][u];\n                d-=(1<<i);\n            }\n        }\n        if(u==v) return u;\n        for(int i=LOGN;i>=0;i--){\n            if(par[i][u]!=par[i][v]) u=par[i][u],v=par[i][v];\n        }\n        return par[0][u];\n    }\n};\n\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        while(k--){\n            int v; cin>>v;\n            g[i].push_back(Edge(i,v,0));\n            g[v].push_back(Edge(v,i,0));\n        }\n    }\n    LCA lca(g,0);\n    int q;\n    cin>>q;\n    while(q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<lca.query(u,v)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n  vector<vector<int> > len,tree;\n\n  HeavyLight(int n,vector<vector<int> > t)\n    :pathCount(0),n(n),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n),tree(t){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(n,tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint n, q;\n\nbool f[100100];\n\nstruct LCA {\n\tint s;\n\tvector<int> G[100100];//????????°??????\n\tint p[30][100100];\n\tint depth[100100] = {};\n\n\tvoid init() {\n\t\tREP(i, 30) {\n\t\t\tREP(j, 100100)p[i][j] = -1;\n\t\t}\n\t}\n\tvoid dfs(int now,int d,int pre){\n\t\tif (pre != -1)p[0][now] = pre;\n\t\tdepth[now] = d;\n\t\tREP(i, G[now].size()) {\n\t\t\tdfs(G[now][i], d + 1, now);\n\t\t}\n\t}\n\tvoid make_p() {\n\t\tFOR(i, 1, 30) {\n\t\t\tREP(j, 100100) {\n\t\t\t\tp[i][j] = p[i - 1][p[i - 1][j]];\n\t\t\t}\n\t\t}\n\t}\n\tint query(int u, int v) {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int i = 30 - 1; i >= 0; i--) {\n\t\t\tint d = depth[v] - depth[u];\n\t\t\tif (d >= (1 << i)) v = p[i][v];\n\t\t}\n\t\tfor (int i = 30 - 1; i >= 0; i--) {\n\t\t\tif (p[i][u] != p[i][v]) {\n\t\t\t\tu = p[i][u];\n\t\t\t\tv = p[i][v];\n\t\t\t}\n\t\t}\n\t\treturn p[0][u];\n\t}\n};\n\nLCA lca;\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tf[c] = 1;\n\t\t\tlca.G[i].push_back(c);\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tif (!f[i]) {\n\t\t\tlca.s = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlca.init();\n\tlca.dfs(lca.s, 0, -1);\n\tlca.make_p(); \n\tcin >> q;\n\tREP(i, q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.query(u, v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 200;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010/B];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define numa(x,a) for(auto x: a)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define pf push_front\n#define sec second\n#define sz(x) ((int)(x).size())\n#define ALL( c ) (c).begin(), (c).end()\n#define gcd(a,b) __gcd(a,b)\n#define endl \"\\n\"\nusing namespace std;\ntemplate <int POS, class TUPLE> void deploy(std::ostream &os, const TUPLE &tuple){}\ntemplate <int POS, class TUPLE, class H, class ...Ts> void deploy(std::ostream &os, const TUPLE &t){ os << (POS == 0 ? \"\" : \", \") << get<POS>(t); deploy<POS + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> &mp){ int remain = mp.size(); os << \"{\"; for(auto e: mp) os << \"(\" << e.first << \" -> \" << e.second << \")\" << (--remain == 0 ? \"}\" : \", \"); return os; }\n#define DEBUG1(var0) { std::cerr << (#var0) << \"=\" << (var0) << endl; }\n#define DEBUG2(var0, var1) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG1(var1); }\n#define DEBUG3(var0, var1, var2) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG2(var1,var2); }\n#define DEBUG4(var0, var1, var2, var3) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG3(var1,var2,var3); }\ntypedef long long ll;\n\n/*\n//*********************************\n//O(n)のLCA\n#define MAX_V 100100\nvector <int> edge[MAX_V];\nint root;\nint parent[MAX_V];\nint depth[MAX_V];\nint V;\nvoid dfs(int v,int p,int d){\n  parent[v] = p;\n  depth[v] = d;\n  for(int i = 0;i < sz(edge[v]);i++){\n    if(edge[v][i] != p){\n      dfs(edge[v][i],v,d+1);\n    }\n  }\n}\n\nvoid init(){\n  //parentとdepthを初期化\n  dfs(root,-1,0);\n}\n\nint LCA(int u,int v){//uとvのLCAを求める\n  while(depth[u] > depth[v]){\n    u = parent[u];\n  }\n  while(depth[v] > depth[u]){\n    v = parent[v];\n  }\n  while(u != v){\n    u = parent[u];\n    v = parent[v];\n  }\n  return u;\n}\n//*********************************\n\n*/\n\n//*********************************\n//O(log n)アルゴリズム\n//O(nlogn)のメモリが必要\n#define MAX_V 100100\n#define MAX_LOG_V 32\nvector <int> edge[MAX_V];\nint root;\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\nint V;\n\nvoid dfs(int v,int p,int d){\n  parent[0][v] = p;\n  depth[v] = d;\n  for(int i = 0;i < edge[v].size();i++){\n    if(edge[v][i] != p){\n      dfs(edge[v][i],v,d+1);\n    }\n  }\n}\n\nvoid init(){\n  //parent[0]とrootを初期化\n  dfs(root,-1,0);\n  //parentを初期化する\n  for(int k = 0;k+1<MAX_LOG_V;k++){\n    for(int v = 0; v < V;v++){\n      if(parent[k][v] < 0){\n        parent[k+1][v] = -1;\n      }else{\n        parent[k+1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n}\n\nint LCA(int u,int v){\n  if(depth[u] > depth[v]){\n    swap(u,v);\n  }\n  \n  for(int k = 0; k < MAX_LOG_V;k++){\n    if((depth[v]-depth[u]) >> k & 1){\n      v = parent[k][v];\n    }\n  }\n  if(u == v){\n    return u;\n  }\n  for(int k = MAX_LOG_V-1;k >= 0;k--){\n    if(parent[k][u] != parent[k][v]){\n      u = parent[k][u];\n      v = parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\n//*********************************\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cin >> V;\n  rep(i,V){\n    int x;\n    cin >> x;\n    rep(j,x){\n      int y;\n      cin >> y;\n      edge[i].pb(y);\n    }\n  }\n  root = 0;\n  init();\n  int Q;\n  cin >> Q;\n  rep(i,Q){\n    int x,y;\n    cin >> x >> y;\n    cout << LCA(x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_V = 100010;\nconst int INF = 2147483647;\n\nint n;\nP v[2 * MAX_V - 1];\n\nvoid init(int _n){\n  n = 1;\n  while(n < _n) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(INF, INF);\n}\n\nvoid update(int k, P a){\n  k += n - 1;\n  v[k] = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = v[k * 2 + 1].first < v[k * 2 + 2].first ? v[k * 2 + 1] : v[k * 2 + 2];\n  }\n}\n\nP query(int a, int b, int k, int l, int r){\n  if(b <= l || a >= r) return P(INF, INF);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return min(vl, vr);\n}\n\nint V, root = 0, id[MAX_V], vs[MAX_V * 2 - 1], depth[MAX_V * 2 - 1];\nvector<int> G[MAX_V];\n\nvoid dfs(int v, int prev, int d, int &k){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  REP(i, G[v].size()){\n    if(G[v][i] != prev){\n      dfs(G[v][i], v, d + 1, k);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid lca_init(){\n  int k = 0;\n  dfs(root, -1, 0, k);\n  init(k + 1);\n  REP(i, k) update(i, P(depth[i], vs[i]));\n}\n\nint lca(int a, int b){\n  return query(min(id[a], id[b]), max(id[a], id[b]) + 1, 0, 0, n).second;\n}\n\n\nint main() {\n  cin >>V;\n  REP(i, V){\n    int k; cin >>k;\n    REP(j, k){\n      int c; cin >>c;\n      G[i].push_back(c);\n      G[c].push_back(i);\n    }\n  }\n  lca_init();\n  int Q; cin >>Q;\n  REP(q, Q){\n    int a, b; cin >>a >>b;\n    cout <<lca(a, b) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nvector<int> G[100001];\nint N;\nint root;\nint MAX_LOG_V = 17;\nint POW[18];\n\nint** parent;\nint* depth;\n\nvoid dfs(int node_id,int parent_id,int d){\n\tparent[0][node_id] = parent_id;\n\tdepth[node_id] = d;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i] != parent_id)dfs(G[node_id][i],node_id,d+1);\n\t}\n}\n\nvoid init(){\n\n\tdfs(root,-1,0);\n\n\tfor(int k = 0; k + 1 < MAX_LOG_V; k++){\n\t\tfor(int node_id = 0; node_id < N; node_id++){\n\t\t\tif(parent[k][node_id] < 0)parent[k+1][node_id] = -1;\n\t\t\telse{\n\t\t\t\tparent[k+1][node_id] = parent[k][parent[k][node_id]];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint lca(int left,int right){\n\n\tif(depth[left] > depth[right])swap(left,right);\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(depth[right]-depth[left] >= POW[k]){\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\n\tif(left == right)return left;\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(parent[k][left] != parent[k][right]){\n\t\t\tleft = parent[k][left];\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\treturn parent[0][left];\n}\n\n\n\nint main(){\n\n\tfor(int i = 0; i <= 17; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d\",&N);\n\n\tint num,child;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&child);\n\t\t\tG[i].push_back(child);\n\t\t}\n\t}\n\n\tparent = new int*[MAX_LOG_V];\n\tfor(int i = 0; i < MAX_LOG_V;i++)parent[i] = new int[N];\n\tdepth = new int[N];\n\troot = 0;\n\tinit();\n\n\tint Q;\n\tscanf(\"%d\",&Q);\n\n\tint left,right;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\",&left,&right);\n\t\tprintf(\"%d\\n\",lca(left,right));\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 17;\nvector<int> G[MAX_V];\n\nclass TREE {\n\n   public:\n      int parent[MAX_LOG_V][MAX_V];\n      int depth[MAX_V];\n\n      void dfs(int v, int p, int d) {\n         parent[0][v] = p;\n         depth[v] = d;\n         for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n         }\n      }\n\n      void init(int V, int root) {\n         dfs(root, -1, 0);\n         for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n            for (int v = 0; v < V; v++) {\n               if (parent[k][v] < 0) parent[k + 1][v] = -1;\n               else parent[k + 1][v] = parent[k][parent[k][v]];\n            }\n         }\n      }\n\n      int lca(int u, int v) {\n         if (depth[u] > depth[v]) swap(u, v);\n         for (int k = 0; k < MAX_LOG_V; k++) {\n            // if k th digit of depth[v] - depth[u] is 1\n            if ((depth[v] - depth[u]) >> k & 1) {\n               v = parent[k][v];\n            }\n         }\n         if (u == v) return u;\n         for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n               u = parent[k][u];\n               v = parent[k][v];\n            }\n         }\n         return parent[0][u];\n      }\n};\n\nint main() {\n   int N;\n   cin >> N;\n   int k;\n   for (int i = 0; i < N; i++) {\n      cin >> k;\n      int c;\n      for (int j = 0; j < k; j++) {\n         cin >> c;\n         G[i].push_back(c);\n         G[c].push_back(i);\n      }\n   }\n   TREE tree;\n   tree.init(N, 0);\n\n   int Q;\n   cin >> Q;\n   int u, v;\n   for (int q = 0; q < Q; q++) {\n      cin >> u >> v;\n      cout << tree.lca(u, v) << endl;\n   }\n\n\n   \n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing loop = int;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(loop (i)=(a);(i)<(n);++(i))\n#define eFOR(i,a,n) for(loop (i)=(a);(i)<=(n);++(i))\n#define rFOR(i,a,n) for(loop (i)=(n)-1;(i)>=(a);--(i))\n#define erFOR(i,a,n) for(loop (i)=(n);(i)>=(a);--(i))\n#define each(i, a) for(auto &i : a)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\n#define all(i) (i).begin(),(i).end()\n#define out(y,x) ((y) < 0 || h <= (y) || (x) < 0 || w <= (x))\n#define line cout << \"------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n//#define stop system(\"pause\") //comment out this on AOJ.\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& elemnt : v)is >> elemnt; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\n\ntemplate<class T> class segtree {\n    int n = 1;\n    vector<T> dat;\n    T def;\n\npublic:\n    segtree(){}\n    segtree(int _n, T _def) : def(_def) {\n        while (n < _n)n *= 2;\n        dat.resize(2 * n, def);\n    }\n    segtree(vector<T> a, T _def) : def(_def) {\n        int _n = a.size();\n        while (n < _n)n *= 2;\n        dat.resize(2 * n, def);\n        FOR(i, 0, _n)dat[i + n] = a[i];\n        rFOR(i, 1, n)dat[i] = fun(dat[2 * i], dat[2 * i + 1]);\n    }\n\n    T fun(T x, T y) { return min(x, y); }\n\n    void update(int i, T a) {\n        i += n;\n        chmin(dat[i], a);\n        while (i > 1) {\n            i /= 2;\n            dat[i] = fun(dat[2 * i], dat[2 * i + 1]);\n        }\n    }\n\n    T value(int l, int r) {\n        l += n, r += n;\n\n        T ret = def;\n        for (; l < r; l /= 2, r /= 2) {\n            if (l & 1) {\n                ret = fun(ret, dat[l]);\n                l++;\n            }\n            if (r & 1) {\n                --r;\n                ret = fun(ret, dat[r]);\n            }\n        }\n\n        return ret;\n    }\n\n    T operator[](int k) { return dat[k + n]; }\n};\n\nclass eulerlca {\n    int n, root;\n    VI first_visit, visit;\n    vector<pair<int, int>> depth;\n    vector<VI> g;\n    segtree<pair<int, int>> seg;\npublic:\n    eulerlca(vector<VI> _g, int _root) : g(_g), root(_root) {\n        n = g.size();\n        first_visit.resize(n, -1);\n        dfs(root, -1, 0);\n        seg = segtree<pair<int, int>>(depth, { INF,-1 });\n    }\n\n    void dfs(int now, int par, int dep) {\n        if (first_visit[now] == -1)first_visit[now] = visit.size();\n        depth.emplace_back(dep, now);\n        visit.push_back(now);\n        each(to, g[now]) {\n            if (to == par)continue;\n            dfs(to, now, dep + 1);\n            depth.emplace_back(dep, now);\n            visit.push_back(now);\n        }\n    }\n    int lca(int a, int b) {\n        if (first_visit[a] > first_visit[b])swap(a, b);\n        return seg.value(first_visit[a], first_visit[b] + 1).second;\n    }\n};\n\nint main() {\n    init();\n\n    int n; cin >> n;\n    vector<VI> g(n);\n    FOR(i, 0, n) {\n        int k; cin >> k;\n        FOR(j, 0, k) {\n            int c; cin >> c;\n            g[i].push_back(c);\n        }\n    }\n    eulerlca euler(g, 0);\n\n    int q; cin >> q;\n    while (q--) {\n        int a, b; cin >> a >> b;\n        cout << euler.lca(a, b) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<string>\n#include<map>\n#include<string.h>\n#include<complex>\n#include<math.h>\n#include<queue>\n#include <functional>\n#include<time.h>\n#include<iomanip>\n#include<cassert>\n#include<bitset>\n#include<sstream>\nusing namespace std;\ntypedef long long int llint;\ntypedef pair<int, int> pint;\ntypedef pair<llint, llint> pllint;\ntypedef vector<int> vint;\ntypedef vector<llint> vllint;\ntypedef vector<pint> vpint;\ntypedef vector<string> vstring;\ntypedef vector<pair<llint, llint>> vpllint;\ntypedef vector<vector<int>> vvint;\ntypedef vector<vector<llint>> vvllint;\ntypedef vector<vector<pint>> vvpint;\ntypedef vector<bool> vbool;\ntypedef vector<vbool> vvbool;\ntypedef vector<vpllint> vvpllint;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define drep(i,n) for(int i=n-1;0<=i;i--)\n#define yes(ans) if(ans)cout<<\"yes\"<<endl;else cout<<\"no\"<<endl;\n#define Yes(ans) if(ans)cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;\n#define YES(ans) if(ans)cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;\n#define POSSIBLE(ans) if(ans)cout<<\"POSSIBLE\"<<endl;else cout<<\"IMPOSSIBLE\"<<endl;\n#define Pi 3.1415926535897932384626\n#define mod llint(1e9+7)\n#define Inf 2147483647\n#define llInf 9223372036854775807\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define isin(n,i) 0<=i&&i<n\n\nclass UnionFind {\npublic:\n\t//親の番号を格納する。親だった場合は-(その集合のサイズ)\n\tvector<int> Parent;\n\n\t//作るときはParentの値を全て-1にする\n\t//こうすると全てバラバラになる\n\tUnionFind(int N) {\n\t\tParent = vector<int>(N, -1);\n\t}\n\n\t//Aがどのグループに属しているか調べる\n\tint root(int A) {\n\t\tif (Parent[A] < 0) return A;\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\n\t//自分のいるグループの頂点数を調べる\n\tint size(int A) {\n\t\treturn -Parent[root(A)];//親をとってきたい\n\t}\n\n\t//AとBをくっ付ける\n\tbool connect(int A, int B) {\n\t\t//AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B) {\n\t\t\t//すでにくっついてるからくっ付けない\n\t\t\treturn false;\n\t\t}\n\n\t\t//大きい方(A)に小さいほう(B)をくっ付けたい\n\t\t//大小が逆だったらひっくり返しちゃう。\n\t\tif (size(A) < size(B)) swap(A, B);\n\n\t\t//Aのサイズを更新する\n\t\tParent[A] += Parent[B];\n\t\t//Bの親をAに変更する\n\t\tParent[B] = A;\n\n\t\treturn true;\n\t}\n};\n\n//セグ木・0-indexed・非再帰・(大きさ・単位元・関数)で初期化\ntemplate<typename T>\nstruct SegTree {\n\t//比較関数の型\n\tusing F = function<T(T, T)>;\n\t//二分木を配列で表したもの\n\tvector<T>seg;\n\t//木の半分の大きさ\n\tint siz;\n\t//単位元\n\tconst T unit;\n\t//比較する関数\n\tconst F f;\n\n\t//大きさn、unit(単位元)、f(モノイド)でsegtreeを初期化する\n\tSegTree(int n, const T unit, const F f) : unit(unit), f(f) {\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t\tseg.assign(siz * 2 - 1, unit);\n\t\tsiz--;\n\t}\n\n\t//k番目にtを入力\n\tvoid set(int k, const T& t) {\n\t\tseg[k + siz] = t;\n\t}\n\n\t//fによって木を構築する\n\tvoid build() {\n\t\tfor (int i = siz - 1; 0 <= i; i--) {\n\t\t\tseg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n\t\t}\n\t}\n\n\tT operator[](const int i) {\n\t\treturn seg[i + siz];\n\t}\n\n\t//k番目をxに更新する\n\tvoid update(int k, T x) {\n\t\tk += siz;\n\t\tseg[k] = x;\n\t\twhile (0 < k) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tseg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\n\t//[a,b)について、fした結果を返す\n\t//半開区域のためa以上b未満の位置を指す\n\tT query(int a, int b) {\n\t\tT l = unit, r = unit;\n\t\tfor (a += siz, b += siz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (!(a & 1))l = f(seg[a++], l);\n\t\t\tif (!(b & 1))r = f(seg[--b], r);\n\t\t}\n\t\treturn f(l, r);\n\t}\n};\n\n//aとbの最大公約数を求めるよ\nlong long GCD(long long a, long long b) {\n\tif (b == 0) return a;\n\telse return GCD(b, a % b);\n}\n\n// 返り値: a と b の最大公約数\n// ax + by = gcd(a, b) を満たす (x, y) が格納される\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\n\n//nCrをmで割った余りを求める\nllint nCr(llint n, llint r, llint m) {\n\tllint ans = 1;\n\tfor (llint i = 0; i < r; i++) {\n\t\tans *= n - i;\n\t\tans %= m;\n\t}\n\tfor (llint i = 1; i <= r; i++) {\n\t\tans *= modinv(i, m);\n\t\tans %= m;\n\t}\n\treturn ans;\n}\n\n//aのb乗をmで割った余りを求める\nllint power(llint a, llint b, llint m) {\n\tif (b == 1)return a;\n\tif (b == 0)return 1;\n\tllint tmp = power(a, (llint)b / 2, m);\n\ttmp *= tmp;\n\ttmp %= m;\n\tif (b % 2 == 1) {\n\t\ttmp *= a;\n\t\ttmp %= m;\n\t}\n\treturn tmp;\n}\n\n//bitを表すsub,要素数を表すlength\nbool next_combination(llint& sub, int length) {\n\tllint x = sub & -sub, y = sub + x;\n\tsub = (((sub & ~y) / x) >> 1) | y;\n\treturn sub < (llint)(1 << (llint)length);\n}\n\nvoid Zalgorithm(string& s, vint& a) {\n\ta[0] = s.size();\n\tint i = 1, j = 0;\n\twhile (i < s.size()) {\n\t\twhile (i + j < s.size() && s[j] == s[i + j])j++;\n\t\ta[i] = j;\n\t\tif (j == 0) { i++; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < s.size() && a[k] + k < j) {\n\t\t\ta[i + k] += a[k]; k++;\n\t\t}\n\t\ti += k; j -= k;\n\t}\n\treturn;\n}\n\nvvint g;\nvpint ET;\nvint l, r;\n\nvoid dfs(int p, vbool& visited, int depth) {\n\tvisited[p] = true;\n\tr[p] = l[p] = ET.size();\n\tET.pb({ depth,p });\n\tfor (int next : g[p]) {\n\t\tdfs(next, visited, depth + 1);\n\t\tr[p] = ET.size();\n\t\tET.pb({ depth,p });\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tl.resize(n); r.resize(n);\n\trep(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tg[i].pb(x);\n\t\t}\n\t}\n\tvbool visited(n, false);\n\tdfs(0, visited, 0);\n\tSegTree<pint> Seg(ET.size(), { n,0 }, [](pint a, pint b) {if (a.first < b.first)return a; else return b; });\n\trep(i, ET.size()) {\n\t\tSeg.set(i, ET[i]);\n\t}\n\tSeg.build();\n\tint q;\n\tcin >> q;\n\tvint ans(q);\n\trep(i, q) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tans[i] = Seg.query(min(l[x], l[y]), max(r[x], r[y]) + 1).second;\n\t}\n\trep(i, q)cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\nstruct UnionFind{\n    vector<int> par,rank,ss;\n    int size;\n    UnionFind(int n):size(n){\n    \tpar=vector<int>(n);iota(ALL(par),0);\n        rank = vector<int>(n);ss=vector<int>(n,1);\n    }\n    int root(int x){ return par[x] = par[x] == x ? x: root(par[x]);}\n    bool same(int x,int y){ return root(x) == root(y);}\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x]>rank[y])swap(x,y);\n        par[x] = y;ss[y]+=ss[x];\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n    int getS(int x){ return ss[root(x)];}\n};\n\ntypedef vector<vector<int>> Graph;\nclass TarjanLCA{\npublic:\n\tGraph& g;vector<tuple<int,int,int>>& qs;\n\tUnionFind uf;\n\tvector<int> ancestor;vector<bool> passed;\n\tvector<vector<int>> uquery;\n\tTarjanLCA(Graph &g,int r,vector<tuple<int,int,int>>& qs):g(g),qs(qs),uf(UnionFind(g.size())){\n\t\tpassed=vector<bool>(g.size());ancestor=vector<int>(g.size());\n\t\tuquery=vector<vector<int>>(g.size());\n\t\tfor(int i:range(qs.size())){\n\t\t\tint u,v,res;tie(u,v,res)=qs[i];\n\t\t\tuquery[u].push_back(i);uquery[v].push_back(i);\n\t\t}\n\t\tvisit(-1,r);\n\t};\n\tvoid visit(int p,int s) {\n\t\tancestor[uf.root(s)] = s;\n\t\tfor(int t:g[s]) if(t != p) {\n\t\t\tvisit(s,t);\n\t\t\tuf.unite(s,t);\n\t\t\tancestor[uf.root(s)] = s;\n\t\t}\n\t\tpassed[s] = true;\n\t\tfor(int i : uquery[s]){\n\t\t\tint u,v,res;tie(u,v,res)=qs[i];\t\n\t\t\tint w = (u == s ? v : v == s ? u : -1);\n\t\t\tif (w >= 0 && passed[w])get<2>(qs[i]) = ancestor[uf.root(w)];\n\t\t}\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t);\n\t\t\t\tg[t].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint q;cin >>q;\n\t\tvector<tuple<int,int,int>> qs(q);\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tqs[i]=make_tuple(u,v,-1);\n\t\t}\n\n\t\tTarjanLCA lca(g,0,qs);\n\t\tREP(i,q)cout << get<2>(qs[i])<<endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 110;\n\nvector<vector<int>> G(MAX_V);\nint root;\n\nint parent[MAX_LOG_V][MAX_V]; // 親を2^k回辿って到達する頂点（根を通り過ぎる場合は-1）\nint depth[MAX_V];             // 根からの深さ\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i=0; i<G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d+1);\n    }\n}\n\nvoid init(int V){\n    dfs(root, -1, 0);\n    \n    for(int k=0; k+1<MAX_LOG_V; k++){\n        for(int v=0; v<V; v++){\n            if(parent[k][v] < 0) parent[k+1][v] = -1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    // uとvの深さが同じになるまで親を辿る\n    if(depth[u] > depth[v]) swap(u, v);\n\n    for(int k=0; k<MAX_LOG_V; k++){\n        if((depth[v] - depth[u]) >> k & 1){\n            v = parent[k][v];\n        }\n    }\n\n    if(u == v) return u;\n\n    for(int k=MAX_LOG_V-1; k>=0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    int n; cin>>n;\n    for(int i=0; i<n; i++){\n        int k; cin>>k;\n        for(int j=0; j<k; j++){\n            int c; cin>>c;\n            G[i].emplace_back(c);\n            G[c].emplace_back(i);\n        }\n    }\n\n    init(n);\n\n    int q; cin>>q;\n    while(q--){\n        int u, v; cin>>u>>v;\n        cout << lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define MAX_LOG_V 30\nusing namespace std;\nvector<int> G[MAX_V];  //??°???????????£??\\??????????????¨???\nint root;              //?????????????????????\n\nint parent[MAX_LOG_V][MAX_V];//??????2^k????????£?????°???????????????(???????????????????????´??????-1??¨??????)\nint depth[MAX_V];            //??????????????±???\n\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0;i<G[v].size();i++)\n    if(G[v][i] != p)dfs(G[v][i],v,d+1);\n}\n\n//?????????\nvoid init(int V){\n  //parent[0]??¨depth?????????????????????\n  dfs(root,-1,0);\n  //parent??????????????????\n  for(int k=0; k+1<MAX_LOG_V ;k++)\n    for(int v=0; v<V ;v++)\n      if(parent[k][v] < 0)parent[k+1][v] = -1;\n      else parent[k+1][v] = parent[k][parent[k][v]];\n}\n\n//u??¨v???LCA????±???????\nint lca(int u,int v){\n  //u??¨v?????±??????????????????????????§????????????\n  if(depth[u]>depth[v]) swap(u,v);\n  \n  for(int k=0; k<MAX_LOG_V ;k++)\n    if((depth[v]-depth[u])>>k&1)v=parent[k][v];\n  \n  if(u==v) return u;\n  //????????¢?´¢??§LCA????±???????\n  for(int k=MAX_LOG_V-1; k>=0 ;k--)\n    if(parent[k][u] != parent[k][v]){\n      u=parent[k][u];\n      v=parent[k][v];\n    }\n  return parent[0][u];\n}\n\nint main(){\n  root=0;\n  int V;\n  cin>>V;\n  for(int i=0;i<V;i++){\n    int k;\n    cin>>k;\n    for(int j=0,a;j<k;j++)cin>>a,G[i].push_back(a);\n  }\n  init(V);\n\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout << lca(u,v)<<endl;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\n\nstruct RootedTree {\n    RootedTree(int n, int root = 0) :\n            mRoot(root) {\n        mVertexTbl.resize(n);\n    }\n\n    void addEdge(int a, int b, long long int cost = 1) {\n        mVertexTbl[a].child.push_back(pair<int, long long int>(b, cost));\n        mVertexTbl[b].child.push_back(pair<int, long long int>(a, cost));\n    }\n\n    void build() {\n        queue<tuple<int, int, long long int>> q;\n        q.push(make_tuple(mRoot, -1, 0));\n        while (!q.empty()) {\n            auto t = q.front();\n            q.pop();\n            int index = get<0>(t);\n            int parent = get<1>(t);\n            long long int depth = get<2>(t);\n            mVertexTbl[index].parent = parent;\n            mVertexTbl[index].depth = depth;\n            for (auto it = mVertexTbl[index].child.begin(); it != mVertexTbl[index].child.end();) {\n                int nxt = (*it).first;\n                if (nxt == parent) {\n                    mVertexTbl[index].child.erase(it);\n                    continue;\n                }\n                q.push(make_tuple(nxt, index, depth + (*it).second));\n                ++it;\n            }\n        }\n\n        for (auto &v:mVertexTbl) {\n            for (int i = 0; i < Vertex::MAX; ++i) {\n                v.doubling[i] = -1;\n            }\n            v.doubling[0] = v.parent;\n        }\n\n        for (int d = 1; d < Vertex::MAX; ++d) {\n            for (auto &v:mVertexTbl) {\n                int p = v.doubling[d - 1];\n                if (p < 0)\n                    continue;\n                v.doubling[d] = mVertexTbl[p].doubling[d - 1];\n            }\n        }\n    }\n\n    int lca(int u, int v) {\n        if (mVertexTbl[u].depth < mVertexTbl[v].depth)\n            swap(u, v);\n        ll d = mVertexTbl[u].depth - mVertexTbl[v].depth;\n        for (int i = 0; i < Vertex::MAX; ++i) {\n            if ((d >> i) & 1)\n                u = mVertexTbl[u].doubling[i];\n        }\n\n        if (u == v)\n            return u;\n\n        for (int i = Vertex::MAX - 1; i >= 0; --i) {\n            if (mVertexTbl[u].doubling[i] == mVertexTbl[v].doubling[i])\n                continue;\n            u = mVertexTbl[u].doubling[i];\n            v = mVertexTbl[v].doubling[i];\n        }\n\n        return mVertexTbl[u].parent;\n    }\n\n    struct Vertex {\n        static const int MAX = 55;\n\n        vector<pair<int, long long int>> child;\n        long long int depth = 0;\n        int parent = -1;\n        int doubling[MAX];\n    };\n\n    int mRoot;\n    vector<Vertex> mVertexTbl;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N;\n    cin >> N;\n    RootedTree tree(N);\n    REP(i, N) {\n        ll k;\n        cin >> k;\n        REP(_, k) {\n            ll n;\n            cin >> n;\n            tree.addEdge(i, n, 1);\n        }\n    }\n\n    tree.build();\n    ll Q;\n    cin >> Q;\n    REP(_, Q) {\n        ll u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <vector>\n\nstruct HLDecomposition {\n  const int N;\n  std::vector<std::vector<int>> tree;\n  std::vector<int> cluster, par, depth, ord, head, offset;\n  HLDecomposition(int N) : N(N), tree(N), cluster(N, -1), par(N, -1), depth(N), ord(N), offset(N) {}\n\n  void add_edge(int u, int v) {\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n  void build(int root = 0) {\n    std::vector<int> Q;\n    Q.reserve(N);\n    Q.push_back(root);\n    for (int i = 0; i < N; i++) {\n      int u = Q[i];\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        par[v] = u;\n        depth[v] = depth[u] + 1;\n        Q.push_back(v);\n      }\n    }\n    std::vector<int> subtree_size(N, 1);\n    for (int i = N - 1; i > 0; i--) {\n      subtree_size[par[Q[i]]] += subtree_size[Q[i]];\n    }\n    std::vector<std::vector<int>> pathes;\n    for (int u : Q) {\n      if (cluster[u] == -1) {\n        cluster[u] = pathes.size();\n        pathes.emplace_back();\n      }\n      pathes[cluster[u]].push_back(u);\n      int max_subsize = -1, selected = -1;\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        if (max_subsize >= subtree_size[v]) continue;\n        max_subsize = subtree_size[v];\n        selected = v;\n      }\n      if (selected != -1) cluster[selected] = cluster[u];\n    }\n    int P = pathes.size();\n    head.resize(P + 1);\n    for (int p = 0; p < P; p++) {\n      int H = head[p];\n      int L = pathes[p].size();\n      head[p + 1] = H + L;\n      for (int i = 0; i < L; i++) {\n        int v = pathes[p][i];\n        offset[v] = i;\n        ord[H + i] = v;\n      }\n    }\n  }\n  void for_each(int u, int v, std::function<void(int, int)> f) const {\n    while (cluster[u] != cluster[v]) {\n      if (depth[ord[head[cluster[u]]]] > depth[ord[head[cluster[v]]]]) std::swap(u, v);\n      int h = head[cluster[v]];\n      f(h, h + offset[v] + 1);\n      v = par[ord[h]];\n    }\n    if (offset[u] > offset[v]) std::swap(u, v);\n    f(head[cluster[u]] + offset[u], head[cluster[v]] + offset[v] + 1);\n  }\n  int lca(int u, int v) const {\n    int x;\n    for_each(u, v, [&](int l, int r) { x = ord[l]; });\n    return x;\n  }\n  std::vector<std::vector<int>> build_pathes() const {\n    const int P = head.size() - 1;\n    std::vector<std::vector<int>> pathes(P);\n    for (int i = 0; i < P; i++) {\n      pathes[i].reserve(head[i + 1] - head[i]);\n      for (int j = head[i]; j < head[i + 1]; j++) {\n        pathes[i].push_back(ord[j]);\n      }\n    }\n    return pathes;\n  }\n};\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n// clang-format off\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}if(m)x=-x;return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n\nint main() {\n  int N = rd();\n  HLDecomposition hl(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    for (int j = 0; j < k; j++) {\n      hl.add_edge(i, rd());\n    }\n  }\n  hl.build();\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(hl.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\nusing namespace std;\n\nint Count;\nvoid dfs(int n,int dep,vector<vector<int>>& T,vector<P>& ET,vector<bool>& f,vector<int>& index) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(n,dep));\n\tindex[n] = Count; Count++;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1, T, ET, f,index);\n\t\tET.emplace_back(make_pair(n,dep));\n\t\tCount++;\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<int> index(n);\n\tvector<bool> f(n,false);\n\tvector<vector<int>> T(n);\n\tvector<P> ET;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\tdfs(0,0, T, ET, f,index);\n\tvector<int> V;\n\tfor (P i : ET) {\n\t\tV.emplace_back(i.second);\n\t}\n\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tauto minIt = min_element(V.begin() + index[u], V.begin() + index[v]);\n\t\tauto minIndex = distance(V.begin(), minIt);\n\t\tcout << ET[minIndex].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <climits>\n\nstruct euler_tour {\n\ttemplate<typename T>\n\tstruct segment_tree {\n\t\tlong long N;\t\t\t\t// the size of V\n\t\tlong long M;\t\t\t\t// the number of leaves\n\t\tstd::vector<T> V;\t\t\t// 1-indexed\n\t\tstd::function<T(T, T)> OP;\t// binary operation\n\t\tT ID;\t\t\t\t\t\t// identity element of OP\n\n\t\tsegment_tree() {}\n\n\t\tvoid init(std::vector<T>& a, std::function<T(T, T)> f, T t) {\n\t\t\tOP = f; ID = t;\n\t\t\tM = 1;\n\t\t\twhile (M < a.size()) M *= 2;\n\t\t\tN = 2 * M;\n\t\t\tV.resize(N, ID);\n\t\t\tfor (long long i = 0; i < a.size(); i++) V[M + i] = a[i];\n\t\t\tfor (long long i = a.size(); i < M; i++) V[M + i] = ID;\n\t\t\tfor (long long i = M - 1; i > 0; i--) {\n\t\t\t\tV[i] = OP(V[2 * i], V[2 * i + 1]);\n\t\t\t}\n\t\t}\n\n\t\tvoid point_update(long long i, T x) {\n\t\t\ti += M;\n\t\t\tV[i] = x;\n\t\t\twhile (i / 2 < i) {\n\t\t\t\ti /= 2;\n\t\t\t\tV[i] = OP(V[2 * i], V[2 * i + 1]);\n\t\t\t}\n\t\t}\n\n\t\tT range_subfunc(\n\t\t\tlong long cur_node, long long cur_left, long long cur_right,\n\t\t\tlong long l, long long r\n\t\t) {\n\t\t\tif (cur_right <= l || r <= cur_left) return ID;\n\t\t\tif (l <= cur_left && cur_right <= r) return V[cur_node];\n\t\t\tlong long mid = (cur_left + cur_right) / 2;\n\t\t\treturn OP(\n\t\t\t\trange_subfunc(cur_node * 2, cur_left, mid, l, r),\n\t\t\t\trange_subfunc(cur_node * 2 + 1, mid, cur_right, l, r)\n\t\t\t);\n\t\t}\n\n\t\tT range_fold(long long l, long long r) {\n\t\t\treturn range_subfunc(1, 0, M, l, r);\n\t\t}\n\t};\n\n\tusing P = std::pair<long long, long long>;\n\tlong long N;\n\tlong long R;\n\tstd::vector<std::vector<long long>> adj_list;\n\tstd::vector<P> dfs_order;\n\tstd::vector<P> LR;\n\tsegment_tree<P> sg;\n\n\teuler_tour(\n\t\tlong long R,\n\t\tstd::vector<std::vector<long long>>& adj_list\n\t) : R(R), adj_list(adj_list) {\n\t\tN = adj_list.size();\n\t\tdfs(-1, R, 0);\n\t\tLR.resize(N, {-1, -1});\n\t\tfor (long long i = 0; i < 2 * N - 1; i++) {\n\t\t\tif (LR[dfs_order[i].second].first == -1) {\n\t\t\t\tLR[dfs_order[i].second].first = i;\n\t\t\t}\n\t\t\tLR[dfs_order[i].second].second = i;\n\t\t}\n\t\tauto f = [] (P x, P y) {return std::min(x, y);};\n\t\tsg.init(dfs_order, f, {LLONG_MAX, LLONG_MAX});\n\t}\n\n\tvoid dfs(long long parent, long long current, long long depth) {\n\t\tif (current && adj_list[current].size() == 1) {\n\t\t\tdfs_order.push_back({depth, current});\n\t\t\treturn;\n\t\t}\n\t\tfor (auto i : adj_list[current]) {\n\t\t\tif (i == parent) continue;\n\t\t\tdfs_order.push_back({depth, current});\n\t\t\tdfs(current, i, depth + 1);\n\t\t}\n\t\tdfs_order.push_back({depth, current});\n\t}\n\n\t// return {LCA, distance}\n\tP lca(long long i, long long j) {\n\t\tlong long l = std::min(LR[i].first, LR[j].first);\n\t\tlong long r = std::max(LR[i].second, LR[j].second) + 1;\n\t\tP x = sg.range_fold(l, r);\n\t\tlong long dist = dfs_order[l].first + dfs_order[r].first - 2 * x.first;\n\t\treturn {x.second, dist};\n\t}\n};\n\nint main() {\n\tlong long n;\n\tstd::cin >> n;\n\tstd::vector<std::vector<long long>> adj_list(n);\n\tfor (long long i = 0; i < n; i++) {\n\t\tlong long k;\n\t\tstd::cin >> k;\n\t\twhile (k--) {\n\t\t\tlong long c;\n\t\t\tstd::cin >> c;\n\t\t\tadj_list[i].push_back(c);\n\t\t\tadj_list[c].push_back(i);\n\t\t}\n\t}\n\teuler_tour et(0, adj_list);\n\tlong long q;\n\tstd::cin >> q;\n\twhile (q--) {\n\t\tlong long u, v;\n\t\tstd::cin >> u >> v;\n\t\tstd::cout << et.lca(u, v).first << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  //{{{\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) std::cerr << #x << ':' << x << '\\n';\n\ntypedef long long ll;\n// clang-format off\ntemplate<typename T,typename U>inline bool chmax(T&x,U a){if(x>=a)return 0;x=a;return 1;}\ntemplate<typename T,typename U>inline bool chmin(T&x,U a){if(x<=a)return 0;x=a;return 1;}\ninline int in(){int x;scanf(\"%d\", &x);return x;}\n// clang-format on\n// }}}\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\n#include <climits>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  using weight_type = int;\n  static constexpr weight_type INF =\n      std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\nusing Weight = Edge::weight_type;\nusing Edges = std::vector<Edge>;\nusing Weights = std::vector<Weight>;\nusing Path = std::vector<int>;\n}\nusing Graph = std::vector<graph::Edges>;\n}\n#endif\n//}}}\n//{{{ hl_decomposition.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n\nnamespace orliv {\nnamespace graph {\n\nstruct HLDecomposition {\n  const Graph& g;\n  const int V;\n  std::vector<int> par, ord, depth;\n  std::vector<int> cluster;\n  std::vector<Path> pathes;\n  std::vector<int> path_idx;\n\n  HLDecomposition(const Graph& g) : g(g), V(g.size()) {}\n\n  void build(int root = 0) {\n    ord.clear();\n    ord.reserve(V);\n    pathes.clear();\n    par.assign(V, 0);\n    depth.assign(V, 0);\n\n    ord.emplace_back(root);\n    par[root] = -1;\n    for (int i = 0; i < ord.size(); i++) {\n      int u = ord[i];\n      for (const auto& e : g[u]) {\n        int v = e.to;\n        if (par[u] == v) continue;\n        par[v] = u;\n        depth[v] = depth[u] + 1;\n        ord.emplace_back(v);\n      }\n    }\n    decomposition();\n  }\n  int lca(int u, int v) const {\n    while (cluster[u] != cluster[v]) {\n      int head_u = pathes[cluster[u]][0];\n      int head_v = pathes[cluster[v]][0];\n      if (depth[head_u] > depth[head_v]) {\n        std::swap(u, v);\n        std::swap(head_v, head_u);\n      }\n      v = par[head_v];\n    }\n    return depth[u] < depth[v] ? u : v;\n  }\n\n private:\n  void decomposition() {\n    std::vector<int> subtree_size(V, 1);\n    for (int i = V - 1; i > 0; i--) {\n      subtree_size[par[ord[i]]] += subtree_size[ord[i]];\n    }\n    cluster.assign(V, -1);\n    for (int u : ord) {\n      if (cluster[u] == -1) {\n        cluster[u] = pathes.size();\n        pathes.emplace_back();\n      }\n      pathes[cluster[u]].emplace_back(u);\n\n      int max_subsize = -1, selected = -1;\n      for (const auto& e : g[u]) {\n        int v = e.to;\n        if (par[u] == v) continue;\n        if (max_subsize >= subtree_size[v]) continue;\n        max_subsize = subtree_size[v];\n        selected = v;\n      }\n      if (selected != -1) cluster[selected] = cluster[u];\n    }\n    path_idx.resize(V);\n    for (const auto& path : pathes) {\n      for (int i = 0; i < path.size(); i++) path_idx[path[i]] = i;\n    }\n  }\n};\n}\n}\n//}}}\n\nusing namespace std;\n\nint main() {\n  int N = in();\n  orliv::Graph g(N);\n  for (int i = 0; i < N; i++) {\n    int k = in();\n    for (int j = 0; j < k; j++) {\n      int c = in();\n      g[i].emplace_back(i, c);\n      g[c].emplace_back(c, i);\n    }\n  }\n  orliv::graph::HLDecomposition hl(g);\n  hl.build(0);\n  int q = in();\n  for (int i = 0; i < q; i++) {\n    int u = in(), v = in();\n    cout << hl.lca(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nclass LCA{\n\tpublic:\n\tint N,root,max_log;\n\tvvi G,parent;\n\tvi depth;\n\tLCA(int size){\n\t\tN=size;\n\t\tG=vvi(size);\n\t\tmax_log=20;\n\t\tdepth=vi(size);\n\t\tparent=vvi(max_log,vi(size));\n\t}\n\tvoid add_edge(int a,int b){\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tvoid dfs(int v,int p,int d){\n\t\tparent[0][v]=p;\n\t\tdepth[v]=d;\n\t\trep(i,G[v].size())if(G[v][i]!=p)dfs(G[v][i],v,d+1);\n\t}\n\tvoid init(){\n\t\troot=0;\n\t\tdfs(root,-1,0);\n\t\tfor(int k=0;k+1<max_log;k++){//doubling\n\t\t\tfor(int v=0;v<N;v++){\n\t\t\t\tif(parent[k][v]<0)parent[k+1][v]=-1;\n\t\t\t\telse parent[k+1][v]=parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u,int v){\n\t\tif(depth[u]>depth[v])swap(u,v);\n\t\trep(k,max_log)if((depth[v]-depth[u])>>k&1)v=parent[k][v];\n\t\tif(u==v)return u;\n\t\tfor(int k=max_log-1;k>=0;k--){\n\t\t\tif(parent[k][u]!=parent[k][v]){\n\t\t\t\tu=parent[k][u];\n\t\t\t\tv=parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nint main(){\n\tint n;\n\tcin>>n;\n\tLCA lca(n);\n\trep(i,n){\n\t\n\t\tint k;\n\t\tcin>>k;\n\t\trep(j,k){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tlca.add_edge(i,a);\n\t\t}\n\t}\n\tlca.init();\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tint k=lca.lca(a,b);\n\t\tcout<<k<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\ntemplate<class T>\nstruct lca {\n    int n, root, l;\n    vector<vector<int> > to, par;\n    vector<vector<T> > co;\n    vector<int> dep;\n    vector<T> costs;\n    lca(int n):n(n), to(n), co(n), dep(n), costs(n) {\n        l = 0;\n        while((1<<l) < n) ++l;\n        par = vector<vector<int> >(n+1, vector<int>(l, n));\n    }\n    void add(int a, int b, T c=0) {\n        to[a].push_back(b); co[a].push_back(c);\n        to[b].push_back(a); co[b].push_back(c);\n    }\n    void dfs(int v, int d=0, T c=0, int p=-1) {\n        if(p != -1) par[v][0] = p;\n        dep[v] = d;\n        costs[v] = c;\n        for(int i = 0; i < to[v].size(); ++i) {\n            int u = to[v][i];\n            if(u == p) continue;\n            dfs(u, d+1, c+co[v][i], v);\n        }\n    }\n    void init(int _root=0) {\n        root = _root;\n        dfs(root);\n        for(int i = 0; i < l-1; ++i) {\n            for(int v = 0; v < n; ++v) {\n                par[v][i+1] = par[par[v][i]][i];\n            }\n        }\n    }\n    int lca_(int a, int b) {\n        if(dep[a] > dep[b]) swap(a, b);\n        int gap = dep[b]-dep[a];\n        for(int i = l-1; i >= 0; --i) {\n            int len = 1<<i;\n            if(gap >= len) {\n                gap -= len;\n                b = par[b][i];\n            }\n        }\n        if(a == b) return a;\n        for(int i = l-1; i >= 0; --i) {\n            int na = par[a][i];\n            int nb = par[b][i];\n            if(na != nb) {\n                a = na;\n                b = nb;\n            }\n        }\n        return par[a][0];\n    }\n    int length(int a, int b) {\n        int c = lca_(a, b);\n        return dep[a]+dep[b]-dep[c]*2;\n    }\n    T dist(int a, int b) {\n        int c = lca_(a, b);\n        return costs[a]+costs[b]-costs[c]*2;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    lca<int> C(n);\n    rep(i, n) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int c;\n            cin >> c;\n            C.add(i, c);\n        }\n    }\n    C.init();\n\n    int q;\n    cin >> q;\n    while(q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << C.lca_(u, v) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rrep(i,x) for(int i=(int)x-1;i>=0;--i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\ninline int in(){int a;scanf(\"%d\",&a);return a;}\ninline ll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvi G[100010];\n\nint depth[100010];\nint par[100010][22];\n\nvoid lca_dfs(int v, int p, int d)\n{\n    depth[v] = d;\n    par[v][0] = p;\n\n    for (int ch : G[v]) {\n        if (ch == p) continue;\n        lca_dfs(ch, v, d + 1);\n    }\n}\n\nvoid lca_init(int root = 0)\n{\n    lca_dfs(root, -1, 0);\n\n    rep(i, 20) {\n        rep(j, 100010) {\n            par[j][i + 1] = par[j][i] == -1 ? -1 : par[par[j][i]][i];\n        }\n    }\n}\n\nint lca(int u, int v)\n{\n    if (depth[u] > depth[v]) swap(u, v);\n\n    int diff = depth[v] - depth[u];\n\n    rep(i, 20) {\n        if (diff >> i & 1) v = par[v][i];\n    }\n\n    if (u == v) return u;\n\n    rrep(i, 20) {\n        if (par[u][i] != par[v][i]) {\n            u = par[u][i];\n            v = par[v][i];\n        }\n    }\n\n    return par[u][0];\n}\n\nint main()\n{\n    int n = in();\n\n    rep(i, n) {\n        int k = in();\n\n        rep(j, k) {\n            int c = in();\n\n            G[i].PB(c);\n            G[c].PB(i);\n        }\n    }\n\n    lca_init();\n\n    int q = in();\n\n    rep(_, q) {\n        int u = in(), v = in();\n\n        printf(\"%d\\n\", lca(u, v));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct tree {\n  int n;\n  tree(int n) : n(n) {}\n  vector<int> pos, tour, depth;\n  vector<vector<int>> table;\n  int argmin(int i, int j) { return depth[i] < depth[j] ? i : j; }\n  void rootify(int r, Graph &adj) {\n    pos.resize(n);\n    function<void (int,int,int)> dfs = [&](int u, int p, int d) {\n      pos[u] = depth.size();\n      tour.push_back(u);\n      depth.push_back(d);\n      for (auto &v: adj[u]) {\n        if (v.dst != p) {\n          dfs(v.dst, u, d+1);\n          tour.push_back(u);\n          depth.push_back(d);\n        }\n      }\n    }; dfs(r, r, 0);\n    int logn = sizeof(int)*__CHAR_BIT__-1-__builtin_clz(tour.size()); // log2\n    table.resize(logn+1, vector<int>(tour.size()));\n    iota(table[0].begin(), table[0].end(), 0);\n    for (int h = 0; h < logn; ++h) \n      for (int i = 0; i+(1<<h) < tour.size(); ++i)\n        table[h+1][i] = argmin(table[h][i], table[h][i+(1<<h)]);\n  }\n  int lca(int u, int v) {\n    int i = pos[u], j = pos[v]; if (i > j) swap(i, j);\n    int h = sizeof(int)*__CHAR_BIT__-1-__builtin_clz(j-i); // = log2\n    return i == j ? u : tour[argmin(table[h][i], table[h][j-(1<<h)])];\n  }\n};\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\ttree tr(V);tr.rootify(0,g);\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tprintf(\"%d\\n\",tr.lca(s,t));\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;\nvector<int> G[100010];\nint parent[100010];//parent[i]はiの親\nint depth[100010];//depth[i]はiの根からの深さ\nint root = 0;//今回は0が根\nvoid dfs(int v,int p,int d){\n\tparent[v] = p;\n\tdepth[v] = d;\n\tfor(int i =0;i <G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tdfs(G[v][i],v,d+1);\n\t\t}\n\t}\n}\n//初期化\nvoid init(){\n\tdfs(root,-1,0);\n}\n\nint lca(int u,int v){\n\twhile(depth[u] >depth[v]) u =parent[u];\n\twhile(depth[u] < depth[v]) v =parent[v];\n\twhile(u!=v){\n\t\tu =parent[u];\n\t\tv =parent[v];\n\t}\n\treturn u;\n}\nint main(){\n\tcin>>n;\n\tfor(int i =0;i < n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j =0;j < k;j++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin>>q;\n\n\tfor(int i =0;i < q;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tcout <<lca(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint head[500005];\nint f[1000005][22];\nint deep[1000005];\nstruct edge\n{\n    int next,to;\n} e[1000005];\nvoid dfs(int now,int father)//now代表当前访问到的节点，father代表now节点的父亲节点\n{\n    deep[now]=deep[father]+1;//深度比父亲节点多1\n    int i;\n    for(i=1; (1<<i)<=deep[now]; i++) //判断条件就是不能跳得比根节点还高吧？\n        f[now][i]=f[f[now][i-1]][i-1];\n    for(i=head[now]; i; i=e[i].next)\n    {\n        if(e[i].to==father)\n            continue;//双向边，不能往回走！\n        f[e[i].to][0]=now;\n        //遍历每一个以now为起点的边的终点\n        dfs(e[i].to,now);\n    }\n}\nint lca(int x,int y)\n{\n    if(deep[x]<deep[y])\n        swap(x,y);//直接让x是最深节点，后面就不用分类讨论了\n    int i;\n    for(i=19; i>=0; i--) //跳到同一层\n    {\n        if(deep[f[x][i]]>=deep[y])//当x的深度大于等于y的时候都会往上跳，最后就会跳到和y同等深度的地方\n            x=f[x][i];\n        if(x==y)\n            return y;//有可能x、y的最近公共祖先就是y本身\n    }\n    for(i=19; i>=0; i--)\n    {\n        if(f[x][i]!=f[y][i])//跳到他们最近公共祖先的下一层就行了\n        {\n            x=f[x][i];\n            y=f[y][i];\n        }\n    }\n    return f[x][0];\n}\nint main()\n{\n    int n,m,k;//k是根节点编号\n    cin>>n;\n    int num=1,i;\n    for(i=0; i<=n-1; i++)\n    {\n        int k;\n        scanf(\"%d\",&k);\n        int from=i,to;\n        while(k--)\n        {\n            scanf(\"%d\",&to);\n            //链式前向星存树\n            e[num].to=to;\n            e[num].next=head[from];\n            head[from]=num;\n\n            num++;\n            //用双向边代替无向边\n            e[num].to=from;\n            e[num].next=head[to];\n            head[to]=num;\n\n            num++;\n        }\n\n    }\n    dfs(0,0);\n    cin>>m;\n    while(m--)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        cout<<lca(x,y)<<'\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int>d(n);\n    vector<vector<int> > p(n,vector<int>(20,-1));\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        for(int j=0;j<k;j++){\n            int m;\n            cin >> m;\n            p[m][0] = i;\n            d[m] = d[i]+1;\n        }\n    }\n    for(int i=1;i<20;i++){\n        for(int j=0;j<n;j++){\n            if(p[j][i-1]!=-1)p[j][i] = p[p[j][i-1]][i-1];\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin >> u >> v;\n        if(d[u]<d[v]){\n            swap(u,v);\n        }\n        int k = d[u]-d[v];\n        int cnt = 0;\n        while(k>0){\n            if(k%2!=0){\n                u = p[u][cnt];\n            }\n            cnt++;\n            k/=2;\n        }\n        if(u==v){\n            cout << u << \"\\n\";\n        }else{\n            for(int s = 19;s>=0;s--){\n                if(p[u][s]!=p[v][s]){\n                    u = p[u][s];\n                    v = p[v][s];\n                }\n            }\n            cout << p[u][0] << \"\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX=100000;\n\nvector<int> G[MAX];\nint root;\nint V;\n\nint vs[MAX*2-1];\nint depth[MAX*2-1];\nint id[MAX];\n\nint n;\nint dat[2*MAX-1];//0-indexed\n\nvoid rmq_init(int V)\n{\n\tn=1;\n\twhile(n<V)n<<=1;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=-1;\n\treturn;\n}\n\nvoid update(int k,int a)\n{\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0)\n\t{\n\t\tk=(k-1)/2;\n\t\tint b1=dat[k*2+1],b2=dat[k*2+2];\n\t\tif(b1!=-1&&b2!=-1)dat[k]=(depth[b1]<=depth[b2]?b1:b2);\n\t\telse if(b2!=-1)dat[k]=b2;\n\t\telse dat[k]=b1;\n\t}\n\treturn;\n}\n\nint getmin(int a,int b,int k,int l,int r)//[a,b),vertex-number(0),k's range[l,r)\n{\n\tif(r<=a||b<=l)return -1;\n\t\n\tif(a<=l&&r<=b)return dat[k];\n\telse\n\t{\n\t\tint vl=getmin(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=getmin(a,b,k*2+2,(l+r)/2,r);\n\t\tif(vl!=-1&&vr!=-1)return (depth[vl]<=depth[vr]?vl:vr);\n\t\telse if(vr!=-1)return vr;\n\t\telse return vl;\n\t}\n}\n\nvoid dfs(int v,int p,int d,int &k)\n{\n\tid[v]=k;\n\tvs[k]=v;\n\tdepth[k]=d;\n\tk++;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tif(G[v][i]!=p)\n\t\t{\n\t\t\tdfs(G[v][i],v,d+1,k);\n\t\t\tvs[k]=v;\n\t\t\tdepth[k]=d;\n\t\t\tk++;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid init()\n{\n\tint k=0;\n\troot=0;\n\tdfs(root,-1,0,k);\n\trmq_init(V*2-1);\n\tfor(int i=0;i<V*2-1;i++)update(i,i);\n\treturn;\n}\n\nint lca(int u,int v)\n{\n\tif(id[u]>id[v])swap(u,v);\n\treturn vs[getmin(id[u],id[v]+1,0,0,n)];\n}\n\nint main()\n{\n\tcin>>V;\n\tint k,c;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tcin>>c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin>>q;\n\tint u,v;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tcout<<lca(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_LOG_V = 17;\n\nvector<int> g[MAX_V]; //??°???????????£??\\?????????\nint root;\n\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i,g[v].size()){\n        if(g[v][i] != p) dfs(g[v][i], v, d + 1);\n    }\n}\n\nvoid init(int v){\n    dfs(root, -1, 0);\n    rep(i,MAX_LOG_V - 1){\n        rep(j,v){\n            if(parent[i][j] < 0) parent[i + 1][j] = -1;\n            else parent[i + 1][j] = parent[i][parent[i][j]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    rep(i,MAX_LOG_V){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = parent[i][v];\n        }\n    }\n    if(u == v) return u;\n\n    //????????¢?´¢\n    for(int i = MAX_LOG_V - 1; i >= 0; i--){\n        if(parent[i][u] != parent[i][v]){\n            u = parent[i][u];\n            v = parent[i][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    int n;\n    cin >> n;\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int v;\n            cin >> v;\n            g[i].emplace_back(v);\n            g[v].emplace_back(i);\n        }\n    }\n\n    init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\n// struct edge { int u, v; ll w; };\n\nint INF = INT_MAX;\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint N;\nvector<int> G[100010];\nint sz[100010], dep[100010];\nint M = 1;\nint id[100010], par[100010];\n\nvoid dfs_sz(int u, int p) {\n\tsz[u] = 1;\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tdfs_sz(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs_dep(int u, int p) {\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tdep[v] = dep[u] + 1;\n\t\tdfs_dep(v, u);\n\t}\n}\n\nvoid dfs_hl(int u, int p) {\n\tint x, ma = 0;\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tif (sz[v] > ma) {\n\t\t\tx = v;\n\t\t\tma = sz[v];\n\t\t}\n\t}\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tif (v == x) id[v] = id[u];\n\t\telse {\n\t\t\tid[v] = M;\n\t\t\tpar[M] = u;\n\t\t\tM++;\n\t\t}\n\t\tdfs_hl(v, u);\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tfor (int u = 0; u < N; u++) {\n\t\tint k; scanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n\tdfs_sz(0, N);\n\tdep[N] = -1;\n\tdfs_dep(0, N);\n\tpar[0] = N;\n\tdfs_hl(0, N);\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\twhile (id[u] != id[v]) {\n\t\t\tint U = par[id[u]], V = par[id[v]];\n\t\t\tif (dep[U] > dep[V]) u = U;\n\t\t\telse v = V;\n\t\t}\n\t\tprintf(\"%d\\n\", dep[u] < dep[v] ? u : v);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\ntemplate <typename T>\nstruct TreeLCA {\npublic:\n    int const MAX_LOG_V;\n    vector< vector< Edge<T> > > G;\n    int root, vn;\n    vector< vector<int> > parent;\n    vector<int> depth;\n\n    // constructor (Graph, root)\n    TreeLCA(vector< vector< Edge<T> > > _G, int _r) : \n        MAX_LOG_V(35), G(_G), root(_r), vn(G.size()), \n        parent(MAX_LOG_V, vector<int>(vn, 0)), depth(vn, 0) {}\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for(int i=0; i<G[v].size(); i++) {\n            if(G[v][i].to != p) dfs(G[v][i].to, v, d+1);\n        }\n    }\n\n    void init(int V) {\n        dfs(root, -1, 0);\n        for(int k=0; k+1 < MAX_LOG_V; k++) {\n            for(int v=0; v < V; v++) {\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    int solve(int u, int v) {\n        init(vn);\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int k=0; k < MAX_LOG_V; k++) {\n            if((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        for(int k=MAX_LOG_V - 1; k>=0; k--) {\n            if(parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\nsigned main() {\n    int n, k, c; cin >> n;\n    Graph(int) G(n);\n    rep(i,0,n) {\n        cin >> k;\n        rep(j,0,k) {\n            cin >> c;\n            G[i].pb(Edge<int>(c, 1));\n        }\n    }\n\n    TreeLCA<int> tr(G, 0);\n    int q; cin >> q;\n    int u, v;\n    rep(i,0,q) {\n        cin >> u >> v;\n        cout << tr.solve(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#if __has_include(<boost/multiprecision/cpp_int.hpp>)\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n\tusing namespace boost::multiprecision;\n#endif\n#if __has_include(<boost/stacktrace.hpp>)\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE 1\n\t#include <boost/stacktrace.hpp>\n#endif\n#ifdef LOCAL_TEST\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::reverse_iterator first, const typename std::vector<T>::reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_iterator first, const typename std::vector<T>::const_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_reverse_iterator first, const typename std::vector<T>::const_reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n); }\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n); }\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\t#define vector dvector\n\t#define bool dbool\n#endif\n#ifdef LOCAL_DEV\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::vector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::vector<std::vector<T>>& vv) {\n\t\ts << \"\\\\\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception(); }\n\tvoid catch_SIGSEGV([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = (ll)1e9 + 7;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1, 0, -1, 0};\nconstexpr ll dy[4] = {0, 1, 0, -1};\nconstexpr ll dx8[8] = {1, 0, -1, 0, 1, 1, -1, -1};\nconstexpr ll dy8[8] = {0, 1, 0, -1, 1, -1, 1, -1};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\n/*\n最小共通祖先(Doubling-Lowest-Common-Ancestor)\nDoublingLowestCommonAncestor(g):= 木 g で初期化する。\nbuild(v):= vを根としたLCAを構築する。\nquery(u, v):= 頂点 u と v の最小共通祖先を返す。\n*/\ntemplate< typename G >\nclass DoublingLowestCommonAncestor {\npublic:\n\tconst G &g;\n\tvector< int > depth;//depth[v]=根からvまでの距離\n\tconst int LOG;\n\tvector< vector< int > > table;\n\n\tDoublingLowestCommonAncestor(const G &g) : g(g), depth(g.size()), LOG(32 - __builtin_clz(g.size())) {\n\t\ttable.assign(LOG, vector< int >(g.size(), -1));\n\t}\n\n\tvoid dfs(int idx, int par, int d) {\n\t\ttable[0][idx] = par;\n\t\tdepth[idx] = d;\n\t\tfor(auto &to : g[idx]) {\n\t\t\tif(to != par) dfs(to, idx, d + 1);\n\t\t}\n\t}\n\n\tvoid build(int v) {\n\t\tdfs(v, -1, 0);\n\t\tfor(int k = 0; k + 1 < LOG; k++) {\n\t\t\tfor(int i = 0,tablesize = table[k].size(); i < tablesize; i++) {\n\t\t\t\tif(table[k][i] == -1) table[k + 1][i] = -1;\n\t\t\t\telse table[k + 1][i] = table[k][table[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u, int v) {\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tfor(int i = LOG - 1; i >= 0; i--) {\n\t\t\tif(((depth[v] - depth[u]) >> i) & 1) v = table[i][v];\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int i = LOG - 1; i >= 0; i--) {\n\t\t\tif(table[i][u] != table[i][v]) {\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n};\n\n/*-----8<-----library-----8<-----*/\n\nsigned main() {\n\tll N;\n\tcin>>N;\n\tvector<vector<ll>> g(N);\n\trep(i,N){\n\t\tll t;\n\t\tcin>>t;\n\t\trep(j,t){\n\t\t\tll v;\n\t\t\tcin>>v;\n\t\t\tg[i].push_back(v);\n\t\t\tg[v].push_back(i);\n\t\t}\n\t}\n\t\n\tDoublingLowestCommonAncestor< vector<vector<ll>> > lca(g);\n\tlca.build(0);\n\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans;\n\trep(q,Q){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tll lcav=lca.query(a,b);\n\t\tans.push_back(lcav);\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define all(v) v.begin(), v.end()\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst int MAX_N=1<<20;\nint N;\nvector<P> dat(2*MAX_N-1);\nvoid rmq_init(int n_){\n    N=1;\n    while(N<n_) N*=2;\n    rep(i,2*N-1) dat[i]=P(INT_MAX,-1);\n}\nvoid update(int k,int a){\n    int index=k;\n    k+=N-1;\n    dat[k]=P(a,index);\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=min(dat[2*k+1],dat[2*k+2]);\n    }\n}\nP subquery(int a,int b,int k=0,int l=0,int r=N){\n    if(r<=a||b<=l) return P(INT_MAX,-1);\n    if(a<=l&&r<=b) return dat[k];\n    else{\n        P vl=subquery(a,b,k*2+1,l,(l+r)/2);\n        P vr=subquery(a,b,k*2+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n}\nint query(int a,int b){\n    return subquery(a,b).second;\n}\nvec G[200001];\nint root,vs[400001],depth[400001],id[200001];\nvoid dfs(int v,int p,int d,int &k){\n    id[v]=k;\n    vs[k]=v;\n    depth[k++]=d;\n    rep(i,G[v].size()){\n        if(G[v][i]!=p){\n            dfs(G[v][i],v,d+1,k);\n            vs[k]=v;\n            depth[k++]=d;\n        }\n    }\n}\nvoid init(int V){\n    int k=0;\n    dfs(root,-1,0,k);\n    rmq_init(V*2-1);\n    rep(i,V*2-1) update(i,depth[i]);\n}\nint lca(int u,int v){\n    return vs[query(min(id[u],id[v]),max(id[u],id[v])+1)];\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k,v;\n        cin>>k;\n        rep(j,k) cin>>v,G[i].push_back(v);\n    }\n    init(n);\n    int q;\n    cin>>q;\n    rep(i,q){\n        int u,v;\n        cin>>u>>v;\n        cout<<lca(u,v)<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef DEBUG\n#include <fmt/format.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  s8 =   int8_t;\nusing  u8 =  uint8_t;\nusing s16 =  int16_t;\nusing u16 = uint16_t;\nusing s32 =  int32_t;\nusing u32 = uint32_t;\nusing s64 =  int64_t;\nusing u64 = uint64_t;\n\ntemplate<typename T>\nusing max_heap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// ???????????´\n//#define int s64\nconstexpr bool IOS_SYNCSTDIO = false;\nconstexpr int  IOS_PREC      = 10;\n\nconstexpr int    INF = numeric_limits<int>::max();\nconstexpr double EPS = 1e-9;\n\n// util {{{\ntemplate<typename T>\nconstexpr int sgn(T x)\n{\n    return (x > T(0)) - (x < T(0));\n}\n\ntemplate<typename T>\nconstexpr typename enable_if<is_signed<T>::value,T>::type modulo(T a, T b)\n{\n    assert(b > 0);\n    T r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T clamp(T x, T lo, T hi)\n{\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(x > hi)\n        return hi;\n    else\n        return x;\n}\n\nint sqrti(int x)\n{\n    assert(x >= 0);\n    return static_cast<int>(sqrt(x));\n}\n\ns64 sqrtl(s64 x)\n{\n    assert(x >= 0);\n    return static_cast<s64>(sqrtl(x));\n}\n\ntemplate<typename T>\nbool max_update(T& xmax, const T& x)\n{\n    if(x > xmax) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nbool min_update(T& xmin, const T& x)\n{\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c)\n{\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N])\n{\n    return static_cast<int>(N);\n}\n\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args)\n{\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args)\n{\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last)\n{\n    for(InputIt it = first; it != last; ++it) {\n        if(it != first) out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N])\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2])\n{\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args)\n{\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args)\n{\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last)\n{\n    return FPRINTSEQ(cout, first, last);\n}\n\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N])\n{\n    return FPRINTARRAY1(cout, c);\n}\n\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2])\n{\n    return FPRINTARRAY2(cout, c);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args)\n{\n    return FPRINT(cerr, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args)\n{\n    return FPRINTLN(cerr, args...);\n}\n\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last)\n{\n    return FPRINTSEQ(cerr, first, last);\n}\n\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N])\n{\n    return FPRINTARRAY1(cerr, c);\n}\n\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2])\n{\n    return FPRINTARRAY2(cerr, c);\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p)\n{\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c)\n{\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const list<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const forward_list<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const unordered_set<T>& c)\n{\n    return out << set<T>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c)\n{\n    return FPRINTSEQ(out, cbegin(c), cend(c));\n}\n\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last)\n{\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last)\n{\n    return FPRINTMAP(cout, first, last);\n}\n\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last)\n{\n    return FPRINTMAP(cerr, first, last);\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c)\n{\n    return FPRINTMAP(out, cbegin(c), cend(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const unordered_map<K,V>& c)\n{\n    return out << map<K,V>(cbegin(c), cend(c));\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c)\n{\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c)\n{\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c)\n{\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\nstruct IosIni {\n    IosIni()\n    {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(IOS_SYNCSTDIO);\n        cout << fixed << setprecision(IOS_PREC);\n    }\n} IOSINI;\n\n#define FOR(i, start, end) for(int i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,cc,...) ([&](decltype((cc)) c) { return (f)(begin(c), end(c), ## __VA_ARGS__); })(cc)\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n// }}}\n\nint N;\nvector<vector<int>> T;\n\nvector<int> D; // ??????????????±???\nvector<vector<int>> P; // P[v][i]: v??????2^i????????£?????????\nint P_NI;\n\nvoid dfs(int v, int p, int d)\n{\n    D[v] = d;\n    P[v][0] = p;\n\n    for(int c : T[v]) {\n        if(c == p) continue;\n        dfs(c, v, d+1);\n    }\n}\n\nvoid make_p()\n{\n    REP(v, N) {\n        REP(i, P_NI-1) {\n            if(P[v][i] == -1) {\n                P[v][i+1] = -1;\n            }\n            else {\n                P[v][i+1] = P[P[v][i]][i];\n            }\n        }\n    }\n}\n\nint lca(int u, int v)\n{\n    if(D[u] > D[v]) swap(u,v);\n\n    int d = D[v] - D[u];\n    REP(i, P_NI) {\n        if((d>>i)&1) v = P[v][i];\n    }\n\n    if(u == v) return u;\n\n    for(int i = P_NI-1; i >= 0; --i) {\n        if(P[u][i] != P[v][i]) {\n            u = P[u][i];\n            v = P[v][i];\n        }\n    }\n    return P[u][0];\n}\n\nvoid solve()\n{\n    D.resize(N);\n\n    P_NI = 1 + static_cast<int>(log2(N));\n    P.assign(N, vector<int>(P_NI));\n\n    dfs(0, -1, 0);\n\n    make_p();\n\n#ifdef DEBUG\n    DBG(D);\n    DBG(P);\n#endif\n\n    int Q; cin >> Q;\n    REP(_, Q) {\n        int u, v; cin >> u >> v;\n        PRINTLN(lca(u,v));\n    }\n}\n\nsigned main(signed /*argc*/, char** /*argv*/)\n{\n    cin >> N;\n    T.resize(N);\n\n    REP(v, N) {\n        int k; cin >> k;\n        REP(_, k) {\n            int c; cin >> c;\n            T[v].push_back(c);\n            T[c].push_back(v);\n        }\n    }\n#ifdef DEBUG\n    DBG(T);\n#endif\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 400){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src_, int dst_, Weight weight_) :\n        src(src_), dst(dst_), weight(weight_) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint const MAX_V = 1000010;\n\ntypedef int dat_t;\ndat_t const inf = (1LL<<31)-1;\ndat_t const init = (1LL<<31)-1;\nstruct segment_tree {\n    vector<pair<dat_t,int>> dat;\n    int n;\n    segment_tree(int n_){\n        n = 1;\n        while(n < n_) n<<=1;\n        dat.resize(n*2);\n        for(int i=n; i<n+n; i++){\n            dat[i] = make_pair(init,i); // -infをdat[i]にするとvectorからのコンストラクタになる\n        }\n        for(int i=n-1; i>=1; i--){\n            dat[i] = min(dat[i<<1], dat[i<<1|1]);\n        }\n    }\n    // bottom-up\n    void set(int k, dat_t x){\n        int i = n+k; // leaf\n        dat[i] = make_pair(x,k);\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i], dat[i^1]);\n            i>>=1;\n        }\n    }\n    // top-down\n    pair<dat_t,int> get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return make_pair(inf,0);\n        if(a <= l && r <= b) return dat[k];\n        pair<dat_t,int> v1 = get(a,b,k<<1,l,(l+r)/2);\n        pair<dat_t,int> v2 = get(a,b,k<<1|1,(l+r)/2,r);\n        return min(v1,v2);\n    }\n    pair<dat_t,int> get(int a, int b){\n        return get(a,b,1,0,n);\n    }\n};\n\nstruct LowestCommonAncestor {\n    int n;\n    Graph g;\n    unique_ptr<int[]> ord, depth, id;\n    unique_ptr<segment_tree> rmq;\n    LowestCommonAncestor(int n_)\n        : n(n_), g(n), ord(new int[n*2]), depth(new int[n*2]), id(new int[n]), rmq(new segment_tree(n*2)) {\n    }\n    void add_edge(int a, int b){\n        g[a].eb(a,b,0);\n    }\n    void compile(int root = 0){\n        int k = 0;\n        dfs(root,-1,0,k);\n        for(int i=0;i<k;i++){\n            rmq->set(i,depth[i]);\n        }\n    }\n    int lca(int u, int v){\n        int a = id[u], b = id[v];\n        return ord[rmq->get(min(a,b), max(a,b)+1).second];\n    }\n    void dfs(int v, int p, int d, int & k){\n        id[v] = k;\n        ord[k] = v;\n        depth[k] = d;\n        k++;\n        for(auto & e : g[v]){\n            if(e.dst != p){\n                dfs(e.dst, v, d+1, k);\n                ord[k] = v;\n                depth[k] = d;\n                k++;\n            }\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k; cin >> k;\n        for(int j=0;j<k;j++){\n            int to; cin >> to;\n            g.add_edge(i,to);\n            g.add_edge(to,i);\n        }\n    }\n    g.compile();\n    int q;\n    cin >> q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin >> u >> v;\n        cout << g.ask(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int> X[1 << 17], Y[1 << 17]; int N, A, B, Q;\nint Solve(int S, int T) {\n\tint A = Y[S].size(), L = 0; if (A > Y[T].size()) { A = Y[T].size(); }\n\tfor (int i = 0; i < A; i++) {\n\t\tint V1 = Y[S].size() - i - 1, V2 = Y[T].size() - i - 1;\n\t\tif (V1 != V2) { return L; }L = V1;\n\t}return L;\n}\nint main() {\n\tcin >> N; for (int i = 0; i < N; i++) { cin >> A; for (int j = 0; j < A; j++) { cin >> B; X[B].push_back(A); } }\n\tfor (int i = 0; i < N; i++) { int cx = i; Y[i].push_back(cx); while (cx>0) { cx = X[cx][0]; Y[i].push_back(cx); } }\n\tcin >> Q; for (int i = 0; i < Q; i++) { cin >> A >> B; cout << Solve(A, B) << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct LeastCommonAncestor {\n   public:\n    LeastCommonAncestor(int n, int root = 0)\n        : root(root),\n          graph(n),\n          parent(ilogb(n) + 1, vector<int>(n)),\n          depth(n) {}\n\n    void add_edge(int a, int b) {\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    void init() {\n        dfs(root, -1, 0);\n\n        for (int k = 0; k + 1 < parent.size(); ++k) {\n            for (int v = 0; v < graph.size(); ++v) {\n                if (parent[k][v] < 0) {\n                    parent[k + 1][v] = -1;\n                } else {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n\n        initialized = true;\n    }\n\n    int query(int u, int v) {\n        if (!initialized) {\n            init();\n        }\n\n        if (depth[u] > depth[v]) {\n            swap(u, v);\n        }\n\n        for (int k = 0; k < parent.size(); ++k) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n\n        if (u == v) {\n            return u;\n        }\n\n        for (int k = parent.size() - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\n   private:\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int to : graph[v]) {\n            if (to != p) {\n                dfs(to, v, d + 1);\n            }\n        }\n    }\n\n   private:\n    int root;\n    vector<vector<int>> graph;\n    vector<vector<int>> parent;\n    vector<int> depth;\n\n    bool initialized = false;\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    LeastCommonAncestor lca(n);\n\n    for (int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n\n        for (int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n\n            lca.add_edge(i, c);\n        }\n    }\n\n    lca.init();\n\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n\n        cout << lca.query(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int nmax=1000010;\n\nvector<int> graph[nmax];\nint parent[nmax][20]; // all is -1\nint depth[nmax];\n\nvoid dfs(int v,int p,int d){\n\tparent[v][0]=p;\n\tdepth[v]=d;\n\tfor(auto &v2:graph[v]) if(v2!=p) dfs(v2,v,d+1);\n}\n\nint lca(int u,int v){\n\tif(depth[u] < depth[v]) swap(u,v);\n\tfor(int i=19;i>=0;--i) if((depth[u]-depth[v])>>i&1) u=parent[u][i];\n\tif(u==v) return u;\n\tfor(int i=19;i>=0;--i){\n\t\tif(parent[u][i]!=parent[v][i]){\n\t\t\tu=parent[u][i];\n\t\t\tv=parent[v][i];\n\t\t}\n\t}\n\treturn parent[u][0];\n}\n\nint main(void){\n\tint n; cin >> n;\n\trep(i,n){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint v; cin >> v;\n\t\t\tgraph[i].push_back(v);\n\t\t}\n\t}\n\n\t// rep(i,n)rep(j,20) parent[i][j]=-1;\n\tdfs(0,-1,0);\n\trep(i,n)rep(j,19) parent[i][j+1]=parent[parent[i][j]][j];\n\n\tint q; cin >> q;\n\trep(i,q){\n\t\tint u,v; cin >> u >> v;\n\t\tcout << lca(u,v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int V_MAX = 100000;\n\nvector<int> graph[V_MAX];\n\nclass LowestCommonAncestor {\n    public:\n    int root, n, LOG_V_MAX = 30;\n    vector<int> depth;\n    vector<vector<int>> parent;\n\n    LowestCommonAncestor(int root=0, int n=V_MAX): root(root), n(n) {\n        depth.resize(n);\n        depth.assign(n, -1);\n        parent.resize(n, vector<int>(LOG_V_MAX));\n        parent.assign(n, vector<int>(LOG_V_MAX, -1));\n        dfs(root, -1, 0);\n        for(int i=0;i<n;++i) {\n            for(int j=1;j<LOG_V_MAX;++j) {\n                if(parent[i][j-1] == -1) break;\n                parent[i][j] = parent[parent[i][j-1]][j-1];\n            }\n        }\n    }\n\n    void dfs(int node, int par, int d) {\n        depth[node] = d;\n        parent[node][0] = par;\n        for(int child: graph[node]) {\n            if(child == par) continue;\n            dfs(child, node, d+1);\n        }\n    }\n\n    int get_lca(int u, int v) {\n        if(depth[u] > depth[v]) swap(u, v);\n        int depth_diff = depth[v] - depth[u];\n        for(int j=0;j<LOG_V_MAX&&depth_diff;++j) {\n            if(depth_diff & (1 << j)) {\n                v = parent[v][j];\n            }\n        }\n        if(u == v) return u;\n        for(int j=LOG_V_MAX-1;j>=0;--j) {\n            if(parent[u][j] != -1 && parent[u][j] != parent[v][j]) {\n                u = parent[u][j];\n                v = parent[v][j];\n            }\n        }\n        return parent[u][0];\n    }\n};\n\nint main() {\n    int n, k, c;\n    cin >> n;\n    for(int i=0;i<n;++i) {\n        cin >> k;\n        for(int j=0;j<k;++j) {\n            cin >> c;\n            graph[i].push_back(c);\n            graph[c].push_back(i);\n        }\n    }\n\n    LowestCommonAncestor lca = LowestCommonAncestor(0, n);\n\n    int q, u, v;\n    cin >> q;\n    for(int i=0;i<q;++i) {\n        cin >> u >> v;\n        cout << lca.get_lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass LowestCommonAncestor{\npublic:\n    int n;\n    int LOG_N;\n    vector<int> depth;\n    vector<vector<int>> g;\n    vector<vector<int>> ancestor;\n\n    void dfs(int s, int p){\n        for(auto& u : g[s]){\n            if(u==p) continue;\n            depth[u] = depth[s] + 1;\n            ancestor[u][0] = s;\n            dfs(u, s);\n        }\n    }\n\n    int lca(int u, int v){\n        if(depth[u]>depth[v]) swap(u, v);\n        for(int i=0;i<LOG_N;++i){\n            if((depth[v]-depth[u]) >> i & 1){\n                v = ancestor[v][i];\n                assert(v!=-1);\n            }\n        }\n        if(u == v) return u;\n        for(int i=LOG_N-1;0<=i;--i){\n            if(ancestor[u][i]!=ancestor[v][i]){\n                u = ancestor[u][i];\n                v = ancestor[v][i];\n            }\n        }\n        return ancestor[u][0];\n    }\n\n    LowestCommonAncestor() : n(0), LOG_N(0){}\n\n    explicit LowestCommonAncestor(vector<vector<int>> &g, int s=0) : g(g){\n        n = g.size();\n        LOG_N = 0;\n        while((1<<LOG_N)<n) ++LOG_N;\n        depth.resize(n, 0);\n        ancestor.resize(n, vector<int>(LOG_N, -1));\n        dfs(s, -1);\n        for(int i=1;i<LOG_N;++i){\n            for(int j=0;j<n;++j){\n                if(ancestor[j][i-1]!=-1) ancestor[j][i] = ancestor[ancestor[j][i-1]][i-1];\n            }\n        }\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n    int N;\n    cin>>N;\n    vector<vector<int>> G(N);\n    for(int i=0;i<N;++i){\n        int ki;\n        cin>>ki;\n        for(int j=0;j<ki;++j){\n            int c;\n            cin>>c;\n            G[i].push_back(c);\n        }\n    }\n    auto solver = LowestCommonAncestor(G);\n    int Q;\n    cin>>Q;\n    while(Q--){\n        int u, v;\n        cin>>u>>v;\n        cout<<solver.lca(u, v)<<'\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return node_[vl] < node_[vr] ? left_child(k) : right_child(k);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n\n// 根付き木\n\n#include<vector>\n#include<memory>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int size() const {return node_.size();}\n    int lowest_common_ancestor(int u, int v) const {\n        RangeMinimumQuery rmq(size());\n        for(int i = 0; i < size(); ++i) rmq.update(i, depth(i));\n        return rmq.find_index(std::min(u, v), std::max(u, v)) - 1;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n\n\n/*\n// LCA: O(n)\n#include<vector>\n#include<memory>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n//     int lowest_common_ancestor(int u, int v) const {\n//         while(depth(u) > depth(v)) u = parent(u);\n//         while(depth(u) < depth(v)) v = parent(v);\n//         while(u != v) {\n//             u = parent(u);\n//             v = parent(v);\n//         }\n//         return u;\n//     }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(u);\n            else                    u = parent(v);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define MAX_V 100010\n#define MAX_LOG_V 20\n\nvector<int> edge[MAX_V];\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nstruct LCA{\n  int root;\n\n  LCA(int r): root(r){}\n\n  void add_edge(int a, int b) {\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  \n  void dfs(int v, int par, int dep) {\n    parent[0][v] = par;\n    depth[v] = dep;\n    for (auto child : edge[v]) {\n      if (child != par) dfs(child, v, dep + 1);\n    }\n  }\n\n  void init(int V) {\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n      for (int v = 0; v < V; v++) {\n\tif (parent[k][v] < 0) {\n\t  parent[k+1][v] = -1;\n\t} else {\n\t  parent[k+1][v] = parent[k][parent[k][v]];\n\t}\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n\tv = parent[k][v];\n      }\n    }\n    if (u == v) return u;\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n\tu = parent[k][u];\n\tv = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  int N;\n  LCA lca(0);\n  \n  scanf(\"%d\", &N);\n  REP(i, N) {\n    int k;\n    cin >> k;\n    REP(j, k) {\n      int c;\n      cin >> c;\n      lca.add_edge(i, c);\n    }\n  }\n  lca.init(N);\n  int Q;\n  cin >> Q;\n  REP(i, Q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n#include<climits>\n#include<cassert>\nusing namespace std;\n\n\n\n//verified\nclass LCA{\n\tint n;\n\tstd::vector<int> _depth,idx;\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tint minimum(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return _depth.size()-1;\n\t\tif(a<=l&&r<=b)return idx[k];\n\t\telse{\n\t\t\tint vl=minimum(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=minimum(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn _depth[vl]<_depth[vr]?vl:vr;\n\t\t}\n\t}\n\tvoid buildRMQ(){\n\t\tn=calcsize(_depth.size());\n\t\tidx.resize(2*n-1);\n\t\tfor(int i=0;i<(int)_depth.size();i++)idx[n-1+i]=i;\n\t\tfor(int i=_depth.size();i<n;i++)idx[n-1+i]=_depth.size();\n\t\t_depth.push_back(INT_MAX);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tidx[i]=_depth[idx[i*2+1]]<_depth[idx[i*2+2]]?idx[i*2+1]:idx[i*2+2];\n\t\t}\n\t}\n\t\n\tstd::vector<int> eulertour;\n\tstd::vector<int> in;\n\tvoid dfs(const std::vector<int> edge[],int d,int u){\n\t\tin[u]=eulertour.size();\t\n\t\teulertour.push_back(u);\n\t\t_depth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,d+1,edge[u][i]);\n\t\t\teulertour.push_back(u);\n\t\t\t_depth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const std::vector<int> edge[],int n,int root):in(n){\n\t\tdfs(edge,1,root);\n\t\teulertour.push_back(root);\n\t\t_depth.push_back(0);\n\t\tbuildRMQ();\n\t}\n\tint query(int u,int v)const{//uとvの最小共通祖先\n\t\tif(u==v)return u;\n\t\tif(in[u]>in[v])std::swap(u,v);\n\t\treturn eulertour[minimum(in[u], in[v],0,0,n)];\n\t}\n\tint depth(int u)const{//rootの深さが1\n\t\treturn _depth[in[u]];\n\t}\n};\n\n\n\n\nclass BIT{//binary indexed tree, Fenwick treeとも\n\tstd::vector<int> bit;\npublic:\n\tBIT(const vector<int> &v):bit(v.size()+1,0){\n\t\tfor(int i=0;i<(int)v.size();i++)\n\t\t\tadd(i,v[i]);\n\t}\n\tvoid add(int i,int x){//i番目にx加える\n\t\ti++;//BIT添え字は1?ｎだから\n\t\twhile(i<(int)bit.size()){\n\t\t\tbit[i]+=x;\n\t\t\ti+= i&-i;\n\t\t}\n\t}\n\tint sum(int a)const{//[0,a]の和\n\t\ta++;\n\t\tint res=0;\n\t\twhile(0<a){\n\t\t\tres+=bit[a];\n\t\t\ta-= a&-a;\n\t\t}\n\t\treturn res;\n\t}\n\tint sum(int a,int b)const{//[a,b]の合計\n\t\treturn sum(b)-sum(a-1);\n\t}\n\tvoid zeroclear(){\n\t\tbit.assign(bit.size(),0);\n\t}\n};\n\n\n\n\nclass HL{\n\tstruct S{\n\t\tpair<int,int> par;\n\t\t//BIT segtree;\n\t\tvector<int> id;\n\t\tS(int a,int b,vector<int> v):par(a,b),id(v){}\n\t};\n\tint calc_size(int u,vector<int> edge[],vector<int> &msz){\n\t\tint res=1,sz=0,idx=0;\n\t\tfor(int i=0;i<(int)edge[u].size();i++){\n\t\t\tint s=calc_size(edge[u][i],edge,msz);\n\t\t\tif(sz<s){\n\t\t\t\tsz=s;\n\t\t\t\tidx=i;\n\t\t\t}\n\t\t\tres+=s;\n\t\t}\n\t\tmsz[u]=idx;\n\t\treturn res;\n\t}\n\tvoid build(int u,vector<int> edge[],int val[],vector<int> &msz,vector<int> &heavy){\n\t\tint par=compressed.size(),pi=heavy.size(),s;\n\t\t//heavy.push_back(val[u]);\n\t\theavy.push_back(u);\n\t\tver[u]=make_pair(par,pi);\n\t\tif(edge[u].empty())\t\t\n\t\t\tcompressed.push_back(S(-1,-1,heavy));\n\t\telse \n\t\t\tbuild(edge[u][msz[u]],edge,val,msz,heavy);\n\t\tfor(int i=0;i<(int)edge[u].size();i++){\n\t\t\tif(i==msz[u])continue;\n\t\t\tvector<int> light;\n\t\t\ts=compressed.size();\n\t\t\tbuild(edge[u][i],edge,val,msz,light);\n\t\t\tcompressed[s].par=make_pair(par,pi);\n\t\t}\n\t}\n\tvector<S> compressed;\n\tvector<pair<int,int> > ver;\n\tLCA lca;\npublic:\n\tHL(vector<int> edge[],int val[],int n):ver(n),lca(edge,n,0){\n\t\tvector<int> maxsz(n,-1);\n\t\tvector<int> heavy;\n\t\tcalc_size(0,edge,maxsz);\n\t\tbuild(0,edge,val,maxsz,heavy);\n\t}\n\tlong long query(int u,int v)const{\n\t\tint w=lca.query(u,v);\n\t\tpair<int,int> a,b,c;\n\t\ta=ver[u];\n\t\tb=ver[v];\n\t\tc=ver[w];\n\t\tlong long res=0;\n\t\twhile(c.first!=a.first){\n\t\t\t//res+=compressed[a.first].segtree.sum(a.second);\n\t\t\ta=compressed[a.first].par;\n\t\t}\n\t\tassert(c.second<=a.second);\n\t\t//res+=compressed[c.first].segtree.sum(c.second,a.second);\n\t\twhile(c.first!=b.first){\n\t\t\t//res+=compressed[b.first].segtree.sum(b.second);\n\t\t\tb=compressed[b.first].par;\n\t\t}\n\t\tassert(c.second<=b.second);\n\t\t//if(c.second+1<=b.second)res+=compressed[c.first].segtree.sum(c.second+1,b.second);\n\t\t//return res;\n\t\treturn compressed[c.first].id[min(a.second,b.second)];\n\t}\n\t/*void update(int u,int val){\n\t\tpair<int,int> a=ver[u];\n\t\tint x=compressed[a.first].segtree.sum(a.second,a.second);\n\t\tcompressed[a.first].segtree.add(a.second,val-x);\n\t}*/\n};\n\n\n\nvector<int> edge[100000];\nint val[100000];\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        int k,v;\n        cin>>k;\n        for(int j=0;j<k;j++){\n            cin>>v;\n            edge[i].push_back(v);\n        }\n    }\n\t\n    HL hl(edge,val,n);\n    int q,u,v;\n    cin>>q;\n    for(int i=0;i<q;i++){\n        cin>>u>>v;\n        cout<<hl.query(u,v)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <utility>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    logN = 21;\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void init(int root) {\n    stack<pair<int, int>> s;\n    s.push(make_pair(root, -1));\n    while(!s.empty()) {\n      auto cur = s.top(); s.pop();\n      if(cur.second < 0) depth[cur.first] = 0;\n      else depth[cur.first] = depth[cur.second] + 1;\n\n      parent[0][cur.first] = cur.second;\n      for(int next : G[cur.first]) {\n        if(next != cur.second) {\n          s.push(make_pair(next, cur.first));\n        }\n      }\n    }\n\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] < 0) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\n\nstruct tree {\n  int n;\n  vector<vector<int>> adj;\n  tree(int n) : n(n), adj(n) { }\n  void add_edge(int s, int t) {\n    adj[s].push_back(t);\n    adj[t].push_back(s);\n  }\n  vector<int> pos, tour, depth;\n  vector<vector<int>> table;\n  int argmin(int i, int j) { return depth[i] < depth[j] ? i : j; }\n  void rootify(int r) {\n    pos.resize(n);\n    function<void (int,int,int)> dfs = [&](int u, int p, int d) {\n      pos[u] = depth.size();\n      tour.push_back(u);\n      depth.push_back(d);\n      for (int v: adj[u]) {\n        if (v != p) {\n          dfs(v, u, d+1);\n          tour.push_back(u);\n          depth.push_back(d);\n        }\n      }\n    }; dfs(r, r, 0);\n    int logn = sizeof(int)*__CHAR_BIT__-1-__builtin_clz(tour.size()); // log2\n    table.resize(logn+1, vector<int>(tour.size()));\n    iota(all(table[0]), 0);\n    for (int h = 0; h < logn; ++h) \n      for (int i = 0; i+(1<<h) < tour.size(); ++i)\n        table[h+1][i] = argmin(table[h][i], table[h][i+(1<<h)]);\n  }\n  int lca(int u, int v) {\n    int i = pos[u], j = pos[v]; if (i > j) swap(i, j);\n    int h = sizeof(int)*__CHAR_BIT__-1-__builtin_clz(j-i); // = log2\n    return i == j ? u : tour[argmin(table[h][i], table[h][j-(1<<h)])];\n  }\n};\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  tree T(n);\n  for (int u = 0; u < n ; ++u) {\n    int k; \n    scanf(\"%d\", &k);\n    for (int j = 0; j < k; ++j) {\n      int v;\n      scanf(\"%d\", &v);\n      T.add_edge(u, v);\n    }\n  }\n  T.rootify(0);\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", T.lca(u, v));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ll INF = 1e15;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T, typename S>inline bool upmin(T&a, const S&b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T, typename S>inline bool upmax(T&a, const S&b) { return a < b ? a = b, 1 : 0; }\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\nll pow(ll a, ll b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b == 1) {\n\t\treturn a;\n\t}\n\tll ans = pow(a, b / 2);\n\tans *= ans;\n\tans *= b % 2 == 1 ? a : 1;\n\treturn ans;\n}\n\nnamespace SOLVE {\n\tint n, a, b;\n\tvector<VI> edges;\n\tVI path;\n\tVI depths;\n\tVI visited;\n\tVI firstpath;\n\n\tstruct SegTree {\n\t\tstatic const int maxn = 200005;\n\n\t\tstruct node {\n\t\t\tint l, r, depth, og;\n\t\t};\n\n\t\tnode no[maxn * 4];\n\t\tvoid push_up(int ind) {\n\t\t\tif (no[lson].depth < no[rson].depth) {\n\t\t\t\tno[ind].depth = no[lson].depth;\n\t\t\t\tno[ind].og = no[lson].og;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tno[ind].depth = no[rson].depth;\n\t\t\t\tno[ind].og = no[rson].og;\n\t\t\t}\n\t\t}\n\n\t\tvoid push_down(int ind) {\n\t\t}\n\n\t\tvoid build(int l, int r, int ind) {\n\t\t\tno[ind].l = l;\n\t\t\tno[ind].r = r;\n\t\t\tno[ind].depth = 1e9;\n\t\t\tno[ind].og = 1e9;\n\n\t\t\tif (l == r) {\n\t\t\t\tno[ind].depth = depths[l];\n\t\t\t\tno[ind].og = path[l];\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tbuild(l, mid, lson);\n\t\t\t\tbuild(mid + 1, r, rson);\n\t\t\t\tpush_up(ind);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid query(int l, int r, int ind, int& ans, int& depth) {\n\t\t\tif (l > no[ind].r || r < no[ind].l) {\n\t\t\t\tans = 1e9;\n\t\t\t\tdepth = 1e9;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (l <= no[ind].l && no[ind].r <= r) {\n\t\t\t\tans = no[ind].og;\n\t\t\t\tdepth = no[ind].depth;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ans1, ans2, depth1, depth2;\n\t\t\t\tpush_down(ind);\n\t\t\t\tquery(l, r, lson, ans1, depth1);\n\t\t\t\tquery(l, r, rson, ans2, depth2);\n\t\t\t\tpush_up(ind);\n\n\t\t\t\tif (depth1 < depth2) {\n\t\t\t\t\tans = ans1;\n\t\t\t\t\tdepth = depth1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans = ans2;\n\t\t\t\t\tdepth = depth2;\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\t}\n\n\t\tvoid show(int n) {\n\t\t\tREP(i, 0, n) {\n\t\t\t\tcout << no[i].depth << ' ';\n\t\t\t} cout << endl;\n\t\t\tREP(i, 0, n) {\n\t\t\t\tcout << no[i].og << ' ';\n\t\t\t} cout << endl;\n\t\t}\n\t};\n\n\n\n\tSegTree tree;\n\n\tvoid dfs(int v, int depth) { // while traversing, leave a path\n\t\tvisited[v] = 1;\n\t\tfirstpath[v] = path.size();\n\t\tpath.push_back(v);\n\t\tdepths.push_back(depth);\n\t\t\n\n\t\tfor (int u : edges[v]) {\n\t\t\tif (!visited[u]) {\n\t\t\t\tdfs(u, depth+1);\n\t\t\t\tpath.push_back(v);\n\t\t\t\tdepths.push_back(depth);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid main() {\n\t\tcin >> n;\n\t\tedges.resize(n);\n\t\tvisited.resize(n);\n\t\tfirstpath.resize(n);\n\n\t\tREP(i, 0, n) {\n\t\t\tcin >> a;\n\t\t\tREP(j, 0, a) {\n\t\t\t\tcin >> b;\n\t\t\t\tedges[i].push_back(b);\n\t\t\t}\n\t\t}\n\n\t\tdfs(0, 0);\n\t\t/*\n\t\tfor (int a : path) {\n\t\t\tcout << a << ' ';\n\t\t} cout << endl;\n\t\tfor (int a : depths) {\n\t\t\tcout << a << ' ';\n\t\t} cout << endl;\n\t\t*/\n\n\t\ttree.build(0, sz(path) - 1, 1);\n\n\t\tint ans, depth, q;\n\n\t\tcin >> q;\n\t\tREP(i, 0, q) {\n\t\t\tcin >> a >> b;\n\t\t\tint small = min(firstpath[a], firstpath[b]);\n\t\t\tint big = max(firstpath[a], firstpath[b]);\n\t\t\ttree.query(small, big, 1, ans, depth);\n\t\t\tcout << ans << endl;\n\t\t}\n\t\t\n\n\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint t;\n\t//    in(t);\n\tt = 1;\n\twhile (t--) {\n\t\tSOLVE::main();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\ntemplate <typename T>\nstruct TreeLCA {\npublic:\n    int const MAX_LOG_V;\n    vector< vector< Edge<T> > > G;\n    int root, vn;\n    vector< vector<int> > parent;\n    vector<int> depth;\n\n    // constructor (Graph, root)\n    TreeLCA(vector< vector< Edge<T> > > _G, int _r) : \n        MAX_LOG_V(35), G(_G), root(_r), vn(G.size()), \n        parent(MAX_LOG_V, vector<int>(vn, 0)), depth(vn, 0)\n        { init(vn); }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for(int i=0; i<G[v].size(); i++) {\n            if(G[v][i].to != p) dfs(G[v][i].to, v, d+1);\n        }\n    }\n\n    void init(int V) {\n        dfs(root, -1, 0);\n        for(int k=0; k+1 < MAX_LOG_V; k++) {\n            for(int v=0; v < V; v++) {\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    int solve(int u, int v) {\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int k=0; k < MAX_LOG_V; k++) {\n            if((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        for(int k=MAX_LOG_V - 1; k>=0; k--) {\n            if(parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\nsigned main() {\n    int n, k, c; cin >> n;\n    Graph(int) G(n);\n    rep(i,0,n) {\n        cin >> k;\n        rep(j,0,k) {\n            cin >> c;\n            G[i].pb(Edge<int>(c, 1));\n        }\n    }\n\n    TreeLCA<int> tr(G, 0);\n    int q; cin >> q;\n    int u, v;\n    rep(i,0,q) {\n        cin >> u >> v;\n        cout << tr.solve(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\nclass Ancestor {\nprivate:\n\tint n;\n\tvvi lst;\n\tvvi table;\n\tvi from;\n\tvi visited, departed;\n\tdeque<int> deq;\n\tvoid dfs(int a, int &t) {\n\t\tfor (int i = 0; i < deq.size(); i = i * 2 + 1) {\n\t\t\ttable[a].push_back(deq[i]);\n\t\t}\n\t\tvisited[a] = t++;\n\t\tdeq.push_front(a);\n\t\tForeach(b, lst[a]) {\n\t\t\tif (from[b] == INT_MIN) {\n\t\t\t\tfrom[b] = a;\n\t\t\t\tdepth[b] = depth[a] + 1;\n\t\t\t\tdfs(b, t);\n\t\t\t}\n\t\t}\n\t\tdeq.pop_front();\n\t\tdeparted[a] = t++;\n\t}\npublic:\n\tvi depth;\n\tAncestor(const vvi &lst, vi roots = { 0 }) {\n\t\tn = lst.size();\n\t\tthis->lst = lst;\n\t\ttable = vvi(n);\n\t\tfrom = vi(n, INT_MIN);\n\t\tvisited.resize(n);\n\t\tdeparted.resize(n);\n\t\tdepth.resize(n);\n\t\tint t = 0;\n\t\tForeach(root, roots) {\n\t\t\tfrom[root] = -1;\n\t\t\tdfs(root, t);\n\t\t}\n\t}\n\tbool is_ancestor(int des, int anc) {\n\t\treturn visited[anc] < visited[des]\n\t\t\t&& departed[des] < departed[anc];\n\t}\n\tint lowest_common_ancestor(int x, int y) {\n\t\tif (x == y) return x;\n\t\tif (is_ancestor(x, y)) return y;\n\t\tif (is_ancestor(y, x)) return x;\n\t\tLoop1(i, table[x].size() - 1) {\n\t\t\tif (is_ancestor(y, table[x][i])) {\n\t\t\t\treturn lowest_common_ancestor(table[x][i - 1], y);\n\t\t\t}\n\t\t}\n\t\treturn lowest_common_ancestor(table[x].back(), y);\n\t}\n\tint get_ancestor(int des, int k) {\n\t\tif (k == 0) return des;\n\t\tint l = int(log2(k));\n\t\tif (l >= table[des].size()) return -1;\n\t\telse return get_ancestor(table[des][l], k - (1 << l));\n\t}\n\t// return first value causing \"t\" in evalfunc that returns descendant->[f,...,f,t,...,t]->root\n\t// NOTE: if [f,...,f] then return -1\n\ttemplate<typename bsargv_t>\n\tint upper_bsearch(int des, const bsargv_t &v, bool(*evalfunc)(int, const bsargv_t&)) {\n\t\tif (evalfunc(des, v)) return des;\n\t\tif (table[des].size() == 0) return -1;\n\t\tLoop1(i, table[des].size() - 1) {\n\t\t\tif (evalfunc(table[des][i], v)) {\n\t\t\t\treturn upper_bsearch(table[des][i - 1], v, evalfunc);\n\t\t\t}\n\t\t}\n\t\treturn upper_bsearch(table[des].back(), v, evalfunc);\n\t}\n};\n\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tvvi lst(n);\n\tLoop(i, n) {\n\t\tint c; cin >> c;\n\t\tLoop(_, c) {\n\t\t\tint x; cin >> x;\n\t\t\tlst[i].push_back(x);\n\t\t\tlst[x].push_back(i);\n\t\t}\n\t}\n\tAncestor anc(lst);\n\tint q; cin >> q;\n\tLoop(_, q) {\n\t\tint s, t; cin >> s >> t;\n\t\tcout << anc.lowest_common_ancestor(s, t) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n//初期化O(n log n) 区間最小値クエリO(1)\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\tSparseTableRMQ rmq;\n\t//RMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nstruct Edge {\n    long long to;\n};\nusing Graph = vector<vector<Edge>>;\n \nstruct LCA {\n    vector<vector<int>> parent; \n    vector<int> dist;           \n    LCA(const Graph &G, int root = 0) { init(G, root); }\n \n    void init(const Graph &G, int root = 0) {\n        int V = G.size();\n        int K = 1;\n        while ((1 << K) < V) K++;\n        parent.assign(K, vector<int>(V, -1));\n        dist.assign(V, -1);\n        dfs(G, root, -1, 0);\n        for (int k = 0; k + 1 < K; k++) {\n            for (int v = 0; v < V; v++) {\n                if (parent[k][v] < 0) {\n                    parent[k + 1][v] = -1;\n                } else {\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n \n    void dfs(const Graph &G, int v, int p, int d) {\n        parent[0][v] = p;\n        dist[v] = d;\n        for (auto e : G[v]) {\n            if (e.to != p) dfs(G, e.to, v, d + 1);\n        }\n    }\n \n    int query(int u, int v) {\n        if (dist[u] < dist[v]) swap(u, v); \n        int K = parent.size();\n        for (int k = 0; k < K; k++) {\n            if ((dist[u] - dist[v]) >> k & 1) {\n                u = parent[k][u];\n            }\n        }\n        if (u == v) return u;\n        for (int k = K - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n    int get_dist(int u, int v){\n        return dist[u] + dist[v] - 2 * dist[query(u, v)];\n    }\n\n    bool is_on_path(int u, int v, int a){\n        return get_dist(u, a) + get_dist(a, v) == get_dist(u, v);\n    }\n};\n\nGraph g;\n\nint main(){\n    int n, q;\n    cin >> n;\n    g.resize(n);\n    for(int i = 0; i < n; ++i){\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j){\n            int c;\n            cin >> c;\n            g[i].push_back({c});\n        }\n    }\n\n    LCA lca(g, 0);\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\n#define rep1(i, n) for(int i=1; i<=n; i++)\n#define repr(i, n) for(int i=n-1; i>=0; i--)\n#define repr1(i, n) for(int i=n; i>=1; i--)\n#define all(v) v.begin(),v.end()\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst ll MOD = 1e9+7;\nconst double EPS = 1e-10;\nconst double PI = acos(-1);\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> g(n);\n    vector<int> depth(n, 0);\n    vector<vector<int>> par(31, vector<int>(n, -1)); // par[k][u] := uの2^k先の親\n    rep(i, n) {\n        int k; cin >> k;\n        rep(j, k) {\n            int c; cin >> c;\n            g[i].push_back(c);\n            depth[c] = depth[i] + 1;\n            par[0][c] = i;\n        }\n    }\n\n    // ダブリングによる前処理\n    rep(k, 30) {\n        rep(i, n) {\n            par[k+1][i] = par[k][par[k][i]];\n        }\n    }\n\n    int q; cin >> q;\n    while (q--) {\n        int u, v; cin >> u >> v;\n        // uの方を深いとする\n        if (depth[u] < depth[v]) swap(u, v);\n        // LCAまでの距離を同じにする\n        // <=> u を depth[u] - depth[v] ぶんだけ親を辿る\n        rep(k, 30) {\n            if ((depth[u] - depth[v]) & (1 << k)) {\n                u = par[k][u];\n            }\n        }\n        // 二分探索でLCAを求める\n        if (u == v) {\n            cout << u << endl;\n        } else {\n            for (int k = 30; k >= 0; k--) {\n                if (par[k][u] != par[k][v]) {\n                    u = par[k][u];\n                    v = par[k][v];\n                }\n            }\n            cout << par[0][u] << endl;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nvector<int> G[100001];\nint N;\nint root;\nint MAX_LOG_V = 17;\n\nint** parent;\nint* depth;\n\nvoid dfs(int node_id,int parent_id,int d){\n\tparent[0][node_id] = parent_id;\n\tdepth[node_id] = d;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i] != parent_id)dfs(G[node_id][i],node_id,d+1);\n\t}\n}\n\n//?????????\nvoid init(){\n\tdfs(root,-1,0);\n\tfor(int k = 0; k + 1 < MAX_LOG_V; k++){\n\t\tfor(int node_id = 0; node_id < N; node_id++){\n\t\t\tif(parent[k][node_id] < 0)parent[k+1][node_id] = -1;\n\t\t\telse{\n\t\t\t\tparent[k+1][node_id] = parent[k][parent[k][node_id]];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint lca(int left,int right){\n\tif(depth[left] > depth[right])swap(left,right);\n\tfor(int k = 0; k < MAX_LOG_V; k++){\n\t\tif((depth[right]-depth[left]) >> k & 1){\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\tif(left == right)return left;\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(parent[k][left] != parent[k][right]){\n\t\t\tleft = parent[k][left];\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\treturn parent[0][left];\n}\n\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tint num,child;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&child);\n\t\t\tG[i].push_back(child);\n\t\t}\n\t}\n\n\tparent = new int*[MAX_LOG_V];\n\tfor(int i = 0; i < MAX_LOG_V;i++)parent[i] = new int[N];\n\tdepth = new int[N];\n\troot = 0;\n\tinit();\n\n\tint Q;\n\tscanf(\"%d\",&Q);\n\n\tint left,right;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\",&left,&right);\n\t\tprintf(\"%d\\n\",lca(left,right));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"/mnt/c/Users/leafc/dev/compro/lib/template.hpp\"\n\n\n#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n#define MM << \" \" <<\n\nusing namespace std;\n\ntemplate <class T> void say(bool val, T yes = \"Yes\", T no = \"No\") { cout << (val ? yes : no) << endl; }\n\ntemplate <class T> void chmin(T &a, T b) {\n  if (a > b)\n    a = b;\n}\n\ntemplate <class T> void chmax(T &a, T b) {\n  if (a < b)\n    a = b;\n}\n\n\n#line 2 \"tmp.cpp\"\n\nint anc(int u, int deg, const vector<vi> &doubling) {\n  int cur = u;\n  int cnt = 0;\n  while (deg > 0) {\n    if (cur == -1)\n      break;\n    if (deg % 2 == 1) {\n      cur = doubling[cnt][cur];\n    }\n    cnt++;\n    deg /= 2;\n  }\n  return cur;\n}\n\nint length(int n, int u, const vector<vi> &doubling) {\n  int ok = 0;\n  int ng = n;\n  while (abs(ok - ng) > 1) {\n    int mid = (ok + ng) / 2;\n    if (anc(u, mid, doubling) != -1) {\n      ok = mid;\n    } else {\n      ng = mid;\n    }\n  }\n  return ok;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  int log_n = ceil(log2(n) + 1);\n  vector<vi> doubling(log_n, vi(n, 0));\n  doubling[0][0] = -1;\n  REP(i, n) {\n    int k;\n    cin >> k;\n    REP(j, k) {\n      int c;\n      cin >> c;\n      doubling[0][c] = i;\n    }\n  }\n\n  REP(k, log_n - 1) {\n    REP(i, n) {\n      if (doubling[k][i] == -1) {\n        doubling[k + 1][i] = -1;\n      } else {\n        doubling[k + 1][i] = doubling[k][doubling[k][i]];\n      }\n    }\n  }\n\n  int q;\n  cin >> q;\n  REP(i, q) {\n    int u, v;\n    cin >> u >> v;\n    int lu = length(n, u, doubling), lv = length(n, v, doubling);\n    if (lu > lv) {\n      u = anc(u, lu - lv, doubling);\n    } else {\n      v = anc(v, lv - lu, doubling);\n    }\n\n    int ok = n;\n    int ng = -1;\n    while (abs(ok - ng) > 1) {\n      int mid = (ok + ng) / 2;\n      // cout << u MM mid MM anc(u, mid, doubling) << endl;\n      // cout << v MM mid MM anc(v, mid, doubling) << endl;\n      if (anc(u, mid, doubling) == anc(v, mid, doubling)) {\n        ok = mid;\n      } else {\n        ng = mid;\n      }\n    }\n    cout << anc(u, ok, doubling) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n\nusing Graph = std::vector<std::vector<int>>;\n\n/// LCA (Lowest Common Ancestor) by doubling.\n///\n/// The calculation order is as follows:\n///\n/// - Construction: O(N logN)\n/// - Query: O(logN)\n///\n/// Usage example:\n///\n/// ```\n/// int root = 0;\n/// LowestCommonAncestor lca(G, root);\n///\n/// for (int q = 0; q < Q; ++q) {\n///   int u, v;\n///   std::cin >> u >> v;\n///   std::cout << lca(u, v) << std::endl;\n/// }\n/// ```\nclass LowestCommonAncestor {\npublic:\n  LowestCommonAncestor(const Graph &G, const int root) {\n    // Get size\n    N = G.size();\n    M = 1; // 2^{M - 1} < N <= 2^M or M = ceil(log(N - 1)) + 1\n    while ((1 << M) < N)\n      ++M;\n\n    // Reserve memory\n    parent.assign(N, std::vector<int>(M, -1));\n    depth.assign(N, -1);\n\n    // Set depth and immediate parent\n    dfs(G, root, -1, 0);\n\n    // Seek ancestors by doubling\n    for (int k = 1; k < M; ++k)\n      for (int i = 0; i < N; ++i)\n        if (parent[i][k - 1] != -1)\n          parent[i][k] = parent[parent[i][k - 1]][k - 1];\n  }\n\n  int operator()(int u, int v) const {\n    if (depth[u] > depth[v])\n      std::swap(u, v);\n\n    // Lift `v` by `depth[v] - depth[u]` generations to align the depth\n    for (int k = 0; k < M; ++k)\n      if ((depth[v] - depth[u]) & (1 << k))\n        v = parent[v][k];\n\n    // Find lowest common ancestor\n    if (u == v)\n      return u;\n    for (int k = M - 1; k >= 0; --k) {\n      if (parent[u][k] != parent[v][k]) {\n        u = parent[u][k];\n        v = parent[v][k];\n      }\n    }\n    return parent[u][0];\n  }\n\nprivate:\n  int N;                                // number of nodes\n  int M;                                // number of doublings\n  std::vector<std::vector<int>> parent; // parent[v][d] := 2^d-th parent of v\n  std::vector<int> depth;\n\n  // Set depth and immediate parent\n  void dfs(const Graph &G, const int v, const int p, const int d) {\n    parent[v][0] = p;\n    depth[v] = d;\n    for (auto c : G[v]) {\n      if (c == p)\n        continue;\n      dfs(G, c, v, d + 1);\n    }\n  }\n};\n\nint main() {\n  // Input\n  int n;\n  std::cin >> n;\n\n  using Graph = std::vector<std::vector<int>>;\n  Graph G(n);\n  for (int i = 0; i < n; ++i) {\n    int K;\n    std::cin >> K;\n    G[i].resize(K);\n    for (int k = 0; k < K; ++k) {\n      int j;\n      std::cin >> j;\n      G[i][k] = j;\n    }\n  }\n\n  // Main\n  int root = 0;\n  LowestCommonAncestor lca(G, root);\n\n  int Q;\n  std::cin >> Q;\n  for (int q = 0; q < Q; ++q) {\n    int u, v;\n    std::cin >> u >> v;\n    std::cout << lca(u, v) << std::endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nint n;\nvector<int> vs[100005];\n\nint ans[100005];\n\nset<int> s[100005];\n\nvoid dfs(int no){\n\trep(i,vs[no].size()){\n\t\tdfs(vs[no][i]);\n\t}\n\t\n\trep(i,vs[no].size()){\n\t\tint to=vs[no][i];\n\t\tif(s[to].size()>s[no].size())swap(s[no],s[to]);\n\t\t\n\t\tfor(set<int>::iterator ite=s[to].begin(); ite!=s[to].end(); ite++){\n\t\t\tint p=*ite;\n\t\t\tif(s[no].count(p)>=1){\n\t\t\t\ts[no].erase(p);\n\t\t\t\tans[p]=no;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[no].insert(p);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\trep(j,k){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tvs[i].push_back(a);\n\t\t}\n\t}\n\t\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a==b)ans[i]=a;\n\t\telse{\n\t\t\ts[a].insert(i);\n\t\t\ts[b].insert(i);\n\t\t}\n\t}\n\t\n\tdfs(0);\n\t\n\trep(i,q){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nclass LowestCommonAncestor\n{\n    //2^k >= n\n    int n, k;\n    vector<vector<int>> g, par;\n    vector<int> dis;\n\n    inline void build()\n    {\n        this->dfs();\n        this->setpar();\n    }\n\n    void dfs(int v = 0, int p = -1)\n    {\n        this->par[0][v] = p;\n        for (int nv : this->g[v])\n        {\n            if (nv != p)\n            {\n                this->dis[nv] = this->dis[v] + 1;\n                this->dfs(nv, v);\n            }\n        }\n    }\n\n    void setpar()\n    {\n        for (int i = 0; i < this->k; i++)\n        {\n            for (int v = 0; v < this->n; v++)\n            {\n                if (this->par[i][v] != -1)\n                {\n                    this->par[i + 1][v] = this->par[i][par[i][v]];\n                }\n            }\n        }\n    }\n\npublic:\n    LowestCommonAncestor(int n_, vector<vector<int>> &g_) : n(n_), g(g_)\n    {\n        k = log2(n + 1);\n        this->par.resize(k + 1, vector<int>(n, -1));\n        dis.resize(n);\n        this->build();\n    }\n\n    int get(int u, int v)\n    {\n        //dis[u] <= dis[v]\n        if (this->dis[u] > this->dis[v])\n        {\n            swap(u, v);\n        }\n        int d = this->dis[v] - this->dis[u];\n        for (int i = k; i >= 0; i--)\n        {\n            if (d >> i & 1)\n            {\n                v = this->par[i][v];\n            }\n        }\n        if (u == v)\n        {\n            return v;\n        }\n        for (int i = k; i >= 0; i--)\n        {\n            if (this->par[i][u] != this->par[i][v])\n            {\n                u = this->par[i][u];\n                v = this->par[i][v];\n            }\n        }\n        return this->par[0][v];\n    }\n};\n\nint main(void)\n{\n    int n;\n    vector<vector<int>> g;\n    cin >> n;\n    g.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n        int k;\n        cin >> k;\n        while (k--)\n        {\n            int l;\n            cin >> l;\n            g[i].push_back(l);\n            g[l].push_back(i);\n        }\n    }\n    LowestCommonAncestor lca(n, g);\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.get(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<bool> vb;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nclass RMQ{\n\tprivate:\n\tvp rmq;\n\tvoid updatefunc(int x,int k,int num){\n\t\trmq[x].first=rmq[k].first;\n\t\trmq[x].second=num;\n\t}\n\tpublic:\n\tint n;\n\tvoid init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\trmq=vp(2*n-1,P(inf,-1));\n\t}\n\tvoid update(int k,int x){\n\t\tk+=n-1;\n\t\trmq[k].second=k-n+1;\n\t\trmq[k].first=x;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tif(rmq[k*2+1].first<rmq[k*2+2].first){\n\t\t\t\tupdatefunc(k,k*2+1,rmq[k*2+1].second);\n\t\t\t}\n\t\t\telse if(rmq[k*2+1].first>rmq[k*2+2].first){\n\t\t\t\tupdatefunc(k,k*2+2,rmq[k*2+2].second);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tupdatefunc(k,k*2+1,rmq[k*2+1].second);\n\t\t\t\tupdatefunc(k,k*2+2,rmq[k*2+2].second);\n\t\t\t}\n\t\t}\n\t}\n\tP query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return P(inf,-1);\n\t\tif(a<=l&&r<=b) return rmq[k];\n\t\telse{\n\t\t\tint mid=(l+r)/2;\n\t\t\tP vl=query(a,b,k*2+1,l,mid);\n\t\t\tP vr=query(a,b,k*2+2,mid,r);\n\t\t\treturn (vl.first<vr.first)?vl:vr;\n\t\t}\n\t}\n\tvoid open(){\n\t\tfor(int i=0;i<rmq.size();i++) cout<<rmq[i].first<<endl;\n\t\tfor(int i=0;i<rmq.size();i++) cout<<rmq[i].second<<endl;\n\t}\n};\n\nclass Graph{\n\tprivate:\n\tint GV;\n\tvvi List;\n\tvoid Euler(int x,int l,int& ind,vb& used){\n\t\teuler[ind]=x;\n\t\tlevel.update(ind,l);\n\t\tused[x]=1;\n\t\tif(disc[x]==-1) disc[x]=ind;\n\t\tind++;\n\t\tfor(int i=0;i<List[x].size();i++){\n\t\t\tint v=List[x][i];\n\t\t\tif(!used[v]){\n\t\t\t\tEuler(v,l+1,ind,used);\n\t\t\t\teuler[ind]=x;\n\t\t\t\tlevel.update(ind,l);\n\t\t\t\tind++;\n\t\t\t}\n\t\t}\n\t}\n\tpublic:\n\tvi euler,disc;\n\tRMQ\tlevel;\n\tGraph(int v){\n\t\tGV=v;\n\t\tList=vvi(v);\n\t}\n\tvoid add_edge(int x,int y){\n\t\tList[x].push_back(y);\n\t\tList[y].push_back(x);\n\t}\n\tvoid LCAprepare(){\n\t\teuler=vi(2*GV-1);\n\t\tdisc=vi(GV,-1);\n\t\tlevel.init(2*GV-1);\n\t\tint ind=0;\n\t\tvb used(GV);\n\t\tEuler(0,0,ind,used);\n\t}\n\tint LCA(int s,int t){\n\t\ts=disc[s];\n\t\tt=disc[t];\n\t\tif(s>t) swap(s,t);\n\t\tP index=level.query(s,t+1,0,0,level.n);\n\t\treturn euler[index.second];\n\t}\n};\n\nint V,Q;\n\nint main(){\n\tcin>>V;\n\tGraph gra(V);\n\tint n,s;\n\tfor(int i=0;i<V;i++){\n\t\tcin>>n;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>s;\n\t\t\tgra.add_edge(i,s);\n\t\t}\n\t}\n\tgra.LCAprepare();\n\tcin>>Q;\n\tint u,v;\n\tfor(int i=0;i<Q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<gra.LCA(u,v)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<vector>\n#include<cmath>\n#include<utility>\n\ntemplate<typename Label>\nclass RootedTree {\npublic:\n  void join(const Label& u, const Label& v) {\n    edge_[u].push_back(v);\n    edge_[v].push_back(u);\n  }\n  void initialize(const Label& root) {initialize(root, root, 0);}\n  int depth(const Label& v) const {return depth_.at(v);}\n  // v の d 番目の祖先を求める O(log(d))\n  Label ancestor(Label v, int d = 1) const {\n    for(int i = 1; i <= d; i <<= 1) if(d & i) v = ancestor_.at(v).at(i);\n    return v;\n  }\n  Label lca(Label u, Label v) const {\n    // u, v の深さを一致させる O(log(深さの差))\n    if(depth(v) < depth(u)) std::swap(u, v);\n    v = ancestor(v, depth(v) - depth(u));\n    // lca を求める O(log(深さ))\n    if(u == v) return u;\n    int bits = log2(depth(u));\n    for(int i = 1 << bits; 0 < i; i >>= 1) {\n      if(ancestor(u, i) == ancestor(v, i)) continue;\n      u = ancestor(u, i);\n      v = ancestor(v, i);\n    }\n    return ancestor(u, 1);\n  }\nprivate:\n  void initialize(const Label& current, const Label& previous, int depth) {\n    depth_[current] = depth;\n    for(int i = 2; i <= depth; i <<= 1) {ancestor_[current][i] = ancestor_[ancestor_[current][i >> 1]][i >> 1];}\n    for(const auto& v: edge_[current]) {\n      if(v == previous) continue;\n      ancestor_[v][1] = current;\n      initialize(v, current, depth + 1);\n    }\n  }\n  std::unordered_map<Label, int> depth_;\n  std::unordered_map<Label, std::vector<Label>> edge_;\n  std::unordered_map<Label, std::unordered_map<int, Label>> ancestor_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  RootedTree<int> t;\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      t.join(i, c);\n    }\n  }\n  t.initialize(0);\n\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << t.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rndf(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define rnddiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) * 2 >= (ll)(b) ? 1 : 0))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\ntypedef ll nodeval_t;\ntypedef ll edgeval_t;\n\nstruct tree_t {\n\tint n;           // |V|, index begins with 0\n\tvector<P> edges; // E\n\tvector<nodeval_t> vals; // value of nodes\n\tvector<edgeval_t> costs; // cost, distance, or weight of edges\n};\n\nclass Tree {\nprivate:\n\tstruct node {\n\t\tint id; vi childs; int parent = -1;\n\t\tint deg = -1; // the number of edges of the path to the root\n\t\tint eid = -1; // edge id of the edge connected by its parent and itself\n\t\tint subtree_n = -1; // the number of nodes of the partial tree rooted by itself\n\t\tint visited = -1; // time stamp of visiting on DFS\n\t\tint departed = -1; // time stamp of departure on DFS\n\t\tnodeval_t val; // value of the node itself\n\t\tedgeval_t cost; // cost of the edge connected by its parent and itself\n\t\tbool operator<(const node & another) const {\n\t\t\treturn deg != another.deg ? deg < another.deg : id < another.id;\n\t\t}\n\t};\n\tstruct edgeinfo {\n\t\tint eid; int to; edgeval_t cost;\n\t};\n\tint n;\n\tstatic const nodeval_t init_val = 0;\n\tstatic const edgeval_t init_cost = 1;\n\tvector<vector<edgeinfo>> edges;\n\tvvi sparse_ancestors;\n\tvoid tree_construction() {\n\t\tleaves = {};\n\t\tqueue<int> que;\n\t\tque.push(root);\n\t\twhile (que.size()) {\n\t\t\tint a = que.front(); que.pop();\n\t\t\tdeg_order.push_back(a);\n\t\t\tif (a == Tree::root) nodes[a].deg = 0;\n\t\t\tint leaf_flag = true;\n\t\t\tLoop(i, edges[a].size()) {\n\t\t\t\tint b = edges[a][i].to;\n\t\t\t\tif (nodes[b].deg != -1) {\n\t\t\t\t\tnodes[a].parent = b;\n\t\t\t\t\tnodes[a].eid = edges[a][i].eid;\n\t\t\t\t\tnodes[a].cost = edges[a][i].cost;\n\t\t\t\t\tnodes[a].deg = nodes[b].deg + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleaf_flag = false;\n\t\t\t\t\tnodes[a].childs.push_back(b);\n\t\t\t\t\tque.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (leaf_flag) leaves.push_back(a);\n\t\t}\n\t\tLoopr(i, n) {\n\t\t\tint a = deg_order[i];\n\t\t\tLoop(j, nodes[a].childs.size()) {\n\t\t\t\tint b = nodes[a].childs[j];\n\t\t\t\tnodes[a].subtree_n += nodes[b].subtree_n;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvector<node> nodes;\n\tvi deg_order; // node ids, sorted by deg\n\tvi leaves;\n\tint root;\n\t// T should be non-empty tree\n\tTree(tree_t T, int root = -1) {\n\t\tn = T.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tnodes[i].id = i;\n\t\t\tnodes[i].val = T.vals.size() > i ? T.vals[i] : 0;\n\t\t\tnodes[i].cost = init_cost;\n\t\t}\n\t\tedges.resize(n);\n\t\tLoop(i, n - 1) {\n\t\t\tedges[T.edges[i].first].push_back({ i, T.edges[i].second, (T.costs.size() > i ? T.costs[i] : init_cost) });\n\t\t\tedges[T.edges[i].second].push_back({ i, T.edges[i].first, (T.costs.size() > i ? T.costs[i] : init_cost) });\n\t\t}\n\t\t// the node which has the greatest degree will automatically decided as the root\n\t\tif (root < 0) {\n\t\t\tint max_d = -1;\n\t\t\tLoop(i, n) {\n\t\t\t\tif (edges[i].size() > max_d) {\n\t\t\t\t\tTree::root = i;\n\t\t\t\t\tmax_d = edges[i].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis->root = min(root, n - 1);\n\t\t}\n\t\ttree_construction();\n\t\treturn;\n\t}\n\tpair<int, vi> solve_center_of_gravity() {\n\t\tpair<int, vi> ret = { INT_MAX,{} };\n\t\tvector<node> c_nodes = nodes;\n\t\tsort(c_nodes.begin(), c_nodes.end());\n\t\tvi record(n, 1);\n\t\tLoopr(i, n) {\n\t\t\tint x = n - 1, max_x = INT_MIN;\n\t\t\tLoop(j, c_nodes[i].childs.size()) {\n\t\t\t\tint b = c_nodes[i].childs[j];\n\t\t\t\tmax_x = max(max_x, record[b]);\n\t\t\t\tx -= record[b];\n\t\t\t\trecord[c_nodes[i].id] += record[b];\n\t\t\t}\n\t\t\tmax_x = max(max_x, x);\n\t\t\tif (max_x < ret.first) ret = { max_x,{ c_nodes[i].id } };\n\t\t\telse if (max_x == ret.first) ret.second.push_back(c_nodes[i].id);\n\t\t}\n\t\tsort(ret.second.begin(), ret.second.end());\n\t\treturn ret;\n\t}\n\tvi solve_node_inclusion_cnt_in_all_path(bool enable_single_node_path) {\n\t\tvi ret(n, 0);\n\t\tLoop(i, n) {\n\t\t\tint a = i;\n\t\t\t// desendants to desendants\n\t\t\tLoop(j, nodes[a].childs.size()) {\n\t\t\t\tint b = nodes[a].childs[j];\n\t\t\t\tret[i] += nodes[b].subtree_n * (nodes[a].subtree_n - nodes[b].subtree_n - 1);\n\t\t\t}\n\t\t\tret[i] /= 2; // because of double counting\n\t\t\tret[i] += (nodes[a].subtree_n - 1) * (n - nodes[a].subtree_n); // desendants to the others except for itself\n\t\t\tret[i] += n - 1; // itself to the others\n\t\t\tif (enable_single_node_path) ret[i]++; // itself\n\t\t}\n\t\treturn ret;\n\t}\n\tvi solve_edge_inclusion_cnt_in_all_path() {\n\t\tvi ret(n - 1, 0);\n\t\tLoop(i, n) {\n\t\t\tint eid = nodes[i].eid;\n\t\t\tif (eid < 0) continue;\n\t\t\tret[eid] = nodes[i].subtree_n * (n - nodes[i].subtree_n); // members in the partial tree to the others\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid solve_sparse_ancestors() {\n\t\tsparse_ancestors.resize(n);\n\t\tvector<int> current_ancestors;\n\t\tstack<int> stk;\n\t\tstk.push(Tree::root);\n\t\tint time_stamp = 1;\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tnodes[a].visited = time_stamp++;\n\t\t\tfor (int i = 1; i <= current_ancestors.size(); i *= 2) {\n\t\t\t\tsparse_ancestors[a].push_back(current_ancestors[current_ancestors.size() - i]);\n\t\t\t}\n\t\t\tif (nodes[a].childs.size()) {\n\t\t\t\tLoop(i, nodes[a].childs.size()) {\n\t\t\t\t\tstk.push(nodes[a].childs[i]);\n\t\t\t\t}\n\t\t\t\tcurrent_ancestors.push_back(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].departed = time_stamp++;\n\t\t\t\twhile (current_ancestors.size() && (stk.empty() || nodes[stk.top()].parent != current_ancestors.back())) {\n\t\t\t\t\tnodes[current_ancestors.back()].departed = time_stamp++;\n\t\t\t\t\tcurrent_ancestors.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbool is_ancestor(int descendant, int ancestor) {\n\t\treturn nodes[ancestor].visited < nodes[descendant].visited\n\t\t\t&& nodes[descendant].departed < nodes[ancestor].departed;\n\t}\n\tint get_lowest_common_ancestor(int u, int v) {\n\t\tif (is_ancestor(u, v)) return v;\n\t\tif (is_ancestor(v, u)) return u;\n\t\tint a = u;\n\t\twhile (!is_ancestor(v, sparse_ancestors[a][0])) {\n\t\t\tint b = sparse_ancestors[a][0];\n\t\t\tLoop1(i, sparse_ancestors[a].size() - 1) {\n\t\t\t\tif (is_ancestor(v, sparse_ancestors[a][i])) break;\n\t\t\t\telse b = sparse_ancestors[a][i - 1];\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\treturn sparse_ancestors[a][0];\n\t}\n};\n\nint main() {\n\ttree_t T;\n\tcin >> T.n;\n\tLoop(i, T.n) {\n\t\tint m; cin >> m;\n\t\tLoop(j, m) {\n\t\t\tint t; cin >> t;\n\t\t\tT.edges.push_back({ i, t });\n\t\t}\n\t}\n\tTree tree(T, 0);\n\ttree.solve_sparse_ancestors();\n\tint q; cin >> q;\n\tLoop(i, q) {\n\t\tint s, t; cin >> s >> t;\n\t\tcout << tree.get_lowest_common_ancestor(s, t) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct LowestCommonAncestor{\n  int n,h;\n  vector<vector<int> > G,par;\n  vector<int> dep;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int sz):\n    n(sz),G(sz),dep(sz){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n  }\n\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    for(int i=0;i<(int)G[v].size();i++){\n      if(G[v][i]!=p) dfs(G[v][i],v,d+1);\n    }\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<h;k++){\n      for(int v=0;v<n;v++){\n\tif(par[k][v]<0) par[k+1][v]=-1;\n\telse par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int k=0;k<h;k++){\n      if((dep[v]-dep[u])>>k&1){\n\tv=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=h-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n\tu=par[k][u];\n\tv=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n;\n  cin>>n;\n  LowestCommonAncestor lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/11/20\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\ntemplate <typename T>\nclass SparseTable {\n\tint n;\n\tvector<vector<T>> t;\n\tT merge(const T& l, const T& r) {\n\t\treturn min(l, r);\n\t}\npublic:\n\tSparseTable(const vector<T>& b) {\n\t\tn = b.size();\n\t\tt.push_back(b);\n\t\tfor (int i = 2, j = 1; i <= n; i <<= 1, j++) {\n\t\t\tt.push_back(vector<T>());\n\t\t\tfor (int k = 0; k + i <= n; k++) {\n\t\t\t\tt[j].push_back(merge(t[j - 1][k], t[j - 1][k + i / 2]));\n\t\t\t}\n\t\t}\n\t}\n\tT find(int l, int r) {\n\t\tr++;\n\t\tassert(0 <= l && l < r && r < n);\n\t\tunsigned int w = r - l;\n\t\tint i = 31 - __builtin_clz(w);\n\t\treturn merge(t[i][l], t[i][r - (1 << i)]);\n\t}\n\tT operator[](int id) {\n\t\treturn t[0][id];\n\t}\n};\n\nclass LCA {\n\tint V, rt;\n\tvector<vector<int>> G;\n\tvector<int> depth, used, id;\n\tvector<int> vs, de;\n\tSparseTable<pii> st;\n\tvoid dfs(int s, int d) {\n\t\tused[s] = 1;\n\t\tvs.push_back(s);\n\t\tde.push_back(d);\n\t\tfor (int v : G[s]) {\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t\tvs.push_back(s);\n\t\t\t\tde.push_back(d);\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> init() {\n\t\tdfs(rt, 0);\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tif (id[vs[i]] == -1) id[vs[i]] = i;\n\t\t}\n\t\tvector<pii> r((int)vs.size());\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tr[i] = pii(de[i], vs[i]);\n\t\t}\n\t\treturn r;\n\t}\npublic:\n\tLCA(vector<vector<int>> G_, int rt_ = 0)\n\t\t: V(G_.size()), rt(rt_), G(G_), depth(V), used(V), id(V, -1), st(init()) {\n\t\tfor (int i = 0; i < V; i++) depth[i] = st[id[i]].first;\n\t}\n\tint calc(int a, int b) {\n\t\treturn st.find(min(id[a], id[b]), max(id[a], id[b])).second;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n;\n\tvector<vector<int>> G(n);\n\tfor (int i = 0, k; i < n; i++) {\n\t\tcin >> k;\n\t\tfor (int j = 0, c; j < k; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c > i) {\n\t\t\t\tG[i].push_back(c);\n\t\t\t\tG[c].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tLCA lca(G);\n\tcin >> q;\n\tfor (int i = 0, u, v; i < q; i++) {\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//lca\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\n/*\nlca(u,v)????????¨???O(logN)??§?±???????\n?????????O(NlogN)\np??¨depth???????????£????????°????????????genlca????????§????????????,?????¬?????°??????G???????????¶????????¨\n??????dfs+genlca??????????????????\n\npath???????§£????????¨??????[u,z) + [v,z) + z ?????????????????????, ???????????????????????????(depth-1???????????????)??¨ok\n\n*/\n\nint bsr(uint x){\t//4~7 -> 2\n\tif(x==0) return -1;\n\treturn 31 ^ __builtin_clz(x);\n}\nstruct LCA{\n\tint N,n;\n\tvector<int> depth;\n\tvector<vector<int>> par;\n\n\tvoid dfs(int v,int p,vector<vector<int>>& G){\n\t\tif(p<0) depth[v]=0;\n\t\telse depth[v]=depth[p]+1;\n\t\tpar[v][0]=p;\n\t\tfor(int u:G[v]){\n\t\t\tif(u!=p) dfs(u,v,G);\n\t\t}\n\t}\n\n\tLCA(const vector<vector<int>>& G){\n\t\tN = G.size();\n\t\tn = bsr(N);\n\t\tdepth = vector<int>(N,0);\n\t\tpar = vector<vector<int>>(N,vector<int>(n+1,0));\n\n\t\tdfs(0,-1,G);\n\t\trep1(i,n){\n\t\t\trep(v,N){\n\t\t\t\tif(par[v][i-1]==-1){\n\t\t\t\t\tpar[v][i]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tpar[v][i]=par[par[v][i-1]][i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint lca(int u,int v){\n\t\tif(depth[u]<depth[v]){\n\t\t\tswap(u,v);\n\t\t}\n\t\tint d=depth[u]-depth[v];\n\t\trep(i,n+1){\n\t\t\tif((d>>i)&1) u=par[u][i];\n\t\t}\n\t\tif(u==v) return u;\n\t\tfor(int i=n;i>=0;i--){\n\t\t\tif(par[u][i]!=par[v][i]){\n\t\t\t\tu=par[u][i];\n\t\t\t\tv=par[v][i];\n\t\t\t}\n\t\t}\n\t\treturn par[v][0];\n\t}\n\n\tint distance(int u,int v){\n\t\treturn depth[u] + depth[v] - 2*depth[lca(u,v)];\n\t}\n};\n\n\nint main(){\n\tint N,Q;\n\tcin>>N;\n\tvector<vector<int>> G(N);\n\trep(i,N){\n\t\tint n;\n\t\tcin>>n;\n\t\trep(j,n){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tG[i].pb(x);\n\t\t\tG[x].pb(i);\n\t\t}\n\t}\n\tLCA lca(G);\n\tcin>>Q;\n\trep(q,Q){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tcout<<lca.lca(x,y)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 310;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010/B + B];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val,E laz):\n      cnt(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using S = function<T(T)>;\n  F f;\n  G g;\n  H h;\n  S s;\n  T ti;\n  E ei;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  \n  LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n    s=[](T a){return a;};\n  }\n  \n  LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v,ei));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,v);\n    t->dat=g(t->dat,v);\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->dat=s(t->dat);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    eval(t);\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\teval(q);eval(t);\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\teval(r);eval(q);eval(t);\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(c);\n    expose(par);\n    c->p=par;\n    par->r=c;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=nullptr;\n    par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  bool is_connected(Node *a,Node *b){\n    expose(a);\n    while(a->l) a=a->l;\n    expose(b);\n    while(b->l) b=b->l;\n    return a==b;\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n\n  void set_propagate(Node *t,E v){\n    expose(t);\n    propagate(t,v);\n    eval(t);\n  }\n};\n\n//END CUT HERE\n//INSERT ABOVE HERE\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_C\n*/\n\nsigned GRL_5_D(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return a+b;};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.expose(v[a]);\n      v[a]->val=f(v[a]->val,b);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_D\n*/\n\n\nsigned GRL_5_E(){\n  int n;\n  cin>>n;\n  using P = pair<int, int>;\n  using LCT = LinkCutTree<P, Int>;\n  auto f=[](P a,P b){return P(a.first+b.first,a.second+b.second);};\n  auto g=[](P a,int b){return P(a.first+b*a.second,a.second);};\n  auto h=[](Int a,Int b){return a+b;};\n  \n  LCT lc(f,g,h,P(0,0),0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,P(0,0));\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  Int c=0;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.set_propagate(v[a],b);\n      c+=b;\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat.first-c<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_E\n*/\n\nsigned JOISC2013_DAY4_3(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  \n  using LCT = LinkCutTree<int, int>;\n  auto f=[](int a,int b){return a+b;};\n  LCT lct(f,f,f,0,0);\n  vector<LCT::Node*> vs(n);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,0);\n\n  for(int i=0;i<q;i++){\n    int t,a,b=0;\n    scanf(\"%d %d\",&t,&a);\n    if(t!=2) scanf(\"%d\",&b);\n    a--;b--;\n    if(t==1) lct.link(vs[b],vs[a]);\n    if(t==2) lct.cut(vs[a]);\n    if(t==3){\n      if(!lct.is_connected(vs[a],vs[b])) puts(\"-1\");\n      else printf(\"%d\\n\",lct.lca(vs[a],vs[b])->idx+1);\n    }\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  https://beta.atcoder.jp/contests/joisc2013-day4/tasks/joisc2013_spaceships\n*/\n\nsigned AOJ_2450(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n\n  using T = tuple<int,int,int,int,int,int,int>;\n  using P = pair<int,int>;\n  using LCT = LinkCutTree<T, P>;\n\n  vector<vector<int> > G(n); \n  T d1(-1,-1,-1,-1,-1,-1,-1);\n  P d0(-1,-114514);\n  \n  vector<LCT::Node* > vs(n);\n  vector<int> ps(n,-1);\n  \n  auto f=[&](T a,T b){\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int bl,br,bs,bva,bvi,bvl,bvr;\n    tie(bl,br,bs,bva,bvi,bvl,bvr)=b;\n    int cl=al,cr=br,cs=as+bs;\n    int cva=ava+bva,cvi=max(avi,bvi),cvl=avl,cvr=bvr;\n    cvi=max(cvi,avr+bvl);\n    cvl=max(cvl,ava+bvl);\n    cvr=max(cvr,avr+bva);\n    return T(cl,cr,cs,cva,cvi,cvl,cvr);\n  };\n  \n  auto g=[&](T a,P p){\n    if(p==d0) return a;\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int v=p.first,b=p.second;\n    if(~v) al=ar=v,as=1;\n    if(b>=0) return T(al,ar,as,b*as,b*as,b*as,b*as);\n    return T(al,ar,as,b*as,b,b,b);\n  };\n  \n  auto h=[&](P a,P b){a.first++;return b;};\n  auto s=\n    [&](T a){      \n      int al,ar,as,ava,avi,avl,avr;\n      tie(al,ar,as,ava,avi,avl,avr)=a;\n      swap(al,ar);\n      swap(avl,avr);\n      return T(al,ar,as,ava,avi,avl,avr);\n    };\n  \n  LCT lct(f,g,h,s,d1,d0);\n  \n  vector<int> w(n);\n  for(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,g(d1,P(i,w[i])));\n  \n  for(int i=0;i<n-1;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n\n  for(int i=0;i<n;i++)\n    sort(G[i].begin(),G[i].end());\n\n  {\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    }\n  }\n  \n  while(q--){\n    int t,a,b,c;\n    scanf(\"%d %d %d %d\",&t,&a,&b,&c);\n    a--;b--;\n    if(t==1){\n      lct.evert(vs[a]);\n      lct.set_propagate(vs[b],P(-1,c));      \n    }\n    if(t==2){\n      lct.evert(vs[a]);\n      lct.expose(vs[b]);\n      int vva,vvi,vvl,vvr;\n      tie(ignore,ignore,ignore,vva,vvi,vvl,vvr)=vs[b]->dat;\n      printf(\"%d\\n\",max({vva,vvi,vvl,vvr}));\n    }\n  }\n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2450\n*/\n\nsigned AOJ_0367(){\n  int n,k;\n  cin>>n>>k;\n  \n  vector<vector<int> > G(n); \n  vector<map<Int, Int> > m(n);\n  for(Int i=0;i<n-1;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n    m[a][b]=m[b][a]=c;\n  }\n  \n  vector<Int> w(n,0);\n  vector<int> ps(n,-1);\n  using T = tuple<Int, Int, Int>;\n  auto mget=[&](Int a,Int b){\n\t      if(ps[a]!=b&&ps[b]!=a) return 0LL;\n\t      Int res=w[a]+w[b]+m[a][b];\n\t      if(res%k) return res;\n\t      return 0LL;\n\t    };\n  \n  auto f=[&](T a,T b){\n\t   if(a>b) swap(a,b);\n\t   Int al,ar,av;\n\t   tie(al,ar,av)=a;\n\t   Int bl,br,bv;\n\t   tie(bl,br,bv)=b;\n\t   if(al<0||ar<0) return b;\n\t   Int cl,cr,cv=av+bv;\n\t   if(m[al].count(bl)){\n\t     cl=ar;cr=br;\n\t     cv+=mget(al,bl);\n\t   }else if(m[al].count(br)){\n\t     cl=ar;cr=bl;\n\t     cv+=mget(al,br);\n\t   }else if(m[ar].count(bl)){\n\t     cl=al;cr=br;\n\t     cv+=mget(ar,bl);\n\t   }else if(m[ar].count(br)){\n\t     cl=al;cr=bl;\n\t     cv+=mget(ar,br);\n\t   }else{\n\t     cl=cr=cv=-1;\n\t   }\n\t   return T(cl,cr,cv);\n\t };\n  \n  auto g=[&](T a,Int b){b++;return a;};\n  auto h=[&](Int a,Int b){b++;return a;};\n  \n  using LCT = LinkCutTree<T, Int>;\n  LCT lct(f,g,h,T(-1,-1,0),0);  \n  vector<LCT::Node* > vs(n);\n  for(Int i=0;i<n;i++) vs[i]=lct.create(i,T(i,i,0));\n  \n  {\n    using P = pair<Int, Int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    } \n  }\n  \n  Int q;\n  cin>>q;\n  while(q--){\n    string op;\n    cin>>op;\n    if(op==\"add\"){\n      Int x,d;\n      cin>>x>>d;\n      lct.expose(vs[x]);\n      w[x]+=d;\n      lct.update(vs[x]);\n    }\n    if(op==\"send\"){\n      Int s,t;\n      cin>>s>>t;\n      lct.evert(vs[s]);\n      lct.expose(vs[t]);\n      cout<<get<2>(vs[t]->dat)<<endl;\n    }\n  }  \n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0367\n*/\n\n\n\nstruct M{\n  Int a,b,c,d;\n  M():a(1),b(0),c(0),d(1){}\n  M(Int a,Int b,Int c,Int d):a(a),b(b),c(c),d(d){}\n  //M(const M &v):a(v.a),b(v.b),c(v.c),d(v.d){}\n  bool operator!=(const M &x)const{\n    return a!=x.a||b!=x.b||c!=x.c||d!=x.d;\n  }\n  bool operator==(const M &x)const{\n    return !(*this!=x);\n  }\n};\n\nsigned YUKI_650(){\n  const int MOD=1e9+7;\n  using M2 = pair<M, M>;\n  using LCT = LinkCutTree<M2, M2>;\n  auto f=[MOD](M x,M y){\n\t   M r(0,0,0,0);\n\t   r.a=x.a*y.a+x.b*y.c;\n\t   r.b=x.a*y.b+x.b*y.d;\n\t   r.c=x.c*y.a+x.d*y.c;\n\t   r.d=x.c*y.b+x.d*y.d;\t   \n\t   r.a%=MOD;r.b%=MOD;r.c%=MOD;r.d%=MOD;\n\t   return r;\n\t };\n  auto f2=[&](M2 x,M2 y){\n\t    return M2(f(x.first,y.first),f(y.second,x.second));\n\t  };\n  auto g=[](M2 x,M2 y){x.first.a++;return y;};\n  auto s=[](M2 x){swap(x.first,x.second);return x;};\n  \n  int n;\n  cin>>n;\n  vector<vector<int> > G(n);\n  vector<int> X,Y;\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    X.emplace_back(a);\n    Y.emplace_back(b);\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  M ti=M();\n  M ei(-1,-1,-1,-1);\n  LCT lct(f2,g,g,s,M2(ti,ti),M2(ei,ei));\n\n  \n  vector<LCT::Node*> vs(n*2-1);\n  for(int i=0;i<(int)vs.size();i++) vs[i]=lct.create(i,M2(ti,ti));\n  \n  vector<map<int, int> > rev(n);\n  int idx=n;\n  {\n    using P = pair<int, int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p){\n\tlct.link(vs[p],vs[idx]);\n\tlct.link(vs[idx],vs[v]);\n\trev[p][v]=rev[v][p]=idx++;\n      }\n      for(int u:G[v])\n\tif(u!=p) q.emplace(u,v);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    char c;\n    cin>>c;\n    if(c=='x'){\n      Int v,a,b,c,d;\n      cin>>v>>a>>b>>c>>d;\n      int z=rev[X[v]][Y[v]];\n      lct.expose(vs[z]);\n      vs[z]->val=M2(M(a,b,c,d),M(a,b,c,d));      \n      lct.expose(vs[z]);\n    }\n    if(c=='g'){\n      Int x,y;\n      cin>>x>>y;\n      lct.evert(vs[x]);\n      lct.expose(vs[y]);\n      M ans=vs[y]->dat.first;\n      cout<<ans.a<<\" \"<<ans.b<<\" \"<<ans.c<<\" \"<<ans.d<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://yukicoder.me/problems/no/650\n*/\n\n\nsigned main(){\n  GRL_5_C();\n  //GRL_5_D();\n  //GRL_5_E();\n  //JOISC2013_DAY4_3();\n  //AOJ_2450();\n  //AOJ_0367();\n  //YUKI_650();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < N; i++) { sort(D[i].begin(), D[i].end()); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\tif (W == 0 || (Depth[b[A]] == 1 && Depth[b[B]] == 1 && A != B)) { cout << \"0\" << endl; continue; }\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass LcaByDoubling {\n    int N;\n    int logN;\n    vector<vector<int>> table;\n    vector<int> depths;\n\n    // dp[i][j] = 2**j th parent node from i th node\n    vector<vector<int>> dp;\n\n    void calc_depth(int node, int par, int depth) {\n        depths[node] = depth;\n        dp[node][0] = par;\n        for (int next : table[node]) {\n            if (next == par) continue;\n            calc_depth(next, node, depth + 1);\n        }\n    }\n\n    void calc_dp() {\n        for (int k = 1; k < logN; k++) {\n            for (int i = 0; i < N; i++) {\n                if (dp[i][k-1] == -1) dp[i][k] = -1;\n                else dp[i][k] = dp[dp[i][k-1]][k-1];\n            }\n        }\n    }\n\npublic:\n    LcaByDoubling(const vector<vector<int>> &table, int root) : table(table) {\n        N = table.size();\n        logN = (sizeof(int) * 8) - __builtin_clz(N);\n        depths.resize(N);\n        dp.resize(N);\n        for (int i = 0; i < N; i++) dp[i].resize(logN, -1);\n        calc_depth(root, -1, 0);\n        calc_dp();\n    }\n\n    // O(logN)\n    int lca(int u, int v) {\n        // Assume depths[u] <= depths[v]\n        if (depths[u] > depths[v]) swap(u, v);\n\n        // Equalize depth\n        int diff = depths[v] - depths[u];\n        for (int k = 0; k < logN; k++) {\n            if ((diff >> k) & 1) v = dp[v][k];\n        }\n\n        if (u == v) return u;\n\n        // Popup both nodes just below the lca\n        for (int k = logN - 1; k >= 0; k--) {\n            if (dp[u][k] != dp[v][k]) {\n                u = dp[u][k];\n                v = dp[v][k];\n            }\n        }\n\n        return dp[u][0];\n    }\n};\n\n// Verified at http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main() {\n    int N;\n    cin >> N;\n    vector<bool> is_root(N, true);\n    vector<vector<int>> table(N);\n\n    for (int i = 0; i < N; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            is_root[c] = false;\n            table[i].push_back(c);\n            table[c].push_back(i);\n        }\n    }\n\n    int root = -1;\n    for (int i = 0; i < N; i++) if (is_root[i]) root = i;\n\n    auto solver = new LcaByDoubling(table, root);\n\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int u, v;\n        cin >> u >> v;\n        cout << solver->lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nconst int MAXV = 100100;\nvector<int> children[MAXV];\nint parent[30][MAXV];\nint depth[MAXV];\n\nint n;\n\nvoid dfs(int v, int d) {\n    depth[v] = d;\n    for (int i = 0; i < children[v].size(); i++) {\n        dfs(children[v][i], d+1);\n    }\n}\n\nvoid init(int V) {\n    dfs(0, 0);\n    for (int k = 0; k < 30; k++) {\n        for (int v = 0; v < V; v++) {\n            if (parent[k][v] < 0) parent[k+1][v] = -1;\n            else parent[k+1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < 30; k++) {\n        if ((depth[v] - depth[u]) >> k & 1) {\n            v = parent[k][v];\n        }\n    }\n    if (u == v) return u;\n    for (int k = 29; k >= 0; k--) {\n        if (parent[k][u] != parent[k][v]) {\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(void) {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            children[i].push_back(c);\n            parent[0][c] = i;\n        }\n    }\n    init(n);\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\nconst int MAXN = 100010;\nint n, l, timer=0;\nvector<int> grf[MAXN];\nvector<vector<int>> up;\nint tin[MAXN],tout[MAXN];\n\nbool isancestor(int u,int v){\n    return tin[u]<=tin[v] and tout[u]>=tout[v];\n}\n\nint lca(int u,int v){\n    if( isancestor(u,v)) return u;\n    if( isancestor(v,u)) return v;\n    for(int i=l; i>=0; i--){\n        if( !isancestor(up[u][i],v)){\n            u = up[u][i];\n        }\n    }\n    return up[u][0];\n}\n\nvoid dfs(int node, int p){\n    tin[node] = ++timer;\n    up[node][0] = p;\n\n    // initialise its ancestors\n    for(int i=1; i<=l; i++){\n        up[node][i] = up[ up[node][i-1] ][i-1];\n    }\n    // go only in subtree\n    for(auto nbr : grf[node]){\n        if( nbr!= p){\n            dfs(nbr,node);\n        }\n    }\n    tout[node] = ++timer;\n}\n\nvoid init(int root){\n    l = (int) ceil(log2(n));\n    up.assign(n+1,vector<int>(l+1));\n    dfs(root,root);\n}\n\nint main() {\n    // freopen(\"./input.txt\",\"r\",stdin);\n    // freopen(\"./output.txt\",\"w\",stdout);\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    cin>>n;\n    int x,ch; \n    for(int i=0; i<n; i++){\n        cin>>ch;\n        while(ch--){\n            cin>>x;\n            grf[i].push_back(x);\n        }\n    }\n    init(0);\n    int q; cin>>q;\n    while(q--){\n        int u,v; cin>>u>>v;\n        cout<< lca(u,v) <<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int MAX_N = 1e5;\nconst int MAX_M = (MAX_N << 1) - 1;\nconst int LSIZE = (MAX_M + 7) >> 3;\n\npii table[15][LSIZE];\npii mini[9][1 << 7];\nint buck[LSIZE];\nint off[LSIZE];\n\n\nint it = 0;\n\nint vs[MAX_M];\nint id[MAX_N];\n\nint n;\nvector<int> G[MAX_N];\n\nvoid dfs(int v) {\n\tid[v] = it;\n\tif (it) {\n\t\tbuck[(it - 1) >> 3] |= 1 << ((it - 1) & 7);\n\t}\n\tvs[it++] = v;\n\tfor (auto to : G[v]) {\n\t\tdfs(to);\n\t\tvs[it++] = v;\n\t}\n}\n\nvoid bitDP() {\n\tmini[0][0] = { 1e9, -100 };\n\tfor (int b = 0; b < 8; b++) {\n\t\tfor (int i = 0; i < (1 << b); i++) {\n\t\t\tint mi = 0, id = 0, t = 0;\n\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\tt += (((i >> j) & 1) << 1) - 1;\n\t\t\t\tif (t < mi) {\n\t\t\t\t\tmi = t;\n\t\t\t\t\tid = j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmini[b + 1][i] = { mi, id };\n\t\t}\n\t}\n}\n\nvoid init() {\n\tbitDP();\n\tint m = (n << 1) - 1;\n\tint l = (m + 7) >> 3;\n\tdfs(0);\n\toff[0] = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tpii tmp = mini[min(m - 1 - (i << 3), 8)][buck[i] & ((1 << 7) - 1)];\n\t\ttable[0][i] = { tmp.first + off[i], tmp.second + (i << 3) };\n\t\toff[i + 1] = off[i] + (__builtin_popcount(buck[i]) << 1) - 8;\n\t}\n\tint h = 31 - __builtin_clz(l);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j + (1 << i) < l; j++) {\n\t\t\ttable[i + 1][j] = min(table[i][j], table[i][j + (1 << i)]);\n\t\t}\n\t}\n}\n\npii get_buck(int l, int r) {\n\tpii tmp = mini[r - l][(buck[l >> 3] & ((1 << ((r - 1) & 7)) - 1)) >> (l & 7)];\n\treturn pii(off[l >> 3] + (__builtin_popcount(buck[l >> 3] & ((1 << (l & 7)) - 1)) << 1) - (l & 7) + tmp.first, l + tmp.second);\n}\n\nint lca(int u, int v) {\n\tu = id[u], v = id[v];\n\tif (u > v) swap(u, v);\n\tv++;\n\tif (((u + 7) >> 3) > (v >> 3)) {\n\t\treturn vs[u + mini[v - u][(buck[u >> 3] & ((1 << ((v - 1) & 7)) - 1)) >> (u & 7)].second];\n\t}\n\tpii left = get_buck(u, (u + 7) & (~7));\n\tpii right = get_buck(v & (~7), v);\n\tu = (u + 7) >> 3;\n\tv >>= 3;\n\tif (u == v) {\n\t\treturn vs[min(left, right).second];\n\t}\n\tint b = 31 - __builtin_clz(v - u);\n\treturn vs[min(min(left, right), min(table[b][u], table[b][v - (1 << b)])).second];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\ntemplate <typename G>\nstruct HLD {\n  G &g;\n  vector<int> sz, in, out, head, rev, par;\n  HLD(G &g) :\n      g(g), sz(g.size()), in(g.size()), out(g.size()), head(g.size()), rev(g.size()), par(g.size()) {}\n\n  void dfs_sz(int idx, int p) {\n    par[idx] = p;\n    sz[idx] = 1;\n    if(g[idx].size() && g[idx][0] == p) swap(g[idx][0], g[idx].back());\n    for(auto &to : g[idx]) {\n      if(to == p) continue;\n      dfs_sz(to, idx);\n      sz[idx] += sz[to];\n      if(sz[g[idx][0]] < sz[to]) swap(g[idx][0], to);\n    }\n  }\n\n  void dfs_hld(int idx, int par, int &times) {\n    in[idx] = times++;\n    rev[in[idx]] = idx;\n    for(auto &to : g[idx]) {\n      if(to == par) continue;\n      head[to] = (g[idx][0] == to ? head[idx] : to);\n      dfs_hld(to, idx, times);\n    }\n    out[idx] = times;\n  }\n\n  void build() {\n    dfs_sz(0, -1);\n    int t = 0;\n    dfs_hld(0, -1, t);\n  }\n\n  int la(int v, int k) {\n    while(1) {\n      int u = head[v];\n      if(in[v] - k >= in[u]) return rev[in[v] - k];\n      k -= in[v] - in[u] + 1;\n      v = par[u];\n    }\n  }\n\n  int lca(int u, int v) {\n    for(;; v = par[head[v]]) {\n      if(in[u] > in[v]) swap(u, v);\n      if(head[u] == head[v]) return u;\n    }\n  }\n\n  template <typename T, typename Q, typename F>\n  T query(int u, int v, const T &ti, const Q &q, const F &f, bool edge = false) {\n    T l = ti, r = ti;\n    for(;; v = par[head[v]]) {\n      if(in[u] > in[v]) swap(u, v), swap(l, r);\n      if(head[u] == head[v]) break;\n      l = f(q(in[head[v]], in[v] + 1), l);\n    }\n    return f(f(q(in[u] + edge, in[v] + 1), l), r);\n//  return {f(q(in[u] + edge, in[v] + 1), l), r};\n  }\n\n  template <typename Q>\n  void add(int u, int v, const Q &q, bool edge = false) {\n    for(;; v = par[head[v]]) {\n      if(in[u] > in[v]) swap(u, v);\n      if(head[u] == head[v]) break;\n      q(in[head[v]], in[v] + 1);\n    }\n    q(in[u] + edge, in[v] + 1);\n  }\n};\n\n\nint main(int argc, char const *argv[]) {\n  ll n, a, x, y;scanf(\"%lld\", &n);\n  vvl G = VV(n, 0, 0, ll);\n  HLD<vvl> h(G);\n\n  for(int i=0;i<n;i++){\n    ll k;scanf(\"%lld\", &k);\n    for(int j=0;j<k;j++){\n      scanf(\"%lldd\", &a);\n      G[i].push_back(a);\n      G[a].push_back(i);\n    }\n  }\n  h.build();\n  ll q;scanf(\"%lld\", &q);\n  for(int i=0;i<q;i++){\n    scanf(\"%lld %lld\", &x, &y);\n    printf(\"%d\\n\", h.lca(x, y));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n  LowestCommonAncestor(size_t size) : size(size), G(size), dep(size), par(MaxlgV, vector<int>(size)) {}\n\n  size_t size, MaxlgV = 30;\n  int root;\n  vector<vector<int>> G, par;\n  vector<int> dep;\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n\n    cerr << u << \" <-> \" << v << endl;\n  }\n\n  void dfs(int v, int u, int d) {\n    dep[v] = d;\n    par[0][v] = u;\n    for (int e : G[v])\n      if (e != u) dfs(e, v, d + 1);\n  }\n\n  void build(int r) {\n    dfs(root = r, -1, 0);\n    for (int k = 0; k + 1 < MaxlgV; k++) {\n      for (int v = 0; v < size; v++) {\n        if (par[k][v] < 0)\n          par[k + 1][v] = -1;\n        else\n          par[k + 1][v] = par[k][par[k][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if (dep[u] > dep[v]) swap(u, v);\n    for (int k = 0; k < MaxlgV; k++) {\n      if ((dep[v] - dep[u]) >> k & 1) {\n        v = par[k][v];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int k = MaxlgV - 1; k >= 0; k--) {\n      if (par[k][u] != par[k][v]) {\n        u = par[k][u];\n        v = par[k][v];\n      }\n    }\n\n    return par[0][u];\n  }\n\n  int dist(int u, int v) {\n    int z = lca(u, v);\n    return dep[u] + dep[v] - 2 * dep[z];\n  }\n};\n\n// https://onlinejudge.u-aizu.ac.jp/#/courses/library/5/GRL/5/GRL_5_C\nint main() {\n  int N;\n  cin >> N;\n\n  LowestCommonAncestor tree(N);\n  for (int i = 0; i < N; ++i) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int c;\n      cin >> c;\n\n      tree.add_edge(i, c);\n    }\n  }\n\n  tree.build(0);\n\n  int q;\n  cin >> q;\n\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n\n    cout << tree.lca(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int> Y[1 << 17]; int N, A, B, Q, X[1 << 17];\nint Solve(int S, int T) {\n\tint D = Y[S].size(), L = 0; if (D > Y[T].size()) { D = Y[T].size(); }\n\tfor (int i = 0; i < D; i++) {\n\t\tint V1 = Y[S].size() - i - 1, V2 = Y[T].size() - i - 1;\n\t\tif (Y[S][V1] != Y[T][V2]) { return L; }L = Y[S][V1];\n\t}return L;\n}\nint main() {\n\tcin >> N; for (int i = 0; i < N; i++) { cin >> A; for (int j = 0; j < A; j++) { cin >> B; X[B] = i; } }\n\tfor (int i = 0; i < N; i++) { int cx = i; Y[i].push_back(cx); while (cx>0) { cx = X[cx]; Y[i].push_back(cx); } }\n\tcin >> Q; for (int i = 0; i < Q; i++) { cin >> A >> B; cout << Solve(A, B) << endl; }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathRoot;\n  vector<vector<int> > tree;\n\n  HeavyLight(vector<vector<int> > t)\n    :pathCount(0),n(t.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathRoot(n),tree(t){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\n// graph by adjacency list\ntemplate <typename T>\nstruct Edge {\n  int dst; T weight;\n  Edge(int dst, T weight) : dst(dst), weight(weight) { }\n  bool operator < (const Edge<T> &e) const {\n    return weight > e.weight;\n  }\n};\n\ntemplate <typename T>\nstruct Graph {\n  int V;\n  vector<vector<Edge<T>>> E;\n  Graph(int V) : V(V) { E.resize(V); }\n  void add_edge(int src, int dst, T weight) {\n    E[src].emplace_back(dst, weight);\n  }\n};\n\ntemplate <typename T>\nstruct HeavyLightDecomposition {\n  const Graph<T> g;\n  vector<int> vid, head, heavy, parent;\n  HeavyLightDecomposition(const Graph<T> g, int root = 0) : g(g), vid(g.V, -1), head(g.V), heavy(g.V, -1), parent(g.V) {\n    dfs(root, -1);\n    bfs(root);\n  }\n\n  int dfs(int v, int par) {\n    parent[v] = par;\n    int sub = 1, max_sub = 0;\n    for (Edge<T> child : g.E[v]) {\n      if (child.dst != par) {\n        int child_sub = dfs(child.dst, v);\n        sub += child_sub;\n        if (child_sub > max_sub) {\n          max_sub = child_sub;\n          heavy[v] = child.dst;\n        }\n      }\n    }\n    return sub;\n  }\n\n  void bfs(int root = 0) {\n    int k = 0;\n    queue<int> que({root});\n    while (not que.empty()) {\n      int r = que.front(); que.pop();\n      for (int v = r; v != -1; v = heavy[v]) {\n        vid[v] = k++;\n        head[v] = r;\n        for (Edge<T> child : g.E[v]) {\n          if (child.dst != parent[v] and child.dst != heavy[v]) que.emplace(child.dst);\n        }\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    while(head[u] != head[v]) {\n      if (vid[u] > vid[v]) swap(u, v);\n      v = parent[head[v]];\n    }\n    if (vid[u] > vid[v]) swap(u, v);\n    return u;\n  }\n};\n\nint main() {\n  int N; scanf(\"%d\", &N);\n  Graph<int> g(N);\n  REP(i, N) {\n    int k; scanf(\"%d\", &k);\n    REP(_, k) {\n      int c; scanf(\"%d\", &c);\n      g.add_edge(i, c, 1);\n      g.add_edge(c, i, 1);\n    }\n  }\n\n  HeavyLightDecomposition<int> hld(g);\n\n  int Q; scanf(\"%d\", &Q);\n  REP(_, Q) {\n    int u, v; scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", hld.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];\nint size[MAX];\nint par[MAX];\n//int cur[MAX];\nint dep[MAX];\nint depth[MAX];\n//int het[MAX];\nint parent[MAX];\n\nvoid idfs(int pos,int prev){\n  int m=-1;\n  parent[pos]=prev;\n  if(G[pos].size()==1&&prev!=-1)return;  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    depth[to]=depth[pos]+1;\n    idfs(to,pos);\n    size[pos]+=size[to];\n    //het[pos]=max(het[pos],het[to]+1);\n    if(m==-1||size[m]<size[to]){\n      m=to;\n    }\n  }\n  //cur[pos]=m;\n  par[m]=pos;\n  //het[pos]=max(het[pos],het[m]);\n}\n\nint calc(int x){\n  if(par[x]==x)return x;\n  return par[x]=calc(par[x]);\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    //G[i].clear();\n    size[i]=1;\n    par[i]=i;\n    //cur[i]=-1;\n    //dep[i]=0;\n    //depth[i]=0;\n    //het[i]=0;\n    //parent[i]=0;\n  }\n  for(int i=0;i<n;i++){    \n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n      G[b].push_back(i);\n    }\n  }\n  for(int i=0;i<n;i++)sort(G[i].begin(),G[i].end());\n  depth[0]=0;\n  idfs(0,-1);\n  for(int i=0;i<n;i++){\n    int root=calc(i);\n    //het[i]=het[root];\n    int p=par[i];\n    while(p>0){\n      p= par[ parent[p] ];      \n      dep[i]++;\n    }\n\n    /*    \n    cout<< (char)('A'+i) <<\"   -> \";\n    cout<< (char)('A'+par[i]) <<endl;    \n    cout<<\"size = \"<< size[i]<<\" , \";    \n    cout<<\"depth = \"<< depth[i]<<\" , \";\n    cout<<\"dep = \"<< dep[i]<<\" , \";\n    cout<<\"parent = \"<< (char)('A'+parent[i]) <<\" , \";\n    cout<<\"cur = \"<< (char)('A'+cur[i]) <<\" , \";\n    cout<<\"het = \"<< het[i] << endl;\n    \n    cout<<endl;\n    */\n  }\n\n  \n}\n\nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n      scanf(\"%d %d\",&a,&b);\n\n      while(par[a]!=par[b]){\n        if(dep[a]<dep[b])swap(a,b);\n        a=parent[par[a]];\n      }\n      printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n\n    }\n    break;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define repp(i, n, m) for(int (i) = (n); (i) < (m); (i)++)\n#define repn(i, n) for(int (i) = 1; (i) <= (n); (i)++)\n#define repr(i, n) for(int (i) = (n-1); (i) >= 0; (i)--)\n#define all(x) (x).begin(), (x).end()\n#define lint long long\n#define ulint unsigned long long\n#define ldou long double\n#define fi first\n#define se second\n#define setpre(x) std::cout << fixed << setprecision(x)\n#define ii(x) int x; cin >> (x)\n#define ii2(x, y) int x, y; cin >> (x) >> (y)\n#define ii3(x, y, z) int x, y, z; cin >> (x) >> (y) >> (z)\n#define out(x) cout << (x) << endl\n#define outs(x) cout << (x) << \" \"\n#define yn(x) cout << ((x)?(\"Yes\"):(\"No\")) << endl\n#define YN(x) cout << ((x)?(\"YES\"):(\"NO\")) << endl\n#define bit_c(x) __builtin_popcountll(x)\n\ninline void logger(){ std::cout << \" [LOGGER] \" << endl; }\ntemplate<typename A, typename... B>\nvoid logger(const A& a, const B&... b){\n    cout << a << \" , \"; logger(b...);\n}\n\ntypedef pair<lint, lint> P;\nconst lint MOD = 1000000007;\nconst lint MOD9 = 998244353;\nconst lint INF = MOD * MOD;\nconst int MAX = 200005;\n\n/* ...o(^-^)o... */\n\n\nvector<int> to[MAX];\nstruct LCA{\n    vector<vector<int> > parent; //parent[i][u]:= u の 2^k 先の親\n    vector<int> dist;\n    int n, k;\n    LCA(int _n, int root = 0):n(_n){ init(root); }\n\n    void init(int root){\n        k = 1;\n        while((1<<k)<n) k++;\n        parent.assign(k, vector<int>(n, -1));\n        dist.assign(n, -1);\n        dfs(root);\n        rep(i, k-1) rep(v, n){\n            if(parent[i][v] == -1) parent[i][v] = -1;\n            else parent[i+1][v] = parent[i][parent[i][v]];\n        }\n    }\n\n    void dfs(int s, int p=-1){\n        parent[0][s] = p;\n        if(p<0) dist[s] = 0; else dist[s] = dist[p] + 1;\n        for(int t : to[s]){\n            if(t == p) continue;\n            dfs(t, s);\n        }\n    }\n\n    int query(int u, int v){\n        if(dist[u] < dist[v]) swap(u, v);\n        rep(i, k){\n            if((dist[u]-dist[v])&(1<<i)){ // d(u,v)を2進展開したときに2^uを含むか?\n                 //(d(u,v)&(1<<i)と書いても良さそう, あとで試す)\n                u = parent[i][u];\n            }\n        }\n        if(u == v) return u;\n        repr(i, k){\n            if(parent[i][u] != parent[i][v]){\n                u = parent[i][u];\n                v = parent[i][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n;\n    rep(i, n){\n        int k; cin>>k;\n        rep(j, k){\n            int c; cin>>c;\n            to[i].push_back(c);\n        }\n    }\n    LCA lca(n, 0);\n    cin >> q;\n    rep(i, q){\n        int u, v; cin>>u>>v;\n        out(lca.query(u, v));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 310;\nint color[100010],  par[100010], depth[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        // assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N, Q;\nint T[MAXN], L[MAXN], P[MAXN][20];  // direct parent, depth, ancestor\nvector<int> adjList[MAXN];\n\nvoid dfs(int node = 0, int depth = 0) {\n    L[node] = depth;\n    for (int i = 0; i < adjList[node].size(); i++) {\n        int child = adjList[node][i];\n        dfs(child,depth+1);\n    }\n}\n\nint query(int u, int v) {\n    int tmp;\n    if (L[u] < L[v])\n        tmp = u, u = v, v = tmp;\n\n    int LOG2;\n    for (LOG2 = 1; 1 << LOG2 <= L[u]; LOG2++); LOG2--;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (L[u] - (1 << i) >= L[v])\n            u = P[u][i];\n\n    if (u == v)\n        return u;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (P[u][i] != -1 && P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n\n    return T[u];\n}\n\nint main() {\n\n    scanf(\"%d\",&N);\n    for (int u = 0, M; u < N; u++) {\n        scanf(\"%d\",&M);\n        for (int i = 0, v; i < M; i++) {\n            scanf(\"%d\",&v);\n\n            T[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted at 0\n    dfs();\n\n    for (int i = 1; i <= N; i++)\n        P[i][0] = T[i];\n    for (int j = 1; 1 << j < N; j++)\n        for (int i = 1; i <= N; i++)\n            P[i][j] = P[P[i][j-1]][j-1];\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v; i < Q; i++) {\n        scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\", query(u,v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass SparseTable{\nprivate:\n    int N;\n    int H;\n    vector<vector<int>> data;\n    vector<int> rdata;\n    \npublic:\n    SparseTable(vector<int> rdata): rdata(rdata){\n        N = rdata.size();\n        H = log2(N);\n        \n        data.resize(H+1);\n        for(int i=0; i<N; i++){\n            data[0].push_back(i);\n        }\n        int l = 1;\n        for(int h=1; h<=H; h++){\n            for(int i=0; i+l*2<=N; i++){\n                int idx = -1;\n                if(rdata[data[h-1][i]] < rdata[data[h-1][i+l]])\n                    idx = data[h-1][i];\n                else\n                    idx = data[h-1][i+l];\n                data[h].push_back(idx);\n            }\n            l <<= 1;\n        }\n    }\n    int find(int a, int b){\n        int h = log2(b-a);\n        if(rdata[data[h][a]] < rdata[data[h][b-(1<<h)]])\n            return data[h][a];\n        else\n            return data[h][b-(1<<h)];\n    }\n};\n\nvoid euler_tour(vector<vector<int>> &G, int u, int d, vector<int> &tour, vector<int> &depth){\n    tour.push_back(u);\n    depth.push_back(d);\n    for(auto v: G[u]){\n        euler_tour(G, v, d+1, tour, depth);\n        tour.push_back(u);\n        depth.push_back(d);\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    \n    for(int i=0; i<N; i++){\n        int k; cin >> k;\n        for(int j=0; j<k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    \n    vector<int> tour, depth;\n    euler_tour(G, 0, 0, tour, depth);\n    vector<int> rightmsot(N);\n    for(int i=0; i<tour.size(); i++)\n        rightmsot[tour[i]] = i;\n    \n    SparseTable st(depth);\n    \n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++){\n        int u, v; cin >> u >> v;\n        int ru = rightmsot[u], rv = rightmsot[v];\n        if(ru > rv)\n            swap(ru, rv);\n        rv++;\n        int d = st.find(ru, rv);\n        cout << tour[d] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\n\nconst int MAXN = 100005;\nconst int LOGN = 20;\n\nint idx_in_path[MAXN];\nii path[MAXN<<1];\nvi adjList[MAXN];\n\nint path_size = 0;\n\n// compute and store the dfs order in path\n// initial call with dfs(root)\nvoid dfs(int u, int depth = 0) {\n    idx_in_path[u] = path_size;\n\n    path[path_size++] = ii(depth,u);\n    for (int v : adjList[u]) {\n        dfs(v, depth + 1);\n\n        path[path_size++] = ii(depth, u);\n    }\n}\n\n// must call dfs before build\nii ST[LOGN][MAXN<<1];\nvoid build(int n) {\n    int h = ceil(log2(n + 1));\n\n    for (int i = 0; i < n; i++) ST[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n            ST[i][j] = min(ST[i-1][j], ST[i-1][j+(1<<(i-1))]);\n}\n\n// return the lowest common ancestor between node u and v\nint lca(int u, int v) {\n    int l = idx_in_path[u], r = idx_in_path[v]; \n    if (l > r) swap(l, r); r++; // range [l, r)\n    \n    int p = 31 - __builtin_clz(r-l);\n    return min(ST[p][l],ST[p][r-(1<<p)]).se;\n}\n\nint main() {\n\n    int num_nodes;\n    scanf(\"%d\", &num_nodes);\n    for (int u = 0; u < num_nodes; u++) {\n        int num_neighbors;\n        scanf(\"%d\", &num_neighbors);\n        for (int i = 0; i < num_neighbors; i++) {\n            int v;\n            scanf(\"%d\", &v);\n            \n            adjList[u].push_back(v); // directed edge\n        }\n    }\n\n    dfs(0);\n    build(path_size);\n\n    int num_queries;\n    scanf(\"%d\",&num_queries);\n    for (int i = 0; i < num_queries; i++) {\n        int u, v;\n        scanf(\"%d%d\",&u,&v);\n\n        printf(\"%d\\n\", lca(u, v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100000];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nvoid sub(int idx)\n{\n  sz[idx] = query[idx].size();\n  for(auto &to : g[idx]) {\n    sub(to);\n    sz[idx] += query[to].size();\n  }\n}\n\nvoid dfs(int idx, bool keep)\n{\n  int heavy = -1;\n  for(auto &to : g[idx]) {\n    if(heavy == -1 || sz[to] > sz[heavy]) heavy = to;\n  }\n  for(auto &to : g[idx]) {\n    if(heavy != to) dfs(to, false);\n  }\n\n  if(~heavy) {\n    dfs(heavy, true);\n    for(int &v: query[idx]) {\n      if(~lca[v]) continue;\n      if(buf[v]++) lca[v] = idx;\n      else query[heavy].push_back(v);\n    }\n    query[idx].swap(query[heavy]);\n  } else {\n    for(int &v: query[idx]) {\n      if(~lca[v]) continue;\n      if(buf[v]++) lca[v] = idx;\n    }\n  }\n\n  for(auto &to : g[idx]) {\n    if(to == heavy) continue;\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      if(buf[v]++) lca[v] = idx;\n      else query[idx].push_back(v);\n    }\n  }\n\n  if(!keep) for(auto &v : query[idx]) buf[v] = false;\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n\n  memset(lca, -1, sizeof(lca));\n\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n\n  sub(0);\n  dfs(0, false);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c = 0): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\nusing Graph =  vector< vector<Edge> >;\n\n\n// calc Lowest Common Ancestor\n// O(N logN)\nstruct LCA{\n  const Graph& G;\n  int N, R;\n  int LOG_MAX;\n  vector<int> depth;\n  vector<vector<int>> parent;\n\n  LCA(const Graph& G_, int N_, int R_):\n\tG(G_), N(N_), R(R_)\n  {\n\tLOG_MAX = log2(N);\n\tdepth.assign(N, -1);\n\tparent.resize(LOG_MAX);\n\tfor(int i=0;i<LOG_MAX;++i)\n\t  parent[i].resize(N);\n\n\tfunction<void(int,int,int)> dfs = [&](int u, int p, int d){\n\t  depth[u] = d;\n\t  parent[0][u] = p;\n\t  for(const auto& e: G[u])\n\t\tif(e.to != p)\n\t\t  dfs(e.to, u, d+1);\n\t};\n\tdfs(R, -1, 0);\n\t\n\tfor(int i=0;i+1<LOG_MAX;++i){\n\t  for(int v=0;v<N;++v){\n\t\tif(parent[i][v] == -1) parent[i+1][v] = -1;\n\t\telse parent[i+1][v] = parent[i][parent[i][v]];\n\t  }\n\t}\n  }\n\n\n  int query(int u, int v){\n\tif(depth[u] > depth[v]) swap(u, v);\n\t// depth[u] <= depth[v]\n\tfor(int i=0;i<LOG_MAX;++i)\n\t  if((depth[v] - depth[u]) >> i & 1)\n\t\tv = parent[i][v];\n\tif(u == v) return u;\n\t\n\tfor(int i=LOG_MAX-1;i>=0;--i){\n\t  if(parent[i][u] != parent[i][v]){\n\t\tu = parent[i][u];\n\t\tv = parent[i][v];\n\t  }\n\t}\n\treturn parent[0][u];\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V; cin >> V;\n  Graph G(V);\n  REP(i,V){\n\tint k; cin >> k;\n\tREP(j,k){\n\t  int c; cin >> c;\n\t  G[i].PB(c);\n\t  G[c].PB(i);\n\t}\n  }\n  LCA lca(G, V, 0);\n\n  int Q; cin >> Q;\n  while(Q--){\n\tint u, v; cin >> u >> v;\n\tcout << lca.query(u,v) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst int sqrtN = 512;\nconst int logN = 32;\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nstruct LowestCommonAncestor{\n\tvector<vector<int>> g, parent;\n\tvector<int> depth;\n\tbool built = false;\n\tint N;\n\t\n\tLowestCommonAncestor(int n) : N(n) {\n\t\tg.resize(N);\n\t\tparent.resize(logN, vector<int>(N));\n\t\tdepth.resize(N);\n\t}\n\t\n\tvoid add_edge(int u, int v){\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int par = -1, int d = 0){\n\t\tparent[0][v] = par;\n\t\tdepth[v] = d;\n\t\t\n\t\tfor(auto e:g[v]){\n\t\t\tif(e == par) continue;\n\t\t\tdfs(e, v, d + 1);\n\t\t}\n\t}\n\t\n\tvoid build(){\n\t\tdfs(0);\n\t\tREP(k, 0, logN - 1){\n\t\t\tREP(i, 0, N){\n\t\t\t\tif(parent[k][i] < 0) parent[k + 1][i] = -1;\n\t\t\t\telse parent[k + 1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint get(int u, int v){\n\t\tif(!built) build(); built = true;\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\t\n\t\tREP(k, 0, logN) if(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\t\n\t\tif(u == v) return u;\n\t\t\n\t\tRREP(k, logN - 1, 0){\n\t\t\tif(parent[k][u] == parent[k][v]) continue;\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\t\t\t\n\t\t}\n\t\t\n\t\treturn parent[0][u];\n\t}\n};\n\nint main(){\n\tint n; cin >> n;\n\tLowestCommonAncestor lca(n);\n\tREP(i, 0, n){\n\t\tint k; cin >> k;\n\t\tREP(j, 0, k){\n\t\t\tint a; cin >> a;\n\t\t\tlca.add_edge(i, a);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tREP(i, 0, q){\n\t\tint a, b; cin >> a >> b;\n\t\t\n\t\tcout << lca.get(a, b) << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// LinkCutTree\n// 各Heavy-edge連結成分を表すBSTをin-orderで捜査すると、元のパスになる\ntemplate<typename Monoid = int, typename OperatorMonoid = Monoid>\nstruct LinkCutTree {\n  using F = function<Monoid(Monoid, Monoid)>;\n  using G = function<Monoid(Monoid, OperatorMonoid, int)>;\n  using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  struct Node {\n    Node *l, *r, *p;\n    int idx;\n    Monoid key, sum;\n    OperatorMonoid lazy;\n\n    bool rev;\n    int sz;\n\n    Node(int idx, const Monoid& key, const OperatorMonoid &om):l(nullptr), r(nullptr), p(nullptr), idx(idx), key(key), sum(key), lazy(om), rev(false), sz(1) {}\n\n    bool is_root() {\n      return !p || (p->l != this && p->r != this);\n    }\n  };\n\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n  LinkCutTree():LinkCutTree([](Monoid a, Monoid b) {return a+b;}, Monoid()) {}\n  LinkCutTree(const F &f, const Monoid &M1):LinkCutTree(f, G(), H(), M1, OperatorMonoid()) {}\n  LinkCutTree(const F &f, const G &g, const H &h, const Monoid &M1, const OperatorMonoid &OM0):f(f), g(g), h(h), M1(M1), OM0(OM0) {}\n\n  Node *make_node(int idx, const Monoid &v = Monoid()) {\n    return new Node(idx, v, OM0);\n  }\n\n  void propagate(Node *t, const OperatorMonoid &x) {\n    t->lazy = h(t->lazy, x);\n    t->key = g(t->key, x, 1);\n    t->sum = g(t->sum, x, t->sz);\n  }\n\n  void toggle(Node *t) {\n    assert(t);\n    swap(t->l, t->r);\n    /*ここに反転処理*/\n    t->rev ^= true;\n  }\n\n  void push(Node *t) {\n    if(t->lazy != OM0) {\n      if(t->l) propagate(t->l, t->lazy);\n      if(t->r) propagate(t->r, t->lazy);\n      t->lazy = OM0;\n    }\n    if(t->rev) {\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev = false;\n    }\n  }\n\n  void update(Node *t) {\n    t->sz = 1;\n    t->sum = t->key;\n    if(t->l) t->sz += t->l->sz, t->sum = f(t->l->sum, t->sum);\n    if(t->r) t->sz += t->r->sz, t->sum = f(t->sum, t->r->sum);\n  }\n\n  void rotr(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void rotl(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t) {\n    push(t);\n    while(!t->is_root()) {\n      auto *q = t->p;\n      if(q->is_root()) { // zig\n\tpush(q), push(t);\n\tif(q->l == t) rotr(t);\n\telse rotl(t);\n      } else {\n\tauto *r = q->p;\n\tpush(r), push(q), push(t);\n\tif(r->l == q) {\n\t  if(q->l == t) rotr(q), rotr(t); // zig zig\n\t  else rotl(t), rotr(t); // zig zag\n\t} else {\n\t  if(q->r == t) rotl(q), rotl(t); // zig zig\n\t  else rotr(t), rotl(t); // zig zag\n\t}\n      }\n    }\n  }\n\n  Node *expose(Node *t) {\n    Node *rp = nullptr;\n    for(Node *cur = t; cur; cur = cur->p /*Light-edgeで移動*/) {\n      splay(cur); // curを根にする\n      cur->r = rp; // Heavy-edgeでつなぐ(元のHeavy-edgeは切れる)\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert(Node *t) {\n    expose(t);\n    toggle(t);\n    push(t);\n  }\n\n  Node *lca(Node *u, Node *v) {\n    expose(u);\n    return expose(v);\n  }\n\n  vector<int> get_path(Node *x) {\n    vector<int> vs;\n    function<void(Node*)> dfs = [&](Node *cur) {\n      if(!cur) return;\n      dfs(cur->r);\n      vs.push_back(cur->idx);\n      dfs(cur->l);\n    };\n    expose(x);\n    dfs(x);\n    return vs;\n  }\n\n  void set_propagate(Node *t, const OperatorMonoid &x) {\n    expose(t);\n    propagate(t, x);\n    push(t);\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  LinkCutTree<> tree;\n  vector<LinkCutTree<>::Node*> nodes(n);\n  for(int i = 0; i < n; ++i) nodes[i] = tree.make_node(i);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    while(k--) {\n      int c;\n      cin >> c;\n      tree.link(nodes[c], nodes[i]);\n    }\n  }\n  int q;\n  cin >> q;\n  while(q--) {\n    int u, v;\n    cin >> u >> v;\n    cout << tree.lca(nodes[u], nodes[v])->idx << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass LowestCommonAncestor\n{\npublic:\n    LowestCommonAncestor(const Graph& g, const int root = 0) : left(g.V, 0)  // 無向根付き木\n    {\n        vector<bool> used(g.V, false);\n        auto dfs = fix([&](auto&& self, const pair<int, int>& s) -> void {\n            used[s.second] = true;\n            const int pos = s.second;\n            left[pos] = depth.size();\n            depth.push_back(s);\n            for (const int to : g.edge[pos]) {\n                if (used[to]) { continue; }\n                self(self, {s.first + 1, to});\n                depth.push_back(s);\n            }\n        });\n        dfs(make_pair(0, root));\n    }\n    int LCA(const int u, const int v) const\n    {\n        static const SparseTable<DepthMin> st{depth};\n        const int ul = left[u];\n        const int vl = left[v];\n        return st.accumulate(min(ul, vl), max(ul, vl) + 1).second;\n    }\n\nprivate:\n    struct DepthMin\n    {\n        using T = pair<int, int>;\n        T operator()(const T& a, const T& b) const { return min(a, b); }\n    };\n    vector<int> left;\n    vector<pair<int, int>> depth;\n};\n\n\n\ntemplate <typename Base>\nclass SparseTable\n{\npublic:\n    using T = typename Base::T;\n    using SemiLattice = Base;\n    SparseTable(const vector<T>& val)\n        : size(val.size()), lg2(size + 1, 0)\n    {\n        for (int i = 2; i <= size; i++) {\n            lg2[i] = lg2[i / 2] + 1;\n        }\n        table.resize(size, vector<T>(lg2[size] + 1));\n        for (int i = 0; i < size; i++) {\n            table[i][0] = val[i];\n        }\n        for (int j = 0; j < lg2[size]; j++) {\n            const int w = 1 << j;\n            for (int i = 0; i <= size - (w << 1); i++) {\n                T tl = table[i][j], tr = table[i + w][j];\n                table[i][j + 1] = op(tl, tr);\n            }\n        }\n    }\n    T accumulate(const int l, const int r) const\n    {\n        assert(0 <= l and l < r and r <= size);\n        const int j = lg2[r - l];\n        return op(table[l][j], table[r - (1 << j)][j]);\n    }\n\nprivate:\n    const int size;\n    vector<int> lg2;\n    vector<vector<T>> table;\n    const SemiLattice op{};\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n// Status: Accepted\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g.addEdge(i, c);\n        }\n    }\n\n    LowestCommonAncestor lca{g};\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.LCA(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(auto i = 0 * n; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate<class T = size_t>\nclass HL_Decomposition{\n#define PB push_back\n\ttypedef vector<T> vt;\n\tT n;\npublic:\n\ttemplate<class G>\n\tHL_Decomposition(const G & es, T root = 0) : n(es.size()), v2cmp(n), v2line(n), parent(n), depth(n, 0) {\n\t\t// to[v] : HL????§£????????????????????????????????????????????§?????? v ????¬??????\\?????????????????????????????? (????????????n)\n\t\tvt to(n, n);\n\n\t\t// to[v] ????§????\n\t\tfunction<T(T, T)> dfs = [&](T c, T p) {\n\t\t\tparent[c] = p;\n\t\t\t// s  : c ????????¨????????¨?????¨????????????\n\t\t\t// ma : ???????????§?????§?????¨?????¨????????????\n\t\t\tT s = 1, ma = 0;\n\t\t\tfor (auto e : es[c]) {\n\t\t\t\tif (e.to != p) {\n\t\t\t\t\tdepth[e.to] = depth[c] + 1;\n\t\t\t\t\tT x = dfs(e.to, c);\n\t\t\t\t\ts += x;\n\t\t\t\t\tif (ma < x) ma = x, to[c] = e.to;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s;\n\t\t};\n\t\tdfs(root, n);\n\n\t\t// HL????§£\n\t\tqueue<T> q({ root });\n\t\twhile (!q.empty()) {\n\t\t\tT i = component.size();\n\t\t\tcomponent.PB({});\n\t\t\tfor (T v = q.front(); v != n; v = to[v]) {\n\t\t\t\tv2cmp[v] = i;\n\t\t\t\tv2line[v] = component[i].size();\n\t\t\t\tcomponent[i].PB(v);\n\t\t\t\tfor (auto e : es[v]) {\n\t\t\t\t\tif (e.to != parent[v] && e.to != to[v]) q.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\n\tvoid for_each(T u, T v, function<void(T, T)> f) const {\n\t\tif (v2cmp[u] != v2cmp[v]) {\n\t\t\tif (v2cmp[u] > v2cmp[v]) swap(u, v);\n\t\t\tf(component[v2cmp[v]][0], v);\n\t\t\tfor_each(u, parent[component[v2cmp[v]][0]], f);\n\t\t} else {\n\t\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\t\tf(u, v);\n\t\t}\n\t}\n\n\tT lca(T u, T v) const {\n\t\tif (v2cmp[u] == v2cmp[v]) return depth[u] < depth[v] ? u : v;\n\t\tif (v2cmp[u] > v2cmp[v]) swap(u, v);\n\t\treturn lca(u, parent[component[v2cmp[v]][0]]);\n\t}\n\tT head_vertex(T i_cmp) const { return component[i_cmp][0]; }\n\tT parent_vertex(T i_cmp) const { return parent[head_vertex(i_cmp)]; }\n\tT parent_component(T i_cmp) const { return v2cmp[parent_vertex(i_cmp)]; }\n\n\t// ????????????????????? i ??? ????????????????????? j ????\\???? ??? i < j\n\n\t// v2cmp[v]     : ?????? v ???????±?????????????????????????????????????????????????\n\t// v2line[v]    : ?????? v ???????±???????????????????????????????????????§?????????????????????\n\t// parent[v]    : ?????? v ???????????????????????????????????? ????????????????????´?????? n ???\n\t// depth[v]     : ?????? v ?????±???(??????0)\n\t// component[i] : i??????????????????????????????????±??????????????????????????????????????????????\n\tvt v2cmp, v2line, parent, depth;\n\tvector<vt> component;\n};\n\nstruct Edge{ size_t to; };\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n    size_t n; cin >> n;\n    vector<vector<Edge>> g(n);\n\tREP(i, n) {\n\t\tsize_t k; cin >> k;\n\t\tREP(j, k) {\n\t\t\tsize_t c; cin >> c;\n\t\t\tg[i].push_back({ c });\n\t\t}\n\t}\n    HL_Decomposition<> hl(g);\n \n    size_t q; cin >> q;\n\tREP(i, q) {\n\t\tsize_t u, v; cin >> u >> v;\n\t\tcout << hl.lca(u, v) << \"\\n\";\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathRoot;\n  vector<vector<int> > tree;\n\n  HeavyLight(vector<vector<int> > t)\n    :pathCount(0),n(t.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathRoot(n),tree(t){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Precomputation: O(nlgn)\n// Query: O(1)\n//\n// Data structure: Sparse Table\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\n\nconst int MAXN = 100005;\nconst int LOGN = 20;\n\nint idx_in_path[MAXN];\nii path[MAXN<<1];\nvi adjList[MAXN];\n\nint path_size = 0;\n\n// compute and store the dfs order in path\n// initial call with dfs(root)\nvoid dfs(int u, int depth = 0) {\n    idx_in_path[u] = path_size;\n\n    path[path_size++] = ii(depth,u);\n    for (int v : adjList[u]) {\n        dfs(v, depth + 1);\n\n        path[path_size++] = ii(depth, u);\n    }\n}\n\n// must call dfs before build\n// compute entries for sparse table\nii st[LOGN][MAXN<<1];\nvoid build(int n) {\n    int h = ceil(log2(n + 1));\n\n    for (int i = 0; i < n; i++) st[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n            st[i][j] = min(st[i-1][j], st[i-1][j+(1<<(i-1))]);\n}\n\n// return the lowest common ancestor between node u and v\nint lca(int u, int v) {\n    int l = idx_in_path[u], r = idx_in_path[v]; \n    if (l > r) swap(l, r); r++; // range [l, r)\n    \n    int p = 31 - __builtin_clz(r-l);\n    return min(st[p][l],st[p][r-(1<<p)]).se;\n}\n\nint main() {\n\n    int num_nodes;\n    scanf(\"%d\", &num_nodes);\n    for (int u = 0; u < num_nodes; u++) {\n        int num_neighbors;\n        scanf(\"%d\", &num_neighbors);\n        for (int i = 0; i < num_neighbors; i++) {\n            int v;\n            scanf(\"%d\", &v);\n            \n            adjList[u].push_back(v); // directed edge\n        }\n    }\n\n    dfs(0);\n    build(path_size);\n\n    int num_queries;\n    scanf(\"%d\",&num_queries);\n    for (int i = 0; i < num_queries; i++) {\n        int u, v;\n        scanf(\"%d%d\",&u,&v);\n\n        printf(\"%d\\n\", lca(u, v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    using Graph = vector<vector<int>>;\n    const int t_inf = numeric_limits<int>::max();\n    pair<int, int> id = make_pair(t_inf, INT_MAX);\n    int n;\n    vector<pair<int, int>> data;\n    vector<int> idx;\n\n    LowestCommonAncestor(Graph G, int s = 0) : idx(G.size(), -1), n(1) {\n        vector<pair<int, int>> p;\n        EulerTour(G, s, s, 0, p);\n        int sz = p.size();\n        for (int i = sz-1; i >= 0; i--) idx[p[i].second] = i;\n        while (n < sz) { n *= 2; }\n        data.resize(2*n-1, id);\n        for (int i = 0; i < sz; i++) data[i+n-1] = p[i];\n        for (int i = n-2; i >= 0; i--) data[i] = min(data[i*2+1], data[i*2+2]);\n    }\n\n    void EulerTour(const Graph &G, int now, int par, int dep, vector<pair<int, int>> &path) {\n        path.emplace_back(dep, now);\n        for (auto nxt : G[now]) if (nxt != par) {\n            EulerTour(G, nxt, now, dep + 1, path);\n            path.emplace_back(dep, now);\n        }\n    }\n\n    inline pair<int, int> query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return id;\n        if (a <= l && r <= b) return data[k];\n        pair<int, int> vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        pair<int, int> vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int ancestor (int a, int b) {\n        int l = min(idx[a], idx[b]), r = max(idx[a], idx[b]);\n        return query(l, r + 1).second;\n    }\n\n    int distance(int a, int b) {\n        int l = min(idx[a], idx[b]), r = max(idx[a], idx[b]);\n        int an = query(l, r + 1).first;\n        int d1 = data[idx[a]+n-1].first, d2 = data[idx[b]+n-1].first;\n        return (d1 + d2 - an*2);\n    }\n};\n\n\n\nint main() {\n    int n, k, q, s, t;\n    scanf(\"%d\", &n);\n    vector<vector<int>> g(n);\n    for (int v = 0; v < n; v++) {\n        scanf(\"%d\", &k);\n        for (int i = 0; i < k; i++) {\n            int u; scanf(\"%d\", &u);\n            g[v].emplace_back(u);\n            g[u].emplace_back(v);\n        }\n    }\n    \n    LowestCommonAncestor lca(g, 0);\n    scanf(\"%d\", &q);\n    while(q--) {\n        scanf(\"%d%d\", &s, &t);\n        printf(\"%d\\n\", lca.ancestor(s, t));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    /*\n    len=vector<vector<int> >(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nclass LCA{\n\tconst int MAX_LOG = 20;\n\tint n;\n\tbool isDirected;\n\tvector<vector<int>> G,par;\n\tvector<int> depth;\n\tpublic:\n\tLCA(int _n,bool b) : n(_n),isDirected(b),par(MAX_LOG,vector<int>(_n,-1)),G(_n),depth(_n,-1){}\n\tvoid add_edge(int u,int v){\n\t\tG[u].pb(v);\n\t\tif(!isDirected) G[v].pb(u);\n\t\telse par[0][v] = u;\n\t}\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor(int to : G[v]){\n\t\t\tif(to != p) dfs(to,v,d + 1);\n\t\t}\n\t}\n\tvoid build(){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(depth[i] == -1){\n\t\t\t\tif(!isDirected || par[0][i] == -1) dfs(i,-1,0);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < MAX_LOG - 1;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(par[i][j] == -1) par[i + 1][j] = -1;\n\t\t\t\telse par[i + 1][j] = par[i][par[i][j]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u,int v){\n\t\tif(depth[u] > depth[v]) swap(u,v);\n\t\tfor(int i = 0;i < MAX_LOG;i++){\n\t\t\tif((depth[v] - depth[u]) >> i & 1) v = par[i][v];\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int i = MAX_LOG - 1;i >= 0;i--){\n\t\t\tif(par[i][u] != par[i][v]){\n\t\t\t\tu = par[i][u];\n\t\t\t\tv = par[i][v];\n\t\t\t}\n\t\t}\n\t\treturn par[0][u];\n\t}\n};\n\nsigned main(){\n\tint n,q;\n\tcin >> n;\n\tLCA lca(n,true);\n\tfor(int i = 0;i < n;i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 0;j < k;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tlca.add_edge(i,v);\n\t\t}\n\t}\n\tlca.build();\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tcout << lca.lca(u,v) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 100005\n \n \nstruct myque{\n  int l,r;\n  int t[MAX_V];\n  void clear(){l=r=0;}\n  void pop(){l++;}\n  void push(int x){t[r++]=x;}\n  int front(){return t[l];}\n  bool empty(){return (l==r);}\n};\n \nmyque que;\nint pa[MAX_V],de[MAX_V],sz[MAX_V];\nint cd[MAX_V],mv[MAX_V],hl[MAX_V];\n \nint V;\nvector<int> G[MAX_V];\n \nvoid HLD(int root=0){\n  que.clear();\n  for(int i=0;i<V;i++){\n    sz[i]=1;\n    pa[i]=cd[i]=mv[i]=i;\n    hl[i]=G[i].size();\n    if(i==root)continue;\n    if(hl[i]!=1)continue;\n    que.push(i);\n  }\n  // calc sz[] cd[] pa[]\n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    if(pos==root)continue;\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(pa[to]==pos)continue;\n      pa[pos]=to;\n      sz[to]+=sz[pos];           \n      if(cd[to]==to)cd[to]=pos;\n      if(sz[cd[to]]<sz[pos])cd[to]=pos;\n      hl[to]--;\n      if(hl[to]==1)que.push(to);\n    }\n  }\n \n  // calc hl[] de[] mv[]\n  que.clear();\n  que.push(root);\n  de[root]=hl[root]=0;\n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    if(cd[pos]==pos)continue;\n    mv[cd[pos]]=mv[pos];\n    hl[cd[pos]]=hl[pos]+1;\n    int sum=hl[pos]+1+sz[cd[pos]];\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(to==pa[pos])continue;\n      que.push(to);\n      de[to]=de[pos]+1;\n      if(to==cd[pos])continue;\n      hl[to]=sum;\n      sum+=sz[to];\n    }\n  }\n}\n \nint lca(int a,int b){\n  while(mv[a]!=mv[b]){\n    if(de[mv[a]]<de[mv[b]])swap(a,b);\n    a=pa[mv[a]];\n  }\n  return (de[a]<de[b]?a:b);\n}\n \nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\n \nint main(){\n  scanf(\"%d\",&V);\n \n  for(int i=0;i<V;i++){\n    int size,ch;\n    scanf(\"%d\",&size);\n    while(size--){\n      scanf(\"%d\",&ch);\n      add_edge(i,ch);\n    }\n  }\n  HLD(0);\n  /*\n  for(int i=0;i<V;i++){\n    cout<< (char)('A'+i) <<endl;\n    cout<<\" hl = \"<< hl[i] <<\" , \";\n    cout<<\" sz = \"<< sz[i] <<\" , \";\n    cout<<\" de = \"<< de[i] <<\" , \";\n    cout<<\" pa = \"<< (char)('A'+pa[i]) <<\" , \";\n    cout<<\" cd = \"<< (char)('A'+cd[i]) <<\" , \";\n    cout<<\" mv = \"<< (char)('A'+mv[i]) <<\" , \";\n    cout<<endl;\n  }\n  */\n  int a,b,Q;\n  scanf(\"%d\",&Q);\n  while(Q--){\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",lca(a,b));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz;\n    vector<pair<T, int> > node;\npublic:\n    void resize(vector<T>& v){\n        sz = (int)v.size();\n        n = 1;\n        while(n < sz){\n            n *= 2;\n        }\n        node.resize(2*n);\n        for(int i = 0; i < sz; i++){\n            node[i+n] = make_pair(v[i], i);\n        }\n        for(int i=n-1; i>=1; i--){\n            node[i] = min(node[2*i], node[2*i+1]);\n        }\n    }\n    void update(int k, T a)\n    {\n    \tnode[k+=n] = make_pair(a, k);\n    \twhile(k>>=1){\n            node[k] = min(node[2*k], node[2*k+1]);\n    \t}\n    }\n    pair<T, int> query(int a,int b,int k=0,int l=0,int r=-1)\n    {\n        pair<T, int> res1 = make_pair(numeric_limits<T>::max(), -1);\n        pair<T, int> res2 = make_pair(numeric_limits<T>::max(), -1);\n        a += n, b += n;\n        while(a != b){\n            if(a % 2) cmn(res1, node[a++]);\n            if(b % 2) cmn(res2, node[--b]);\n            a >>= 1, b>>= 1;\n        }\n        return min(res1, res2);\n    }\n};\n\nclass LCA{\npublic:\n    int V;\n    vector<vector<int> > G;\n    vector<int> ord,depth,id;\n    segtree<int> st;\n    LCA(int node_size) : V(node_size), G(V), depth(V), id(V, -1){}\n    void add_edge(int from,int to){\n        G[from].push_back(to),G[to].push_back(from);\n    }\n    void dfs(int u,int p,int k){\n        id[u] = (int)ord.size();\n        ord.push_back(u);\n        depth[u] = k;\n        for(int v : G[u]){\n            if(v != p){\n                dfs(v,u,k+1);\n                ord.push_back(u);\n            }\n        }\n    }\n    void build(){\n        ord.reserve(2*V-2);\n        for(int i = 0; i < V; i++){\n            if(id[i] < 0){\n                dfs(i,-1,0);\n            }\n        }\n        vector<int> stvec(2*V-2);\n    \tfor(int i = 0; i < 2*V-2; i++){\n    \t\tstvec[i] = depth[ord[i]];\n    \t}\n        st.resize(stvec);\n    }\n    int solve(int u,int v){\n        return ord[st.query(min(id[u],id[v]),max(id[u],id[v])+1).second];\n    }\n    int dist(int u,int v){\n        int lca = solve(u,v);\n        return depth[u] + depth[v] - 2*depth[lca];\n    }\n};\n\nvector<int> G[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,n){\n        int cnt;\n        cin >> cnt;\n        rep(j,cnt){\n            int a;\n            cin >> a;\n            lca.add_edge(i,a);\n        }\n    }\n    lca.build();\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.solve(a,b) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n\ntemplate<int SZ>\nclass HLDecomp {\nprivate:\n  int n;\n  void dfs(const int root){\n    stack<pair<int,bool> > st;\n    par[root] = -1;\n    dep[root] = 0;\n    st.push({root,false});\n    while(!st.empty()){\n      int v = st.top().first;\n      bool &b = st.top().second;\n      if(!b){\n        // initial visit of v\n        b = true;\n        for(int u : tree[v]) if(u != par[v]){\n          par[u] = v;\n          dep[u] = dep[v] + 1;\n          // st.push({u, false});\n          st.push(mp(u, false));\n        }\n      }\n      else {\n        // second visit\n        st.pop();\n        int cur_max = 0;\n        for(int u : tree[v]) if(u != par[v]){\n          sub_sz[v] += sub_sz[u];\n          if(sub_sz[u] > cur_max){\n            cur_max = sub_sz[u];\n            heavy_child[v] = u;\n          }\n        }\n      }\n    }\n  }\n  void bfs(const int root){\n    int cnt = 0;\n    queue<int> q;\n    q.push(root);\n    while(!q.empty()){\n      int h = q.front(); q.pop();\n      for(int i=h; i!=-1; i = heavy_child[i]){\n        vid[i] = cnt++;\n        vid2idx[vid[i]] = i;\n        chain_head[i] = h;\n        for(int to : tree[i]) if(to!=par[i] && to!=heavy_child[i]) q.push(to);\n      }\n    }\n  }\npublic:\n  vector<int> tree[SZ];\n  int par[SZ], dep[SZ], sub_sz[SZ], heavy_child[SZ], vid[SZ], vid2idx[SZ], chain_head[SZ];\n  HLDecomp(const int _n) : n(_n) {\n    assert(n<=SZ);\n    fill(sub_sz, sub_sz+n, 1);\n    fill(heavy_child, heavy_child+n, -1);\n  }\n  void add_edge(const int u, const int v){\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n  void build(const int root = 0){\n    dfs(root);\n    bfs(root);\n  }\n\n  int lca(int u, int v) const {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(chain_head[u] == chain_head[v]) return u;\n      v = par[chain_head[v]];\n    }\n  }\n  int distance(const int u, const int v) const {\n    return dep[u] + dep[v] - 2*dep[lca(u,v)];\n  }\n};\n\n\nint main(){\n  int n;\n  cin>>n;\n  HLDecomp<100000> hl(n);\n  rep(i,n){\n    int k;\n    cin>>k;\n    rep(j,k){\n      int d;\n      cin>>d;\n      hl.add_edge(i,d);\n    }\n  }\n  hl.build();\n\n  int q;\n  cin>>q;\n  rep(i,q){\n    int a,b;\n    cin>>a>>b;\n    cout << hl.lca(a,b) << \"\\n\";\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n/*\n// ????????????????§?????§£?????¨\ntypedef string::const_iterator State;\nclass ParseError {};\n*/\n\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint N;\nvi depth;\nint maxdepth = 0;\nGraph G;\nvvi dblpar;\n\nvoid dfs1(int pos, int d = 0) {\n\tdepth[pos] = d;\n\tmaxdepth = max(maxdepth, d);\n\tfor (auto ch : G[pos]) {\n\t\tdfs1(ch.to, d + 1);\n\t}\n}\n\nvoid dfs2(int pos, int par, int dbl) {\n\tif (dbl == 0) {\n\t\tdblpar[0][pos] = par;\n\t}\n\telse {\n\t\tdblpar[dbl][pos] = dblpar[dbl - 1][dblpar[dbl - 1][pos]];\n\t}\n\tfor (auto ch : G[pos]) {\n\t\tdfs2(ch.to, pos, dbl);\n\t}\n}\n\nint parent(int pos, int step) {\n\tint ret = pos;\n\tint dbl = 0;\n\twhile (step > 0) {\n\t\tif ((step & 1) != 0) {\n\t\t\tret = dblpar[dbl][ret];\n\t\t}\n\t\tstep >>= 1;\n\t\tdbl++;\n\t}\n\treturn ret;\n}\n\nint bindigit(int n) {\n\tint ret = 0;\n\twhile (n > 0) {\n\t\tret++;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\tdepth = vi(N);\n\tG = Graph(N);\n\trep(i, N) {\n\t\tint num;\n\t\tcin >> num;\n\t\trep(j, num) {\n\t\t\tint ch;\n\t\t\tcin >> ch;\n\t\t\tG[i].push_back(Edge{ i,ch,1 });\n\t\t}\n\t}\n\n\tdfs1(0);\n\tint D = bindigit(maxdepth) + 1;\n\tdblpar = vvi(D, vi(N));\n\trep(i, D) {\n\t\tdfs2(0, 0, i);\n\t}\n\t/*\n\trep(i, N) {\n\t\tcout << depth[i] << \":\";\n\t\trep(j, D) {\n\t\t\tcout << dblpar[j][i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\tint Q;\n\tcin >> Q;\n\trep(q, Q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (depth[u] < depth[v]) {\n\t\t\tswap(u, v);\n\t\t}\n\t\tu = parent(u, depth[u] - depth[v]);\n\t\t// u,v???????????±???\n\t\tif (u == v) {\n\t\t\tcout << u << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ng = -1, ok = D - 1;\n\t\twhile (ok - ng > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (dblpar[mid][u] == dblpar[mid][v]) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\tcout << dblpar[ok][u] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nstruct LCA {\n    int V;//頂点数\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    int MAX_LOG_V = 0;\n    int root = 0;//根ノードの番号\n\n    vector<vector<int>> parent;//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1とする)\n    vector<int> depth;//根からの深さ\n\n    LCA(int V) {\n        this->V = V;\n        while (1 << MAX_LOG_V < V) {//バグが怖い\n            MAX_LOG_V++;\n        }\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n\n    /**\n     * 辺を追加した後に初期化をする\n     */\n    void init() {\n        //parentとdepthの初期化\n        dfs(root, -1, 0);\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n\n    /**\n     * uとvのlcaを求める\n     * @param u 頂点\n     * @param v 頂点\n     * @return lcaとなる頂点\n     */\n    int lca(int u, int v) {\n        //uとvの高さが同じになるまで親を辿る\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k < MAX_LOG_V; k++) {\n            if((depth[v] - depth[u]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        //二分探索でLCAを求める\n        for (int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /**\n     * 辺を追加する\n     * @param from 元\n     * @param to 先\n     */\n    void add_edge(int from,int to){\n        G[from].push_back(to);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.init();\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n    cout << \"---\" << endl;\n    rep(i,0,lca.G.size()){\n        rep(j,0,lca.G[i].size()){\n            cout << i << \" \" << lca.G[i][j] << endl;\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdint>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Doubling{\n  vector<vector<int>>table;\n  int log;\n  int sz;\n  //sz:要素数 lim:最大の数\n  Doubling(int sz,int64_t lim):sz(sz),log(64-__builtin_clzll(lim)){\n    table.resize(sz,vector<int>(log,-1));\n  }\n  void set_next(int now,int next){\n    table[now][0]=next;\n  }\n  void build(){\n    for(int j=0;j<log-1;j++){\n      for(int i=0;i<sz;i++){\n        if(table[i][j]==-1)table[i][j+1]=-1;\n        else table[i][j+1]=table[table[i][j]][j]; //iの2^j先の2^j先->iの2^(j+1)先\n      }\n    }\n  }\n};\n\nstruct DLCA{\n  int r;\n  vector<int>par;\n  vector<int>dep;\n  vector<vector<int>>g;\n  Doubling*d;\n  DLCA(vector<vector<int>>g,int r):g(g),r(r){\n    int N=g.size();\n    par.resize(N,0);\n    dep.resize(N,0);\n    d=new Doubling(N,N);\n    dfs(r,-1,0);\n    for(int i=0;i<N;i++)d->set_next(i,par[i]);\n    d->build();\n  }\n  void dfs(int x,int p,int val){\n    par[x]=p;\n    dep[x]=val;\n    for(auto it:g[x]){\n      if(it!=p)dfs(it,x,val+1);\n    }\n  }\n  int query(int x,int y){\n    if(dep[x]<dep[y])swap(x,y);\n    for(int i=d->log-1;i>=0;i--){\n      if(((dep[x]-dep[y])>>i)&1)x=d->table[x][i];\n    }\n    if(x==y)return x;\n    for(int i=d->log-1;i>=0;i--){\n      if(d->table[x][i]!=d->table[y][i]){\n        x=d->table[x][i];\n        y=d->table[y][i];\n      }\n    }\n    return d->table[x][0];\n  }\n};\n\n#include <bits/stdc++.h>\n\nint main(){\n  int n;\n  cin>>n;\n  vector<vector<int>>g(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      g[i].push_back(c);\n    }\n  }\n  int q;\n  cin>>q;\n  vector<int>u(q),v(q);\n  for(int i=0;i<q;i++)cin>>u[i]>>v[i];\n  DLCA d(g,0);\n  for(int i=0;i<q;i++)cout<<d.query(u[i],v[i])<<endl;\n}\n\n/*\nstruct DLCA{\n  int LOG;\n  vector<int>dep;\n  vector<vector<int>>g;\n  vector<vector<int>>table;\n\n  DLCA(vector<vector<int>>&g):g(g),dep(g.size()),LOG(32-__builtin_clz(g.size())){\n    table.assign(LOG,vector<int>(g.size(),-1));\n  }\n\n  //全ての葉の親をtable[0]に記録\n  void dfs(int idx,int par,int d){\n    //idxの一つ上の親\n    table[0][idx]=par;\n    //根からの距離\n    dep[idx]=d;\n    for(auto to:g[idx]){\n      if(to!=par)dfs(to,idx,d+1);\n    }\n  }\n\n  void build(){\n    dfs(0,-1,0);\n    //LOG=floor(log(g.size()));\n    //ダブリング\n    for(int k=0;k+1<LOG;k++){\n      for(int i=0;i<table[k].size();i++){\n        if(table[k][i]==-1)table[k+1][i]=-1;\n        else table[k+1][i]=table[k][table[k][i]];\n      }\n    }\n  }\n\n  int query(int u,int v){\n    //深さを揃える\n    if(dep[u]>dep[v])swap(u,v);\n    for(int i=LOG-1;i>=0;i--){\n      if(((dep[v]-dep[u])>>i)&1)v=table[i][v];\n    }\n    if(u==v)return u;\n    //同じになるまでちょっとずつ近づく\n    for(int i=LOG-1;i>=0;i--){\n      if(table[i][u]!=table[i][v]){\n        u=table[i][u];\n        v=table[i][v];\n      }\n    }\n    return table[0][u];\n  }\n\n};\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <vector>\n\nclass lowest_common_ancestor {\n\tstd::vector<std::vector<size_t>> g, parent;\n\tstd::vector<size_t> depth;\n\t\n\tconst size_t logN = 20;\n\n\tprivate:\n\tvoid dfs(size_t v, int par = -1, size_t d = 0) {\n\t\tparent[0][v] = par;\n\t\tdepth[v] = d;\n\t\t\n\t\tfor(auto e:g[v]) {\n\t\t\tif(e == par) continue;\n\t\t\t\n\t\t\tdfs(e, v, d + 1);\n\t\t}\n\t}\n\tvoid build() {\n\t\tdfs(0);\n\t\t\n\t\tfor(int k = 0; k < logN - 1; k++) {\n\t\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\t\tif(parent[k][i] == -1) parent[k + 1][i] = -1;\n\t\t\t\telse parent[k + 1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic:\n\tlowest_common_ancestor() {}\n\tlowest_common_ancestor(int n) : g(n), depth(n) {\n\t\tparent.assign(logN, std::vector<size_t>(n, -1));\n\t}\n\tvoid add_edge(const size_t & u, const size_t & v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tconst size_t query(size_t u, size_t v) {\n\t\tstatic bool built = false;\n\t\tif(!built) {\n\t\t\tbuild();\n\t\t\tbuilt = true;\n\t\t}\n\n\t\tif(depth[u] > depth[v]) std::swap(u, v);\n\t\tfor(int k = 0; k < logN; k++) {\n\t\t\tif(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\n\t\t}\n\t\tif(u == v) return u;\n\n\t\tfor(int k = logN - 1; k >= 0; k--) {\n\t\t\tif(parent[k][u] == parent[k][v]) continue;\n\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\t\t\t\n\t\t}\t\t\n\t\treturn parent[0][u];\n\t}\n};\n\n#include <stdio.h>\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tlowest_common_ancestor lca(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tint k; scanf(\"%d\", &k);\n\n\t\twhile(k--) {\n\t\t\tint p; scanf(\"%d\", &p);\n\n\t\t\tlca.add_edge(i, p);\n\t\t}\n\t}\n\n\tint q; scanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\n\t\tprintf(\"%d\\n\", lca.query(x, y));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define FILL(Itr,n) fill((Itr).begin(),(Itr).end(),n)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\ntypedef long long ll;\n#define MOD 1000000007\n\nstruct LCA {\n    int n,ln;\n    vector<vector<int> > parent;\n    vector< vector<int> > G;\n    vector<int> depth;\n    \n    LCA(int _n) : n(_n), depth(_n),G(_n+10){\n        ln=0;\n        while(n>(1<<ln)) ln++;\n        parent = vector<vector<int> >(ln, vector<int>(n));\n    }\n    \n    void dfs(int v, int p, int d){\n        parent[0][v]=p;\n        depth[v]=d;\n        for(int i=0;i<G[v].size();i++) if(G[v][i]!=p) dfs(G[v][i], v, d+1);\n    }\n    \n    int dist(int a, int b){\n        int par=getParent(a,b);\n        return depth[a]+depth[b]-depth[par]*2;\n    }\n    \n    void init(int root){\n        dfs(root, -1, 0);\n        for(int k=0; k+1<ln; k++){\n            for(int v=0; v<n; v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n    \n    void add_edge(int a, int b){\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    int getParent(int u, int v){\n        if(depth[u] > depth[v]) swap(u,v);\n        for(int k=0; k<ln; k++){\n            if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n        }\n        if(u==v) return u;\n        \n        for(int k=ln-1; k>=0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\n\nint main(){\n    \n    int n; cin>>n;\n    \n    LCA inst(100010);\n    REP(i,n){\n        int k; cin>>k;\n        REP(j,k){\n            int t; cin>>t;\n            inst.add_edge(i,t);\n        }\n    }\n    \n    inst.init(0);\n    \n    int q; cin>>q;\n    REP(i,q){\n        int a,b; cin>>a>>b;\n        cout<<inst.getParent(a,b)<<endl;\n    }\n   \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, root, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int n_, int root_) : N(n_), root(root_), G(n_), depth(n_) {\n    logN = floor(log2(N));\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init() {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      int pu = parent[k][u], pv = parent[k][v];\n      if(pu != pv) {\n        u = pu, v = pv;\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N, 0);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init();\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 300){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(max(logN, 1), vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<typename T> class Monoid{\npublic:\n\tvirtual inline T e()=0,c(T,T)=0;\n};\n\ntemplate<typename T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;Monoid<T>& m;\n\tSegmentTree(int n,Monoid<T>& m):size(n),n2(upper_pow2(size)),m(m){\n\t\tdat=vector<T>(n2*2,m.e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return m.e();//out of range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\nclass MiniMonoid:public Monoid<int>{\npublic:\n\tvector<int>& vs;\n\tMiniMonoid(vector<int>& vs):vs(vs){};\n\tinline int e(){return -1;}\n\tinline int c(int a,int b){\n\t\tif(b==-1)return a;if(a==-1)return b;\n\t\treturn min(vs[a],vs[b])==vs[a]?a:b;// left most\n\t}\n};\ntemplate<typename T> class SegmentTreei{\npublic:\n\tvector<T> vs;MiniMonoid mm;SegmentTree<T> seg;\n\tSegmentTreei(int n):vs(n),mm(vs),seg(n,mm){}\n\tvoid set(int v,T a){ vs[v]=a;seg.set(v,v);}\n};\n\ntypedef vector<vector<int>> Graph;\nclass EularTourLCA{\n\tpublic:\n\tGraph& g;int r;\n\tvector<int> id,depth,vs;\n\tSegmentTreei<int> rmq;\n\tEularTourLCA(Graph & g,int r):g(g),r(r),rmq(SegmentTreei<int>(2*g.size()-1)){\n\t\tid=vector<int>(g.size());\n\t\tdepth=vector<int>(2*g.size()-1);\n\t\tvs=vector<int>(2*g.size()-1);\n\t\tint k=0;dfs(-1,r,0,k);\n\t\tREP(i,vs.size())rmq.set(i,depth[i]);\n\t};\n\tvoid dfs(int p,int s,int d,int& k){\n\t\tid[s]=k;vs[k]=s;depth[k++]=d;\n\t\tfor(int t:g[s])if(t!=p){\n\t\t\tdfs(s,t,d+1,k);\n\t\t\tvs[k]=s;\n\t\t\tdepth[k++]=d;\n\t\t}\n\t}\n\tint lca(int u,int v){ return vs[rmq.seg.query(min(id[u],id[v]),max(id[u],id[v])+1)];}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t); g[t].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tEularTourLCA lca(g,0);\n\t\tint q;cin >>q;\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tcout << lca.lca(u,v) <<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 0\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(lint ngtkana_is_a_genius=0; ngtkana_is_a_genius<(lint)k; ngtkana_is_a_genius++)\nusing lint=long long;\nusing ld=long double;\ntemplate<class T> using numr=std::numeric_limits<T>;\nstruct input_t {\n    template<class T> operator T() {\n        T t;\n        std::cin>>t;\n        return t;\n    }\n} input;\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n\n// segtree {{{\n/* APIs\n * - segtree(sz)\n * - size()\n * - fold(l, r)\n * - set(i, x)\n * - lazy_set(i, x)\n * - build()\n * - to_vec()\n */\ntemplate <class Monoid> struct segtree{/*{{{*/\n    // a type alias\n    using value_type = typename Monoid::value_type;\n\n    // member variables\n    std::vector<value_type>table;\n\n    // trivial constructors\n    segtree()=default;\n    segtree(segtree const&)=default;\n    segtree(segtree&&)=default;\n    segtree&operator=(segtree const&)=default;\n    segtree&operator=(segtree&&)=default;\n\n    // a non-trivial constructor\n    segtree(std::size_t n) : table(2*n, Monoid::id) {}\n\n    // resize\n    void resize(std::size_t n) {\n        assert(table.empty());\n        table.resize(2*n);\n    }\n\n    // size\n    std::size_t size() const { return table.size() / 2; }\n\n    // fold\n    value_type fold(std::size_t l, std::size_t r) const {\n        value_type fl = Monoid::id;\n        value_type fr = Monoid::id;\n\n        for(l+=size(),r+=size();l<r;l>>=1,r>>=1){\n            if(l&1u) fl=Monoid::op(fl, table.at(l++));\n            if(r&1u) fr=Monoid::op(fr, table.at(--r));\n        }\n\n        return Monoid::op(fl, fr);\n    }\n\n    // set\n    void set(std::size_t i, value_type x) {\n        assert(0 <= i);\n        assert(i < size());\n\n        i+=size();\n        table.at(i) = x;\n\n        for(i>>=1;i;i>>=1){ table.at(i) = Monoid::op(table.at(2*i), table.at(2*i+1)); }\n    }\n\n    // lazy_set\n    void lazy_set(std::size_t i, value_type x) {\n        assert(0 <= i);\n        assert(i < size());\n\n        i+=size();\n        table.at(i) = x;\n    }\n\n    // map\n    template <class F>\n        void map(std::size_t i, F const& f) { set(i, f(at(i))); }\n\n    // build\n    void build() {\n        for(std::size_t i=size()-1;i;i--){ table.at(i) = Monoid::op(table.at(2*i), table.at(2*i+1)); }\n    }\n\n    // at\n    value_type at(std::size_t i) const { return table.at(size() + i); }\n\n    // to_vec\n    std::vector<value_type> to_vec() const {\n        std::vector<value_type> ret(size());\n        std::copy(table.begin()+size(), table.end(), ret.begin());\n        return ret;\n    }\n\n};/*}}}*/\n/*}}}*/\nlint inf=std::numeric_limits<lint>::max();\n// min-monoid{{{\ntemplate <class Value> struct min_monoid_t {\n    using value_type = Value;\n    static value_type op(value_type l, value_type r) { return std::min(l, r); }\n    static const value_type id;\n};\ntemplate <class Value> const typename min_monoid_t<Value>::value_type\nmin_monoid_t<Value>::id = {inf,inf};\n/*}}}*/\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    lint n=input;\n    std::vector<std::vector<lint>>g(n);\n    for(lint i=0;i<n;i++){\n        lint k=input;\n        LOOP(k){\n            lint j=input;\n            g.at(i).push_back(j);\n            g.at(j).push_back(i);\n        }\n    }\n    DEBUG(matrix_style(g));\n\n    std::vector<lint> ord, depth(n),in_pos(n);\n    auto dfs=[&](auto&&f, lint x, lint p)->void {\n        in_pos.at(x)=ord.size();\n        ord.push_back(x);\n        for(lint y:g.at(x)) if (y!=p) {\n            depth.at(y)=depth.at(x)+1;\n            f(f, y, x);\n            ord.push_back(x);\n        }\n    };\n    dfs(dfs, 0, 0);\n    DEBUG(depth, ord, in_pos);\n    assert((lint)ord.size()==2*n-1);\n\n    auto seg=segtree<min_monoid_t<std::pair<lint,lint>>>(2*n-1);\n    for(lint i=0;i<2*n-1;i++){\n        seg.lazy_set(i, {depth.at(ord.at(i)), ord.at(i)});\n    }\n    seg.build();\n    DEBUG(seg.to_vec());\n\n    lint q=input;\n    LOOP(q){\n        lint u=input,v=input;\n        if(u==v){\n            std::cout<<u<<'\\n';\n            continue;\n        }\n        u=in_pos.at(u), v=in_pos.at(v);\n        if (u>v) std::swap(u, v);\n        auto f = seg.fold(u, v);\n        DEBUG(u, v, f);\n        std::cout << f.second << '\\n';\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=(int)0;i<(int)a;++i)\n#define rrep(i,a) for(int i=(int)a-1;i>=0;--i)\n#define REP(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RREP(i,a,b) for(int i=(int)a-1;i>=b;--i)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\nusing ll=long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n \ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nll gcd(ll n, ll m) {\n    ll tmp;\n    while (m!=0) {\n        tmp = n % m;\n        n = m;\n        m = tmp;\n    }\n    return n;\n}\n \nll lcm(ll n, ll m) {\n    return abs(n) / gcd(n, m)*abs(m);//gl=xy\n}\n\nusing namespace std;\n\ntemplate<typename T>\nstruct LCA{\n\tconst int LOG_N;\n\tvector<int> depth;//根からの深さ\n\tvector<vector<T>> g;\n\tvector<vector<int>> dp;//dp[i][j]:2^i回たどって到達する頂点\n\tbool flag;\n\n\tLCA(vector<vector<T>> &g):g(g),depth(g.size()),LOG_N(log2(g.size())+1){\n\t\tdp.assign(LOG_N, vector<int>(g.size(), -1));\n\t\tflag = false;\n\t}\n\n\tvoid dfs(int v,int p,int d){\n\t\tdp[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor(auto to:g[v]){\n\t\t\tif(to!=p){\n\t\t\t\tdfs(to, v, d + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init(int root=0){\n\t\tflag = true;\n\t\tdfs(root, -1, 0);\n\t\tfor (int k = 0; k + 1 < LOG_N;++k){\n\t\t\tfor (int i = 0; i < dp[0].size();++i){\n\t\t\t\tif(dp[k][i]==-1){\n\t\t\t\t\tdp[k + 1][i] = -1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[k + 1][i] = dp[k][dp[k][i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int u,int v){\n\t\tassert(flag);\n\t\tif (depth[u] > depth[v])\n\t\t{\n\t\t\tswap(u, v);\n\t\t}\n\t\tfor (int i = LOG_N - 1; i >= 0;--i){\n\t\t\tif(((depth[v]-depth[u])>>i)&1)\n\t\t\t\tv = dp[i][v];\n\t\t}\n\t\tif(u==v)\n\t\t\treturn u;\n\t\tfor (int i = LOG_N - 1; i >= 0;--i){\n\t\t\tif(dp[i][u]!=dp[i][v]){\n\t\t\t\tu = dp[i][u];\n\t\t\t\tv = dp[i][v];\n\t\t\t}\n\t\t}\n\t\treturn dp[0][u];\n\t}\n};\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> g(n);\n\trep(i,n){\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j,k){\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tg[i].pb(c);\n\t\t}\n\t}\n\tLCA<int> lca(g);\n\tlca.init();\n\tint q;\n\tcin >> q;\n\trep(i,q){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.query(u, v) << \"\\n\";\n\t}\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(15);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <map>\n#include <utility>\n\n#define MAXN 100000\n\nusing namespace std;\n\nint pre[MAXN] = {-1};\nint st[MAXN];\n\nint seek[MAXN][MAXN];\n\nvector<pair<int,int>> vp;\nmap<pair<int,int>,int> mans;\n\nvoid swap(int &i,int &j){\n    int t = i;\n    i = j;\n    j = t;\n}\n\n\nclass Edge{\npublic:\n    int s;\n    int t;\n    Edge(int si,int ti):s(si),t(ti){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    vector<forward_list<int>> adj;\n    Graph(int v):V(v){\n        adj.resize(v);\n        for(int i = 0; i < V;i++) {st[i] = i;pre[i] = -1;}\n        }\n    void addEdge(int i,int j){adj[i].push_front(j);}\n    void tarjanR(Edge e);\n};\n\nint root(int v){\n    while(st[v] != v) v = st[v];\n    return v;\n}\n\nvoid Graph::tarjanR(Edge e){\n    int t = e.t;\n    int s = e.s;\n    pre[t] = 0;\n\n    for(auto a = adj[t].begin();a != adj[t].end();++a){\n        int v = *a;\n        if(pre[v] == -1){\n            tarjanR(Edge(t,v));\n        }\n    }\n    for(int i = 0; i < V;i++){\n        int mi = i,ma = t;\n        if(mi > ma) swap(mi,ma);\n        pair<int,int> p = make_pair(mi,ma);\n        if(pre[i] != -1 && mans.find(p) != mans.end() && mans[p] == -1){\n            mans[p] = root(i);\n        }\n    }\n    st[t] = s;\n}\n\n\nint main()\n{\n    int V,j,q,tt;\n    scanf(\"%d\",&V);\n    Graph G(V);\n    for(int i = 0; i < V; i++){\n        scanf(\"%d\",&j);\n        for(int k = 0; k < j;k++)\n        {\n            scanf(\"%d\",&tt);\n            G.addEdge(i,tt);\n        }\n    }\n\n    int s,t;\n\n    scanf(\"%d\",&q);\n    for(int i = 0; i < q;i++){\n        scanf(\"%d %d\",&s,&t);\n        if(s > t){swap(s,t);}\n        vp.push_back(make_pair(s,t));\n        mans[make_pair(s,t)] = -1;\n    }\n\n    G.tarjanR(Edge(0,0));\n\n    for(int i = 0; i < q;i++){\n        printf(\"%d\\n\",mans[vp[i]]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L;\n\n  std::vector<int> lg;\n  std::vector<BitIndex> small;\n  std::vector<std::vector<Index>> large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n\nprivate:\n  Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), lg(1 << S), small(N), large(L, std::vector<Index>(LG_L)) {\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li][0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li][0] = F(large[li][0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li][x + 1] = F(large[li][x], large[li + (1 << x)][x]);\n      }\n    }\n    std::vector<Index> st;\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      st.clear();\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (!st.empty() && f(i + si, st.back())) st.pop_back();\n        small[i + si] |= 1 << si;\n        if (!st.empty()) small[i + si] |= small[st.back()];\n        st.push_back(i + si);\n      }\n    }\n  }\n  int ntz(int x) const { return lg[x & -x]; }\n  int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l][x], large[r - (1 << x) + 1][x]);\n  }\n};\n#include <vector>\n#include <map>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::map<int, int> ord;\n\n  EulerTour(int N) : T(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ninline int in(){ int x; cin >> x; return x; }\n\nint main() {\n  int N = in();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = in();\n    for (int j = 0; j < k; j++) {\n      et.add_edge(i, in());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = in();\n  for (int i = 0; i < Q; i++) {\n    int u = in(), v = in();\n    cout << lca.query(u, v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nstruct LCA {\n    int V;//頂点数\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    int MAX_LOG_V = 0;\n    int root = 0;//根ノードの番号\n\n    vector<vector<int>> parent;//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1とする)\n    vector<int> depth;//根からの深さ\n\n    LCA(int V) {\n        this->V = V;\n        while (1 << MAX_LOG_V <= V) {//バグが怖い\n            MAX_LOG_V++;\n        }\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n\n    /**\n     * 辺を追加した後に初期化をする\n     */\n    void init() {\n        //parentとdepthの初期化\n        dfs(root, -1, 0);\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n\n    /**\n     * uとvのlcaを求める\n     * @param u 頂点\n     * @param v 頂点\n     * @return lcaとなる頂点\n     */\n    int lca(int u, int v) {\n        //uとvの高さが同じになるまで親を辿る\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k < MAX_LOG_V; k++) {\n            if((depth[u] - depth[v]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        //二分探索でLCAを求める\n        for (int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /**\n     * 辺を追加する\n     * @param from 元\n     * @param to 先\n     */\n    void add_edge(int from,int to){\n        G[from].push_back(to);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.init();\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// HL ????§£\n// ???????????? v ???????????? c_i ?????????????????????????????¨????????¨?????¨???????????°???\n// ?????§???????????? 1 ?????? c_h ??¨?????????????????¨????????? (v, c_h) ??? \"heavy\" ????????§????????¨?????????\n// ????????\\???????????? \"light\" ????????§????????¨?????????\n\n// ?????????????????? \"heavy\" ??¨ \"light\" ?????????????????¨?????¨??? \"heavy\" ??????????????????\n// (????????????????????¨ chain) ???????§£ (\"heavy\" ??§???????????£???????????????????????¨???????????¨??????) ??§?????????\n// ????????? HL ????§£??¨?????????\n\n// chain ???????´????????????¨?????¨???????????? O(log N) ??§?????????\n// ????????????\"heavy\" ?????????????????????????????? v ??¨ \"light\" ????????§?????°???????????? v ?????????????????????????????????\n// ??¨?????¨?????§????????? subsize(v) / 2 ??\\?????¨?????£??????????????¨???????°??????????\n// \"light\" ??????????????????????????¨?????¨???????????????????????\\???????????????????????±?????? O(log N) ??¨?????????\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\nstruct HLD {\n    int N;\n    const Graph<int> G;\n    // ???????????¨????????????\n    // ??????????????±????????????????????????????????????????????¨????????¨?????¨????????????\n    // ???????????????????????????????????? \"heavy\" ??????\n    vector<int> depth, parent, subsize, heavy;\n    // ???chain ????????????\n    // chain ?????????????´????????°?????´??????????????????? 1 ????¬??????????????´????chain ?????§?????????????????????\n    vector<int> head, last, prev, next, chain, idx;\n    // chain ????????± (?????? vector ????????????????´??????????????????? chain ????±???????)\n    vector< vector<int> > chains;\n\n    HLD(const Graph<int> &H, int r=-1) :\n        N(H.size()), G(H), depth(N, -1), parent(N, 0), subsize(N, 0), heavy(N, -1),\n        head(N), last(N), prev(N, -1), next(N, -1), chain(N, -1), idx(N, 0)\n    {\n        if(r != -1) decompose(r);\n    }\n\n    // root ????????¨??????????§£\n    void decompose(const int root) {\n        stack<int> st; st.push(root);\n        parent[root] = -1;\n        depth[root] = 0;        \n\n        while(st.size()) {\n            int cur_v = st.top(); st.pop();\n            // ?????????????????????????¨???????\n            if(cur_v >= 0) {\n                st.push(~cur_v);\n                for(auto e : G[cur_v]) {\n                    // ??????????????§???????????°????????´??°\n                    if(depth[e.to] != -1) continue;\n                    depth[e.to] = depth[cur_v] + 1;\n                    parent[e.to] = cur_v;\n                    st.push(e.to);\n                }\n            }\n            // ??°?????????\n            else {\n                int ma = 0;\n                cur_v = ~cur_v;\n                subsize[cur_v] = 1;\n                for(auto e : G[cur_v]) {\n                    if(parent[cur_v] == e.to) continue;\n                    subsize[cur_v] += subsize[e.to];\n                    if(ma < subsize[e.to]) {\n                        // cur_v ??¨??¨?????¨????????????????????§??????????????¶\n                        // (????????? \"heavy\" ??????)\n                        ma = subsize[e.to];\n                        heavy[cur_v] = e.to;\n                    }\n                }\n            }\n        }\n\n        st.push(root);\n        while(st.size()) {\n            int cur_v = st.top(); st.pop();\n            for(auto e : G[cur_v]) {\n                if(parent[cur_v] != e.to) st.push(e.to);\n            }\n\n            if(chain[cur_v] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> &path = chains.back();\n\n            for(int v=cur_v; v!=-1; v=heavy[v]) path.push_back(v);\n\n            for(size_t i=0; i<path.size(); i++) {\n                int v = path[i];\n                head[v] = path.front(), last[v] = path.back();\n                prev[v] = (i != 0 ? path[i-1] : -1);\n                next[v] = (i+1 != path.size() ? path[i+1] : -1);\n                chain[v] = (int)chains.size() - 1;\n                idx[v] = i;\n            }\n        }\n    }\n\n    // ?????? v ????????????????????? chain ????±?????????????\n    // ???????????? chain ????????§????????????????????????????????? pair ??§??????\n    pair<int, int> get_index(int v) {\n        return make_pair(chain[v], idx[v]);\n    }\n\n    // v ????±??????? chain ?????????????????? (head[v] ???????????? -1 ?????????)\n    int climb(int v) {\n        return parent[ head[v] ];\n    }\n\n    // ?????? u ??¨ v ???????°???±????\\????\n    int lca(int u, int v) {\n        while(chain[u] != chain[v]) {\n            if(depth[head[u]] < depth[head[v]]) v = climb(v);\n            else u = climb(u);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n};\n\nsigned main() {\n    int N; cin >> N;\n    Graph<int> G(N);\n    rep(i,0,N) {\n        int K; cin >> K;\n        while(K--) {\n            int child; cin >> child;\n            G[i].push_back(Edge<int>(child, 1));\n            G[child].push_back(Edge<int>(i, 1));\n        }\n    }\n\n    HLD hl(G, 0);\n    int Q; cin >> Q;\n\n    /*\n    rep(i,0,N) {\n        pii res = hl.get_index(i);\n        printf(\"vertex %lld: chain = %lld, index = %lld\\n\", i+1, res.first, res.second);\n    }\n    */\n\n    rep(i,0,Q) {\n        int u, v; cin >> u >> v;\n        cout << hl.lca(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct rmqsegtree{\n  vector< pair<int, int> > t; //<data, at>\n  pair<int, int> re;\n  int n;\n  void dflt(void){ re.first = 2147483647; re.second = -1; return; }\n  void use(void){\n    int i; dflt();\n    for(i = 0;;++i)if((1 << i) >= n)break;\n    ++i; t.resize(1 << i); t[0].first = 1 << (i - 1); t[0].second = 1 << i;\n    for(i = 1;i < t[0].second;++i)t[i] = re;\n    for(i = 0;i < n;++i)t[i + t[0].first].second = i;\n    return;\n  }\n  void build(vector<int> a){\n    for(n = 1;;n <<= 1)if(n >= a.size())break;\n    t.resize(n << 1); dflt();\n    t[0].first = n; t[0].second = t[0].first << 1; n = a.size();\n    for(int i = 1;i < t[0].second;++i)t[i] = re;\n    for(int i = 0;i < n;++i){\n      t[t[0].first + i].first = a[i]; t[t[0].first + i].second = i;\n    }\n    for(int i = t[0].first - 1;i >= 1;--i)\n      t[i] = (t[i << 1] <= t[(i << 1) + 1]) ? t[i << 1] : t[(i << 1) + 1];\n    return;\n  }\n  void update(int at, int data){\n    t[t[0].first + at].first = data;\n    for(int x = t[0].first + at;x > 1;){\n      x >>= 1;\n      if(t[x << 1].first <= t[(x << 1) + 1].first)t[x] = t[x << 1];\n      else t[x] = t[(x << 1) + 1];\n    }\n    return;\n  }\n  pair<int, int> query(int l, int r, int k, int kl, int kr){\n    if(l <= t[k].second && t[k].second < r)return t[k];\n    if(k >= t.size())return re;\n    if(kl >= r || kr <= l)return re;\n    if(l <= kl && kr <= r)return t[k];\n    pair<int, int> a = query(l, r, k << 1, kl, (kl + kr) >> 1);\n    pair<int, int> b = query(l, r, (k << 1) + 1, (kl + kr) >> 1, kr);\n    return (a.first < b.first) ? a : b;\n  }\n  pair<int, int> find(int l, int r){ return query(l, r, 1, 0, t[0].first); }\n  void deb(void){\n    int x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].first);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    x = 1;\n    printf(\"t[0] = (%d, %d)\\n\", t[0].first, t[0].second);\n    for(int i = 1;i < t[0].second;++i){\n      printf(\"%3d\", t[i].second);\n      if(i == (1 << x) - 1){ puts(\"\"); ++x; }\n    }\n    return;\n  }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nstruct tree{\n  vector< vector<edge> > t;\n  int v;\n  void nexttree(int x){ //x-indexed\n    scanf(\"%d\", &v);  t.resize(v);\n    int from, to, cost = 1;\n    for(int i = 1;i < v;++i){\n      scanf(\"%d %d\", &from, &to);\n      t[from - x].push_back((edge){to - x, cost});\n      t[to - x].push_back((edge){from - x, cost});\n    }\n    return;\n  }\n  void nexttree2(int x){\n    scanf(\"%d\", &v); t.resize(v);\n    int k, to, cost = 1;\n    for(int i = 0;i < v;++i){\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;++j){\n        scanf(\"%d\", &to);\n        t[i - x].push_back((edge){to - x, cost});\n        t[to - x].push_back((edge){i - x, cost});\n      }\n    }\n    return;\n  }\n  rmqsegtree S;\n  vector<int> vst, dpth, id;\n  void lcarmqdfs(int now, int dep){ //575!!\n    id[now] = vst.size();\n    vst.push_back(now); dpth.push_back(dep);\n    for(int i = 0;i < t[now].size();++i)if(id[t[now][i].to] == -1){\n      lcarmqdfs(t[now][i].to, dep + 1);\n      vst.push_back(now); dpth.push_back(dep);\n    }\n    return;\n  }\n  void lcarmq(void){\n    if(vst.size() > v)return;\n    id.resize(v); for(int i = 0;i < v;++i)id[i] = -1;\n    lcarmqdfs(0, 0);\n    S.build(vst);\n    return;\n  }\n  int lcaid(int a, int b){\n    if(id[a] > id[b])swap(a, b);\n    return vst[S.find(id[a], id[b] + 1).second];\n  }\n  int depth(int a){ return dpth[id[a]]; }\n  int dist(int a, int b){ return depth(a) + depth(b) - 2 * depth(lcaid(a, b)); }\n};\n\nsigned main(void){\n  tree T; T.nexttree2(0);\n  T.lcarmq();\n\n  int q, a, b;\n  scanf(\"%d\", &q);\n  for(;q--;){\n    scanf(\"%d%d\", &a, &b);\n    printf(\"%d\\n\", T.lcaid(a, b));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint n;\n\tint segn;\n\tST(int v,int k):n(v)\n\t{\n\t\tfor (segn = 1; segn < (n * 2 - 1); segn *= 2);\n\t\tdata.assign(2 * segn, make_pair(INF, -1));\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tdata[segn + i] = make_pair(depth[i], et[i]);\n\t\t}\n\t\tfor (int i = segn - 1; i >= 1; --i)\n\t\t{\n\t\t\tdata[i] = min(data[i * 2], data[i * 2 + 1]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = segn;\n\t\t}\n\t\tif (t <= s || r == 0)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (t - s == r)\n\t\t{\n\t\t\treturn data[l];\n\t\t}\n\n\t\treturn min(find(s, min(t, r / 2), l * 2, r / 2), find(max(0, s - (r / 2)), t - (r / 2), l * 2 + 1, r / 2));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tid[n] = eti;\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(n,eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 1, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <cstring> //memset(dp,0,sizeof(dp))\n#include <functional>\n#include <cctype>\n#include <locale>\n#define ll long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> Pll;\n#define fout(num) cout << fixed << setprecision(20) << (num) << endl\n//s[i]=tolower(s[i]); islower(s[i]); cout << tolower(s[i])はバグ\n//vector<vector<ll>> dp(n,vector<ll>(n))\n//exist x map o setconst ll MOD = 1e9+7;return fac[n]*(finv[k]*finv[n-k] % MOD) % MOD;\nstruct RMQ{\nprivate:\n    int n;\n    vector<pair<int,int>> node;\npublic:\n    void rebulid(vector<int> &v){\n        int sz=(int)v.size();\n        n=1; while(n<sz)n*=2;\n        node.resize(2*n-1);\n        for(int i=0;i<sz;i++) node[i+n-1]={v[i],i};\n        for(int i=n-2;i>=0;i--) node[i]=min(node[2*i+1],node[2*i+2]);\n    }\n    pair<int,int> query(int a,int b,int idx=0,int l=0,int r=-1){ /* get [a,b) */\n        if(r<0) r=n;\n        if(r<=a||b<=l) return {1e9,-1};\n        if(a<=l&&r<=b) return node[idx];\n        pair<int,int> vl=query(a,b,2*idx+1,l,(l+r)/2);\n        pair<int,int> vr=query(a,b,2*idx+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n};\n\nstruct LCA{\nprivate:\n    int n;\n    vector<int> EulerTour,depth,id;\n    vector<vector<int>> G;\n    RMQ rmq;\n    void dfs(int v,int pre,int d){\n        id[v]=(int)EulerTour.size();\n        EulerTour.push_back(v);\n        depth[v]=d;\n        for(int u:G[v]){\n            if(u!=pre){\n                dfs(u,v,d+1);\n                EulerTour.push_back(v);\n            }\n        }\n    }\npublic:\n    LCA(int node_size) : n(node_size),G(n), depth(n), id(n, -1){}\n    void add(int from,int to){\n        G[from].push_back(to);\n        G[to].push_back(from);\n    }\n    void build(){\n        EulerTour.reserve(2*n-2);\n        for(int i=0;i<n;i++){\n            if(id[i]<0){\n                dfs(i,-1,0);\n            }\n        }\n        vector<int> vec(2*n-2);\n        for(int i=0;i<2*n-2;i++){\n            vec[i]=depth[EulerTour[i]];\n        }\n        rmq.rebulid(vec);\n    }\n    int lca(int u,int v){\n        return EulerTour[rmq.query(min(id[u],id[v]),max(id[u],id[v])+1).second];\n    }\n    int dist(int u,int v){\n        int lc=lca(u,v);\n        return depth[u]+depth[v]-2*depth[lc];\n    }\n};\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n; cin >> n;\n    LCA hoge(n);\n    rep(i,n){\n        int k; cin >> k;\n        rep(j,k){\n            int a; cin >> a;\n            hoge.add(i,a);\n        }\n    }\n    hoge.build();\n    int q; cin >> q;\n    rep(i,q){\n        int a,b; cin >> a >> b;\n        cout <<  hoge.lca(a,b) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\n\n\nclass RMQsub1{\n\tstd::vector<int> pattern;\n\tstd::vector<std::vector<int> > minpos;\n\tstd::vector<int> depth;\n\tSparseTableRMQ rmq;\n\tint blocksize;\n\tint n;\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tstd::vector<int> B;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k>>1;//log(n)/2\n\t\tif(blocksize==0)blocksize=1;\n\t\tint m=(n+blocksize-1)/blocksize;//num node\n\t\twhile(m&m-1)m+=m&-m;\n\t\tthis->n=m;\n\t\tpattern.resize(n,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tB.resize((n+blocksize-1)/blocksize);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tB[i]=depth[minpos[p][0+b-1]];\n\t\t}\n\t\trmq.build(B);\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\tb--;\n\t\tint ab=a/blocksize,bb=b/blocksize;\n\t\tif(ab==bb)return ab*blocksize + minpos[pattern[ab]][(a%blocksize)*blocksize+b%blocksize];\n\t\tint i,j;\n\t\ti=ab*blocksize + minpos[pattern[ab]][(a%blocksize)*blocksize+blocksize-1];\n\t\tj=bb*blocksize + minpos[pattern[bb]][0+b%blocksize];\n\t\tif(depth[i]>depth[j])i=j;\n\t\tif(ab+1==bb)return i;\n\t\tj=rmq.query(ab+1,bb);\n\t\tj=j*blocksize + minpos[pattern[j]][0+blocksize-1];\n\t\tif(depth[i]>depth[j])i=j;\n\t\treturn i;\n\t}\n};\n\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Lowest Common Ancestor\n//最小共通先祖\n//二部探索を用いる方法\n/*\nint main(){\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    a = max(a, b);\n    a = max(max(a, b), max(c, d));\n\n}*/\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 10000\n#define MAX_LOG_V 100\nvector<int> G[MAX_V];                   //グラフの隣接リスト\nint root;                               //根の頂点番号\nint parent[MAX_LOG_V][MAX_V];           //parent[i][j] := 頂点jから2^i親をたどって到達する頂点\nint depth[MAX_V];                       //根からの深さ\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    //parent[0]とdepthを初期化する\n    dfs(root, -1, 0);\n    //parentを初期化する\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n//uとvのLCAを求める\nint lca(int u, int v){\n    //uとvの深さが同じになるまで親をたどる\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u] >> k) & 1){    //これあテクい\n            v = parent[k][v];\n        }\n    }\n\n    if(u == v) return u;\n\n\n    //二部探索でLCAを求める\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n\n    return parent[0][u];      //uの親を返す\n}\n\nint main(){\n\n    //0-indexed\n    int V; cin >> V;\n    root = 0;\n    for(int i = 0; i < V; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    init(V);\n    int q; cin >> q;\n\n    for(int i = 0; i < q; i++){\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\n#define INF (1 << 30)\nusing namespace std;\n\nvector<int> index(100010);  \nvector<bool> f(100010, false);\nvector<vector<int>> T(100010); //??°??????\nvector<P> ET;              //??????????????¨\n\n//??°???????????????????????¨????????????index?????¨??????????´??????????????????¨?????????????????????????????????????????????\n//ET : 2n - 1 ?????????????????¨??? (??±??????????´???????????????????\nvoid dfs(int n,int dep) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(dep,n));\n\tindex[n] = ET.size() - 1;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1);\n\t\tET.emplace_back(make_pair(dep,n));\n\t}\n}\n\nP RMQ(int a, int b, int k, int l, int r,vector<P>& node) {\n\tif (r <= a || b <= l)return make_pair(INF, 0);\n\tif (a <= l && r <= b) { return node[k]; }\n\tP vl = RMQ(a, b, 2 * k + 1, l, (l + r) / 2,node);\n\tP vr = RMQ(a, b, 2 * k + 2, (l + r) / 2, r,node);\n\n\tif (vl.first > vr.first) {\n\t\treturn vr;\n\t}\n\telse { return vl; }\n}\n\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n_; cin >> n_;\n\tvector<int> v(n_);\n\tfor (int i = 0; i < n_; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\n\tdfs(0,0);\n\n\tn_ = ET.size();\n\tint n = 1;\n\twhile (n < n_) n *= 2;\n\tvector<P> node(2 * n - 1,make_pair(INF,0));\n\tfor (int i = 0; i < n_;i++) {\n\t\tnode[n - 1 + i] = ET[i];\n\t}\t\n\tfor (int i = n - 2; i >= 0; i--) {\n\t\tif (node[2 * i + 1].first > node[2 * i + 2].first) {\n\t\t\tnode[i] = node[2 * i + 2];\n\t\t}\n\t\telse { \n\t\t\tnode[i] = node[2 * i + 1];\n\t\t}\n\t}\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tint a = index[u], b = index[v];\n\t\tif (a > b) swap(a, b);\n\t\tcout << RMQ(a, b, 0, 0, n_, node).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 500){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, -1);\n        int c = 0;\n        for(int u : tord){\n            if(color[u] == -1) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(color[c] != -1) q[r++] = c;\n            }\n            c++;\n        }\n    }\n    int solve(int u, int v){\n        while(topDepth[u] > topDepth[v]) u = goUp[u];\n        while(topDepth[u] < topDepth[v]) v = goUp[v];\n        while(depth[u] > depth[v]) u = parent[u];\n        while(depth[u] < depth[v]) v = parent[v];\n        while(u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 100010;\nclock_t START, END;\n\nint V, Q;\n\nstruct HeapNode {\n\tint d, u;\n\tbool operator < (const HeapNode& rhs) const {\n\t\treturn d > rhs.d;\n\t}\n};\n\nstruct Edge {\n\tint from, to, dist;\n\tEdge(int u, int v, int d) :from(u), to(v), dist(d) {}\n};\n\nstruct Dijkstra {\n\tint n, m;\n\tvector<Edge> edges;\n\tvector<int> G[NUM];\n\n\tint dep[NUM], p[20][NUM];\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\tdfs(0, -1, 0);\n\t\tfor (int k = 0; k + 1 < 20; k++) {\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\tif (p[k][v] < 0)\n\t\t\t\t\tp[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tp[k + 1][v] = p[k][p[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid AddEdge(int from, int to, int dist) {\n\t\tedges.push_back(Edge(from, to, dist));\n\t\tm = edges.size();\n\t\tG[from].push_back(m - 1);\n\t}\n\n\tvoid dfs(int u, int fa, int depth) {\n\t\tdep[u] = depth;\n\t\tp[0][u] = fa;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tEdge& e = edges[G[u][i]];\n\t\t\tint v = e.to;\n\t\t\tif (v == fa)\n\t\t\t\tcontinue;\n\t\t\tdfs(v, u, depth + 1);\n\t\t}\n\t}\n\n\tint lca(int u, int v) {\n\t\tif (dep[u] > dep[v])\n\t\t\tswap(u, v);\n\t\tfor (int k = 0; k < 20; k++) {\n\t\t\tif ((dep[v] - dep[u]) >> k & 1) {\n\t\t\t\tv = p[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tfor (int k = 19; k >= 0; k--) {\n\t\t\tif (p[k][u] != p[k][v]) {\n\t\t\t\tu = p[k][u];\n\t\t\t\tv = p[k][v];\n\t\t\t}\n\t\t}\n\t\treturn p[0][u];\n\t}\n};\n\nDijkstra solve;\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint k, c, u, v;\n\tcin >> V;\n\tfor (int i = 0; i < V; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tsolve.AddEdge(i, c, 1);\n\t\t\tsolve.AddEdge(c, i, 1);\n\t\t}\n\t}\n\tsolve.init(V);\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tprintf(\"%d\\n\", solve.lca(u, v));\n\t}\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100000];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nvoid sub(int idx)\n{\n  sz[idx] = query[idx].size();\n  for(auto &to : g[idx]) {\n    sub(to);\n    sz[idx] += query[to].size();\n  }\n}\n\nvoid dfs(int idx, bool keep)\n{\n  int heavy = -1;\n  for(auto &to : g[idx]) {\n    if(heavy == -1 || sz[to] > sz[heavy]) heavy = to;\n  }\n  for(auto &to : g[idx]) {\n    dfs(to, false);\n  }\n  for(int &v : query[idx]) {\n    buf[v] = true;\n  }\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      if(buf[v]++) lca[v] = idx;\n      query[idx].push_back(v);\n    }\n  }\n  if(!keep) for(auto &v : query[idx]) buf[v] = false;\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n  memset(lca, -1, sizeof(lca));\n  sub(0);\n  dfs(0, 0);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(v) (v).begin(), (v).end()\ntypedef long long int lint;\nusing namespace std;\n\n//ただの辺\nstruct edge {\n    using lint = long long int;\n    int to;\n    lint cost;\n    //引数一つの時は距離1\n    edge(int t, lint c = 1) : to(t), cost(c) {\n    }\n};\n\n// 木のlcaをキビキビ計算\n// depend:edge\nstruct lowest_common_ancestor {\n    using G = vector<vector<edge>>&;\n    G g;\n    int sz;\n    int root;\n    int log;\n    vector<int> dep;\n    vector<vector<int>> parent;\n    lowest_common_ancestor(G _g, int _root)\n        : g(_g), sz(_g.size()), root(_root), dep(_g.size()) {\n        log = 1;\n        while (1 << log < sz) log++;\n        parent.assign(log, vector<int>(sz, -1));\n    }\n    // parent[0]埋め、深さ埋め\n    void dfs(int now, int p, int d) {\n        parent[0][now] = p;\n        dep[now] = d;\n        for (int i = 0; i < (int)g[now].size(); i++) {\n            int next = g[now][i].to;\n            if (next != p) dfs(next, now, d + 1);\n        }\n    }\n    // 前計算を済ませる O(nlog n)\n    void build() {\n        dfs(root, -1, 0);\n        for (int i = 1; i < log; i++) {\n            for (int j = 0; j < sz; j++) {\n                if (parent[i - 1][j] == -1)\n                    parent[i][j] = -1;\n                else\n                    parent[i][j] = parent[i - 1][parent[i - 1][j]];\n            }\n        }\n    }\n    // uとvのlcaを求める O(log sz)\n    int query(int u, int v) {\n        if (dep[u] > dep[v]) swap(u, v);\n        for (int i = 0; i < log; i++) {\n            if ((dep[v] - dep[u]) & (1 << i)) v = parent[i][v];\n        }\n        if (u == v) return u;\n        for (int i = log - 1; i >= 0; i--) {\n            if (parent[i][u] != parent[i][v])\n                u = parent[i][u], v = parent[i][v];\n        }\n        return parent[0][u];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<edge>> g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g[i].push_back(edge(c));\n            g[c].push_back(edge(i));\n        }\n    }\n    lowest_common_ancestor lca(g, 0);\n    lca.build();\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\n\n\nclass RMQsub1{\n\tstd::vector<int> pattern;か\n\tstd::vector<std::vector<int> > minpos;\n\tstd::vector<int> depth;\n\tSparseTableRMQ rmq;\n\tint blocksize;\n\tint n;\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tstd::vector<int> B;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k>>1;//log(n)/2\n\t\tif(blocksize==0)blocksize=1;\n\t\tint m=(n+blocksize-1)/blocksize;//num block\n\t\tthis->n=m;\n\t\tpattern.resize(m,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tB.resize(m);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tB[i]=depth[s+minpos[p][0+b-1]];\n\t\t}\n\t\trmq.build(B);\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\tb--;\n\t\tint ab=a/blocksize,bb=b/blocksize;\n\t\tif(ab==bb)return ab*blocksize + minpos[pattern[ab]][(a-ab*blocksize)*blocksize+b-bb*blocksize];\n\t\tint i,j;\n\t\ti=ab*blocksize + minpos[pattern[ab]][(a-ab*blocksize)*blocksize+blocksize-1];\n\t\tj=bb*blocksize + minpos[pattern[bb]][0+b-bb*blocksize];\n\t\tif(depth[i]>depth[j])i=j;\n\t\tif(ab+1==bb)return i;\n\t\tj=rmq.query(ab+1,bb);\n\t\tj=j*blocksize + minpos[pattern[j]][0+blocksize-1];\n\t\tif(depth[i]>depth[j])i=j;\n\t\treturn i;\n\t}\n};\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int MAX_V = 1e5+10;\nconst int MAX_LOG_V = 110;\n\nvector<int> G[MAX_V];\nint V, root;\n\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid add_edge(int s, int t){\n\tG[s].push_back(t);\n}\n\nvoid dfs(int v, int p, int d){\n\tparent[0][v] = p;\n\tdepth[v] = d;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tif (G[v][i] != p) dfs(G[v][i], v, d+1);\n\t}\n}\n\nvoid init() {\n\tdfs(root, -1, 0);\n\tfor (int k = 0; k+1 < MAX_LOG_V; ++k)\n\t{\n\t\tfor (int v = 0; v < V; ++v)\n\t\t{\n\t\t\tif (parent[k][v] < 0) parent[k+1][v] = -1;\n\t\t\telse parent[k+1][v] = parent[k][parent[k][v]];\n\t\t}\n\t}\n}\n\nint lca(int u, int v) {\n\tif (depth[u] > depth[v]) swap(u, v);\n\tfor (int k = 0; k < MAX_LOG_V; ++k) {\n\t\tif ((depth[v] - depth[u]) >> k & 1) v = parent[k][v];\n\t}\n\tif (u == v) return u;\n\n\tfor (int k = MAX_LOG_V - 1; k >= 0; k--)\n\t{\n\t\tif (parent[k][u] != parent[k][v])\n\t\t{\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}\n\nint main(int argc, char const *argv[])\n{\n\tcin >> V;\n\troot = 0;\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; ++j)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tadd_edge(i, c);\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\tvector<pair<int, int> > vec;\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tvec.push_back(make_pair(u, v));\n\t}\n\tinit();\n\tfor (int i = 0; i < vec.size(); ++i)\n\t{\n\t\tcout << lca(vec[i].first, vec[i].second) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0, i##_len = (n); i < i##_len; i++)\n#define reps(i, s, n) for(ll i = (s), i##_len = (n); i < i##_len; i++)\n#define rrep(i, n) for(ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, e, n) for(ll i = (n) - 1; i >= (e); i--)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((ll)(x).size())\n#define len(x) ((ll)(x).length())\n#define endl \"\\n\"\n\nstruct HeavyLightDecomposition {\nprivate:\n    void dfs_sz(int v) {\n        for(int &u : g[v]) {\n            if (u == par[v]) swap(u, g[v].back());\n        }\n        if (~par[v]) g[v].pop_back();\n        for(int &u : g[v]) {\n            par[u] = v;\n            dep[u] = dep[v] + 1;\n            dfs_sz(u);\n            sub[v] += sub[u];\n            if (sub[u] > sub[g[v][0]]) swap(u, g[v][0]);\n        }\n    }\n    \n    void dfs_hld(int v, int c, int &idx) {\n        vid[v] = idx++;\n        inv[vid[v]] = v;\n        type[v] = c;\n        for(int &u : g[v]) {\n            if (u == par[v]) continue;\n            head[u] = ((u == g[v][0]) ? head[v] : u);\n            dfs_hld(u, c, idx);\n        }\n    }\n    \npublic:\n    vector<vector<int>> g;\n    vector<int> par, sub, dep, vid, inv, type, head;\n    \n    HeavyLightDecomposition() {}\n    HeavyLightDecomposition(int n) {\n        g.resize(n);\n        par.resize(n, -1);\n        dep.resize(n, 0);\n        sub.resize(n, 1);\n        vid.resize(n, -1);\n        inv.resize(n);\n        type.resize(n);\n        head.resize(n);\n    }\n    \n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    void build(vector<int> rs = {0}) {\n        int c = 0, idx = 0;\n        for(int r : rs) {\n            dfs_sz(r);\n            head[r] = r;\n            dfs_hld(r, c++, idx);\n        }\n    }\n    \n    int lca(int u, int v) {\n        while(true) {\n            if (vid[u] > vid[v]) swap(u, v);\n            if (head[u] == head[v]) return u;\n            v = par[head[v]];\n        }\n    }\n    \n    int distance(int u, int v) {\n        return dep[u] + dep[v] - 2 * dep[lca(u, v)];\n    }\n    \n    template<class F>\n    void for_each(int u, int v, const F &f) {\n        while(true) {\n            if (vid[u] > vid[v]) swap(u, v);\n            f(max(vid[head[v]], vid[u]), vid[v] + 1);\n            if (head[u] == head[v]) break;\n            v = par[head[v]];\n        }\n    }\n    \n    template<class T, class Q, class F>\n    T for_each(int u, int v, T ti, const Q &q, const F &f) {\n        T l = ti, r = ti;\n        while(true) {\n            if (vid[u] > vid[v]) {\n                swap(u, v);\n                swap(l, r);\n            }\n            l = f(l, q(max(vid[head[v]], vid[u]), vid[v] + 1));\n            if (head[u] == head[v]) break;\n            v = par[head[v]];\n        }\n        return f(l, r);\n    }\n    \n    template<class F>\n    void for_each_edge(int u, int v, const F &f) {\n        while(true) {\n            if (vid[u] > vid[v]) swap(u, v);\n            if (head[u] != head[v]) {\n                f(vid[head[v]], vid[v] + 1);\n                v = par[head[v]];\n            }\n            else {\n                if (u != v) f(vid[u] + 1, vid[v] + 1);\n                break;\n            }\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // ifstream in(\"input.txt\");\n    // cin.rdbuf(in.rdbuf());\n    ll n;\n    cin >> n;\n    HeavyLightDecomposition hld(n);\n    rep(i, n) {\n        ll k;\n        cin >> k;\n        rep(j, k) {\n            ll c;\n            cin >> c;\n            hld.add_edge(i, c);\n        }\n    }\n    hld.build();\n    ll q;\n    cin >> q;\n    rep(i, q) {\n        ll u, v;\n        cin >> u >> v;\n        cout << hld.lca(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nvector<size_t> get_parents(const Graph &g, size_t root=0) {\n    size_t V=g.size();\n    vector<size_t> parents(V);\n    for (size_t i=0; i<V; ++i)\n        for (const Edge &e: g[i])\n            parents[e.dst] = e.src;\n\n    return parents;\n}\n\nvector<vector<size_t>> get_ancestors(\n    const Graph &g, const vector<size_t> &parents\n) {\n    size_t V=g.size();\n    vector<vector<size_t>> ancestors(V);\n    for (size_t i=0; i<V; ++i)\n        ancestors[i].push_back(parents[i]);\n\n    for (size_t j=0; (1u<<j)<V; ++j)\n        for (size_t i=0; i<V; ++i) {\n            if (j < ancestors[i].size() && ~ancestors[i][j]) {\n                size_t parent=ancestors[i][j];\n                ancestors[i].push_back(ancestors[parent][j]);\n            }\n        }\n\n    return ancestors;\n}\n\nvector<size_t> get_depth(const Graph &g, size_t root=0) {\n    size_t V=g.size();\n    vector<size_t> depth(V);\n\n    queue<size_t> q; q.push(root);\n    while (!q.empty()) {\n        size_t v=q.front(); q.pop();\n        for (const Edge &e: g[v]) {\n            depth[e.dst] = depth[v] + 1;\n            q.push(e.dst);\n        }\n    }\n\n    return depth;\n}\n\nsize_t get_kth_ancestor(\n    size_t v, size_t k, const vector<vector<size_t>> &ancestors\n) {\n    for (size_t i=0; k; (++i, k>>=1))\n        if (k & 1)\n            v = ancestors[v][i];\n\n    return v;\n}\n\nsize_t lcancestor(\n    size_t u, size_t v, const vector<vector<size_t>> &ancestors,\n    vector<size_t> &depth\n) {\n    if (depth[u] > depth[v])\n        swap(u, v);\n\n    v = get_kth_ancestor(v, depth[v]-depth[u], ancestors);\n\n    if (u == v) return u;\n    for (size_t i=ancestors[0].size(); i--;)\n        if (ancestors[u][i] != ancestors[v][i]) {\n            u = get_kth_ancestor(u, 1<<i, ancestors);\n            v = get_kth_ancestor(v, 1<<i, ancestors);\n        }\n\n    return ancestors[u][0];\n}\n\nint main() {\n    size_t V;\n    scanf(\"%zu\", &V);\n\n    Graph g(V);\n    for (size_t i=0; i<V; ++i) {\n        size_t k;\n        scanf(\"%zu\", &k);\n        for (size_t j=0; j<k; ++j) {\n            size_t c;\n            scanf(\"%zu\", &c);\n\n            connect(g, i, c);\n        }\n    }\n\n    vector<size_t> depth=get_depth(g, 0), parents=get_parents(g);\n    vector<vector<size_t>> ancestors=get_ancestors(g, parents);\n\n    size_t q;\n    scanf(\"%zu\", &q);\n\n    for (size_t i=0; i<q; ++i) {\n        size_t u, v;\n        scanf(\"%zu %zu\", &u, &v);\n\n        printf(\"%zd\\n\", lcancestor(u, v, ancestors, depth));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass RMQ{\nprivate:\n    int N;\n    vector<int> data;\n    \n    int find(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l)\n            return INF;\n        if(a <= l && r <= b)\n            return data[k];\n        int x1 = find(a, b, 2*k+1, l, (l+r)/2);\n        int x2 = find(a, b, 2*k+2, (l+r)/2, r);\n        return min(x1, x2);\n    }\n    \npublic:\n    RMQ(int N_){\n        N = 1;\n        while(N < N_)\n            N <<= 1;\n        data.assign(2*N-1, INF);\n    }\n    \n    void update(int x, int a){\n        x += N-1;\n        data[x] = a;\n        while(x){\n            x = (x-1)/2;\n            data[x] = min(data[2*x+1], data[2*x+2]);\n        }\n    }\n    int find(int a, int b){\n        return find(a, b, 0, 0, N);\n    }\n};\n\nvoid euler_tour(vector<vector<int>> &G, int u, int d, vector<int> &tour, vector<int> &depth){\n    tour.push_back(u);\n    depth.push_back(d);\n    for(auto v: G[u]){\n        euler_tour(G, v, d+1, tour, depth);\n        tour.push_back(u);\n        depth.push_back(d);\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    \n    for(int i=0; i<N; i++){\n        int k; cin >> k;\n        for(int j=0; j<k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    \n    vector<int> tour, depth;\n    euler_tour(G, 0, 0, tour, depth);\n    vector<int> rightmsot(N);\n    for(int i=0; i<tour.size(); i++)\n        rightmsot[tour[i]] = i;\n    \n    RMQ rmq(tour.size());\n    for(int i=0; i<tour.size(); i++){\n//        cout << tour[i] << \" \" << depth[i] << endl;\n        rmq.update(i, depth[i]);\n    }\n    \n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++){\n        int u, v; cin >> u >> v;\n        int ru = rightmsot[u], rv = rightmsot[v];\n        if(ru > rv)\n            swap(ru, rv);\n        rv++;\n        int d = rmq.find(ru, rv);\n        for(int j=ru; j<rv; j++){\n            if(depth[j] == d){\n                cout << tour[j] << endl;\n                break;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t{\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n  bool rev;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL;\n    rev=false; \n    lazy=0; \n    update();\n  }\n   \n  void update(){\n    mini=val,minId=id;\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>=rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  void apply(int v){ lazy+=v, val+=v, mini+=v; }\n   \n  void push(){\n    if(rev){\n      rev=false;\n      swap(lp,rp);\n      if(lp)lp->rev^=true;\n      if(rp)rp->rev^=true;\n    }\n    if(lp)lp->apply(lazy);\n    if(rp)rp->apply(lazy);\n    lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  x->splay();\n  return x;\n  //return rp; //lca\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n  c->update();\n}\n\n//Unverified.\nvoid evert(node_t *p){\n  node_t *r=expose(p);\n  r->rev^=true;\n}\n\n//Verified.\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->apply(val); }\n\n//Verified. AOJ GRL_5_C\nnode_t *LCA(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\n//AOJ GRL_5_C\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << LCA(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int, int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v=st.top().first;\n      int &i=st.top().second;\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tint res=0;\n\tfor(int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\nsigned AOJ_GRL5C(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned YUKI_529(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/12/31\nhttps://yukicoder.me/problems/no/529\n*/\n\nsigned main(){\n  AOJ_GRL5C();\n  //YUKI_529();\n  return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint clog2(int n){\n  n--;\n  int res = 0;\n  while(n > 0)res++, n >>=1;\n  return res;\n}\n\nstruct LCA{\n  int n, root, logn;\n  vector<int> lvl;\n  vector<vector<int>> ady, up;\n\n  LCA(vector<vector<int>> ady, int root):\n    ady(ady), n(ady.size()), root(root), logn(clog2(n)){init();}\n\n  void init(){\n    up.assign(n, vector<int>(logn + 1));\n    lvl.assign(n, 0);\n    dfs(root, root, 0);\n    for(int p = 1; p <= logn; p++){\n      for(int i = 0; i < n; i++){\n\tup[i][p] = up[up[i][p - 1]][p - 1];\n      }\n    }\n  }\n\n  void dfs(int v, int p, int l){\n    lvl[v] = l;\n    up[v][0] = p;\n    for(int u : ady[v]){\n      if(u != p) dfs(u, v, l + 1);\n    }\n  }\n\n  int jump(int u, int d){\n    for(int p = logn; p >= 0; p--){\n      if(d & (1 << p)) u = up[u][p];\n    }\n    return u;\n  }\n  \n  int lca(int u, int v){\n    if(lvl[u] > lvl[v]) swap(u, v);\n    v = jump(v, lvl[v] - lvl[u]);\n    if(u == v) return u;\n    for(int p = logn; p >= 0; p--){\n      if(up[u][p] != up[v][p]){\n\tu = up[u][p], v = up[v][p];\n      }\n    }\n    return up[u][0];\n  }\n};\n\n// test: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n\nint main(){\n  int n;\n  cin >> n;\n  vector<vector<int>> ady;\n  for(int i = 0; i < n; i++){\n    int k;\n    cin >> k;\n    vector<int> v(k);\n    for(int j = 0; j < k; j++){\n      cin >> v[j];\n    }\n    ady.push_back(v);\n  }\n  LCA lca(ady, 0);\n  int q;\n  cin >> q;\n  while(q--){\n    int u, v;\n    cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// \n// Least common ancestor by doubling\n//\n// Description:\n//   For a rooted tree T, LCA(u,v) is a vertex u\n//   that is the deepest node that is a common ancestor of u and v.\n//\n// Algorithm:\n//   It stores all 2^k-ancestors for all vertices.\n//   Then LCA can be solved in O(log n) time.\n//\n// Complexity:\n//   O(n) for preprocessing,\n//   O(log n) for query\n//\n// Verified:\n//   AOJ GRL_5C\n//\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n#define TEST(s) if (!(s)) { cout << __LINE__ << \" \" << #s << endl; exit(-1); }\n\n\nstruct tree {\n  int n, logn;\n  vector<vector<int>> adj;\n  tree(int n) : n(n), adj(n) { \n    logn = 1;\n    for (int k = 1; k < n; k *= 2) ++logn;\n  }\n  void add_edge(int s, int t) {\n    adj[s].push_back(t);\n    adj[t].push_back(s);\n  }\n  vector<vector<int>> parent;\n  vector<int> rank, depth;\n  void rootify(int r) {\n    parent.assign(logn, vector<int>(n, r));\n    rank.resize(n);\n    depth.assign(n, 0);\n    int id = 0;\n    function<void (int,int)> dfs = [&](int u, int p) {\n      rank[u] = id++;\n      parent[0][u] = p;\n      for (int i = 0; i+1 < logn; ++i) \n        parent[i+1][u] = parent[i][parent[i][u]];\n      for (int v: adj[u]) \n        if (v != p) { depth[v] = depth[u]+1; dfs(v, u); }\n    }; dfs(r, r);\n  }\n\n  int lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int i = depth[v]-depth[u], k = 0; i; i /= 2) {\n      if (i & 1) v = parent[k][v];\n      ++k;\n    }\n    if (u == v) return u;\n    for (int i = logn-1; i >= 0; --i) {\n      if (parent[i][u] != parent[i][v]) {\n        u = parent[i][u];\n        v = parent[i][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  tree T(n);\n  for (int u = 0; u < n ; ++u) {\n    int k; \n    scanf(\"%d\", &k);\n    for (int j = 0; j < k; ++j) {\n      int v;\n      scanf(\"%d\", &v);\n      T.add_edge(u, v);\n    }\n  }\n  T.rootify(0);\n  int q;\n  scanf(\"%d\", &q);\n  for (int i = 0; i < q; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", T.lca(u, v));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint N; // Graph(Tree)の頂点数\nvector< vector<int> > G; // Graph(Tree)の隣接リスト表現\nvector<int> D; // 各頂点のrootからの距離\nint LOG_N; // log2(N)の天井\nvector< vector<int> > P; // P[k][v] : 頂点vの2^k番目の先祖\nvoid dfs(int prev, int index, int d) {\n    P[0][index] = prev;\n    D[index] = d;\n    for (int i = 0; i < G[index].size(); i++) {\n        int next = G[index][i];\n        if (next == prev) continue;\n        dfs(index, next, d + 1);\n    }\n}\nvoid init() {\n    LOG_N = int(ceil(log2(N) + 1));\n    P.clear(); P.resize(LOG_N, vector<int>(N));\n    D.clear(); D.resize(N);\n    dfs(-1, 0, 0);\n    for (int k = 0; k < LOG_N - 1; k++) {\n        for (int v = 0; v < N; v++) {\n            if (P[k][v] < 0) P[k + 1][v] = -1;\n            else P[k + 1][v] = P[k][ P[k][v] ];\n        }\n    }\n}\n// 頂点vのn番目の親を返す\nint nth_parent(int v, int n) {\n    for (int k = 0; k < LOG_N; k++)\n        if (n & (1 << k)) v = P[k][v];\n    return v;\n}\n// 2頂点uとvのLCAを返す\nint lca(int u, int v) {\n    if (D[u] > D[v]) swap(u, v);\n    v = nth_parent(v, D[v] - D[u]);\n    if (u == v) return u;\n    for (int k = LOG_N - 1; k >= 0; k--) {\n        if (P[k][u] != P[k][v]) {\n            u = P[k][u];\n            v = P[k][v];\n        }\n    }\n    return P[0][u];\n}\n// 2頂点uとvの距離を返す\nint dist(int u, int v) {\n    int root = lca(u, v);\n    return (D[u] - D[root]) + (D[v] - D[root]);\n}\n\nint main() {\n    cin >> N;\n    G.clear(); G.resize(N);\n    for (int i = 0; i < N; i++) {\n        int k; cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    init();\n    int Q; cin >> Q;\n    for (int q = 0; q < Q; q++) {\n        int u, v; cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\n// #define TEST\n\ntemplate <typename T>\nstruct HLD {\n\tvector<vector<pair<int, T>>> g;\n\tint n;\n\tvector<int> subsz, depth, parent;\n\tvector<vector<T>> chain_edge;\n\tvector<vector<int>> chain_node;\n\tmap<int, int> chain_top, chain_id, id_in_chain;\n\n\t/* constructor */\n\tHLD(vector<vector<pair<int, T>>>& g) {\n\t\tthis->g = g; n = g.size();\n\t\tparent.resize(g.size());\n\t\tsubsz.resize(g.size());\n\t\tdepth.resize(g.size());\n\t}\n\n\t/* init parent, depth, and subsz */\n\tint dfs_sz(int s = 0, int p = -1, int dep = 0) {\n\t\tparent[s] = p;\n\t\tdepth[s] = dep;\n\t\tint sz = 1;\n\t\tif (g[s].size() > 2 && g[s][0].first == p)\n\t\t\tswap(g[s][0], g[s][1]); // g[s][0] must be heavy\n\t\tfor (int i = 0; i < g[s].size(); ++i) {\n\t\t\tif (g[s][i].first != p) {\n\t\t\t\tsz += dfs_sz(g[s][i].first, s, dep + 1);\n\t\t\t\tif (subsz[g[s][0].first] < subsz[g[s][i].first])\n\t\t\t\t\tswap(g[s][0], g[s][i]); // g[s][0] must be heavy\n\t\t\t}\n\t\t}\n\t\tsubsz[s] = sz;\n\t\treturn sz;\n\t}\n\n\t/* HL Decomposition */\n\tvoid dfs_hld(int s, int& cid) {\n\t\tchain_id[s] = cid;\n\t\tfor (int i = 0; i < g[s].size(); ++i) {\n\t\t\tif (g[s][i].first != parent[s]) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tchain_edge.resize(cid + 1);\n\t\t\t\t\tchain_node.resize(cid + 1);\n\t\t\t\t\tchain_edge[cid].push_back(g[s][i].second);\n\t\t\t\t\tchain_node[cid].push_back(g[s][i].first);\n\t\t\t\t\tid_in_chain[g[s][i].first] = chain_edge[cid].size();\n\t\t\t\t\tdfs_hld(g[s][i].first, cid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t++cid;\n\t\t\t\t\tchain_edge.resize(cid + 1);\n\t\t\t\t\tchain_node.resize(cid + 1);\n\t\t\t\t\tchain_edge[cid].push_back(g[s][i].second);\n\t\t\t\t\tchain_node[cid].push_back(g[s][i].first);\n\t\t\t\t\tid_in_chain[g[s][i].first] = chain_edge[cid].size();\n\t\t\t\t\tdfs_hld(g[s][i].first, cid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the number of chain */\n\tint chain_number() {\n\t\treturn chain_node.size();\n\t}\n\n\t/* find chain_top */\n\tvoid find_chain_top() {\n\t\tfor (int i = 0; i < chain_number(); ++i)\n\t\t\tchain_top[i] = parent[chain_node[i][0]];\n\t}\n\n\t/* for test */\n\tvoid show() {\n#ifdef TEST\n\t\tfor (int i = 0; i < chain_number(); ++i) {\n\t\t\tcout << \"chain id : \" << i << endl;\n\t\t\tcout << \"    \" << chain_top[i];\n\t\t\tfor (int j = 0; j < chain_edge[i].size(); ++j)\n\t\t\t\tcout << \"-(\" << chain_edge[i][j] << \")-\" << chain_node[i][j];\n\t\t\tcout << endl;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << \"node : \" << i << endl;\n\t\t\tcout << \"    chain : \" << chain_id[i] << \",  id_in_chain : \" << id_in_chain[i] << endl;\n\t\t}\n#endif\n\t}\n\n\t/* build */\n\tvoid build() {\n\t\tdfs_sz();\n\t\tint cid = 0;\n\t\tdfs_hld(0, cid);\n\t\tfind_chain_top();\n\t}\n\n\t/* find lca */\n\tint LCA(int s, int t) {\n\t\tif (chain_id[s] < chain_id[t]) swap(s, t);\n\t\twhile (chain_id[s] != chain_id[t]) {\n\t\t\ts = chain_top[chain_id[s]];\n\t\t\tif (chain_id[s] < chain_id[t]) swap(s, t);\n\t\t}\n\t\tif (depth[s] < depth[t]) return s;\n\t\treturn t;\n\t}\n};\n\nint main() {\n\tint n; cin >> n;\n\tvector<vector<pair<int, int>>> g(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint k; cin >> k;\n\t\twhile (k--) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(c, 1);\n\t\t\tg[c].emplace_back(i, 1);\n\t\t}\n\t}\n\tHLD<int> tree(g);\n\ttree.build();\n\ttree.show();\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << tree.LCA(u, v) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    //len.resize(pathCount);\n    /*\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef long long int ll;\n\nstruct LowestCommonAncester{\n    int n,h;\n    vector<vector<int>> g,par;\n    vector<int> dep;\n    LowestCommonAncester(int n):n(n),g(n),dep(n){\n        h=1;\n        while((1<<h)<=n)h++;\n        par.assign(h,vector<int> (n,-1));\n    }\n    void add_edge(int u,int v){\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    void dfs(int v,int p,int d){\n        par[0][v]=p;\n        dep[v]=d;\n        for(auto u:g[v]){\n            if(u!=p)dfs(u,v,d+1);\n        }\n    }\n    void build(int r){\n        dfs(r,-1,0);\n        for(int i=0;i<h-1;i++){\n            for(int j=0;j<n;j++){\n                if(par[i][j]>=0)par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n    }\n    int lca(int u,int v){\n        if(dep[u]>dep[v])swap(u,v);\n        for(int i=0;i<h;i++){\n            if((dep[v]-dep[u])&1<<i)v=par[i][v];\n        }\n        if(u==v)return u;\n        for(int i=h-1;i>=0;i--){\n            if(par[i][u]!=par[i][v])u=par[i][u],v=par[i][v];\n        }\n        return par[0][u];\n    }\n    int distance(int u,int v){\n        return dep[u]+dep[v]-dep[lca(u,v)]*2;\n    }\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    LowestCommonAncester LCA(n);\n    for(int i=0;i<n;i++){\n        int a; cin >> a;\n        for(int j=0;j<a;j++){\n            int x; cin >> x;\n            LCA.add_edge(i,x);\n        }\n    }\n    LCA.build(0);\n    int q; cin >> q;\n    while(q--){\n        int x,y; cin >> x >> y;\n        cout << LCA.lca(x,y) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n/// --- LinkCutTree Library {{{ ///\n\ntemplate < class Monoid, class M_act >\nstruct LinkCutTree {\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n  struct Splay;\n  int n;\n\n  // Splay sequence {{{\n  struct Splay {\n    int ch[2] = {-1, -1}, p = -1;\n    vector< Splay > &data;\n    int id;\n    X val, accum;\n    M lazy = M_act::identity(); ///////\n    // BSTの大きさ\n    // 実際の部分木の大きさ，ではない\n    int sz = 1;\n    bool isRoot() {\n      return p == -1 || (data[p].ch[0] != id && data[p].ch[1] != id);\n    }\n    bool rev = false;\n    // call before use\n    void eval() {\n      if (rev) {\n        swap(ch[0], ch[1]);\n        if (ch[0] != -1) data[ch[0]].rev ^= 1;\n        if (ch[1] != -1) data[ch[1]].rev ^= 1;\n        rev = false;\n      }\n      if (lazy != M_act::identity()) {\n        val = M_act::actInto(lazy, 1, val);\n        accum = M_act::actInto(lazy, sz, accum);\n        for (int i = 0; i < 2; i++)\n          if (ch[i] != -1) data[ch[i]].lazy = M_act::op(lazy, data[ch[i]].lazy);\n        lazy = M_act::identity();\n      }\n    }\n    void evalDown() {\n      vector< int > b2t;\n      int t = id;\n      for (; !data[t].isRoot(); t = data[t].p) b2t.emplace_back(t);\n      data[t].eval();\n      while (b2t.size()) data[b2t.back()].eval(), b2t.pop_back();\n      vector< int >().swap(b2t);\n    }\n    X accumulated(int a) {\n      return a == -1 ? Monoid::identity() : data[a].accum;\n    }\n    int size(int a) { return a == -1 ? 0 : data[a].sz; }\n    // call after touch\n    void prop() {\n      if (ch[0] != -1) data[ch[0]].eval(); ////\n      if (ch[1] != -1) data[ch[1]].eval(); ////\n      sz = size(ch[0]) + 1 + size(ch[1]);\n      accum =\n          Monoid::op(Monoid::op(accumulated(ch[0]), val), accumulated(ch[1]));\n    }\n    Splay(vector< Splay > &data, const X &val)\n        : data(data), val(val), accum(val) {}\n    int rotate(bool R) {\n      int t = ch[!R];\n      if ((ch[!R] = data[t].ch[R]) != -1) data[ch[!R]].p = id;\n      data[t].ch[R] = id; ////\n      if ((data[t].p = p) != -1) {\n        if (data[data[t].p].ch[0] == id) data[data[t].p].ch[0] = t;\n        if (data[data[t].p].ch[1] == id) data[data[t].p].ch[1] = t;\n      }\n      p = t; //////\n      prop();\n      data[t].prop();\n      return t;\n    }\n    // bottom-up\n    int splay() {\n      evalDown();\n      while (!this->isRoot()) {\n        int q = p;\n        if (data[q].isRoot()) {\n          data[q].rotate(data[q].ch[0] == id);\n        } else {\n          int r = data[q].p;\n          bool V = data[r].ch[0] == q;\n          if (data[q].ch[!V] == id)\n            data[r].rotate(V);\n          else\n            data[q].rotate(!V);\n          data[p].rotate(V); ///////\n        }\n      }\n      return id;\n    }\n  };\n  // }}}\n\n  vector< Splay > data;\n  LinkCutTree() : n(0) {}\n  LinkCutTree(int n, const X &initial = Monoid::identity())\n      : n(n), data(n, Splay(data, initial)) {\n    for (int i = 0; i < n; i++) data[i].id = i;\n  }\n  const X &get(int i) {\n    data[i].evalDown();\n    return data[i].val;\n  }\n  void set(int i, X val) {\n    data[i].splay();\n    data[i].val = val;\n    data[i].prop();\n  }\n\n  // LinkCutTree implementation\n\n  int expose(int i) {\n    int prv = -1, now = i;\n    for (; now != -1; prv = now, now = data[now].p) {\n      data[now].splay();\n      data[now].ch[1] = prv;\n      data[now].prop();\n    }\n    data[i].splay(); /////\n    return prv;\n  }\n  void cut(int c) {\n    expose(c);\n    int s = data[c].ch[0];\n    data[c].ch[0] = -1;\n    data[c].prop();\n    data[s].p = -1;\n  }\n  void link(int p, int c) {\n    expose(p);\n    expose(c);\n\n    static const struct CannotLinkSameNode {\n    } ex;\n    if (data[p].p != -1) throw ex;\n\n    data[c].p = p;\n\n    data[p].ch[1] = c;\n    data[p].prop();\n  }\n  void evert(int x) {\n    expose(x);\n    data[x].rev = true;\n  }\n  bool same(int a, int b) {\n    if (a == b) return true;\n    expose(a);\n    expose(b);\n    return data[a].p != -1;\n  }\n  int lca(int a, int b) {\n    expose(a);\n    int r = expose(b);\n    return r == -1 ? b : r;\n  }\n  void act(int a, int b, const M &m) {\n    static const struct CannotActAnotherNode {\n    } ex;\n    if (!same(a, b)) throw ex;\n    // evert(a);\n    expose(b);\n    data[b].lazy = M_act::op(m, data[b].lazy);\n  }\n  X query(int a) {\n    // static const struct CannotQueryAnotherNode {\n    // } ex;\n    // if (!same(a, b)) throw ex;\n    // evert(a);\n    expose(a);\n    return data[a].accum;\n  }\n};\n\n/// }}}--- ///\n\n// Monoid, M_act expamles {{{\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class S, class X >\n  static constexpr X actInto(const M &, S, const X &x) {\n    return x;\n  }\n};\n\n// }}}\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n;\n  cin >> n;\n  LinkCutTree< Nothing, Nothing > lc(n); ////\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    while(k--) {\n      int a;\n      cin >> a;\n      lc.evert(a);\n      lc.link(i, a);\n    }\n  }\n  // lc.evert(0);\n  int q;\n  cin >> q;\n  while (q--) {\n    int a, b;\n    cin >> a >> b;\n    cout << lc.lca(a, b) << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass RMQ{\nprivate:\n    int N;\n    vector<int> data;\n    vector<int> rdata;\n    \n    int find(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l)\n            return -1;\n        if(a <= l && r <= b)\n            return data[k];\n        int x1 = find(a, b, 2*k+1, l, (l+r)/2);\n        int x2 = find(a, b, 2*k+2, (l+r)/2, r);\n        \n        if(x1 == -1)\n            return x2;\n        if(x2 == -1)\n            return x1;\n        if(rdata[x1] < rdata[x2])\n            return x1;\n        else\n            return x2;\n    }\n    \npublic:\n    RMQ(vector<int> vec){\n        N = 1;\n        while(N < vec.size())\n            N <<= 1;\n        data.assign(2*N-1, -1);\n        rdata.assign(N, INF);\n        \n        for(int i=0; i<vec.size(); i++){\n            data[i+N-1] = i;\n            rdata[i] = vec[i];\n        }\n        for(int p=N-2; p>=0; p--){\n            if(rdata[data[p*2+1]] < rdata[data[p*2+2]])\n                data[p] = data[p*2+1];\n            else\n                data[p] = data[p*2+2];\n        }\n    }\n    int find(int a, int b){\n        return find(a, b, 0, 0, N);\n    }\n};\n\nvoid euler_tour(vector<vector<int>> &G, int u, int d, vector<int> &tour, vector<int> &depth){\n    tour.push_back(u);\n    depth.push_back(d);\n    for(auto v: G[u]){\n        euler_tour(G, v, d+1, tour, depth);\n        tour.push_back(u);\n        depth.push_back(d);\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    \n    for(int i=0; i<N; i++){\n        int k; cin >> k;\n        for(int j=0; j<k; j++){\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    \n    vector<int> tour, depth;\n    euler_tour(G, 0, 0, tour, depth);\n    vector<int> rightmsot(N);\n    for(int i=0; i<tour.size(); i++)\n        rightmsot[tour[i]] = i;\n    \n    RMQ rmq(tour);\n    \n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++){\n        int u, v; cin >> u >> v;\n        int ru = rightmsot[u], rv = rightmsot[v];\n        if(ru > rv)\n            swap(ru, rv);\n        rv++;\n        int d = rmq.find(ru, rv);\n        cout << tour[d] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<typename T> class Monoid{\npublic:\n\tvirtual inline T e()=0,c(T,T)=0;\n};\n\ntemplate<typename T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;Monoid<T>& m;\n\tSegmentTree(int n,Monoid<T>& m):size(n),n2(upper_pow2(size)),m(m){\n\t\tdat=vector<T>(n2*2,m.e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return m.e();//out range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\nclass MiniMonoid:public Monoid<int>{\npublic:\n\tvector<int>& vs;\n\tMiniMonoid(vector<int>& vs):vs(vs){};\n\tinline int e(){return -1;}\n\tinline int c(int a,int b){// left most\n\t\tif(b==-1)return a;if(a==-1)return b;\n\t\treturn min(vs[a],vs[b])==vs[a]?a:b;\n\t}\n};\ntemplate<typename T> class SegmentTreei{\npublic:\n\tvector<T> vs;MiniMonoid mm;SegmentTree<T> seg;\n\tSegmentTreei(int n):vs(vector<T>(n)),mm(MiniMonoid(vs)),seg(n,mm){}\n\tvoid set(int v,T a){ vs[v]=a;seg.set(v,v);}\n};\n\ntypedef vector<vector<int>> Graph;\nclass EularTourLCA{\n\tpublic:\n\tGraph& g;int r;\n\tvector<int> id,depth,vs;\n\tSegmentTreei<int> rmq;\n\tEularTourLCA(Graph & g,int r):g(g),r(r),rmq(SegmentTreei<int>(2*g.size()-1)){\n\t\tid=vector<int>(g.size());\n\t\tdepth=vector<int>(2*g.size()-1);\n\t\tvs=vector<int>(2*g.size()-1);\n\t\tint k=0;dfs(-1,r,0,k);\n\t\tREP(i,vs.size())rmq.set(i,depth[i]);\n\t};\n\tvoid dfs(int p,int s,int d,int& k){\n\t\tid[s]=k;vs[k]=s;depth[k++]=d;\n\t\tfor(int t:g[s])if(t!=p){\n\t\t\tdfs(s,t,d+1,k);\n\t\t\tvs[k]=s;\n\t\t\tdepth[k++]=d;\n\t\t}\n\t}\n\tint lca(int u,int v){ return vs[rmq.seg.query(min(id[u],id[v]),max(id[u],id[v])+1)];}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t); g[t].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tEularTourLCA lca(g,0);\n\t\tint q;cin >>q;\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tcout << lca.lca(u,v) <<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n// BEGIN CUT HERE\nstruct HeavyLightDecomposition {\n  const int n;\n  VV<> g;\n  V<> sz, par, in, out, anc;\n  HeavyLightDecomposition(VV<>& g, int r = 0) : n(g.size()), g(g), sz(n), par(n), in(n), out(n), anc(n) {\n    dfs_sz(r, -1);\n    anc[r] = r;\n    dfs_hl(r);\n  }\n  void dfs_sz(int v, int p) {\n    par[v] = p;\n    for (auto&& w : g[v]) if (w == p) {\n      swap(w, g[v].back());\n      g[v].pop_back();\n      break;\n    }\n    sz[v] = 1;\n    for (auto&& w : g[v]) {\n      dfs_sz(w, v);\n      sz[v] += sz[w];\n      if (sz[w] > sz[g[v][0]]) swap(w, g[v][0]);\n    }\n  }\n  void dfs_hl(int v) {\n    static int t = 0;\n    in[v] = t++;\n    for (int w : g[v]) {\n      anc[w] = w == g[v][0] ? anc[v] : w;\n      dfs_hl(w);\n    }\n    out[v] = t;\n  }\n  int lca(int u, int v) {\n    while (true) {\n      if (in[u] > in[v]) swap(u, v);\n      if (anc[u] == anc[v]) return u;\n      v = par[anc[v]];\n    }\n  }\n};\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> g(n);\n  for (int v = 0; v < n; ++v) {\n    int k; cin >> k;\n    while (k--) {\n      int c; cin >> c;\n      g[v].push_back(c);\n      g[c].push_back(v);\n    }\n  }\n  HeavyLightDecomposition hld(g);\n  int q; cin >> q;\n  while (q--) {\n    int u, v; cin >> u >> v;\n    cout << hld.lca(u, v) << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src_, int dst_, Weight weight_) :\n        src(src_), dst(dst_), weight(weight_) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint const MAX_V = 1000010;\n\ntypedef int dat_t;\ndat_t const inf = (1LL<<31)-1;\ndat_t const init = (1LL<<31)-1;\nstruct segment_tree {\n    vector<pair<dat_t,int>> dat;\n    int n;\n    segment_tree(int n_){\n        n = 1;\n        while(n < n_) n<<=1;\n        dat.resize(n*2);\n        for(int i=n; i<n+n; i++){\n            dat[i] = make_pair(init,i); // -infをdat[i]にするとvectorからのコンストラクタになる\n        }\n        for(int i=n-1; i>=1; i--){\n            dat[i] = min(dat[i<<1], dat[i<<1|1]);\n        }\n    }\n    // bottom-up\n    void set(int k, dat_t x){\n        int i = n+k; // leaf\n        dat[i] = make_pair(x,k);\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i], dat[i^1]);\n            i>>=1;\n        }\n    }\n    // top-down\n    pair<dat_t,int> get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return make_pair(inf,0);\n        if(a <= l && r <= b) return dat[k];\n        pair<dat_t,int> v1 = get(a,b,k<<1,l,(l+r)/2);\n        pair<dat_t,int> v2 = get(a,b,k<<1|1,(l+r)/2,r);\n        return min(v1,v2);\n    }\n    pair<dat_t,int> get(int a, int b){\n        return get(a,b,1,0,n);\n    }\n};\n\nstruct LowestCommonAncestor {\n    int n;\n    Graph g;\n    unique_ptr<int[]> ord, depth, id;\n    unique_ptr<segment_tree> rmq;\n    LowestCommonAncestor(int n_)\n        : n(n_), g(n), ord(new int[n*2]), depth(new int[n*2]), id(new int[n]), rmq(new segment_tree(n*2)) {\n    }\n    void add_edge(int a, int b){\n        g[a].eb(a,b,0);\n    }\n    void compile(int root = 0){\n        int k = 0;\n        dfs(root,-1,0,k);\n        for(int i=0;i<k;i++){\n            rmq->set(i,depth[i]);\n        }\n    }\n    int lca(int u, int v){\n        int a = id[u], b = id[v];\n        return ord[rmq->get(min(a,b), max(a,b)+1).second];\n    }\n    void dfs(int v, int p, int d, int & k){\n        id[v] = k;\n        ord[k] = v;\n        depth[k] = d;\n        k++;\n        for(auto & e : g[v]){\n            if(e.dst != p){\n                dfs(e.dst, v, d+1, k);\n                ord[k] = v;\n                depth[k] = d;\n                k++;\n            }\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k; cin >> k;\n        for(int j=0;j<k;j++){\n            int to; cin >> to;\n            g.add_edge(i,to);\n            g.add_edge(to,i);\n        }\n    }\n    g.compile();\n    int q;\n    cin >> q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin >> u >> v;\n        cout << g.lca(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass LCA{\npublic:\n  typedef pair<int,int> P;\n  int LOG_V;                          //log V (自分で決めて)\n  int V;                              //頂点数\n  vector<vector<P> > G;               //グラフの隣接リストの表現\n  int root;                           //根のノード番号\n  vector<vector<int> > parent;        //親を2^k回辿って到達する頂点(根を通りすぎる場合は-1とする)\n  vector<int> depth;                  //根からの深さ\n  vector<int> D;                      //根からの距離\n  int ok;\n\n  LCA():V(-1){}\n  LCA(int V,int root = 0):V(V),G(V),root(root),depth(V), D(V, 0),ok(0){\n    LOG_V = 1;\n    int tmp = V;\n    while(tmp) LOG_V++, tmp /= 2;\n    parent.resize(LOG_V, vector<int>(V));\n  }\n\n  void add_edge(int a, int b,int c = 1){\n    assert(a >= 0 && b >= 0);\n    assert(a < V && b < V);\n    G[a].push_back(P(b,c));\n    G[b].push_back(P(a,c));\n  }\n\n  void dfs(int v,int p,int d,int c){\n    assert(v < V);\n    parent[0][v] = p;\n    depth[v] = d;\n    D[v] = c;\n    for(auto to:G[v])\n      if(to.first != p) dfs(to.first, v, d+1, c + to.second);\n  }\n\n  //vからn個上の祖先\n  int getAnc(int v,int n){\n    for(int k=0; k<LOG_V ;k++) if((v != -1) && (n>>k&1)) v=parent[k][v];\n    return v;\n  }\n\n  //初期化\n  void build(){\n    ok = 1;\n    //parent[0]とdepthを初期化する。\n    dfs(root, -1, 0, 0);\n    //parentを初期化する\n    for(int k=0; k+1<LOG_V ;k++)\n      for(int v=0; v<V ;v++)\n        if(parent[k][v] < 0)parent[k+1][v] = -1;\n        else parent[k+1][v] = parent[k][parent[k][v]];\n  }\n\n  //uとvのLCAを求める\n  int get(int u,int v){\n    assert(ok);\n    assert(u >= 0 && v >= 0);\n    assert(u < V && v < V);\n    if(depth[u]>depth[v]) swap(u,v);\n    v = getAnc(v, depth[v] - depth[u]);\n\n    if(u==v) return u;\n    //二分探索でLCAを求める\n    for(int k=LOG_V-1; k>=0 ;k--)\n      if(parent[k][u] != parent[k][v]){\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    return parent[0][u];\n  }\n\n  int getDis(int u,int v){\n    assert(u >= 0 && v >= 0);\n    assert(u < V && v < V);\n    return D[u] + D[v] - 2 * D[get(u, v)];\n  }\n\n  //rootを根としたときの頂点uの親: O(logV)\n  int getParent(int u, int root = -1){\n    if(root == -1) root = this->root;\n    assert(0 <= u && u < V);\n    assert(0 <= root && root < V);\n    int num = depth[root] - depth[u];\n    if(num > 0){\n      int v = getAnc(root, num - 1);\n      int p = parent[0][v];\n      if(p == u) return v;\n    }\n    return parent[0][u];\n  }\n};\n\nint main(){\n  int n;\n  cin>>n;\n  LCA lca(n);\n\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n\n  lca.build();\n\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.get(u,v)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct Node{\n  int id,val,parent,size,in,out;\n  vector<int> children;\n  Node(){}\n  Node(int id,int v,vector<int>ch):id(id),val(v),children(ch){}\n};\n\ntypedef vector<Node> Tree;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>path, pathSize, pathPos, pathRoot;\n  Tree tree;\n  \n  HeavyLight(Tree tree)\n    :pathCount(0),n(tree.size()),path(n),pathSize(n),pathPos(n),pathRoot(n),tree(tree){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    tree[u].in=k++, tree[u].parent=p, tree[u].size=1;\n    EACH(v,tree[u].children){\n      if(*v!=p){\n\tdfs(*v, u, k);\n\ttree[u].size += tree[*v].size;\n      }\n    }\n    tree[u].out=k++;\n  }\n\n  int newPath(int u){\n    pathRoot[pathCount] = u;\n    return pathCount++;\n  }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u].children)\n      if(*v != tree[u].parent)\n\tbuildPaths(*v, 2* tree[*v].size >= tree[u].size ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return tree[p].in <= tree[ch].in && tree[ch].out <= tree[p].out;\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=tree[root].parent);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=tree[root].parent);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  Tree tree(n);\n  \n  REP(i,n){\n    tree[i].id=i;\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].children.push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nvector<int> ord;\nint depth[MAX_N];\nint id[MAX_N];\nbool flag[MAX_N];\n\n//?????????????????????0?§???????\n//????°????????±???????????????°??????(RMQ)\nconst int N = 1 << 17;\t//10^5?¨????\n\n//?????°???????????¨???????????°??????????????????\n\nint n_,dat[2*N-1];\n\n//?????????\n//n_???x??\\??????????°????2????????????\nvoid init(int x)\n{\n\t//?°????????????????????´???°???2???????????????\n\tn_=1;\n\twhile(n_<x){\n\t\tn_*=2;\n\t}\n\trep(i,2*n_-1){\n\t\tdat[i] = INF;\n\t}\n}\n\n//k???????????????a????????´??????\nvoid update(int k,int a)\n{\n\t//????????????\n\tk += n_-1;\n\tdat[k] = a;\n\t//?????????????????´??°\n\twhile(k>0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = min(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int k=0,int l=0,int r=n_)\n{\n\tif(r <= a || b <= l){\n\t\treturn INF;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn dat[k];\n\t}else{\n\t\tint vl = query(a,b,2*k+1,l,(l+r)/2);\n\t\tint vr = query(a,b,2*k+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nvoid dfs(int u,int k)\n{\n    id[u] = ord.size();\n    ord.pb(u);\n    flag[u] = true;\n    depth[u] = k;\n    rep(i,G[u].size()){\n        if(!flag[G[u][i]]){\n            dfs(G[u][i],k+1);\n            ord.pb(u);\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,0);\n    init(ord.size());\n    rep(i,ord.size()){\n        update(i,depth[ord[i]]);\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\",query(id[u],id[v]+1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <cassert>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\nusing namespace std;\n\n/**\n * @brief lowest common ancestor with doubling\n */\nstruct lowest_common_ancestor {\n    vector<vector<int> > a;\n    vector<int> depth;\n    lowest_common_ancestor() = default;\n    /**\n     * @note O(N \\log N)\n     */\n    lowest_common_ancestor(int root, vector<vector<int> > const & g) {\n        int n = g.size();\n        int log_n = floor(log2(n));\n        a.resize(log_n, vector<int>(n, -1));\n        depth.resize(n, -1);\n        {\n            auto & parent = a[0];\n            stack<int> stk;\n            depth[root] = 0;\n            parent[root] = -1;\n            stk.push(root);\n            while (not stk.empty()) {\n                int x = stk.top(); stk.pop();\n                for (int y : g[x]) if (depth[y] == -1) {\n                    depth[y] = depth[x] + 1;\n                    parent[y] = x;\n                    stk.push(y);\n                }\n            }\n        }\n        repeat (k, log_n-1) {\n            repeat (i, n) {\n                if (a[k][i] != -1) {\n                    a[k+1][i] = a[k][a[k][i]];\n                }\n            }\n        }\n    }\n    /**\n     * @brief find the LCA of x and y\n     * @note O(log N)\n     */\n    int operator () (int x, int y) const {\n        int log_n = a.size();\n        if (depth[x] < depth[y]) swap(x,y);\n        repeat_reverse (k, log_n) {\n            if (a[k][x] != -1 and depth[a[k][x]] >= depth[y]) {\n                x = a[k][x];\n            }\n        }\n        assert (depth[x] == depth[y]);\n        assert (x != -1);\n        if (x == y) return x;\n        repeat_reverse (k, log_n) {\n            if (a[k][x] != a[k][y]) {\n                x = a[k][x];\n                y = a[k][y];\n            }\n        }\n        assert (x != y);\n        assert (a[0][x] == a[0][y]);\n        return a[0][x];\n    }\n    /**\n     * @brief find the descendant of x for y\n     */\n    int descendant (int x, int y) const {\n        assert (depth[x] < depth[y]);\n        int log_n = a.size();\n        repeat_reverse (k, log_n) {\n            if (a[k][y] != -1 and depth[a[k][y]] >= depth[x]+1) {\n                y = a[k][y];\n            }\n        }\n        assert (a[0][y] == x);\n        return y;\n    }\n};\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n) {\n        int edges; scanf(\"%d\", &edges);\n        while (edges --) {\n            int j; scanf(\"%d\", &j);\n            g[i].push_back(j);\n            g[j].push_back(i);\n        }\n    }\n    constexpr int root = 0;\n    lowest_common_ancestor lca(root, g);\n    int query; scanf(\"%d\", &query);\n    while (query --) {\n        int x, y; scanf(\"%d%d\", &x, &y);\n        printf(\"%d\\n\", lca(x, y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nstruct LCA {\n    int V;//頂点数\n    vector<vector<int> > G;//グラフの隣接リスト表現\n    int MAX_LOG_V = 0;\n    int root = 0;//根ノードの番号\n\n    vector<vector<int>> parent;//親を2^k回辿って到達する頂点(根を通り過ぎる場合は-1とする)\n    vector<int> depth;//根からの深さ\n\n    LCA(int V) {\n        this->V = V;\n        while (1 << MAX_LOG_V < V) {//バグが怖い\n            MAX_LOG_V++;\n        }\n        G.resize(V);\n        parent.resize(MAX_LOG_V, vector<int>(V));\n        depth.resize(V);\n    }\n\n    /**\n     * 辺を追加した後に初期化をする\n     */\n    void init() {\n        //parentとdepthの初期化\n        dfs(root, -1, 0);\n        //parentを初期化する\n        for(int k = 0; k + 1 < MAX_LOG_V; k++){\n            for(int v = 0; v < V; v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n        }\n    }\n\n    /**\n     * uとvのlcaを求める\n     * @param u 頂点\n     * @param v 頂点\n     * @return lcaとなる頂点\n     */\n    int lca(int u, int v) {\n        //uとvの高さが同じになるまで親を辿る\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int k = 0; k < MAX_LOG_V; k++) {\n            if((depth[v] - depth[u]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u == v) return u;\n        //二分探索でLCAを求める\n        for (int k = MAX_LOG_V - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n    /**\n     * 辺を追加する\n     * @param from 元\n     * @param to 先\n     */\n    void add_edge(int from,int to){\n        G[from].push_back(to);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,0,n){\n        int k;\n        cin >> k;\n        rep(j,0,k){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.init();\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n//    cout << \"---\" << endl;\n//    rep(i,0,lca.G.size()){\n//        rep(j,0,lca.G[i].size()){\n//            cout << i << \" \" << lca.G[i][j] << endl;\n//        }\n//    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 500;\nint color[100010], par[100010], depth[100010];\nint depthTop[100010];\nint goUp[100010];\nint vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(!vis[c]){\n                q.push(c);\n                par[c] = v;\n                depth[c] = depth[v] + 1;\n            }\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            depthTop[v] = depth[u];\n            k++;\n            for(int c : g[v]){\n                if(!vis[c]) q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depthTop[u] > depthTop[v]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Splay_Tree{\n\tprivate:\n\tint n;\n\tvi L,R,par,val,date,sub;\n\tinline void Fix(int k){\n\t\tsub[k]=sub[L[k]]+sub[R[k]]+1;\n\t\tdate[k]=((val[k]+date[L[k]])%mod+date[R[k]])%mod;\n\t}\n\tinline void Set(int k,int l,int r,int p,bool B=0){\n\t\tif(B) swap(l,r);\n\t\tL[k]=l;R[k]=r;par[k]=p;\n\t\tif(l!=n) par[l]=k;\n\t\tif(r!=n) par[r]=k;\n\t\tFix(k);\n\t}\n\tinline int Ch(int v,bool B){return (B?R[v]:L[v]);}\n\tvoid Rotate(int v,bool B){\n\t\tint p=par[v],u=Ch(v,B);\n\t\tSet(v,Ch(u,!B),Ch(v,!B),u,B);\n\t\tSet(u,Ch(u,B),v,p,B);\n\t\tif(p!=n) (L[p]==v?L[p]:R[p])=u;\n\t}\n\tint Splay(int u){\n\t\twhile(par[u]!=n){\n\t\t\tint v=par[u],w=par[v];\n\t\t\tbool A=(R[v]==u),B=(R[w]==v);\n\t\t\tif(w==n){\n\t\t\t\tRotate(v,A);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(A==B){swap(v,w);swap(A,B);}\n\t\t\tRotate(v,A);Rotate(w,B);\n\t\t}\n\t}\n\tpublic:\n\tvoid Init(int N){\n\t\tn=N;\n\t\tL=R=par=vi(n+1,n);\n\t\tval=date=vi(n+1);\n\t\tsub=vi(n+1,1);\n\t\tsub[n]=0;\n\t}\n\tint Find(int v,int k){\n\t\tSplay(v);\n\t\twhile(1){\n\t\t\tint t=sub[L[v]];\n\t\t\tif(t==k) break;\n\t\t\tif(k<t) v=L[v];\n\t\t\telse k-=t+1,v=R[v];\n\t\t}\n\t\tSplay(v);\n\t\treturn v;\n\t}\n\tvoid Update(int k,int x){\n\t\tk=Find(0,k);\n\t\tval[k]=x;Fix(k);\n\t}\n\tint Sub(int v){Splay(v);return sub[v];}\n\tvoid Merge(int l,int r){\n\t\tr=Find(r,0);\n\t\tSplay(l);\n\t\tSet(r,l,R[r],n);\n\t}\n\tint Split(int v,int k){\n\t\tif(!k||k==Sub(v)) return n;\n\t\tv=Find(v,k);\n\t\tpar[L[v]]=n;\n\t\tSet(v,n,R[v],n);\n\t\treturn v;\n\t}\n\tint Split_id(int v){\n\t\tSplay(v);\n\t\treturn Split(v,sub[L[v]]+1);\n\t}\n\tvoid Open(){\n\t\tfor(int i=0;i<=n;i++) cout<<i<<':'<<L[i]<<' '<<R[i]<<' '<<par[i]<<endl;\n\t}\n};\n\nclass LinkCut_Tree{\n\tprivate:\n\tint n;\n\tSplay_Tree sp;\n\tvi par;\n\tpublic:\n\tLinkCut_Tree(int N){\n\t\tn=N;\n\t\tsp.Init(n);\n\t\tpar=vi(n+1,n);\n\t}\n\tint Expose(int v){\n\t\tint u=sp.Split_id(v);\n\t\tif(u!=n) par[u]=v;\n\t\twhile(1){\n\t\t\tu=sp.Find(v,0);\n\t\t\tif(par[u]==n) break;\n\t\t\tint w=sp.Split_id(par[u]);\n\t\t\tif(w!=u) par[w]=par[u];\n\t\t\tsp.Merge(par[u],u);\n\t\t}\n\t\treturn u;\n\t}\n\tvoid Link(int v,int p){\n\t\tExpose(p);\n\t\tpar[v]=n;\n\t\tsp.Merge(p,v);\n\t}\n\tvoid Cut(int v){\n\t\tExpose(v);\n\t\tsp.Split_id(par[v]);\n\t\tpar[v]=n;\n\t}\n\tint LCA(int u,int v){\n\t\tint ru=Expose(u),rv=Expose(v);\n\t\tif(ru!=rv) return -1;\n\t\tint w=par[sp.Find(u,0)];\n\t\tif(w==n) return u;\n\t\treturn  w;\n\t}\n\tvoid Open(){\n\t\tsp.Open();\n\t\tfor(auto i:par) cout<<i<<' ';\n\t\tcout<<endl;\n\t}\n};\n\nint n,q;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n;\n\tLinkCut_Tree lct(n);\n\tfor(int i=0;i<n;i++){\n\t\tint m;\n\t\tcin>>m;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin>>v;\n\t\t\tlct.Link(v,i);\n\t\t}\n\t}\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tcout<<lct.LCA(u,v)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 111111;\n\nint par[N];\nvector<int> ch[N];\nint ch_size[N];\n\nint dfs(int v) {\n  int sz = 1;\n  for (size_t i = 0; i < ch[v].size(); i++) {\n    sz += dfs(ch[v][i]);\n  }\n  return ch_size[v] = sz;\n}\n\nint es, ei[N], ed[N], ep[N];\nvector<int> e[N];\nint dd[N];\n\nint dec(int v, int k = 0, int d = 0) {\n  int idx = -1;\n  int tk = k;\n  ei[v] = tk;\n  dd[v] = e[tk].size();\n  e[tk].push_back(v);\n  ed[tk] = d;\n  for (int i = 0; i < int(ch[v].size()); i++) {\n    if (idx == -1 || ch_size[ch[v][idx]] < ch_size[ch[v][i]]) {\n      idx = i;\n    }\n  }\n\n  if (idx >= 0) k = dec(ch[v][idx], tk, d);\n  \n  for (int i = 0; i < int(ch[v].size()); i++) {\n    if (i != idx) {\n      ep[k+1] = tk;\n      k = dec(ch[v][i], k+1, d+1);\n    }\n  }\n\n  return k;\n}\n\nstruct path {\n  int i, a, b;\n  path() {}\n  path(int i, int a, int b) :\n      i(i), a(a), b(b) {}\n};\nvector<path> pathset(int u, int v) {\n  vector<path> ps, qs;\n  int aa = ei[u];\n  int bb = ei[v];\n\n  while (aa != bb) {\n    // printf(\"%d %d %d %d\\n\", u, v, aa, bb);\n    if (ed[aa] > ed[bb]) {\n      ps.push_back({aa, 0, dd[u]+1});\n      u = par[e[aa][0]];\n      aa = ep[aa];\n    } else {\n      qs.push_back({bb, 0, dd[v]+1});\n      v = par[e[bb][0]];\n      bb = ep[bb];\n    }\n  }\n  ps.push_back({aa, min(dd[u], dd[v]), max(dd[u], dd[v])+1});\n\n  reverse(qs.begin(), qs.end());\n  copy(qs.begin(), qs.end(), back_inserter(ps));\n  return ps;\n}\n\nint a[N], b[N];\n\nint main(void) {\n  int n, q;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    int k; scanf(\"%d\", &k);\n    for (int j = 0; j < k; j++) {\n      int c; scanf(\"%d\", &c);\n      par[c] = i;\n      ch[i].push_back(c);\n    }\n  }\n\n  dfs(0);\n  es = dec(0)+1;\n\n  /*\n  for (int i = 0; i < es; i++) {\n    printf(\"%3d(%d, %d): \", i, ed[i], ep[i]);\n    for (int j = 0; j < int(e[i].size()); j++) {\n      printf(\"%d(%d) \", e[i][j], dd[e[i][j]]);\n    }\n    puts(\"\");\n  }\n  */\n\n  scanf(\"%d\", &q);\n  for (int ii = 0; ii < q; ii++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    auto ps = pathset(u, v);\n\n    /*\n    for (int k = 0; k < int(ps.size()); k++) {\n      printf(\"[%d](%d, %d, %d) \", ed[ps[k].i], ps[k].i, ps[k].a, ps[k].b);\n    }\n    puts(\"\");\n    */\n        \n    int md = -1;\n    for (int k = 0; k < int(ps.size()); k++) {\n      if (md < 0 || ed[ps[md].i] > ed[ps[k].i]) {\n        md = k;\n      }\n    }\n    printf(\"%d\\n\", e[ps[md].i][ps[md].a]);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// LCA (0-indexed)\nstruct LCA {\n  int n, bi;\n  vi dep;\n  vector<vi> to, par;\n  LCA(int n):n(n),dep(n),to(n){}\n  void add(int a, int b){ to[a].pb(b); to[b].pb(a);}\n  void calcDep(int v, int ndep=0, int p=-1){\n    dep[v] = ndep; par[0][v] = p;\n    for(int u : to[v]) if(u != p) calcDep(u,ndep+1,v);\n  }\n  void init(){\n    bi = 0;\n    while(1<<bi <= n) bi++;\n    par.resize(bi,vi(n,-1));\n    calcDep(0);\n    rep(i,bi-1)rep(j,n) par[i+1][j] = (par[i][j]==-1?-1:par[i][par[i][j]]);\n  }\n  int lca(int a, int b){\n    if(dep[a] < dep[b]) swap(a,b);\n    int x = dep[a]-dep[b];\n    for(int i = bi-1; i >= 0; --i){\n      if(1<<i <= x) a = par[i][a], x -= 1<<i;\n    }\n    if(a == b) return a;\n    for(int i = bi-1; i >= 0; --i){\n      if(par[i][a] != par[i][b]) a = par[i][a], b = par[i][b];\n    }\n    return par[0][a];\n  }\n  int dist(int a, int b){\n    int c = lca(a,b);\n    return dep[a]+dep[b] - dep[c]*2;\n  }\n};\n//\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  LCA g(n);\n  rep(i,n) {\n    int m;\n    scanf(\"%d\",&m);\n    rep(j,m) {\n      int a;\n      scanf(\"%d\",&a);\n      g.add(i,a);\n    }\n  }\n  g.init();\n  int q;\n  scanf(\"%d\",&q);\n  rep(i,q) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    printf(\"%d\\n\",g.lca(a,b));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n\nclass doubling_LCA {\nprivate:\n    std::vector<std::vector<int>> Tree;\n    std::vector<std::vector<int>> par;\n    std::vector<int> depth;\n\n    void dfs(int v, int p){\n        for(auto& c : Tree[v]) {\n            if(c == p) continue;\n            depth[c] = depth[v] + 1;\n            par[0][c] = v;\n            dfs(c, v); \n        }\n    }\n    void doubling(const int& V){\n        const int D = par.size();\n        for(int d = 1; d < D; d++){\n            for(int v = 0; v < V; v++){\n                if(par[d-1][v] < 0) par[d][v] = -1;\n                else par[d][v] = par[d-1][par[d-1][v]];\n            }\n        }\n    }\n\npublic: \n    doubling_LCA() = delete;\n    doubling_LCA(const doubling_LCA&) = delete;\n    doubling_LCA& operator=(const doubling_LCA&) = delete;\n\n    doubling_LCA(std::vector<std::vector<int>>& tree, int root = 0) : Tree(tree) {\n        int V = Tree.size();\n        int D = 1;\n        while((1 << D) < V) D++;\n        depth.assign(V, -1);\n        par.assign(D, std::vector<int>(V, -1));\n\n        dfs(root, -1);\n        doubling(V);\n    }\n\n    int operator()(int u, int v){\n        if(depth[u] < depth[v]) std::swap(u, v);\n        int D = par.size();\n        for(int d = 0; d < D; d++){\n            if((depth[u] - depth[v]) & (1 << d)) u = par[d][u];\n        }\n\n        if(u == v) return u;\n        for(int d = D - 1; d >= 0; d--){\n            if(par[d][u] != par[d][v]) {\n                u = par[d][u];\n                v = par[d][v];\n            }\n        }\n        return par[0][u];\n    }\n};\n\nint main(){\n    using namespace std;\n    int N;\n    cin >> N;\n\n    std::vector<std::vector<int>> Tree(N);\n    for(int i = 0; i < N; i++){\n        int K; cin >> K;\n        Tree[i].resize(K);\n        for(int k = 0; k < K; k++){\n            cin >> Tree[i][k];\n        }\n    }\n\n    doubling_LCA LCA(Tree);\n\n    int Q;\n    cin >> Q;\n    for(int i = 0; i < Q; i++){\n        int u, v;\n        cin >> u >> v;\n        cout << LCA(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, ans, sum, last, cnt;\nstruct Edge { LL to,cost; };\nvector<Edge>vec[100010];\nstring str;\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node, lazy, num;\n\tSeg(vector<LL>v) {\n\t\tn = 1; while (n < v.size())n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = v[i];\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tlazy.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = INF;\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t//区間最小などの時\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\n\t}\n\t//区間の和の遅延\n\tvoid eval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tnode[k] += lazy[k];\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2 + 1] += lazy[k] / 2;\n\t\t\t\tlazy[k * 2 + 2] += lazy[k] / 2;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\t//区間の最小の遅延\n\tvoid ceval(LL k, LL l, LL r) {\n\t\tif (lazy[k] != -1) {\n\t\t\tnode[k] = lazy[k];\n\t\t\tif (r - l >= 1) {\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t\tlazy[k * 2 + 2] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = -1;\n\t\t}\n\t}\n\tvoid update(LL i, LL x,LL u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tvoid update(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\tceval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] = x;\n\t\t\tceval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tupdate(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tupdate(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t}\n\t}\n\tPll find(LL i, LL a, LL b, LL l, LL r) {\n\t\t//ceval(i, a, b);\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n\tvoid add(LL i, LL x) {\n\t\ti = i + n - 1;\n\t\tnode[i] += x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tnode[i] = (node[i * 2 + 1] + node[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid add(LL i, LL x, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b < l || r < a)return;\n\t\tif (l <= a&&b <= r) {\n\t\t\tlazy[i] += (b - a + 1)*x;\n\t\t\teval(i, a, b);\n\t\t}\n\t\telse {\n\t\t\tadd(i * 2 + 1, x, a, (a + b) / 2, l, r);\n\t\t\tadd(i * 2 + 2, x, (a + b + 1) / 2, b, l, r);\n\t\t\tnode[i] = node[i * 2 + 1] + node[i * 2 + 2];\n\t\t}\n\t}\n\tLL getsum(LL i, LL a, LL b, LL l, LL r) {\n\t\teval(i, a, b);\n\t\tif (b< l || r < a)return 0;\n\t\tif (l <= a&&b <= r)return node[i];\n\t\treturn (getsum(i * 2 + 1, a, (a + b) / 2, l, r) + getsum(i * 2 + 2, (a + b + 1) / 2, b, l, r));\n\t}\n};\nstruct vertex {\n\tLL l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<LL>root;\n\tLL num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tLL u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j].to].f == 0) {\n\t\t\t\troot.push_back(vec[u][j].to);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(Edge{ h,1 });\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\n\nvector<int> vis;\nvector<int> d;\nvector<vector<int> > g;\nvector<vector<int> > anc;\n\nvoid dfs( int curr, vector<int>& vv )\n{\n    vis[curr]=1;\n    d[curr]=(int)vv.size();\n\n    int k=1;\n    while(k<=d[curr]) {\n        anc[curr].push_back(vv[d[curr]-k]);\n        k*=2;\n    }\n\n    vv.push_back( curr );\n    int i;\n    for(i=0; i<(int)g[curr].size(); i++) {\n        if( !vis[g[curr][i]] ) {\n            dfs( g[curr][i], vv );\n        }\n    }\n    vv.pop_back();\n\n    return;\n}\n\nint getanc( int a, int b )\n{\n    if(d[a]>d[b]) swap(a, b);\n    int delta = d[b]-d[a];\n    int cnt=0;\n    while(delta>0) {\n        if(delta & (1<<cnt)) {\n            b = anc[b][cnt];\n            delta -= (1<<cnt);\n        }\n        cnt++;\n    }\n    assert(d[a]==d[b]);\n    if(a==b) return a;\n\n    int N=(int)anc[a].size();\n    int i;\n    for(i=N-1; i>=0; i--) {\n        if((int)anc[a].size()>i) {\n            if(anc[a][i]!=anc[b][i]) {\n                a = anc[a][i];\n                b = anc[b][i];\n            }\n        }\n    }\n    return anc[a][0];\n}\n\nint main(int argc, char* argv[])\n{\n    int n;\n    scanf(\"%d\", &n);\n\n    vis.resize(n);\n    g.resize(n);\n    d.resize(n);\n    anc.resize(n);\n\n    int i,j;\n    for(i=0; i<n; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        for(j=0; j<num; j++) {\n            int tmp;\n            scanf(\"%d\", &tmp);\n            g[i].push_back(tmp);\n            g[tmp].push_back(i);\n        }\n    }\n\n    vector<int> vv;\n    dfs(0, vv );\n\n    int q;\n    scanf(\"%d\", &q);\n    for(i=0; i<q; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        int p = getanc(a, b);\n\n        printf(\"%d\\n\", p);\n    }\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define repLRE(i, l, r) for (ll i = (l); i <= (r); ++i)\n#define rrepLRE(i, l, r) for (ll i = (l); i >= (r); --i)\n#define Sort(v) sort(v.begin(), v.end())\n#define rSort(v) sort(v.rbegin(), v.rend())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\n/* Macros reg. ends here */\n\nconst ll INF = 1LL << 50;\n\nll n, h = 20;\nvvll to, par;\nvll dep;\n\nvoid dfs(ll x, ll p, ll d) {\n  par[0][x] = p;\n  dep[x] = d;\n  for (auto& y : to[x])\n    if (y != p) dfs(y, x, d + 1);\n}\n\nvoid build() {\n  dep.resize(n);\n  par.assign(h, vll(n, -1));\n  dfs(0, -1, 0);\n  rep(i, h - 1) {\n    rep(j, n) {\n      if (par[i][j] < 0)\n        par[i + 1][j] = -1;\n      else\n        par[i + 1][j] = par[i][par[i][j]];\n    }  // j\n  }    // i\n}\n\nll lca(ll u, ll v) {\n  if (dep[u] > dep[v]) swap(u, v);\n  rep(i, h) if ((dep[v] - dep[u]) >> i & 1) v = par[i][v];\n  assert(dep[v] == dep[u]);\n  if (u == v) return u;\n  for (ll i = h - 1; i >= 0; i--) {\n    if (par[i][u] != par[i][v]) {\n      u = par[i][u];\n      v = par[i][v];\n    }\n  }  // i\n  return par[0][u];\n}\n\nint main() {\n  // ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout << fixed << setprecision(15);\n\n  cin >> n;\n  to.resize(n);\n\n  rep(i, n) {\n    ll k;\n    cin >> k;\n    rep(j, k) {\n      ll c;\n      cin >> c;\n      to[i].emplace_back(c);\n      to[c].emplace_back(i);\n    }\n  }\n\n  build();\n\n  ll q;\n  cin >> q;\n  rep(i, q) { ll u, v;\n    cin >> u >> v;\n    cout << lca(u, v) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nint n,k,q,sz[100005],hv[100005],vs[100005],hd[100005],dp[100005],chain[100005],id[1000005];\nvector<int>g[100005];\nvoid dfs(int v,int p){\n    sz[v]=1;\n    hv[v]=-1;\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=p){\n            dfs(g[v][i],v);\n            sz[v]+=sz[g[v][i]];\n            if(hv[v]==-1||sz[hv[v]]<sz[g[v][i]])hv[v]=g[v][i];\n        }\n    }\n}\nvoid dfs1(int v,int d,int p,int h){\n    hd[k]=h;\n    id[v]=k;\n    vs[k]=v;\n    dp[k++]=d;\n    if(hv[v]!=-1)dfs1(hv[v],d+1,v,h);\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=p&&g[v][i]!=hv[v]){\n            chain[k]=id[v];\n            dfs1(g[v][i],d+1,v,k);\n        }\n    }\n}\nint lca(int u,int v){\n    u=id[u];v=id[v];\n    while(hd[u]!=hd[v]){\n        if(dp[hd[u]]>dp[hd[v]])u=chain[hd[u]];\n        else v=chain[hd[v]];\n    }\n    if(dp[u]<dp[v])return vs[u];\n    else return vs[v];\n}\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            int a;\n            scanf(\"%d\",&a);\n            g[i].push_back(a);\n            g[a].push_back(i);\n        }\n    }\n    dfs(0,-1);\n    dfs1(0,0,-1,0);\n    scanf(\"%d\",&q);\n    for(int i=0;i<q;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        printf(\"%d\\n\",lca(a,b));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n頂点は0-indexedを想定\nLCAに特化したHLD\n構築にO(N)、クエリにO(logN) ダブリングより早い！！\ndepは根が1\n参考:\nhttps://ei1333.github.io/luzhiled/snippets/tree/heavy-light-decomposition.html\nhttps://codeforces.com/blog/entry/53170\nverify:\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\n\nstruct LCA{\n    Graph g;\n    vector<int> sz,head,par,in,dep;\n    LCA(Graph &g):g(g),sz(g.size(),1),head(g.size()),par(g.size()),in(g.size()),dep(g.size()){}\n\n    void dfs_sz(int idx,int p,int d){\n        par[idx]=p;\n        dep[idx]=d;\n        if(g[idx].size() && g[idx][0]==p) swap(g[idx][0],g[idx].back());\n        for(int &next:g[idx]){\n            if(next==p) continue;\n            dfs_sz(next,idx,d+1);\n            sz[idx]+=sz[next];\n            if(sz[g[idx][0]]<sz[next]) swap(g[idx][0],next);\n        }\n    }\n\n    void dfs_hld(int idx,int p,int &times){\n        in[idx]=times++;\n        for(int next:g[idx]){\n            if(next==p) continue;\n            head[next]=(next==g[idx][0] ? head[idx]:next);\n            dfs_hld(next,idx,times);\n        }\n    }\n    //rootは根\n    void build(int root){\n        dfs_sz(root,-1,1);\n        int times=0;\n        dfs_hld(root,-1,times);\n    }\n\n    int lca(int u,int v){\n        while(true){\n            if(in[u]>in[v]) swap(u,v); //vの方を深くする\n            if(head[u]==head[v]) return u;\n            v=par[head[v]];\n        }\n    }\n    //uとvの最短距離\n    int dis(int u,int v){\n        int p=lca(u,v);\n        return dep[u]+dep[v]-dep[p]*2;\n\n    }\n};\n\nsigned main(){\n    int N,Q;\n    cin>>N;\n    Graph g(N);\n    for(int i=0;i<N;i++){\n        int k;\n        cin>>k;\n        while(k--){\n            int c;\n            cin>>c;\n            g[i].push_back(c);\n            g[c].push_back(i);\n        }\n    }\n    LCA lca(g);\n    lca.build(0);\n    cin>>Q;\n    while(Q--){\n        int x,y;\n        cin>>x>>y;\n        cout<<lca.lca(x,y)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename Monoid>\nstruct SegmentTree{\nprivate:\n    using F = function<Monoid(Monoid, Monoid)>;\n    int N{};\n    vector<Monoid> node;\n    F f;\n    Monoid e;  // identity element\n\npublic:\n    SegmentTree() = default;\n    SegmentTree(F f, Monoid e):f(f), e(e){}\n    void init(int sz){\n        N = 1;\n        while(N < sz) N <<= 1;\n        node.assign(2*N-1, e);\n    }\n    void build(vector<Monoid>& v){\n        int sz = int(v.size());\n        init(sz);\n        for(int i=0; i<sz; i++){\n            node[i+N-1] = v[i];\n        }\n        for(int i=N-2; i>=0; i--){\n            node[i] = f(node[i*2+1], node[i*2+2]);\n        }\n    }\n    void update(int k, Monoid x){\n        k += N-1;\n        node[k] = x;\n        while(k > 0){\n            k = (k-1)/2;\n            node[k] = f(node[2*k+1], node[2*k+2]);\n        }\n    }\n    // [a,b)\n    Monoid query(int a, int b){return query(a, b, 0, 0, N);}\n    Monoid query(int a, int b, int k, int l, int r){\n        if(b <= l || r <= a) return e;\n        if(a <= l && r <= b) return node[k];\n        Monoid vl, vr;\n        vl = query(a, b, 2*k+1, l, (l+r)/2);\n        vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(vl, vr);\n    }\n};\n\nusing P = std::pair<int,int>;\n\n\nclass LCA {\nprivate:\n    using Type = int;\n    const int INF = 1 << 30;\n    struct edge {\n        int from, to, rev;\n        Type cost;\n        edge(int from, int to, int rev, Type cost) : from(from), to(to), rev(rev), cost(cost){}\n    };\n    int V = 0;\n    int root = 0;\n    std::vector<std::vector<edge> > graph;\n    std::vector<int> depth, vs, ds, us;\n\n    SegmentTree<P> rmq = SegmentTree<P>([](P a, P b){return min(a,b);},P(INF,-1));\n    SegmentTree<Type> rsq = SegmentTree<Type>([](Type a, Type b){return a+b;}, 0);\n\n    void dfs(int v, int p, int d, int &idx){\n        vs[idx] = v;\n        depth[v] = d;\n        ds[v] = idx++;\n        for(auto& e : graph[v]){\n            if(e.to == p) continue;\n            dfs(e.to, v, d+1, idx);\n            vs[idx] = v;\n            idx++;\n        }\n        us[v] = idx;\n    }\n\npublic:\n    LCA() = default;\n    LCA(int V, int root = 0) : V(V), graph(V), depth(V), vs(V*2-1), ds(V), us(V), root(root){}\n    void init(int n, int r = 0){\n        V = n;\n        graph.resize(V);\n        depth.resize(V);\n        vs.resize(V*2-1);\n        ds.resize(V);\n        us.resize(V);\n        root = r;\n    }\n    void add_edge(int from, int to, Type cost = 1){\n        graph[from].emplace_back(edge(from,to,int(graph[to].size()),cost));\n        graph[to].emplace_back(edge(to,from,int(graph[from].size())-1,cost));\n    }\n    void build(){\n        int idx = 0;\n        dfs(root, -1, 0, idx);\n        std::vector<P> depv(idx);\n        for(int i=0;i<idx;i++){\n            depv[i] = P(depth[vs[i]], vs[i]);\n        }\n        rmq.build(depv);\n        std::vector<Type> cstv(idx);\n        for(int i=0;i<V;i++){\n            for(auto& e : graph[i]){\n                if(depth[e.from] < depth[e.to]){\n                    cstv[ds[e.to]] = e.cost;\n                    cstv[us[e.to]] = -e.cost;\n                }\n            }\n        }\n        rsq.build(cstv);\n    }\n    int query(int u, int v){\n        return rmq.query(min(ds[u],ds[v]), max(ds[u],ds[v])+1).second;\n    }\n    Type dist(int u, int v){\n        int w = query(u, v);\n        return rsq.query(ds[root], ds[u]+1) + rsq.query(ds[root], ds[v]+1) - 2*rsq.query(ds[root], ds[w]+1);\n    }\n    void update(int v, Type cost){\n        rsq.update(ds[v], cost);\n        rsq.update(us[v], -cost);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n;\n    LCA lca(n);\n    for(int i=0;i<n;i++){\n        int k;\n        cin >> k;\n        for(int j=0;j<k;j++){\n            int c;\n            cin >> c;\n            lca.add_edge(i,c);\n        }\n    }\n    lca.build();\n    cin >> q;\n    for(int i=0;i<q;i++){\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <vector> \n#include <algorithm> \n#include <climits>\nusing namespace std;\n\n\nusing P = pair<int,int>;\nstruct SegmentTree{\n  private:\n  int n;\n  vector<P> node;\n  public:\n  SegmentTree(vector<P> v){\n    int sz = v.size();\n    n = 1;\n    while(n<sz) n *= 2;\n    node.resize(2*n-1,P(INT_MAX,INT_MAX));\n    for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n    for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1],node[2*i+2]);\n  }\n  void update(int x,int val){\n    x += (n-1);\n    node[x] = P(val,x);\n    while(x>0){\n      x = (x-1)/2;\n      node[x] = min(node[2*x+1],node[2*x+2]);\n    }\n  }\n  // [a,b)\n  P getmin(int a,int b,int k=0,int l=0,int r=-1){\n    if(r < 0) r = n;\n    if(r <= a || b <= l) return P(INT_MAX,INT_MAX);\n    if(a <= l && r <= b) return node[k];\n    P vl = getmin(a,b,2*k+1,l,(l+r)/2);\n    P vr = getmin(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\n\nvector<vector<int>> G;\nvector<int> Eulartour;\nvoid dfs(int v,int p=-1){\n  Eulartour.emplace_back(v);\n  for(int nv: G[v]){\n    if(nv == p) continue;\n    dfs(nv,v);\n    Eulartour.emplace_back(v);\n  }\n}\n\nvector<int> depth;\nvoid dfs2(int v,int p=-1){\n  for(int nv: G[v]){\n    if(nv == p) continue;\n    depth[nv] = depth[v] + 1;\n    dfs2(nv,v);\n  }\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int N;\n  cin >> N;\n  G.resize(N);\n  for(int i=0; i<N; i++){\n    int K;\n    cin >> K;\n    for(int k=0; k<K; k++){\n      int c;\n      cin >> c;\n      G[c].emplace_back(i);\n      G[i].emplace_back(c);\n    }\n  }\n  dfs(0);\n\n\n  vector<int> fst(N,-1);\n  for(int i=0; i<Eulartour.size(); i++){\n    if(fst[Eulartour[i]] == -1) fst[Eulartour[i]] = i;\n  }\n\n  depth.resize(N);\n  depth[0] = 0;\n  dfs2(0);\n\n  // P = pair<int,int>\n  vector<P> p(Eulartour.size());\n  for(int i=0; i<Eulartour.size(); i++){\n    p[i].first = depth[Eulartour[i]];\n    p[i].second = Eulartour[i];\n  }\n\n  SegmentTree seg(p);\n\n  int Q;\n  cin >> Q;\n  for(int q=0; q<Q; q++){\n    int u,v;\n    cin >> u >> v;\n    if(fst[u] > fst[v]) swap(u,v);\n    P LCA = seg.getmin(fst[u],fst[v]+1);\n    cout << LCA.second << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate <int B> // (1 << B) >= MAX_LEN\nstruct lowest_common_ancestor {\n    vector<vector<int>> graph;\n    int N, root;\n    int parent[B][1 << B], depth[1 << B];\n\n    lowest_common_ancestor() {}\n    void init(int _root) {\n        root = _root;\n\n        N = graph.size();\n\n        // set ancestors\n        set_parent(root, -1, 0);\n        for (int b = 1; b < B; ++b) {\n            for (int i = 0; i < N; ++i) {\n                if (parent[b-1][i] == -1) {\n                    parent[b][i] = -1;\n                } else {\n                    parent[b][i] = parent[b-1][parent[b-1][i]];\n                }\n            }\n        }\n    }\n\n    int query(int u, int v) {\n        if (depth[u] > depth[v]) {\n            int t = u; u = v; v = t;\n        }\n\n        for (int i = 0; i < B; ++i) {\n            if ((((depth[v] - depth[u]) >> i) & 1) != 0) {\n                v = parent[i][v];\n            }\n        } // depth[u] == depth[v]\n\n        if (u == v) return u;\n\n        for (int b = B-1; b >= 0; --b) {\n            if (parent[b][u] != parent[b][v]) {\n                u = parent[b][u];\n                v = parent[b][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\nprivate:\n    void set_parent(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (const int& e : graph[v]) {\n            if (e != p) {\n                set_parent(e, v, d+1);\n            }\n        }\n    }\n};\n\nint N;\nvector<vector<int>> g;\nlowest_common_ancestor<17> lca;\n\nint main() {\n    cin >> N; lca.graph.resize(N);\n    for (int j = 0; j < N; ++j) {\n        int k; cin >> k;\n        for (int x = 0; x < k; ++x) {\n            int c; cin >> c;\n            lca.graph[j].push_back(c);\n        }\n    }\n\n    lca.init(0);\n\n    int Q; cin >> Q;\n    for (int j = 0; j < Q; ++j) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include<vector>\n#include<algorithm>\n#include<map>\n#include<iomanip>\n#include<set>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<sstream>\n#include<cmath>\n#include<tuple>\n#include<bitset>\nusing namespace std;\n#define rep(i, n) for (ll i = 0; i < (int)(n); i++)\n#define req(i,n) for(ll i = 1;i <=  n; i++)\n#define rrep(i,n) for(ll i = n -1;i >= 0;i--)\n#define ALL(obj) begin(obj), end(obj)\ntypedef long long int ll;\ntypedef long double ld;\nconst int INF =  1e9;\nint k, m, t;int  sum = 0, ans = INF; int n; string s;\nconst ld PI = acos(-1);\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T & val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nstruct LCA {\n    int n, bit; \n    vector<int> depth;\n    vector<vector<int>> par, v;\n    LCA(int n) : n(n) {\n        depth.resize(n, -1);\n        bit = 0;\n        while (1 << bit <= n)  bit++;\n        par.resize(bit);\n        for (int i = 0; i < bit; i++)    par[i].resize(n);\n        v.resize(n);\n    }\n    void add_edge(int a, int b) {\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    void dfs(int now, int p, int d) {\n        par[0][now] = p;\n        depth[now] = d;\n        for (int child : v[now]) {\n            if (child == p)  continue;\n            dfs(child, now, d + 1);\n        }\n    }\n    void build() {\n        for (int i = 0; i < n; i++) {\n            if (depth[i] == -1)    dfs(i, -1, 0);\n        }\n        for (int k = 0; k + 1 < bit; k++) {\n            for (int i = 0; i < n; i++) {\n                if (par[k][i] < 0)   par[k + 1][i] = -1;\n                else                par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n    }\n    int lca(int a, int b) {\n        if (depth[a] > depth[b]) swap(a, b);\n        for (int k = 0; k < 30; k++) {\n            if (((depth[b] - depth[a]) >> k) & 1) {\n                b = par[k][b];\n            }\n        }\n        if (a == b)  return a;\n        for (int k = bit - 1; k >= 0; k--) {\n            if (par[k][a] != par[k][b]) {\n                a = par[k][a];\n                b = par[k][b];\n            }\n        }\n        return par[0][a];\n    }\n    int get_dist(int u, int v) {\n        return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n    }\n    bool is_on_path(int u, int v, int a) {\n        return get_dist(u, a) + get_dist(a, v) == get_dist(u, v);\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    LCA l(n);\n    rep(i,n) {\n        int k; cin >> k;\n        while (k--) {\n            int x; cin >> x;\n            l.add_edge(i, x);\n        }\n    }\n    l.build();\n    int q; cin >> q;\n    while (q--) {\n        int u, v; cin >> u >> v;\n        cout << l.lca(u, v) <<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];//*\nint size[MAX];// *\nint par[MAX];// *\nint cur[MAX];// *\nint dep[MAX];// *\nint depth[MAX];\nint het[MAX];\nint parent[MAX];\n\nvoid idfs(int pos,int prev){\n  int m=-1;\n  parent[pos]=prev;\n  if(G[pos].size()==1&&prev!=-1)return;  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    depth[to]=depth[pos]+1;\n    idfs(to,pos);\n    size[pos]+=size[to];\n    het[pos]=max(het[pos],het[to]+1);\n    if(m==-1||size[m]<size[to]){\n      m=to;\n    }\n  }\n  cur[pos]=m;\n  par[m]=pos;\n  het[pos]=max(het[pos],het[m]);\n}\n\nint calc(int x){\n  if(par[x]==x)return x;\n  return par[x]=calc(par[x]);\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n    size[i]=1;\n    par[i]=i;\n    cur[i]=-1;\n    dep[i]=0;\n    depth[i]=0;\n    het[i]=0;\n    parent[i]=0;\n  }\n  for(int i=0;i<n;i++){    \n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n      G[b].push_back(i);\n    }\n  }\n  for(int i=0;i<n;i++)sort(G[i].begin(),G[i].end());\n  depth[0]=0;\n  idfs(0,-1);\n  for(int i=0;i<n;i++){\n    int root=calc(i);\n    het[i]=het[root];\n    int p=par[i];\n    while(p>0){\n      p= par[ parent[p] ];      \n      dep[i]++;\n    }\n\n    /*    \n    cout<< (char)('A'+i) <<\"   -> \";\n    cout<< (char)('A'+par[i]) <<endl;    \n    cout<<\"size = \"<< size[i]<<\" , \";    \n    cout<<\"depth = \"<< depth[i]<<\" , \";\n    cout<<\"dep = \"<< dep[i]<<\" , \";\n    cout<<\"parent = \"<< (char)('A'+parent[i]) <<\" , \";\n    cout<<\"cur = \"<< (char)('A'+cur[i]) <<\" , \";\n    cout<<\"het = \"<< het[i] << endl;\n    \n    cout<<endl;\n    */\n  }\n\n  \n}\n\nint main(){\n  while( scanf(\"%d\",&n)!=EOF){\n    init();\n    int q;\n    scanf(\"%d\",&q);\n    while(q--){\n      scanf(\"%d %d\",&a,&b);\n\n      while(par[a]!=par[b]){\n        if(dep[a]<dep[b])swap(a,b);\n        a=parent[par[a]];\n      }\n      printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n\n    }\n    break;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    enum { B = 1000 };\n    vector<int> color, par, depth, depthTop, goUp, vis;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root){\n        color.assign(n, 0); par.assign(n, -1); depth.assign(n, 0);\n        depthTop.assign(n, 0); goUp.assign(n, -1); vis.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; vis[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q[r++] = c;\n                par[c] = v; depth[c] = depth[v] + 1;\n            }\n        }\n        vis.assign(n, false);\n        int c = 0;\n        for(int u : tord){\n            if(vis[u]) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                vis[v] = true; color[v] = c; goUp[v] = par[u]; depthTop[v] = depth[u];\n                for(int c : g[v]) if(!vis[c]) q[r++] = c;\n            }\n            c++;\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(depthTop[u] > depthTop[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = par[u];\n            else v = par[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n \nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n \n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(max(logN, 1), vector<int>(N));\n  }\n \n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n \n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n \n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n \nint main() {\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<iostream>\nusing namespace std;\n\n#include<vector>\n#include<memory>\n#include<algorithm>\n\n// class RootedTree {\n// public:\n//     RootedTree(int n) :node(n) {}\n//     std::vector<int> lowest_common_ancestor(int u, int v) {}\n// private:\n//     struct Node {\n//         std::unique_ptr<Node> parent;\n//         std::vector<std::unique_ptr<Node>> child;\n//         Node() :parent(nullptr) {}\n//     };\n//     std::vector<Node> node;\n// };\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(depth(u) > depth(v)) u = parent(u);\n        while(depth(u) < depth(v)) v = parent(v);\n        while(u != v) {\n            u = parent(u);\n            v = parent(v);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n\nclass RMQsub1{//隣接差が±1だけのRMQ\n\tstd::vector<int> pattern;//ブロックがどのパターンか\n\tstd::vector<std::vector<int> > minpos;//バイナリパターンに対する最小位置\n\tstd::vector<int> dat;//葉でないノード\n\tstd::vector<int> depth;\n\tint blocksize;\n\tint n;\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return -1;\n\t\tif(n-1<=k){//leaf\n\t\t\tif(pattern[k-(n-1)]==-1)return -1;\n\t\t\tint s=l<a?a%blocksize:0;\n\t\t\tint t=r<=b?blocksize:b%blocksize;\n\t\t\treturn (k-(n-1))*blocksize+minpos[pattern[k-(n-1)]][s*blocksize+t-1];\n\t\t}else{\n\t\t\tif(a<=l&&r<=b)return dat[k];\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\tif(vl==-1)return vr;\n\t\t\treturn vr==-1||depth[vl]<depth[vr]?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k-1;//log(n)/2\n\t\tint m=(n+blocksize-1)/blocksize;//num node\n\t\twhile(m&m-1)m+=m&-m;\n\t\tthis->n=m;\n\t\tdat.resize(m-1,-1);\n\t\tpattern.resize(n,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint par=(m-1+i-1)/2;\n\t\t\tif(dat[par]==-1 || a[i*blocksize+minpos[p][0+b-1]]<a[dat[par]])\n\t\t\t\tdat[par]=i*blocksize+minpos[p][0+b-1];\n\t\t}\n\t\tdat.resize(m-1);\n\t\tfor(int i=(m-2)/2-1;i>=0;i--){\n\t\t\tint vl,vr;\n\t\t\tvl=dat[2*i+1];\n\t\t\tvr=dat[2*i+2];\n\t\t\tdat[i]=vr==-1||a[vl]<a[vr]?vl:vr;\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n*blocksize);\n\t}\n};\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nstruct LoCoAn {\n  vector<vector<int>> g;\n  vector<vector<int>> par;\n  vector<int> dep;\n  int L = 1;\n  LoCoAn(const vector<vector<int>> &g) : g(g) {\n    int n = g.size();\n    dep.resize(n);\n    while ((1 << L) <= n) {\n      L += 1;\n    }\n    par.resize(n, vector<int>(L, -1));\n    dfs(0);\n    for (int j = 0; j + 1 < L; j++)\n      rep(i, n) {\n        if (par[i][j] >= 0) par[i][j + 1] = par[par[i][j]][j];\n      }\n  }\n  void dfs(int i, int p = -1) {\n    par[i][0] = p;\n    dep[i] = p >= 0 ? dep[p] + 1 : 0;\n    for (int j : g[i]) {\n      if (j != p) dfs(j, i);\n    }\n  }\n  int lca(int s, int t) {\n    if (dep[s] < dep[t]) swap(s, t);\n    rep(i, L) if ((dep[s] - dep[t]) >> i & 1) s = par[s][i];\n    if (s == t) return s;\n    for (int i = L - 1; i >= 0; i--) {\n      if (par[s][i] != par[t][i]) {\n        s = par[s][i];\n        t = par[t][i];\n      }\n    }\n    return par[s][0];\n  }\n};\n\nint main() {\n\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      int c;\n      cin >> c;\n      g[i].emplace_back(c);\n    }\n  }\n  LoCoAn lca(g);\n  int q;\n  cin >> q;\n  while (q--) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy4 = {0, -1, 0, 1}, dx4 = {1, 0, -1, 0};\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n// 木上のクエリを処理\n// ・作成(O(n log n))\n// ・ノード間の距離(O(log n))\n// ・直径・中心(O(log n))\n// ・最小共通素性(O(log n))\n// ・ノード間の最大の重み(O(log n))\nclass QueryOnTree {\nprivate:\n    std::unordered_map<int, std::vector<std::pair<int, int>>> tree;\n    int log_v = 0;\n    std::vector<std::unordered_map<int, int>> parent;        // 2^k個上の親\n    std::vector<std::unordered_map<int, int>> max_weight;    // 2^k個上の親までにでてくる最大の重み\n    std::unordered_map<int, int> depth;                      // 各頂点についての根からの深さ\n    std::unordered_map<int, long long> distance_from_root;   // 根からの距離\n\npublic:\n    QueryOnTree() {\n\n    }\n\n    // 無向グラフの場合はu->vとv->uの両方をいれること\n    QueryOnTree(const std::unordered_map<int, std::vector<std::pair<int, int>>> &tree) : tree(tree) {\n\n    }\n\n    // 無向グラフの場合はu->vとv->uの両方をいれること\n    void add_edge(int u, int v, int w) {\n        tree[u].emplace_back(std::make_pair(v, w));\n    }\n\n    void build(int root) {\n        int n = tree.size();\n        if (n == 0) {\n            return ;\n        }\n\n        this->log_v = int(log2(n)) + 1;\n        this->parent = std::vector<std::unordered_map<int, int>>(log_v);\n        this->max_weight = std::vector<std::unordered_map<int, int>>(log_v);\n        this->distance_from_root[root] = 0;\n\n        dfs(root, -1, 0, 0);\n\n        for (int k = 0; k + 1 < this->log_v; k++) {\n            for (const auto &p : tree) {\n                int u = p.first;\n                if (parent[k][u] < 0) {\n                    parent[k + 1][u] = -1;\n                }\n                else {\n                    parent[k + 1][u] = parent[k][parent[k][u]]; // uの2^k個上のノードの2^k上のノードはuの2^(k+1)個上のノード\n                    if (parent[k + 1][u] >= 0) {\n                        max_weight[k + 1][u] = std::max(max_weight[k][u], max_weight[k][parent[k][u]]);\n                    }\n                }\n            }\n        }\n    }\n\n    // uとvの距離\n    long long distance(int u, int v) {\n        return distance_from_root[u] + distance_from_root[v] - 2 * distance_from_root[lca(u, v)];\n    }\n\n    // 木の直径，中心\n    std::pair<int, long long> center_diameter() {\n        // node 0から一番遠いnode\n        int u = 0;\n        long long max_distance = -1;\n        for (const auto &p : tree) {\n            auto node = p.first;\n            auto dist = this->distance(0, node);\n            if (dist > max_distance) {\n                max_distance = dist;\n                u = node;\n            }\n        }\n\n        // node uから一番遠いnode\n        std::unordered_map<long long, int> distance_node;\n        long long diameter = 0;\n        for (const auto &p : tree) {\n            auto node = p.first;\n            auto dist = this->distance(u, node);\n            distance_node[dist] = node;\n            if (dist > diameter) {\n                diameter = dist;\n            }\n        }\n        assert(diameter != -1);\n\n        int center = distance_node[max_distance / 2];\n\n        return std::make_pair(center, diameter);\n    }\n\n    // uとvの間で出現する最大の重み\n    int maximum_weight(int u, int v) {\n        int lca = this->lca(u, v);\n        return std::max(this->maximum_weight_ancestor(u, lca), this->maximum_weight_ancestor(v, lca));\n    }\n\n    // uとvの最近共通祖先(O(log n))\n    int lca(int u, int v) {\n        if (depth[u] > depth[v]) {\n            std::swap(u, v);\n        }\n        for (int k = 0; k < this->log_v; ++k) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n\n        if (u == v) {\n            return u;\n        }\n\n        for (int k = this->log_v - 1; k >= 0; --k) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\nprivate:\n    // 各頂点について，1つ上の親，1つ上の重み，根からの深さ，根からの距離を求める\n    void dfs(int u, int p, int d, int w) {\n        parent[0][u] = p;\n        max_weight[0][u] = w;\n        depth[u] = d;\n\n        for (const auto &a : tree[u]) {\n            int v = a.first;\n            int dist = a.second;\n            if (v != p) {\n                distance_from_root[v] = distance_from_root[u] + dist;\n                dfs(v, u, d + 1, dist);\n            }\n        }\n    }\n\n    // uとuの祖先の間の最大の重みを取得\n    int maximum_weight_ancestor(int u, int ancestor) {\n        int res = -INF;\n        int d = depth[u] - depth[ancestor];\n        for (int k = 0; k < log_v; k ++) {\n            if ((d >> k) & 1) {\n                res = std::max(res, max_weight[k][u]);\n                u = parent[k][u];\n            }\n        }\n        return res;\n    }\n};\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    QueryOnTree qut;\n    FOR(i, 0, N) {\n        int K;\n        cin >> K;\n        FOR(j, 0, K) {\n            int C;\n            cin >> C;\n            qut.add_edge(i, C, 1);\n            qut.add_edge(C, i, 1);\n        }\n    }\n    qut.build(0);\n\n    int Q;\n    cin >> Q;\n    FOR(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        print(qut.lca(U, V));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n#if 0\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) ord[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n#else\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n#endif\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  // std::freopen(\"in_large.txt\", \"r\", stdin);\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(move(et));\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n//constructor: LCA(n, graph);\nclass LCA {\nprivate:\n    int n;                      //number of vertex\n    int D = 30;                 //hight\n    vector<int> depth;          //depth from root\n    vector<vector<int>> hen;    //tree\n    vector<vector<int>> par;    //doubling array\n\n    void dfs(int v, int p, int dep) {\n        par[v][0] = p;\n        depth[v] = dep; \n        for(auto i : hen[v]) {\n            if(i == p)continue;\n            dfs(i, v, dep + 1);\n        }\n    }\n\npublic:\n\n    LCA(const int& n, const vector<vector<int>>& hen):n(n), hen(hen) {\n        par.resize(n, vector<int>(D + 1));\n        depth.resize(n);\n\n\n        dfs(0, -1, 0);\n        for(int i = 0; i < D; i++) {\n            for(int j = 0; j < n; j++) {\n                if(par[j][i] == -1)par[j][i + 1] = -1;\n                else par[j][i + 1] = par[par[j][i]][i];\n            }\n        }\n    }\n\n    //go back to root\n    int back(int v, int dist) {\n        for(int i = 0; i < D; i++)if((1 << i) & dist) {\n            if(v == -1)return v;\n            v = par[v][i];\n        }\n        return v;\n    }\n\n    //u-v path distance\n    int dist(int u, int v) {\n        int ret = 0;\n        if(depth[u] > depth[v])swap(u, v);\n        ret = depth[v] - depth[u];\n        v = back(v, ret);\n        if(u == v)return ret;\n        int lef = 0, rig = n;\n        while(rig - lef > 1) {\n            int mid =(rig + lef) / 2;\n            (back(u, mid) == back(v, mid) ? rig : lef) = mid;\n        }\n        return rig * 2 + ret;\n    }\n\n    //get LCA\n    int get(int u, int v) {\n        int ret = 0;\n        if(depth[u] > depth[v])swap(u, v);\n        ret = depth[v] - depth[u];\n        v = back(v, ret);\n        if(u == v)return v;\n\n        int lef = 0, rig = n;\n        while(rig - lef > 1) {\n            int mid = (rig + lef) / 2;\n            (back(u, mid) == back(v, mid) ? rig : lef) = mid;\n        }\n        return back(v, rig);\n    }\n\n    //print parents\n    void print(int i) {\n        cerr << \"[\";\n        for(int j = 0; j < n; j++)cerr << par[j][i] << (j == n - 1 ? \"\" : \",\");\n        cerr << \"]\";\n    }\n\n};\n\nint main()\n{\n    int n; cin >> n;\n    vector<vector<int>> hen(n);\n    for(int i = 0; i < n; i++) {\n        int t; cin >> t;\n        for(int j = 0; j < t; j++) {\n            int p; cin >> p;\n            hen[i].push_back(p);\n            hen[p].push_back(i);\n        }\n    }\n    LCA lca(n, hen);\n    int q; cin >> q;\n    for(int i = 0; i < q; i++) {\n        int u, v; cin >> u >> v;\n        cout << lca.get(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nconst int MAX = 1e5;\npii table[17][MAX * 2 - 1];\n\nint n;\nvector<int> G[MAX];\nint id[MAX];\n\nint it = 0;\n\nvoid dfs(int v, int d) {\n\tid[v] = it;\n\ttable[0][it++] = { d, v };\n\tfor (auto to : G[v]) {\n\t\tdfs(to, d + 1);\n\t\ttable[0][it++] = { d, v };\n\t}\n}\n\nvoid init() {\n\tdfs(0, 0);\n\tint m = (n << 1) - 1;\n\tint h = 31 - __builtin_clz(m);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j + (1 << i) < m; j++) {\n\t\t\ttable[i + 1][j] = min(table[i][j], table[i][j + (1 << i)]);\n\t\t}\n\t}\n}\n\nint lca(int u, int v) {\n\tu = id[u], v = id[v];\n\tif (u > v) swap(u, v);\n\tint b = 31 - __builtin_clz(v + 1 - u);\n\treturn min(table[b][u], table[b][v + 1 - (1 << b)]).second;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\n\nvvi E(222222);\n\ntemplate< typename G >\nclass DoublingLowestCommonAncestor {\npublic:\n  const G &g;\n  vector< int > depth;//depth[v]=根からvまでの距離\n  const int LOG;\n  vector< vector< int > > table;\n \n  DoublingLowestCommonAncestor(const G &g) : g(g), depth(g.size()), LOG(32 - __builtin_clz(g.size())) {\n    table.assign(LOG, vector< int >(g.size(), -1));\n  }\n \n  void dfs(int idx, int par, int d) {\n    table[0][idx] = par;\n    depth[idx] = d;\n    for(auto &to : g[idx]) {\n      if(to != par) dfs(to, idx, d + 1);\n    }\n  }\n \n  void build(int v) {\n    dfs(v, -1, 0);\n    for(int k = 0; k + 1 < LOG; k++) {\n      for(int i = 0,tablesize = table[k].size(); i < tablesize; i++) {\n\tif(table[k][i] == -1) table[k + 1][i] = -1;\n\telse table[k + 1][i] = table[k][table[k][i]];\n      }\n    }\n  }\n \n  int query(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(((depth[v] - depth[u]) >> i) & 1) v = table[i][v];\n    }\n    if(u == v) return u;\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(table[i][u] != table[i][v]) {\n\tu = table[i][u];\n\tv = table[i][v];\n      }\n    }\n    return table[0][u];\n  }\n};\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;cin>>n;\n  for(int i=0;i<n;i++){\n    ll p;cin>>p;\n    for(int j=0;j<p;j++){\n      ll a;cin>>a;\n      E[a].pb(i);\n      E[i].pb(a);\n    }\n  }\n  DoublingLowestCommonAncestor<vvi> lca(E);\n  lca.build(0);\n  ll q;cin>>q;\n  for(int i=0;i<q;i++){\n    ll u,v;cin>>u>>v;\n    cout<<lca.query(u,v)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nclass LCA {\nprivate:\n\tconst std::vector<std::vector<int>>& graph; // graph's list expression\n\tint root;\n\tint n; // the number of nodes\n\tint log2n; // = floor(log2(n))\n\tstd::vector<std::vector<int>> parent; // parent[x][v] = a parent(above 2^x) of v (nonexistence -> -1)\n\tstd::vector<int> depth; // the depth of each node\n\npublic:\n\tLCA(const std::vector<std::vector<int>>& graph, int root) :\n\t\tgraph(graph), root(root), n(graph.size()), log2n(std::floor(std::log2(n))),\n\t\tparent(log2n, std::vector<int>(n, 0)), depth(n, 0)\n\t{\n\t\tinit();\n\t}\n\n\t// Check the depth of each node(node \"v\" -> parent is \"p\", depth is \"d\")\n\tvoid dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (int i = 0; i < graph[v].size(); ++i) {\n\t\t\tif (graph[v][i] != p) {\n\t\t\t\tdfs(graph[v][i], v, d + 1); // Check each child of v\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initialize\n\tvoid init() {\n\t\t// Initialize \"parent[0]\" and \"depth\"\n\t\tdfs(root, -1, 0);\n\n\t\t// Initialize \"parent\"\n\t\tfor (int k = 0; k < log2n - 1; ++k) {\n\t\t\tfor (int v = 0; v < n; ++v) {\n\t\t\t\tif (parent[k][v] < 0) { // If parent above 2^k of v is nonexistence\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find LCA of (u, v)\n\tint lca(int u, int v) {\n\t\t// go up parent while depth of u and v is same\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2n; ++k) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v]; // go up to 2^k if k-th binary is 1\n\t\t\t}\n\t\t}\n\n\t\tif (u == v) return u; // this case is that v is in u's subtree\n\n\t\t// Find LCA by binary searching\n\t\tfor (int k = log2n - 1; k >= 0; --k) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n) {\n\t\tVAR(int, k);\n\t\tVEC(int, c, k);\n\t\tREP(j, k) {\n\t\t\tg[i].emplace_back(c[j]);\n\t\t}\n\t}\n\tLCA lca(g, 0);\n\tVAR(int, Q);\n\tREP(q, Q) {\n\t\tVAR(int, u, v);\n\t\tOUT(lca.lca(u, v))BR;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define double long double\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\n// const double PI = atan(1.0) * 4.0;\nconst ll dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\n// rmq build:n query:logn\nstruct LCA {\n    const int lg = 12;\n    const int sz = 1 << lg;\n    const int ms = sz - 1;\n    int n;\n    vector<int> P, D, E, A, B, T, ht;\n    vector<vector<int>> G, dat;\n    LCA(int n)\n        : n(n), P(n, -1), D(n), E(n * 2, 0), A(n * 2, -1), B(n * 2 / lg + 1), T(sz, 0), G(n) {}\n\n    void add_edge(int u, int v) {\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    void dfs(int v, int p, int d, int &k) {\n        D[v] = k;\n        A[k] = P[v] = p;\n        E[k++] = d;\n        for(int u : G[v])\n            if(u != p) dfs(u, v, d + 1, k);\n        A[k] = P[v];\n        E[k++] = d - 1;\n    }\n\n    // if it need leftmost, then add: if(E[i]==E[j]) return i<j?i:j;\n    inline int comp(int i, int j) { return E[i] < E[j] ? i : j; };\n    inline int comp(int i, int j, int k) { return comp(comp(i, j), k); };\n\n    void build(int r = 0) {\n        int k = 0;\n        dfs(r, -1, 1, k);\n\n        B[0] = 1;\n        for(int i = 1; i < n * 2; i++)\n            B[i / lg] |= (E[i - 1] < E[i]) << (i % lg);\n\n        for(int b = 0; b < sz; b++) {\n            int e = 0, w = 1, &x = T[b];\n            for(int i = 0; i < lg; i++) {\n                if((b >> i) & 1)\n                    e++;\n                else\n                    e--;\n                if(e < w) e = w, x = i;\n            }\n        }\n\n        int m = (n * 2 + lg - 1) / lg;\n        int h = 1;\n        while((1 << h) < m) h++;\n        dat.assign(h, vector<int>(m, -1));\n        ht.assign(m + 1, 0);\n        for(int j = 2; j <= m; j++) ht[j] = ht[j >> 1] + 1;\n\n        for(int j = 0; j < n * 2; j++) {\n            if(dat[0][j / lg] < 0) dat[0][j / lg] = j;\n            dat[0][j / lg] = comp(dat[0][j / lg], j);\n        }\n\n        for(int i = 1, p = 1; i < h; i++, p <<= 1)\n            for(int j = 0; j < m; j++)\n                dat[i][j] = comp(dat[i - 1][j], dat[i - 1][min(j + p, m - 1)]);\n    }\n\n    inline int cs(int a, int b) {\n        int l = b - a;\n        return comp(dat[ht[l]][a], dat[ht[l]][b - (1 << ht[l])]);\n    }\n\n    inline int es(int i, int l, int r) {\n        int x = r - i * lg + 1, y = l - i * lg;\n        int b = (((B[i] | (ms << x)) >> y) | (ms << (lg - y))) & ms;\n        return l + T[b];\n    }\n\n    inline int ls(int i, int l) {\n        int k = l - i * lg;\n        int b = ((B[i] >> k) | (ms << (lg - k))) & ms;\n        return l + T[b];\n    }\n\n    inline int rs(int j, int r) {\n        int k = r - j * lg + 1;\n        int b = (B[j] | (ms << k)) & ms;\n        return j * lg + T[b];\n    }\n\n    inline int rmq(int l, int r) {\n        int i = l / lg, j = r / lg;\n        if(i == j) return es(i, l, r);\n        if(i + 1 == j) return comp(ls(i, l), rs(j, r));\n        return comp(ls(i, l), cs(i + 1, j), rs(j, r));\n    }\n\n    int lca(int l, int r) {\n        if(l == r) return l;\n        if(D[l] > D[r]) swap(l, r);\n        int x = D[l], y = D[r];\n        int m = rmq(x, y);\n        return m == x ? l : A[m];\n    }\n};\n\nsigned main() {\n    LCIN(n);\n    LCA lca(n);\n    REP(i, n) {\n        LCIN(k);\n        REP(j, k) {\n            LCIN(c);\n            lca.add_edge(i, c);\n        }\n    }\n    lca.build();\n    LCIN(q);\n    REP(i, q) {\n        LCIN(u, v);\n        cout << lca.lca(u, v) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// LCA (0-indexed)\nstruct LCA {\n  int n, bi;\n  vi dep;\n  vector<vi> to, par;\n  LCA(int n):n(n),dep(n),to(n){}\n  void add(int a, int b){ to[a].pb(b); to[b].pb(a);}\n  void calcDep(int v, int ndep=0, int p=-1){\n    dep[v] = ndep; par[0][v] = p;\n    for(int u : to[v]) if(u != p) calcDep(u,ndep+1,v);\n  }\n  void init(){\n    bi = 0;\n    while(1<<bi <= n) bi++;\n    par.resize(bi,vi(n,-1));\n    calcDep(0);\n    rep(i,bi-1)rep(j,n) par[i+1][j] = (par[i][j]==-1?-1:par[i][par[i][j]]);\n  }\n  int lca(int a, int b){\n    if(dep[a] < dep[b]) swap(a,b);\n    int x = dep[a]-dep[b];\n    for(int i = bi-1; i >= 0; --i){\n      if(1<<i <= x) a = par[i][a], x -= 1<<i;\n    }\n    if(a == b) return a;\n    for(int i = bi-1; i >= 0; --i){\n      if(par[i][a] != par[i][b]) a = par[i][a], b = par[i][b];\n    }\n    return par[0][a];\n  }\n  int dist(int a, int b){\n    int c = lca(a,b);\n    return dep[a]+dep[b] - dep[c]*2;\n  }\n};\n//\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  LCA g(n);\n  rep(i,n) {\n    int m;\n    scanf(\"%d\",&m);\n    rep(j,m) {\n      int a;\n      scanf(\"%d\",&a);\n      g.add(i,a);\n    }\n  }\n  g.init();\n  int q;\n  scanf(\"%d\",&q);\n  rep(i,q) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    printf(\"%d\\n\",g.lca(a,b));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using treap = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\nstruct TreeDoubling {\n  struct Edge { int to; }; // 場合に応じて書き換える、toは必須\n  vector<vector<Edge>> g;\n  int n, size; // MSB + 1\n  int root;\n  vector<int> depth;\n  vector<vector<int>> parent; // ダミー頂点n(親もn)\n  TreeDoubling(int n) : g(n), n(n), depth(n), size(64 - __builtin_clzll(n)) {\n    parent.resize(size, vector<int>(n + 1, n));\n  }\n  void dfs(int v, int prev, int d) {\n    depth[v] = d;\n    parent[0][v] = prev;\n    for (auto& s : g[v]) if (s.to != prev) {\n      dfs(s.to, v, d + 1);\n    }\n  }\n  void build(int root_ = 0) {\n    root = root_;\n    dfs(root, n, 0);\n    for (int k = 0; k < size - 1; k++) {\n      for (int i = 0; i < n; i++) {\n        parent[k + 1][i] = parent[k][parent[k][i]];\n      }\n    }\n  }\n  \n  // vからd個分親にさかのぼった頂点、rootよりも上はnを返す\n  int query(int v, int d) {\n    int ret = v;\n    for (int j = 0; j < size; j++) {\n      if (d >> j & 1) ret = parent[j][ret];\n    }\n    return ret;\n  }\n  int lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    v = query(v, depth[v] - depth[u]);\n    if (u == v) return u;\n\n    for (int j = size - 1; j >= 0; j--) {\n      if (parent[j][u] == parent[j][v]) continue;\n      u = parent[j][u];\n      v = parent[j][v];\n    }\n    assert(parent[0][u] == parent[0][v]);\n    return parent[0][u];\n  }\n};\n\nsigned main() {\n  int n; cin >> n;\n  TreeDoubling td(n);\n  REP (i, n) {\n    int k; cin >> k;\n    REP (x, k) {\n      int j; cin >> j;\n      td.g[i].push_back({j});\n    }\n  }\n  td.build();\n  int Q; cin >> Q;\n  while (Q--) {\n    int u, v; cin >> u >> v;\n    cout << td.lca(u, v) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdint>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::uint_fast32_t;\n\nprivate:\n\tstd::vector<std::pair<bool, size_type>> tree;\n\npublic:\n\tUnionFind(const size_type size) : tree(size, std::make_pair(1, 1)) {}\n\tsize_type find(const size_type x) {\n\t\tassert(x < size());\n\t\tif (tree[x].first)\n\t\t\treturn x;\n\t\treturn tree[x].second = find(tree[x].second);\n\t}\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (tree[x].second < tree[y].second)\n\t\t\tstd::swap(x, y);\n\t\ttree[x].second += tree[y].second;\n\t\ttree[y] = std::make_pair(0, x);\n\t\treturn true;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn tree[find(x)].second;\n\t}\n\tsize_type size() const noexcept { return tree.size(); }\n\tbool empty() const noexcept { return tree.empty(); }\n};\n\n#include <cstddef>\n#include <functional>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\n\ntemplate <class GraphContainer, class UnionFindDataStructure>\nstd::vector<typename GraphContainer::size_type> TarjansOfflineLCA(\n\tconst GraphContainer &graph, const typename GraphContainer::size_type root,\n\tconst std::vector<std::pair<typename GraphContainer::size_type,\n\ttypename GraphContainer::size_type>> &queries) {\n\tusing size_type = typename GraphContainer::size_type;\n\tconst size_type size_ = graph.size();\n\tUnionFindDataStructure uft(size_);\n\tstd::vector<size_type> ret(queries.size(), size_), anc(size_);\n\tstd::vector<std::vector<std::size_t>> qset(size_);\n\tstd::stack<std::pair<size_type, size_type>> st;\n\n\tfor (std::size_t i = 0; i < queries.size(); ++i) {\n\t\tqset[queries[i].first].emplace_back(i);\n\t\tqset[queries[i].second].emplace_back(i);\n\t}\n\n\tst.emplace(root, 0);\n\n\tstd::function<void(const size_type, const size_type)> dfs =\n\t\t[&](const size_type v, const size_type prev) {\n\t\tanc[v] = v;\n\t\tfor (const auto e : graph[v]) {\n\t\t\tif (e.to != prev) {\n\t\t\t\tdfs(e.to,v);\n\t\t\t\tuft.unite(v, e.to);\n\t\t\t\tanc[uft.find(v)] = v;\n\t\t\t}\n\t\t}\n\t\tfor (const auto e : qset[v])\n\t\t\tif (ret[e] == size_)\n\t\t\t\tret[e] = v;\n\t\t\telse\n\t\t\t\tret[e] = anc[uft.find(ret[e])];\n\t};\n\tdfs(root, size_);\n\treturn ret;\n}\n\n#include <cstddef>\n#include <vector>\n\nstruct edge {\n\tusing cost_type = int;\n\tusing size_type = std::size_t;\n\n\tstd::size_t to;\n\tedge(size_type t):to(t){}\n};\n\ntemplate <class Edge> using Graph = std::vector<std::vector<Edge>>;\n\n#include<cstdio>\nint main() {\n\tusing uint = unsigned int;\n\tuint n;\n\tscanf(\"%u\", &n);\n\tGraph<edge> g(n);\n\tfor (uint i = 0;i < n;++i) {\n\t\tuint k, c;\n\t\tscanf(\"%u\", &k);\n\t\twhile (k--) {\n\t\t\tscanf(\"%u\", &c);\n\t\t\tg[i].emplace_back(c);\n\t\t}\n\t}\n\tuint q;\n\tscanf(\"%u\", &q);\n\tusing S = typename Graph<edge>::size_type;\n\tstd::vector<std::pair<S, S>> Q;\n\tQ.reserve(q);\n\twhile (q--) {\n\t\tuint u, v;\n\t\tscanf(\"%u%u\", &u, &v);\n\t\tQ.emplace_back(u, v);\n\t}\n\tconst auto &&ans=TarjansOfflineLCA<Graph<edge>, UnionFind>(g, 0, Q);\n\tfor (const auto e : ans)\n\t\tprintf(\"%u\\n\", e);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define rrep(i, n) for (int i = (int)n-1; i >= 0; --i)\nusing namespace std;\nusing ll = long long;\ntemplate<typename T>\ninline bool chmax(T& a, const T& b) {\n    if (a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T>\ninline bool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T> vector<T> make_vec(size_t n) { return vector<T>(n); }\ntemplate<typename T, typename... Args> auto make_vec(size_t n, Args... args) {\n    return vector<decltype(make_vec<T>(args...))>(n, make_vec<T>(args...));\n}\ntemplate<typename T, typename U, typename... V>\ntypename enable_if<is_same<T, U>::value>::type fill_v(U& u, const V... v) { u = U(v...); }\ntemplate<typename T, typename U, typename... V>\ntypename enable_if<!is_same<T, U>::value>::type fill_v(U& u, const V... v) {\n    for (auto& e : u) fill_v<T>(e, v...);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n    auto par = make_vec<int>(20, n);\n    rep(i, n) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int c;\n            cin >> c;\n            par[0][c] = i;\n        }\n    }\n\n    for (int i = 1; i < 20; ++i) {\n        rep(j, n) {\n            par[i][j] = par[i-1][par[i-1][j]];\n        }\n    }\n\n    vector<int> dep(n);\n    rep(i, n) {\n        if (i == 0) continue;\n        int now = i;\n        for (int j = 19; j >= 0; --j) {\n            if (par[j][now] != 0) {\n                now = par[j][now];\n                dep[i] += 1 << j;\n            }\n        }\n        dep[i]++;\n    }\n\n    auto la = [&](int v, int level) {\n        rep(i, 20) {\n            if (level >> i & 1) {\n                v = par[i][v];\n                level -= 1 << i;\n            }\n        }\n        return v;\n    };\n\n    auto lca = [&](int u, int v) {\n        if (dep[u] < dep[v]) swap(u, v);\n        u = la(u, dep[u] - dep[v]);\n        if (u == v) return u;\n        for (int i = 19; i >= 0; --i) {\n            if (par[i][u] != par[i][v]) {\n                u = par[i][u];\n                v = par[i][v];\n            }\n        }\n        return par[0][u];\n    };\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define MAX_V 100000\n\nvector<int> G[MAX_V];\nvector<int> depth,vs;\nint id[MAX_V]={};\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int a;\n            cin>>a;\n            G[i].pb(a);\n        }\n    }\n    \n    init();\n    segtree<pii> st(depth.size(),pii((1<<31)-1,(1<<31)-1));\n    rep(i,depth.size()){\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int q;\n    cin>>q;\n    rep(i,q){\n        int a,b;\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nint n,k,q,sz[100005],hv[100005],vs[100005],hd[100005],dp[100005],cn[100005],id[1000005];\nvector<int>g[100005];\nvoid dfs(int v,int p){\n    sz[v]=1;\n    hv[v]=-1;\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=p){\n            dfs(g[v][i],v);\n            sz[v]+=sz[g[v][i]];\n            if(hv[v]==-1||sz[hv[v]]<sz[g[v][i]])hv[v]=g[v][i];\n        }\n    }\n}\nvoid dfs1(int v,int d,int p,int h){\n    hd[k]=h;\n    cn[k]=cn[h];\n    id[v]=k;\n    vs[k]=v;\n    dp[k++]=d;\n    if(hv[v]!=-1)dfs1(hv[v],d+1,v,h);\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=p&&g[v][i]!=hv[v]){\n            cn[k]=id[v];\n            dfs1(g[v][i],d+1,v,k);\n        }\n    }\n}\nint lca(int u,int v){\n    u=id[u];v=id[v];\n    while(hd[u]!=hd[v]){\n        if(dp[hd[u]]>dp[hd[v]])u=cn[u];\n        else v=cn[v];\n    }\n    return vs[min(u,v)];\n}\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            int a;\n            scanf(\"%d\",&a);\n            g[i].push_back(a);\n            g[a].push_back(i);\n        }\n    }\n    dfs(0,-1);\n    dfs1(0,0,-1,0);\n    scanf(\"%d\",&q);\n    for(int i=0;i<q;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        printf(\"%d\\n\",lca(a,b));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> vi;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct hl_decomp {\n\tint N, M;\n\tvector<vi> G;\n\tvi sz, id, par, dep;\n\thl_decomp(int _N, vector<vi> _G)\n\t\t: N(_N), G(_G), sz(N), id(N), par(N), dep(N) {\n\t\tdfs_sz(0, -1);\n\t\tdfs_decomp(0, -1);\n\t\tM = 1; par[0] = -1; dfs_decomp(0, -1);\n\t\tdfs_dep(0, -1);\n\t}\n\tvoid dfs_sz(int u, int p) {\n\t\tsz[u] = 1;\n\t\tfor (int v : G[u]) if (v != p) {\n\t\t\tdfs_sz(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t}\n\tvoid dfs_decomp(int u, int p) {\n\t\tint v0 = -1;\n\t\tfor (int v : G[u]) if (v != p)\n\t\t\tif (v0 == -1 || sz[v] > sz[v0]) v0 = v;\n\t\tfor (int v : G[u]) if (v != p) {\n\t\t\tif (v == v0) {\n\t\t\t\tid[v] = id[u];\n\t\t\t\tpar[v] = par[u];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid[v] = M++;\n\t\t\t\tpar[v] = u;\n\t\t\t}\n\t\t\tdfs_decomp(v, u);\n\t\t}\n\t}\n\tvoid dfs_dep(int u, int p) {\n\t\tfor (int v : G[u]) if (v != p) {\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tdfs_dep(v, u);\n\t\t}\n\t}\n\tint lca(int u, int v) {\n\t\twhile (id[u] != id[v]) {\n\t\t\tint _u = par[u], _v = par[v];\n\t\t\tint du = (_u == -1 ? -1 : dep[_u]);\n\t\t\tint dv = (_v == -1 ? -1 : dep[_v]);\n\t\t\tif (du >= dv) u = _u;\n\t\t\telse v = _v;\n\t\t}\n\t\treturn dep[u] < dep[v] ? u : v;\n\t}\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int> > G(N);\n\trep(u, N) {\n\t\tint K; scanf(\"%d\", &K);\n\t\twhile (K--) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\tG[u].pb(v);\n\t\t}\n\t}\n\thl_decomp hl(N, G);\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tint w = hl.lca(u, v);\n\t\tprintf(\"%d\\n\", w);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconst int MAX_N = 100001;\n\n\n\nint D[MAX_N];// (HL分解後にあるnodeとあるnodeが同じHeavyPathに含まれているかどうか)\nint find(int a){return a-D[a]?(D[a]=find(D[a])):a; }\n  \nstruct node{\n  int id;\n  vector<int> to;\n  int h;//深さ\n  int size;\n  node(){ h = -1; }\n  bool operator<(const node& n) const{\n    return h < n.h;\n  }\n};\n  \nstruct HL_node{\n  int h;\n  vector<int> v;//sortされる\n  int np;//Light-edgeで結ばれた親\n};\n  \nbool used[MAX_N];\nint vid[MAX_N];\nnode G[MAX_N];//子への辺をもつ\nHL_node HL[MAX_N];\nint V;//頂点数\n\n  \nint dfs(int id,int h){\n  if( G[id].h>-1 ) return 0;\n  G[id].h = h;\n  G[id].size = 1;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    G[id].size+=dfs(G[id].to[i],h+1);;\n  }\n  if( G[id].size == 1 ) return G[id].size;\n  for(int i=0;i<(int)G[id].to.size();i++){\n    if( G[id].size/2 <= G[G[id].to[i]].size ){\n      D[G[id].to[i]] = find(id);break;    \n    }\n  }\n  return G[id].size;\n}\n\nvoid HeavyLightDecomposition(int root){\n  for(int i=0;i<V;i++) D[i] = i;\n  memset(used,0,sizeof(used));\n  dfs(root,0);\n  sort(G,G+V);\n  vector<int> vs;//after_hl\n  for(int i=0;i<V;i++) vid[G[i].id] = i;\n  for(int i=0;i<V;i++){\n    int now = G[i].id;\n    used[now] = true;\n    HL[find(now)].v.push_back(now);\n    for(int j=0;j<(int)G[vid[now]].to.size();j++){\n      int to = G[vid[now]].to[j];\n      if( used[to] ) continue;\n      if( find(to) == find(now) ) continue;\n      HL[find(to)].np = now;\n      HL[find(to)].h = HL[find(now)].h+1;\n    }  \n  }\n\n}\n  \nint HeavyLightLCA(int a, int b){\n  for(; HL[find(a)].h != HL[find(b)].h ; HL[find(a)].h>HL[find(b)].h?(a=HL[find(a)].np):(b=HL[find(b)].np) );\n  for(; find(a) != find(b) ; a = HL[find(a)].np, b = HL[find(b)].np );\n  return vid[a]<vid[b]?a:b;\n}\n\nint main(){\n  cin >> V;\n  for(int i=0;i<V;i++){\n    G[i].id = i;\n    int k; cin >> k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin >> c;\n      G[i].to.push_back( c );\n    }\n  }\n  HeavyLightDecomposition(0);\n  int Q;\n  cin >> Q;\n  for(int i=0;i<Q;i++){ \n    int u,v; cin >> u>> v;\n    cout << HeavyLightLCA(u,v) << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.resize(2 * size - 1);\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tif (i < n)\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = pii(depth[i], et[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata[size - 1 + i] = pii(INF, -1);\n\t\t\t}\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn pii(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src_, int dst_, Weight weight_) :\n        src(src_), dst(dst_), weight(weight_) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint const MAX_V = 1000010;\n\ntypedef int dat_t;\ndat_t const inf = (1LL<<31)-1;\ndat_t const init = (1LL<<31)-1;\nstruct segment_tree {\n    vector<pair<dat_t,int>> dat;\n    int n;\n    segment_tree(int n_){\n        n = 1;\n        while(n < n_) n<<=1;\n        dat.resize(n*2);\n        for(int i=n; i<n+n; i++){\n            dat[i] = make_pair(init,i); // -infをdat[i]にするとvectorからのコンストラクタになる\n        }\n        for(int i=n-1; i>=1; i--){\n            dat[i] = min(dat[i<<1], dat[i<<1|1]);\n        }\n    }\n    // bottom-up\n    void set(int k, dat_t x){\n        int i = n+k; // leaf\n        dat[i] = make_pair(x,k);\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i], dat[i^1]);\n            i>>=1;\n        }\n    }\n    // top-down\n    pair<dat_t,int> get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return make_pair(inf,0);\n        if(a <= l && r <= b) return dat[k];\n        pair<dat_t,int> v1 = get(a,b,k<<1,l,(l+r)/2);\n        pair<dat_t,int> v2 = get(a,b,k<<1|1,(l+r)/2,r);\n        return min(v1,v2);\n    }\n    pair<dat_t,int> get(int a, int b){\n        return get(a,b,1,0,n);\n    }\n};\n\nstruct LowestCommonAncestor {\n    int n;\n    Graph g;\n    unique_ptr<int[]> ord, depth, id;\n    unique_ptr<segment_tree> rmq;\n    LowestCommonAncestor(int n_)\n        : n(n_), g(n), ord(new int[n*2]), depth(new int[n*2]), id(new int[n]), rmq(new segment_tree(n*2)) {\n    }\n    void add_edge(int a, int b){\n        g[a].eb(a,b,0);\n    }\n    void compile(int root = 0){\n        int k = 0;\n        dfs(root,-1,0,k);\n        for(int i=0;i<k;i++){\n            rmq->set(i,depth[i]);\n        }\n    }\n    int ask(int u, int v){\n        int a = id[u], b = id[v];\n        return ord[rmq->get(min(a,b), max(a,b)+1).second];\n    }\n    void dfs(int v, int p, int d, int & k){\n        id[v] = k;\n        ord[k] = v;\n        depth[k] = d;\n        k++;\n        for(auto & e : g[v]){\n            if(e.dst != p){\n                dfs(e.dst, v, d+1, k);\n                ord[k] = v;\n                depth[k] = d;\n                k++;\n            }\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k; cin >> k;\n        for(int j=0;j<k;j++){\n            int to; cin >> to;\n            g.add_edge(i,to);\n            g.add_edge(to,i);\n        }\n    }\n    g.compile();\n    int q;\n    cin >> q;\n    for(int i=0;i<q;i++){\n        int u,v;\n        cin >> u >> v;\n        cout << g.ask(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    enum { B = 500 };\n    vector<int> color, par, depth, depthTop, goUp, vis;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root){\n        color.assign(n,0); par.assign(n,-1); depth.assign(n,0);\n        depthTop.assign(n,0); goUp.assign(n,-1); vis.assign(n,0);\n        for(size_t i = 0; i < n; i++) vis[i] = false, par[i] = -1;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        vector<int> tord;\n        while(l != r){\n            int v = q[l++]; vis[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q[r++] = c;\n                par[c] = v; depth[c] = depth[v] + 1;\n            }\n        }\n        for(size_t i = 0; i < n; i++) vis[i] = false;\n        int c = 0;\n        for(int u : tord){\n            if(vis[u]) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                vis[v] = true; color[v] = c; goUp[v] = par[u]; depthTop[v] = depth[u];\n                for(int c : g[v]) if(!vis[c]) q[r++] = c;\n            }\n            c++;\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(depthTop[u] > depthTop[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = par[u];\n            else v = par[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 100005\n\nint n,a,b,c;\nvector<int> G[MAX];\nint size[MAX];\nint par[MAX];\nint dep[MAX];\nint depth[MAX];\nint parent[MAX];\n\nvoid idfs(int pos){\n  int m=-1;\n  if(G[pos].empty())return;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    depth[to]=depth[pos]+1;\n    idfs(to);\n    size[pos]+=size[to];\n    if(m==-1||size[m]<size[to])m=to;\n  }\n  par[m]=pos;\n}\n\nint calc(int x){\n  if(par[x]==x)return x;\n  return par[x]=calc(par[x]);\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    size[i]=1;\n    par[i]=i;\n  }\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",&a);\n    while(a--){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n      parent[b]=i;\n    }\n  }\n  idfs(0);\n  for(int i=0;i<n;i++){\n    int p=calc(i);\n    while(p){\n      p=par[parent[p]];\n      dep[i]++;\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  init();\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    scanf(\"%d %d\",&a,&b);\n    while(par[a]!=par[b]){\n      if(dep[a]<dep[b])swap(a,b);\n      a=parent[par[a]];\n    }\n    printf(\"%d\\n\",(depth[a]<depth[b]?a:b));      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define FOR(i,n) for (int i = 0; i < n; i++)\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ii> vii;\ntypedef vector<vii> vvii;\n\nconst int MX = 100005, LMX = 18;\nint p[LMX][MX], lvl[MX];\nint n, q, u, v, k;\nvi adj[MX];\n\nvoid dfs (int u) {\n\tfor (int v : adj[u]) {\n\t\tp[0][v] = u;\n\t\tlvl[v] = lvl[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nvoid pre () {\n\tfor (int j = 1; j < LMX; j++)\n\t\tfor (int i = 0; i < n; i++) \n\t\t\tp[j][i] = p[j-1][p[j-1][i]];\n}\n\nint lca (int u, int v) {\n\tif (lvl[u] < lvl[v])\n\t\tswap(u, v);\n\n\tfor (int j = 0; j < LMX; j++)\n\t\tif ((lvl[u] - lvl[v]) & (1 << j))\n\t\t\tu = p[j][u];\n\n\tif (u == v)\n\t\treturn u;\n\n\tfor (int j = LMX - 1; j >= 0; j--)\n\t\tif (p[j][u] != p[j][v]) {\n\t\t\tu = p[j][u];\n\t\t\tv = p[j][v];\n\t\t}\n\n\treturn p[0][u];\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    \n    cin >> n;\n    for (int i = 0; i < n; i++) {\n    \tcin >> k;\n    \twhile (k--) {\n    \t\tcin >> u;\n    \t\tadj[i].push_back(u);\n    \t}\n    }\n\n   \tdfs(0);\n   \tpre();\n\n    cin >> q;\n    while (q--) {\n    \tcin >> u >> v;\n    \tcout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type, ps, pt;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n),ps(n),pt(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int, int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v=st.top().first;\n      int &i=st.top().second;\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tfor(int j=0;j<(int)G[v].size();j++){\n\t  int &u=G[v][j];\n\t  if(u==par[v]){\n\t    swap(u,G[v].back());\n\t    continue;\n\t  }\n\t  sub[v]+=sub[u];\n\t  if(sub[u]>sub[G[v].front()]) swap(u,G[v].front());\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    using T = tuple<int, int, int>;\n    stack<T> st;\n    st.emplace(r,r,0);\n    while(!st.empty()){\n      int v,h;\n      tie(v,h,ignore)=st.top();\n      int &i=get<2>(st.top());\n      if(!i){\n\ttype[v]=c;\n\tps[v]=vid[v]=pos++;\n\tinv[vid[v]]=v;\n\thead[v]=h;\n        hvy[v]=(G[v].empty()?-1:G[v][0]);\n\tif(hvy[v]==par[v]) hvy[v]=-1;\n      }\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tst.emplace(u,(hvy[v]==u?h:u),0);\n      }else{\n\tst.pop();\n\tpt[v]=pos;\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      }else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\nsigned AOJ_GRL5C(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned YUKI_529(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){a++;return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/12/31\nhttps://yukicoder.me/problems/no/529\n*/\n\nsigned main(){\n  AOJ_GRL5C();\n  //YUKI_529();\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int MAXN = 100005;\n\nint path[2*MAXN], depth[2*MAXN], idx[MAXN];     // idx : the index of node in dfs path\n\nint par[MAXN];\nvi adjList[MAXN];\n\nclass SparseTable{\nprivate:\n    int n, h;\n    vvi t;\n\n    int combine(int l, int r){\n        if (l == -1 || r == -1) return max(l,r);\n\n        return depth[l] < depth[r] ? l : r;\n    }\npublic:\n    SparseTable(int size){\n        n = size; h = ( n == 1 ? 1 : ceil(log2(n)));\n        t.assign(h, vi());\n\n        t[0].assign(n,0);\n        for (int i=0; i<n; i++) t[0][i] = i;\n        for (int i=1; i<h; i++){\n            t[i].assign(n,0);\n            for (int j=0; j+(1<<i)<=n; j++){\n                t[i][j] = combine(t[i-1][j],t[i-1][j+(1<<(i-1))]);\n            }\n        }\n    }\n    int query(int l, int r){                            // query in range v[l,r]\n        int p = 31 - __builtin_clz(r-l+1);\n        return combine(t[p][l],t[p][r-(1<<p)+1]);\n    }\n};\n\nint cnt = 0;\n\n// build dfs path, depth\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n    path[cnt] = curr;\n    depth[cnt++] = d;\n    for (int i=0; i<adjList[curr].size(); i++){\n        dfs(adjList[curr][i],d+1);\n\n        path[cnt] = curr;\n        depth[cnt++] = d;\n    }\n}\nint N, M, Q, v;\n\nint main(){\n\n    memset(par,-1,sizeof(par));\n\n    scanf(\"%d\",&N);\n    for (int u=0; u<N; u++){\n        scanf(\"%d\",&M);\n\n        for (int i=0; i<M; i++){\n            scanf(\"%d\",&v);\n\n            par[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    int root;\n    for (int i=0; i<N; i++) if (par[i] == -1) root = i;\n    \n    dfs(root,0);\n\n    SparseTable st(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i=0; i<Q; i++){\n        int u, v, l, r;\n        scanf(\"%d%d\",&u,&v);\n\n        l = idx[u];\n        r = idx[v];\n        if (l > r) swap(l,r);\n\n        int id = st.query(l,r);\n        printf(\"%d\\n\",path[id]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,-1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs=vector<int>(1,0)) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int,int>;\n    stack<T> st;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v=st.top().first;\n      int &i=st.top().second;\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tint res=0;\n\tfor(int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if (vid[u] > vid[v]) swap(u, v);\n      f(max(vid[head[v]], vid[u]), vid[v]);\n      if (head[u] != head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] != head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/11/07\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n/*\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned main(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/11/07\nhttps://yukicoder.me/problems/no/529\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\nstruct Edge{\n    int to,id;\n    ll dist;\n    Edge(int to,ll dist=1,int id=0):to(to),dist(dist),id(id){}\n};\n\nstruct HeavyLightDecomposition{\n    vector<vector<Edge>> g;\n    vector<int> in,out,head,par,dep,sz;\n    int times;\n    int root;\n\n    HeavyLightDecomposition(int V,vector<vector<Edge>> &G):\n        g(G),in(V),out(V),head(V),par(V),dep(V),sz(V){\n            root=0;\n            times=0;\n            sz_dfs(root,-1);\n            hld_dfs(root,-1);\n        }\n    \n    void sz_dfs(int now,int p){\n        par[now]=p;\n        sz[now]=1;\n        if(p==-1) dep[now]=0;\n        else dep[now]=dep[p]+1;\n\n        for(auto &e:g[now]){\n            if(e.to==p) continue;\n            sz_dfs(e.to,now);\n            sz[now]+=sz[e.to];\n            if(sz[e.to]>sz[g[now][0].to]) swap(e,g[now][0]);\n        }\n    }\n\n    void hld_dfs(int now,int p){\n        in[now]=times++;\n        for(auto e:g[now]){\n            if(e.to==p) continue;\n            head[e.to]=(e.to == g[now][0].to ? head[now] : e.to);\n            hld_dfs(e.to,now);\n        }\n        out[now]=times;\n    }\n\n    int lca(int u,int v){\n        for(;;v=par[head[v]]){\n            if(in[u]>in[v]) swap(u,v);\n            if(head[u]==head[v]) return u;\n        }\n    }\n\n    int distance(int u,int v){\n        return dep[u]+dep[v]-2*dep[lca(u,v)];\n    }\n};\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N;\n  cin>>N;\n  vector<vector<Edge>> g(N);\n  rep(i,N){\n      int K;cin>>K;\n      rep(j,K){\n          int a;cin>>a;\n          g[i].push_back(a);\n      }\n  }\n\n  HeavyLightDecomposition hld(N,g);\n\n  int Q;\n  cin>>Q;\n  rep(i,Q){\n      int a,b;\n      cin>>a>>b;\n      cout<<hld.lca(a,b)<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathRoot;\n  vector<vector<int> > tree;\n\n  HeavyLight(vector<vector<int> > t)\n    :pathCount(0),n(t.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathRoot(n),tree(t){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    return a;\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nusing Weight = int;\nstruct Edge {\n\tint s, d; Weight w;\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//lowest common ancestor (??????????????° + dfs????????°)\n//?§????O(NlogN) ?????¨???O(logN)\nstruct LowestCommonAncestor {\n\tconst Graph &g;\n\tint root;\n\tconst int n, log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\tLowestCommonAncestor(const Graph &g, int root)\n\t\t:g(g), root(root), n(g.size()), log2_n(log2(n) + 1), parent(log2_n, vector<int>(n)), depth(n) {\n\t\tdfs();\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs() {\n\t\tusing State = tuple<int, int, int>;\n\t\tstack<State> st; st.emplace(root, -1, 0);\n\t\twhile (st.size()) {\n\t\t\tint s, p, d;\n\t\t\ttie(s, p, d) = st.top(); st.pop();\n\t\t\tparent[0][s] = p;\n\t\t\tdepth[s] = d;\n\t\t\tfor (auto &e : g[s]) {\n\t\t\t\tif (e.d == p)continue;\n\t\t\t\tst.emplace(e.d, s, d + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tGraph g(n);\n\trep(i, 0, n) {\n\t\tint k; cin >> k;\n\t\trep(j, 0, k) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(i, c);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tLowestCommonAncestor lca(g, 0);\n\trep(i, 0, q) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << lca.get(u, v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#include <boost/multiprecision/cpp_int.hpp>\n//using multiInt = boost::multiprecision::cpp_int;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconst int MOD_TYPE = 1;\nconst ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\nconst int INF = (int)1e9;\nconst ll LINF = (ll)4e18;\nconst double PI = acos(-1.0);\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << endl\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << endl\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << endl;\n\nvector<int> Dx = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nvector<int> Dy = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\nstruct Tree\n{\n  const static int MAX_V = 100010;\n  vector<int> E[MAX_V];\n  int par[MAX_V];\n  vector<int> ch[MAX_V];\n  int depth[MAX_V];\n\n  void dfs(int p, int d, bool make_ch)\n  {\n    for (auto v : E[p])\n    {\n      if (par[v] != -2)\n        continue;\n      par[v] = p;\n      depth[v] = d + 1;\n      if (make_ch)\n        ch[p].push_back(v);\n      dfs(v, d + 1, make_ch);\n    }\n  }\n\n  void make_tree(int root = 0, bool make_ch = false)\n  {\n    fill(par, par + MAX_V, -2);\n    par[root] = -1;\n    depth[root] = 0;\n    dfs(root, 0, make_ch);\n  }\n\n  int par_double[MAX_V][25]; //頂点iの2^k個上の頂点\n  bool calculated = false;\n  void calc_double()\n  {\n    for (int i = 0; i < MAX_V; i++)\n      par_double[i][0] = (par[i] < 0 ? -1 : par[i]);\n\n    for (int k = 0; k < 24; k++)\n    {\n      for (int i = 0; i < MAX_V; i++)\n      {\n        if (par_double[i][k] == -1)\n          par_double[i][k + 1] = -1;\n        else\n          par_double[i][k + 1] = par_double[par_double[i][k]][k];\n      }\n    }\n  }\n\n  int getLCA(int a, int b)\n  {\n    if (!calculated)\n    {\n      calc_double();\n      calculated = true;\n    }\n\n    if (a == b)\n      return a;\n\n    if (depth[a] < depth[b])\n      swap(a, b);\n\n    for (int k = 24; k >= 0; k--)\n    {\n      if (par_double[a][k] != -1 && depth[par_double[a][k]] >= depth[b])\n      {\n        a = par_double[a][k];\n      }\n    }\n\n    if (a == b)\n      return a;\n\n    for (int k = 24; k >= 0; k--)\n    {\n      if (par_double[a][k] != -1 && par_double[a][k] != par_double[b][k])\n      {\n        a = par_double[a][k];\n        b = par_double[b][k];\n      }\n    }\n    return par_double[a][0];\n  }\n\n  inline int length(int a, int b)\n  {\n    return depth[a] + depth[b] - 2 * depth[getLCA(a, b)];\n  }\n};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(50) << setiosflags(ios::fixed);\n\n  int n;\n  cin >> n;\n  Tree tr;\n  rep(i, n)\n  {\n    int k;\n    cin >> k;\n    rep(j, k)\n    {\n      int c;\n      cin >> c;\n      tr.E[i].push_back(c);\n      tr.E[c].push_back(i);\n    }\n  }\n\n  tr.make_tree(0);\n  int q;\n  cin >> q;\n  rep(qi, q)\n  {\n    int u, v;\n    cin >> u >> v;\n    cout << tr.getLCA(u, v) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return (node_[vl] < node_[vr] ? left_child(k) : right_child(k));\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    std::vector<Node> node_;\n};\n//*/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n\n    RangeMinimumQuery rmq(n);\n    for(int i = 0; i < n; ++i) rmq.update(i, t.depth(i));\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n//         cout << t.lowest_common_ancestor(u, v) << endl;\n//         cout << rmq.find(u, v) << endl;\n        cout << rmq.find_index(u, v) - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// RMQ\n#include<vector>\n#include<climits>\n#include<cassert>\nconst int INF = INT_MAX;\nclass RangeMinimumQuery {\npublic:\n  explicit RangeMinimumQuery(int s);\n  void update(int i, int v);\n  int index(int left, int right) const;\n  int value(int left, int right) const;\nprivate:\n  int parent(int node) const;\n  int left_child(int node) const;\n  int right_child(int node) const;\n  int power_of_two(int n) const;\n  int query(int left, int right, int node, int node_left, int node_right) const;\n  int size_, nil_, inf_;\n  std::vector<int> index_, value_;\n};\nRangeMinimumQuery::RangeMinimumQuery(int s) : size_(power_of_two(s)), nil_(size_), inf_(INF), index_(2 * size_ - 1, nil_), value_(size_ + 1, inf_) {}\nvoid RangeMinimumQuery::update(int i, int v) {\n  int node = i + size_ - 1;\n  index_.at(node) = i;\n  value_.at(i) = v;\n  while((node = parent(node)) != nil_) {\n    int l = value_.at(index_.at(left_child(node)));\n    int r = value_.at(index_.at(right_child(node)));\n    index_.at(node) = index_.at(l <= r ? left_child(node) : right_child(node));\n  }\n}\nint RangeMinimumQuery::index(int left, int right) const {\n  return query(left, right, 0, 0, size_ - 1);\n}\nint RangeMinimumQuery::value(int left, int right) const {\n  return value_.at(query(left, right, 0, 0, size_ - 1));\n}\nint RangeMinimumQuery::parent(int node) const {return node ? (node - 1) / 2 : nil_;}\nint RangeMinimumQuery::left_child(int node) const {return 2 * node + 1;}\nint RangeMinimumQuery::right_child(int node) const {return 2 * node + 2;}\nint RangeMinimumQuery::power_of_two(int n) const {\n  while(n & (n - 1)) n += n & -n;\n  return n;\n}\nint RangeMinimumQuery::query(int left, int right, int node, int node_left, int node_right) const {\n  assert(left <= right);\n  assert(0 <= left);\n  assert(right < size_);\n  if(node_right < left || right < node_left) return nil_;\n  if(left <= node_left && node_right <= right) return index_.at(node);\n  int middle = (node_left + node_right) / 2;\n  int l = query(left, right, left_child(node), node_left, middle);\n  int r = query(left, right, right_child(node), middle + 1, node_right);\n  return value_.at(l) <= value_.at(r) ? l : r;\n}\n\n// Graph: Adjacency list\n#include<vector>\ntypedef std::vector<std::vector<int>> Graph;\n\n// LCA\n#include<vector>\n#include<utility>\n#include<memory>\nclass LowestCommonAncestor {\npublic:\n  explicit LowestCommonAncestor(const Graph& g) : id_(g.size()) {\n    dfs(g, 0, 0);\n    RMQ_ = std::unique_ptr<RangeMinimumQuery>(new RangeMinimumQuery(depth_.size()));\n    for(int i = 0; i < depth_.size(); ++i) RMQ_->update(i, depth_.at(i));\n  }\n  int find(int u, int v) const {\n    if(id_.at(u) > id_.at(v)) std::swap(u, v);\n    return vs_.at(RMQ_->index(id_.at(u), id_.at(v)));\n  }\nprivate:\n  void dfs(const Graph& g, int current, int depth) {\n    id_.at(current) = vs_.size();\n    vs_.push_back(current);\n    depth_.push_back(depth);\n    for(const auto& next: g.at(current)) {\n      dfs(g, next, depth + 1);\n      vs_.push_back(current);\n      depth_.push_back(depth);\n    }\n  }\n  std::vector<int> id_, vs_, depth_;\n  std::unique_ptr<RangeMinimumQuery> RMQ_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n\n  Graph g(n);\n  for(auto& list: g) {\n    int k;\n    cin >> k;\n    list.resize(k);\n    for(auto& c: list) cin >> c;\n  }\n\n  LowestCommonAncestor lca(g);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca.find(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define POWER9 1000000000\n#define MOD POWER9+7\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n#define LLONG_MAX 9223372036854775807LL\n\n//RMQ セグメント木\nstruct SegmentTree{\nprivate:\n\tint n;\n\tvector<long long> nodes;\npublic:\n\tvoid init(int N){ //初期化する O(N)\n\t\tnodes.clear();\n\t\tn = 1;\n\t\twhile(n < N) n *= 2;\n\t\tn = 2 * n -1;\n\t\tfor(int i=0; i<n; i++) nodes.push_back(LLONG_MAX);\n\t}\n\tvoid update(int i, long long x){ //値を変更する O(log N)\n\t\ti += n / 2;\n\t\tnodes[i] = x;\n\t\twhile(i > 0){\n\t\t\ti = (i-1)/2; //親の取得は(i-1)/2\n\t\t\tnodes[i] = min(nodes[i*2+1], nodes[i*2+2]); //子の取得はi*2+1,i*2+2\n\t\t}\n\t}\n\tlong long minimum(int a, int b){ //[a,b)の最小値を求める O(log N)\n\t\treturn query(a, b, 0, 0, n/2+1);\n\t}\n\tlong long query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return LLONG_MAX; //交差する場合\n\t\tif(a <= l && r <= b) return nodes[k]; //完全に含む場合\n\t\tlong long valueL = query(a, b, k*2+1, l, (l+r)/2);\n\t\tlong long valueR = query(a, b, k*2+2, (l+r)/2, r);\n\t\treturn min(valueL, valueR);\n\t}\n\tlong long m;\n\tlong long find(int a, int b, int k=0, int l=0, int r=-1){\n\t\tif(r == -1){\n\t\t\tm = minimum(a, b);\n\t\t\tr = (n+1)/2;\n\t\t}\n\t\tif(r <= a || b <= l) return LLONG_MAX; //交差する場合\n\t\tif(r-l == 1){\n\t\t\tif(nodes[k] == m) return l;\n\t\t\telse return LLONG_MAX;\n\t\t}\n\t\tif(a <= l && r <= b){ //完全に含む場合\n\t\t\tlong long valueL = query(a, b, k*2+1, l, (l+r)/2);\n\t\t\tlong long valueR = query(a, b, k*2+2, (l+r)/2, r);\n\t\t\tif(valueL <= valueR) return find(a, b, k*2+1, l, (l+r)/2);\n\t\t\telse return find(a, b, k*2+2, (l+r)/2, r);\n\t\t}\n\t\tlong long valueL = find(a, b, k*2+1, l, (l+r)/2);\n\t\tlong long valueR = find(a, b, k*2+2, (l+r)/2, r);\n\t\treturn min(valueL, valueR);\n\t}\n};\n\nint n;\nvector<int> c[100000];\nint par[100000];\nint q;\n\nint d[100000] = {};\nint depth(int now){\n\tif(par[now] == now) return 0;\n\tif(d[now] != 0) return d[now];\n\treturn d[now] = 1 + depth(par[now]);\n}\n\nvector<int> order;\nbool already[100000] = {};\nint pre[100000];\nvoid dfs(int now){\n\tpre[now] = order.size();\n\torder.push_back(now);\n\tfor(int i=0; i<c[now].size(); i++){\n\t\tif(already[c[now][i]]) continue;\n\t\talready[c[now][i]] = true;\n\t\tdfs(c[now][i]);\n\t\torder.push_back(now);\n\t}\n}\n\nSegmentTree st;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << setprecision(9);\n\n\tcin >> n;\n\tfor(int i=0; i<n; i++) par[i] = i;\n\tfor(int i=0; i<n; i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0; j<k; j++){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\tc[i].push_back(tmp);\n\t\t\tpar[tmp] = i;\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++) depth(i);\n\tfor(int i=0; i<n; i++){\n\t\tif(already[i]) continue;\n\t\talready[i] = true;\n\t\tdfs(i);\n\t}\n\n\t/*for(int i=0; i<n; i++) cout << d[i] << \" \";\n\tcout << endl;\n\tfor(int i=0; i<order.size(); i++) cout << order[i] << \" \";\n\tcout << endl;\n\tfor(int i=0; i<n; i++) cout << pre[i] << \" \";\n\tcout << endl;*/\n\n\tst.init(order.size());\n\tfor(int i=0; i<order.size(); i++) st.update(i, d[order[i]]);\n\tcin >> q;\n\tfor(int i=0; i<q; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tif(pre[b] < pre[a]) swap(a, b);\n\t\t//cout << st.find(pre[a],pre[b]+1) << endl;\n\t\tcout << order[st.find(pre[a],pre[b]+1)] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nstruct LCA{\n    int n, bit; // n < 1<<bit\n    vector<int> depth;\n    vector<vector<int>> par, v;\n\n    LCA(int n) : n(n){\n        depth.resize(n, -1);\n        bit = 0;\n        while(1<<bit <= n)  bit++;\n        par.resize(bit);\n        for(int i = 0; i < bit; i++)    par[i].resize(n);\n        v.resize(n);\n    }\n\n    void add_edge(int a, int b){\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    void dfs(int now, int p, int d){\n        par[0][now] = p;\n        depth[now] = d;\n        for(int child : v[now]){\n            if(child == p)  continue;\n            dfs(child, now, d+1);\n        }\n    }\n\n    void build(){\n        for(int i = 0; i < n; i++){\n            if(depth[i] == -1)    dfs(i, -1, 0);\n        }\n        for(int k = 0; k+1 < bit; k++){\n            for(int i = 0; i < n; i++){\n                if(par[k][i] < 0)   par[k+1][i] = -1;\n                else                par[k+1][i] = par[k][par[k][i]];\n            }\n        }\n    }\n\n    int lca(int a, int b){\n        // make b deeper\n        if(depth[a] > depth[b]) swap(a, b);\n        for(int k = 0; k < 30; k++){\n            // depth(b)-depth(a) is equal to or bigger than 2^k\n            if(((depth[b]-depth[a])>>k)&1){\n                b = par[k][b];\n            }\n        }\n        if(a == b)  return a;\n        for(int k = bit-1; k >= 0; k--){\n            if(par[k][a] != par[k][b]){\n                a = par[k][a];\n                b = par[k][b];\n            }\n        }\n        return par[0][a];\n    }\n};\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    LCA l(n);\n    for(int i = 0; i < n; i++){\n        int k;\n        scanf(\"%d\", &k);\n        while(k--){\n            int x;  scanf(\"%d\", &x);\n            l.add_edge(i, x);\n        }\n    }\n    l.build();\n    int q;\n    scanf(\"%d\", &q);\n    while(q--){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        printf(\"%d\\n\", l.lca(u,v));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<vector>\n#include<cmath>\n#include<utility>\n\ntemplate<typename Label>\nclass RootedTree {\npublic:\n  RootedTree(const Label& root) : root_(root) {}\n  void add(const Label& p, const Label& c) {child_[p].push_back(c);}\n  void init() {init(root_, 0);}\n  Label lca(Label u, Label v) {\n    // u, v を同じ深さにする O(log(深さの差))\n    if(depth_[v] < depth_[u]) std::swap(u, v);\n    int difference = depth_[v] - depth_[u];\n    for(int i = 1; i <= difference; i <<= 1)\n      if(difference & i)\n        v = parent_[v][i];\n    // lca を求める O(log(深さ))\n    if(u == v) return u;\n    int bits = log2(depth_[u]);\n    for(int i = bits << 1; 0 < i; i >>= 1) {\n      if(parent_[u][i] == parent_[v][i]) continue;\n      u = parent_[u][i];\n      v = parent_[v][i];\n    }\n    return parent_[u][1];\n  }\nprivate:\n  void init(const Label& current, int depth) {\n    depth_[current] = depth;\n    for(int i = 2; i <= depth; i <<= 1) parent_[current][i] = parent_[parent_[current][i >> 1]][i >> 1];\n    for(const auto& v: child_[current]) {\n      parent_[v][1] = current;\n      init(v, depth + 1);\n    }\n  }\n  Label root_;\n  std::unordered_map<Label, int> depth_;\n  std::unordered_map<Label, std::vector<Label>> child_;\n  std::unordered_map<Label, std::unordered_map<int, Label>> parent_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  RootedTree<int> t(0);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      t.add(i, c);\n    }\n  }\n  t.init();\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << t.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) // cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Graph = vector<vector<Edge>>;\n\nclass lca {\npublic:\n  int n;\n  int log2_n;\n  vector<vector<int>> parent;\n  vector<int> depth;\n\n  lca() {}\n\n  lca(const Graph &g, int root)\n      : n(g.size()), log2_n(log2(n) + 2), parent(log2_n, vector<int>(n)),\n        depth(n) {\n    dfs(g, root, -1, 0);\n    for (int k = 0; k + 1 < log2_n; k++) {\n      for (int v = 0; v < (int)g.size(); v++) {\n        if (parent[k][v] < 0)\n          parent[k + 1][v] = -1;\n        else\n          parent[k + 1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n\n  void dfs(const Graph &g, int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (auto &e : g[v]) {\n      if (e.dst != p)\n        dfs(g, e.dst, v, d + 1);\n    }\n  }\n\n  int get(int u, int v) {\n    if (depth[u] > depth[v])\n      swap(u, v);\n    for (int k = 0; k < log2_n; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    if (u == v)\n      return u;\n    for (int k = log2_n - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nconst int B = 300;\n\nint N, Q;\nGraph g;\nvector<tuple<int, int, int, int>> query;\n\nint dist[100010];\nvector<pair<int, int>> add_at[100010];\nvector<int> stk;\n\nvoid make_dist(int v, int p, int s) {\n  dist[v] = s;\n  for (auto &e : g[v]) {\n    if (e.dst != p) {\n      make_dist(e.dst, v, dist[v] + e.weight);\n    }\n  }\n}\n\nvoid add_many(int v, int p) {\n  for (auto &aq : add_at[v]) {\n    int k = aq.first;\n    int x = aq.second;\n    if (k < (int)stk.size())\n      stk.rbegin()[k] += x;\n  }\n\n  int add = stk.back();\n  stk.pop_back();\n  for (auto &e : g[v]) {\n    if (e.dst != p) {\n      e.weight += add;\n      add_many(e.dst, v);\n    }\n  }\n  stk.push_back(add);\n\n  for (auto &aq : add_at[v]) {\n    int k = aq.first;\n    int x = aq.second;\n    if (k < (int)stk.size())\n      stk.rbegin()[k] -= x;\n  }\n}\n\nsigned main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    Graph g(n);\n    rep(i, n){\n        int k;\n        cin >> k;\n        rep(j, k){\n            int c;\n            cin >> c;\n            g[i].emplace_back(i, c, 1);\n        }\n    }\n    lca l(g, 0);\n    int q;\n    cin >> q;\n    rep(i, q){\n        int u, v;\n        cin >> u >> v;\n        cout << l.get(u, v) << '\\n';\n    }\n}\n\n// signed main() {\n//   ios::sync_with_stdio(0);\n//   cin.tie(0);\n\n//   cin >> N;\n//   g.assign(N, {});\n//   for (int i = 0; i < N - 1; i++) {\n//     int a, b, c;\n//     cin >> a >> b >> c;\n//     --a;\n//     --b;\n//     g[a].emplace_back(a, b, c);\n//     g[b].emplace_back(b, a, c);\n//   }\n\n//   lca lc(g, 0);\n\n//   cin >> Q;\n//   query.resize(Q);\n//   for (auto &q : query) {\n//     int t;\n//     cin >> t;\n//     if (t == 1) {\n//       int v, k, x;\n//       cin >> v >> k >> x;\n//       --v;\n//       --k;\n//       q = make_tuple(t, v, k, x);\n//     } else {\n//       int u, v;\n//       cin >> u >> v;\n//       --u;\n//       --v;\n//       q = make_tuple(t, u, v, -1);\n//     }\n//   }\n\n//   for (int i = 0; i < Q; i += B) {\n//     make_dist(0, -1, 0);\n\n//     int left = i, right = min(Q, i + B);\n\n//     for (int j = left; j < right; ++j) {\n//       int t, u, v;\n//       tie(t, u, v, ignore) = query[j];\n//       if (t == 2) {\n//         int add = 0;\n//         for (auto &path_v : {u, v}) {\n//           for (int jj = left; jj < j; ++jj) {\n//             int tt, add_v, k, x;\n//             tie(tt, add_v, k, x) = query[jj];\n//             if (tt == 1 && lc.get(add_v, path_v) == add_v &&\n//                 lc.depth[path_v] > lc.depth[add_v] + k) {\n//               add += x;\n//             }\n//           }\n//         }\n//         dump(add);\n//         int l = lc.get(u, v);\n//         cout << dist[u] + dist[v] - 2 * dist[l] + add << '\\n';\n//       }\n//     }\n\n//     for (int j = left; j < right; ++j) {\n//       int t, v, k, x;\n//       tie(t, v, k, x) = query[j];\n//       if (t == 1)\n//         add_at[v].push_back(make_pair(k, x));\n//     }\n//     stk.assign(N, 0);\n//     add_many(0, -1);\n//   }\n// }"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nstruct LCA {\nprivate:\n\tint n;\n\tvector<vector<int>>g;\n\tint root;\n\tvector<int>depth;\n\tvector<vector<int>>par;\npublic:\n\n\tvoid dfs(int v, int p, int d) {\n\t\tpar[v][0] = p;\n\t\tdepth[v] = d;\n\t\tfor (int i = 0; i<g[v].size(); i++) {\n\t\t\tif (g[v][i] == p)continue;\n\t\t\tdfs(g[v][i], v, d + 1);\n\t\t}\n\t}\n\n\tLCA(int N,vector<int>* G,int Root) {\n\t\tn = N;\n\t\tg.resize(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\tg[i].emplace_back(G[i][j]);\n\t\t\t}\n\t\t}\n\t\tdepth.resize(N);\n\t\tpar.resize(N);\n\t\tfor (int i = 0; i < N; i++)par[i].resize(31);\n\t\troot = Root;\n\t\tdfs(root, -1, 0);\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (par[j][i] == -1)par[j][i + 1] = -1;\n\t\t\t\telse par[j][i + 1] = par[par[j][i]][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 30; i >= 0; i--) {\n\t\t\tif (((depth[v] - depth[u]) >> i) & 1) {\n\t\t\t\tv = par[v][i];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\n\t\tfor (int i = 30; i >= 0; i--) {\n\t\t\tif (par[u][i] != par[v][i]) {\n\t\t\t\tu = par[u][i];\n\t\t\t\tv = par[v][i];\n\t\t\t}\n\t\t}\n\t\treturn par[u][0];\n\t}\n};\n\nint n;\nvector<int> g[101010];\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tg[i].emplace_back(c);\n\t\t\tg[c].emplace_back(i);\n\t\t}\n\t}\n\tLCA lca(n, g, 0);\n\tint q;\n\tcin >> q;\n\tREP(qqq, q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.get(u, v) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <map>\n#include <math.h>\n#include <string.h>\n#include <iomanip>\n#include <numeric>\n#include <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <functional>\n#include <limits>\n#include <cassert>\n\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\nusing vl = vector<ll>;\nusing vll = vector<vl>;\nusing vpll = vector<pll>;\n\nvoid debug_out() { cout << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cout << H << \" \";\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cout << \"debug: \"; debug_out(__VA_ARGS__)\n#else\n#define debug(...) \n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define Rep(i, n) for (long long i = 0; i< (long long)(n); i++)\n#define RRep(i,n) for (long long i = ((long long)(n)-1); i>=0; i--)\n#define all(v) (v).begin(),(v).end()\n\nstruct Edge{\n    int to;\n    int weight;\n    Edge(int t, int w) : to(t), weight(w){ }\n};\n\nstruct edge{\n    int from;\n    int to;\n    int weight;\n    edge(int f,int t,int w) : from(f), to(t), weight(w){ }\n};\n\n\nusing Graph = vector<vector<Edge>>;\nusing graph = vector<vector<int>>;\nusing edges = vector<edge>;\n\ntemplate <class T>\ninline bool chmin(T &a, T b){\n    if (a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T>\ninline bool chmax(T &a, T b){\n    if (a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T>\nT gcd(T a, T b){\n    if( b==0 ) return a;\n    return gcd(b, a%b);\n}\n\ntemplate <class T>\nT lcm(T a, T b){\n    return (a*b)/gcd(a,b);\n}\n\nbool isPalindrome(string s){\n    string t = s;\n    reverse(all(t));\n    return s==t;\n}\n\nconstexpr int INF = 1e9+7;\n\nvector<int> dx = {-1,0,1,0};\nvector<int> dy = {0,-1,0,1};\n\nstruct LCA{\n    int n,log_n;\n    graph g;\n    vector<bool> used;\n    vector<int> depth;\n    vector<vector<int>> parent;\n\n    LCA(int n) : n(n), log_n(1), g(n), used(n,false), depth(n,0) { }\n\n    void addEdge(int a,int b){\n        g[a].emplace_back(b);\n        g[b].emplace_back(a);\n    }\n\n    void dfs(int v,int p,int d){\n        used[v] = true;\n        parent[0][v] = p;\n        depth[v] = d;\n        for(auto next_v: g[v]){\n            if(!used[next_v]) dfs(next_v,v,d+1);\n        }\n    }\n\n    void init(){\n        while((1<<log_n)<n){\n            log_n++;\n        }\n        parent.resize(log_n);\n        for(int i=0; i<log_n; i++){\n            parent[i].resize(n);\n        }\n        dfs(0,-1,0);\n        for(int k = 0; k<log_n-1; k++){\n            for(int v = 0; v<n; v++){\n                if(parent[k][v]==-1) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        if(depth[u]>depth[v]) swap(u,v);\n        for(int k = 0; k<log_n; k++){\n            if((depth[v]-depth[u])>>k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u==v) return u;\n        for(int k = log_n-1; k>=0; k--){\n            if(parent[k][u]!=parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    LCA l(n);\n    rep(i,n){\n        int k; cin >> k;\n        rep(j,k){\n            int c; cin >> c;\n            l.addEdge(i,c);\n        }\n    }\n    l.init();\n    int q; cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << l.lca(u,v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n\nusing namespace std;\n\nconst int sz = 1e5 + 13;\nconst int logsz = 10;\n\nint n;\n\nint p[sz][logsz];\nint t[sz], level[sz];\n\nvector<vector<int> > g (sz);\n\nvoid dfs(int u, int parent){\n    for(auto v: g[u]){\n        if(v != parent){\n            level[v] = level[u] + 1;\n            t[v] = u;\n            dfs(v, u);\n        }\n    }\n}\n\nvoid preprocess(){\n    t[0] = -1;\n    dfs(0, -1);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; (1<<j) < n; ++j)\n            p[i][j] = -1;\n    for(int i = 0; i < n; ++i)\n        p[i][0] = t[i];\n    for(int j = 1; (1<<j) < n; ++j)\n        for(int i = 0; i < n; ++i) if(p[i][j-1] != -1)\n            p[i][j] = p[p[i][j-1]][j-1];\n}\n\nint lca(int u, int v){\n    if(level[u] < level[v]){u ^= v; v ^= u; u ^= v;}\n    int log;\n    for(log = 1; (1<<log) < level[u]; ++log);\n    log--;\n    for(int i = log; i >= 0; --i)\n        if(level[u]  - (1<< i) >= level[v])\n            u = p[u][i];\n    if(u == v)\n        return u;\n    for(int i = log; i>= 0; --i)\n        if(p[u][i] != -1 && p[u][i] != p[v][i]){\n            u = p[u][i]; v = p[v][i];\n        }\n    return t[u];\n}\n\n\nint main(){\n    cin>>n;\n    for(int i = 0; i < n; ++i){\n        int k;\n        cin>>k;\n        for(int j = 0; j < k; ++j){\n            int x;\n            cin>>x;\n            g[i].push_back(x);\n            g[x].push_back(i);\n        }\n    }\n    preprocess();\n    int q;\n    cin>>q;\n    for(int i = 0; i < q; ++i){\n        int u,v;\n        cin>>u>>v;\n        cout<<lca(u,v)<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n//#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n//#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> T sum(vector<T> &v, int s = 0, int t = inf) {\n    T ret = 0;\n    rep(i, s, min(sz(v), t))ret += v[i];\n    return ret;\n}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    return ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    return ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &m) {\n    for (auto &&v:m) os << v << \" \";\n    return os;\n}\nconstexpr bool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\n\n//@formatter:off\ntemplate<class T> struct edge { int f, t; T c; int id; int ty; edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), ty(ty) {} bool operator<(const edge &b) const { return c < b.c; } bool operator>(const edge &b) const { return c > b.c; }};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {    os << e.f << \" \" << e.t << \" \" << e.c;    return os;}\ntemplate<typename T> class graph {protected:    vector<bool> usedv;public :    vector<vector<edge<T>>> g;    vector<edge<T>> edges;    int n;    graph(int n) : n(n) { g.resize(n), usedv.resize(n); }    void clear() { g.clear(), edges.clear(); }    void resize(int n) {        this->n = n;        g.resize(n);        usedv.resize(n);    }    int size() { return g.size(); }    vector<edge<T> > &operator[](int i) { return g[i]; }    virtual void add(int f, int t, T c, int ty ,int id) = 0;    virtual bool used(edge<T> &e) = 0;    virtual bool used(int id) = 0;    virtual void del(edge<T> &e) = 0;    virtual void del(int id) = 0;    virtual void set_edges() = 0;};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::usedv;\n    int eid = 0;\n    undigraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1,  int ty = -1,int id = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid, eid += 2;\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n        edges.emplace_back(f, t, c, id, ty);\n        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {        int f = e.f, t = e.t, ty = e.ty;        T c = e.c;        add(f, t, c, ty);    }\n    bool used(edge<T> &e) { return usedv[e.id]; }\n    bool used(int id) { return usedv[id]; }\n    void del(edge<T> &e) { usedv[e.id] = usedv[e.id ^ 1] = 1; }\n    void del(int id) { usedv[id] = usedv[id ^ 1] = 1; }\n    void set_edges() {        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\n\ntemplate<class T>\nclass MinOp{\npublic:\n    T operator () ( T a , T b ){ return min( a , b ); }\n};\n\n// sparse table\n// static range semigroup query\n// time complexity: <O(n log n), O(1)>\n// OpFunc is binary operator: T x T -> T\ntemplate<typename T, typename OpFunc>\nstruct SparseTable{\n    OpFunc op;\n    int size;\n    vector<int> lg;\n    vector<vector<T> > table;\n    void init( const vector<T> &array, OpFunc opfunc ){\n        int n = array.size();\n        op = opfunc;\n\n        lg.assign( n + 1 , 0 );\n        for( int i = 1; i <= n; i++ ){\n            lg[i] = 31 - __builtin_clz( i );\n        }\n\n        table.assign( lg[n] + 1, array );\n        for( int i = 1; i <= lg[n]; i++ ){\n            for( int j = 0; j < n; j++ ){\n                if( j + (1<<(i-1)) < n ){\n                    table[i][j] = op( table[i-1][j] , table[i-1][j+(1<<(i-1))] );\n                } else {\n                    table[i][j] = table[i-1][j];\n                }\n            }\n        }\n    }\n    T query( int l , int r ){\n        assert( l < r );\n        return op( table[ lg[r-l] ][l], table[ lg[r-l] ][r-(1<<lg[r-l])] );\n    }\n};\n\n\n// plus minus one Range Minimum Query\n// time complexity: <O(n), O(1)>\nstruct PMORMQ{\n    vector<int> a;\n    SparseTable<pair<int,int>,MinOp<pair<int,int> > > sparse_table;\n    vector<vector<vector<int> > > lookup_table;\n    vector<int> block_type;\n    int block_size, n_block;\n    void init( const vector<int> &array ){\n        a = array;\n        int n = a.size();\n        block_size = max( 1, ( 31 - __builtin_clz( n ) ) / 2 );\n        while( n % block_size != 0 ){\n            a.push_back( a.back() + 1 );\n            n++;\n        }\n        n_block = n / block_size;\n\n        vector<pair<int,int> > b( n_block, make_pair( INT_MAX, INT_MAX ) );\n        for( int i = 0; i < n; i++ ){\n            b[i/block_size] = min( b[i/block_size], make_pair( a[i], i ) );\n        }\n        sparse_table.init( b, MinOp<pair<int,int> >() );\n\n        block_type.assign( n_block, 0 );\n        for( int i = 0; i < n_block; i++ ){\n            int cur = 0;\n            for( int j = 0; j < block_size-1; j++ ){\n                int ind = i * block_size + j;\n                if( a[ind] < a[ind+1] ){\n                    cur |= 1 << j;\n                }\n            }\n            block_type[i] = cur;\n        }\n\n        lookup_table.assign( 1 << (block_size-1), vector<vector<int> >( block_size, vector<int>( block_size+1 ) ) );\n        for( int i = 0; i < (1<<(block_size-1)); i++ ){\n            for( int j = 0; j < block_size; j++ ){\n                int res = 0;\n                int cur = 0;\n                int pos = j;\n                for( int k = j+1; k <= block_size; k++ ){\n                    lookup_table[i][j][k] = pos;\n                    if( i & ( 1 << (k-1) ) ){\n                        cur++;\n                    } else {\n                        cur--;\n                    }\n                    if( res > cur ){\n                        pos = k;\n                        res = cur;\n                    }\n                }\n            }\n        }\n    }\n    int query( int l, int r ){ // return position\n        assert( l < r );\n        int lb = l / block_size;\n        int rb = r / block_size;\n        if( lb == rb ){\n            return lb * block_size + lookup_table[ block_type[lb] ][ l % block_size ][ r % block_size ];\n        }\n        int pl = lb * block_size + lookup_table[ block_type[lb] ][ l % block_size ][ block_size ];\n        int pr = rb * block_size + lookup_table[ block_type[rb] ][0][ r % block_size ];\n        int pos = pl;\n        if( r % block_size > 0 && a[pl] > a[pr] ){\n            pos = pr;\n        }\n        if( lb + 1 == rb ){\n            return pos;\n        }\n        int sp = sparse_table.query( lb+1, rb ).second;\n        if( a[pos] > a[sp] ){\n            return sp;\n        }\n        return pos;\n    }\n};\n// LCA\n// time complexity: <O(n), O(1)>\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;    using undigraph<T>::n;    using undigraph<T>::edges;    using undigraph<T>::usedv;\n\n    PMORMQ rmq;\n    int cnt;\n    vector<int> depth,disv, id, in;\n    int root;\n    bool never=true;\n    tree(int n_, int root = 0) : undigraph<T>(n_), root(root) {\n        n=n_;\n    }\n    void dfs( int x , int p , int d ,int dis =0){\n        id[cnt] = x;\n        depth.push_back( d );\n        disv[x]=dis;\n        in[x] = cnt++;\n        forg(gi, g[x]){\n            if( t == p ){\n                continue;\n            }\n            dfs( t , x , d+1 ,dis+c);\n            id[cnt] = x;\n            depth.push_back( d );\n            cnt++;\n        }\n    }\n    void precalc( ){\n        never = false;\n        cnt = 0;\n        depth.clear();\n        disv.assign(n,0);\n        in.assign( n, -1 );\n        id.assign( 2*n-1, -1 );\n        dfs( root, -1, 0 );\n        rmq.init( depth );\n    }\n    int lca( int a , int b ){\n        if(never)precalc();\n        int x = in[a];\n        int y = in[b];\n        if( x > y ){\n            swap( x , y );\n        }\n        int pos = rmq.query( x, y + 1 );\n        return id[pos];\n    }\n};\ntree <> g(k5);\n\nsigned main() {\n    int n;\n    cin>>n;\n    g.resize(n);\n    for( int i = 0; i < n; i++ ){\n        int k;\n        cin>>k;\n        for( int j = 0; j < k; j++ ){\n            int a;\n            cin>>a;\n            g.add( i , a );\n        }\n    }\n\n    int q;\n    cin>>q;\n\n    for( int i = 0; i < q; i++ ){\n        int a, b;\n        cin>>a>>b;\n        int res = g.lca( a, b );\n        cout << res << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 500){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        // for(int i = 0; i < n; i++) cout << parent[i] << \" \";\n        // cout << endl;\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        // cout << depth[u] << \" \" << depth[v] << endl;\n        while(depth[u] > depth[v]){\n            assert(depth[u] == depth[parent[u]]+1);\n            u = parent[u];\n            // cout << depth[u] << \" \" << depth[v] << endl;\n        }\n        while(depth[u] < depth[v]){\n            assert(depth[v] == depth[parent[v]]+1);\n            v = parent[v];\n            // cout << depth[u] << \" \" << depth[v] << endl;\n        }\n        assert(depth[u] == depth[v]);\n        while(u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <map>\n#include <unordered_map>\n#include <utility>\n\n#define MAXN 100000\n\nusing namespace std;\n\nint pre[MAXN] = {-1};\nint st[MAXN];\n\nvector<pair<int,int>> vp;\nvector<forward_list<int>> query;\nmap<pair<int,int>,int> mans;\n\nstruct pair_hash {\n    template <class T1, class T2>\n    size_t operator () (const pair<T1, T2> &p)const {\n        auto h1 = hash<T1>{}(p.first);\n        auto h2 = hash<T2>{}(p.second);\n        return h1 + h2;\n    }\n};\n\nunordered_map<pair<int,int>,int,pair_hash> seek;\n\nvoid swap(int &i,int &j){\n    int t = i;\n    i = j;\n    j = t;\n}\n\n\nclass Edge{\npublic:\n    int s;\n    int t;\n    Edge(int si,int ti):s(si),t(ti){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    vector<forward_list<int>> adj;\n    Graph(int v):V(v){\n        adj.resize(v);\n        query.resize(v);\n        for(int i = 0; i < V;i++) {st[i] = i;pre[i] = -1;}\n        }\n    void addEdge(int i,int j){adj[i].push_front(j);}\n    void tarjanR(Edge e);\n};\n\nint root(int v){\n    while(st[v] != v) v = st[v];\n    return v;\n}\n\nvoid Graph::tarjanR(Edge e){\n    int t = e.t;\n    int s = e.s;\n    pre[t] = 0;\n\n    for(auto a = adj[t].begin();a != adj[t].end();++a){\n        int v = *a;\n        if(pre[v] == -1){\n            tarjanR(Edge(t,v));\n        }\n    }\n    for(auto k = query[t].begin(); k != query[t].end();++k){\n        int mi = *k,ma = t;\n        if(mi > ma) swap(mi,ma);\n        pair<int,int> p = make_pair(mi,ma);\n        if(pre[*k] != -1 && seek.find(p)!=seek.end() && seek[p] == -1){\n            seek[p] = root(*k);\n        }\n    }\n    st[t] = s;\n}\n\n\nint main()\n{\n    int V,j,q,tt;\n    scanf(\"%d\",&V);\n    Graph G(V);\n    for(int i = 0; i < V; i++){\n        scanf(\"%d\",&j);\n        for(int k = 0; k < j;k++)\n        {\n            scanf(\"%d\",&tt);\n            G.addEdge(i,tt);\n        }\n    }\n\n    int s,t;\n\n    scanf(\"%d\",&q);\n    for(int i = 0; i < q;i++){\n        scanf(\"%d %d\",&s,&t);\n        if(s > t){swap(s,t);}\n        vp.push_back(make_pair(s,t));\n        seek[make_pair(s,t)] = -1;\n        query[s].push_front(t);\n        query[t].push_front(s);\n    }\n\n    G.tarjanR(Edge(0,0));\n\n    for(int i = 0; i < q;i++){\n        printf(\"%d\\n\",seek[vp[i]]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PI 4*atan(1.0)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int SIZE=100001;\n//int arr[SIZE]={};\n//???????????§???????????¬\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tGraph G;\n\tfor(int i=0;i<2*N;i++){\n\t\tEdges E;\n\t\tG.push_back(E);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint l;\n\t\t\tcin>>l;\n\t\t\tG[i].push_back(Edge(i,l,1));\n\t\t\tG[l].push_back(Edge(l,i,1));\n\t\t}\n\t}\n\tint Q;\n\tcin>>Q;\n\tvector<Query> VQ;\n\tfor(int i=0;i<Q;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tVQ.push_back(Query(a,b));\n\t}\n\n\tleastCommonAncestor(G,0,VQ);\n\n\tfor(int i=0;i<Q;i++){\n\t\tcout<<VQ[i].w<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\n\nint N,Q;\nvector<int> g[MAX_N+5];\nint root;\nint depth[MAX_N+5];\nint par[21][MAX_N];\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    for(int u=0;u<g[v].size();++u){\n        if(g[v][u]!=p)dfs(g[v][u],v,d+1);\n    }\n}\n\nvoid fill_table(){\n    for(int i=0;i<20;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nint LCA(int u,int v){\n    if(depth[u]>depth[v])swap(u,v);\n    for(int i=0;i<20;++i){\n        if((depth[v]-depth[u])>>i&1)v=par[i][v];\n    }\n    if(v==u)return u;\n    for(int i=20;i>=0;--i){\n        if(par[i][v]!=par[i][v]){\n            u=par[i][u];\n            v=par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;++j){\n            int c;\n            cin>>c;\n            g[i].PB(c);\n        }\n    }\n    dfs(root,-1,0);\n    fill_table();\n    cin>>Q;\n    while(Q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<LCA(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nvi MSB;\nvoid initMSB(int n){\n  MSB = vi(n+1,0);\n  int k = 2;\n  rep(i,n){\n    if(i+1==k)MSB[i+1] = MSB[i] + 1, k<<=1;\n    else MSB[i+1] = MSB[i];\n  }\n}\n\nstruct SparseTable{\n  vi val;\n  vector<vi> table;\n\n  SparseTable(void){}\n  SparseTable(const vi a):val(a){\n    int n = a.size();\n    initMSB(n);\n    table = vector<vi>(n,vi(MSB[n]+1,0));\n    rep(i,n)table[i][0] = i;\n\n    int k = 1;\n    rep(j,MSB[n]){\n      rep(i,n){\n\tint id1 = table[i][j], id2 = (i+k<n)?table[i+k][j]:id1;\n\ttable[i][j+1] = (val[id1]<=val[id2])?id1:id2;\n      }\n      k <<= 1;\n    }\n  }\n\n  int rmqi(int l, int r){\n    int ln = MSB[r-l];\n    int id1 = table[l][ln], id2 = table[r-(1<<ln)][ln];\n    return (val[id1]<=val[id2])?id1:id2;\n  }\n\n  int rmq(int l, int r){ return val[rmqi(l,r)]; }\n};\n\nstruct dif1RMQ{\n  int s;\n  vi val, subval, subid, bit;\n  SparseTable st;\n  vector< vector<vi> > lookup_table;\n\n  dif1RMQ(void){}\n  dif1RMQ(const vi a):val(a){\n    int n = a.size();\n    initMSB(n);\n    s = max(1,MSB[n]/2);\n    int m = (n+s-1)/s;\n\n    subval.resize(m); subid.resize(m); bit.resize(m);\n    rep(i,m){\n      subval[i] = val[s*i]; subid[i] = s*i;\n      int lim = min(s*(i+1),n);\n      for(int j=s*i;j<lim;j++){\n\tif(subval[i] > val[j]){ subval[i] = val[j]; subid[i] = j; }\n      }\n      bit[i] = 0;\n      for(int j=s*i;j<lim-1;j++){\n\tif(val[j]<val[j+1])bit[i] |= 1<<(j-s*i+1);\n      }\n    }\n    st = SparseTable(subval);\n\n    lookup_table.resize(1<<s);\n    rep(i,1<<s)lookup_table[i] = vector<vi>(s, vi(s,0));\n      \n    rep(i,1<<s)rep(j,s){\n      int cur = 0, minv = 0, minid = j;\n      lookup_table[i][j][j] = j;\n      for(int k=j+1;k<s;k++){\n\tif( (i>>k)&1 )cur++;\n\telse cur--;\n\tif(minv > cur){ minv = cur; minid = k; }\n\tlookup_table[i][j][k] = minid;\n      }\n    }\n  }\n\n  int rmqi(int l, int r){\n    //cerr << l << \" \" << r << endl;\n    r--;\n    int bl = l/s, br = r/s;\n    if(bl == br)return lookup_table[bit[bl]][l-bl*s][r-br*s] + bl*s;\n    else{\n      //cerr << bit[bl] << \" \"<< bl << \" \" << s << endl;\n      //cerr << bit[br] << \" \"<< br << \" \" << s << endl;\n      int res = lookup_table[bit[bl]][l-bl*s][s-1] + bl*s;\n      int tmp = lookup_table[bit[br]][0][r-br*s] + br*s;\n\n      //cerr << res << \" \" << tmp << endl;\n      if(val[res] > val[tmp])res = tmp;\n      if(br-bl>1){\n\ttmp = subid[st.rmqi(bl+1,br)];\n\tif(val[res] > val[tmp])res = tmp;\n      }\n      return res;\n    }\n  }\n\n  int rmq(int l, int r){ return val[rmqi(l,r)]; }\n};\n\nstruct LCA{\n  vi tour, depth, id;\n  dif1RMQ dr;\n  \n  LCA(void){}\n  LCA(const vector<vi> t,int root){\n    int n = t.size(), k = 0;\n    tour.resize(2*n-1); depth.resize(2*n-1); id.resize(n);\n    dfs(root,-1,0,k,t);\n    /*\n    rep(i,2*n-1)cerr << tour[i] << \" \"; cerr << endl;\n    rep(i,2*n-1)cerr << depth[i] << \" \"; cerr << endl;\n    rep(i,n)cerr << id[i] << \" \"; cerr << endl;\n    */\n    dr = dif1RMQ(depth);\n  }\n\n  void dfs(int v,int p, int d, int &k, const vector<vi> &t){\n    id[v] = k; tour[k] = v;\n    depth[k++] = d;\n    for(int u : t[v]){\n      if(u != p){\n\tdfs(u,v,d+1,k,t);\n\ttour[k] = v;\n\tdepth[k++] = d;\n      }\n    }\n  }\n\n  int lca(int u, int v){\n    int a = min(id[u],id[v]), b = max(id[u],id[v]);\n    //cerr << dr.rmqi(a,b+1) << endl;\n    return tour[dr.rmqi(a,b+1)];\n  }\n  int dep(int v){ return depth[id[v]]; }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<vi> g(n);\n  rep(i,n){\n    int k;\n    cin >> k;\n    rep(j,k){\n      int c;\n      cin >> c;\n      g[i].push_back(c);\n    }\n  }\n  LCA lca(g,0);\n  \n  int q;\n  cin >> q;\n  rep(i,q){\n    int a,b;\n    cin >> a >> b;\n    int x = lca.lca(a,b);\n    cout << x << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\nusing namespace std;\n\n\nclass RMQ{//RangeMinimumQuery\n\tint n;\n\tstd::vector<int> dat,idx;\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tint query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return dat.size()-1;\n\t\tif(a<=l&&r<=b)return idx[k];\n\t\telse{\n\t\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn dat[vl]<dat[vr]?vl:vr;\n\t\t}\n\t}\npublic:\n\tRMQ(){}\n\t~RMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tn=calcsize(a.size());\n\t\tidx.resize(2*n-1);\n\t\tfor(int i=0;i<(int)a.size();i++)idx[n-1+i]=i;\n\t\tfor(int i=a.size();i<n;i++)idx[n-1+i]=a.size();\n\t\tdat=a;\n\t\tdat.push_back(INT_MAX);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tidx[i]=dat[idx[i*2+1]]<dat[idx[i*2+2]]?idx[i*2+1]:idx[i*2+2];\n\t\t}\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\nclass LCA{\n\tvector<pair<int,int> > eulertour;\n\tvector<int> vertex;\n\tRMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u].first=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t\tif(edge[u].empty()){\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,0,root);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u].first<eulertour[v].first && eulertour[v].second<eulertour[u].second)\n\t\t\treturn u;\n\t\tif(eulertour[v].first<eulertour[u].first && eulertour[u].second<eulertour[v].second)\n\t\t\treturn v;\n\t\tif(eulertour[u].first>eulertour[v].first)swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u].second, eulertour[v].first)];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vii> vvii;\ntypedef vector<int>::iterator vit;\n\nconst int MAXN = 100005;\nconst int LOGN = 50;\n\nint idx[MAXN]; // i : index of node i in dfs path\nii path[MAXN << 1];\nvi adjList[MAXN];\n\nii ST[LOGN][MAXN<<1];\n\nvoid build(int n) {\n    int h = (n == 1 ? 1 : ceil(log2(n)));\n\n    for (int i = 0; i < n; i++) ST[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n            ST[i][j] = min(ST[i-1][j], ST[i-1][j+(1<<(i-1))]);\n}\n\nint RMQ(int l, int r) {    // range [l,r)\n    int p = 31 - __builtin_clz(r-l);\n    return min(ST[p][l],ST[p][r-(1<<p)]).se;\n}\n\n// build dfs path, depth\nint cnt = 0;\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n\n    path[cnt++] = ii(d,curr);\n    for (vit it = adjList[curr].begin(); it != adjList[curr].end(); it++) {\n        dfs(*it,d+1);\n\n        path[cnt++] = ii(d,curr);\n    }\n}\n\nint N, M, Q, v;\n\nint main(){\n\n    scanf(\"%d\",&N);\n    for (int u = 0; u < N; u++){\n        scanf(\"%d\",&M);\n        for (int i = 0; i < M; i++){\n            scanf(\"%d\",&v);\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted as 0\n    dfs(0,0);\n    build(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v, l, r; i < Q; i++){\n    scanf(\"%d%d\",&u,&v);\n\n        l = idx[u], r = idx[v]; if (l > r) swap(l,r);\n\n        printf(\"%d\\n\",RMQ(l,r+1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (__typeof(a.begin()) x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define endl '\\n'\n\nint n;\nvector<int> c[100005];\nconst int K = log2(100005);\nint parent[K][100005];\nint depth[100005];\n\nvoid dfs(int v, int p, int d) {\n  parent[0][v] = p;\n  depth[v] = d;\n  for (auto i: c[v]) {\n    dfs(i, v, d + 1);\n  }\n}\n\nvoid init() {\n  dfs(0, -1, 0);\n  for (int k = 0; k + 1 < K; k++) {\n    for (int v; v < n; v++) {\n      if (parent[k][v] < 0) parent[k + 1][v] = -1;\n      else parent[k + 1][v] = parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u, int v) {\n  if (depth[u] > depth[v]) swap(u, v);\n  for (int k; k < K; k++) {\n    if ((depth[v] - depth[v] >> k & 1)) {\n      v = parent[k][v];\n    } \n    if (u == v) return u;\n  }\n  for (int k = K - 1; k >= 0; k--) {\n    if (parent[k][u] != parent[k][v]) {\n      u = parent[k][u];\n      v = parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  rep(i, n) {\n    int k;\n    cin >> k;\n    rep(j, k) {\n      int cj;\n      cin >> cj;\n      c[i].push_back(cj);\n    }\n  }\n\n  init();\n\n  int q;\n  cin >> q;\n  rep(i, q) {\n    int u, v;\n    cin >> u >> v;\n    cout << lca(u, v) + 1 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<int> tree[100005];\n\nclass LCA {\npublic:\n  int n,ln; // number of nodes and log n\n  vector<vector<int>> parent;\n  vector<int> depth;\n  LCA(int _n, int root=-1) : n(_n), depth(_n){\n    ln=0;\n    while(n>=(1<<ln)) ln++;  // calc log n\n    parent = vector<vector<int>>(ln, vector<int>(n));\n    if(root!=-1) init(root);\n  }\n  void dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    rep(i,tree[v].size()) if(tree[v][i]!=p) dfs(tree[v][i], v, d+1);\n  }\n  void init(int root){\n    dfs(root, -1, 0);\n    for(int k=0; k+1<ln; k++){\n      for(int v=0; v<n; v++){\n        if(parent[k][v] < 0) parent[k+1][v] = -1;\n        else parent[k+1][v] = parent[k][parent[k][v]];\n      }\n    }\n  }\n  int query(int u, int v){\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<ln; k++){\n      if((depth[v]-depth[u])>>k & 1) v = parent[k][v];\n    }\n    if(u==v) return u;\n    for(int k=ln-1; k>=0; k--){\n      if(parent[k][u] != parent[k][v]){\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main(){\n  int n;\n  cin>>n;\n  rep(i,n){\n    int k;\n    cin>>k;\n    rep(j,k){\n      int d;\n      cin>>d;\n      tree[i].pb(d);\n    }\n  }\n\n  LCA lca(n, 0);\n\n  int q;\n  cin>>q;\n  rep(_,q){\n    int a,b;\n    cin>>a>>b;\n    cout << lca.query(a,b) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass LCA{\nprivate:\n\tvector<vector<int>> v;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\tint h = 0;\n\tvoid dfs(int n,int m,int d){\n\t\tparent[0][n] = m;\n\t\tdepth[n] = d;\n\t\tfor(auto x:v[n]){\n\t\t\tif(x!=m) dfs(x,n,d+1);\n\t\t}\n\t}\npublic:\n\tLCA(int N,int root,vector<vector<int>>& tree){\n\t\twhile((1<<h)<=N) h++;\n\t\tv = tree;\n\t\tparent = vector<vector<int>>(h,vector<int>(N,0));\n\t\tdepth = vector<int>(N,0);\n\t\tdfs(root,-1,0);\n\t\tfor(int j=0;j+1<h;j++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(parent[j][i]<0) parent[j+1][i] = -1;\n\t\t\t\telse parent[j+1][i] = parent[j][parent[j][i]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int n,int m){\n\t\tif(depth[n]>depth[m]) swap(n,m);\n\t\tfor(int j=0;j<h;j++){\n\t\t\tif((depth[m]-depth[n]) >> j&1) m = parent[j][m];\n\t\t}\n\t\tif(n==m) return n;\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tif(parent[j][n]!=parent[j][m]){\n\t\t\t\tn = parent[j][n];\n\t\t\t\tm = parent[j][m];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][n];\n\t}\n\tint dep(int n){return depth[n];}\n};\nint N,Q,x,y,a,b;\n\nint main(){\n\tcin >> N;\n\tvector<vector<int>> tree(N+1);\n\tfor(int i=0;i<N;i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\ttree[i].push_back(c);\n\t\t\ttree[c].push_back(i);\n\t\t}\n\t}\n\tLCA lca(N,0,tree);\n\tcin >> Q;\n\tfor(int i=0;i<Q;i++){\n\t\tcin >> a >> b;\n\t\tint p = lca.lca(a,b);\n\t\tcout << p << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c = 0): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\nusing Graph = vector<vector<Edge>>;\n\nvoid add_edge(Graph& graph, int u, int v, int cost = 0){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nstruct HL{\n  int N;\n  VI depth;\n  VI par;\n  VI sz;\n  //! ????????????????????????????§????\n  VI xs;\n  //! ?????????????±???????Heavy???id\n  VI heavy_id;\n  //! ?????????????????????\n  VI heavy_nth;\n  //! heavys[id] := {id???Heavy???????????????}\n  VVI heavys;\n  //! Heavy??????????????¨?????¨??¨????????¨????????????heavy_id\n  VI heavy_par;\n  //! heavy?????°\n  int H;\n\n  HL(const Graph& G, int root = 0, const VI& xs_ = {}){\n\tN = SZ(G);\n\tdepth.assign(N, 0);\n\tpar.assign(N, -1);\n\tsz.assign(N, 1);\n\tif(!xs_.empty())\n\t  xs = xs_;\n\telse\n\t  xs.assign(N, 0);\n\theavy_id.assign(N, -1);\n\theavy_nth.assign(N, 0);\n\theavys.assign(N, {});\n\theavy_par.assign(N, -1);\n\n\tfunction<void(int,int)> init = [&](int u, int p){\n\t  par[u] = p;\n\t  for(auto& e: G[u]){\n\t\tif(e.to == p){\n\t\t  continue;\n\t\t}\n\t\tdepth[e.to] = depth[u] + 1;\n\t\tinit(e.to, u);\n\t\tsz[u] += sz[e.to];\n\t\tif(xs_.empty())\n\t\t  xs[e.to] = e.cost;\n\t  }\n\t};\n\tdepth[root] = 0;\n\tinit(root, -1);\n\tH = 1;\n\tfunction<void(int,int)> calcHL = [&](int u, int p){\n\t  heavy_nth[u] = SZ(heavys[heavy_id[u]]);\n\t  heavys[heavy_id[u]].PB(u);\n\n\t  int max_u = -1;\n\t  for(auto& e: G[u]){\n\t\tif(e.to == p) continue;\n\t\tif(max_u < 0 || sz[max_u] < sz[e.to])\n\t\t  max_u = e.to;\n\t  }\n\n\t  if(max_u < 0) return;\n\t  heavy_id[max_u] = heavy_id[u];\n\t  calcHL(max_u, u);\n\t  \n\t  for(auto& e: G[u]){\n\t\tif(e.to == p || e.to == max_u) continue;\n\t\theavy_id[e.to] = H++;\n\t\tcalcHL(e.to, u);\n\t\theavy_par[heavy_id[e.to]] = heavy_id[u];\n\t  }\n\t};\n\theavy_id[root] = 0;\n\tcalcHL(root, -1);\n  }\n\n  int LCA(int u, int v){\n\twhile(true){\n\t  if(heavy_id[u] == heavy_id[v])\n\t\treturn (depth[u] <= depth[v]? u: v);\n\n\t  int ru = heavys[heavy_id[u]][0];\n\t  int rv = heavys[heavy_id[v]][0];\n\t  if(depth[ru] < depth[rv])\n\t\tv = par[rv];\n\t  else\n\t\tu = par[ru];\n\t}\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  Graph G(N);\n  REP(i,N){\n\tint k;\n\tcin >> k;\n\tREP(j,k){\n\t  int c;\n\t  cin >> c;\n\t  add_edge(G, i, c);\n\t}\n  }\n\n  HL hl(G);  \n  int Q;\n  cin >> Q;\n  while(Q--){\n\tint u, v;\n\tcin >> u >> v;\n\tcout << hl.LCA(u, v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass lca {\npublic:\n    int n, segn;\n    std::vector<int> path, depth, in_order;\n    std::vector<std::pair<int,int>> dat;\n    const std::pair<int,int> INF = std::make_pair(1000000000, 1000000000);\n\n    lca(const Graph &g, int root)\n        : n(g.size()),\n          path(n * 2 - 1),\n          depth(n * 2 - 1),\n          in_order(n) {\n        int k = 0;\n        dfs(g, root, -1, 0, k);\n        for (segn = 1; segn < n * 2 - 1; segn <<= 1);\n        dat.assign(segn * 2, INF);\n        for (int i = 0; i < (int)depth.size(); ++i)\n            dat[segn + i] = std::make_pair(depth[i], i);\n        for (int i = segn - 1; i >= 1; --i)\n            dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n    }\n\n    int get(int u, int v) {\n        int l = std::min(in_order[u], in_order[v]);\n        int r = std::max(in_order[u], in_order[v]) + 1;\n        auto res = range_min(1, segn, l, r);\n        return path[res.second];\n    }\n\n    void dfs(const Graph &g, int v, int p, int d, int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : g[v]) {\n            if (e.dst != p) {\n                dfs(g, e.dst, v, d + 1, k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n    }\n\n    std::pair<int,int> range_min(int v, int w, int l, int r) const {\n        if (r <= l || w == 0) return INF;\n        if (r - l == w) return dat[v];\n        int m = w / 2;\n        auto rmin = range_min(v * 2, m, l, std::min(r, m));\n        auto lmin = range_min(v * 2 + 1, m, std::max(0, l - m), r - m);\n        return min(rmin, lmin);\n    }\n};\n\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    Graph g(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            g[i].emplace_back(i, c, 1);\n        }\n    }\n    lca l(g, 0);\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << l.get(u, v) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nstruct LowestCommonAncestor {\n    size_t n;\n    size_t size() const { return n; }\n    vector<int> color, parent, depth, topDepth, goUp, visited;\n    vector<vector<int>> g;\n    LowestCommonAncestor(size_t n_) : n(n_), g(n) {}\n    void addEdge(int u, int v){\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    void decomp(int root = 0, int B = 500){\n        parent.assign(n, -1); depth.assign(n, 0);\n        topDepth.assign(n, 0); goUp.assign(n, -1); visited.assign(n, false);\n        vector<int> tord;\n        vector<int> q(n+1); int l = 0, r = 0;\n        q[r++] = root;\n        while(l != r){\n            int v = q[l++]; visited[v] = true;\n            tord.push_back(v);\n            for(int c : g[v]){\n                if(!visited[c]){ parent[c] = v; depth[c] = depth[v] + 1; q[r++] = c; }\n            }\n        }\n        swap(color, visited); // ?????¢????????±??????\n        color.assign(n, 0);\n        int c = 0;\n        for(int u : tord){\n            if(color[u]) continue;\n            c++;\n            l = 0, r = 0;\n            q[r++] = u;\n            for(int i = 0; i < B && l != r; i++){\n                int v = q[l++];\n                color[v] = c; goUp[v] = parent[u]; topDepth[v] = depth[u];\n                for(int c : g[v]) if(!color[c]) q[r++] = c;\n            }\n        }\n    }\n    int solve(int u, int v){\n        while(color[u] != color[v]){\n            if(topDepth[u] > topDepth[v]) u = goUp[u];\n            else v = goUp[v];\n        }\n        while(u != v){\n            if(depth[u] > depth[v]) u = parent[u];\n            else v = parent[v];\n        }\n        return u;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint main(){\n    int n;\n    cin >> n;\n    LowestCommonAncestor g(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g.addEdge(i,c);\n        }\n    }\n    g.decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << g.solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\n\n\nclass RMQsub1{\n\tstd::vector<int> pattern;\n\tstd::vector<std::vector<int> > minpos;\n\tstd::vector<int> depth;\n\tSparseTableRMQ rmq;\n\tint blocksize;\n\tint n;\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tstd::vector<int> B;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k>>1;//log(n)/2\n\t\tif(blocksize==0)blocksize=1;\n\t\tint m=(n+blocksize-1)/blocksize;//num block\n\t\tthis->n=m;\n\t\tpattern.resize(m,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tB.resize(m);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tB[i]=depth[s+minpos[p][0+b-1]];\n\t\t}\n\t\trmq.build(B);\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\tb--;\n\t\tint ab=a/blocksize,bb=b/blocksize;\n\t\tif(ab==bb)return ab*blocksize + minpos[pattern[ab]][(a%blocksize)*blocksize+b%blocksize];\n\t\tint i,j;\n\t\ti=ab*blocksize + minpos[pattern[ab]][(a%blocksize)*blocksize+blocksize-1];\n\t\tj=bb*blocksize + minpos[pattern[bb]][0+b%blocksize];\n\t\tif(depth[i]>depth[j])i=j;\n\t\tif(ab+1==bb)return i;\n\t\tj=rmq.query(ab+1,bb);\n\t\tj=j*blocksize + minpos[pattern[j]][0+blocksize-1];\n\t\tif(depth[i]>depth[j])i=j;\n\t\treturn i;\n\t}\n};\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 300005\n#define MAX_M 3000005\ntypedef long long ll;\ntypedef pair<int,int> P;\nstruct data{ll x,a,b;};\n\nint N,Q;\nint a,b,c;\nvector<int> G[MAX_N];\nint p[MAX_N],l[MAX_N],r[MAX_N],d[MAX_N],cnt=0;\nvector<int> g,flg;\n\n\nvoid rec(int pos,int prev,int depth){\n  d[pos]=depth;\n  l[pos]=g.size();\n  p[pos]=g.size();\n  g.push_back(pos);\n  if(G[pos].size()==0)l[pos]=r[pos]=cnt++;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int w=G[pos][i];\n    if(w==prev)continue;\n    rec(w,pos,depth+1);\n    g.push_back(pos);\n  }\n  r[pos]=g.size()-1;\n}\n\nint Depth[MAX_N];\nP dp[MAX_N][30];\n\nint lca(int u,int v){\n\n  u=p[u];\n  v=p[v];\n  if(u>v)swap(u,v);\n  int dist=v-u+1;\n  int pos=u;\n  P res=P((1<<26),(1<<26));\n\n  for(int I=26;I>=0;I--){\n    int i=(1<<I);\n    if(dist>=i){\n      dist-=i;\n      res=min(res,dp[pos][I]);\n      pos+=i;\n    }\n  }\n\n  return g[res.second];\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&a);\n    for(int j=0;j<a;j++){\n      scanf(\"%d\",&b);\n      G[i].push_back(b);\n    }\n  }\n\n  rec(0,-1,0);\n\n\n  for(int i=0;i<(int)g.size();i++)\n    dp[i][0]=P(d[g[i]],i);\n\n  int K=1;\n  for(int k=1;k<30;k++){\n    for(int i=0;i<(int)g.size();i++){\n      dp[i][k]=dp[i][k-1];\n      int j=i+K;\n      if(j>=(int)g.size())j=g.size()-1;\n      dp[i][k]=min(dp[i][k],dp[j][k-1]);\n    }\n    K*=2;\n  }\n  \n  cin>>Q;\n\n\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",lca(a,b));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst int sqrtN = 512;\nconst int logN = 64;\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nstruct LowestCommonAncestor{\n\tvector<vector<int>> g, parent;\n\tvector<int> depth;\n\tbool built = false;\n\tint N;\n\t\n\tLowestCommonAncestor(int n) : N(n) {\n\t\tg.resize(N);\n\t\tparent.resize(logN, vector<int>(N));\n\t\tdepth.resize(N);\n\t}\n\t\n\tvoid add_edge(int u, int v){\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int par = -1, int d = 0){\n\t\tparent[0][v] = par;\n\t\tdepth[v] = d;\n\t\t\n\t\tfor(auto e:g[v]){\n\t\t\tif(e == par) continue;\n\t\t\tdfs(e, v, d + 1);\n\t\t}\n\t}\n\t\n\tvoid build(){\n\t\tdfs(0);\n\t\tREP(k, 0, logN - 1){\n\t\t\tREP(i, 0, N){\n\t\t\t\tif(parent[k][i] < 0) parent[k + 1][i] = -1;\n\t\t\t\telse parent[k + 1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint get(int u, int v){\n\t\tif(!built) build(); built = true;\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\t\n\t\tREP(k, 0, logN) if(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\t\n\t\tif(u == v) return u;\n\t\t\n\t\tRREP(k, logN - 1, 0){\n\t\t\tif(parent[k][u] == parent[k][v]) continue;\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\t\t\t\n\t\t}\n\t\t\n\t\treturn parent[0][u];\n\t}\n};\n\nint main(){\n\tint n; cin >> n;\n\tLowestCommonAncestor lca(n);\n\tREP(i, 0, n){\n\t\tint a; cin >> a;\n\t\tREP(j, 0, a){\n\t\t\tint u; cin >> u;\n\t\t\tlca.add_edge(i, u);\n\t\t}\n\t}\n\t\n\tint q; cin >> q;\n\tREP(i, 0, q){\n\t\tint a,b; cin >> a >> b;\n\t\tcout << lca.get(a, b) << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing i32 = int;\nusing i64 = long long;\nusing ll = long long;\n\nusing namespace std;\n\ntemplate<class T> class Graph{\npublic:\n    struct edge{\n        int to;\n        T cost;\n        edge(int to,T cost):to(to),cost(cost){}\n    };\n    int N,M;\n    vector<vector<edge>> g;\n    Graph(int N,int M):N(N),g(N),M(M){}\n    void add_edge(int a,int b,T cost = 1){\n       g[a].emplace_back(b,cost);\n    }\n    void input(bool undirected = true,bool unweighted = true){\n        for(int i = 0;i < M;i++){\n            int a,b;\n            T c = 1;\n            cin >> a >> b;\n            if(!unweighted) cin >> c;\n            g[a].emplace_back(b,c);\n            if(undirected) g[b].emplace_back(a,c);\n        }\n    }\n\n};\ntemplate<class T> class LCA : public Graph<T>{\nprivate:\n    vector<vector<int>> par;\n    vector<int> depth;\n    int root;\npublic:\n    LCA(int N): Graph<T>(N,N-1),par(40,vector<int>(N,-1)),depth(N){}\n    void add_edge(int a,int b){\n        Graph<T>::add_edge(a,b);\n    }\n    void input(){\n        Graph<T>::input(true,true);\n    }\n    void dfs(int,int,int);\n    void init(int);\n    int lca(int,int);\n};\n\ntemplate<class T>\nvoid LCA<T>::dfs(int v,int p,int d) {\n    par[0][v] = p;\n    depth[v] = d;\n    for(int i = 0;i < Graph<T>::g[v].size();i++){\n        if(Graph<T>::g[v][i].to != p) dfs(Graph<T>::g[v][i].to,v,d+1);\n    }\n}\n\ntemplate<class T>\nvoid LCA<T>::init(int root){\n    dfs(root,-1,0);\n    // initialize parent\n    for(int k = 0;k + 1 < 40;k++){\n        for(int v = 0;v < Graph<T>::N;v++){\n            if(par[k][v] < 0) par[k+1][v] = -1;\n            else par[k+1][v] = par[k][par[k][v]];\n        }\n    }\n}\n\ntemplate<class T>\nint LCA<T>::lca(int u,int v) {\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k = 0;k < 40;k++){\n        if((depth[v] - depth[u]) >> k & 1){\n            v = par[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = 39;k >= 0;k--){\n        if(par[k][u] != par[k][v]){\n            u = par[k][u];\n            v = par[k][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;cin >> n;\n    LCA<int> G(n);\n    for(int i = 0;i < n;i++){\n       int k;cin >> k;\n       for(int j = 0;j < k;j++){\n           int c;cin >> c;\n           G.add_edge(i,c);\n           G.add_edge(c,i);\n       }\n    }\n    G.init(0);\n    int q;cin >> q;\n    while(q--){\n        int u,v;cin >> u >> v;\n        cout << G.lca(u,v) << '\\n';\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,a,b,fa[100000][18],depth[100000],x,y,m;\nvector<ll> v[100000];\nvoid dfs(ll a,ll cnt){\n    depth[a]=cnt;\n    for(ll z:v[a]){\n        fa[z][0]=a;\n        dfs(z,cnt+1);\n    }\n    return ;\n}\nP d(ll a,ll b){\n    if(depth[a]==depth[b])return {a,b};\n    if(depth[a]<depth[b])swap(a,b);\n    //cout<<a<<\" \"<<b<<endl;\n    for(int i=17;i>=0;i--){\n        if(fa[a][i]!=-1&&depth[fa[a][i]]>depth[b])return d(fa[a][i],b);\n        //cout<<depth[fa[a][i]]<<\" \"<<depth[b]<<endl;\n    }\n    //cout<<\"W\"<<a<<b<<endl;\n    return {fa[a][0],b};\n}\nll d2(ll a,ll b){\n    if(a==b)return a;\n    for(int i=17;i>=0;i--){\n        if(fa[a][i]!=-1&&fa[a][i]!=fa[b][i])return d2(fa[a][i],fa[b][i]);\n    }\n    return fa[a][0];\n}\nint main(void){\n    cin>>n;\n    for(int i=0;i<18;i++)fa[0][i]=-1;\n    for(int i=0;i<n;i++){\n        cin>>a;\n        while(a--){\n            cin>>b;\n            v[i].push_back(b);\n        }\n    }\n    dfs(0,0);\n    \n    for(int i=1;i<18;i++){\n        for(int j=0;j<n;j++){\n            int L=i;\n            int LL=j;\n            while(L){\n                if(fa[LL][L-1]==-1){\n                    fa[j][i]=-1;\n                    break;\n                }\n                LL=fa[LL][L-1];\n                L--;\n            }\n            if(fa[j][i]==0)fa[j][i]=fa[LL][0];\n        }\n    }\n    cin>>m;\n    for(int i=0;i<m;i++){\n        cin>>a>>b;\n        P q=d(a,b);\n        //cout<<q.first<<\" \"<<q.second<<endl;\n        cout<<d2(q.first,q.second)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n  vector<vector<int> > tree;\n\n  HeavyLight(int n,vector<vector<int> > t)\n    :pathCount(0),n(n),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n),tree(t){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(n,tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{ START\nusing namespace std;\n#define int int64_t\n#define rep(i, a, n) for (int i = (a); i < (n); ++i)\n#define reps(i, a, n) for (int i = (a); i > (n); --i)\n#define arep(i, x) for (auto &&i : (x))\n#define irep(i, x) for (auto i = (x).begin(); i != (x).end(); ++i)\n//降順はgreater<T>()\n#define all(x) (x).begin(), (x).end()\n#define rv(s) reverse((s).begin(), (s).end())\n// gcd lcmはそのままok\n#define gcd(a, b) __gcd(a, b)\n#define bits(n) (1LL << (n))\n#define pcnt(x) __builtin_popcountll(x)\n//配列内等要素削除\n#define unique(x) (x).erase(unique((x).begin(), (x).end()), (x).end())\n#define Fixed(n) fixed << setprecision(n)\n//総和\n#define sowa(n) ((n) * ((n) + 1)) / 2\n#define pb(x, a) (x).push_back(a)\n#define fb(x, a) (x).push_front(a)\n#define eb(x, a) (x).emplace_back(a)\n#define F first\n#define S second\n#define cauto const auto &\nusing P = pair<int, int>;\nusing Graph = vector<vector<P>>;\ntemplate <class T>  //昇順\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>  //降順\nusing max_heap = priority_queue<T>;\ntemplate <class A, class B>\nusing umap = unordered_map<A, B>;\ntemplate <class A>\nusing uset = unordered_set<A>;\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {  //多次元初期化\n  std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <class T>\nbool chmax(T &a, const T &b) {  //最大値更新 返り値はbool\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {  //最小値更新 返り値はbool\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr int LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr int mod1 = 1e9 + 7;\nconstexpr int mod2 = 998244353;\n//} END\n\nusing graph = vector<vector<int>>;\n\n/* LCA(G, root): 木 G に対する根を root として\nLowest Common Ancestorを求める構造体\nquery(u,v): u と v の LCA を求める。計算量 O(logn)\n前処理:O(nlogn)時間, O(nlogn)空間\n*/\nstruct LCA {\n  vector<vector<int>> parent;  // parent[k][u]:= u の 2^k 先の親\n  vector<int> dist;            // root からの距離\n  LCA(const graph &G, int root = 0) { init(G, root); }\n\n  // 初期化\n  void init(const graph &G, int root = 0) {\n    int V = G.size();\n    int K = 1;\n    while ((1 << K) < V) K++;\n    parent.assign(K, vector<int>(V, -1));\n    dist.assign(V, -1);\n    dfs(G, root, -1, 0);\n    for (int k = 0; k + 1 < K; k++) {\n      for (int v = 0; v < V; v++) {\n        if (parent[k][v] < 0) {\n          parent[k + 1][v] = -1;\n        } else {\n          parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n      }\n    }\n  }\n\n  // 根からの距離と1つ先の頂点を求める\n  void dfs(const graph &G, int v, int p, int d) {\n    parent[0][v] = p;\n    dist[v] = d;\n    for (auto e : G[v]) {\n      if (e != p) dfs(G, e, v, d + 1);\n    }\n  }\n\n  int query(int u, int v) {\n    if (dist[u] < dist[v]) swap(u, v);  // u の方が深いとする\n    int K = parent.size();\n    // LCA までの距離を同じにする\n    for (int k = 0; k < K; k++) {\n      if ((dist[u] - dist[v]) >> k & 1) {\n        u = parent[k][u];\n      }\n    }\n    // 二分探索で LCA を求める\n    if (u == v) return u;\n    for (int k = K - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nsigned main() {\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  graph g(n);\n  rep(i, 0, n) {\n    int k;\n    cin >> k;\n    rep(j, 0, k) {\n      int c;\n      cin >> c;\n      g[i].emplace_back(c);\n    }\n  }\n\n  LCA lca(g);\n  int q;\n  cin >> q;\n\n  rep(i, 0, q) {\n    int x, y;\n    cin >> x >> y;\n    cout << lca.query(x, y) << '\\n';\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <complex>\n#include <stdlib.h>\n#include <stdio.h>\n#include <functional>\n#include <cfloat>\n#include <math.h>\n#include <numeric>\n#include <string.h>\n#include <sys/time.h>\n#include <random>\n\n\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define MAX_V 100000\n#define MAX_LOG_V 30\n\nvector<int> G[MAX_V];\nclass LCA{\n    int root;\n    vector<vector<int>> parent;\n    vector<int> depth;\n\npublic:\n    /**\n     *\n     * @param V: 頂点数\n     */\n    LCA(int V){\n        root = 0;\n        init(V);\n    }\n\n    LCA(int root, int V): root(root){\n        init(V);\n    }\n\n    void dfs(int v, int p, int d){\n        parent[0][v] = p;\n        depth[v] = d;\n        for(auto u: G[v]){\n            if(u != p){\n                dfs(u, v, d+1);\n            }\n        }\n    }\n\n    void init(int V){\n        parent = vector<vector<int>>(MAX_LOG_V, vector<int>(MAX_V, 0));\n        depth = vector<int>(MAX_V, 0);\n\n        dfs(root, -1, 0);\n        for(int k = 0; k + 1 < MAX_LOG_V; k++){\n            for(int v = 0; v < V; v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    /**\n     *\n     * @param u\n     * @param v\n     * @return 頂点uと頂点vのLCA\n     */\n    int lca(int u, int v){\n        if(depth[u] > depth[v]){\n            swap(u, v);\n        }\n\n        for(int k = 0; k < MAX_LOG_V; k++) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n        if(u == v){\n            return u;\n        }\n        for(int k = MAX_LOG_V-1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\n};\n\n\nint main(){\n    int n;  cin >> n;\n    for(int i = 0; i < n; i++){\n        int k;  cin >> k;\n        for(int j = 0; j < k; j++){\n            int c;  cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n\n    LCA lca(n);\n    int q;  cin >> q;\n    for(int i = 0; i < q; i++){\n        int u, v;   cin >> u >> v;\n        cout << lca.lca(u, v) << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\n// struct edge { int u, v; ll w; };\n\nint INF = INT_MAX;\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint N;\nvector<int> G[100010];\nint sz[100010], par[100010], dep[100010];\n\nvoid dfs_sz(int u, int p) {\n\tsz[u] = 1;\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tdfs_sz(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs_hl(int u, int p) {\n\tint x, ma = 0;\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tif (sz[v] > ma) {\n\t\t\tx = v;\n\t\t\tma = sz[v];\n\t\t}\n\t}\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tpar[v] = (v == x ? par[u] : u);\n\t\tdfs_hl(v, u);\n\t}\n}\n\nvoid dfs_dep(int u, int p) {\n\tfor (int v: G[u]) {\n\t\tif (v == p) continue;\n\t\tdep[v] = dep[u] + 1;\n\t\tdfs_dep(v, u);\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tfor (int u = 0; u < N; u++) {\n\t\tint k; scanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n\tdfs_sz(0, N);\n\tpar[0] = N;\n\tdfs_hl(0, N);\n\tdep[N] = -1;\n\tdfs_dep(0, N);\n\tint Q; cin >> Q;\n\twhile (Q--) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tfor (;;) {\n\t\t\tint U = par[u], V = par[v];\n\t\t\tif (U == V) break;\n\t\t\tif (dep[U] > dep[V]) u = U;\n\t\t\telse v = V;\n\t\t}\n\t\tprintf(\"%d\\n\", dep[u] < dep[v] ? u : v);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <functional>\n#include <vector>\n\nusing namespace std;\n\n#define int long long\n#define dotimes(i, n) for (int i = 0, i##max__ = (n); i < i##max__; i++)\n#define whole(f, x, ...) ([&](decltype((x)) c) { return (f)(begin(c), end(c), ## __VA_ARGS__); })(x)\n\nint rint() {\n  int x;\n  scanf(\"%lld\", &x);\n  return x;\n}\n\nvoid wint(int x) {\n  printf(\"%lld\\n\", x);\n}\n\ntemplate<typename T> int size(T const& c) { return static_cast<int>(c.size()); }\ntemplate <typename T> bool maxs(T& a, T const& b) { return a < b ? a = b, true : false; }\ntemplate <typename T> bool mins(T& a, T const& b) { return a > b ? a = b, true : false; }\ninline int lg(int x) { return 63 - __builtin_clzll(static_cast<unsigned int>(x)); }\n\nsigned main() {\n  const int n = rint();\n  vector<vector<int>> edges(n);\n  dotimes(i, n)\n    dotimes(j, rint())\n      edges[i].emplace_back(rint());\n  // doubling\n  vector<pair<int, vector<int>>> p(n, pair<int, vector<int>>(0, vector<int>(lg(n - 1) + 1)));\n  function<void(int, int)> rec;\n  rec =\n    [&](int u, int c) {\n      for (int v : edges[u]) {\n        p[v].first = c;\n        p[v].second[0] = u;\n        rec(v, c+1);\n      }\n    };\n  rec(0, 1);\n  dotimes(i, lg(n - 1))\n    for (auto& pu : p)\n      pu.second[i+1] = p[pu.second[i]].second[i];\n  // query\n  const int q = rint();\n  dotimes(i, q) {\n    int u = rint();\n    int v = rint();\n    if (p[u].first < p[v].first)\n      swap(u, v);\n    for (int j = 0, b = p[u].first - p[v].first; b; j++, b >>= 1)\n      if (b & 1)\n        u = p[u].second[j];\n    assert(p[u].first == p[v].first);\n    if (u == v) {\n      wint(u);\n      continue;\n    }\n    for (int j = lg(p[u].first); j >= 0; j--)\n      if (p[u].second[j] != p[v].second[j]) {\n        u = p[u].second[j];\n        v = p[v].second[j];\n      }\n    assert(p[u].second[0] == p[v].second[0]);\n    wint(p[u].second[0]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N, Q;\nint T[MAXN], L[MAXN], P[MAXN][20];  // direct parent, depth, ancestor\nvector<int> adjList[MAXN];\n\nvoid dfs(int node = 0, int depth = 0) {\n    L[node] = depth;\n    for (int i = 0; i < adjList[node].size(); i++) {\n        int child = adjList[node][i];\n        dfs(child,depth+1);\n    }\n}\n\nint query(int u, int v) {\n    int tmp;\n    if (L[u] < L[v])\n        tmp = u, u = v, v = tmp;\n\n    int LOG2;\n    for (LOG2 = 1; 1 << LOG2 <= L[u]; LOG2++); LOG2--;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (L[u] - (1 << i) >= L[v])\n            u = P[u][i];\n\n    if (u == v)\n        return u;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (P[u][i] != -1 && P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n\n    return T[u];\n}\n\nint main() {\n\n\n    scanf(\"%d\",&N);\n    for (int u = 0, M; u < N; u++) {\n        scanf(\"%d\",&M);\n        for (int i = 0, v; i < M; i++) {\n            scanf(\"%d\",&v);\n\n            T[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted at 0\n    dfs();\n\n    for (int i = 1; i <= N; i++)\n        P[i][0] = T[i];\n    for (int j = 1; 1 << j < N; j++)\n        for (int i = 1; i <= N; i++)\n            if (P[i][j-1] != -1)\n                P[i][j] = P[P[i][j-1]][j-1];\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v; i < Q; i++) {\n        scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\", query(u,v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n#if 0\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) ord[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n#else\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n#endif\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  // std::freopen(\"in_large.txt\", \"r\", stdin);\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(move(et));\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nstruct sqrt_decomp_tree {\n    int n, B;\n    int size() const { return n; }\n    vi color, parent, depth, block_root_depth, block_parent, visited;\n    vvi adj;\n    sqrt_decomp_tree(int n_) : n(n_), adj(n) {\n        int l = 0, r = n;\n        while (l < r - 1) {\n            i64 m = (l + r) / 2;\n            if (m * m >= n) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        B = r;\n    }\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    void decomp(int root = 0) {\n        color.assign(n, -1);\n        parent.assign(n, -1);\n        depth.assign(n, 0);\n        block_root_depth.assign(n, 0);\n        block_parent.assign(n, -1);\n        visited.assign(n, 0);\n        vi tord;\n        vi q(n + 1);\n        int l = 0, r = 0;\n        q[r++] = root;\n        while (l != r) {\n            int v = q[l++];\n            visited[v] = 1;\n            tord.push_back(v);\n            for (int c : adj[v]) {\n                if (!visited[c]) {\n                    parent[c] = v;\n                    depth[c] = depth[v] + 1;\n                    q[r++] = c;\n                }\n            }\n        }\n        int c = 0;\n        for (int u : tord) {\n            if (color[u] != -1) continue;\n            l = 0, r = 0;\n            q[r++] = u;\n            for (int i = 0; i < B && l != r; i++) {\n                int v = q[l++];\n                color[v] = c;\n                block_parent[v] = parent[u];\n                block_root_depth[v] = depth[u];\n                for (int c : adj[v])\n                    if (color[c] == -1) q[r++] = c;\n            }\n            c++;\n        }\n    }\n    int lca(int u, int v) {\n        while (block_root_depth[u] > block_root_depth[v]) u = block_parent[u];\n        while (block_root_depth[u] < block_root_depth[v]) v = block_parent[v];\n        while (depth[u] > depth[v]) u = parent[u];\n        while (depth[u] < depth[v]) v = parent[v];\n        while (u != v) u = parent[u], v = parent[v];\n        return u;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    sqrt_decomp_tree tree(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int u;\n            cin >> u;\n            tree.addEdge(i, u);\n        }\n    }\n    \n    tree.decomp();\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << tree.lca(u, v) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing PII = std::pair<int, int>;\nusing PLL = std::pair<ll, ll>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\n\n\nconst int amax = 18;\n\nstruct node\n{\n    int custom;\n    int depth;\n    vector<int> ansestors;\n    vector<int> childrens;\n};\n\nvector<node> nodes;\n\nvoid dfs(int s, int d)\n{\n    nodes[s].depth = d;\n    for (auto z : nodes[s].childrens)\n        dfs(z, d + 1);\n}\n\nint back_to_ansestors(int s, int n)\n{\n    int m, c;\n    c = 0;\n    if (n == 0)\n        return s;\n    else\n    {\n        m = n;\n        while (m > 0 && m % 2 == 0)\n        {\n            c++;\n            m /= 2;\n        }\n        return back_to_ansestors(nodes[s].ansestors[c], n - pow(2, c));\n    }\n}\n\nint lca(int a, int b)\n{\n    int dd, ok, ng, mid;\n\n    dd = nodes[a].depth - nodes[b].depth;\n    if (dd > 0)\n        a = back_to_ansestors(a, dd);\n    if (dd < 0)\n        b = back_to_ansestors(b, abs(dd));\n    if (a == b)\n        return a;\n    if (a == 0 || b == 0)\n        return 0;\n\n    while (nodes[a].ansestors[0] != nodes[b].ansestors[0])\n    {\n        for (int i = amax - 1; i > -1; i--)\n        {\n            if (nodes[a].ansestors[i] != nodes[b].ansestors[i])\n            {\n                a = nodes[a].ansestors[i];\n                b = nodes[b].ansestors[i];\n                break;\n            }\n        }\n    }\n\n    return nodes[a].ansestors[0];\n}\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, k, c, q, a, b, da, db, dd, ca;\n    cin >> n;\n    vector<int> ainit, cinit;\n\n    rep(i, n)\n    {\n        nodes.push_back((node){0, 0, ainit, cinit});\n        rep(j, amax)\n        {\n            nodes[i].ansestors.push_back(-1);\n        }\n    }\n\n    rep(i, n)\n    {\n        cin >> k;\n        rep(j, k)\n        {\n            cin >> c;\n            nodes[c].ansestors[0] = i;\n            nodes[i].childrens.push_back(c);\n        }\n    }\n    rep(j, amax - 1)\n    {\n        rep(i, n)\n        {\n            if (nodes[i].ansestors[j] != -1 && nodes[nodes[i].ansestors[j]].ansestors[j] != -1)\n                nodes[i].ansestors[j + 1] = nodes[nodes[i].ansestors[j]].ansestors[j];\n        }\n    }\n\n    dfs(0, 0);\n\n    cin >> q;\n    rep(i, q)\n    {\n        cin >> a >> b;\n        cout << lca(a, b) << endl;\n    }\n\n    // rep(i, n)\n    // {\n    //     cout << nodes[i].depth << \"\\t\";\n    //     rep(j, amax)\n    //     {\n\n    //         cout << nodes[i].ansestors[j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll four[] = {0, 1, 0, -1, 0};\nconst ll eight[] = {0, 1, 1, 0, -1, -1, 1, -1, 0};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n)-1;i>=0;i--)\n#define rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++) { int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\n\nstruct HLDecomposition{\n    ll n;\n    const vector<vector<ll>>& g;\n    vector<ll> index, invex, light_root, heavy_root, siz;\n    HLDecomposition(const vector<vector<ll>>& g, ll root = 0): n(g.size()), g(g), index(n), invex(n), light_root(n), heavy_root(n), siz(n, 1){\n        dfs(-1, root);\n        n = 0;\n        dfs2(-1, root, -1, 0);\n        vector<ll> siz2(n);\n        for(ll i = 0; i < n; i++) siz2[index[i]] = siz[i];\n        swap(siz, siz2);\n    }\n    void dfs(ll from, ll at){\n        for(auto& i : g[at]) if(i != from){\n            dfs(at, i);\n            siz[at] += siz[i];\n        }\n    }\n    void dfs2(ll from, ll at, ll light, ll heavy){\n        invex[n] = at;\n        light_root[n] = light;\n        heavy_root[n] = heavy;\n        index[at] = n++;\n        ll max = -1, maxdex = -1;\n        for(auto& i : g[at]) if(i != from && chmax(max, siz[i])) maxdex = i;\n        if(maxdex == -1) return;\n        dfs2(at, maxdex, light, heavy);\n        for(auto& i : g[at]) if(i != from && i != maxdex) dfs2(at, i, index[at], n);\n    }\n    ll lca(ll a, ll b){\n        a = index[a]; b = index[b];\n        while(true){\n            if(a > b) swap(a, b);\n            if(heavy_root[a] == heavy_root[b]) return invex[a];\n            b = light_root[b];\n        }\n    }\n    template<class T> void path_node(ll a, ll b, T f){\n        a = index[a]; b = index[b];\n        while(true){\n            if(a > b) swap(a, b);\n            if(heavy_root[a] == heavy_root[b]){\n                f(a, b + 1);\n                return;\n            }\n            f(heavy_root[b], b + 1);\n            b = light_root[b];\n        }\n    }\n    template<class T> void path_edge(ll a, ll b, T f){\n        a = index[a]; b = index[b];\n        while(true){\n            if(a > b) swap(a, b);\n            if(heavy_root[a] == heavy_root[b]){\n                f(a, b);\n                return;\n            }\n            f(heavy_root[b] - 1, b);\n            b = light_root[b];\n        }\n    }\n    template<class T> void subtree_node(ll a, T f){\n        a = index[a];\n        f(a, a + siz[a]);\n    }\n    template<class T> void subtree_edge(ll a, T f){\n        a = index[a];\n        f(a, a + siz[a] - 1);\n    }\n};\nsigned main(){\n    LL(n);\n    vector<vector<ll>>g(n);\n    rep(n){\n        LL(m);\n        rep(_,m){\n            LL(j);\n            g[i].push_back(j);\n            g[j].push_back(i);\n        }\n    }\n    HLDecomposition hld(g);\n    LL(q);\n    rep(q){\n        LL(x,y);\n        out(hld.lca(x,y));\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// RMQ\n#include<vector>\n#include<climits>\n#include<algorithm>\nconst int INF = INT_MAX;\nconst int NIL = -1;\nclass RangeMinimumQuery {\npublic:\n  RangeMinimumQuery(int s) {\n    size_ = 1;\n    while(size_ < s) size_ <<= 1;\n    node_ = std::vector<int>((size_ << 1) - 1, INF);\n  }\n  int find(int left, int right) const {\n    return query(left, right, 0, 0, size_ - 1);\n  }\n  void update(int index, int value) {\n    int i = index + size_ - 1;\n    node_[i] = value;\n    while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n  }\nprivate:\n  int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n  int left_child(int node) const {return (node << 1) + 1;}\n  int right_child(int node) const {return (node << 1) + 2;}\n  int query(int a, int b, int k, int l, int r) const {\n    if(b < l || r < a) return INF;\n    if(a <= l && r <= b) return node_[k];\n    int vl = query(a, b, left_child(k), l, (l + r) / 2);\n    int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n    return std::min(vl, vr);\n  }\n  int size_;\n  std::vector<int> node_;\n};\n\n// Graph\n#include<vector>\ntypedef std::vector<std::vector<int>> Graph;\n\n// LCA\n#include<vector>\n#include<memory>\nclass LowestCommonAncestor {\npublic:\n  LowestCommonAncestor(const Graph& g) {initialize(g);}\n  int find(int u, int v) const {return rmq_->find(id_[u], id_[v]);}\nprivate:\n  void initialize(const Graph& g) {\n    id_.resize(g.size());\n    rmq_ = std::unique_ptr<RangeMinimumQuery>(new RangeMinimumQuery(2 * g.size()));\n    dfs(g, 0, -1, 0);\n  }\n  int dfs(const Graph& g, int current, int depth, int index) {\n    rmq_->update(index, depth);\n    id_[current] = index;\n    for(auto next: g[current]) index = dfs(g, next, depth + 1, index);\n    rmq_->update(++index, depth);\n    return index;\n  }\n  std::vector<int> id_;\n  std::unique_ptr<RangeMinimumQuery> rmq_;\n};\n\n// main\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n\n  Graph g(n);\n  for(auto& list: g) {\n    int k;\n    cin >> k;\n    list.resize(k);\n    for(auto& c: list) cin >> c;\n  }\n\n  LowestCommonAncestor LCA(g);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << LCA.find(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy4 = {0, -1, 0, 1}, dx4 = {1, 0, -1, 0};\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n// 木上のクエリを処理\n// ・作成(O(n log n))\n// ・ノード間の距離(O(log n))\n// ・直径・中心(O(log n))\n// ・最小共通素性(O(log n))\n// ・ノード間の最大の重み(O(log n))\nclass QueryOnTree {\nprivate:\n    std::unordered_map<int, std::vector<std::pair<int, int>>> tree;\n    int log_v = 0;\n    std::vector<std::unordered_map<int, int>> parent;        // 2^k個上の親\n    std::vector<std::unordered_map<int, int>> max_weight;    // 2^k個上の親までにでてくる最大の重み\n    std::unordered_map<int, int> depth;                      // 各頂点についての根からの深さ\n    std::unordered_map<int, long long> distance_from_root;   // 根からの距離\n\npublic:\n    // 無向グラフの場合はu->vとv->uの両方をいれること\n    QueryOnTree(int root, const std::unordered_map<int, std::vector<std::pair<int, int>>> &tree) : tree(tree) {\n        int n = tree.size();\n        if (n == 0) {\n            return ;\n        }\n\n        this->log_v = int(log2(n)) + 1;\n        this->parent = std::vector<std::unordered_map<int, int>>(log_v);\n        this->max_weight = std::vector<std::unordered_map<int, int>>(log_v);\n        this->distance_from_root[root] = 0;\n\n        dfs(root, -1, 0, 0);\n\n        for (int k = 0; k + 1 < this->log_v; k++) {\n            for (const auto &p : tree) {\n                int u = p.first;\n                if (parent[k][u] < 0) {\n                    parent[k + 1][u] = -1;\n                }\n                else {\n                    parent[k + 1][u] = parent[k][parent[k][u]]; // uの2^k個上のノードの2^k上のノードはuの2^(k+1)個上のノード\n                    if (parent[k + 1][u] >= 0) {\n                        max_weight[k + 1][u] = std::max(max_weight[k][u], max_weight[k][parent[k][u]]);\n                    }\n                }\n            }\n        }\n    }\n\n    // uとvの距離\n    long long distance(int u, int v) {\n        return distance_from_root[u] + distance_from_root[v] - 2 * distance_from_root[lca(u, v)];\n    }\n\n    // 木の直径，中心\n    std::pair<int, long long> center_diameter() {\n        // node 0から一番遠いnode\n        int u = 0;\n        long long max_distance = -1;\n        for (const auto &p : tree) {\n            auto node = p.first;\n            auto dist = this->distance(0, node);\n            if (dist > max_distance) {\n                max_distance = dist;\n                u = node;\n            }\n        }\n\n        // node uから一番遠いnode\n        std::unordered_map<long long, int> distance_node;\n        long long diameter = 0;\n        for (const auto &p : tree) {\n            auto node = p.first;\n            auto dist = this->distance(u, node);\n            distance_node[dist] = node;\n            if (dist > diameter) {\n                diameter = dist;\n            }\n        }\n        assert(diameter != -1);\n\n        int center = distance_node[max_distance / 2];\n\n        return std::make_pair(center, diameter);\n    }\n\n    // uとvの間で出現する最大の重み\n    int maximum_weight(int u, int v) {\n        int lca = this->lca(u, v);\n        return std::max(this->maximum_weight_ancestor(u, lca), this->maximum_weight_ancestor(v, lca));\n    }\n\n    // uとvの最近共通祖先(O(log n))\n    int lca(int u, int v) {\n        if (depth[u] > depth[v]) {\n            std::swap(u, v);\n        }\n        for (int k = 0; k < this->log_v; ++k) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n\n        if (u == v) {\n            return u;\n        }\n\n        for (int k = this->log_v - 1; k >= 0; --k) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\nprivate:\n    // 各頂点について，1つ上の親，1つ上の重み，根からの深さ，根からの距離を求める\n    void dfs(int u, int p, int d, int w) {\n        parent[0][u] = p;\n        max_weight[0][u] = w;\n        depth[u] = d;\n\n        for (const auto &a : tree[u]) {\n            int v = a.first;\n            int dist = a.second;\n            if (v != p) {\n                distance_from_root[v] = distance_from_root[u] + dist;\n                dfs(v, u, d + 1, dist);\n            }\n        }\n    }\n\n    // uとuの祖先の間の最大の重みを取得\n    int maximum_weight_ancestor(int u, int ancestor) {\n        int res = -INF;\n        int d = depth[u] - depth[ancestor];\n        for (int k = 0; k < log_v; k ++) {\n            if ((d >> k) & 1) {\n                res = std::max(res, max_weight[k][u]);\n                u = parent[k][u];\n            }\n        }\n        return res;\n    }\n};\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    unordered_map<int, vector<pair<int, int>>> tree;\n    FOR(i, 0, N) {\n        int K;\n        cin >> K;\n        FOR(j, 0, K) {\n            int C;\n            cin >> C;\n            tree[i].emplace_back(make_pair(C, 1));\n            tree[C].emplace_back(make_pair(i, 1));\n        }\n    }\n\n    QueryOnTree qut(0, tree);\n\n    int Q;\n    cin >> Q;\n    FOR(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        print(qut.lca(U, V));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B, cnt = 1;\nstack<int>S;\ninline void dfs(int p) {\n\tint A = S.top();\n\tfor (int i = 0; i < X[A].size(); i++) {\n\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; dfs(X[A][i]); }\n\t}\n\tS.pop();\n}\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\tint C1 = 0; dfs(0);\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < N; i++) { sort(D[i].begin(), D[i].end()); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\tif (W == 0 || (Depth[b[A]] == 1 && Depth[b[B]] == 1 && A != B)) { cout << \"0\" << endl; continue; }\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(max(1, logN), vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  for(int i = 2; i <= 20; i++) {\n    LCA lca(i);\n    cout << i << \": \" << lca.logN << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;\nvector<int> G[100010];\nint parent[100010];//parent[i]はiの親\nint depth[100010];//depth[i]はiの根からの深さ\nint root = 0;//今回は0が根\nvoid dfs(int v,int p,int d){\n\tparent[v] = p;\n\tdepth[v] = d;\n\tfor(int i =0;i <G[v].size();i++){\n\t\tif(G[v][i]!=p){\n\t\t\tdfs(G[v][i],v,d+1);\n\t\t}\n\t}\n}\n//初期化\nvoid init(){\n\tdfs(root,-1,0);\n}\n\nint lca(int u,int v){\n\twhile(depth[u] >depth[v]) u =parent[u];\n\twhile(depth[u] < depth[v]) v =parent[v];\n\twhile(u!=v){\n\t\tu =parent[u];\n\t\tv =parent[v];\n\t}\n\treturn u;\n}\nint main(){\n\tcin>>n;\n\tfor(int i =0;i < n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j =0;j < k;j++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tG[i].push_back(c);\n\t\t\t//G[c].push_back(i);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin>>q;\n\n\tfor(int i =0;i < q;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tcout <<lca(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\ntemplate <int B> // (1 << B) >= MAX_LEN\nstruct lowest_common_ancestor {\n    vector<vector<int>> graph;\n    int N, root;\n    int parent[B][1 << B], depth[1 << B];\n\n    lowest_common_ancestor() {}\n    void init(vector<vector<int>>& _graph, int _root) {\n        graph = _graph;\n        root = _root;\n\n        N = graph.size();\n\n        // set ancestors\n        set_parent(root, -1, 0);\n        for (int b = 1; b < B; ++b) {\n            for (int i = 0; i < N; ++i) {\n                if (parent[b-1][i] == -1) {\n                    parent[b][i] = -1;\n                } else {\n                    parent[b][i] = parent[b-1][parent[b-1][i]];\n                }\n            }\n        }\n    }\n\n    int query(int u, int v) {\n        if (depth[u] > depth[v]) {\n            int t = u; u = v; v = t;\n        }\n\n        for (int i = 0; i < B; ++i) {\n            if ((((depth[v] - depth[u]) >> i) & 1) != 0) {\n                v = parent[i][v];\n            }\n        } // depth[u] == depth[v]\n\n        if (u == v) return u;\n\n        for (int b = B-1; b >= 0; --b) {\n            if (parent[b][u] != parent[b][v]) {\n                u = parent[b][u];\n                v = parent[b][v];\n            }\n        }\n\n        return parent[0][u];\n    }\n\nprivate:\n    void set_parent(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (const int& e : graph[v]) {\n            if (e != p) {\n                set_parent(e, v, d+1);\n            }\n        }\n    }\n};\n\nint N;\nvector<vector<int>> g;\nlowest_common_ancestor<17> lca;\n\nint main() {\n    cin >> N; g.resize(N);\n    for (int j = 0; j < N; ++j) {\n        int k; cin >> k;\n        for (int x = 0; x < k; ++x) {\n            int c; cin >> c;\n            g[j].push_back(c);\n        }\n    }\n\n    lca.init(g, 0);\n    int Q; cin >> Q;\n    for (int j = 0; j < Q; ++j) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<bool> vb;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nclass RMQ{\n\tprivate:\n\tvector<pair<int,vi> > rmq;\n\tvoid updatefunc(int x,int k,vi num){\n\t\trmq[x].first=rmq[k].first;\n\t\tfor(int i=0;i<num.size();i++){\n\t\t\trmq[x].second.push_back(num[i]);\n\t\t}\n\t}\n\tpublic:\n\tint n;\n\tvoid init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\trmq=vector<pair<int,vi> >(2*n-1,pair<int,vi>(inf,emp));\n\t}\n\tvoid update(int k,int x){\n\t\tk+=n-1;\n\t\tif(rmq[k].second.empty()) rmq[k].second.push_back(k-n+1);\n\t\trmq[k].first=x;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\trmq[k].second.clear();\n\t\t\tif(rmq[k*2+1].first<rmq[k*2+2].first){\n\t\t\t\tupdatefunc(k,k*2+1,rmq[k*2+1].second);\n\t\t\t}\n\t\t\telse if(rmq[k*2+1].first>rmq[k*2+2].first){\n\t\t\t\tupdatefunc(k,k*2+2,rmq[k*2+2].second);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tupdatefunc(k,k*2+1,rmq[k*2+1].second);\n\t\t\t\tupdatefunc(k,k*2+2,rmq[k*2+2].second);\n\t\t\t}\n\t\t}\n\t}\n\tpair<int,vi> query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return pair<int,vi>(inf,emp);\n\t\tif(a<=l&&r<=b) return rmq[k];\n\t\telse{\n\t\t\tint mid=(l+r)/2;\n\t\t\tpair<int,vi> vl=query(a,b,k*2+1,l,mid);\n\t\t\tpair<int,vi> vr=query(a,b,k*2+2,mid,r);\n\t\t\treturn (vl.first<vr.first)?vl:vr;\n\t\t}\n\t}\n\tint open(int x){\n\t\tx+=n-1;\n\t\treturn rmq[x].first;\n\t}\n\tvoid full_open(){\n\t\tfor(int i=0;i<rmq.size();i++){\n\t\t\tfor(int j=0;j<rmq[i].second.size();j++){\n\t\t\t\tcout<<rmq[i].second[j]<<' ';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n};\n\nclass Graph{\n\tprivate:\n\tint GV;\n\tvvi List;\n\tvoid Euler(int x,int l,int& ind,vb& used){\n\t\teuler[ind]=x;\n\t\tlevel.update(ind,l);\n\t\tused[x]=1;\n\t\tif(disc[x]==-1) disc[x]=ind;\n\t\tind++;\n\t\tfor(int i=0;i<List[x].size();i++){\n\t\t\tint v=List[x][i];\n\t\t\tif(!used[v]){\n\t\t\t\tEuler(v,l+1,ind,used);\n\t\t\t\teuler[ind]=x;\n\t\t\t\tlevel.update(ind,l);\n\t\t\t\tind++;\n\t\t\t}\n\t\t}\n\t}\n\tpublic:\n\tvi euler,disc;\n\tRMQ\tlevel;\n\tGraph(int v){\n\t\tGV=v;\n\t\tList=vvi(v);\n\t}\n\tvoid add_edge(int x,int y){\n\t\tList[x].push_back(y);\n\t\tList[y].push_back(x);\n\t}\n\tvoid LCAprepare(){\n\t\teuler=vi(2*GV-1);\n\t\tdisc=vi(GV,-1);\n\t\tlevel.init(2*GV-1);\n\t\tint ind=0;\n\t\tvb used(GV);\n\t\tEuler(0,0,ind,used);\n\t}\n\tint LCA(int s,int t){\n\t\ts=disc[s];\n\t\tt=disc[t];\n\t\tif(s>t) swap(s,t);\n\t\tpair<int,vi> index=level.query(s,t+1,0,0,level.n);\n\t\treturn euler[index.second[0]];\n\t}\n};\n\nint V,Q;\n\nint main(){\n\tcin>>V;\n\tGraph gra(V);\n\tint n,s;\n\tfor(int i=0;i<V;i++){\n\t\tcin>>n;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>s;\n\t\t\tgra.add_edge(i,s);\n\t\t}\n\t}\n\tgra.LCAprepare();\n\tcin>>Q;\n\tint u,v;\n\tfor(int i=0;i<Q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<gra.LCA(u,v)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass LCA{\nprivate:\n    int n,h;\n    struct edge { int to, cost;};\n    vector< vector<edge> > g;\n    vector<vector<int> > par;\n    vector<int> dist,dep;\n\n    void dfs(int now, int p, int d, int cost){\n        par[0][now] = p;\n        dep[now] = d;\n        dist[now] = cost;\n        for(int i = 0; i < g[now].size(); i++){\n            int ne = g[now][i].to;\n            if(ne != p) dfs(ne, now, d + 1, cost + g[now][i].cost);\n        }\n    }\n\npublic:\n\n    LCA(){}\n\n    LCA(int size){\n        n = size;\n        g.resize(n);\n        dist.resize(n,0);\n        dep.resize(n,0);\n        h = 1;\n        while((1<<h) <= n)h++;\n        par.assign(h,vector<int>(n,-1));\n    }\n\n    void add(int a, int b, int c){//無向辺\n        edge e1 = {b, c}, e2 = {a, c};\n        g[a].push_back(e1);\n        g[b].push_back(e2);//有向辺の場合はここをコメントアウトする\n    }\n\n    void build(int root = 0){\n        dfs(root,-1,0,0);\n        for(int k = 0; k+1 < h; k++){\n            for(int v = 0; v < n; v++){\n                if(par[k][v] < 0) par[k+1][v] = -1;\n                else par[k+1][v] = par[k][par[k][v]];\n            }\n        }\n    }\n\n    int lca(int a, int b){//頂点ABのLCAのindex\n        if(dep[a] > dep[b]) swap(a,b);\n        for(int k = 0; k < h; k++){\n            if((dep[b] - dep[a]) >> k & 1){\n                b = par[k][b];\n            }\n        }\n        if(a == b) return a;\n        for(int k = h-1; k >= 0; k--){\n            if(par[k][a] != par[k][b]){\n                a = par[k][a];\n                b = par[k][b];\n            }\n        }\n        return par[0][a];\n    }\n\n    int distance(int a, int b){//頂点ABのパスの長さ\n        return dist[a] + dist[b] - dist[lca(a,b)]*2;\n    }\n\n};\n\n\nvoid GRL5C(){\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int to;\n            cin >> to;\n            lca.add(i,to,1);\n        }\n    }\n    lca.build();\n    int q;\n    cin >> q;\n    while(q--){\n        int a,b;\n        cin >> a >> b;\n        cout << lca.lca(a,b) << endl;\n    }\n}\n\nsigned main(void) {\n\n    GRL5C();\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,n) for(int i = a; n > i; i++)\n#define REP(i,n) rep(i,0,n)\n \nsigned main()\n{\n  int n;\n  cin >> n;\n  vector<vector<int>> graph(n), par(n, vector<int>(30));\n  vector<int> d(n);\n\n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int c;\n      cin >> c;\n      graph[i].push_back(c);\n      graph[c].push_back(i);\n    }\n  }\n\n  function<void(int,int,int)> dfs = [&](int c, int p, int depth){\n    d[c] = depth;\n    par[c][0] = p;\n    for(auto ch : graph[c]){\n      if(ch != p)\n        dfs(ch, c, depth + 1);\n    }\n  };\n  dfs(0, 0, 0);\n  \n  int q;\n  cin >> q;\n\n  /*calc par*/\n  for (int i = 1; 30 > i; i++)\n  {\n    REP(j, n)\n    {\n      par[j][i] = par[par[j][i - 1]][i - 1];\n    }\n  }\n\n  REP(__, q)\n  {\n    int u, v;\n    cin >> u >> v;\n    if (d[u] > d[v])\n      swap(u, v);\n\n    /*LCA!!!*/\n    \n    for (int i = 29; 0 <= i; i--)\n    {\n      //cout << d[u] << \" \" << d[v] << endl;\n      if (d[u] <= d[par[v][i]])\n      {\n        v = par[v][i];\n      }\n    }\n    /* LCA */\n    for (int i = 29; 0 <= i; i--)\n    {\n      //cout << u << \" \" << v << endl;\n      if (par[u][i] != par[v][i])\n      {\n        v = par[v][i];\n        u = par[u][i];\n      }\n    }\n    if(u == v) cout << u << endl;\n    else cout << par[v][0] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define maxv 100000\n\nusing namespace std;\n\nint n, len, in[maxv], out[maxv], up[100][maxv];\nvector<int> tree[maxv];\n\nvoid dfs(int u, int p, int &k){\n  in[u] = k++;\n  up[0][u] = p;\n  for(int i = 1; i < len; i++)\n    up[i][u] = up[i - 1][up[i - 1][u]];\n\n  for(int i = 0; i < tree[u].size(); i++){\n    if(tree[u][i] != p)dfs(tree[u][i],u,k);\n  }\n  out[u] = k++;\n}\n\nvoid init(int root){\n  while((1 << len) <= n)len++;\n  int k=0;\n  dfs(root,root,k);\n}\n\nbool isParent(int parent, int child){\n  return in[parent] <= in[child] && out[child] <= out[parent];\n}\n\nint lca(int a, int b){\n  if(isParent(a,b))return a;\n  if(isParent(b,a))return b;\n  for(int i = len - 1; i >= 0; i--){\n    if(!isParent(up[i][a],b))a = up[i][a];\n  }\n  return up[0][a];\n}\n\nint main(void){\n  int k,c,q,u,v;\n\n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> c;\n      tree[i].push_back(c);\n    }\n  }\n\n  init(0);\n\n  cin >> q;\n  while(q--){\n    cin >> u >> v;\n    cout << lca(u,v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len,tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\n\nvector<int> G[V_MAX];\nvector<bool> used(V_MAX,false);\nvector<int> visit;\nvector<int> first_visit(V_MAX,-1);\nvector<int> dat(5*V_MAX,INT_MAX);\nint counter=0;\nint n;\n\nvoid vector_out(vector<int> &vec){\n\tfor (int i=0;i<vec.size();i++){\n\t\tcout << vec[i] << endl;\n\t}\n}\n\nvoid dfs(int s){\n\tif(used[s]==true){return;}\n\tused[s]=true;\n\tvisit.push_back(s);\n\tfirst_visit[s]=counter;\n\tcounter++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(used[G[s][i]]==false){\n\t\t\tdfs(G[s][i]);\n\t\t\tvisit.push_back(s);\n\t\t\tcounter++;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid update(int k, int a){\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int l,int r,int k){\n\tif(r<=a || b<=l){\n\t\treturn INT_MAX;\n\t}else if(a<=l && r<=b){\n\t\treturn dat[k];\n\t}else{\n\t\treturn min(query(a,b,l,(l+r)/2,2*k+1),query(a,b,(l+r)/2,r,2*k+2));\n\t}\n}\n\nint LCA(int u,int v){\n\tint fu=first_visit[u];\n\tint fv=first_visit[v];\n\treturn query(fu,fv+1,0,visit.size(),0);\n}\n\nint main(){\n\tint V,deg,to;\n\tcin>> V ;\n\tfor (int i=0;i<V;i++){\n\t\tcin >> deg;\n\t\tfor(int j=0;j<deg;j++){\n\t\t\tcin >> to;\n\t\t\tG[i].push_back(to);\n\t\t}\n\t}\n\tdfs(0);\n\t// vector_out(first_visit);\n\t\n\tint R = visit.size();\n\t\n\tn=1;\n\twhile(n<R){\n\t\tn=2*n;\n\t}\n\t\n\tfor(int i=0;i<R;i++){\n\t\tupdate(i,visit[i]);\n\t}\n\t\n\tint Q;\n\tcin >> Q ;\n\tfor (int i=0;i<Q;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tcout << LCA(x,y) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;else return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nclass Seg_Tree{\npublic:\n\tvector< pair<int,int> > dat;\n\t// first  -> min value\n\t// second -> min index\n\tint n;\n\tvoid initsize(int n0){\n\t\tint k=1;\n\t\twhile(1){\n\t\t\tif(n0<=k){\n\t\t\t\tn=k;\n\t\t\t\tdat.resize(2*n-1);\n\t\t\t\tfor(int i=0;i<2*n-1;i++){\n\t\t\t\t\tdat[i].first=INT_MAX;\n\t\t\t\t\tdat[i].second = i-n+1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk*=2;\n\t\t}\n\t}\n\t//i banme wo x nisuru\n\tvoid update(int i,int x){\n\t\ti += n-1;\n\t\tdat[i].first = x;\n\t\twhile(i>0){\n\t\t\ti = (i-1) / 2;\n\t\t\tif(dat[i*2+1].first<=dat[i*2+2].first)\n\t\t\t\tdat[i] = dat[i*2+1];\n\t\t\telse\n\t\t\t\tdat[i] = dat[i*2+2];\n\t\t}\n\t}\n\t//[a,b)\n\tpair<int,int> query0(int a,int b,int k,int l,int r){\n\t\tif(r<=a || b<=l)return {INT_MAX,-1};\n\t\tif(a<=l && r<=b)return dat[k];\n\t\telse{\n\t\t\tpair<int,int> vl = query0(a,b,k*2+1,l,(l+r)/2);\n\t\t\tpair<int,int> vr = query0(a,b,k*2+2,(l+r)/2,r);\n\t\t\tif(vl.first<=vr.first)return vl;\n\t\t\telse return vr;\n\t\t}\n\t}\n\t//return min [a,b)\n\tpair<int,int> query(int a,int b){\n\t\treturn query0(a,b,0,0,n);\n\t}\n};\n\n\n\nstruct LCA{\n\t// This struct uses class Seg_Tree\n\tvector< vector<ll> > G;\n\tll root;\n\tvector<ll> vs,depth,id;\n\tSeg_Tree se;\n\n\tLCA(ll v){\n\t\tG.resize(v);\n\t\tvs.resize(v*2-1);\n\t\tdepth.resize(v*2-1);\n\t\tid.resize(v);\n\t\troot = 0;\n\t}\n\tvoid dfs(ll v,ll p,ll d,ll &k){\n\t\tid[v] = k;\n\t\tvs[k] = v;\n\t\tdepth[k++] = d;\n\t\tfor(ll i=0;i<G[v].size();i++){\n\t\t\tif(G[v][i] != p){\n\t\t\t\tdfs(G[v][i],v,d+1,k);\n\t\t\t\tvs[k] = v;\n\t\t\t\tdepth[k++] = d;\n\t\t\t}\n\t\t}\n\t}\n\tvoid init(){\n\t\tll V = id.size();\n\t\tll k = 0;\n\t\tdfs(root,-1,0,k);\n\t\tse.initsize(V*2-1);\n\t\tfor(int i=0;i<depth.size();i++){\n\t\t\tse.update(i,depth[i]);\n\t\t}\n\t}\n\t//[u,v]\n\tint lca(ll u,ll v){\n\t\treturn vs[se.query(min(id[u],id[v]),max(id[u],id[v])+1).second];\n\t}\n\tint length_from_root(int v){\n\t\treturn depth[id[v]];\n\t}\n};\n\n\n\n\n// ant p.294\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll n;\n\tcin >> n;\n\tLCA g(n);\n\tFOR(i,0,n){\n\t\tll k,c;\n\t\tcin >> k;\n\t\tFOR(j,0,k){\n\t\t\tcin >> c;\n\t\t\tg.G[i].push_back(c);\n\t\t}\n\t}\n\tg.init();\n\tll q;\n\tcin >> q;\n\tFOR(i,0,q){\n\t\tll x,y;\n\t\tcin >> x >> y;\n\t\tcout << g.lca(x,y) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rrep(i,x) for(int i=(int)x-1;i>=0;--i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\nint in(){int a;scanf(\"%d\",&a);return a;}\nll lin(){ll a;scanf(\"%lld\",&a);return a;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nvi G[100010];\n\nint depth[100010];\nint par[100010][22];\n\nvoid lca_dfs(int v, int p, int d)\n{\n    depth[v] = d;\n    par[v][0] = p;\n\n    for (int ch : G[v]) {\n        if (ch == p) continue;\n        lca_dfs(ch, v, d + 1);\n    }\n}\n\nvoid lca_init(int root = 0)\n{\n    lca_dfs(root, -1, 0);\n\n    rep(i, 20) {\n        rep(j, 100010) {\n            par[j][i + 1] = par[j][i] == -1 ? -1 : par[par[j][i]][i];\n        }\n    }\n}\n\nint lca(int u, int v)\n{\n    if (depth[u] > depth[v]) swap(u, v);\n\n    int diff = depth[v] - depth[u];\n\n    rep(i, 20) {\n        if (diff >> i & 1) v = par[v][i];\n    }\n\n    if (u == v) return u;\n\n    rrep(i, 20) {\n        if (par[u][i] != par[v][i]) {\n            u = par[u][i];\n            v = par[v][i];\n        }\n    }\n\n    return par[u][0];\n}\n\nint main()\n{\n    int n = in();\n\n    rep(i, n) {\n        int k = in();\n\n        rep(j, k) {\n            int c = in();\n\n            G[i].PB(c);\n            G[c].PB(i);\n        }\n    }\n\n    lca_init();\n\n    int q = in();\n\n    rep(_, q) {\n        int u = in(), v = in();\n\n        printf(\"%d\\n\", lca(u, v));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define MAX 100000\n#define MAX_PARENT 100\n\nvector<int>G[MAX];\nint depth[MAX];\nint parent[MAX_PARENT][MAX];\nint root = 0;\n\nvoid dfs(int v,int p,int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0;i < G[v].size();++i){\n        if(G[v][i] != p)\n            dfs(G[v][i],v,d + 1);\n    }\n}\n\nvoid init(int v){\n    dfs(root,-1,0);\n    for(int i = 0;i + 1 < MAX_PARENT;++i){\n        for(int j = 0;j < v;++j){\n            if(parent[i][j] < 0){\n                parent[i + 1][j]= -1;  \n            } \n            else{\n                parent[i + 1][j] = parent[i][parent[i][j]];  \n            } \n        }\n    }\n}\n\nint lca(int u,int v){\n    if(depth[u] > depth[v]){\n        swap(u,v);   \n    }\n    \n    for(int i = 0;i < MAX_PARENT;++i){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = parent[i][v];\n        }\n    }\n    if(u == v){\n        return u;\n    }\n    \n    for(int i = MAX_PARENT -1;i >= 0;--i){\n        if(parent[i][u] != parent[i][v]){\n            u = parent[i][u];\n            v = parent[i][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n    int n,p,t;\n    cin>>n;\n    for(int i = 0;i < n;++i){\n        cin >> p;\n        for(int j = 0;j < p;++j){\n            cin >> t;\n            G[i].push_back(t);\n        }\n    }\n    init(n);\n    cin >> n;\n    for(int i = 0;i < n;++i){\n        cin >> p >> t;\n        cout << lca(p,t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF (1<<29)\n#define max_n 10000\n\nusing namespace std;\n\nstruct node_t;\n\nstruct edge{\n  node_t *u,*v;\n  int val,mini;\n  edge(node_t *u, node_t *v, int val):u(u),v(v),val(val),mini(val){}\n  inline node_t *opposite(node_t *from){return (from==u)?u:v;}\n};\n\nstruct node_t{\n  node_t *pp,*lp,*rp;\n  edge *pe,*le,*re;\n  int id,val,mini,minId,lazy;\n  bool rev;\n\n  node_t(int id,int v):id(id),val(v),mini(v){\n    pp=lp=rp=NULL;\n    rev=false; \n    lazy=0; \n    update();\n  }\n   \n  void update(){\n    mini=val,minId=id;\n    //pp=pe->opposite(this);\n    //lp=le->opposite(this);\n    //rp=re->opposite(this);\n    push();\n    if(lp)lp->push();\n    if(rp)rp->push();\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n   \n  void push(){\n    if(rev){\n      rev=false;\n      swap(lp,rp);\n      swap(le,re);\n      //lp=le->opposite(this);\n      //rp=re->opposite(this);\n      \n      if(lp)lp->rev^=true;\n      if(rp)rp->rev^=true;\n    }\n    if(lp)lp->lazy+=lazy;\n    if(rp)rp->lazy+=lazy;\n\n    val+=lazy,mini+=lazy,lazy=0;\n  }\n \n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n  \n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      node_t *r=q->pp;\n      if(!q->is_root())r->push();\n      q->push();\n      push();\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    rp=p;\n  }\n  x->splay();\n  return rp;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nbool isConnected(node_t *x, node_t *y){\n  if(x->id==y->id)return true;\n  expose(x);\n  //assert(x->pp==NULL);\n  expose(y);\n  return (x->pp != NULL);\n}\n\n//Verified.\nvoid evert(node_t *p){\n  expose(p);\n  p->rev^=true;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n}\n\nvoid link(node_t *c,node_t *p){\n  if(isConnected(c,p))return;\n  evert(c);\n  c->pp=p;\n}\n\n//Verified.\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->lazy=val; }\n\n//Verified. AOJ GRL_5_C\nnode_t *lca(node_t *x,node_t* y){\n  expose(x);\n  return expose(y);\n}\n\n//Verified.\nint min(node_t *from, node_t *to){\n  evert(from);\n  expose(to);\n  return to->mini;\n}\n\n//Verified.\nvoid add(node_t *from, node_t *to,int v){\n  evert(from);\n  expose(to);\n  to->lazy+=v;\n}\n\n\n//AOJ GRL_5_C\nnode_t *node[100001];\n\nint main(void){\n  int n;\n  cin >> n;\n  \n  for(int i=0;i<n;i++)node[i]=new node_t(i,0);\n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      link(node[t],node[i]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << lca(node[u],node[v])->id << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nstruct SegmentTreeForLCA{\n    int sz;\n    // {深さ,id}\n    vector<pair<int,int>> seg;\n    // 初期化\n    void resize(int n){\n        sz=1;\n        while(sz<n) sz<<=1;\n        seg.resize(sz<<1,{1<<30,-1});\n    }\n    // 代入\n    void set(int id,int depth){\n        seg[id+sz]={depth,id};\n    }\n    // 構築\n    void build(){\n        for(int k=sz-1;k>0;k--){\n            seg[k]=min(seg[2*k],seg[2*k+1]);\n        }\n    }\n    // [l,r]の結果を取得\n    int get(int l,int r){\n        pair<int,int> L={1<<30,-1},R={1<<30,-1};\n        l+=sz,r+=sz+1;\n        for(;l<r;l>>=1,r>>=1){\n            if(l&1) L=min(L,seg[l++]);\n            if(r&1) R=min(seg[--r],R);\n        }\n        return min(L,R).second;\n    }\n};\nstruct LCA{\n    const int V;\n    const int root;\n    const vector<vector<int>> &edge;\n    vector<int> nodeOrder;\n    vector<int> depthOrder;\n    vector<int> nodeFirstID;\n    SegmentTreeForLCA seg;\n    LCA(int V,int root,vector<vector<int>> edge):\n        V(V),\n        root(root),\n        edge(edge)\n        {\n            const int MAX=2*V-1;\n            nodeOrder.resize(MAX);\n            depthOrder.resize(MAX);\n            nodeFirstID.resize(V+1);\n            dfs(root,-1,0);\n            seg.resize(MAX);\n            for(int id=0;id<MAX;id++){\n                seg.set(id,depthOrder[id]);\n            }\n            seg.build();\n        }\n    int id=0;\n    void dfs(int from,int par,int depth){\n        nodeOrder[id]=from;\n        depthOrder[id]=depth;\n        nodeFirstID[from]=id;\n        id++;\n        for(int to:edge[from]){\n            if(to==par) continue;\n            dfs(to,from,depth+1);\n            nodeOrder[id]=from;\n            depthOrder[id]=depth;\n            id++;\n        }\n    }\n    int get(int u,int v){\n        return nodeOrder[seg.get(min(nodeFirstID[u],nodeFirstID[v]),max(nodeFirstID[u],nodeFirstID[v]))];\n    }\n};\n\nint main(){\n    int n; cin>>n;\n    vector<vector<int>> g(n+1);\n    for(int i=0;i<n;i++){\n        int k; cin>>k;\n        while(k--){\n            int c; cin>>c;\n            g[i].push_back(c);\n            g[c].push_back(i);\n        }\n    }\n    LCA lca(n,0,g);\n    int q; cin>>q;\n    while(q--){\n        int u,v; cin>>u>>v;\n        cout<<lca.get(u,v)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <vector>\n\nstruct HLDecomposition {\n  const int N;\n  std::vector<std::vector<int>> tree;\n  std::vector<int> cluster, par, depth, ord, head, offset;\n  HLDecomposition(int N) : N(N), tree(N), cluster(N, -1), par(N, -1), depth(N), ord(N), offset(N) {}\n\n  void add_edge(int u, int v) {\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n  void build(int root = 0) {\n    std::vector<int> Q;\n    Q.reserve(N);\n    Q.push_back(root);\n    for (int i = 0; i < N; i++) {\n      int u = Q[i];\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        par[v] = u;\n        depth[v] = depth[u] + 1;\n        Q.push_back(v);\n      }\n    }\n    std::vector<int> subtree_size(N, 1);\n    for (int i = N - 1; i > 0; i--) {\n      subtree_size[par[Q[i]]] += subtree_size[Q[i]];\n    }\n    std::vector<std::vector<int>> pathes;\n    for (int u : Q) {\n      if (cluster[u] == -1) {\n        cluster[u] = pathes.size();\n        pathes.emplace_back();\n      }\n      pathes[cluster[u]].push_back(u);\n      int max_subsize = -1, selected = -1;\n      for (int v : tree[u]) {\n        if (par[u] == v) continue;\n        if (max_subsize >= subtree_size[v]) continue;\n        max_subsize = subtree_size[v];\n        selected = v;\n      }\n      if (selected != -1) cluster[selected] = cluster[u];\n    }\n    int P = pathes.size();\n    head.resize(P + 1);\n    for (int p = 0; p < P; p++) {\n      int H = head[p];\n      int L = pathes[p].size();\n      head[p + 1] = H + L;\n      for (int i = 0; i < L; i++) {\n        int v = pathes[p][i];\n        offset[v] = i;\n        ord[H + i] = v;\n      }\n    }\n  }\n  void for_each(int u, int v, std::function<void(int, int)> f) const {\n    while (cluster[u] != cluster[v]) {\n      if (depth[ord[head[cluster[u]]]] > depth[ord[head[cluster[v]]]]) std::swap(u, v);\n      int h = head[cluster[v]];\n      f(h, h + offset[v] + 1);\n      v = par[ord[h]];\n    }\n    if (offset[u] > offset[v]) std::swap(u, v);\n    f(head[cluster[u]] + offset[u], head[cluster[v]] + offset[v] + 1);\n  }\n  int lca(int u, int v) const {\n    int x;\n    for_each(u, v, [&](int l, int r) { x = ord[l]; });\n    return x;\n  }\n  std::vector<std::vector<int>> build_pathes() const {\n    const int P = head.size() - 1;\n    std::vector<std::vector<int>> pathes(P);\n    for (int i = 0; i < P; i++) {\n      pathes[i].reserve(head[i + 1] - head[i]);\n      for (int j = head[i]; j < head[i + 1]; j++) {\n        pathes[i].push_back(ord[j]);\n      }\n    }\n    return pathes;\n  }\n};\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n// clang-format off\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}if(m)x=-x;return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n\n#include <iostream>\n\nint main() {\n  int N = rd();\n  HLDecomposition hl(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    for (int j = 0; j < k; j++) {\n      hl.add_edge(i, rd());\n    }\n  }\n  hl.build();\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(hl.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n/* attention\n    long longのシフト演算には気をつけよう\n    タイポした時のデバッグが死ぬほどきつくなるので変数名は最低3字くらい使った方がいいかも\n    sizeは(int)とキャストしよう\n    cin.tie(0);\n    ios::sync_with_stdio(false);<- これら、printfとかと併用しない方が良さそう\n\n*/\n\nconst ll mod = 1e9+7;\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n\n// 線分 ab の偏角 返り値は[-π, π]\ndouble argument(const pair<double, double> &a, const pair<double, double> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n\nstruct LCA {\n    int n; // 頂点数\n    int root; // 根\n    int l; // floor(log(n))\n    vector<vector<int>> const * adj; // 隣接リストへのポインタ\n    vector<vector<int>> parent; // parent[k][v] := v から 2^k 個上にいった頂点の番号（根を通り過ぎるなら -1 ）\n    vector<int> depth;\n\n    // コンストラクタ\n    LCA(int _n, int _root, vector<vector<int>> const * G) :n(_n), root(_root) {\n        adj = G;\n        l = 0;\n        while((1<<l) < n) ++l;\n        parent.resize(l+5, vector<int>(n, 0));\n        depth.resize(n, 0);\n    }\n\n    // 深さをセットする\n    void dfs(int now, int par, int dep) {\n        parent[0][now] = par;\n        depth[now] = dep;\n        for(auto to: (*adj)[now]) if (to != par) dfs(to, now, dep+1);\n    }\n\n    // 初期化\n    void init() {\n        dfs(root, -1, 0);\n        // parent の設定\n        for(int k=0; k+1<l; ++k) {\n            for(int v=0; v<n; ++v) {\n                if (parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    // u と v の LCA を求める\n    int lca(int u, int v) {\n        // 深い方が v になるようにする\n        // u と v の深さが同じになるまで v に先祖を辿らせる\n        if (depth[u] > depth[v]) swap(u, v);\n        for(int k=0; k<l; ++k) {\n            if ((depth[v] - depth[u]) >> k & 1) { v = parent[k][v]; }\n        }\n        if (u == v) return u;\n        // 二分探索で LCA を求める\n        for(int k=l-1; k>=0; --k) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    vector<vector<int>> adj(n);\n    rep(i, n) {\n        int k; cin >> k;\n        rep(j, k) {\n            int c; cin >> c;\n            adj[i].push_back(c);\n            adj[c].push_back(i);\n        }\n    }\n\n    LCA Lca(n, 0, &adj);\n    Lca.init();\n\n    int q; cin >> q;\n    while(q--) {\n        int u, v; cin >> u >> v;\n        cout << Lca.lca(u, v) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int from, to;\n    int64_t cost;\n    Edge(int _to) : from(-1), to(_to), cost(-1) {}\n    Edge(int _to, int64_t _cost) : from(-1), to(_to), cost(_cost) {}\n};\n\nclass LCA {\npublic:\n    const int K = 18;\n    vector<vector<int>> par;\n    vector<int> depth;\n    LCA(const vector<vector<Edge>> &G) {\n        par.assign(K + 1, vector<int>(G.size()));\n        depth.resize(G.size());\n        dfs(G, 0, -1, 0);\n        for(int k = 0; k < K; ++k) {\n            for(int i = 0; i < G.size(); ++i) {\n                if(par[k][i] == -1) par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n    }\n\n    void dfs(const vector<vector<Edge>> &G, int u, int v, int d) {\n        par[0][u] = v;\n        depth[u] = d;\n        for(auto &e : G[u]) {\n            if(e.to != v) dfs(G, e.to, u, d + 1);\n        }\n    }\n\n    int operator()(int u, int v) {\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int i = K - 1; i >= 0; --i) {\n            if((depth[v] - depth[u]) & (1 << i)) v = par[i][v];\n        }\n        if(u == v) return u;\n        for(int i = K - 1; i >= 0; --i) {\n            if(par[i][u] != par[i][v]) {\n                u = par[i][u];\n                v = par[i][v];\n            }\n        }\n        return par[0][u];\n    }\n};\n\nint main() {\n    int N; cin >> N;\n    vector<vector<Edge>> G(N);\n    for(int i = 0; i < N; ++i) {\n        int k; cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c; cin >> c;\n            G[i].emplace_back(c);\n        }\n    }\n    LCA lca(G);\n    int Q; cin >> Q;\n    while(Q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <vector>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> begin, end;\n  std::vector<int> id, depth;\n\n  EulerTour(int N) : T(N), begin(N), end(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) begin[f.u] = id.size();\n      end[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#include <algorithm>\n#include <cassert>\n#include <cstdlib>\n\ntemplate <typename T, bool Min=true>\nstruct FastRMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return Min ^ (A[a] > A[b]);\n    return a < b;\n  }\n  FastRMQ(const std::vector<T>& A) : FastRMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  FastRMQ(const std::vector<T>& A, int N) : FastRMQ(A, N, std::__lg(N) + 1) {}\n  FastRMQ(const std::vector<T>& A, int N, int S) : FastRMQ(A, N, S, (N + S - 1) / S) {}\n  FastRMQ(const std::vector<T>& A, int N, int S, int L) : FastRMQ(A, N, S, L, std::__lg(L) + 1) {}\n  FastRMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <utility>\n\nstruct FastLCA {\n  EulerTour euler_tour;\n  const FastRMQ<int> rmq;\n\n  FastLCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.begin[u];\n    int r = euler_tour.begin[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  FastLCA lca(std::move(et));\n\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nconstexpr int MAX_N=(int)1e5,MAX_LOG_N=17;\n\nint n,q;\n\nstd::vector<int> G[MAX_N];\n\nint parent[MAX_LOG_N][MAX_N],depth[MAX_N];\n\nvoid dfs(int v,int p,int d){\n\tparent[0][v]=p;\n\tdepth[v]=d;\n\tfor(auto& x : G[v]){\n\t\tif(x!=p)\n\t\t\tdfs(x,v,d+1);\n\t}\n}\n\nvoid init(){\n\tdfs(0,-1,0);\n\n\tfor(int i=0;i<MAX_LOG_N-1;++i){\n\t\tfor(int j=0;j<n;++j){\n\t\t\tif(parent[i][j]<0)\n\t\t\t\tparent[i+1][j]=-1;\n\t\t\telse\n\t\t\t\tparent[i+1][j]=parent[i][parent[i][j]];\n\t\t}\n\t}\t\n}\n\nint lca(int u,int v){\n\tif(depth[u]>depth[v])\n\t\tstd::swap(u,v);\n\tfor(int i=0;i<MAX_LOG_N;++i){\n\t\tif(depth[v]-depth[u]>>i & 1)\n\t\t\tv=parent[i][v];\n\t}\n\tif(u==v)\n\t\treturn u;\n\n\tfor(int i=MAX_LOG_N-1;i>=0;--i){\n\t\tif(parent[i][u]!=parent[i][v]){\n\t\t\tu=parent[i][u];\n\t\t\tv=parent[i][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}\n\nint main() {\n\tstd::cin>>n;\n\tint m;\n\tfor(int i=0;i<n;++i){\n\t\tstd::cin>>m;\n\t\tint c;\n\t\tfor(int j=0;j<m;++j){\n\t\t\tstd::cin>>c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tstd::cin>>q;\n\tint u,v;\n\tfor(int i=0;i<q;++i){\n\t\tstd::cin>>u>>v;\n\t\tstd::cout<<lca(u,v)<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int MAX=100000;\nconst int logMAX=17;//2^17>=100000(=MAX)\n\nint V;\nvector<int> G[MAX];\nint root;\nint parent[logMAX][MAX];\nint depth[MAX];\n\nvoid dfs(int v,int p,int d)\n{\n\tparent[0][v]=p;\n\tdepth[v]=d;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tif(G[v][i]!=p)dfs(G[v][i],v,d+1);\n\t}\n\treturn;\n}\n\nvoid init()\n{\n\tdfs(root,-1,0);\n\tfor(int k=0;k+1<logMAX;k++)\n\t{\n\t\tfor(int v=0;v<V;v++)\n\t\t{\n\t\t\tif(parent[k][v]<0)parent[k+1][v]=-1;\n\t\t\telse parent[k+1][v]=parent[k][parent[k][v]];\n\t\t}\n\t}\n\treturn;\n}\n\nint lca(int u,int v)\n{\n\tif(depth[u]>depth[v])swap(u,v);\n\tfor(int k=0;k<logMAX;k++)\n\t{\n\t\tif((depth[v]-depth[u])>>k&1)\n\t\t{\n\t\t\tv=parent[k][v];\n\t\t}\n\t}\n\tif(u==v)return u;\n\tfor(int k=logMAX-1;k>=0;k--)\n\t{\n\t\tif(parent[k][u]!=parent[k][v])\n\t\t{\n\t\t\tu=parent[k][u];\n\t\t\tv=parent[k][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}\n\nint main()\n{\n\tcin>>V;\n\troot=0;\n\tint k,c;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tcin>>c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tinit();\n\tint q;\n\tcin>>q;\n\tint u,v;\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tcout<<lca(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct LowestCommonAncestor{\n  const int MAX_LOG_V = 50;\n  \n  int n;\n  vector<vector<int> > G,par;\n  vector<int> depth;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int sz):\n    n(sz),G(sz),par(MAX_LOG_V,vector<int>(n)),depth(sz){}\n\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    for(int i=0;i<(int)G[v].size();i++){\n      if(G[v][i]!=p) dfs(G[v][i],v,d+1);\n    }\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<MAX_LOG_V;k++){\n      for(int v=0;v<n;v++){\n\tif(par[k][v]<0) par[k+1][v]=-1;\n\telse par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(depth[u]>depth[v]) swap(u,v);\n    for(int k=0;k<MAX_LOG_V;k++){\n      if((depth[v]-depth[u])>>k&1){\n\tv=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=MAX_LOG_V-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n\tu=par[k][u];\n\tv=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return depth[u]+depth[v]-depth[lca(u,v)]*2;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n;\n  cin>>n;\n  LowestCommonAncestor lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/06/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nstruct LowestCommonAncestor {\n\n  int V, MAX_LOG_V;\n  vector<vector<int>> edge;\n\n  vector<vector<int>> parent;\n  vector<int> depth;\n\n  LowestCommonAncestor(int V, int MAX_LOG_V = 17) : V(V), MAX_LOG_V(MAX_LOG_V) {\n    edge.resize(V);\n    parent.resize(MAX_LOG_V);\n    REP(i, MAX_LOG_V) parent[i].resize(V);\n    depth.resize(V);\n  }\n\n  void add_edge(int a, int b) {\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n\n  void dfs(int v, int par, int dep) {\n    parent[0][v] = par;\n    depth[v] = dep;\n    for (auto child : edge[v]) {\n      if (child != par) dfs(child, v, dep + 1);\n    }\n  }\n\n  void init(int root = 0) {\n    dfs(root, -1, 0);\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n      for (int v = 0; v < V; v++) {\n        if (parent[k][v] < 0) {\n          parent[k+1][v] = -1;\n        } else {\n          parent[k+1][v] = parent[k][parent[k][v]];\n        }\n      }\n    }\n  }\n\n  int run(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n      if ((depth[v] - depth[u]) >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    if (u == v) return u;\n\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n\n  int get_cntup_node(int v, int cnt) {\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n      if (cnt >> k & 1) {\n        v = parent[k][v];\n      }\n    }\n    return v;\n  }\n};\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  LowestCommonAncestor lca(N);\n  REP(i, N) {\n    int K; cin >> K;\n    REP(_, K) {\n      int c; cin >> c;\n      lca.add_edge(i, c);\n    }\n  }\n\n  lca.init();\n\n  int Q; cin >> Q;\n  REP(i, Q) {\n    int u, v; cin >> u >> v;\n    int anc = lca.run(u, v);\n    cout << anc << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\nusing namespace std;\n\n\n//初期化O(n log n) 区間最小値クエリO(1)\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\nclass LCA{\n\tvector<pair<int,int> > eulertour;\n\tvector<int> vertex;\n\tSparseTableRMQ rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u].first=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t\tif(edge[u].empty()){\n\t\t\teulertour[u].second=vertex.size();\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,0,root);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(eulertour[u].first<eulertour[v].first && eulertour[v].second<eulertour[u].second)\n\t\t\treturn u;\n\t\tif(eulertour[v].first<eulertour[u].first && eulertour[u].second<eulertour[v].second)\n\t\t\treturn v;\n\t\tif(eulertour[u].first>eulertour[v].first)swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u].second, eulertour[v].first)];\n\t}\n};\n\n\nvector<int> edge[100000];\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 200;\nint color[100010],  par[100010], depth[100010];\nint top[100010];\nint goUp[100010];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = false, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(!vis[c]){\n                q.push(c);\n                par[c] = v;\n                depth[c] = depth[v] + 1;\n            }\n        }\n    }\n    rep(i,n) vis[i] = false;\n    int c = 0;\n    for(int u : tord){\n        if(vis[u]) continue;\n        q.push(u);\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[u];\n            top[v] = u;\n            k++;\n            for(int c : g[v]){\n                if(!vis[c]) q.push(c);\n            }\n        }\n        while(q.size()) q.pop();\n        c++;\n    }\n    // rep(i,n) printf(\"v:%d col:%d dep:%d\\n\", i, color[i], depth[i]);\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        // cout << u << \" \" << v << endl;\n        assert(u != -1 && v != -1);\n        if(depth[top[u]] > depth[top[v]]) u = goUp[u];\n        else v = goUp[v];\n    }\n    while(u != v){\n        assert(u != -1 && v != -1);\n        if(depth[u] > depth[v]) u = par[u];\n        else v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct SegmentTree {\n  vector< int > data;\n  vector< bool > zero;\n  int n;\n  SegmentTree(int sz) {\n    n = 1;\n    while(n < sz) n *= 2;\n    data.assign(2 * n + 1, 0);\n    zero.assign(2 * n + 1, false);\n    for(int i = 0; i < sz; i++) {\n      data[i + n - 1] = 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n      data[i] = data[2 * i + 1] + data[2 * i + 2];\n    }\n  }\n  void Clear(int a, int b, int k, int l, int r) {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      zero[k] = true;\n    } else {\n      Clear(a, b, 2 * k + 1, l, (l + r) >> 1);\n      Clear(a, b, 2 * k + 2, (l + r) >> 1, r);\n      data[k] = 0;\n      if(!zero[2 * k + 1]) data[k] += data[2 * k + 1];\n      if(!zero[2 * k + 2]) data[k] += data[2 * k + 2];\n    }\n  }\n  void Clear(int a, int b) {\n    return(Clear(a + 1, b + 1, 0, 0, n));\n  }\n  int Query(int a, int b, int k, int l, int r) {\n    if(a >= r || b <= l) return(0);\n    if(zero[k]) return(0);\n    if(a <= l && r <= b) return(data[k]);\n    return(Query(a, b, 2 * k + 1, l, (l + r) >> 1) + Query(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n  int Query(int a, int b) {\n    return(Query(a + 1, b + 1, 0, 0, n));\n  }\n};\n\nstruct Node {\n  int ParIdx, ParDepth, Deep; // Deep: HeavyEdge?????§?????±???\n  int Size;\n  vector< int > Nodes;\n};\ntypedef vector< vector< int > > Graph;\n\nint N, Q, x[100000];\nGraph graph;\n\nint treesz[100000], sz;\nNode nodes[100000];\nint nowtreeIdx[100000], nowtreeDepth[100000]; \nvector< SegmentTree > segs;\n\nint sizeDFS(int idx, int prev) {\n  treesz[idx] = 1;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) treesz[idx] += sizeDFS(graph[idx][i], idx);\n  }\n  return(treesz[idx]);\n}\nvoid makeDFS(int idx, int prev, int treeIdx, int treeDepth, int ParDepth) {\n  nodes[treeIdx].Size++;\n  nodes[treeIdx].Nodes.push_back(idx);\n  nowtreeIdx[idx] = treeIdx;\n  nowtreeDepth[idx] = treeDepth;\n  int ret = 0;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) ret = max(ret, treesz[graph[idx][i]]);\n  }\n  bool done = false;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) {\n      if(!done && treesz[graph[idx][i]] == ret && !done++) {\n        makeDFS(graph[idx][i], idx, treeIdx, treeDepth + 1, ParDepth);\n      } else {\n        nodes[sz++] = (Node){ treeIdx, treeDepth, ParDepth + 1, 0};\n        makeDFS(graph[idx][i], idx, sz - 1, 0, ParDepth + 1);\n      }\n    }\n  }\n}\nvoid HL() { // ??????????§£\n  sizeDFS(0, -1);\n  sz = 0;\n  nodes[sz++] = (Node){ -1, -1, 0, 0};\n  makeDFS(0, -1, 0, 0, 0);\n  for(int i = 0; i < sz; i++) {\n    segs.push_back(SegmentTree(nodes[i].Size));\n  }\n}\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  graph.resize(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      graph[i].push_back(c);\n    }\n  }\n  HL();\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n\n    int TreeIdxA = nowtreeIdx[u], TreeDepthA = nowtreeDepth[u];\n    int TreeIdxB = nowtreeIdx[v], TreeDepthB = nowtreeDepth[v];\n    while(TreeIdxA != TreeIdxB) {\n      if(nodes[TreeIdxA].Deep > nodes[TreeIdxB].Deep) {\n        TreeDepthA = nodes[TreeIdxA].ParDepth;\n        TreeIdxA   = nodes[TreeIdxA].ParIdx;\n      } else {\n        TreeDepthB = nodes[TreeIdxB].ParDepth;\n        TreeIdxB   = nodes[TreeIdxB].ParIdx;\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    cout << nodes[TreeIdxA].Nodes[TreeDepthA] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define mod 1000000007\n#define INF 1145141919810364364\n#define int long long\n#define all(vec) vec.begin(),vec.end()\n#define P pair<int,int>\n#define S second\n#define F first\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nbool prime(int x) {\n\tfor (int i = 2; i <= sqrt(x); i++) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nint kai(int x, int y) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= mod;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y) {\n\tif (y > x)return 0;\n\treturn kai(x, y) * mod_pow(kai(y, y), mod - 2, mod) % mod;\n}\n\nint n, q;\nvector<int> vec[100010];\nint nex[20][100010];\nint d[100010];\n\nvoid bfs() {\n\tqueue<P> que;\n\td[0] = 0;\n\tque.push({ 0,0 });\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\tint t = p.second;\n\t\tfor (int i = 0; i < vec[t].size(); i++) {\n\t\t\td[vec[t][i]] = p.first + 1;\n\t\t\tque.push({ p.first + 1,vec[t][i] });\n\t\t}\n\t}\n}\n\nint query(int a, int b) {\n\tif (d[a] > d[b])swap(a, b);\n\tint t = d[b] - d[a];\n\tfor (int i = 0; i <= log2(n); i++)if (t&(1 << i))b = nex[i][b];\n\tif (a == b)return a;\n\tfor (int i = log2(n); i >= 0; i--) {\n\t\tif (nex[i][a] != nex[i][b]) {\n\t\t\ta = nex[i][a];\n\t\t\tb = nex[i][b];\n\t\t}\n\t}\n\treturn nex[0][a];\n}\n\nsigned main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; \n\t\t\tcin >> c;\n\t\t\tvec[i].push_back(c);\n\t\t\tnex[0][c] = i;\n\t\t}\n\t}\n\tnex[0][0] = -1;\n\tfor (int i = 1; i <= log2(n); i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (nex[i - 1][j] == -1)nex[i][j] = -1;\n\t\t\telse nex[i][j] = nex[i - 1][nex[i - 1][j]];\n\t\t}\n\t}\n\tbfs();\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tcout << query(a, b) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\nconst int LOG_N = 17;\n\nvector<int> G[MAX_N];\n\nint par[LOG_N][MAX_N];\nint depth[MAX_N];\n\nvoid dfs(int u,int p,int d)\n{\n    par[0][u] = p;\n    depth[u] = d;\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            dfs(G[u][i],u,d+1);\n        }\n    }\n}\n\nint lca(int u,int v)\n{\n    if(depth[u] > depth[v]){\n        swap(u,v);\n    }\n    rep(i,LOG_N){\n        if((depth[v] - depth[u]) >> i & 1){\n            v = par[i][v];\n        }\n    }\n    if(u == v){\n        return u;\n    }\n    for(int i=LOG_N-1;i>=0;i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,-1,0);\n    rep(i,LOG_N-1){\n        rep(j,n){\n            if(par[i][j] < 0){\n                par[i+1][j] = -1;\n            }else{\n                par[i+1][j] = par[i][par[i][j]];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        printf(\"%d\\n\",lca(x,y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst int MAXN = 100005;\n\nint path[2*MAXN], depth[2*MAXN], idx[MAXN];     // idx : the index of node in dfs path\n\nint par[MAXN];\nvi adjList[MAXN];\n\nclass SparseTable{\nprivate:\n    int n, h;\n    vvi t;\n\n    int combine(int l, int r){\n        if (l == -1 || r == -1) return max(l,r);\n\n        return depth[l] < depth[r] ? l : r;\n    }\npublic:\n    SparseTable(int size){\n        n = size; h = ceil(log2(n));\n        t.assign(h, vi());\n\n        t[0].assign(n,0);\n        for (int i=0; i<n; i++) t[0][i] = i;\n        for (int i=1; i<h; i++){\n            t[i].assign(n,0);\n            for (int j=0; j+(1<<i)<=n; j++){\n                t[i][j] = combine(t[i-1][j],t[i-1][j+(1<<(i-1))]);\n            }\n        }\n    }\n    int query(int l, int r){                            // query in range v[l,r]\n        int p = 31 - __builtin_clz(r-l+1);\n        return combine(t[p][l],t[p][r-(1<<p)+1]);\n    }\n};\n\nint cnt = 0;\n\n// build dfs path, depth\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n    path[cnt] = curr;\n    depth[cnt++] = d;\n    for (int i=0; i<adjList[curr].size(); i++){\n        dfs(adjList[curr][i],d+1);\n\n        path[cnt] = curr;\n        depth[cnt++] = d;\n    }\n}\nint N, M, Q, v;\n\nint main(){\n\n    memset(par,-1,sizeof(par));\n\n    scanf(\"%d\",&N);\n    for (int u=0; u<N; u++){\n        scanf(\"%d\",&M);\n\n        for (int i=0; i<M; i++){\n            scanf(\"%d\",&v);\n\n            par[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    int root;\n    for (int i=0; i<N; i++) if (par[i] == -1) root = i;\n    \n    dfs(root,0);\n\n    SparseTable st(cnt);\n    \n    scanf(\"%d\",&Q);\n    for (int i=0; i<Q; i++){\n        int u, v, l, r;\n        scanf(\"%d%d\",&u,&v);\n\n        l = idx[u];\n        r = idx[v];\n        if (l > r) swap(l,r);\n\n        int id = st.query(l,r);\n        printf(\"%d\\n\",path[id]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass LCA{\npublic:\n    int n,root,log2_n;\n    vector<vector<int>> parent; // parent[i][v]:=vから2^i回親を辿ったノード\n    vector<int> depth;\n\n    LCA(){}\n    /* g:graph, r:root */\n    LCA(const vector<vector<int>>& g,int r){\n        init(g,r);\n    }\n    void init(const vector<vector<int>>& g,int r){\n        n = g.size();\n        log2_n = log2(n)+1;\n        root = r;\n        parent = vector<vector<int>>(log2_n,vector<int>(n));\n        depth = vector<int>(n);\n        dfs(g,root,-1,0);   // parent[0],depthの初期化\n        // parentの計算\n        for(int k=0;k+1<log2_n;k++){\n            for(int v=0;v<n;v++){\n                if(parent[k][v]<0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n    void dfs(const vector<vector<int>>& G,int v,int p,int d){\n        parent[0][v] = p;\n        depth[v] = d;\n        for(const auto& u : G[v]){\n            if(u != p) dfs(G,u,v,d+1);\n        }\n    }\n\n    int get(int u,int v){\n        if(depth[u]>depth[v])swap(u,v);\n        for(int k=0;k<log2_n;k++){\n            if((depth[v]-depth[u]) >> k & 1){\n                v = parent[k][v];\n            }\n        }\n        if(u==v) return u;\n        for(int k=log2_n-1;k>=0;k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\nint main(){\n    int n; cin >> n;\n    vector<vector<int>> G(n);\n    for(int i=0;i<n;i++){\n        int k; cin >> k;\n        for(int j=0;j<k;j++){\n            int u; cin >> u;\n            G[i].push_back(u);\n        }\n    }\n    LCA lca(G,0);\n    int q; cin >> q;\n    for(int i=0;i<q;i++){\n        int u,v; cin >> u >> v;\n        int ans = lca.get(u,v);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef VVI Graph;\n\nGraph G;\nconst int N = 100000;\nconst int LOG_N = 350;\nint depth[N];\nint parent[LOG_N][N];\nvoid dfs(int node ,int p = -1, int d = 0)\n{\n  if(depth[node] >= 0) return;\n  depth[node] = d;\n  parent[0][node] = p;\n  for(int i=0;i<SZ(G[node]);++i)\n\tdfs(G[node][i], node, d+1);\n}\n\nvoid init(int V){\n  fill(depth, depth+N, -1);\n  dfs(0);\n  for(int i=0;i+1<LOG_N;++i){\n\tfor(int v=0;v<V;++v){\n\t  if(parent[i][v] == -1) parent[i+1][v] = -1;\n\t  else parent[i+1][v] = parent[i][parent[i][v]];\n\t}\n  }\n}\n\nint LCA(int u, int v){\n  if(depth[u] > depth[v]) swap(u, v);\n  //depth[u] <= depth[v]\n  for(int i=0;i<LOG_N;++i)\n\tif((depth[v] - depth[u]) >> i & 1)\n\t  v = parent[i][v];\n  if(u == v) return u;\n\n  for(int i=LOG_N-1;i>=0;--i){\n\tif(parent[i][u] != parent[i][v]){\n\t  u = parent[i][u];\n\t  v = parent[i][v];\n\t}\n  }\n  return parent[0][u];\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V; cin >> V;\n  G.assign(V, VI());\n  REP(i,V){\n\tint k; cin >> k;\n\tREP(j,k){\n\t  int c; cin >> c;\n\t  G[i].PB(c);\n\t}\n  }\n  init(V);\n  int Q; cin >> Q;\n  while(Q--){\n\tint u, v; cin >> u >> v;\n\tcout << LCA(u,v) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct LowestCommonAncestor{\n  const int MAX_LOG_V = 50;\n  \n  vector<vector<int> > G,parent;\n  int root=0,V;\n  vector<int> depth;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int V):V(V){init();}\n\n  void init(){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    for(int i=0;i<(int)parent.size();i++) parent[i].clear();\n    parent.clear();\n    depth.clear();\n    G.resize(V);\n    parent.resize(MAX_LOG_V,vector<int>(V));\n    depth.resize(V);\n  }\n\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    parent[0][v]=p;\n    depth[v]=d;\n    for(int i=0;i<(int)G[v].size();i++){\n      if(G[v][i]!=p) dfs(G[v][i],v,d+1);\n    }\n  }\n  \n  void construct(){\n    dfs(root,-1,0);\n    for(int k=0;k+1<MAX_LOG_V;k++){\n      for(int v=0;v<V;v++){\n\tif(parent[k][v]<0) parent[k+1][v]=-1;\n\telse parent[k+1][v]=parent[k][parent[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(depth[u]>depth[v]) swap(u,v);\n    for(int k=0;k<MAX_LOG_V;k++){\n      if((depth[v]-depth[u])>>k&1){\n\tv=parent[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=MAX_LOG_V-1;k>=0;k--){\n      if(parent[k][u]!=parent[k][v]){\n\tu=parent[k][u];\n\tv=parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n;\n  cin>>n;\n  LowestCommonAncestor lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.construct();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/06/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_A&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nvector<int> G[100001];\nint N;\nint root;\nint MAX_LOG_V = 17;\nint POW[18];\n\nint** parent;\nint* depth;\n\nvoid dfs(int node_id,int parent_id,int d){\n\tparent[0][node_id] = parent_id;\n\tdepth[node_id] = d;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i] != parent_id)dfs(G[node_id][i],node_id,d+1);\n\t}\n}\n\n//?????????\nvoid init(){\n\n\tdfs(root,-1,0);\n\n\tfor(int k = 0; k + 1 < MAX_LOG_V; k++){\n\t\tfor(int node_id = 0; node_id < N; node_id++){\n\t\t\tif(parent[k][node_id] < 0)parent[k+1][node_id] = -1;\n\t\t\telse{\n\t\t\t\tparent[k+1][node_id] = parent[k][parent[k][node_id]];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint lca(int left,int right){\n\n\tif(depth[left] > depth[right])swap(left,right);\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(depth[right]-depth[left] >= POW[k]){\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\n\tif(left == right)return left;\n\n\tfor(int k = MAX_LOG_V-1; k >= 0; k--){\n\t\tif(parent[k][left] == parent[k][right]){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tleft = parent[k][left];\n\t\t\tright = parent[k][right];\n\t\t}\n\t}\n\treturn parent[0][left];\n}\n\n\n\nint main(){\n\n\tfor(int i = 0; i <= 17; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d\",&N);\n\n\tint num,child;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&num);\n\t\tfor(int k = 0; k < num; k++){\n\t\t\tscanf(\"%d\",&child);\n\t\t\tG[i].push_back(child);\n\t\t}\n\t}\n\n\tparent = new int*[MAX_LOG_V];\n\tfor(int i = 0; i < MAX_LOG_V;i++)parent[i] = new int[N];\n\tdepth = new int[N];\n\troot = 0;\n\tinit();\n\n\tint Q;\n\tscanf(\"%d\",&Q);\n\n\tint left,right;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\",&left,&right);\n\t\tprintf(\"%d\\n\",lca(left,right));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\n\nint n,q,l,sec,st[maxn],ed[maxn];\nvector<vector<int>>up;\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n\tst[u]=sec++;\n\tup[u][0]=p;\n\tfor (int i=1;i<=l;i++) \n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\tfor (int v:G[u])\n\t\tif (v!=p) dfs(v,u);\n\ted[u]=sec;\n}\n\nbool upper(int u,int v) {\n\treturn st[u]<st[v] && ed[u]>=ed[v];\n}\n\nint lca(int u,int v) {\n\tif (u==v) return u;\n\tif (upper(u,v)) return u;\n\tif (upper(v,u)) return v;\n\tfor (int i=l;i>=0;i--) \n\t\tif (!upper(up[u][i],v))\n\t\t\tu=up[u][i];\n\treturn up[u][0];\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i=0;i<n;i++) {\n\t\tint m; cin>>m;\n\t\tfor (int j=0;j<m;j++) {\n\t\t\tint v; cin>>v;\n\t\t\tG[i].pb(v);\n\t\t}\n\t}\n\twhile ((1<<l)<=n) l++;\n\t up.assign(n, vector<int>(l + 1));\n\tdfs(0,0);\n\tcin>>q;\n\tfor (int i=0;i<q;i++) {\n\t\tint u,v; cin>>u>>v;\n\t\tcout<<lca(u,v)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\nconst int LOG_N = 17;\n\nvector<int> G[MAX_N];\n\nint par[LOG_N][MAX_N];\nint depth[MAX_N];\n\nvoid dfs(int u,int p,int d)\n{\n    par[0][u] = p;\n    depth[u] = d;\n    rep(i,G[u].size()){\n        if(G[u][i] != p){\n            dfs(G[u][i],u,d+1);\n        }\n    }\n}\n\nint lca(int u,int v)\n{\n    if(depth[u] > depth[v]){\n        swap(u,v);\n    }\n    rep(i,LOG_N){\n        if((depth[v] - depth[u]) & (1 << i)){\n            v = par[i][v];\n        }\n    }\n    if(u == v){\n        return u;\n    }\n    for(int i=LOG_N-1;i>=0;i--){\n        if(par[i][u] != par[i][v]){\n            u = par[i][u];\n            v = par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    rep(i,n){\n        int m;\n        scanf(\"%d\",&m);\n        rep(j,m){\n            int x;\n            scanf(\"%d\",&x);\n            G[i].pb(x);\n        }\n    }\n    dfs(0,-1,0);\n    rep(i,LOG_N-1){\n        rep(j,n){\n            if(par[i][j] < 0){\n                par[i+1][j] = -1;\n            }else{\n                par[i+1][j] = par[i][par[i][j]];\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        printf(\"%d\\n\",lca(x,y));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 100005\n\n\nstruct myque{\n  int l,r;\n  int t[MAX_V];\n  void clear(){l=r=0;}\n  void pop(){l++;}\n  void push(int x){t[r++]=x;}\n  int front(){return t[l];}\n  bool empty(){return (l==r);}\n};\n\nmyque que;\nint pa[MAX_V],de[MAX_V],sz[MAX_V];\nint cd[MAX_V],mv[MAX_V],hl[MAX_V];\n\nint V;\nvector<int> G[MAX_V];\n\nvoid HLD(int root=0){\n  que.clear();\n  for(int i=0;i<V;i++){\n    sz[i]=1;\n    pa[i]=cd[i]=mv[i]=i;\n    hl[i]=G[i].size();\n    if(i==root)continue;\n    if(hl[i]!=1)continue;\n    que.push(i);\n  }\n  // calc sz[] cd[] pa[]\n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    if(pos==root)continue;\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(pa[to]==pos)continue;\n      pa[pos]=to;\n      sz[to]+=sz[pos];           \n      if(cd[to]==to)cd[to]=pos;\n      if(sz[cd[to]]<sz[pos])cd[to]=pos;\n      hl[to]--;\n      if(hl[to]==1)que.push(to);\n    }\n  }\n\n  // calc hl[] de[] mv[]\n  que.clear();\n  que.push(root);\n  de[root]=hl[root]=0;\n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    if(cd[pos]==pos)continue;\n    mv[cd[pos]]=mv[pos];\n    hl[cd[pos]]=hl[pos]+1;\n    int sum=hl[pos]+1+sz[cd[pos]];\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(to==pa[pos])continue;\n      que.push(to);\n      de[to]=de[pos]+1;\n      if(to==cd[pos])continue;\n      hl[to]=sum;\n      sum+=sz[to];\n    }\n  }\n}\n\nint lca(int a,int b){\n  while(mv[a]!=mv[b]){\n    if(mv[a]<mv[b])swap(a,b);\n    a=pa[mv[a]];\n  }\n  return (de[a]<de[b]?a:b);\n}\n\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\n\nint main(){\n  scanf(\"%d\",&V);\n\n  for(int i=0;i<V;i++){\n    int size,ch;\n    scanf(\"%d\",&size);\n    while(size--){\n      scanf(\"%d\",&ch);\n      add_edge(i,ch);\n    }\n  }\n  HLD(0);\n  /*\n  for(int i=0;i<V;i++){\n    cout<< (char)('A'+i) <<endl;\n    cout<<\" hl = \"<< hl[i] <<\" , \";\n    cout<<\" sz = \"<< sz[i] <<\" , \";\n    cout<<\" de = \"<< de[i] <<\" , \";\n    cout<<\" pa = \"<< (char)('A'+pa[i]) <<\" , \";\n    cout<<\" cd = \"<< (char)('A'+cd[i]) <<\" , \";\n    cout<<\" mv = \"<< (char)('A'+mv[i]) <<\" , \";\n    cout<<endl;\n  }\n  */\n  int a,b,Q;\n  scanf(\"%d\",&Q);\n  while(Q--){\n    scanf(\"%d %d\",&a,&b);\n    printf(\"%d\\n\",lca(a,b));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nint Count;\nvoid dfs(int n,int dep,vector<vector<int>>& T,vector<int>& ET,vector<bool>& f,vector<int>& index) {\n\tf[n] = true;\n\tET.emplace_back(dep);\n\tindex[n] = Count; Count++;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1, T, ET, f,index);\n\t\tET.emplace_back(dep);\n\t\tCount++;\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<int> index(n);\n\tvector<bool> f(n,false);\n\tvector<vector<int>> T(n);\n\tvector<int> ET;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\tdfs(0,0, T, ET, f,index);\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << *min_element(ET.begin() + index[u], ET.begin() + index[v]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <random>\n#include <cstdlib>\n#define INT_MAX 2147483647\n#define INT_MIN -2147483646\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\nusing namespace std;\ntypedef long long int ll;\n\nstruct node {\n\tint p;\n\tint d;\n};\n\nvector<node> T(100005);\n\nint main() {\n\tint n;\n\tcin >> n;\n\tLoop(i, 100005) {\n\t\tT[i] = { 0,0 };\n\t}\n\tLoop(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\tLoop(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tT[c].p = i;\n\t\t\tT[c].d = T[i].d + 1;\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\tLoop(i, q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (T[u].d < T[v].d) {\n\t\t\twhile (T[u].d < T[v].d) {\n\t\t\t\tv = T[v].p;\n\t\t\t}\n\t\t}\n\t\telse if (T[u].d > T[v].d) {\n\t\t\twhile (T[u].d > T[v].d) {\n\t\t\t\tu = T[u].p;\n\t\t\t}\n\t\t}\n\t\twhile (u != v) {\n\t\t\tu = T[u].p;\n\t\t\tv = T[v].p;\n\t\t}\n\t\tcout << u << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) ord[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size) {for(int i=0;i<size;i++)data[i]=i;}\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    //if (x != y) {\n      //if (data[y] < data[x]) swap(x, y);\n      //data[x] += data[y];\n\t  data[y] = x;\n    //}\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x]==x ? x : (data[x] = root(data[x]));\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n  vector<vector<int> > tree;\n\n  HeavyLight(vector<vector<int> > t)\n    :pathCount(0),n(t.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n),tree(t){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n#define ld long double\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Heavy Light Deconposition\n//-------------------------------------------------\nclass HLD\n{\nprivate:\n    using Graph = ::std::vector<::std::vector<int> >;\n    int n;\n    Graph g;\n    ::std::vector<int> par, weight, depth;\n    ::std::vector<int> head;\n    ::std::vector<int> next;\n    ::std::vector<int> chain, at;\n    ::std::vector<::std::vector<int> > chains;\n    void init(){\n        par.resize(n);\n        weight.resize(n);\n        depth.resize(n);\n        next.resize(n);\n        chain.resize(n);\n        at.resize(n);\n        head.resize(n);\n    }\n    void dfs(Graph &g_){\n        par[0] = -1;\n        depth[0] = 0;\n        using P = ::std::pair<int,int>;\n        ::std::stack<P> st;\n        st.emplace(0,0);\n        while(!st.empty()){\n            int v = st.top().first;\n            int &idx = st.top().second;\n            if (idx < g_[v].size()){\n                int u = g_[v][idx++];\n                if (u==par[v]) continue;\n                par[u] = v;\n                depth[u] = depth[v]+1;\n                st.emplace(u,0);\n            }else{\n                st.pop();\n                int heavy = 0;\n                weight[v] = 1;\n                for(auto u:g_[v]){\n                    if (u==par[v]) continue;\n                    weight[v]+=weight[u];\n                    if (weight[u]>heavy){\n                        heavy = weight[u];\n                        next[v] = u;\n                    }\n                }\n            }\n        }\n    }\n    void bfs(Graph &g_){\n        int idx=0;\n        using P = ::std::pair<int,int>;\n        ::std::queue<P> que;\n        que.emplace(0,idx++);\n        chains.push_back(::std::vector<int>());\n        while(!que.empty()){\n            int v,c;\n            tie(v,c) = que.front(); que.pop();\n            chain[v] = c;\n            at[v] = chains[c].size();\n            chains[c].push_back(v);\n            head[v] = chains[c].front();\n            for(auto u:g_[v]){\n                if (u==par[v]) continue;\n                if (u==next[v]){\n                    que.emplace(u,c);\n                }else{\n                    que.emplace(u,idx++);\n                    chains.push_back(::std::vector<int>());\n                }\n            }\n        }\n    }\n    int climb(int v){return par[head[v]];};\npublic:\n    HLD(Graph &g_):n(g_.size()){\n        init();\n        build(g_);\n    }\n    HLD(int n_):n(n_),g(n_){init();}\n    void add_edge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    void build(){\n        dfs(g);\n        bfs(g);\n    }\n    void build(Graph &g_){\n        dfs(g_);\n        bfs(g_);\n    }\n    int lca(int u, int v){\n        while(head[u]!=head[v]){\n            if (depth[head[u]] > depth[head[v]]){\n                u = climb(u);\n            }else{\n                v = climb(v);\n            }\n        }\n        return (depth[u]<depth[v])?u:v;\n    }\n};\n\n\n//-------------------------------------------------\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin>>n;\n    vector<vi> adj(n);\n    HLD hld(n);\n    rep(i,n){\n        int k; cin>>k;\n        rep(j,k){\n            int c; cin>>c;\n            hld.add_edge(i,c);\n        }\n    }\n    hld.build();\n    int q; cin>>q;\n    while(q--){\n        int u,v; cin>>u>>v;\n        cout<<hld.lca(u,v)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs=vector<int>(1,0)) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int,int>;\n    stack<T> st;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v=st.top().first;\n      int &i=st.top().second;\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tint res=0;\n\tfor(int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if (vid[u] > vid[v]) swap(u, v);\n      f(max(vid[head[v]], vid[u]), vid[v]);\n      if (head[u] != head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] != head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/11/07\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n/*\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned main(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/11/07\nhttps://yukicoder.me/problems/no/529\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nusing P=pair<int,int>;\nconst int INF=1<<29;\nconst int MAX_V=10010;\nvector<int> children[MAX_V];\n\nint dep[100010];\nint par[100010][20];\nvoid dfs(int node,int p,int d){\n  dep[node]=d;\n  for(int child:children[node]){\n    if(child==p)continue;\n    par[child][0]=node;\n    dfs(child,node,d+1);\n  }\n}\nint lca(int a,int b){\n  if(dep[a]<dep[b])swap(a,b);\n  REP(i,20) if((dep[a]-dep[b])&(1<<i))a=par[a][i];\n  if(a==b)return a;\n  for(int i=19;i>=0;i--) if(par[a][i]!=par[b][i]) a=par[a][i],b=par[b][i];\n  return par[a][0];\n}\n\nint main(){_;\n  int n,q,k,u,v;\n  cin>>n;\n  REP(i,n){\n    cin>>k;\n    children[i]=vector<int>(k);\n    REP(j,k)cin>>children[i][j];\n  }\n  dfs(0,-1,0);\n  REP(i,19) REP(j,n) par[j][i+1]=par[par[j][i]][i];\n  cin>>q;\n  REP(i,q){\n    cin>>u>>v;\n    cout<<lca(u,v)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100001];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nint sub(int idx)\n{\n  sz[idx] = 1;\n  for(auto &to : g[idx]) sz[idx] += sub(to);\n  return (sz[idx]);\n}\n\nvoid dfs(int idx, bool keep)\n{\n  if(g[idx].empty()) {\n    if(keep) for(int &v : query[idx]) buf[v] = true;\n    return;\n  }\n\n  int heavy = g[idx][0];\n  for(auto &to : g[idx]) if(sz[to] > sz[heavy]) heavy = to;\n  for(auto &to : g[idx]) if(heavy != to) dfs(to, false);\n  dfs(heavy, true);\n  query[idx].swap(query[heavy]);\n\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(buf[v]) lca[v] = idx;\n    }\n    for(int &v : query[to]) {\n      if(~lca[v]) continue;\n      buf[v] = true;\n      query[idx].push_back(v);\n    }\n  }\n\n  if(!keep) {\n    //  for(auto &v : query[idx]) buf[v] = false;\n  }\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n\n  memset(lca, -1, sizeof(lca));\n\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n\n  sub(0);\n  dfs(0, false);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nusing Weight = int;\nstruct Edge {\n\tint s, d; Weight w;\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//LCA: Lowest Common Ancestor (??????????????° + dfs????????°)\nstruct LowestCommonAncestor {\n\tconst int n, log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\tLowestCommonAncestor(const Graph &g, int root)\n\t\t:n(g.size()), log2_n(log2(n) + 1), parent(log2_n, vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph &g, int s, int p, int d) {\n\t\tparent[0][s] = p;\n\t\tdepth[s] = d;\n\t\tfor (auto &e : g[s]) {\n\t\t\tif (e.d == p)continue;\n\t\t\tdfs(g, e.d, s, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tGraph g(n);\n\trep(i, 0, n) {\n\t\tint k; cin >> k;\n\t\trep(j, 0, k) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(i, c);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tLowestCommonAncestor lca(g, 0);\n\trep(i, 0, q) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << lca.get(u, v) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\n\nint N,Q;\nvector<int> g[MAX_N+5];\nint root;\nint depth[MAX_N+5];\nint par[21][MAX_N];\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    for(int u=0;u<g[v].size();++u){\n        if(g[v][u]!=p)dfs(g[v][u],v,d+1);\n    }\n}\n\nvoid fill_table(){\n    dfs(root,-1,0);\n    for(int i=0;i+1<20;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nint LCA(int u,int v){\n    if(depth[u]>depth[v])swap(u,v);\n    for(int i=0;i<20;++i){\n        if((depth[v]-depth[u])>>i&1)v=par[i][v];\n    }\n    if(v==u)return u;\n    for(int i=20;i>=0;--i){\n        if(par[i][v]!=par[i][v]){\n            u=par[i][u];\n            v=par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;++j){\n            int c;\n            cin>>c;\n            g[i].PB(c);\n        }\n    }\n    fill_table();\n    cin>>Q;\n    while(Q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<LCA(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pi = pair<int, int>;\n\ntemplate <typename T>\nclass SparseTable {\n\tusing func_t = function<T(T, T)>;\n\tint n;\n\tfunc_t merge;\n\tvector<vector<T>> t;\n\tint clz(unsigned int w) {\n\t\treturn (w & 0xffff0000) ? (w & 0xff000000) ? (w & 0xf0000000) ? (w & 0xc0000000) ? (w & 0x80000000) ? 0 : 1 : (w & 0xe0000000) ? 2 : 3 : (w & 0xfc000000) ? (w & 0xf8000000) ? 4 : 5 : (w & 0xfe000000) ? 6 : 7 : (w & 0xfff00000) ? (w & 0xffc00000) ? (w & 0xff800000) ? 8 : 9 : (w & 0xffe00000) ? 10 : 11 : (w & 0xfffc0000) ? (w & 0xfff80000) ? 12 : 13 : (w & 0xfffe0000) ? 14 : 15 : (w & 0xffffff00) ? (w & 0xfffff000) ? (w & 0xffffc000) ? (w & 0xffff8000) ? 16 : 17 : (w & 0xffffe000) ? 18 : 19 : (w & 0xfffffc00) ? (w & 0xfffff800) ? 20 : 21 : (w & 0xfffffe00) ? 22 : 23 : (w & 0xfffffff0) ? (w & 0xffffffc0) ? (w & 0xffffff80) ? 24 : 25 : (w & 0xffffffe0) ? 26 : 27 : (w & 0xfffffffc) ? (w & 0xfffffff8) ? 28 : 29 : (w & 0xfffffffe) ? 30 : 31;\n\t}\npublic:\n\tSparseTable() {}\n\tSparseTable(const vector<T>& b, func_t mq = [](T l, T r) { return min(l, r); }) : merge(mq) {\n\t\tn = b.size();\n\t\tt.push_back(b);\n\t\tfor (int i = 2, j = 1; i <= n; i <<= 1, j++) {\n\t\t\tt.push_back(vector<T>());\n\t\t\tfor (int k = 0; k + i <= n; k++) {\n\t\t\t\tt[j].push_back(merge(t[j - 1][k], t[j - 1][k + i / 2]));\n\t\t\t}\n\t\t}\n\t}\n\tT find(int l, int r) {\n\t\tr++;\n\t\tassert(l < r);\n\t\tunsigned int w = r - l;\n\t\tint i = 31 - clz(w);\n\t\treturn merge(t[i][l], t[i][r - (1 << i)]);\n\t}\n\tT operator[](int id) {\n\t\treturn t[0][id];\n\t}\n};\n\nclass LCA {\n\tint V, rt;\n\tvector<vector<int>> G;\n\tvector<int> depth, used, id;\n\tvector<int> vs, de;\n\tSparseTable<pi> st;\n\tvoid dfs(int s, int d) {\n\t\tused[s] = 1;\n\t\tvs.push_back(s);\n\t\tde.push_back(d);\n\t\tfor (int v : G[s]) {\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, d + 1);\n\t\t\t\tvs.push_back(s);\n\t\t\t\tde.push_back(d);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCA(int n, int rt_ = 0) : G(n), depth(n), used(n), id(n) {\n\t\tV = n;\n\t\trt = rt_;\n\t}\n\tvoid add(int a, int b) {\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tvoid init() {\n\t\tfill(used.begin(), used.end(), 0);\n\t\tfill(id.begin(), id.end(), -1);\n\t\tdfs(rt, 0);\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tif (id[vs[i]] == -1) {\n\t\t\t\tid[vs[i]] = i;\n\t\t\t}\n\t\t}\n\t\tvector<pi> r((int)vs.size());\n\t\tfor (int i = 0; i < (int)vs.size(); i++) {\n\t\t\tr[i] = pi(de[i], vs[i]);\n\t\t}\n\t\tSparseTable<pi> res(r);\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tdepth[i] = res[id[i]].first;\n\t\t}\n\t\tst = res;\n\t}\n\tint calc(int a, int b) {\n\t\treturn st.find(min(id[a], id[b]), max(id[a], id[b])).second;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tLCA lca(N);\n\tfor (int i = 0, x, y; i < N - 1; i++) {\n\t\tcin >> x >> y;\n\t\tlca.add(x - 1, y - 1);\n\t}\n\tint Q, a, b;\n\tlca.init();\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> a >> b;\n\t\tprintf(\"%d\\n\", lca.dist(a - 1, b - 1) + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing llong = long long;\n\n//===\n// call build() before other query (except add_edge)\n// 0-indexed\n// climb(u, d): climb d steps towards root\n// fold(u, v):\nstruct DoublingTree {\n    vector<vector<int> > G;\n    vector<vector<int> > parent;\n    vector<int> depth;\n    int logn;\n\n    DoublingTree(int n) {\n        logn = 1;\n        while ((1 << logn) < n) logn++;\n\n        G.resize(n);\n        parent.assign(logn, vector<int>(n, -1));\n        depth.assign(n, -1);\n    };\n\n    template<class Graph>\n    DoublingTree(Graph &g) {\n        DoublingTree(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            G[i].resize(g[i].size());\n            for (int j = 0; j < g[i].size(); j++) {\n                G[i][j] = g[i][j];\n            }\n        }\n    };\n\n    void calc_depth(int u, int d, int par) {\n        depth[u] = d++;\n        parent[0][u] = par;\n        for (int v:G[u]) {\n            if (v == par) continue;\n            calc_depth(v, d, u);\n        }\n    };\n    \n    void build(vector<int> root = {0}) {\n        for (int i = 0; i < root.size(); i++) {\n            calc_depth(root[i], 0, -1);\n        }\n        for (int k = 1; k < logn; k++) {\n            for (int u = 0; u < size(); u++) {\n                if (parent[k - 1][u] == -1) continue;\n                parent[k][u] = parent[k - 1][parent[k - 1][u]];\n            }\n        }\n    };\n    \n    void add_edge(int u, int v) {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    };\n    int climb(int u, int d) {\n        int cnt = 0;\n        while (d) {\n            if (d & 1) u = parent[cnt][u];\n            d >>= 1;\n            cnt++;\n        }\n        return u;\n    };\n    // LowestCommonAncestor\n    int lca(int u, int v) {\n        if (depth[u] > depth[v]) swap(u, v);\n        v = climb(v, depth[v] - depth[u]);\n\n        if (u == v) return u;\n        for (int k = logn - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    };\n    inline int distance(int u, int v) {\n        return depth[u] + depth[v] - depth[lca(u, v)] * 2;\n    };\n    inline int size() {\n        return G.size();\n    };\n};\n//===\n\n// verify lca()\nint AOJ_GRL_5_C() {\n    int n;\n    int k, c;\n    int q;\n    int u, v;\n\n    cin >> n;\n    DoublingTree t(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            cin >> c;\n            t.add_edge(i, c);\n        }\n    }\n\n    t.build();\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        cin >> u >> v;\n        cout << t.lca(u, v) << endl;\n    }\n\n    return 0;\n};\n\nint main() {\n    return AOJ_GRL_5_C();\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass LCA {\nprivate:\n    static const int MAX_LOG = 20;\n    const int n;\n    Graph G;\n    VV par;\n    V depth;\npublic:\n    LCA(int _n) : n(_n), G(_n), par(MAX_LOG, V(_n)), depth(_n) {}\n    // undirected\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n    // ??????????????±?????¨???1????????????????±???????\n    void dfs(int v, int p, int d) {\n        par[0][v] = p;\n        depth[v] = d;\n        for (auto nxt : G[v]) {\n            if (nxt != p) {\n                dfs(nxt, v, d + 1);\n            }\n        }\n    }\n    // ????????????2^k????????????????±?????????????\n    void setPar() {\n        // 0????????¨??????1????????????????±???????\n        dfs(0, -1, 0);\n\n        // 2^i????????????????±???????\n        rep(i, MAX_LOG - 1) {\n            rep(j, n) {\n                if (par[i][j] == -1) {\n                    par[i + 1][j] = -1;\n                } else {\n                    par[i + 1][j] = par[i][par[i][j]];\n                }\n            }\n        }\n    }\n    int lca(int a, int b) {\n        // ??????a??¨b?????±???????????????\n        if (depth[a] > depth[b]) {\n            swap(a, b);\n        }\n        rep(i, MAX_LOG) {\n            if ((depth[b] - depth[a]) >> i & 1) {\n                b = par[i][b];\n            }\n        }\n        if (a == b) return a;\n\n        // ??¶???????????´????????§a, b????????????\n        rrep(i, MAX_LOG) {\n            if (par[i][a] != par[i][b]) {\n                a = par[i][a];\n                b = par[i][b];\n            }\n        }\n        // a??¨b???1????????????????????´????????????\n        return par[0][a];\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    scanf(\"%lld\", &n);\n    LCA lca(n);\n    rep(i, n) {\n        int k;\n        scanf(\"%lld\", &k);\n        rep(j, k) {\n            int c;\n            scanf(\"%lld\", &c);\n            lca.addEdge(i, c);\n        }\n    }\n\n    lca.setPar();\n\n    int Q;\n    scanf(\"%lld\", &Q);\n    rep(i, Q) {\n        int u, v;\n        scanf(\"%lld%lld\", &u, &v);\n        printf(\"%lld\\n\", lca.lca(u, v));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\n#define MAXN 100001\n\nint block_sz;          // block size = sqrt(height)\nint depth[MAXN];       // stores depth for each node.\nint parent[MAXN];      // stores first parent for each node.\nint jump_parent[MAXN]; // stores first ancestor in previous block.\nvector<int> adj[MAXN];\n\nvoid addEdge(int u, int v){\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\n\nint LCANaive(int u,int v){\n    if(u == v)              return u;\n    if(depth[u] > depth[v]) swap(u, v);\n    v = parent[v];\n    return LCANaive(u, v);\n}\n\n// precalculating the required parameters associated with every node.\nvoid dfs(int cur, int prev){\n    // marking depth of cur node\n    depth[cur] = depth[prev] + 1;\n    \n    // marking parent of cur node\n    parent[cur] = prev;\n    \n    // making jump_parent of cur node\n    // if it is first node of the block then its jump_parent is its cur parent.\n    if (depth[cur] % block_sz == 0) jump_parent[cur] = parent[cur];\n    // if it is not the first node of this block then its jump_parent is jump_parent of its parent.\n    else                            jump_parent[cur] = jump_parent[prev];\n    \n    // propogating the marking down the subtree\n    for(int i = 0; i < adj[cur].size(); ++i) if(adj[cur][i] != prev) dfs(adj[cur][i], cur);\n}\n\n// using sqrt decomposition trick\nint LCASQRT(int u, int v){\n    while(jump_parent[u] != jump_parent[v]){\n        // maintaining depth[v] > depth[u]\n        if(depth[u] > depth[v]) swap(u, v);\n        // climb to its jump parent\n        v = jump_parent[v];\n    }\n    // u and v have same jump_parent\n    return LCANaive(u, v);\n} \n\nvoid preprocess(int height){\n    block_sz = sqrt(height);\n    depth[0] = -1;\n    // precalclating 1) depth.  2) parent.  3) jump_parent for each node\n    dfs(0, 0);\n}\n\nint main(){\n    \n    // 1. 入力情報取得.\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0, s, t, w; i < N; ++i){\n        int k;\n        scanf(\"%d\", &k);\n        for(int j = 0; j < k; ++j){\n            int c;\n            scanf(\"%d\", &c);\n            addEdge(i, c);\n        }\n    }\n    \n    // 2. 前処理.\n    preprocess(MAXN);\n    \n    // 3. 各判定クエリに対し, 出力を行う.\n    int Q;\n    scanf(\"%d\", &Q);\n    for(int i = 0; i < Q; i++){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        printf(\"%d\\n\", LCASQRT(u, v));\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,-1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs=vector<int>(1,0)) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int,int>;\n    stack<T> st;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v,i;\n      tie(v,i) = st.top();\n      if(i<(int)G[v].size()){\n\tst.top().second++;\n\tint u=G[v][i];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tint res=0;\n\tfor(int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if (vid[u] > vid[v]) swap(u, v);\n      f(max(vid[head[v]], vid[u]), vid[v]);\n      if (head[u] != head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] != head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/11/07\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n/*\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned main(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/11/07\nhttps://yukicoder.me/problems/no/529\n*/"
  },
  {
    "language": "C++",
    "code": "//\n// LCA (by Doubling)\n//\n// verified:\n//   AOJ Course GRL_5_C Tree - Lowest Common Ancestor\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n//\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nusing Graph = vector<vector<int> >;\nstruct LCA {\n    vector<vector<int> > parent; // parent[d][v] := 2^d-th parent of v\n    vector<int> depth;\n    LCA() { }\n    LCA(const Graph &G, int r = 0) { init(G, r); }\n    void init(const Graph &G, int r = 0) {\n        int V = (int)G.size();\n        int h = 1;\n        while ((1<<h) < V) ++h;\n        parent.assign(h, vector<int>(V, -1));\n        depth.assign(V, -1);\n        dfs(G, r, -1, 0);\n        for (int i = 0; i+1 < (int)parent.size(); ++i)\n            for (int v = 0; v < V; ++v)\n                if (parent[i][v] != -1)\n                    parent[i+1][v] = parent[i][parent[i][v]];\n    }\n    void dfs(const Graph &G, int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        for (auto e : G[v]) if (e != p) dfs(G, e, v, d+1);\n    }\n    int get(int u, int v) {\n        if (depth[u] > depth[v]) swap(u, v);\n        for (int i = 0; i < (int)parent.size(); ++i)\n            if ( (depth[v] - depth[u]) & (1<<i) )\n                v = parent[i][v];\n        if (u == v) return u;\n        for (int i = (int)parent.size()-1; i >= 0; --i) {\n            if (parent[i][u] != parent[i][v]) {\n                u = parent[i][u];\n                v = parent[i][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\n\n\nint main() {\n    int N; cin >> N;\n    Graph G(N);\n    for (int i = 0; i < N; ++i) {\n        int num; cin >> num;\n        for (int j = 0; j < num; ++j) {\n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    LCA lca(G);\n    int Q; cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int u, v; cin >> u >> v;\n        cout << lca.get(u, v) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 5000000000000000000\n#define ll long long\n#define pll pair<ll, ll>\nusing namespace std;\n\nconst ll next_d = 17;\nll n_up(ll now, ll n, vector<vector<ll>>& next)\n{\n  for (ll i = next_d; i >= 0; --i) {\n    if (n & (1 << i)) {\n      now = next.at(i).at(now);\n    }\n  }\n  return now;\n}\n\nint main()\n{\n  ll N;\n  cin >> N;\n  vector<vector<ll>> next(next_d, vector<ll>(N, -1));\n  vector<vector<ll>> connection(N);\n  for (ll i = 0; i < N; ++i) {\n    ll K;\n    cin >> K;\n    for (ll j = 0; j < K; ++j) {\n      ll c;\n      cin >> c;\n      connection.at(i).push_back(c);\n      next.at(0).at(c) = i;\n    }\n  }\n\n\n  //深さを求める--------------------------\n  vector<ll> depth(N, 0);\n  queue<ll> q;\n  q.push(0);\n  while (!q.empty()) {\n    ll now = q.front();\n    ll now_d = depth.at(now);\n    q.pop();\n    for (ll i = 0; i < connection.at(now).size(); ++i) {\n      depth.at(connection.at(now).at(i)) = now_d + 1;\n      q.push(connection.at(now).at(i));\n    }\n  }\n  // for (ll i = 0; i < N; ++i) {\n  //   cout << depth.at(i) << \" \";\n  // }\n  // cout << \"\\n\";\n  //----------------------------------------\n\n  //ダブリング--------------------------\n  for (ll i = 0; i < next_d - 1; ++i) {\n    for (ll j = 0; j < N; ++j) {\n      ll temp = next.at(i).at(j);\n      if (temp == -1) {\n        next.at(i + 1).at(j) = -1;\n      }\n      else {\n        next.at(i + 1).at(j) = next.at(i).at(temp);\n      }\n    }\n  }\n  // cout << \"next\" << \"\\n\";\n  // for (ll i = 0; i < next_d; ++i) {\n  //   for (ll j = 0; j < N; ++j) {\n  //     cout << next.at(i).at(j) << \" \";\n  //   }\n  //   cout << \"\\n\";\n  // }\n  //----------------------------------------\n\n  // ans------------------------------------\n  ll Q;\n  cin >> Q;\n  for (ll i = 0; i < Q; ++i) {\n    ll u, v;\n    cin >> u >> v;\n    ll ud = depth.at(u), vd = depth.at(v);\n    if (vd > ud) {\n      swap(vd, ud);\n      swap(v, u);\n    }\n    u = n_up(u, ud - vd, next);\n    ud = vd;\n    ll l = -1, r = ud + 1;\n    ll ans, temp;\n    while (l + 1 != r) {\n      ll m = (l + r) / 2;\n      temp = n_up(u, m, next);\n      if (temp == n_up(v, m, next)) {\n        r = m;\n        ans = temp;\n      }\n      else {\n        l = m;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  //----------------------------------------\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    logN = 21;\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(\"Ofast\",\"unroll-loops\")\n// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace::std;\n//struct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n__attribute__((constructor))\nvoid init(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(15);\n}\n// random_device rd;\n// mt19937 mt(rd());\n// #include <boost/numeric/interval.hpp>\n// #include <boost/numeric/interval/io.hpp>\n// #include <boost/intrusive/rbtree.hpp>\n// #include <boost/dynamic_bitset.hpp>\n// #include <boost/geometry.hpp>\n// #include <boost/geometry/geometries/linestring.hpp>\n// #include <boost/geometry/geometries/polygon.hpp>\n// #include <boost/geometry/geometries/point_xy.hpp>\n// #include <boost/math/tools/minima.hpp>\n// using boost::math::tools::brent_find_minima;\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\n// #include <boost/unordered_map.hpp>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\ntemplate<typename T=long long>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pqueue =__gnu_pbds::priority_queue<T, less<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntemplate<typename T>using Vec=vector<T>;\ntemplate<typename T>using Mat=vector<vector<T>>;\ntemplate<typename T>using Mat3=vector<vector<vector<T>>>;\ntemplate<typename T>using Mat4=vector<vector<vector<vector<T>>>>;\ntemplate<typename S,typename T>using pvec=vector<pair<S,T>>;\ntemplate<typename S,typename T>using pmat=vector<vector<pair<S,T>>>;\ntemplate<typename S,typename T>using pmat3=vector<vector<vector<pair<S,T>>>>;\ntemplate<typename S,typename T>using pmat4=vector<vector<vector<vector<pair<S,T>>>>>;\ntemplate<typename... T>using tvec=vector<tuple<T...>>;\ntemplate<typename... T>using tmat=vector<vector<tuple<T...>>>;\ntemplate<typename... T>using tmat3=vector<vector<vector<tuple<T...>>>>;\ntemplate<typename... T>using tmat4=vector<vector<vector<vector<tuple<T...>>>>>;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n//#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807LL\n//#define MOD 998244353LL\n#define MOD 1000000007LL\n#define endl \"\\n\"\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(int i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(int i=0;i<t.size();i++)output(t[i]);}\nauto Y=[&](auto f){return[&](auto... args){return f(f, args...);};};\ntemplate<typename T=lint>T in(){return *istream_iterator<T>(cin);}\ntemplate<typename T=lint>inline T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<typename T=lint>inline T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<typename T>inline T minq(T a,T b){return min(a,b);}\ntemplate<typename T>inline T maxq(T a,T b){return max(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={-1,1,0,0,1,1,-1,-1};\nconst vector<lint> dy={0,0,-1,1,1,-1,1,-1};\n\nclass HLD{\n\tpublic:\n\tint* dep;\n\tint* vertex;\n\tint* par;\n\tint* head;\n\tint depth(const auto& v,int n,int p){\n\t\tint mx=0;\n\t\tfor(auto t:v[n]){\n\t\t\tif(t!=p)mx=max(mx,depth(v,t,n));\n\t\t}\n\t\treturn dep[n]=mx+1;\n\t}\n\tHLD(auto v,int root){\n\t\tdep=new int[v.size()];\n\t\tvertex=new int[v.size()];\n\t\tpar=new int[v.size()];\n\t\thead=new int[v.size()];\n\t\tdepth(v,root,-1);\n\t\tstack<tuple<int,int>>stk;\n\t\tstk.emplace(root,-1);\n\t\tint i=0;\n\t\tpar[root]=root;\n\t\thead[root]=root;\n\t\twhile(!stk.empty()){\n\t\t\tint n,p;\n\t\t\ttie(n,p)=stk.top();\n\t\t\tstk.pop();\n\t\t\tvertex[n]=i++;\n\t\t\tint mx=0,heavy=-1;\n\t\t\tfor(auto t:v[n])if(t!=p&&mx<dep[t])heavy=t;\n\t\t\tfor(auto t:v[n]){\n\t\t\t\tif(t==heavy){\n\t\t\t\t\tpar[heavy]=par[n];\n\t\t\t\t\thead[heavy]=head[n];\n\t\t\t\t\tstk.emplace(heavy,n);\n\t\t\t\t}else if(t!=p){\n\t\t\t\t\tpar[t]=n;\n\t\t\t\t\thead[t]=t;\n\t\t\t\t\tstk.emplace(t,n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint lca(auto l,auto r){\n\t\twhile(1){\n\t\t\tif(head[l]==head[r])return dep[l]>dep[r]?l:r;\n\t\t\telse if(dep[head[l]]>dep[head[r]])r=par[r];\n\t\t\telse l=par[l];\n\t\t}\n\t}\n};\n\nint main(){\n\tlint n;\n\tcin>>n;\n\tmat v(n);\n\trep(i,n){\n\t\tlint x;\n\t\tcin>>x;\n\t\trep(j,x){\n\t\t\tlint y;\n\t\t\tcin>>y;\n\t\t\tv[i].push_back(y);\n\t\t}\n\t}\n\tlint q;\n\tcin>>q;\n\tHLD hld(v,0);\n\trep(i,q){\n\t\tlint s,t;\n\t\tcin>>s>>t;\n\t\tcout<<hld.lca(s,t)<<endl;\n\t}\n}\n// int main(){\n// \tlint n,q;\n// \tcin>>n>>q;\n// \tmat v(n);\n// \trepi(i,1,n){\n// \t\tlint x;\n// \t\tcin>>x;\n// \t\tv[i].push_back(x);\n// \t\tv[x].push_back(i);\n// \t}\n// \tHLD hld(v,0);\n// \trep(i,q){\n// \t\tlint s,t;\n// \t\tcin>>s>>t;\n// \t\tcout<<hld.lca(s,t)<<endl;\n// \t}\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nconst int B = 200;\nint color[100010],  par[100010], depth[100010];\nint colorTop[100010/B];\nint goUp[100010/B];\nbool vis[100010];\nint n;\nvector<vector<int>> g;\n\nvoid decomp(int root){\n    rep(i,n) vis[i] = 0, par[i] = -1;\n    queue<int> q;\n    q.push(root);\n    vector<int> tord;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        vis[v] = true;\n        tord.push_back(v);\n        for(int c : g[v]){\n            if(vis[c]) continue;\n            q.push(c);\n            par[c] = v;\n            depth[c] = depth[v] + 1;\n        }\n    }\n    assert(q.size() == 0);\n    rep(i,n) vis[i] = 0;\n    int c = 0;\n    rep(i,n){\n        if(vis[i]) continue;\n        q.push(tord[i]);\n        colorTop[c] = i;\n        int k = 0;\n        while(q.size() && k < B){\n            int v = q.front(); q.pop();\n            vis[v] = true;\n            color[v] = c;\n            goUp[v] = par[i];\n            k++;\n            for(int c : g[v]){\n                if(vis[c]) continue;\n                q.push(c);\n            }\n        }\n        c++;\n    }\n}\n\nint solve(int u, int v){\n    while(color[u] != color[v]){\n        if(depth[u] < depth[v]) swap(u,v);\n        v = goUp[v];\n    }\n    if(depth[u] > depth[v]){\n        swap(u,v);\n    }\n    while(depth[u] != depth[v]){\n        v = par[v];\n    }\n    while(u != v){\n        u = par[u];\n        v = par[v];\n    }\n    return u;\n}\n\nint main(){\n    cin >> n;\n    g.assign(n,{});\n    rep(i,n){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n            par[c] = i;\n        }\n    }\n    decomp(0);\n    int q;\n    cin >> q;\n    rep(i,q){\n        int u,v;\n        cin >> u >> v;\n        cout << solve(u,v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rrep(i,n) for(int (i)=((n)-1);(i)>=0;(i)--)\n#define itn int\n#define miele(v) min_element(v.begin(), v.end())\n#define maele(v) max_element(v.begin(), v.end())\n#define SUM(v) accumulate(v.begin(), v.end(), 0LL)\n#define lb(a, key) lower_bound(a.begin(),a.end(),key)\n#define ub(a, key) upper_bound(a.begin(),a.end(),key)\n#define COUNT(a, key) count(a.begin(), a.end(), key) \n#define BITCOUNT(x) __builtin_popcount(x)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\nusing P = pair <int,int>;\nusing WeightedGraph = vector<vector <P>>;\nusing UnWeightedGraph = vector<vector<int>>;\nusing Real = long double;\nusing Point = complex<Real>; //Point and Vector2d is the same!\nusing Vector2d = complex<Real>;\nconst long long INF = 1LL << 60;\nconst int MOD = 1000000007;\nconst double EPS = 1e-15;\nconst double PI=3.14159265358979323846;\ntemplate <typename T> \nint getIndexOfLowerBound(vector <T> &v, T x){\n    return lower_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate <typename T> \nint getIndexOfUpperBound(vector <T> &v, T x){\n    return upper_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n#define DUMPOUT cerr\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\nistream &operator>>(istream &is, Point &p) {\n    Real a, b; is >> a >> b; p = Point(a, b); return is;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T,U> &p_var) {\n    is >> p_var.first >> p_var.second;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<vector<T>> &df) {\n    for(int i=0;i<df.size();i++)for(int j=0;j<df[i].size();j++)\n    is >> df[i][j];\n    return is;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    DUMPOUT<<'{';\n    os << pair_var.first;\n    DUMPOUT<<',';\n    os << \" \"<< pair_var.second;\n    DUMPOUT<<'}';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &vec) {\n    DUMPOUT<<'[';\n    for (int i = 0; i < vec.size(); i++) \n    os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    DUMPOUT<<']';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<vector<T>> &df) {\n  for (auto& vec : df) os<<vec;\n  return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    DUMPOUT << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    DUMPOUT << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\nvoid print() {cout << endl;}\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  cout << head;\n  if (sizeof...(tail) != 0) cout << \" \";\n  print(forward<Tail>(tail)...);\n}\nvoid dump_func() {DUMPOUT << '#'<<endl;}\ntemplate <typename Head, typename... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\ntemplate <typename T>\nstruct doubling{\n    int sz;\n    vector <vector <T>> parents;\n    vector <int> dep;\n    doubling(UnWeightedGraph &g){\n        sz = g.size();\n        parents.resize(20), dep.resize(sz);\n        rep(i, 20) parents[i].resize(sz);\n        queue <tuple <int,int,int>> q;\n        q.push(make_tuple(0, 0, 0)); //now, pre, depth\n        while(!q.empty()){\n            auto tmp = q.front(); q.pop();\n            int now = get <0>(tmp), pre = get <1>(tmp), depth = get <2>(tmp);\n            parents[0][now] = pre, dep[now] = depth;\n            for(auto ne: g[now]) if(ne != pre) q.push(make_tuple(ne, now, depth+1));\n        }\n        for(int i=1;i<20;i++) rep(j, sz) parents[i][j] = parents[i-1][parents[i-1][j]];\n    }\n    /*doubling(WeightedGraph &g){\n        sz = g.size();\n        parents.resize(20), dep.resize(20);\n        rep(i, 20) parents[i].resize(sz);\n        queue <tuple <int,int,int>> q;\n        q.push(make_tuple(0, 0, 0)); //now, pre, depth\n        while(!q.empty()){\n            auto tmp = q.front(); q.pop();\n            int now = get <0>(tmp), pre = get <1>(tmp), depth = get <2>(tmp);\n            parents[0][now] = pre, dep[now] = depth;\n            for(auto ne: g[now]) if(ne.F != pre) q.push(make_tuple(ne.F, now, dep+1));\n        }\n        for(int i=1;i<20;i++) rep(j, sz) parents[i][j] = parents[i-1][parents[i-1][j]];\n    }*/\n    int getAncestor(int a, int k){\n        int now = a;\n        for(int i=19;i>=0;i--) if(k&(1<<i)) now = parents[i][now];\n        return now;\n    }\n    int lca(int a, int b){\n        if(a==b) return a;\n        if(dep[a] > dep[b]) swap(a, b);\n        for(int i=19;i>=0;i--) if(((dep[b] - dep[a]) >> i) & 1) b = parents[i][b];\n        if(a==b) return a;\n        for(int i=19;i>=0;i--) \n        if(parents[i][a] != parents[i][b]) a = parents[i][a], b = parents[i][b];\n        return parents[0][a];\n    }\n    int dist(int a, int b){\n        int anc = lca(a, b);\n        return dep[a] + dep[b] - 2*dep[anc];\n    }\n    /*int query(int a, int b){\n        int anc = lca(a, b);\n        for(int i=19;i>=0;i--){\n            if(dist&(1LL<<i)) {\n                chmax(res, maxEdge[i][now]);\n                now = parents[i][now];\n            }\n        }\n        return res;\n    }*/\n};\nint main(void) { cin.tie(0); ios::sync_with_stdio(false);\n    int n; cin>>n;\n    UnWeightedGraph g(n);\n    rep(i, n){\n        int k; cin>>k;\n        rep(j, k){\n            int a; cin>>a;\n            g[i].emplace_back(a);\n        }\n    }\n    int q; cin>>q;\n    doubling<int> dou(g);\n    while(q--){\n        int a, b; cin>>a>>b;\n        print(dou.lca(a, b));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define rndf(d) (ll)((double)(d) + (d >= 0 ? 0.5 : -0.5))\n#define floorsqrt(x) ((ll)sqrt((double)x) + ((ll)sqrt((double)x) * (ll)sqrt((double)x) <= (ll)(x) ? 0 : -1))\n#define ceilsqrt(x) ((ll)sqrt((double)x) + ((ll)x <= (ll)sqrt((double)x) * (ll)sqrt((double)x) ? 0 : 1))\n#define rnddiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) * 2 >= (ll)(b) ? 1 : 0))\n#define ceildiv(a, b) ((ll)(a) / (ll)(b) + ((ll)(a) % (ll)(b) == 0 ? 0 : 1))\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n\n/*******************************************************/\n\ntypedef ll nodeval_t;\ntypedef ll edgeval_t;\n\nstruct tree_t {\n\tint n;           // |V|, index begins with 0\n\tvector<P> edges; // E\n\tvector<nodeval_t> vals; // value of nodes\n\tvector<edgeval_t> costs; // cost, distance, or weight of edges\n};\n\nclass Tree {\nprivate:\n\tstruct node {\n\t\tint id; vi childs; int parent = -1;\n\t\tint deg = -1; // the number of edges of the path to the root\n\t\tint eid = -1; // edge id of the edge connected by its parent and itself\n\t\tint subtree_n = -1; // the number of nodes of the partial tree rooted by itself\n\t\tint visited = -1; // time stamp of visiting on DFS\n\t\tint departed = -1; // time stamp of departure on DFS\n\t\tnodeval_t val; // value of the node itself\n\t\tedgeval_t cost; // cost of the edge connected by its parent and itself\n\t\tbool operator<(const node & another) const {\n\t\t\treturn deg != another.deg ? deg < another.deg : id < another.id;\n\t\t}\n\t};\n\tstruct edgeinfo {\n\t\tint eid; int to; edgeval_t cost;\n\t};\n\tint n;\n\tstatic const nodeval_t init_val = 0;\n\tstatic const edgeval_t init_cost = 1;\n\tvector<vector<edgeinfo>> edges;\n\tvvi sparse_ancestors;\n\tvoid tree_construction() {\n\t\tleaves = {};\n\t\tqueue<int> que;\n\t\tque.push(root);\n\t\twhile (que.size()) {\n\t\t\tint a = que.front(); que.pop();\n\t\t\tdeg_order.push_back(a);\n\t\t\tif (a == Tree::root) nodes[a].deg = 0;\n\t\t\tint leaf_flag = true;\n\t\t\tLoop(i, edges[a].size()) {\n\t\t\t\tint b = edges[a][i].to;\n\t\t\t\tif (nodes[b].deg != -1) {\n\t\t\t\t\tnodes[a].parent = b;\n\t\t\t\t\tnodes[a].eid = edges[a][i].eid;\n\t\t\t\t\tnodes[a].cost = edges[a][i].cost;\n\t\t\t\t\tnodes[a].deg = nodes[b].deg + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleaf_flag = false;\n\t\t\t\t\tnodes[a].childs.push_back(b);\n\t\t\t\t\tque.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (leaf_flag) leaves.push_back(a);\n\t\t}\n\t\tLoopr(i, n) {\n\t\t\tint a = deg_order[i];\n\t\t\tLoop(j, nodes[a].childs.size()) {\n\t\t\t\tint b = nodes[a].childs[j];\n\t\t\t\tnodes[a].subtree_n += nodes[b].subtree_n;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvector<node> nodes;\n\tvi deg_order; // node ids, sorted by deg\n\tvi leaves;\n\tint root;\n\t// T should be non-empty tree\n\tTree(tree_t T, int root = -1) {\n\t\tn = T.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tnodes[i].id = i;\n\t\t\tnodes[i].val = T.vals.size() > i ? T.vals[i] : 0;\n\t\t\tnodes[i].cost = init_cost;\n\t\t}\n\t\tedges.resize(n);\n\t\tLoop(i, n - 1) {\n\t\t\tedges[T.edges[i].first].push_back({ i, T.edges[i].second, (T.costs.size() > i ? T.costs[i] : init_cost) });\n\t\t\tedges[T.edges[i].second].push_back({ i, T.edges[i].first, (T.costs.size() > i ? T.costs[i] : init_cost) });\n\t\t}\n\t\t// the node which has the greatest degree will automatically decided as the root\n\t\tif (root < 0) {\n\t\t\tint max_d = -1;\n\t\t\tLoop(i, n) {\n\t\t\t\tif (edges[i].size() > max_d) {\n\t\t\t\t\tTree::root = i;\n\t\t\t\t\tmax_d = edges[i].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis->root = min(root, n - 1);\n\t\t}\n\t\ttree_construction();\n\t\treturn;\n\t}\n\tpair<int, vi> solve_center_of_gravity() {\n\t\tpair<int, vi> ret = { INT_MAX,{} };\n\t\tvector<node> c_nodes = nodes;\n\t\tsort(c_nodes.begin(), c_nodes.end());\n\t\tvi record(n, 1);\n\t\tLoopr(i, n) {\n\t\t\tint x = n - 1, max_x = INT_MIN;\n\t\t\tLoop(j, c_nodes[i].childs.size()) {\n\t\t\t\tint b = c_nodes[i].childs[j];\n\t\t\t\tmax_x = max(max_x, record[b]);\n\t\t\t\tx -= record[b];\n\t\t\t\trecord[c_nodes[i].id] += record[b];\n\t\t\t}\n\t\t\tmax_x = max(max_x, x);\n\t\t\tif (max_x < ret.first) ret = { max_x,{ c_nodes[i].id } };\n\t\t\telse if (max_x == ret.first) ret.second.push_back(c_nodes[i].id);\n\t\t}\n\t\tsort(ret.second.begin(), ret.second.end());\n\t\treturn ret;\n\t}\n\tvi solve_node_inclusion_cnt_in_all_path(bool enable_single_node_path) {\n\t\tvi ret(n, 0);\n\t\tLoop(i, n) {\n\t\t\tint a = i;\n\t\t\t// desendants to desendants\n\t\t\tLoop(j, nodes[a].childs.size()) {\n\t\t\t\tint b = nodes[a].childs[j];\n\t\t\t\tret[i] += nodes[b].subtree_n * (nodes[a].subtree_n - nodes[b].subtree_n - 1);\n\t\t\t}\n\t\t\tret[i] /= 2; // because of double counting\n\t\t\tret[i] += (nodes[a].subtree_n - 1) * (n - nodes[a].subtree_n); // desendants to the others except for itself\n\t\t\tret[i] += n - 1; // itself to the others\n\t\t\tif (enable_single_node_path) ret[i]++; // itself\n\t\t}\n\t\treturn ret;\n\t}\n\tvi solve_edge_inclusion_cnt_in_all_path() {\n\t\tvi ret(n - 1, 0);\n\t\tLoop(i, n) {\n\t\t\tint eid = nodes[i].eid;\n\t\t\tif (eid < 0) continue;\n\t\t\tret[eid] = nodes[i].subtree_n * (n - nodes[i].subtree_n); // members in the partial tree to the others\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid solve_sparse_ancestors() {\n\t\tsparse_ancestors.resize(n);\n\t\tvector<int> current_ancestors;\n\t\tstack<int> stk;\n\t\tstk.push(Tree::root);\n\t\tint time_stamp = 1;\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tnodes[a].visited = time_stamp++;\n\t\t\tfor (int i = 1; i <= current_ancestors.size(); i *= 2) {\n\t\t\t\tsparse_ancestors[a].push_back(current_ancestors[current_ancestors.size() - i]);\n\t\t\t}\n\t\t\tif (nodes[a].childs.size()) {\n\t\t\t\tLoop(i, nodes[a].childs.size()) {\n\t\t\t\t\tstk.push(nodes[a].childs[i]);\n\t\t\t\t}\n\t\t\t\tcurrent_ancestors.push_back(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].departed = time_stamp++;\n\t\t\t\twhile (current_ancestors.size() && (stk.empty() || nodes[stk.top()].parent != current_ancestors.back())) {\n\t\t\t\t\tnodes[current_ancestors.back()].departed = time_stamp++;\n\t\t\t\t\tcurrent_ancestors.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbool is_ancestor(int descendant, int ancestor) {\n\t\treturn nodes[ancestor].visited < nodes[descendant].visited\n\t\t\t&& nodes[descendant].departed < nodes[ancestor].departed;\n\t}\n\tint get_lowest_common_ancestor(int u, int v) {\n\t\tif (u == v) return u;\n\t\tif (is_ancestor(u, v)) return v;\n\t\tif (is_ancestor(v, u)) return u;\n\t\tint a = u;\n\t\twhile (!is_ancestor(v, sparse_ancestors[a][0])) {\n\t\t\tint b = sparse_ancestors[a][0];\n\t\t\tLoop1(i, sparse_ancestors[a].size() - 1) {\n\t\t\t\tif (is_ancestor(v, sparse_ancestors[a][i])) break;\n\t\t\t\telse b = sparse_ancestors[a][i - 1];\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\treturn sparse_ancestors[a][0];\n\t}\n};\n\nint main() {\n\ttree_t T;\n\tcin >> T.n;\n\tLoop(i, T.n) {\n\t\tint m; cin >> m;\n\t\tLoop(j, m) {\n\t\t\tint t; cin >> t;\n\t\t\tT.edges.push_back({ i, t });\n\t\t}\n\t}\n\tTree tree(T, 0);\n\ttree.solve_sparse_ancestors();\n\tint q; cin >> q;\n\tLoop(i, q) {\n\t\tint s, t; cin >> s >> t;\n\t\tcout << tree.get_lowest_common_ancestor(s, t) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing vvll = vector<vll>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr int INF = 1001001001;\n//constexpr ll INF = 1001001001001001001ll;\nconstexpr double EPS = 1e-10;\nusing number = long long;\n\n\nstruct inRMQ {\n    int n;\n    vector<int> dat;\n    vector<int> ind;\n\n    inRMQ() {}\n    inRMQ(int N, const vector<int> &vec) { init(N, vec); }\n\n    inline void init(int N, const vector<int> &vec) {\n        n = 1; while (n < N) n *= 2;\n        dat.assign(2 * n - 1, INF);\n        ind.assign(2 * n - 1, -1);\n\n        rep(k, N) {\n            dat[k + n - 1] = vec[k];\n            ind[k + n - 1] = k;\n        }\n\n        int tmp = n;\n        while (tmp > 1) {\n            tmp /= 2;\n            for (int k = tmp - 1 ; k < 2 * tmp - 1; k++) {\n                if (dat[k * 2 + 1] > dat[k * 2 + 2]) {\n                    dat[k] = dat[k * 2 + 2]; ind[k] = ind[k * 2 + 2];\n                }\n                else {\n                    dat[k] = dat[k * 2 + 1]; ind[k] = ind[k * 2 + 1];\n                }\n            }\n        }\n    }\n\n    inline void update(int k, int a) {\n        k += n - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            if (dat[k * 2 + 1] > dat[k * 2 + 2]) {\n                dat[k] = dat[k * 2 + 2]; ind[k] = ind[k * 2 + 2];\n            }\n            else {\n                dat[k] = dat[k * 2 + 1]; ind[k] = ind[k * 2 + 1];\n            }\n        }\n    }\n\n    inline pii QUERY(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return pii(INF, -1);\n        if (a <= l && r <= b) return pii(dat[k], ind[k]);\n        else {\n            pii vl = QUERY(a, b, k * 2 + 1, l, (l + r) / 2);\n            pii vr = QUERY(a, b, k * 2 + 2, (l + r) / 2, r);\n            if (vl.first > vr.first) return vr;\n            else return vl;\n        }\n    }\n\n    inline int query(int a, int b) {\n        return QUERY(a, b, 0, 0, n).second;\n    }\n\n};\n\n\nusing Graph = vector<vector<int>>;\n\nstruct segmentLCA {\n    int root;\n    vector<int> vs;\n    vector<int> dept; //オイラーツアーの途上におけるdepth\n    vector<int> id;\n    inRMQ rmq;\n\n    segmentLCA(int V, int r, const Graph &G) {init(V, r, G);}\n\n    void init(int V, int r, const Graph &G) {\n        root = r;\n        vs.assign(V * 2 - 1, 0);\n        dept.assign(V * 2 - 1, 0);\n        id.assign(V, 0);\n        int k = 0;\n        DFS(root, -1, 0, k, G);\n        rmq.init(2 * V - 1, dept);\n    }\n\n    void DFS(int v, int p, int d, int &k, const Graph &G) {\n        id[v] = k;\n        vs[k] = v;\n        dept[k++] = d;\n        for (auto x : G[v]) {\n            if (x == p) continue;\n            DFS(x, v, d + 1, k, G);\n            vs[k] = v;\n            dept[k++] = d;\n        }\n    }\n\n    int calcLCA(int u, int v) {\n        return vs[rmq.query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n    }\n\n};\n\n\n\nint main() {\n    int n; cin >> n;\n    Graph G(n);\n    int k, c;\n    rep(i, n) {\n        cin >> k;\n        rep(j, k) {\n            cin >> c;\n            G[i].pb(c);\n            G[c].pb(i);\n        }\n    }\n\n    segmentLCA lca(n, 0, G);\n\n    int q, u, v; cin >> q;\n    rep(i, q) {\n        cin >> u >> v;\n        cout << lca.calcLCA(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// 根付き木\n\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nint leftMostBit(int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(std::min(left, right), std::max(left, right), 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return (node_[vl] < node_[vr] ? left_child(k) : right_child(k));\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n#include<iostream>\nusing namespace std;\n\n//*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(v);\n            else                    u = parent(u);\n        }\n        return u;\n    }\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    std::vector<Node> node_;\n};\n//*/\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n\n    RangeMinimumQuery rmq(n);\n    for(int i = 0; i < n; ++i) rmq.update(i, t.depth(i));\n\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n//         cout << rmq.find(u, v) << endl;\n//         cout << rmq.find_index(u, v) - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, t1, t2, q, u, v, par[100005], d[100005], f[100005][21];\nvector <int> path[100005];\n\nvoid dfs(int u, int p) {\n\tpar[u] = p, d[u] = d[p] + 1;\n\tfor (int i : path[u]) {\n\t\tdfs(i, u);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t1;\n\t\tfor (int j = 0; j < t1; j++) {\n\t\t\tcin >> t2;\n\t\t\tpath[i].push_back(t2);\n\t\t}\n\t}\n\tdfs(0, -1);\n\tfor (int i = 0; i < n; i++) f[i][0] = par[i];\n\tfor (int i = 1; i < 20; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (f[j][i - 1] != -1) f[j][i] = f[f[j][i - 1]][i - 1];\n\t\t}\n\t}\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> u >> v;\n\t\tif (d[u] < d[v]) swap(u, v);\n\t\tfor (int j = 19; j >= 0; j--) {\n\t\t\tif (d[f[u][j]] >= d[v]) u = f[u][j];\n\t\t}\n//\t\tcout << u << ' ' << v << endl;\n\t\tif (u == v) {\n\t\t\tcout << u << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 19; j >= 0; j--) {\n\t\t\tif (f[u][j] != f[v][j]) u = f[u][j], v = f[v][j];\n\t\t}\n\t\tcout << par[u] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n// ?????????\nclass RootedTree {\npublic:\n  RootedTree(int n);\n  int size() const;\n  int parent(int v, int n = 1) const;\n  void join(int u, int v);\n  void initialize(int root);\n  int lca(int u, int v) const;\nprivate:\n  void initialize(int current, int previous, int depth);\n  std::vector<std::vector<int>> edge_;\n  std::vector<std::vector<int>> parent_;  // parent_[v][i]: ??????v???2^i????????????\n  std::vector<int> depth_;\npublic:   // ???????????°??¨\n  void print(int c, int p) {\n    std::cout<<c<<\":\";\n    for(auto i: parent_[c])std::cout<<\" \"<<i;\n    std::cout<<std::endl;\n    for(auto n: edge_[c])if(n!=p)print(n,c);\n  }\n};\n// ?????????????????????\nRootedTree::RootedTree(int n) : edge_(n) {}\n// ????????°\nint RootedTree::size() const {return edge_.size();}\n// ??????v???n????????????\nint RootedTree::parent(int v, int n) const {\n  if(!n) return v;\n  if(__builtin_popcount(n) == 1) return parent_[v][__builtin_ctz(n)];\n  for(int i = 31 - __builtin_clz(n); 0 <= i; --i) if((n >> i) & 1) v = parent_[v][i];\n  return v;\n}\n// ????????????\nvoid RootedTree::join(int u, int v) {\n  edge_[u].push_back(v);\n  edge_[v].push_back(u);\n}\n// ?????????\nvoid RootedTree::initialize(int root) {\n  parent_.assign(size(), std::vector<int>());\n  depth_.assign(size(), 0);\n  initialize(root, root, 0);\n}\nvoid RootedTree::initialize(int current, int previous, int depth) {\n  depth_[current] = depth;\n  parent_[current].push_back(previous);\n  for(int i = 1; (1 << i) <= depth; ++i) parent_[current].push_back(parent_[parent_[current][i - 1]][i - 1]);\n  for(const auto& next: edge_[current]) if(next != previous) initialize(next, current, depth + 1);\n}\n// LCA\nint RootedTree::lca(int u, int v) const {\n  // u, v???????????±????????????\n  if(u > v) std::swap(u, v);\n  v = parent(v, depth_[v] - depth_[u]);\n  // LCA????±???????\n  if(u == v) return u;\n  for(int i = 31 - __builtin_clz(depth_[u]); 0 <= i; --i) {\n    if(parent_[u][i] == parent_[v][i]) continue;\n    u = parent_[u][i];\n    v = parent_[v][i];\n    i = std::min(i, 31 - __builtin_clz(depth_[u]));\n  }\n  return parent_[u][0];\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  RootedTree tree(n);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      tree.join(i, c);\n    }\n  }\n  tree.initialize(0);\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << tree.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define FOR(i,n) for (int i = 0; i < n; i++)\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ii> vii;\ntypedef vector<vii> vvii;\n\nconst int MX = 100005, LMX = 18;\nint p[LMX][MX], lvl[MX];\nint n, q, u, v, k;\nvi adj[MX];\n\nvoid dfs (int u) {\n\tfor (int v : adj[u]) {\n\t\tp[0][v] = u;\n\t\tlvl[v] = lvl[u] + 1;\n\t\tdfs(v);\n\t}\n}\n\nvoid pre () {\n\tfor (int j = 1; j < LMX; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[j][i] = p[j-1][p[j-1][i]];\n\t\t}\n\t}\n}\n\nint lca (int u, int v) {\n\tif (lvl[u] < lvl[v])\n\t\tswap(u, v);\n\n\tfor (int j = 0; j < LMX; j++)\n\t\tif (lvl[u] - lvl[v] & (1 << j))\n\t\t\tu = p[j][u];\n\n\tif (u == v)\n\t\treturn u;\n\n\tfor (int j = LMX - 1; j >= 0; j--)\n\t\tif (p[j][u] != p[j][v]) {\n\t\t\tu = p[j][u];\n\t\t\tv = p[j][v];\n\t\t}\n\n\treturn p[0][u];\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    \n    cin >> n;\n    for (int i = 0; i < n; i++) {\n    \tcin >> k;\n    \twhile (k--) {\n    \t\tcin >> u;\n    \t\tadj[i].push_back(u);\n    \t}\n    }\n\n   \tdfs(0);\n\n    cin >> q;\n    while (q--) {\n    \tcin >> u >> v;\n    \tcout << lca(u, v) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nint NextPow2(int x)\n{\n\tx--;\n\tfor(int i=1;i<32;i*=2) x|=x>>i;\n\treturn x+1;\n}\nconst int I=numeric_limits<int>::max();\nint F(int a,int b){return min(a,b);}\n\nstruct SegmentTree{\n\tint size;\n\tvi data,index;\n\tSegmentTree(int n):size(NextPow2(n)),data(size,I),index(size*2){\n\t\tiota(size+all(index),0);\n\t\tperi(i,1,size) index[i]=index[i*2];\n\t}\n\tSegmentTree(const vi& a):size(NextPow2(a.size())),data(size,I),index(size*2){\n\t\tcopy(all(a),begin(data));\n\t\tiota(size+all(index),0);\n\t\tperi(i,1,size){\n\t\t\tint u=index[i*2],v=index[i*2+1];\n\t\t\tindex[i]=data[u]==F(data[u],data[v])?u:v;\n\t\t}\n\t}\n\tvoid Update(int i,int x){\n\t\tdata[i]=x;\n\t\tfor(i+=size;i/=2;){\n\t\t\tint u=index[i*2],v=index[i*2+1];\n\t\t\tindex[i]=data[u]==F(data[u],data[v])?u:v;\n\t\t}\n\t}\n\tint QueryIndex(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return -1;\n\t\tif(a<=l && r<=b) return index[i];\n\t\tint u=QueryIndex(a,b,i*2,l,(l+r)/2),v=QueryIndex(a,b,i*2+1,(l+r)/2,r);\n\t\tif(u==-1 || v==-1) return u!=-1?u:v;\n\t\treturn data[u]==F(data[u],data[v])?u:v;\n\t}\n\tint QueryIndex(int a,int b){\n\t\treturn QueryIndex(a,b,1,0,size);\n\t}\n};\n\nstruct LCA{\n\tvi tour,fs;\n\tSegmentTree st;\n\tLCA(const Graph& g,int root):fs(g.size(),INF),st(1){\n\t\tvi ds;\n\t\tDFS(g,-1,root,0,ds);\n\t\trep(i,tour.size()) if(fs[tour[i]]==INF) fs[tour[i]]=i;\n\t\tst=SegmentTree(ds);\n\t}\n\tvoid DFS(const Graph& g,int p,int v,int d,vi& ds){\n\t\ttour.push_back(v);\n\t\tds.push_back(d);\n\t\tfor(auto e:g[v]) if(e.dst!=p){\n\t\t\tDFS(g,e.src,e.dst,d+1,ds);\n\t\t\ttour.push_back(v);\n\t\t\tds.push_back(d);\n\t\t}\n\t}\n\tint Find(int u,int v){\n\t\tif(fs[u]>fs[v]) swap(u,v);\n\t\treturn tour[st.QueryIndex(fs[u],fs[v]+1)];\n\t}\n};\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tGraph g(n);\n\t\trep(u,n){\n\t\t\tint k; cin>>k;\n\t\t\trep(i,k){\n\t\t\t\tint v; cin>>v;\n\t\t\t\tg[u].emplace_back(u,v);\n\t\t\t\tg[v].emplace_back(v,u);\n\t\t\t}\n\t\t}\n\t\tLCA lca(g,0);\n\t\t\n\t\tint q; cin>>q;\n\t\trep(_,q){\n\t\t\tint u,v; cin>>u>>v;\n\t\t\tcout<<lca.Find(u,v)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nclass HeavyLightDecomposition {\n    // [in[v], out[v]) に対応した列が v を頂点とした部分木に対応\npublic:\n    int n;\n    V< V<int> > edges;\n    V<int> subsz;\n    V<int> in, out, nxt;\n    V<int> par;\n\n    HeavyLightDecomposition(int n): n(n), edges(n), subsz(n, 0), in(n), out(n), nxt(n), par(n) {}\n\n    void add_edge(int u, int v) {\n        edges[u].emplace_back(v);\n    }\n\n    void calc_subsz(int i, int p) {\n        subsz[i] = 1;\n        par[i] = p;\n        if (edges[i].size() > 0 && edges[i][0] == p) swap(edges[i][0], edges[i].back());\n        for (int ei = 0; ei < (int)edges[i].size(); ei++) {\n            int e = edges[i][ei];\n            if (e == p) continue;\n            calc_subsz(e, i);\n            subsz[i] += subsz[e];\n            if (subsz[e] > subsz[edges[i][0]]) swap(edges[i][ei], edges[i][0]);\n        }\n    }\n\n    void hld(int i, int p, int &t) {\n        in[i] = t++;\n        for (int e: edges[i]) {\n            // nxt[e]: 分解した後の一番上の頂点\n            // e が分解後の一番上 (e == edges[i][0]) なら、その上の頂点の nxt を代入\n            if (e == p) continue;\n            nxt[e] = (e == edges[i][0] ? nxt[i] : e);\n            hld(e, i, t);\n        }\n        out[i] = t;\n    }\n\n    int lca(int u, int v) {\n        while (true) {\n            if (in[u] > in[v]) swap(u, v);\n            if (nxt[u] == nxt[v]) return u;\n            v = par[nxt[v]];\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    HeavyLightDecomposition hld(n);\n    for (int i = 0; i < n; i++) {\n        int k; cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c; cin >> c;\n            hld.add_edge(i, c);\n        }\n    }\n\n    hld.calc_subsz(0, -1);\n    int t = 0;\n    hld.hld(0, -1, t);\n\n    int q; cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v; cin >> u >> v;\n        cout << hld.lca(u, v) << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class V, class E>\nstruct Graph\n{\n\tint sz;\n\tvector<V> v;\n\tvector<vector<E>> e;\n\tGraph(int n) : sz(n), v(n), e(n) {}\n\ttemplate<class... Args>\n\tinline void assign_vertex(int pos, Args... args) {\n\t\tv[pos] = V(args...);\n\t}\n\ttemplate<class... Args>\n\tinline void add_edge(int pos, Args... args) {\n\t\te[pos].emplace_back(args...);\n\t}\n\tinline int size() {\n\t\treturn sz;\n\t}\n};\nstruct Vertex{};\nusing vertex = Vertex;\nstruct Edge\n{\n\tint to;\n\tEdge(int t) : to(t) {}\n\tEdge() {}\n};\n\nusing edge = Edge;\nusing graph = Graph<vertex, edge>;\ntemplate<class G>\nstruct LCA {\n\tint sz;\n\tvector<vector<int>> dp;\n\tvector<int> depth;\n\tint log2_n;\n\tLCA(G& g, int root) : sz(g.size()), depth(sz) {\n\t\tlog2_n = 0;\n\t\tfor (int t = sz; t; t /= 2, log2_n++);\n\t\tdp.resize(sz, vector<int>(log2_n, -1));\n\t\tdfs(g, root);\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tfor (int j = 1; j < log2_n; j++) {\n\t\t\t\tint t = dp[i][j-1];\n\t\t\t\tdp[i][j] = t == -1 ? -1 : dp[t][j-1];\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return sz;}\n\tvoid dfs(G& g, int root) {\n\t\tstack<tuple<int, int, int>> s;\n\t\ts.emplace(root, -1, 0);\n\t\twhile (!s.empty()) {\n\t\t\tint now, par, d;\n\t\t\ttie(now, par, d) = s.top(); s.pop();\n\t\t\tdp[now][0] = par;\n\t\t\tdepth[now] = d;\n\t\t\tfor (auto& x: g.e[now]) {\n\t\t\t\tif (x.to != par) s.emplace(x.to, now, d+1);\n\t\t\t}\n\t\t}\n\t}\n\tint get(int a, int b) {\n\t\tif (depth[a] > depth[b]) swap(a, b);\n\t\tfor (int i = 0; i < log2_n; i++) {\n\t\t\tif ((depth[b] - depth[a]) & (1 << i)) b = dp[b][i];\n\t\t}\n\t\tif (a == b) return a;\n\t\tfor (int i = log2_n - 1; i >= 0; i--) {\n\t\t\tif (dp[a][i] != dp[b][i]) {\n\t\t\t\ta = dp[a][i];\n\t\t\t\tb = dp[b][i];\n\t\t\t}\n\t\t}\n\t\treturn dp[a][0];\n\t}\n};\nusing lca = LCA<graph>;\n\nint main() {\n\tint N, Q;\n\tcin >> N;\n\tgraph G(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tfor (int j = 0; j < a; j++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tG.add_edge(i, t);\n\t\t\tG.add_edge(t, i);\n\t\t}\n\t}\n\tlca L(G, 0);\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tcout << L.get(a, b) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\nstruct LCA {\n    vector<vector<int>> par;\n    vector<int> dist;\n    LCA(const Graph &G, int root = 0) { init(G, root); }\n\n    void init(const Graph &G, int root = 0) {\n        int V = G.size();\n        int K = 1;\n        while ((1 << K) < V) K++;\n        par.assign(K, vector<int> (V, -1));\n        dist.assign(V, -1);\n        dfs(G, root, -1, 0);\n        for (int k = 0; k + 1 < K; k++) {\n            for (int v = 0; v < V; v++) {\n                if (par[k][v] < 0) {\n                    par[k + 1][v] = -1;\n                } else {\n                    par[k + 1][v] = par[k][par[k][v]];\n                }\n            }\n        }\n    }\n\n    void dfs(const Graph &G, int v, int p, int d) {\n        par[0][v] = p;\n        dist[v] = d;\n        for (auto to : G[v]) {\n            if (to != p) {\n                dfs(G, to, v, d + 1);\n            }\n        }\n    }\n\n    int query(int u, int v) {\n        if (dist[u] < dist[v]) swap(u, v);\n        int K = par.size();\n        for (int k = 0; k < K; k++) {\n            if ((dist[u] - dist[v]) >> k & 1) {\n                u = par[k][u];\n            }\n        }\n\n        if (u == v) return u;\n        for (int k = K - 1; k >= 0; --k) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n, vector<int>());\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int in;\n            cin >> in;\n            g[i].push_back(in);\n            g[in].push_back(i);\n        }\n    }\n    int q;\n    cin >> q;\n    auto lca = LCA(g, 0);\n    for (int i = 0; i < q; ++i) {\n        int a, b;\n        cin >> a >> b;\n        cout << lca.query(a, b) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst long long LINF = 1e18;\n#define dump(x)  cout << 'x' << ' = ' << (x) << ` `;\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define REPR(i,n) for(ll i=n;i>=0;i--)\n#define FOREACH(x,a) for(auto& (x) : (a) )\ntypedef long long ll;\nusing namespace std;\ntypedef pair<ll, ll> P;\n\ntemplate<typename T>\nvoid print(const vector<T> &x) {\n    int n = x.size();\n    rep(i,n) {\n        cout << x[i];\n        if (i!=n-1) cout<<\" \";\n        else cout << endl;\n    }\n}\n\ntemplate<typename T>\nvoid print(const vector<vector<T>> &x) {\n    int n = x.size();\n    rep(i,n) {\n        rep(j,x[i].size()) {\n            cout << x[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\ntemplate<typename T>\nvoid print(const vector<T> &x, int n) {\n    rep(i,n) {\n        cout << x[i];\n        if (i!=n-1) cout<<\" \";\n        else cout << endl;\n    }\n}\n\ntemplate<typename T>\nvoid print(const vector<vector<T>> &x, int n, int m) {\n    rep(i,n) {\n        rep(j,m) {\n            cout << x[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid input_init() {\n    cin.tie(0); ios::sync_with_stdio(false);\n}\n\nclass euler_tour {\npublic:\n    int n;\n    vector<int> vs;\n    vector<int> reach;\n    vector<int> depth;\n    vector<vector<int>> g;\n    euler_tour(int n, const vector<vector<int>> &g);\n    void dfs(int x, int p, int& id, int d);\n    ~euler_tour();\n};\n\neuler_tour::euler_tour(int _n, const vector<vector<int>>& _g) {\n    n = _n;\n    g = _g;\n    reach.assign(n,-1);\n    int id = 0;\n    dfs(0,-1,id,0);\n}\n\nvoid euler_tour::dfs(int x, int p, int &id, int d) {\n    if (reach[x] == -1) reach[x] = id;\n    depth.push_back(d);\n    vs.push_back(x);\n    id++;\n    for (auto &&e: g[x]) {\n        if (e == p) continue;\n        dfs(e, x, id, d+1);\n        depth.push_back(d);\n        vs.push_back(x);\n        id++;\n    }\n    return;\n}\n\neuler_tour::~euler_tour() {\n}\n\ntemplate <class T>\nclass SegTree {\n    int n; // number of leaves\n    vector<T> data; // vector which has datas\n    T def; // init number & 単位元\n    function<T(T,T)> operation; // 区間クエリで使う処理\n    function<T(T,T)> update; // 点更新で使う処理\n\n    T _query(int a, int b, int k, int l, int r) {\n        // [a, b)のクエリ\n        // ノードk(区間[l, r)担当)が答える\n        if (b <= l || r <= a) return def; // 区間がかぶらなければdef\n        if (a <= l && r <= b) return data[k]; // 区間が完全にかぶっていればdata[k]\n        else {\n            // 一部だけかぶる場合は左右の子に委託する\n            T c1 = _query(a, b, 2*k+1, l, (l+r)/2);\n            T c2 = _query(a, b, 2*k+2, (l+r)/2, r);\n            return operation(c1, c2);\n        }\n    }\n\n    public:\n\n        SegTree(size_t _n, T _def, function<T(T,T)> _operation, function<T(T,T)> _update) :\n            def(_def), operation(_operation), update(_update){\n                n = 1;\n                while (n < _n) {n *= 2;}\n                data = vector<T>(2*n-1, def);\n        }\n\n        T query(int a, int b) {return _query(a,b,0,0,n);}\n\n        void change(int i, T x) {\n            i += n-1;\n            data[i] = update(data[i],x);\n            while (i>0) {\n                i = (i-1)/2;\n                data[i] = operation(data[i*2+1], data[i*2+2]);\n            }\n        }\n\n        T operator[](int i) {return data[i+n-1];}\n};\n\nclass lowest_common_ancestor {\nprivate:\n    int n;\n    SegTree<P> rmq;\n    euler_tour et;\npublic:\n    lowest_common_ancestor(const euler_tour &et, SegTree<P> rmq);\n    int get_lca(int x, int y);\n    ~lowest_common_ancestor();\n};\n\nlowest_common_ancestor::lowest_common_ancestor(const euler_tour &_et, SegTree<P> _rmq): et(_et),rmq(_rmq){\n    n = et.depth.size();\n    rep(i,n) {\n        rmq.change(i, P(et.depth[i], et.vs[i]));\n    }\n}\n\nint lowest_common_ancestor::get_lca(int x, int y) {\n    int l = et.reach[x]; int r = et.reach[y];\n    if (l > r) swap(l,r);\n    P res = rmq.query(l,r+1);\n    return res.second;\n}\n\nlowest_common_ancestor::~lowest_common_ancestor() {\n}\n\n\n\nint main(int argc, char const *argv[]) {\n    int n; cin>>n;\n    vector<vector<int>> g(n);\n    rep(i,n) {\n        int k; cin>>k;\n        rep(j,k) {\n            int t; cin>>t;\n            g[i].push_back(t);\n            g[t].push_back(i);\n        }\n    }\n\n    euler_tour et(n, g);\n    SegTree<P> rmq(et.depth.size(), P(LINF,LINF), [](P x, P y) {return min(x,y);}, [](P a, P x) {return x;});\n    lowest_common_ancestor lca(et,rmq);\n\n\n    int q; cin>>q;\n\n    while (q--) {\n        int u,v; cin>>u>>v;\n        cout << lca.get_lca(u,v) << '\\n';\n    }\n    /*\n    cout << \"----------------\" << '\\n';\n    vector<int> h(n);\n    rep(i,n) h[i] = i;\n    print(h);\n    print(et.reach);\n    print(et.vs);\n    print(et.depth);\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size) {for(int i=0;i<size;i++)data[i]=i;}\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    //if (x != y) {\n      //if (data[y] < data[x]) swap(x, y);\n      //data[x] += data[y];\n\t  data[y] = x;\n    //}\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x]==x ? x : (data[x] = root(data[x]));\n  }\n};\n\nstruct Query {\n  int u, v, w;\n  Query(int u, int v) : u(u), v(v), w(-1) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<Query> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf) {\n  ancestor[ uf.root(u) ] = u;\n  FOR(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  FOR(q, qs) {\n    int w = (q->v == u ? q->u : q->u == u ? q->v : -1);\n    if (w >= 0 && color[w]) q->w = ancestor[ uf.root(w) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<Query> &qs) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf);\n}\n\nint main(){\n\tint k,i,V,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d\",&V);\n\t\tGraph g(V);\n\t\tfor(i=0;i<V;i++)for(scanf(\"%d\",&k);k--;)\n\t\t\tscanf(\"%d\",&t),g[i].push_back(Edge(i,t,1)),g[t].push_back(Edge(t,i,1));\n\t\tvector<Query>qs;\n\t\tfor(scanf(\"%d\",&k),i=0;i<k;i++){\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tqs.push_back(Query(s,t));\n\t\t}\n\t\tleastCommonAncestor(g,0,qs);\n\t\tfor(i=0;i<k;i++)printf(\"%d\\n\",qs[i].w);\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst int sqrtN = 512;\nconst int logN = 64;\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nstruct LowestCommonAncestor{\n\tvector<vector<int>> g, parent;\n\tvector<int> depth;\n\tbool built = false;\n\tint N;\n\t\n\tLowestCommonAncestor(int n) : N(n) {\n\t\tg.resize(N);\n\t\tparent.resize(logN, vector<int>(N));\n\t\tdepth.resize(N);\n\t}\n\t\n\tvoid add_edge(int u, int v){\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int par = -1, int d = 0){\n\t\tparent[0][v] = par;\n\t\tdepth[v] = d;\n\t\t\n\t\tfor(auto e:g[v]){\n\t\t\tif(e == par) continue;\n\t\t\tdfs(e, v, d + 1);\n\t\t}\n\t}\n\t\n\tvoid build(){\n\t\tdfs(0);\n\t\tREP(k, 0, logN - 1){\n\t\t\tREP(i, 0, N){\n\t\t\t\tif(parent[k][i] < 0) parent[k + 1][i] = -1;\n\t\t\t\telse parent[k + 1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint get(int u, int v){\n\t\tif(!built) build(); built = true;\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\t\n\t\tREP(k, 0, logN) if(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\t\n\t\tif(u == v) return u;\n\t\t\n\t\tRREP(k, logN - 1, 0){\n\t\t\tif(parent[k][u] == parent[k][v]) continue;\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\t\t\t\n\t\t}\n\t\t\n\t\treturn parent[0][u];\n\t}\n};\n\nint main(){\n\tint n; cin >> n;\n\tLowestCommonAncestor lca(n);\n\tREP(i, 0, n){\n\t\tint a; cin >> a;\n\t\tREP(j, 0, a){\n\t\t\tint u; cin >> u;\n\t\t\tlca.add_edge(i, u);\n\t\t}\n\t}\n\t\n\tint q; cin >> q;\n\tREP(i, 0, q){\n\t\tint a,b; cin >> a >> b;\n\t\tcout << lca.get(a, b) << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repr(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repr(i,0,n)\n#define reprrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) reprrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define exist(container, item) (find(container.begin(),container.end(),item)!=container.end())\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFL 9e18\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<Pi> vPi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<Pi> > vvPi;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<Pi, vector<Pi>, greater<Pi> > pqlP;\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate<class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nstring debug_show(Pi a) {\n\treturn \"(\" + to_string(a.first) + \",\" + to_string(a.second) + \")\";\n}\n\ntemplate<class T>\nstruct augEdge {\n\tT from, to;\n\tint cost;\n\tbool operator<(augEdge e) { return cost < e.cost; }\n\tbool operator>(augEdge e) { return cost > e.cost; }\n};\ntemplate<class T>\nusing augGraph = vector<augEdge<T>>;\n\nclass LCA {\npublic:\n\tint N;\n\tvi depth;\n\tint maxdepth = 0;\n\tvvi dblpar;\n\n\tLCA(const Graph G) {\n\t\tN = G.size();\n\t\tdepth = vi(N);\n\t\tdfs1(G, 0);\n\t\tint D = bindigit(maxdepth) + 1;\n\t\tdblpar = vvi(D, vi(N));\n\t\trep(i, D) {\n\t\t\tdfs2(G, 0, 0, i);\n\t\t}\n\t}\n\n\tvoid dfs1(const Graph &G, int pos, int d = 0) {\n\t\tdepth[pos] = d;\n\t\tmaxdepth = max(maxdepth, d);\n\t\tfor (auto ch : G[pos]) {\n\t\t\tdfs1(G, ch.to, d + 1);\n\t\t}\n\t}\n\n\tvoid dfs2(const Graph &G, int pos, int par, int dbl) {\n\t\tif (dbl == 0) {\n\t\t\tdblpar[0][pos] = par;\n\t\t}\n\t\telse {\n\t\t\tdblpar[dbl][pos] = dblpar[dbl - 1][dblpar[dbl - 1][pos]];\n\t\t}\n\t\tfor (auto ch : G[pos]) {\n\t\t\tdfs2(G, ch.to, pos, dbl);\n\t\t}\n\t}\n\n\tint parent(int pos, int step) {\n\t\tint ret = pos;\n\t\tint dbl = 0;\n\t\twhile (step > 0) {\n\t\t\tif ((step & 1) != 0) {\n\t\t\t\tret = dblpar[dbl][ret];\n\t\t\t}\n\t\t\tstep >>= 1;\n\t\t\tdbl++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint bindigit(int n) {\n\t\tint ret = 0;\n\t\twhile (n > 0) {\n\t\t\tret++;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint lca(int u, int v) {\n\t\tif (depth[u] < depth[v]) {\n\t\t\tswap(u, v);\n\t\t}\n\t\tu = parent(u, depth[u] - depth[v]);\n\t\tint ng = -1, ok = depth[u];\n\t\twhile (ok - ng > 1) {\n\t\t\tint mid = (ok + ng) / 2;\n\t\t\tif (parent(u, mid) == parent(v, mid)) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn parent(u, ok);\n\t}\n};\n\n\nint main(void) {\n\tint N;\n\tcin >> N;\n\tGraph G(N);\n\trep(i, N) {\n\t\tint num;\n\t\tcin >> num;\n\t\trep(j, num) {\n\t\t\tint ch;\n\t\t\tcin >> ch;\n\t\t\tG[i].push_back(Edge{ i,ch,1 });\n\t\t}\n\t}\n\n\tLCA lca(G);\n\n\tint Q;\n\tcin >> Q;\n\trep(q, Q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.lca(u, v) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class SparseTable {\nprivate:\n    vector<T> Arr;\n    vector<int> LogTable;\n    vector<vector<int> > Table; //最小値のインデックスを保持\n    int sz;\npublic:\n    void resize(vector<T>& v){\n        sz = (int)v.size();\n        Arr = v;\n        LogTable.resize(sz+1);\n        for(int i = 2; i < sz + 1; i++){\n            LogTable[i] = LogTable[i >> 1] + 1;\n        }\n        Table.resize(sz,vector<T>(LogTable[sz]+1));\n        rep(i,sz){\n            Table[i][0] = i;\n        }\n        for(int k = 1; (1 << k) <= sz; k++){\n            for(int i = 0; i + (1 << k) <= sz; i++){\n                int s = Table[i][k-1];\n                int t = Table[i + (1 << (k-1))][k-1];\n                if(Arr[s] < Arr[t]){\n                    Table[i][k] = s;\n                }else{\n                    Table[i][k] = t;\n                }\n            }\n        }\n    }\n    pair<T,int> query(int l,int r){\n        int k = LogTable[r-l];\n        if(Arr[Table[l][k]] < Arr[Table[r-(1<<k)][k]]){\n            return make_pair(Arr[Table[l][k]],Table[l][k]);\n        }else{\n            return make_pair(Arr[Table[r-(1<<k)][k]],Table[r-(1<<k)][k]);\n        }\n    }\n};\n\nclass LCA{\npublic:\n    vector<int> ord,depth,id;\n    vector<vector<int> > G;\n    SparseTable<int> st;\n    int V;\n    LCA(int node_size){\n        V = node_size;\n        G.resize(V),depth.resize(V),id.resize(V,-1);\n    }\n    void add_edge(int from,int to){\n        G[from].push_back(to),G[to].push_back(from);\n    }\n    void dfs(int u,int p,int k){\n        id[u] = (int)ord.size();\n        ord.push_back(u);\n        depth[u] = k;\n        rep(i,G[u].size()){\n            if(G[u][i] != p){\n                dfs(G[u][i],u,k+1);\n                ord.push_back(u);\n            }\n        }\n    }\n    void build(){\n        rep(i,V){\n            if(id[i] < 0){\n                dfs(i,-1,0);\n            }\n        }\n        vector<int> stvec((int)ord.size());\n    \trep(i,ord.size()){\n    \t\tstvec[i] = depth[ord[i]];\n    \t}\n        st.resize(stvec);\n    }\n    int solve(int u,int v){\n        return ord[st.query(min(id[u],id[v]),max(id[u],id[v])+1).second];\n    }\n    int dist(int u,int v){\n        int lca = solve(u,v);\n        return depth[u] + depth[v] - 2*depth[lca];\n    }\n};\n\nvector<int> G[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n\tLCA lca(n);\n\trep(i,n){\n\t\tint cnt;\n\t\tcin >> cnt;\n\t\trep(j,cnt){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tlca.add_edge(i,a);\n\t\t}\n\t}\n\tlca.build();\n\tint q;\n\tcin >> q;\n\trep(i,q){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcout << lca.solve(a,b) << \"\\n\";\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nint n;\nvector<int> vs[100005];\n\nint ans[100005];\n\nset<int> s[100005];\n\nvoid dfs(int no){\n\trep(i,vs[no].size()){\n\t\tdfs(vs[no][i]);\n\t}\n\t\n\trep(i,vs[no].size()){\n\t\tint to=vs[no][i];\n\t\tif(s[to].size()>s[no].size())swap(s[no],s[to]);\n\t\t\n\t\tfor(set<int>::iterator ite=s[to].begin(); ite!=s[to].end(); ite++){\n\t\t\tint p=*ite;\n\t\t\tif(s[no].count(p)>=1){\n\t\t\t\ts[no].erase(p);\n\t\t\t\tans[p]=no;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[no].insert(p);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\trep(j,k){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tvs[i].push_back(a);\n\t\t}\n\t}\n\t\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a==b)ans[i]=a;\n\t\telse{\n\t\t\ts[a].insert(i);\n\t\t\ts[b].insert(i);\n\t\t}\n\t}\n\t\n\tdfs(0);\n\t\n\trep(i,q){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INF = 2147483647;\nconst long long LINF = 1LL<<60;\nconst long long MOD = 1000000007; // 998244353\n\n#define CLR(a) memset((a), 0, sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nstruct Node{\n    int id;\n    int v;\n    bool done = false;\n    Node(int id, int v=1e9): id(id), v(v) {}\n    Node(): id(0), v(1e9) {}\n};\n\nbool operator>(Node a, Node  b){\n    return a.v > b.v;\n}\n\nstruct Edge{\n    int from, to, id;\n    int cost;\n    Edge(int from, int to, int cost=1, int id=-1): from(from), to(to), cost(cost), id(id) {}\n};\n\nstruct Graph{\n    int N;\n    vector<vector<Edge>> adj;\n    vector<Node> node;\n\n    Graph(int N): N(N) {\n        adj.assign(N, vector<Edge>());\n        node.assign(N, Node());\n        for(int i=0; i<N; ++i) node[i].id = i;\n    }\n\n    Graph() {}\n\n    void add_edge(int i, int j, int cost=1, int id=-1){\n        Edge e(i, j, cost, id);\n        adj[i].emplace_back(e);\n    }\n\n    vector<Edge> get_adj(Node node){\n        return adj[node.id];\n    }\n\n    void assign(int n){\n        N = n;\n        adj.assign(N, vector<Edge>());\n        node.assign(N, Node());\n        for(int i=0; i<N; ++i) node[i].id = i;\n    }\n\n    void reset(){\n        for(int i=0; i<N; ++i){\n            node[i].done = false;\n            node[i].v = 1e9;\n        }\n    }\n};\n\nint N, LOGN;\nGraph G;\nVVI tab;\nVI depth;\nvoid doubling(){\n    for(int i=0; i<N; i++) tab[i][0] = -1;\n\n    for(int i=0; i<N; i++){\n        for(Edge e : G.adj[i]) tab[e.to][0] = i;\n    }\n\n    for(int k=0; k<LOGN; k++)\n        for(int i=0; i<N; i++){\n            if(tab[i][k] == -1) tab[i][k+1] = -1;\n            else tab[i][k+1] = tab[tab[i][k]][k];\n        }\n}\n\nint LCA(int u, int v){\n    int k = depth[v] - depth[u];\n    for(int i=0; i<LOGN; i++){\n        if(k & 1<<i) v = tab[v][i];\n    }\n    if(u == v) return u;\n    for(int i=LOGN; i>=0; i--){\n        if(tab[u][i] != tab[v][i]){\n            u = tab[u][i];\n            v = tab[v][i];\n        }\n    }\n    return tab[u][0];\n}\n\nvoid dfs(int n, int d){\n    depth[n] = d;\n    for(Edge e : G.adj[n]){\n        dfs(e.to, d+1);\n    }\n    return;\n}\n\nint main() {\n\tcin >> N;\n    G.assign(N);\n    LOGN = floor(log2(N)) + 1;\n    tab.assign(N, VI(LOGN+1)); depth.resize(N);\n    REP(i,N){\n        int k; cin >> k;\n        REP(j,k){\n            int c; cin >> c;\n            G.add_edge(i,c);\n        }\n    }\n    dfs(0,0);\n    doubling();\n    int q; cin >> q;\n    REP(i,q){\n        int u,v; cin >> u >> v;\n        if(depth[u] > depth[v]) swap(u,v);\n        cout << LCA(u,v) << en;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.assign(2 * size - 1, make_pair(INF, -1));\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = make_pair(depth[i], et[i]);\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn make_pair(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].emplace_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(min(id[u], id[v]), max(id[u], id[v]) + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nstruct LinkCutTree{;\n    struct Node{\n        Node *lp,*rp,*pp;\n        Node():lp(0),rp(0),pp(0){}\n        bool isRoot(){\n            return !pp||(pp->lp!=this&&pp->rp!=this);\n        }\n        void rotR(){\n            Node *q=pp,*r=q->pp;\n            if((q->lp=rp))rp->pp=q;\n            rp=q;q->pp=this;\n            if((pp=r)){\n                if(r->lp==q)r->lp=this;\n                if(r->rp==q)r->rp=this;\n            }\n        }\n\n        void rotL(){\n            Node *q=pp,*r=q->pp;\n            if((q->rp=lp))lp->pp=q;\n            lp=q;q->pp=this;\n            if((pp=r)){\n                if(r->lp==q)r->lp=this;\n                if(r->rp==q)r->rp=this;\n            }\n        }\n\n        void splay(){\n            while(!isRoot()){\n                Node *q=pp;\n                if(q->isRoot()){\n                    if(q->lp==this)rotR();\n                    else rotL();\n                }\n                else{\n                    Node *r=q->pp;\n                    if(r->lp==q){\n                        if(q->lp==this){q->rotR();rotR();}\n                        else {rotL();rotR();}\n                    }\n                    else{\n                        if(q->rp==this){q->rotL();rotL();}\n                        else{rotR();rotL();}\n                    }\n                }\n            }\n        }\n\n        void expose(){\n            Node *rp=NULL;\n            for(Node *p=this;p;p=p->pp){\n                p->splay();\n                p->rp=rp;\n                rp=p;\n            }\n            splay();\n        }\n    };\n\n    Node *nodes;\n    LinkCutTree(int n){nodes=new Node[n];}\n\n    //???(v->v??????)?????????\n    void cut(int v){\n        nodes[v].expose();\n        Node *p=nodes[v].lp;\n        nodes[v].lp=NULL;\n        p->pp=NULL;\n    }\n\n    //???(v->u)?????????\n    void link(int v,int u){\n        nodes[v].expose();\n        nodes[u].expose();\n        nodes[v].pp=&nodes[u];\n        nodes[u].rp=&nodes[v];\n    }\n\n    int lca(int a,int b){\n        nodes[a].expose();\n        nodes[b].expose();\n\n        bool sameTree=false;\n        Node *ret=&nodes[a];\n        for(Node *x=&nodes[a];x;x=x->pp){\n            if(x->pp&&x->isRoot())ret=x->pp;\n            if(x==&nodes[b])sameTree=true;\n        }\n        return sameTree?(ret-nodes):-1;\n    }\n\n\n    //verify??????\n    int findRoot(int v){\n        Node *p=&nodes[v];\n        p->expose();\n        while(p->lp)p=p->lp;\n        p->splay();\n        return p-nodes;\n    }\n};\n\n\nsigned main(){\n    int N;scanf(\"%lld\",&N);\n    LinkCutTree lct(N);\n    rep(i,N){\n        int k;scanf(\"%lld\",&k);\n        while(k--){\n            int c;scanf(\"%lld\",&c);\n            lct.link(c,i);\n        }\n    }\n    int q;scanf(\"%lld\",&q);\n    while(q--){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n        printf(\"%lld\\n\",lct.lca(a,b));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1005;\n\nint N, Q;\nint T[MAXN], L[MAXN], P[MAXN][20];  // direct parent, depth, ancestor\nvector<int> adjList[MAXN];\n\nvoid dfs(int node = 0, int depth = 0) {\n    L[node] = depth;\n    for (int i = 0; i < adjList[node].size(); i++) {\n        int child = adjList[node][i];\n        dfs(child,depth+1);\n    }\n}\n\nint query(int u, int v) {\n    int tmp;\n    if (L[u] < L[v])\n        tmp = u, u = v, v = tmp;\n\n    int LOG2;\n    for (LOG2 = 1; 1 << LOG2 <= L[u]; LOG2++); LOG2--;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (L[u] - (1 << i) >= L[v])\n            u = P[u][i];\n\n    if (u == v)\n        return u;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (P[u][i] != -1 && P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n\n    return T[u];\n}\n\nint main() {\n\n\n    scanf(\"%d\",&N);\n    for (int u = 0, M; u < N; u++) {\n        scanf(\"%d\",&M);\n        for (int i = 0, v; i < M; i++) {\n            scanf(\"%d\",&v);\n\n            T[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted at 0\n    dfs();\n\n    for (int i = 1; i <= N; i++)\n        P[i][0] = T[i];\n    for (int j = 1; 1 << j < N; j++)\n        for (int i = 1; i <= N; i++)\n            if (P[i][j-1] != -1)\n                P[i][j] = P[P[i][j-1]][j-1];\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v; i < Q; i++) {\n        scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\", query(u,v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\ntypedef vector<vii> vvii;\ntypedef vector<int>::iterator vit;\n\nconst int MAXN = 100005;\nconst int LOGN = 20;\n\nint idx[MAXN]; // i : index of node i in dfs path\nii path[MAXN << 1];\nvi adjList[MAXN];\n\nii ST[LOGN][MAXN];\n\nvoid build(int n) {\n    int h = (n == 1 ? 1 : ceil(log2(n)));\n\n    for (int i = 0; i < n; i++) ST[0][i] = path[i];\n    for (int i = 1; i < h; i++)\n        for (int j = 0; j + (1<<i) <= n; j++)\n            ST[i][j] = min(ST[i-1][j], ST[i-1][j+(1<<(i-1))]);\n}\n\nint RMQ(int l, int r) {    // range [l,r)\n    int p = 31 - __builtin_clz(r-l);\n    return min(ST[p][l],ST[p][r-(1<<p)]).se;\n}\n\n// build dfs path, depth\nint cnt = 0;\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n\n    path[cnt++] = ii(d,curr);\n    for (vit it = adjList[curr].begin(); it != adjList[curr].end(); it++) {\n        dfs(*it,d+1);\n\n        path[cnt++] = ii(d,curr);\n    }\n}\n\nint N, M, Q, v;\n\nint main(){\n\n    scanf(\"%d\",&N);\n    for (int u = 0; u < N; u++){\n        scanf(\"%d\",&M);\n        for (int i = 0; i < M; i++){\n            scanf(\"%d\",&v);\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted as 0\n    dfs(0,0);\n    build(cnt);\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v, l, r; i < Q; i++){\n    scanf(\"%d%d\",&u,&v);\n\n        l = idx[u], r = idx[v]; if (l > r) swap(l,r);\n\n        printf(\"%d\\n\",RMQ(l,r+1));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) ord[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  // std::freopen(\"in_large.txt\", \"r\", stdin);\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint n, q;\n\nbool f[100100];\n\nstruct LCA {\n\tint s;\n\tvector<int> G[100100];//????????°??????\n\tint p[30][100100];\n\tint depth[100100] = {};\n\n\tvoid init() {\n\t\tREP(i, 30) {\n\t\t\tREP(j, 100100)p[i][j] = -1;\n\t\t}\n\t}\n\tvoid dfs(int now,int d,int pre){\n\t\tif (pre != -1)p[0][now] = pre;\n\t\tdepth[now] = d;\n\t\tREP(i, G[now].size()) {\n\t\t\tdfs(G[now][i], d + 1, now);\n\t\t}\n\t}\n\tvoid make_p() {\n\t\tFOR(i, 1, 30) {\n\t\t\tREP(j, 100100) {\n\t\t\t\tp[i][j] = p[i - 1][p[i - 1][j]];\n\t\t\t}\n\t\t}\n\t}\n\tint query(int u, int v) {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int i = 30 - 1; i >= 0; i--) {\n\t\t\tint d = depth[v] - depth[u];\n\t\t\tif (d >= (1 << i)) v = p[i][v];\n\t\t}\n\t\tfor (int i = 30 - 1; i >= 0; i--) {\n\t\t\tif (p[i][u] != p[i][v]) {\n\t\t\t\tu = p[i][u];\n\t\t\t\tv = p[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\treturn p[0][u];\n\t}\n};\n\nLCA lca;\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\tREP(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tf[c] = 1;\n\t\t\tlca.G[i].push_back(c);\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tif (!f[i]) {\n\t\t\tlca.s = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlca.init();\n\tlca.dfs(lca.s, 0, -1);\n\tlca.make_p(); \n\tcin >> q;\n\tREP(i, q) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tcout << lca.query(u, v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <map>\n#include <unordered_map>\n#include <utility>\n\n#define MAXN 100000\n\nusing namespace std;\n\nint pre[MAXN] = {-1};\nint st[MAXN];\n\nvector<pair<int,int>> vp;\nmap<pair<int,int>,int> mans;\n\nstruct pair_hash {\n    template <class T1, class T2>\n    size_t operator () (const pair<T1, T2> &p)const {\n        auto h1 = hash<T1>{}(p.first);\n        auto h2 = hash<T2>{}(p.second);\n        return h1 + h2;\n    }\n};\n\nunordered_map<pair<int,int>,int,pair_hash> seek;\n\nvoid swap(int &i,int &j){\n    int t = i;\n    i = j;\n    j = t;\n}\n\n\nclass Edge{\npublic:\n    int s;\n    int t;\n    Edge(int si,int ti):s(si),t(ti){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    vector<forward_list<int>> adj;\n    Graph(int v):V(v){\n        adj.resize(v);\n        for(int i = 0; i < V;i++) {st[i] = i;pre[i] = -1;}\n        }\n    void addEdge(int i,int j){adj[i].push_front(j);}\n    void tarjanR(Edge e);\n};\n\nint root(int v){\n    while(st[v] != v) v = st[v];\n    return v;\n}\n\nvoid Graph::tarjanR(Edge e){\n    int t = e.t;\n    int s = e.s;\n    pre[t] = 0;\n\n    for(auto a = adj[t].begin();a != adj[t].end();++a){\n        int v = *a;\n        if(pre[v] == -1){\n            tarjanR(Edge(t,v));\n        }\n    }\n    for(int i = 0; i < V;i++){\n        int mi = i,ma = t;\n        if(mi > ma) swap(mi,ma);\n        pair<int,int> p = make_pair(mi,ma);\n        if(pre[i] != -1 && seek.find(p)!=seek.end() && seek[p] == -1){\n            seek[p] = root(i);\n        }\n    }\n    st[t] = s;\n}\n\n\nint main()\n{\n    int V,j,q,tt;\n    scanf(\"%d\",&V);\n    Graph G(V);\n    for(int i = 0; i < V; i++){\n        scanf(\"%d\",&j);\n        for(int k = 0; k < j;k++)\n        {\n            scanf(\"%d\",&tt);\n            G.addEdge(i,tt);\n        }\n    }\n\n    int s,t;\n\n    scanf(\"%d\",&q);\n    for(int i = 0; i < q;i++){\n        scanf(\"%d %d\",&s,&t);\n        if(s > t){swap(s,t);}\n        vp.push_back(make_pair(s,t));\n        seek[make_pair(s,t)] = -1;\n    }\n\n    G.tarjanR(Edge(0,0));\n\n    for(int i = 0; i < q;i++){\n        printf(\"%d\\n\",seek[vp[i]]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\ntypedef vector<vector<int>> Graph;\n//O(Q * logN)\nclass DoublingLCA{\n\tGraph& g;int r;\n\tvector<vector<int> > parent;\n\tvector<int> depth;\npublic:\n\tDoublingLCA(Graph& g,int r):g(g),r(r),parent(msb(g.size())+1,vector<int>(g.size())),depth(vector<int>(g.size())){\n\t\tdfs(-1,r,0);\n\t\tfor(int l:range(1,parent.size()))for(int v:range(parent[l].size()))\n\t\t\tparent[l][v] == (parent[l-1][v]==-1)?-1:parent[l-1][parent[l-1][v]];\n\t}\n\tvoid dfs(int p,int v,int d){\n\t\tparent[0][v]=p;depth[v]=d;\n\t\tfor(int t:g[v])if(t!=p)dfs(v,t,d+1);\n\t}\n\tint lca(int u,int v){\n\t\tif(depth[u]>depth[v])swap(u,v);\n\t\tREP(l,parent.size()){\n\t\t\tif(!((depth[v]-depth[u])&(1<<l)))continue;\n\t\t\tv=parent[l][v];\n\t\t}\n\t\t//: depth[u] == depth[v]\n\t\tif(u==v) return u;\n\t\t//binary search\n\t\tfor(int l=parent.size()-1;l>=0;l--){\n\t\t\tif(parent[l][u]==parent[l][v])continue;\n\t\t\tu=parent[l][u];\n\t\t\tv=parent[l][v];\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t);\n\t\t\t\tg[t].push_back(i);\n\t\t\t}\n\t\t}\n\t\tDoublingLCA lca(g,0);\n\t\tint q;cin >>q;\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tcout << lca.lca(u,v) <<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define INCLUDE_RMQ_HPP\n#include <algorithm>\n#include <cassert>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#define INCLUDE_EULER_TOUR_HPP\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> begin, end;\n  std::vector<int> id, depth;\n\n  EulerTour(int N) : T(N), begin(N), end(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) begin[f.u] = id.size();\n      end[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#include <utility>\n\nstruct LCA {\n  EulerTour euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.begin[u];\n    int r = euler_tour.begin[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(std::move(et));\n\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct LowestCommonAncestor{\n  int n,h;\n  vector<vector<int> > G,par;\n  vector<int> dep;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int n):n(n),G(n),dep(n){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n  }\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    for(int u:G[v])\n      if(u!=p) dfs(u,v,d+1);\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<h;k++){\n      for(int v=0;v<n;v++){\n\tif(par[k][v]<0) par[k+1][v]=-1;\n\telse par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int k=0;k<h;k++){\n      if((dep[v]-dep[u])>>k&1){\n\tv=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=h-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n\tu=par[k][u];\n\tv=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n;\n  cin>>n;\n  LowestCommonAncestor lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2018/05/16\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass LowestCommonAncestor\n{\npublic:\n    LowestCommonAncestor(const Graph& g, const int root = 0) : left(g.V, 0)  // 無向根付き木\n    {\n        vector<bool> used(g.V, false);\n        auto dfs = fix([&](auto&& self, const pair<int, int>& s) -> void {\n            used[s.second] = true;\n            const int pos = s.second;\n            left[pos] = depth.size();\n            depth.push_back(s);\n            for (const int to : g.edge[pos]) {\n                if (used[to]) { continue; }\n                self(self, {s.first + 1, to});\n                depth.push_back(s);\n            }\n        });\n        dfs(make_pair(0, root));\n    }\n    int LCA(const int u, const int v) const\n    {\n        static const SparseTable<DepthMin> st{depth};\n        const int ul = left[u];\n        const int vl = left[v];\n        return st.accumulate(min(ul, vl), max(ul, vl) + 1).second;\n    }\n\nprivate:\n    struct DepthMin\n    {\n        using T = pair<int, int>;\n        T operator()(const T& a, const T& b) const { return min(a, b); }\n    };\n    vector<int> left;\n    vector<pair<int, int>> depth;\n};\n\n\n\ntemplate <typename Base>\nclass SparseTable\n{\npublic:\n    using T = typename Base::T;\n    using SemiLattice = Base;\n    SparseTable(const vector<T>& val)\n        : size(val.size()), lg2(size + 1, 0)\n    {\n        for (int i = 2; i <= size; i++) {\n            lg2[i] = lg2[i / 2] + 1;\n        }\n        table.resize(size, vector<T>(lg2[size] + 1));\n        for (int i = 0; i < size; i++) {\n            table[i][0] = val[i];\n        }\n        for (int j = 0; j < lg2[size]; j++) {\n            const int w = 1 << j;\n            for (int i = 0; i <= size - (w << 1); i++) {\n                T tl = table[i][j], tr = table[i + w][j];\n                table[i][j + 1] = op(tl, tr);\n            }\n        }\n    }\n    T accumulate(const int l, const int r) const\n    {\n        assert(0 <= l and l < r and r <= size);\n        const int j = lg2[r - l];\n        return op(table[l][j], table[r - (1 << j)][j]);\n    }\n\nprivate:\n    const int size;\n    vector<int> lg2;\n    vector<vector<T>> table;\n    const SemiLattice op{};\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n// Status: Accepted\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g.addEdge(i, c);\n        }\n    }\n\n    LowestCommonAncestor lca{g};\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.LCA(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<climits>\nusing namespace std;\n\n\n\n\nclass SparseTableRMQ{\n\tint maxlog;\n\tstd::vector<int> a;\n\tstd::vector<char> log;\n\tstd::vector<int> M;\npublic:\n\tSparseTableRMQ(){}\n\tvoid build(const std::vector<int> &a){\n\t\tthis->a=a;\n\t\tint n=a.size();\n\t\tlog.resize(n+1);\n\t\tlog[0]=0;\n\t\tfor(int i=1,a=0;i<=n;i++){\n\t\t\tif((1<<a+1)<i)a++;\n\t\t\tlog[i]=a;\n\t\t}\n\t\tmaxlog=log[n]+1;\n\t\tM.resize(n*maxlog);\n\t\tfor(int i=0;i<n;i++)M[i*maxlog]=i;\n\t\tfor(int j=1;1<<j<=n;j++){\n\t\t\tfor(int i=0;i+(1<<j)-1<n;i++){\n\t\t\t\tint n=M[i*maxlog+j-1];\n\t\t\t\tint m=M[(i+(1<<j-1))*maxlog+j-1];\n\t\t\t\tM[i*maxlog+j] = a[n]<a[m]?n:m;\n\t\t\t}\n\t\t}\n\t}\n\tint query(int i,int j)const{//[i,j)の最小値\n\t\tint k=log[j-i];\n\t\tint n=M[i*maxlog+k];\n\t\tint m=M[(j-(1<<k))*maxlog+k];\n\t\treturn a[n]<a[m]?n:m;\n\t}\n};\n\n\n\nclass RMQsub1{\n\tstd::vector<int> pattern;\n\tstd::vector<std::vector<int> > minpos;\n\tstd::vector<int> depth;\n\tSparseTableRMQ rmq;\n\tint blocksize;\n\tint n;\npublic:\n\tRMQsub1(){}\n\tvoid build(std::vector<int> &a){\n\t\tdepth=a;\n\t\tstd::vector<int> B;\n\t\tint n=a.size();\n\t\tint k=1;\n\t\twhile((1<<k)<a.size())k++;\n\t\tblocksize=k>>1;//log(n)/2\n\t\tif(blocksize==0)blocksize=1;\n\t\tint m=(n+blocksize-1)/blocksize;//num block\n\t\tthis->n=m;\n\t\tpattern.resize(m,-1);\n\t\tminpos.resize(1<<blocksize-1);\n\t\tB.resize(m);\n\t\tfor(int i=0;i<(n+blocksize-1)/blocksize;i++){\n\t\t\tint s=i*blocksize;\n\t\t\tint p=0;\n\t\t\tfor(int j=1;j<blocksize&&s+j<n;j++){\n\t\t\t\tif(a[s+j-1]>a[s+j])p|=1<<j-1;\n\t\t\t}\n\t\t\tpattern[i]=p;\n\t\t\tint b=(i+1)*blocksize<=n?blocksize:n-i*blocksize;\n\t\t\tif(minpos[p].empty()){\n\t\t\t\tminpos[p].resize(blocksize*blocksize);\n\t\t\t\tfor(int j=0;j<blocksize;j++){\n\t\t\t\t\tint d=0,pos=j,mind=0;\n\t\t\t\t\tminpos[p][j*blocksize+j]=pos;\n\t\t\t\t\tfor(int k=j+1;k<blocksize;k++){\t\n\t\t\t\t\t\tif(p>>k-1&1)d--;\n\t\t\t\t\t\telse d++;\n\t\t\t\t\t\tif(d<mind){\n\t\t\t\t\t\t\tmind=d;\n\t\t\t\t\t\t\tpos=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tminpos[p][j*blocksize+k]=pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tB[i]=depth[s+minpos[p][0+b-1]];\n\t\t}\n\t\trmq.build(B);\n\t}\n\tint query(int a,int b)const{//[a,b)の最小値\n\t\tb--;\n\t\tint ab=a/blocksize,bb=b/blocksize;\n\t\tif(ab==bb)return ab*blocksize + minpos[pattern[ab]][(a-ab*blocksize)*blocksize+b-bb*blocksize];\n\t\tint i,j;\n\t\ti=ab*blocksize + minpos[pattern[ab]][(a-ab*blocksize)*blocksize+blocksize-1];\n\t\tj=bb*blocksize + minpos[pattern[bb]][0+b-bb*blocksize];\n\t\tif(depth[i]>depth[j])i=j;\n\t\tif(ab+1==bb)return i;\n\t\tj=rmq.query(ab+1,bb);\n\t\tj=j*blocksize + minpos[pattern[j]][0+blocksize-1];\n\t\tif(depth[i]>depth[j])i=j;\n\t\treturn i;\n\t}\n};\n\n\n\n\nclass LCA{\n\tvector<int> eulertour;\n\tvector<int> vertex;\n\t//SparseTableRMQ rmq;\n\t//RMQ rmq;\n\tRMQsub1 rmq;\n\tvoid dfs(const vector<int> edge[],int n,vector<int> &depth,int d,int u){\n\t\teulertour[u]=vertex.size();\t\n\t\tvertex.push_back(u);\n\t\tdepth.push_back(d);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tdfs(edge,n,depth,d+1,edge[u][i]);\n\t\t\tvertex.push_back(u);\n\t\t\tdepth.push_back(d);\n\t\t}\n\t}\npublic:\n\tLCA(const vector<int> edge[],int n,int root):eulertour(n){\n\t\tvector<int> depth;\n\t\tdfs(edge,n,depth,1,root);\n\t\tvertex.push_back(root);\n\t\tdepth.push_back(0);\n\t\trmq.build(depth);\n\t}\n\tint query(int u,int v)const{\n\t\tif(u==v)return u;\n\t\tif(eulertour[u]>eulertour[v])swap(u,v);\n\t\treturn vertex[rmq.query(eulertour[u], eulertour[v])];\n\t}\n};\n\n\n\nvector<int> edge[100000];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k,v;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcin>>v;\n\t\t\tedge[i].push_back(v);\n\t\t}\n\t}\n\tLCA lca(edge,n,0);\n\tint q,u,v;\n\tcin>>q;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>u>>v;\n\t\tcout<<lca.query(u,v)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint logV;\nvector<vector<int>> graph;\nvector<vector<int>> parent;\nvector<int> depth;\n\nvoid dfs(int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (int u : graph[v]) {\n        if (u != p) dfs(u, v, d + 1);\n    }\n}\n\nvoid build(int root) {\n    logV = 1; int n_ = 1; while (n_ < graph.size()) n_ *= 2, logV++;\n    parent.resize(logV, vector<int>(graph.size()));\n    depth.resize(graph.size());\n    dfs(root, -1, 0);\n    for (int k = 0; k < logV - 1; ++k) {\n        for (int v = 0; v < graph.size(); ++v) {\n            if (parent[k][v] == -1) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < logV; ++k) {\n        if ((depth[v] - depth[u]) >> k & 1) v = parent[k][v];\n    }\n    if (v == u) return v;\n    for (int k = logV - 1; k >= 0; --k) {\n        if (parent[k][u] != parent[k][v]) {\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    graph.resize(n);\n    for (int i = 0; i < n ; ++i) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            graph[i].push_back(c);\n        }\n    }\n\n    build(0);\n\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca(u, v) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    //cout << \"Path Count = \" << pathCount << \"\\n\";\n    len.resize(pathCount);\n    /*\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 110000\n#define MAX_LOG_V 20\n\nvector<int> G[MAX_V];\n\nint parent[MAX_LOG_V][MAX_V]; // 2^k th parent\nint depth[MAX_V]; // distance from root\nint root = 0;\n \nvoid dfs(int v, int p, int d){\n\tparent[0][v] = p;\n\tdepth[v] = d;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] != p){\n\t\t\tdfs(G[v][i], v, d + 1);\n\t\t}\n\t}\n}\n \nvoid init(int V){\n\tdfs(root, -1, 0);\n\tfor(int k = 0; k < MAX_LOG_V - 1; k++){\n\t\tfor(int v = 0; v < V; v++){\n\t\t\tif(parent[k][v] < 0){\n\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t}else{\n\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint lca(int u, int v){\n\tif(depth[u] > depth[v]){\n\t\tswap(u, v);\n\t}\n\tfor(int k = 0; k < MAX_LOG_V; k++){\n\t\tif((depth[v] - depth[u]) >> k & 1){\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\tif(u == v){\n\t\treturn u;\n\t}\n\tfor(int k = MAX_LOG_V - 1; k >= 0; k--){\n\t\tif(parent[k][u] != parent[k][v]){\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}\n \nint main(){\n\t\n\tint N;\n\tcin >> N;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tG[x].push_back(i);\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\t\n\tinit(N);\n\t\n\tint Q;\n\tcin >> Q;\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcout << lca(x, y) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define si(i) scanf(\"%d\", &i)\n#define sll(i) scanf(\"%lld\", &i)\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define nl '\\n'\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair< int, int > pii;\n\nint n, l[100005];\nint f[100005][17];\nvector< vector<int> >v;\n\nint main(){\n    memset( f[0], -1, sizeof f[0]);\n    si(n);\n    v.resize(n);\n    int nn = 32 - __builtin_clz(n);\n    for( int i = 0 ; i < n ; i++ ){\n        int k; si(k);\n        for( int j = 0 ; j < k ; j++ ){\n            int c; si(c);\n            v[i].pb(c);\n            f[0][c] = i;\n        }\n    }\n    queue < int >q;\n    l[0] = 0;\n    q.push(0);\n    while( q.size() ){\n        int x = q.front();\n        q.pop();\n        for( int i = 0 ; i < v[x].size() ; i++ ){\n            l[v[x][i]] = l[x] + 1;\n            q.push(mp( l[x] + 1, v[x][i]));\n        }\n    }\n    \n    for( int i = 1 ; i <= nn ; i++ ){\n        for( int j = 0 ; j < n ; j++ ){\n            int x = f[i - 1][j];\n            if( x == -1 ){\n                f[i][j] = -1;\n                continue;\n            }\n            int y = f[i - 1][x];\n            f[i][j] = y;\n        }\n    }\n    int _q; si(_q);\n    while( _q-- ){\n        int u, v;\n        si(u); si(v);\n        if( l[u] < l[v] ) swap( u, v );\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( ( 1 << i ) <= l[u] - l[v] ){\n                u = f[i][u];\n            }\n        }\n        if( u == v ){\n            cout << u << nl;\n            continue;\n        }\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( f[i][u] == f[i][v] ) continue;\n            u = f[i][u];\n            v = f[i][v];\n        }\n        cout << f[0][u] << nl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass LowestCommonAncestor\n{\npublic:\n    LowestCommonAncestor(const Graph& g, const int root = 0) : left(g.V, 0)  // 無向根付き木\n    {\n        vector<bool> used(g.V, false);\n        auto dfs = fix([&](auto&& self, const pair<int, int>& s) -> void {\n            used[s.second] = true;\n            const int pos = s.second;\n            left[pos] = depth.size();\n            depth.push_back(s);\n            for (const int to : g.edge[pos]) {\n                if (used[to]) { continue; }\n                self(self, {s.first + 1, to});\n                depth.push_back(s);\n            }\n        });\n        dfs(make_pair(0, root));\n    }\n    int LCA(const int u, const int v) const\n    {\n        static const SparseTable<DepthMin> st{depth};\n        const int ul = left[u];\n        const int vl = left[v];\n        return st.accumulate(min(ul, vl), max(ul, vl) + 1).second;\n    }\n\nprivate:\n    struct DepthMin\n    {\n        using T = pair<int, int>;\n        T operator()(const T& a, const T& b) const { return min(a, b); }\n    };\n    vector<int> left;\n    vector<pair<int, int>> depth;\n};\n\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\n// Status: Accepted\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g.addEdge(i, c);\n        }\n    }\n\n    LowestCommonAncestor lca{g};\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.LCA(u, v) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i=0;i<(n);++i)\n\nusing namespace std;\n\nstruct edge {\n    typedef size_t weight_type;\n\n    size_t m_to;\n\n    edge(size_t to) : m_to(to) { }\n\n    inline size_t to() const { return m_to; }\n\n    inline weight_type weight() const { return 1; }\n\n    friend std::ostream& operator<<(std::ostream &os, const edge &e) {\n        os << \"{ to: \" << e.m_to << \" }\";\n        return os;\n    }\n};\n\ntemplate <class Edge>\nstruct graph {\n    using edge_type = Edge;\n\n    const size_t m_n_vertices;\n    std::vector<std::vector<edge_type>> m_edges;\n\n    graph(size_t n_vertices) : m_n_vertices(n_vertices), m_edges(n_vertices) { }\n\n    inline size_t n_vertices() const { return m_n_vertices; }\n\n    inline void add_edge(size_t from, size_t to, typename edge_type::weight_type weight) {\n        m_edges[from].emplace_back(to, weight);\n    }\n\n    inline void add_edge(size_t from, size_t to) {\n        m_edges[from].push_back(to);\n    }\n\n    inline void add_edge(size_t from, const edge_type &e) {\n        m_edges[from].emplace_back(e);\n    }\n\n    inline void add_biedge(size_t v0, size_t v1, typename edge_type::weight_type weight) {\n        m_edges[v0].emplace_back(v1, weight);\n        m_edges[v1].emplace_back(v0, weight);\n    }\n\n    inline void add_biedge(size_t v0, size_t v1) {\n        m_edges[v0].push_back(v1);\n        m_edges[v1].push_back(v0);\n    }\n\n    inline std::vector<edge_type> edges_from(size_t v) const {\n        return m_edges[v];\n    }\n};\n\n// N > 1\nclass lowest_common_ancestor {\n\n    size_t log2_max_height; // floor(log2(max_height))\n    std::vector<std::vector<size_t>> parent;\n    std::vector<size_t> depth;\n\n    size_t n_th_parent(size_t u, size_t n) {\n        for (size_t i = 0; (1 << i) <= n; ++i) {\n            if (n & (1 << i)) {\n                u = parent[u][i];\n            }\n        }\n        return u;\n    }\n\npublic:\n\n    // g is a tree\n    template <class Graph>\n    lowest_common_ancestor(const Graph &g, size_t root) {\n\n        using Edge = typename Graph::edge_type;\n\n        size_t N = g.n_vertices();\n        size_t max_height = N - 1;\n        log2_max_height = 32 - __builtin_clz(max_height);\n        \n        parent.assign(N, std::vector<size_t>(log2_max_height));\n        depth.resize(N);\n\n        std::function<void(int, int)> dfs = [&](int u, int p) {\n            for (const Edge &e: g.edges_from(u)) {\n                size_t v = e.to();\n                if (v == p) {\n                    continue;\n                }\n                parent[v][0] = u;\n                depth[v] = depth[u] + 1;\n                dfs(v, u);\n            }\n        };\n\n        parent[root][0] = root;\n        depth[root] = 0;\n        dfs(root, root);\n\n        for (size_t i = 1; i < log2_max_height; ++i) {\n            for (size_t u = 0; u < N; ++u) {\n                parent[u][i] = parent[parent[u][i - 1]][i - 1];\n            }\n        }\n    }\n\n    size_t query(size_t u, size_t v) {\n        if (depth[u] > depth[v]) {\n            u = n_th_parent(u, depth[u] - depth[v]);\n        } else if (depth[v] > depth[u]) {\n            v = n_th_parent(v, depth[v] - depth[u]);\n        }\n        if (u == v) {\n            return u;\n        }\n        for (int i = log2_max_height - 1; i >= 0; --i) {\n            if (parent[u][i] != parent[v][i]) {\n                u = parent[u][i];\n                v = parent[v][i];\n            }\n        }\n        return parent[u][0];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    graph<edge> g(n);\n    REP(i, n) {\n        int k;\n        cin >> k;\n        REP(_, k) {\n            int c;\n            cin >> c;\n            g.add_edge(i, c);\n        }\n    }\n\n    int root = 0;\n    lowest_common_ancestor lcm(g, root);\n\n    int q;\n    cin >> q;\n    REP(_, q) {\n        int u, v;\n        cin >> u >> v;\n        cout << lcm.query(u, v) << '\\n';\n    }\n    cout << flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    len.resize(pathCount);\n    /*\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n    */\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 200000;\nconst int INF = 2147483647;\n\nint n;\nP v[2 * MAX_N - 1];\n\nvoid init(int _n){\n  n = 1;\n  while(n < _n) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(INF, INF);\n}\n\nvoid update(int k, P a){\n  k += n - 1;\n  v[k] = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = v[k * 2 + 1].first < v[k * 2 + 2].first ? v[k * 2 + 1] : v[k * 2 + 2];\n  }\n}\n\nP query(int a, int b, int k, int l, int r){\n  if(b <= l || a >= r) return P(INF, INF);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return min(vl, vr);\n}\n\nint id[MAX_N], vs[MAX_N * 2 - 1], depth[MAX_N * 2 - 1];\n\nvoid dfs(int v, int prev, int d, int &k, vector< vector<int> > &G){\n  id[v] = k;\n  vs[k] = v;\n  depth[k++] = d;\n  REP(i, G[v].size()){\n    if(G[v][i] != prev){\n      dfs(G[v][i], v, d + 1, k, G);\n      vs[k] = v;\n      depth[k++] = d;\n    }\n  }\n}\n\nvoid lca_init(int N, int root, vector< vector<int> > &G){\n  int k = 0;\n  dfs(root, -1, 0, k, G);\n  init(k + 1);\n  REP(i, k) update(i, P(depth[i], vs[i]));\n}\n\nint lca(int a, int b){\n  return query(min(id[a], id[b]), max(id[a], id[b]) + 1, 0, 0, n).second;\n}\n\nint main() {\n  int N; cin >>N;\n  vector< vector<int> > G(N);\n  REP(i, N){\n    int k; cin >>k;\n    REP(j, k){\n      int c; cin >>c;\n      G[i].push_back(c);\n    }\n  }\n  lca_init(N, 0, G);\n  int Q; cin >>Q;\n  REP(q, Q){\n    int a, b; cin >>a >>b;\n    cout <<lca(a, b) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX_V = 10005;\nconst int MAX_N = 100010;\n\nclass segTree{\n    private:\n        //?????°?????????????????????????????????\n        int n, dat[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n            else{\n                //????????§???????????°??????????????????????°????\n                int vl = query(a, b, k * 2, l, ( l + r) / 2);\n                int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n                return min(vl, vr);\n            }\n        }\n    public:\n        void rmqInit(int n_){\n            n = 1;\n            while(n < n_) n *= 2;\n            rep(i,2 * n) dat[i] = INT_MAX;\n        }\n        void rmqInit(int a[MAX_N], int n_){ //??????a??§????????????\n            n = 1;\n            while(n < n_) n *= 2;\n            for(int i = n; i < n * n; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n            }\n        }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){\n            return query(a,b,1,0,n);\n        }\n};\n\nclass LCA : public segTree{\n    private:\n        int root = 0;\n        int vs[MAX_V * 2]; //?????????????????¢???\n        int depth[MAX_V * 2];\n        int id[MAX_V];\n        void dfs(int v, int par, int d, int &k){\n            id[v] = k;\n            vs[k] = v;\n            depth[k++] = d;\n            rep(i,G[v].size()){\n                if(G[v][i] != par){\n                    dfs(G[v][i], v, d + 1, k);\n                    vs[k] = v;\n                    depth[k++] = d;\n                }\n            }\n        }\n    public:\n        vector<int> G[MAX_V];\n        void init(int V){\n            int k = 0;\n            dfs(root, -1, 0, k);\n            rmqInit(depth,k * 2 - 1);\n        }\n        int lca(int u, int v){\n            return vs[query(min(id[u], id[v]), max(id[u], id[v]) + 1)];\n        }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    LCA ob;\n    rep(i,n){\n        int m;\n        cin >> m;\n        rep(j,m){\n            int v;\n            cin >> v;\n            ob.G[i].emplace_back(v);\n        }\n    }\n\n    ob.init(n);\n\n    int q;\n    cin >> q;\n    rep(i,q){\n        int a, b;\n        cin >> a >> b;\n        cout << ob.lca(a,b) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nint n;\nvector<int> vs[100005];\n\nint ans[100005];\n\nset<int> s[100005];\n\nvoid dfs(){\n\tvector<int> stc;\n\tstc.push_back(0);\n\t{\n\t\tfor(int i=0;i!=stc.size();i++){\n\t\t\tint no=stc[i];\n\t\t\trep(j,vs[no].size()){\n\t\t\t\tstc.push_back(vs[no][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tirep(k,stc.size()){\n\t\tint no=stc[k];\n\t\n\t\trep(i,vs[no].size()){\n\t\t\tint to=vs[no][i];\n\t\t\tif(s[to].size()>s[no].size())swap(s[no],s[to]);\n\t\t\t\n\t\t\tfor(set<int>::iterator ite=s[to].begin(); ite!=s[to].end(); ite++){\n\t\t\t\tint p=*ite;\n\t\t\t\tif(s[no].count(p)>=1){\n\t\t\t\t\ts[no].erase(p);\n\t\t\t\t\tans[p]=no;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts[no].insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts[to].clear();\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\trep(j,k){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tvs[i].push_back(a);\n\t\t}\n\t}\n\t\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a==b)ans[i]=a;\n\t\telse{\n\t\t\ts[a].insert(i);\n\t\t\ts[b].insert(i);\n\t\t}\n\t}\n\t\n\tdfs();\n\t\n\trep(i,q){\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\n#define sz(x) ((int)x.size())\n\nstruct UnionFind {\n    vi data;\n    int comp;\n    UnionFind() {}\n    UnionFind(int size) {\n        init(size);\n    }\n    void init(int size) {\n        data.assign(size, -1);\n        comp = size;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        if (data[x] < 0) {\n            return x;\n        } else {\n            return data[x] = root(data[x]);\n        }\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() {\n        return comp;\n    }\n};\n\nstruct LCA {\n    using Query = pii;\n    Graph g;\n    vi color;\n    vi ancestor;\n    vector<vector<pair<int, Query>>> query_set;\n    vi res;\n    UnionFind uf;\n    LCA(const vvi &g, vector<Query> &query) :\n            g         (g),\n            color     (sz(g)),\n            ancestor  (sz(g)),\n            query_set (sz(g)),\n            res       (sz(query)),\n            uf        (sz(g))\n    {\n        int qs = sz(query);\n        rep(i, 0, qs) {\n            query_set[query[i].first ].emplace_back(i, query[i]);\n            query_set[query[i].second].emplace_back(i, query[i]);\n        }\n    }\n    void visit(int v, int prev) {\n        ancestor[uf.root(v)] = v;\n        for (auto &w : g[v]) {\n            if (w == prev) {\n                continue;\n            }\n            visit(w, v);\n            uf.unite(v, w);\n            ancestor[uf.root(v)] = v;\n        }\n        color[v] = 1;\n        for (auto &p : query_set[v]) {\n            Query q = p.second;\n            int w = (q.second == v ? q.first : (q.first == v ? q.second : -1));\n            if (w == -1 || !color[w]) {\n                continue;\n            }\n            res[p.first] = ancestor[uf.root(w)];\n        }\n    }\n    vi solve(int root) {\n        visit(root, -1);\n        return res;\n    }\n};\n\nsigned main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> G(N);\n    rep(v, 0, N) {\n        int K;\n        cin >> K;\n        rep(k, 0, K) {\n            int X;\n            cin >> X;\n            G[v].push_back(X);\n        }\n    }\n    int Q;\n    cin >> Q;\n    vector<pii> queries;\n    rep(i, 0, Q) {\n        int U, V;\n        cin >> U >> V;\n        queries.emplace_back(U, V);\n    }\n    LCA<vvi> lca(G, queries);\n    vi res = lca.solve(0);\n\n    for (int ans : res) {\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n  int ParIdx, ParDepth, Deep; // Deep: HeavyEdge?????§?????±???\n  int Size;\n};\ntypedef vector< vector< int > > Graph;\n\nint N, Q;\nGraph graph;\nint treesz[100000], sz;\nNode nodes[100000];\nvector< int > Nodes[100000];\nint nowtreeIdx[100000], nowtreeDepth[100000]; \n\nint sizeDFS(int idx, int prev) {\n  treesz[idx] = 1;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) treesz[idx] += sizeDFS(graph[idx][i], idx);\n  }\n  return(treesz[idx]);\n}\nvoid makeDFS(int idx, int prev, int treeIdx, int treeDepth, int ParDepth) {\n  nodes[treeIdx].Size++;\n  Nodes[treeIdx].push_back(idx);\n  nowtreeIdx[idx] = treeIdx;\n  nowtreeDepth[idx] = treeDepth;\n  int ret = 0;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) ret = max(ret, treesz[graph[idx][i]]);\n  }\n  bool done = false;\n  for(int i = 0; i < graph[idx].size(); i++) {\n    if(graph[idx][i] != prev) {\n      if(!done && treesz[graph[idx][i]] == ret && !done++) {\n        makeDFS(graph[idx][i], idx, treeIdx, treeDepth + 1, ParDepth);\n      } else {\n        nodes[sz++] = (Node){ treeIdx, treeDepth, ParDepth + 1, 0};\n        makeDFS(graph[idx][i], idx, sz - 1, 0, ParDepth + 1);\n      }\n    }\n  }\n}\nvoid HL() { // ??????????§£\n  sizeDFS(0, -1);\n  sz = 0;\n  nodes[sz++] = (Node){ -1, -1, 0, 0};\n  makeDFS(0, -1, 0, 0, 0);\n}\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  graph.resize(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      graph[i].push_back(c);\n    }\n  }\n  HL();\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n\n    int TreeIdxA = nowtreeIdx[u], TreeDepthA = nowtreeDepth[u];\n    int TreeIdxB = nowtreeIdx[v], TreeDepthB = nowtreeDepth[v];\n    while(TreeIdxA != TreeIdxB) {\n      if(nodes[TreeIdxA].Deep > nodes[TreeIdxB].Deep) {\n        TreeDepthA = nodes[TreeIdxA].ParDepth;\n        TreeIdxA   = nodes[TreeIdxA].ParIdx;\n      } else {\n        TreeDepthB = nodes[TreeIdxB].ParDepth;\n        TreeIdxB   = nodes[TreeIdxB].ParIdx;\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    printf(\"%d\\n\", Nodes[TreeIdxA][TreeDepthA]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// HL-Decomposition\nstruct HLD{\n    typedef ll TYPE;\n    typedef pair<TYPE,TYPE> PTT;\n    TYPE V; // 頂点数\n    TYPE root;\n    vector<vector<TYPE>> G;\n    vector<TYPE> parent,Hchild,number,id,group,depth;\n    vector<PTT> paths; // [u,v]間の経路を分解(最大でもlogN)\n    vector<PTT> Ledges; // pathsを結ぶライドエッジ\n    \n    HLD() {root = V = -1; }\n    HLD(TYPE V):\n    V(V),root(0),G(V),parent(V,-1),Hchild(V,-1),number(V,-1),id(V,-1),group(V,-1),depth(V,0){}\n    void init(TYPE V){\n        V = V; root = 0;\n        G.clear(); parent.clear(); Hchild.clear(); number.clear();\n        id.clear(); group.clear(); depth.clear();\n        G.resize(V); parent.assign(V,-1); Hchild.assign(V,-1);\n        number.assign(V,-1); id.assign(V,-1); group.assign(V,-1); depth.assign(V,0);\n    }\n    \n    void add_edge(TYPE u,TYPE v){ G[u].push_back(v); G[v].push_back(u);}\n    void build(TYPE _root = 0){\n        root = _root;\n        int num = 0;\n        dfs1(); init_number(num); dfs2();\n    }\n    TYPE dfs1(TYPE pos = -1,TYPE pre = -1){\n        if(pos == -1) pos = root;\n        TYPE maxw = -1, weight = 1;\n        for(TYPE next:G[pos]){\n            if(next == pre) continue;\n            TYPE child_weight = dfs1(next,pos);\n            weight += child_weight;\n            if(maxw < child_weight){ Hchild[pos] = next; maxw = child_weight; }\n        }\n        return weight;\n    }\n    void dfs2(TYPE pos = -1,TYPE pre = -1,TYPE dep = 0,TYPE g = -1){\n        if(pos == -1) pos = g = root;\n        parent[pos] = pre; depth[pos] = dep; group[pos] = g;\n        for(TYPE next:G[pos]){\n            if(next == pre) continue;\n            dfs2(next,pos,dep+1,Hchild[pos]==next?g:next);\n        }\n    }\n    void init_number(int& num,TYPE pos = -1,TYPE pre = -1){\n        if(pos == -1) pos = root;\n        number[pos] = num++;\n        id[number[pos]] = pos;\n        if(Hchild[pos] >= 0) init_number(num,Hchild[pos],pos);\n        for(TYPE next:G[pos]){\n            if(next != pre && next != Hchild[pos]) init_number(num,next,pos);\n        }\n    }\n    \n    void buildPaths(TYPE u,TYPE v){\n        if(depth[group[u]] < depth[group[v]]) swap(u,v);\n        TYPE num_u=number[u], num_v=number[v];\n        if(same(u,v)){ paths.push_back({min(num_u,num_v),max(num_u,num_v)}); return;}\n        TYPE group_u = group[u];\n        buildPaths(parent[group_u],v);\n        paths.push_back({number[group_u], number[u]});\n        Ledges.push_back({number[parent[group_u]], number[group_u]});\n    }\n    \n    TYPE lca(TYPE u,TYPE v){\n        if(depth[group[u]] < depth[group[v]]) swap(u,v);\n        if(same(u,v)) return depth[u] < depth[v]?u:v;\n        return lca(parent[group[u]],v);\n    }\n    pair<vector<PTT>,vector<PTT>> getPath(TYPE u,TYPE v){\n        paths.clear(); Ledges.clear();\n        buildPaths(u,v);\n        return make_pair(paths,Ledges);\n    }\n    bool same(TYPE a,TYPE b){return group[a] == group[b];}\n};\n\n// ================================= //\n// use example\n\n/*\n update : [s,t)にxを加算する\n query : [s,t) の総和を出力する\n */\nconst ll INIT = 0;\nstruct SegTree {\n    int N;\n    ll init_v;\n    vector<ll> node, lazy;\n    SegTree(int _N):init_v(INIT) {\n        N = 1; while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v); lazy.resize(2 * N - 1, init_v);\n    }\n    \n    void lazy_evaluate(int k) {\n        node[k] += lazy[k]; // add のため加算\n        if (k < N - 1) { lazy[2 * k + 1] += lazy[k] / 2; lazy[2 * k + 2] += lazy[k] / 2; }\n        lazy[k] = 0;\n    }\n    \n    /* [a,b) 引数の範囲に注意!! s~tまでを更新→update(s,t+1,~) */\n    ll update(int a, int b, int x) { return update(a, b, 0, 0, N, x); }\n    ll update(int a, int b, int k, int l, int r, int x) {\n        if (r <= a || b <= l) { lazy_evaluate(k); return node[k]; }\n        if (a <= l && r <= b) { lazy[k] += (r - l) * x; lazy_evaluate(k); return node[k]; }\n        else {\n            lazy_evaluate(k);\n            ll vl = update(a, b, 2 * k + 1, l, (l + r) / 2, x);\n            ll vr = update(a, b, 2 * k + 2, (l + r) / 2, r, x);\n            return node[k] = vl + vr;\n        }\n    }\n    \n    /* [a,b) 引数の範囲に注意!! */\n    ll query(int a, int b) { return query(a, b, 0, 0, N); }\n    ll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) { lazy_evaluate(k); return node[k]; }\n        else {\n            lazy_evaluate(k);\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return vl + vr;\n        }\n    }\n};\n\n\n// LCA : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\nvoid GRL_5_C(){\n    ll n; cin >> n;\n    HLD hld(n);\n    for(int i = 0; i < n;i++){\n        ll k; cin >> k;\n        for(int j = 0; j < k;j++){\n            ll c; cin >> c;\n            hld.add_edge(i, c);\n        }\n    }\n    hld.build();\n    ll q; cin >> q;\n    while(q--){\n        ll u,v; cin >> u >> v;\n        cout << hld.lca(u,v) << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    GRL_5_C();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <assert.h>\n\n#define LL long long\n#define VI vector<int>\n#define VL vector<long long>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int MAX_LOG_V = 10;\n// ??\\???\nvector<int> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint root = 0; // ?????????????????????\nint parent[MAX_LOG_V][MAX_V]; // ??????2^k????????£?????°???????????????(???????????????????????´??????-1??¨??????)\nint depth[MAX_V]; // ??????????????±???\n\nvoid dfs(int v, int p, int d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    for (int i = 0; i < G[v].size(); i++) {\n        if (G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\n// ?????????\nvoid init(int V) {\n    // parent[0]??¨depth??????????????????\n    dfs(root, -1, 0);\n    // parent??????????????????\n    for (int k = 0; k + 1 < MAX_LOG_V; k++) {\n        for (int v = 0; v < V; v++) {\n            if (parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\n// u??¨v???LCA????±???????\nint lca(int u, int v) {\n    // u??¨v?????±??????????????????????????§????????????\n    if (depth[u] > depth[v]) swap(u, v);\n    for (int k = 0; k < MAX_LOG_V; k++) {\n        if ((depth[v] - depth[u]) >> k & 1) {\n            v = parent[k][v];\n        }\n\n    }\n    if (u == v) return u;\n    // ????????¢?´¢??§LCA????±???????\n    for (int k = MAX_LOG_V - 1; k >= 0; k--) {\n        if (parent[k][u] != parent[k][v]) {\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];\n}\n\nint main(int argc, char *argv[]) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k, c;\n    cin >> n;\n    \n    FOR(i, 0, n) {\n        cin >> k;\n        FOR(j, 0, k) {\n            cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    init(n);\n\n    int q, u, v;\n    cin >> q;\n    FOR(i, 0, q) {\n        cin >> u >> v;\n        cout << lca(u, v) << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, Q;\nvector< int > g[100000];\nvector< int > query[100001];\nint sz[100000];\n\nint lca[100000];\nbool buf[100000];\n\nint sub(int idx)\n{\n  sz[idx] = query[idx].size();\n  for(auto &to : g[idx]) sz[idx] += sub(to);\n  return (sz[idx]);\n}\n\nvoid dfs(int idx, bool keep)\n{\n  if(g[idx].empty()) {\n    if(keep) for(int &v : query[idx]) buf[v] = true;\n    return;\n  }\n\n  int heavy = g[idx][0];\n  for(auto &to : g[idx]) if(sz[to] > sz[heavy]) heavy = to;\n  for(auto &to : g[idx]) if(heavy != to) dfs(to, false);\n  dfs(heavy, true);\n  query[idx].swap(query[heavy]);\n\n  for(auto &to : g[idx]) {\n    for(int &v : query[to]) {\n      if(buf[v]++) lca[v] = idx;\n      if(~lca[v]) continue;\n      query[idx].push_back(v);\n    }\n  }\n\n  if(!keep) {\n    for(auto &v : query[idx]) buf[v] = false;\n  }\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int U;\n      scanf(\"%d\", &U);\n      g[i].push_back(U);\n    }\n  }\n  scanf(\"%d\", &Q);\n\n  memset(lca, -1, sizeof(lca));\n\n  for(int i = 0; i < Q; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    if(U == V) {\n      lca[i] = V;\n    } else {\n      query[U].push_back(i);\n      query[V].push_back(i);\n    }\n  }\n\n  sub(0);\n  dfs(0, false);\n  for(int i = 0; i < Q; i++) {\n    printf(\"%d\\n\", lca[i]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=1e5+9;\nvector<int>adj[MAX];\nint lca[32][MAX];\nint vis[MAX];\nint depth[MAX],n;\nvoid init(){\n\tfor(int i=0;i<32;i++){\n\t\tfor(int j=0;j<MAX;j++){\n\t\t\tlca[i][j]=-1;\n\t\t}\n\t}\n}\nvoid dfs(int s){\n\tvis[s]=1;\n\tfor(int i=0;i<adj[s].size();i++){\n\t\tif(!vis[adj[s][i]]){\n\t\t\tlca[0][adj[s][i]]=s;\n\t\t\tdepth[adj[s][i]]=depth[s]+1;\n\t\t\tdfs(adj[s][i]);\n\t\t}\n\t}\n}\nint find_lca(int u, int v){\n\tif(depth[u]<depth[v]){\n\t\tswap(u,v);\n\t}\n\tint dis=depth[u]-depth[v];\n\twhile(dis>0){\n\t\tint r=log2(dis);\n\t\tu=lca[r][u];\n\t\tdis=dis-(1<<r);\n\t}\n\tif(u==v)\n\t\treturn u;\n\tfor(int i=31;i>=0;i--){\n\t\tif(lca[i][u]!=-1&&(lca[i][u]!=lca[i][v])){\n\t\t\tu=lca[i][u];\n\t\t\tv=lca[i][v];\n\t\t}\n\t}\n\treturn lca[0][u];\n\n}\nvoid binary_lift(){\n\tfor(int i=1;i<31;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(lca[i-1][j]!=-1){\n\t\t\t\tlca[i][j]=lca[i-1][lca[i-1][j]];\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint m;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tadj[i].push_back(a);\n\t\t\tadj[a].push_back(i);\n\t\t}\n\t}\n\tinit();\n\tdfs(0);\n\tbinary_lift();\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tint l=find_lca(x,y);\n\t\tcout<<l<<\"\\n\";\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\n\nstruct LCA {\n    private:\n        ll N;\n        vector<int> tree[200010];\n        ll logN;\n        int parent[200010] = {};\n        int depth[200010] = {};\n        int next_val[25][200010] = {};\n        ll p;\n    public:\n        void build(ll n, vector<int> t[], ll pa = 0){\n            N = n;\n            p = pa;\n            rep(i,0,N) tree[i] = t[i];\n            logN = floor(log2(N)) + 1;\n            dfs(p, -1, 0);\n            rep(i,0,N){\n                next_val[0][i] = parent[i];\n            }\n            rep(k,0,logN){\n                rep(i,0,N){\n                    if(next_val[k][i] == -1){\n                        next_val[k+1][i] = -1;\n                    }else{\n                        next_val[k+1][i] = next_val[k][next_val[k][i]];\n                    }\n                }\n            }\n        }\n\n        void dfs(ll cur, ll par, ll d){\n            depth[cur] = d;\n            parent[cur] = par;\n            for(auto &e: tree[cur]){\n                if(e == par) continue;\n                dfs(e, cur, d+1);\n            }\n        }\n\n        ll getParent(ll cur, ll num) {\n            ll p = cur;\n            rrep(k,logN-1, 0){\n                if(p == -1){\n                    break;\n                }\n                if((num >> k) & 1){\n                    p = next_val[k][p];\n                }\n            }\n            return p;\n        }\n\n        ll getLCA(ll va, ll vb){\n            if(depth[va] > depth[vb]){\n                va = getParent(va, depth[va] - depth[vb]);\n            }else if(depth[va] < depth[vb]){\n                vb = getParent(vb, depth[vb] - depth[va]);\n            }\n            ll lv = -1, rv = N+1;\n            while(rv - lv > 1){\n                ll mid = (rv + lv) / 2;\n                ll ta = getParent(va, mid);\n                ll tb = getParent(vb, mid);\n                if(ta == -1 || tb == -1){\n                    rv = mid;\n                }else if(ta != tb){\n                    lv = mid;\n                }else{\n                    rv = mid;\n                }\n            }\n            return getParent(va, rv);\n        }\n} lca;\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    vector<int> tree[150010];\n    rep(i,0,N){\n        ll k;\n        cin >> k;\n        rep(j,0,k){\n            ll c;\n            cin >> c;\n            tree[i].push_back(c);\n            tree[c].push_back(i);\n        }\n    }\n    lca.build(N, tree);\n    ll Q;\n    cin >> Q;\n\n    while(Q--){\n        ll a,b;\n        cin >> a >> b;\n        print(lca.getLCA(a,b));\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n    s.emplace(u, p, d);\n    while (!s.empty()) {\nentry:;\n      {\n        auto& f = s.top();\n        ord[f.u] = id.size();\n        id.push_back(f.u);\n        depth.push_back(f.d);\n      }\nconti:;\n      for (auto& f = s.top(); f.i < T[f.u].size();) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v == f.p) continue;\n        s.emplace(v, f.u, f.d + 1);\n        goto entry;\n      }\n      s.pop();\n      if (!s.empty()) {\n        auto& f = s.top();\n        id.push_back(f.u);\n        depth.push_back(f.d);\n        goto conti;\n      }\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge>> Graph;\n\ninline int clz(uint x)\n{\n\tint i=0;\n\tif(!(x&0xffff0000)) i+=16,x<<=16;\n\tif(!(x&0xff000000)) i+=8,x<<=8;\n\tif(!(x&0xf0000000)) i+=4,x<<=4;\n\tif(!(x&0xc0000000)) i+=2,x<<=2;\n\tif(!(x&0x80000000)) i+=1,x<<=1;\n\treturn i+!x;\n}\n\nstruct LCA{\n\tvi ds;\n\tvvi ps;\n\tLCA(const Graph& g,int root):ds(g.size()),ps(32-clz(g.size()),vi(g.size(),-1)){\n\t\tDFS(g,-1,root,0);\n\t\trep(i,ps.size()-1) rep(j,ps[i].size())\n\t\t\tps[i+1][j]=ps[i][j]==-1?-1:ps[i][ps[i][j]];\n\t}\n\tvoid DFS(const Graph& g,int p,int v,int depth){\n\t\tds[v]=depth;\n\t\tps[0][v]=p;\n\t\tfor(auto e:g[v]) if(e.dst!=p)\n\t\t\tDFS(g,e.src,e.dst,depth+1);\n\t}\n\tint Find(int a,int b){\n\t\tif(ds[a]>ds[b]) swap(a,b);\n\t\trep(i,ps.size())\n\t\t\tif(ds[b]-ds[a]>>i&1)\n\t\t\t\tb=ps[i][b];\n\t\tif(a==b) return a;\n\t\tper(i,ps.size())\n\t\t\tif(ps[i][a]!=ps[i][b])\n\t\t\t\ta=ps[i][a],b=ps[i][b];\n\t\treturn ps[0][a];\n\t}\n};\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tGraph g(n);\n\t\trep(u,n){\n\t\t\tint k; cin>>k;\n\t\t\trep(i,k){\n\t\t\t\tint v; cin>>v;\n\t\t\t\tg[u].emplace_back(u,v);\n\t\t\t\tg[v].emplace_back(v,u);\n\t\t\t}\n\t\t}\n\t\tLCA lca(g,0);\n\t\tint q; cin>>q;\n\t\trep(_,q){\n\t\t\tint u,v; cin>>u>>v;\n\t\t\tcout<<lca.Find(u,v)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz=\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\n\nstruct Graph {\n    using T = bool;\n    Graph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        const int from;\n        const int to;\n        const T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost = 1)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge(to, from, cost));\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\ntemplate <typename Base>\nclass SparseTable\n{\npublic:\n    using T = typename Base::T;\n    using SemiLattice = Base;\n    SparseTable(const vector<T>& val) : size(val.size()), lg2(size + 1, 0)\n    {\n        for (int i = 2; i <= size; i++) {\n            lg2[i] = lg2[i / 2] + 1;\n        }\n        table.resize(size, vector<T>(lg2[size] + 1));\n        for (int i = 0; i < size; i++) {\n            table[i][0] = val[i];\n        }\n        for (int j = 0; j < lg2[size]; j++) {\n            const int w = 1 << j;\n            for (int i = 0; i <= size - (w << 1); i++) {\n                T tl = table[i][j], tr = table[i + w][j];\n                table[i][j + 1] = op(tl, tr);\n            }\n        }\n    }\n\n    T accumulate(const int l, const int r) const\n    {\n        assert(0 <= l and l < r and r <= size);\n        const int j = lg2[r - l];\n        return op(table[l][j], table[r - (1 << j)][j]);\n    }\n\n\nprivate:\n    const int size;\n    vector<int> lg2;\n    vector<vector<T>> table;\n    const SemiLattice op{};\n};\n\nclass LowestCommonAncestor\n{\npublic:\n    LowestCommonAncestor(const Graph& g, const int root = 0) : left(g.V, 0) { dfs(g, make_pair(0, root)); }\n    int LCA(const int u, const int v) const\n    {\n        static const SparseTable<DepthMin> st{depth};\n        const int ul = left[u];\n        const int vl = left[v];\n        return st.accumulate(min(ul, vl), max(ul, vl) + 1).second;\n    }\n\nprivate:\n    struct DepthMin {\n        using T = pair<int, int>;\n        T operator()(const T& a, const T& b) const\n        {\n            return min(a, b);\n        }\n    };\n\n    void dfs(const Graph& g, const pair<int, int> s)\n    {\n        const int pos = s.second;\n        left[pos] = depth.size();\n        depth.push_back(s);\n        for (const auto& e : g.edge[pos]) {\n            const int to = e.to;\n            dfs(g, make_pair(s.first + 1, to));\n            depth.push_back(s);\n        }\n    }\n    vector<int> left;\n    vector<pair<int, int>> depth;\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    Graph g(n);\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c;\n            cin >> c;\n            g.addEdge(i, c);\n        }\n    }\n\n    LowestCommonAncestor lca{g};\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.LCA(u, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nint h, w, n, m, k, s, t, q, ans, sum, last, cnt;\nstruct Edge { int to,cost; };\nvector<int>vec[100010];\nstring str;\nbool f;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tint n;\n\tvector<int>node, num;\n\tSeg(int n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\tnum.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = std::numeric_limits<int>::max();\n\t\tMfor(i, n - 2)node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n\t}\n\tvoid update(int i, int x,int u) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\tnum[i] = u;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tLL mn = i * 2 + 1;\n\t\t\tif (node[i * 2 + 1] > node[i * 2 + 2])mn = i * 2 + 2;\n\t\t\tnode[i] = node[mn];\n\t\t\tnum[i] = num[mn];\n\t\t}\n\t}\n\tPll find(int i, int a, int b, int l, int r) {\n\t\tif (b < l || r < a)return Pll(INF, INF);\n\t\tif (l <= a&&b <= r)return Pll(node[i], num[i]);\n\t\tPll v1 = find(i * 2 + 1, a, (a + b) / 2, l, r),\n\t\t\tv2 = find(i * 2 + 2, (a + b + 1) / 2, b, l, r);\n\t\treturn (v1.fir < v2.fir ? v1 : v2);\n\t}\n};\nstruct vertex {\n\tint l, r, deep;\n\tbool f = 0;\n};\nvertex v[100010];\nSeg seg(200010);\nvoid lca() {\n\tvector<int>root;\n\tint num = 0, deep = 0;\n\troot.push_back(0);\n\twhile (root.size() != 0) {\n\t\tint u = root[root.size() - 1];\n\t\tif (v[u].f == 0) {\n\t\t\tv[u].l = num;\n\t\t\tv[u].deep = deep;\n\t\t\tv[u].f = 1;\n\t\t}\n\t\tv[u].r = num;\n\t\tseg.update(num,deep,u);\n\t\tnum++;\n\t\trep(j, vec[u].size()) {\n\t\t\tif (v[vec[u][j]].f == 0) {\n\t\t\t\troot.push_back(vec[u][j]);\n\t\t\t\tvec[u].erase(vec[u].begin()+j);\n\t\t\t\tdeep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seg.node[seg.n + num - 2] == deep) {\n\t\t\tdeep--;\n\t\t\troot.pop_back();\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> k;\n\t\trep(j, k) {\n\t\t\tcin >> h;\n\t\t\tvec[i].push_back(h);\n\t\t}\n\t}\n\tlca();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tif (v[x].l > v[y].l)swap(x, y);\n\t\tcout << seg.find(0, 0, seg.n - 1, v[x].l, v[y].r).sec << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree)\n    :tree(tree),n(tree.size()),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n//Usage: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C\nint main(void){\n  //ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 1;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\nusing Graph = vector<vector<edge>>;\n\nclass LCA {\nprivate:\n    static const int MAX_LOG = 20;\n    const int n;\n    Graph G;\n    vector<vector<int>> par;\n    vector<int> depth;\n    vector<int> cost;\n\n    bool inited = false;\n\npublic:\n    void dfs(int v, int p, int d, int c = 0, bool debug = false) {\n        par[0][v] = p;\n        depth[v] = d;\n        cost[v] = c;\n        for (auto e : G[v]) {\n            if (e.to != p) {\n                dfs(e.to, v, d + 1, c + e.cost, debug);\n            }\n        }\n    }\n    LCA(int _n) : n(_n), G(_n), par(MAX_LOG, vector<int>(_n)), depth(_n), cost(_n) {}\n    void addEdge(int a, int b, int c = 0) {\n        G[a].emplace_back(b, c);\n        G[b].emplace_back(a, -c);\n    }\n    void init(bool debug = false) {\n        dfs(0, -1, 0, 0, debug);\n        rep(i, MAX_LOG - 1) {\n            rep(j, n) {\n                if (par[i][j] == -1) {\n                    par[i + 1][j] = -1;\n                } else {\n                    par[i + 1][j] = par[i][par[i][j]];\n                }\n            }\n        }\n        inited = true;\n    }\n    int lca(int a, int b) {\n        assert(inited);\n        if (depth[a] > depth[b]) {\n            swap(a, b);\n        }\n        rep(i, MAX_LOG) {\n            if ((depth[b] - depth[a]) >> i & 1) {\n                b = par[i][b];\n            }\n        }\n        if (a == b) return a;\n\n        rrep(i, MAX_LOG) {\n            if (par[i][a] != par[i][b]) {\n                a = par[i][a];\n                b = par[i][b];\n            }\n        }\n        return par[0][a];\n    }\n    int query(int a, int b) {\n        int v = lca(a, b);\n        return - (cost[a] - cost[v]) + cost[b] - cost[v];\n    }\n\n    bool isTree(int v, int p, vector<bool>& visited) {\n        if (visited[v]) return false;\n        visited[v] = true;\n        for (auto e : G[v]) {\n            if (e.to == p) continue;\n            if (!isTree(e.to, v, visited)) return false;\n            visited[e.to] = false;\n        }\n        return true;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    cin >> n;\n    LCA lca(n);\n    rep(i, n) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int c;\n            cin >> c;\n            lca.addEdge(i, c);\n        }\n    }\n\n    lca.init();\n\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.lca(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;// 998244353;// ;\nconstexpr long long INF = numeric_limits<LL>::max() / 2;\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge { LL from, to, cost; };\nvector<vector<Edge>>g;\nvector<edge>edges;\nvector<LL>v;\nmap<LL, LL>ma;\nset<Pll>st;\nLL h, w, n, m, k, t, s, p, q, last, cnt, sum, ans, dp[210000],a[210000], b[210000];\nstring str, ss;\nbool f;\nchar c;\nstruct HLD {\n\tLL n;\n\tLL cnt = 0;\n\tvector<vector<Edge>>g;\n\tvector<LL>vid, head, nex,dep,lab,par;\n\tHLD(vector<vector<Edge>>G) :g(G), n(G.size()), vid(n), head(n), nex(n), dep(n), lab(n), par(n) {\n\t\tdfs(0, -1);\n\t\tbuild(0);\n\t}\n\tvoid dfs(LL cur,LL pa) {\n\t\tLL mx = 0;\n\t\tnex[cur] = -1;\n\t\trep(i, g[cur].size()) {\n\t\t\tEdge e = g[cur][i];\n\t\t\tif (e.to == pa)continue;\n\t\t\tdep[e.to] = dep[cur] + 1;\n\t\t\tpar[e.to] = cur;\n\t\t\tif (mx < dep[e.to]) {\n\t\t\t\tmx = dep[e.to];\n\t\t\t\tnex[cur] = e.to;\n\t\t\t}\n\t\t\tdfs(e.to, cur);\n\t\t}\n\t}\n\tvoid build(LL root) {\n\t\tqueue<LL>q;\n\t\tq.push(root);\n\t\tvector<LL>Par(n), Dep(n);\n\t\twhile (!q.empty()) {\n\t\t\tLL h = q.front();\n\t\t\tfor (int i = h; i != -1; i = nex[i]) {\n\t\t\t\tvid[i] = cnt;\n\t\t\t\tlab[cnt] = i;\n\t\t\t\thead[cnt] = vid[h];\n\t\t\t\tPar[cnt] = vid[par[i]];\n\t\t\t\tDep[cnt] = dep[i];\n\t\t\t\tcnt++;\n\t\t\t\trep(j, g[i].size()) {\n\t\t\t\t\tLL u = g[i][j].to;\n\t\t\t\t\tif (u == nex[i] || u == par[i])continue;\n\t\t\t\t\tq.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t\tswap(Par, par);\n\t\tswap(Dep, dep);\n\t}\n\tLL lca(LL u,LL v) {\n\t\tu = vid[u];\n\t\tv = vid[v];\n\t\twhile (head[u] != head[v]) {\n\t\t\tif (dep[head[u]] < dep[head[v]])swap(u, v);\n\t\t\tu = par[head[u]];\n\t\t}\n\t\tif (dep[u] > dep[v])swap(u, v);\n\t\treturn  lab[u];\n\t}\n};\nint main() {\n\tcin >> n;\n\tg.resize(n);\n\trep(i, n) {\n\t\tLL x, y;\n\t\tcin >> x;\n\t\trep(j, x) {\n\t\t\tcin >> y;\n\t\t\tg[y].push_back(Edge{ i,1 });\n\t\t\tg[i].push_back(Edge{ y ,1 });\n\t\t}\n\t}\n\tHLD hld(g);\n\tcin >> m;\n\trep(i, m) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tcout << hld.lca(x, y) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define MAX_V 100000\n\nvector<int> G[MAX_V];\nvector<int> depth,vs;\nint id[MAX_V]={};\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int b;\n            cin>>b;\n            G[i].pb(b);\n        }\n    }\n    init();                                                         // aranging depth[] , vs[] and id[]\n    segtree<pii> st(depth.size(),pii((1<<31)-1,(1<<31)-1));         // the number of elements is depth.size()\n    rep(i,depth.size()){                                            //initialize\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int a,b;\n    int q;\n    cin>>q;\n    rep(i,q){\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;  // is equal to LCA(a,b)\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LOG 16\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100000];\nint d[100000], par[17][100000];\nvoid dfs(int v, int p, int d1) {\n\td[v] = d1; par[0][v] = p;\n\tfor (int u : E[v])dfs(u, v, d1 + 1);\n}\nint lca(int a, int b) {\n\tif (d[a] > d[b])swap(a, b);\n\trep(i, LOG + 1) {\n\t\tif ((d[b] - d[a]) >> i & 1)b = par[i][b];\n\t}\n\tif (a == b)return a;\n\tfor (int i = LOG; i >= 0; i--) {\n\t\tif (par[i][a] != par[i][b]) {\n\t\t\ta = par[i][a]; b = par[i][b];\n\t\t}\n\t}\n\treturn par[0][a];\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\tint k; scanf(\"%d\", &k);\n\t\trep(j, k) {\n\t\t\tint c; scanf(\"%d\", &c);\n\t\t\tE[i].push_back(c);\n\t\t}\n\t}\n\tdfs(0, -1, 0);\n\tfor (int i = 1; i <= LOG; i++) {\n\t\trep(j, n) {\n\t\t\tif (par[i - 1][j] == -1)par[i][j] = -1;\n\t\t\telse par[i][j] = par[i - 1][par[i - 1][j]];\n\t\t}\n\t}\n\tint q; scanf(\"%d\", &q);\n\trep(i, q) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\n\nint N,Q;\nvector<int> g[MAX_N+5];\nint root;\nint depth[MAX_N+5];\nint par[21][MAX_N];\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    for(int u=0;u<g[v].size();++u){\n        if(g[v][u]!=p)dfs(g[v][u],v,d+1);\n    }\n}\n\nvoid fill_table(){\n    dfs(root,-1,0);\n    for(int i=0;i<20;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nint LCA(int u,int v){\n    if(depth[u]>depth[v])swap(u,v);\n    for(int i=0;i<20;++i){\n        if((depth[v]-depth[u])>>i&1)v=par[i][v];\n    }\n    if(v==u)return u;\n    for(int i=20;i>=0;--i){\n        if(par[i][u]!=par[i][v]){\n            u=par[i][u];\n            v=par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;++j){\n            int c;\n            cin>>c;\n            g[i].PB(c);\n        }\n    }\n    fill_table();\n    cin>>Q;\n    while(Q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<LCA(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct LCA {\n  int N, logN; // logN-1 == floor(lg(N-1))\n  vector<vector<int>> G;\n  vector<int> depth;\n  // vから根の方向に2^k回登ったときのノード parent[k][v]\n  vector<vector<int>> parent;\n\n  LCA(int size) : N(size), G(size), depth(size) {\n    logN = 0;\n    for(int x = 1; x < N; x *= 2) logN++;\n    parent.assign(logN, vector<int>(N));\n  }\n\n  // どちらが根であってもOK\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(int v, int par, int dep) {\n    depth[v] = dep;\n    parent[0][v] = par;\n    for(int next : G[v]) {\n      if(next != par) dfs(next, v, dep + 1);\n    }\n  }\n\n  void init(int root) {\n    dfs(root, -1, 0);\n    for(int k = 1; k < logN; k++) {\n      for(int v = 0; v < N; v++) {\n        if(parent[k - 1][v] == -1) parent[k][v] = -1;\n        else parent[k][v] = parent[k - 1][parent[k - 1][v]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(depth[u] > depth[v]) swap(u, v); // vのほうが深くなる\n    // uとvの深さが同じになるまでvを根の方向に移動する\n    for(int k = 0; k < logN; k++) {\n      if(((depth[v] - depth[u]) >> k) & 1) {\n        v = parent[k][v];\n      }\n    }\n    if(u == v) return u;\n    for(int k = logN - 1; k >= 0; k--) {\n      if(parent[k][u] != parent[k][v]) {\n        u = parent[k][u];\n        v = parent[k][v];\n      }\n    }\n    return parent[0][u];\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N; cin >> N;\n  LCA lca(N);\n  for(int u = 0; u < N; u++) {\n    int k; cin >> k;\n    while(k--) {\n      int v; cin >> v;\n      lca.add_edge(u, v);\n    }\n  }\n  lca.init(0);\n  int Q; cin >> Q;\n  while(Q--) {\n    int u, v; cin >> u >> v;\n    cout << lca.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<vector>\n#include<cmath>\n#include<utility>\n\ntemplate<typename Label>\nclass RootedTree {\npublic:\n  RootedTree(const Label& root) : root_(root) {}\n  void add(const Label& p, const Label& c) {child_[p].push_back(c);}\n  void init() {init(root_, 0);}\n  Label lca(Label u, Label v) {\n    // u, v を同じ深さにする O(log(深さの差))\n    if(depth_[v] < depth_[u]) std::swap(u, v);\n    int difference = depth_[v] - depth_[u];\n    for(int i = 1; i <= difference; i <<= 1)\n      if(difference & i)\n        v = parent_[v][i];\n    // lca を求める O(log(深さ))\n    if(u == v) return u;\n    for(int i = log2(depth_[u]); 0 < i; i >>= 1) {\n      if(parent_[u][i] == parent_[v][i]) continue;\n      u = parent_[u][i];\n      v = parent_[v][i];\n    }\n    return parent_[u][1];\n  }\nprivate:\n  void init(const Label& current, int depth) {\n    depth_[current] = depth;\n    for(int i = 2; i <= depth; i <<= 1) parent_[current][i] = parent_[parent_[current][i >> 1]][i >> 1];\n    for(const auto& v: child_[current]) {\n      parent_[v][1] = current;\n      init(v, depth + 1);\n    }\n  }\n  Label root_;\n  std::unordered_map<Label, int> depth_;\n  std::unordered_map<Label, std::vector<Label>> child_;\n  std::unordered_map<Label, std::unordered_map<int, Label>> parent_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  RootedTree<int> t(0);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int c;\n      cin >> c;\n      t.add(i, c);\n    }\n  }\n  t.init();\n\n  int q;\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int u, v;\n    cin >> u >> v;\n    cout << t.lca(u, v) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXV 100010\n#define MAXLV 20\nusing namespace std;\n\nvector<int> e[MAXV];\nint n,root=0;\n\nint parent[MAXLV][MAXV];\nint depth[MAXV];\n\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0;i<e[v].size();i++){\n    if(e[v][i]!=p)dfs(e[v][i],v,d+1);\n  }\n}\n\nvoid init(){\n  dfs(root,-1,0);\n  for(int k=0;k+1<MAXLV;k++){\n    for(int v=0;v<n;v++){\n      if(parent[k][v]<0)parent[k+1][v]=-1;\n      else parent[k+1][v]=parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u,int v){\n  if(depth[u]>depth[v])swap(u,v);\n  for(int k=0;k<MAXLV;k++){\n    if((depth[v]-depth[u])>>k&1){\n      v=parent[k][v];\n    }\n  }\n  if(u==v)return u;\n  for(int k=MAXLV-1;k>=0;k--){\n    if(parent[k][u]!=parent[k][v]){\n      u=parent[k][u];\n      v=parent[k][v];\n    }\n  }\n  return parent[0][u];\n}\n\nint main()\n{\n  int q,u,v,k,c;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>k;\n    for(int j=0;j<k;j++){\n      cin>>c;\n      e[i].push_back(c);\n    }\n  }\n  init();\n  cin>>q;\n  for(int i=0;i<q;i++){\n    cin>>u>>v;\n    cout<<lca(u,v)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L;\n\n  std::vector<int> lg;\n  std::vector<BitIndex> small;\n  std::vector<std::vector<Index>> large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n\nprivate:\n  Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), lg(1 << S), small(N), large(L, std::vector<Index>(LG_L)) {\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li][0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li][0] = F(large[li][0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li][x + 1] = F(large[li][x], large[li + (1 << x)][x]);\n      }\n    }\n    std::vector<Index> st;\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      st.clear();\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (!st.empty() && f(i + si, st.back())) st.pop_back();\n        small[i + si] |= 1 << si;\n        if (!st.empty()) small[i + si] |= small[st.back()];\n        st.push_back(i + si);\n      }\n    }\n  }\n  int ntz(int x) const { return lg[x & -x]; }\n  int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l][x], large[r - (1 << x) + 1][x]);\n  }\n};\n#include <vector>\n#include <unordered_map>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    ord[u] = id.size();\n    id.push_back(u);\n    depth.push_back(d);\n    for (int v : T[u]) {\n      if (v == p) continue;\n      traverse(v, u, d + 1);\n      id.push_back(u);\n      depth.push_back(d);\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ninline int in(){ int x; scanf(\"%d\", &x); return x; }\ninline void pr(int x) { printf(\"%d\\n\", x); }\n\nint main() {\n  // std::freopen(\"in31.txt\", \"r\", stdin);\n  int N = in();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = in();\n    for (int j = 0; j < k; j++) {\n      et.add_edge(i, in());\n    }\n  }\n  et.build(0);\n  LCA lca(et);\n  int Q = in();\n  for (int i = 0; i < Q; i++) {\n    int u = in(), v = in();\n    pr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root), cnum(V), place(V), id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// u??¨v????????????\n\t// lca????±????????????¨????????????????????§????????°????????¨????????????\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\t// init??????\n\t// ????????????????????????????????????????????????????????°????????¨lca????±???????????????????\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// u??¨v???lca????±???????\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// u??¨v????????¢????±???????\n\t// edge????????????????????¨????????????????????????????????????\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v] += dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v] + 1;\n\t}\n\n\tvoid getid(const int v, const int p, int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// ??°???????????£??\\???????????¨???\n\tvector<vector<int> > T;\n\t// ???????????°\n\tint V;\n\t// ?????????????????????\n\tint root;\n\n\t// ????????????\n\tvector<int> parent[MAXLOGV];\n\t// ??????????????±???\n\tvector<int> depth;\n\n\t//????????°\n\tvector<int>cnum;\n\n\t//??????\n\tvector<int>place;\n\tvector<int>id;\n\n};\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tvector<int>isp(N,true);\n\t\tvector<pair<int, int>>edges;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint K; cin >> K;\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tedges.emplace_back(i, a);\n\t\t\t\tisp[a] = false;\n\t\t\t}\n\t\t}\n\t\tint pa = find(isp.begin(), isp.end(), 1) - isp.begin();\n\t\tTree t(N, pa);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tt.unite(edges[i].first, edges[i].second);\n\t\t}\n\t\tt.init();\n\t\tint Q; cin >> Q;\n\t\twhile (Q--) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\tint ans = t.lca(a, b);\n\t\t\tcout << ans << endl;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n};\n\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\n\nclass Heavy_Light_Decomposition {\npublic:\n\tBiDGraph g, compg;\n\tvector<int> sz,depth,chain, par;\n\n\tHeavy_Light_Decomposition(BiDGraph graph, int root):\n\t\tg(graph), compg(graph.vn), sz(graph.vn,1), depth(graph.vn), chain(graph.vn),par(graph.vn){\n\t\tgetsz(root, root);\n\t\tHLD(root, -1, root);\n\t}\n\n\tint getsz(int cur, int p) {\n\t\tpar[cur] = p;\n\t\tfor (auto itr : g.g[cur])\n\t\t\tif (p != itr.first) \n\t\t\t\tdepth[itr.first] = depth[cur]+1,sz[cur] += getsz(itr.first, cur);\n\t\treturn sz[cur];\n\t}\n\n\tvoid HLD(int cur, int p, int head) {\n\t\tchain[cur] = head;\n\t\tpii Maxc = {-1,-1};\n\t\tfor (auto itr : g.g[cur]) \n\t\t\tif (itr.first != p)\n\t\t\t\tMaxc = max(Maxc, { sz[itr.first], itr.first });\n\t\t\n\n\t\tfor (auto itr : g.g[cur]) \n\t\t\tif (itr.first != p)\n\t\t\t\tHLD(itr.first, cur, itr.first == Maxc.second ? head : itr.first);\n\t}\n\n\n\n\tint lca(int a, int b) {\n\t\tif (chain[a] == chain[b]) return depth[a] < depth[b] ? a : b;\n\t\tif (depth[chain[a]] > depth[chain[b]])\n\t\t\treturn lca(par[chain[a]], b);\n\t\treturn lca(a, par[chain[b]]);\n\t}\n\n\n};\n\nsigned main() {\n\tint n;\n\tscnaf(\"%d\", &n);\n\tBiDGraph g(n);\n\tREP(i, n) {\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tREP(j, m) {\n\t\t\tint a;\n\t\t\tscnaf(\"%d\", &a);\n\t\t\tg.con(i,a);\n\t\t}\n\t}\n\n\tHeavy_Light_Decomposition hld(g, 0);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tREP(i, q) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\tprintf(\"%d\\n\", hld.lca(a,b));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass RootedNode{\npublic:\n\tvector<ll> parent;\n\tll depth,dist;\n\tRootedNode():depth(0),dist(0){}\n};\n\nclass ConnectNodeInfo{\n\tvector<vector<pair<ll,ll>>> graph;\npublic:\n\tConnectNodeInfo(int node_num){\n\t\tgraph.resize(node_num);\n\t}\n\tvoid AddNonDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tgraph[v].emplace_back(u,w);\n\t}\n\tvoid AddDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t}\n\tvector<pair<ll,ll>>& operator[](ll index){\n\t\treturn graph[index];\n\t}\n\tsize_t size(){return graph.size();}\n};\n\nclass RootedTree{\n\tint parent_size;\n\n\tvoid DFS(ConnectNodeInfo& connection,ll child,ll parent,ll dep,ll dist){\n\t\tnode[child].parent[0] = parent;\n\t\tnode[child].depth = dep;\n\t\tnode[child].dist = dist;\n\n\t\tfor(int i = 0;i < connection[child].size();i++){\n\t\t\tif(connection[child][i].first != parent){\n\t\t\t\tDFS(connection,connection[child][i].first,child,dep+1,dist+connection[child][i].second);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvector<RootedNode> node;\n\n\tRootedTree(ConnectNodeInfo& connection){\n\t\tauto connection_size = connection.size();\n\t\tparent_size = 1;\n\t\twhile((1LL<<parent_size)<connection_size) parent_size++;\n\n\t\tnode.resize(connection_size);\n\t\tfor(auto& x:node) x.parent.resize(parent_size);\n\t\tDFS(connection,0,-1,0,0);\n\t\tfor(int k=0;k<parent_size-1;k++){\n\t\t\tfor(int v=0,ev=connection_size;v<ev;v++){\n\t\t\t\tif(node[v].parent[k] < 0) node[v].parent[k+1] = -1;\n\t\t\t\telse node[v].parent[k+1] = node[node[v].parent[k]].parent[k];\n\t\t\t}\n\t\t}\n\t}\n\tll FindLCA(ll u,ll v){\n\t\tif(node[u].depth > node[v].depth) swap(u,v);\n\t\tfor(int k=0;k<parent_size;k++){\n\t\t\tif((node[v].depth - node[u].depth) & (1LL<<k)){\n\t\t\t\tv = node[v].parent[k];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return u;\n\t\tfor(int k=parent_size-1;k>=0;k--){\n\t\t\tif(node[u].parent[k] != node[v].parent[k]){\n\t\t\t\tu = node[u].parent[k];\n\t\t\t\tv = node[v].parent[k];\n\t\t\t}\n\t\t}\n\t\treturn node[u].parent[0];\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in();\n\tConnectNodeInfo connect(N);\n\tREP(i,N){\n\t\tint k=in();\n\t\tLOOP(k){\n\t\t\tint j=in();\n\t\t\tconnect.AddNonDirectionalConnection(i,j,1);\n\t\t}\n\t}\n\tRootedTree tree(connect);\n\tint Q=in();\n\tLOOP(Q){\n\t\tint u=in(),v=in();\n\t\tout(tree.FindLCA(u,v));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define EACH(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct HeavyLight {\n  vector<vector<int> > len, tree;\n  int pathCount,n;\n  vector<int>size,parent,in,out,path,pathSize,pathPos,pathRoot;\n\n  HeavyLight(vector<vector<int> >tree,int n)\n    :tree(tree),n(n),size(n),parent(n),in(n),out(n),\n     path(n),pathSize(n),pathPos(n),pathRoot(n){\n    int time=0;\n    dfs(0,-1,time);\n    buildPaths(0,newPath(0));\n    len.resize(pathCount);\n\n    REP(i,pathCount){\n      int m=pathSize[i];\n      len[i].resize(2*m);\n      fill(ALL(len[i]),0);\n      fill(len[i].begin()+m,len[i].begin()+2*m,1);\n      for(int j=2*m-1;j>1;j-=2)len[i][j>>1]=len[i][j]+len[i][j^1];\n    }\n  }\n\n  void dfs(int u, int p, int &k){\n    in[u]=k++, parent[u]=p, size[u]=1;\n    EACH(v,tree[u])if(*v!=p)dfs(*v, u, k),size[u]+=size[*v];\n    out[u]=k++;\n  }\n\n  int newPath(int u){ pathRoot[pathCount]=u; return pathCount++; }\n\n  void buildPaths(int u, int pt){\n    path[u]=pt, pathPos[u]=pathSize[pt]++;\n    EACH(v,tree[u])if(*v != parent[u])\n      buildPaths(*v, 2*size[*v] >= size[u] ? pt : newPath(*v));\n  }\n\n  bool isAncestor(int p, int ch){\n    return in[p] <= in[ch] && out[ch] <= out[p];\n  }\n\n  int lca(int a,int b){\n    for(int root; !isAncestor(root=pathRoot[path[a]],b);a=parent[root]);\n    for(int root; !isAncestor(root=pathRoot[path[b]],a);b=parent[root]);\n    return isAncestor(a,b)?a:b;\n  }\n};\n\n\nint main(void){\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<vector<int> >tree(n);\n  \n  REP(i,n){\n    int k;\n    cin >> k;\n    REP(j,k){\n      int ch;\n      cin >> ch;\n      tree[i].push_back(ch);\n    }\n  }\n\n  HeavyLight hl = HeavyLight(tree,n);\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u >> v;\n    cout << hl.lca(u,v) << \"\\n\";\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <utility>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename T = int >\nstruct Edge {\n  int from, to;\n  T cost;\n  int idx;\n\n  Edge() = default;\n\n  Edge(int from, int to, T cost = 1, int idx = -1) : from(from), to(to), cost(cost), idx(idx) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T = int >\nstruct Graph {\n  vector< vector< Edge< T > > > g;\n  int es;\n\n  Graph() = default;\n\n  explicit Graph(int n) : g(n), es(0) {}\n\n  size_t size() const {\n    return g.size();\n  }\n\n  void add_directed_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost, es++);\n  }\n\n  void add_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost, es);\n    g[to].emplace_back(to, from, cost, es++);\n  }\n\n  void read(int M, int padding = -1, bool weighted = false, bool directed = false) {\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      cin >> a >> b;\n      a += padding;\n      b += padding;\n      T c = T(1);\n      if(weighted) cin >> c;\n      if(directed) add_directed_edge(a, b, c);\n      else add_edge(a, b, c);\n    }\n  }\n};\n\ntemplate< typename T >\nstruct DoublingLowestCommonAncestor : Graph< T > {\npublic:\n  using Graph< T >::g;\n  vector< int > dep;\n  vector< T > sum;\n  vector< vector< int > > table;\n  const int LOG;\n\n  explicit DoublingLowestCommonAncestor(int n)\n      : LOG(32 - __builtin_clz(g.size())), Graph< T >(n) {}\n\n  explicit DoublingLowestCommonAncestor(const Graph< T > &g)\n      : LOG(32 - __builtin_clz(g.size())), Graph< T >(g) {}\n\n  void build() {\n    dep.assign(g.size(), 0);\n    sum.assign(g.size(), 0);\n    table.assign(LOG, vector< int >(g.size(), -1));\n    dfs(0, -1, 0);\n    for(int k = 0; k + 1 < LOG; k++) {\n      for(int i = 0; i < table[k].size(); i++) {\n        if(table[k][i] == -1) table[k + 1][i] = -1;\n        else table[k + 1][i] = table[k][table[k][i]];\n      }\n    }\n  }\n\n  int lca(int u, int v) {\n    if(dep[u] > dep[v]) swap(u, v);\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(((dep[v] - dep[u]) >> i) & 1) v = table[i][v];\n    }\n    if(u == v) return u;\n    for(int i = LOG - 1; i >= 0; i--) {\n      if(table[i][u] != table[i][v]) {\n        u = table[i][u];\n        v = table[i][v];\n      }\n    }\n    return table[0][u];\n  }\n\n  T dist(int u, int v) {\n    return sum[u] + sum[v] - 2 * sum[lca(u, v)];\n  }\n\nprivate:\n  void dfs(int idx, int par, int d) {\n    table[0][idx] = par;\n    dep[idx] = d;\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        sum[to] = sum[idx] + to.cost;\n        dfs(to, idx, d + 1);\n      }\n    }\n  }\n};\n\n\nint main() {\n  int N, Q;\n  cin >> N;\n  DoublingLowestCommonAncestor< int > dlca(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int c;\n      cin >> c;\n      dlca.add_edge(i, c);\n    }\n  }\n  dlca.build();\n  cin >> Q;\n  for(int i = 0; i < Q; i++) {\n    int u, v;\n    cin >> u >> v;\n    cout << dlca.lca(u, v) << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct HeavyLightDecomposition {\n  int root;\n  vector<vector<int>> g;\n  vector<int> sz, par, in, out, head;\n  HeavyLightDecomposition(int n = 1, int _root = 0)\n      : root(_root), g(n), sz(n), par(n), in(n), out(n),\n        head(n) {}\n  HeavyLightDecomposition(const vector<vector<int>> &_g,\n                          const int _root = 0)\n      : root(_root), g(_g), sz(_g.size()), par(_g.size()),\n        in(_g.size()), out(_g.size()), head(_g.size()) {\n    build();\n  }\n  void add(int a, int b) {\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  void build() {\n    dfs_sz(root, -1);\n    int t = 0;\n    dfs_hld(root, -1, t);\n  }\n  void dfs_sz(int now, int bf) {\n    par[now] = bf;\n    sz[now] = 1;\n    if(g[now].size() && g[now][0] == bf)\n      swap(g[now][0], g[now].back());\n    for(auto &to : g[now]) {\n      if(to == bf) continue;\n      dfs_sz(to, now);\n      sz[now] += sz[to];\n      if(sz[g[now][0]] < sz[to]) swap(g[now][0], to);\n    }\n  }\n  void dfs_hld(int now, int bf, int &t) {\n    in[now] = t++;\n    for(auto &to : g[now]) {\n      if(to == bf) continue;\n      head[to] = (g[now][0] == to ? head[now] : to);\n      dfs_hld(to, now, t);\n    }\n    out[now] = t;\n  }\n  int lca(int x, int y) {\n    for(;; y = par[head[y]]) {\n      if(in[x] > in[y]) swap(x, y);\n      if(head[x] == head[y]) return x;\n    }\n  }\n};\n\nint n, q;\nHeavyLightDecomposition hld;\n\nint main() {\n  cin >> n;\n  hld = HeavyLightDecomposition(n);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; ++j) {\n      int p;\n      cin >> p;\n      hld.add(i, p);\n    }\n  }\n  hld.build();\n  cin >> q;\n  for(int i = 0; i < q; ++i) {\n    int x, y;\n    cin >> x >> y;\n    cout << hld.lca(x, y) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint path[2*MAXN], depth[2*MAXN], idx[MAXN];     // idx : the index of node in dfs path\n\nint par[MAXN];\nvector<int> adjList[MAXN];\n\nclass SegmentTree{\nprivate:\n    int n;\n    vector<int> t;\n    \n    int combine(int l, int r){\n        if (l == -1 || r == -1) return max(l,r);\n\n        if (depth[l] < depth[r]) return l;\n        return r;\n    }\npublic:\n    SegmentTree(int size){                                 // build tree\n        n = size;\n        t.assign(n<<1,0);\n\n        for (int i=0; i<n; i++) t[n+i] = i;\n        for (int i=n-1; i>0; i--) t[i] = combine(t[i<<1], t[i<<1|1]);\n    }\n    int query(int l, int r){                               // query in range v[l,r)\n        if (r < l) swap(l,r); r++;\n        int res = -1;\n        for (l+=n, r+=n; l<r; l>>=1, r>>=1){\n            if (l&1) res = combine(res,t[l++]);\n            if (r&1) res = combine(res,t[--r]);\n        }\n        return res;\n    }\n};\n\nint cnt = 0;\nvoid dfs(int curr, int d){\n    idx[curr] = cnt;\n\n    path[cnt] = curr;\n    depth[cnt++] = d;\n\n    for (int i=0; i<adjList[curr].size(); i++){\n        dfs(adjList[curr][i],d+1);\n\n        path[cnt] = curr;\n        depth[cnt++] = d;\n    }\n}\n\nint main(){\n\n    // init\n    memset(par,-1,sizeof(par));\n\n    int N;\n    scanf(\"%d\",&N);\n\n    for (int u=0; u<N; u++){\n        int M;\n        scanf(\"%d\",&M);\n\n        int v;\n        for (int i=0; i<M; i++){\n            scanf(\"%d\",&v);\n\n            par[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    // find root\n    int root;\n    for (int i=0; i<N; i++) if (par[i] == -1) root = i;\n\n    dfs(root,0);\n\n    // build RMQ\n    SegmentTree st(cnt);\n    \n    int Q;\n    scanf(\"%d\",&Q);\n\n    for (int i=0; i<Q; i++){\n        int u, v;\n        scanf(\"%d%d\",&u,&v);\n\n        int id = st.query(idx[u],idx[v]);\n\n        cout << path[id] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass LowestCommonAncestor {\n  ll N, D;\n  vector<ll> depth;\n  vector<vector<ll>> parent, E;\n\npublic:\n  LowestCommonAncestor(ll N, ll D = 24): N(N), D(D) {\n    depth.resize(N);\n    parent.resize(D, vector<ll>(N));\n    E.resize(N);\n  }\n\n  void add_edge(ll u, ll v) {\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n\n  void init(ll root) {\n    dfs(root, -1, 0);\n    REP(i, 0, D - 1) REP(j, 0, N) {\n      if (parent[i][j] == -1) parent[i + 1][j] = -1;\n      else parent[i + 1][j] = parent[i][parent[i][j]];\n    }\n  }\n\n  ll query(ll u, ll v) {\n    if (depth[u] > depth[v]) swap(u, v);\n    REP(i, 0, D) {\n      if ((depth[v] - depth[u]) & 1LL << i) {\n        v = parent[i][v];\n      }\n    }\n    if (u == v) return u;\n    for (ll i = D - 1; i >= 0; i--) {\n      if (parent[i][u] != parent[i][v]) {\n        u = parent[i][u];\n        v = parent[i][v];\n      }\n    }\n    return parent[0][u];\n  }\n\n  ll dist(ll u, ll v) {\n    return depth[u] + depth[v] - depth[query(u, v)] * 2;\n  }\n\nprivate:\n  void dfs(ll v, ll p, ll d) {\n    parent[0][v] = p;\n    depth[v] = d;\n    REP(i, 0, E[v].size()) {\n      if (E[v][i] != p) {\n        dfs(E[v][i], v, d + 1);\n      }\n    }\n  }\n};\n\n/* http://judge.u-aizu.ac.jp/onlinejudge/description.jsp */\nint main(void) {\n  ll N;\n  cin >> N;\n  LowestCommonAncestor lca(N);\n  REP(i, 0, N) {\n    ll k;\n    cin >> k;\n    REP(j, 0, k) {\n      ll v;\n      cin >> v;\n      lca.add_edge(i, v);\n    }\n  }\n  lca.init(0);\n\n  ll Q;\n  cin >> Q;\n  REP(i, 0, Q) {\n    ll U, V;\n    cin >> U >> V;\n    cout << lca.query(U, V) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define si(i) scanf(\"%d\", &i)\n#define sll(i) scanf(\"%lld\", &i)\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define nl '\\n'\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair< int, int > pii;\n\nvector < vector < int > > v;\nint n, l[100005];\nint f[100005][17];\n\nint main(){\n    si(n);\n    v.resize(n);\n    int nn = 32 - __builtin_clz(n);\n    memset( f[0], -1, sizeof f[0]);\n    for( int i = 0 ; i < n ; i++ ){\n        int k; si(k);\n        for( int j = 0 ; j < k ; j++ ){\n            int c; si(c);\n            v[k].pb( c );\n            v[c].pb( k );\n            f[0][c] = i;\n        }\n    }\n    \n    memset(l, -1, sizeof(l));\n    queue < int > q;\n    q.push(0);\n    l[0] = 0;\n    while(!q.empty()){\n    \tint u = q.front();\n    \tfor( int x : v[u] ){\n    \t\tif( l[x] == -1 ){\n    \t\t\tl[x] = l[u]+1;\n    \t\t\tq.push(x);\n\t\t\t}\n\t\t}\n\t}\n    \n    for( int i = 1 ; i <= nn ; i++ ){\n        for( int j = 0 ; j < n ; j++ ){\n            int x = f[i - 1][j];\n            if( x == -1 ){\n                f[i][j] = -1;\n                continue;\n            }\n            int y = f[i - 1][x];\n            f[i][j] = y;\n        }\n    }\n    int _q; si(_q);\n    while( _q-- ){\n        int u, v;\n        si(u); si(v);\n        if( l[u] < l[v] ) swap( u, v );\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( ( 1 << i ) <= l[u] - l[v] ){\n                u = f[i][u];\n            }\n        }\n        if( u == v ){\n            cout << u << nl;\n            continue;\n        }\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( f[i][u] == f[i][v] ) continue;\n            u = f[i][u];\n            v = f[i][v];\n        }\n        cout << f[0][u] << nl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nclass LCA {\n\tusing pii = pair<int, int>;\n\tconst int n;\n\tvector<int> depth, dde, par, heavy, head;\n\tint dfs(int v, int prev, const graph& G) {\n\t\tpar[v] = prev;\n\t\tint ma = 0, res = 1;\n\t\tfor (auto to : G[v]) if (to != prev) {\n\t\t\tdepth[to] = depth[v] + 1;\n\t\t\tint size = dfs(to, v, G);\n\t\t\tres += size;\n\t\t\tif (size > ma) {\n\t\t\t\tma = size;\n\t\t\t\theavy[v] = to;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tLCA(const graph& G, int rt = 0)\n\t\t: n(G.size()), depth(n), dde(n), par(n), heavy(n, -1), head(n) {\n\t\tdfs(rt, -1, G);\n\t\tqueue<int> q;\n\t\tq.push(rt);\n\t\thead[rt] = rt;\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\twhile (v != -1) {\n\t\t\t\tfor (auto to : G[v]) if (to != par[v] && to != heavy[v]) {\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tdde[to] = dde[v] + 1;\n\t\t\t\t\thead[to] = to;\n\t\t\t\t}\n\t\t\t\tif (heavy[v] != -1) {\n\t\t\t\t\tdde[heavy[v]] = dde[v];\n\t\t\t\t\thead[heavy[v]] = head[v];\n\t\t\t\t}\n\t\t\t\tv = heavy[v];\n\t\t\t}\n\t\t}\n\t}\n\tint calc(int u, int v) {\n\t\tif (dde[u] > dde[v]) swap(u, v);\n\t\twhile (dde[u] < dde[v]) v = par[head[v]];\n\t\twhile (head[u] != head[v]) u = par[head[u]], v = par[head[v]];\n\t\treturn depth[u] < depth[v] ? u : v;\n\t}\n\tint dist(int a, int b) {\n\t\treturn depth[a] + depth[b] - depth[calc(a, b)] * 2;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph G(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t\tG[c].push_back(i);\n\t\t}\n\t}\n\tLCA lca(G);\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", lca.calc(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1005;\n\nint N, Q;\nint T[MAXN], L[MAXN], P[MAXN][20];  // direct parent, depth, ancestor\nvector<int> adjList[MAXN];\n\nvoid dfs(int node = 0, int depth = 0) {\n    L[node] = depth;\n    for (int i = 0; i < adjList[node].size(); i++) {\n        int child = adjList[node][i];\n        dfs(child,depth+1);\n    }\n}\n\nint query(int u, int v) {\n    int tmp;\n    if (L[u] < L[v])\n        tmp = u, u = v, v = tmp;\n\n    int LOG2;\n    for (LOG2 = 1; 1 << LOG2 <= L[u]; LOG2++); LOG2--;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (L[u] - (1 << i) >= L[v])\n            u = P[u][i];\n\n    if (u == v)\n        return u;\n\n    for (int i = LOG2; i >= 0; i--)\n        if (P[u][i] != -1 && P[u][i] != P[v][i])\n            u = P[u][i], v = P[v][i];\n\n    return T[u];\n}\n\nint main() {\n\n\n    scanf(\"%d\",&N);\n    for (int u = 0, M; u < N; u++) {\n        scanf(\"%d\",&M);\n        for (int i = 0, v; i < M; i++) {\n            scanf(\"%d\",&v);\n\n            T[v] = u;\n            adjList[u].push_back(v);\n        }\n    }\n\n    // rooted at 0\n    dfs();\n\n    for (int i = 1; i <= N; i++)\n        P[i][0] = T[i];\n    for (int j = 1; 1 << j < N; j++)\n        for (int i = 1; i <= N; i++)\n            if (P[i][j-1] != -1)\n                P[i][j] = P[P[i][j-1]][j-1];\n\n    scanf(\"%d\",&Q);\n    for (int i = 0, u, v; i < Q; i++) {\n        scanf(\"%d%d\",&u,&v);\n        printf(\"%d\\n\", query(u,v));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass lca {\npublic:\n    int n, segn;\n    std::vector<int> path, depth, in_order, out_order;\n    std::vector<std::pair<int,int>> dat;\n    const std::pair<int,int> INF = std::make_pair(1000000000, 1000000000);\n\n    lca(const Graph &g, int root)\n        : n(g.size()),\n          path(n * 2 - 1),\n          depth(n * 2 - 1),\n          in_order(n),\n          out_order(n) {\n        int k = 0;\n        dfs(g, root, -1, 0, k);\n        for (segn = 1; segn < n * 2 - 1; segn <<= 1);\n        dat.assign(segn * 2, INF);\n        for (int i = 0; i < (int)depth.size(); ++i)\n            dat[segn + i] = std::make_pair(depth[i], i);\n        for (int i = segn - 1; i >= 1; --i)\n            dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n    }\n\n    int get(int u, int v) {\n        int l = std::min(in_order[u], in_order[v]);\n        int r = std::max(in_order[u], in_order[v]) + 1;\n        auto res = range_min(1, segn, l, r);\n        return path[res.second];\n    }\n\n    void dfs(const Graph &g, int v, int p, int d, int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : g[v]) {\n            if (e.dst != p) {\n                dfs(g, e.dst, v, d + 1, k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k - 1;\n    }\n\n    std::pair<int,int> range_min(int v, int w, int l, int r) const {\n        if (r <= l || w == 0) return INF;\n        if (r - l == w) return dat[v];\n        int m = w / 2;\n        auto rmin = range_min(v * 2, m, l, std::min(r, m));\n        auto lmin = range_min(v * 2 + 1, m, std::max(0, l - m), r - m);\n        return min(rmin, lmin);\n    }\n};\n\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    Graph g(n);\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            g[i].emplace_back(i, c, 1);\n        }\n    }\n    lca l(g, 0);\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << l.get(u, v) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint n,k,q,sz[100005],hv[100005],vs[100005],hd[100005],dp[100005],chain[100005],id[1000005];\nvector<int>g[100005];\nvoid dfs(int v,int p){\n    sz[v]=1;\n    hv[v]=-1;\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=p){\n            dfs(g[v][i],v);\n            sz[v]+=sz[g[v][i]];\n            if(hv[v]==-1||sz[hv[v]]<sz[g[v][i]])hv[v]=g[v][i];\n        }\n    }\n}\nvoid dfs1(int v,int d,int p,int h){\n    hd[k]=h;\n    id[v]=k;\n    vs[k]=v;\n    dp[k++]=d;\n    if(hv[v]!=-1)dfs1(hv[v],d+1,v,h);\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]!=p&&g[v][i]!=hv[v]){\n            chain[k]=id[v];\n            dfs1(g[v][i],d+1,v,k);\n        }\n    }\n}\nint lca(int u,int v){\n    u=id[u];v=id[v];\n    while(hd[u]!=hd[v]){\n        if(dp[hd[u]]>dp[hd[v]])u=chain[hd[u]];\n        else v=chain[hd[v]];\n    }\n    if(dp[u]<dp[v])return vs[u];\n    else return vs[v];\n}\nint main(void){\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            int a;\n            scanf(\"%d\",&a);\n            g[i].push_back(a);\n            g[a].push_back(i);\n        }\n    }\n    dfs(0,-1);\n    dfs1(0,0,-1,0);\n    scanf(\"%d\",&q);\n    for(int i=0;i<q;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        printf(\"%d\\n\",lca(a,b));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define dump(x) cerr<<#x<<\": \"<<x<<endl;\n#define bit(k) (1LL<<(k))\n#define Yes \"Yes\"\n#define No \"No\"\n#define YES \"YES\"\n#define NO \"NO\"\ntypedef long long ll;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = (ll)1e9;\nconst ll INFLL = (ll)1e18+1;\nconst ll MOD = (ll)1e9+7;\nconst double PI = acos(-1.0);\n/*\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst string dir = \"DRUL\";\n*/\n\nclass LCA{\n  public:\n    int N;\n    int bitlen = 1;\n    vector<vector<int>> edges;\n    vector<int> d; //depth\n    vector<vector<int>> anc; // bitlen * N\n    // the number of vertexs\n    LCA(int _N):N(_N){\n        init(N);\n    }\n    LCA(int _N, vector< vector<int>> G):N(_N){\n        init(N, G);\n    }\n    void init(int n){\n        while((1 << bitlen) < n){\n            bitlen++;\n        }\n        d.assign(n, 0);\n        anc.assign(bitlen, vector<int>(n,-1));\n        dfs();\n    }\n    void init(int n, vector<vector<int>> G){\n        edges = G;\n        init(n);\n    }\n    void dfs(int v = 0, int p = -1){\n        anc[0][v] = p;\n        for(int i = 0; i+1 < bitlen; ++i){\n            anc[i+1][v] = (anc[i][v] >= 0) ? anc[i][anc[i][v]] : -1;\n        }\n        for(auto nv: edges[v]) if(nv != p){\n            d[nv] = d[v]+1;\n            dfs(nv, v);\n        }\n    }\n    int lca(int u, int v){\n        if(d[u] > d[v]) swap(u, v);\n        for(int i = 0; i < bitlen;i++){\n            if((d[v] - d[u]) & (1<<i)){\n                v = anc[i][v];\n            }\n        }\n        if(u == v) return u;\n        for(int i = bitlen-1; i >= 0;i--){\n            if(anc[i][u] != anc[i][v]){\n                u = anc[i][u];\n                v = anc[i][v];\n            }\n        }\n        return anc[0][u];\n    }\n    void debug(){\n        print(d);\n        for(int i = 0;i < bitlen;i++){\n            cerr << i << \": \";print(anc[i]);\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int N;\n    cin >> N;\n    vvec<int> g(N);\n    rep(i,N){\n        int k;\n        cin >> k;\n        rep(j,k){\n            int a;\n            cin >> a;\n            g[i].push_back(a);\n            g[a].push_back(i);\n        }\n    }\n    LCA G(N, g);\n    //G.debug();\n    int Q;\n    cin >> Q;\n    while(Q--){\n        int a, b;\n        cin >> a >> b;\n        cout << G.lca(a, b) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n//CodeChef Persistent Oak\nstruct HLD{\n\tconst vvc<int>&g;\n\tint n,cnt;\n\tvi sub,in,out,par,head,dep;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto to:g[v])if(to!=p)\n\t\t\tsub[v]+=dfs1(to,v,d+1);\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int p,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tpi mx(-1,-1);\n\t\tint i=0;\n\t\tfor(auto to:g[v])if(to!=p)\n\t\t\tchmax(mx,pi(sub[to],i++));\n\t\ti=0;\n\t\tfor(auto to:g[v])if(to!=p&&mx.b==i++)\n\t\t\tdfs2(to,v,h);\n\t\ti=0;\n\t\tfor(auto to:g[v])if(to!=p&&mx.b!=i++)\n\t\t\tdfs2(to,v,to);\n\t\tout[v]=cnt;\n\t}\n\tHLD(const vvc<int>&gg,int r):g(gg),n(g.size()),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n){\n\t\tdfs1(r,-1,0);\n\t\tdfs2(r,-1,r);\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n};\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tvvc<int> t(n);\n\trep(i,n){\n\t\tint m;cin>>m;\n\t\trep(_,m){\n\t\t\tint c;cin>>c;\n\t\t\tt[i].pb(c);\n\t\t}\n\t}\n\t\n\tauto hld=HLD(t,0);\n\t\n\tint q;cin>>q;\n\trep(_,q){\n\t\tint u,v;cin>>u>>v;\n\t\tcout<<hld.lca(u,v)<<\"\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\nconst int logn=18;\n\nint n,q,l;\nint dep[maxn];\nint up[maxn][logn];\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n    dep[u]=dep[p]+1;\n    up[u][0]=p;\n    for (int i=1;i<=l;i++) up[u][i]=up[up[u][i-1]][i-1];\n    for (int v:G[u])\n        if (v!=p) dfs(v,u);\n}\n\nint lca(int u,int v) {\n    if (u==v) return u;\n    if (dep[u]<dep[v]) swap(u,v);\n    for (int i=l;i>=0;i--) {\n        if (dep[up[u][i]]>=dep[v]) u=up[u][i];\n        if (dep[u]==dep[v]) break;\n    }\n    for (int i=l;i>=0;i--)\n        if (up[u][i]!=up[v][i]) {\n            u=up[u][i];\n            v=up[v][i];\n        }\n    return up[u][0];\n}\n\nint main() {\n    cin>>n;\n    for (int i=0;i<n;i++) {\n        int m; cin>>m;\n        for (int j=0;j<m;j++) {\n            int v; cin>>v;\n            G[i].pb(v);\n        }\n    }\n    while ((1<<l)<=n) ++l;\n    dfs(0,0);\n    cin>>q;\n    for (int i=0;i<q;i++) {\n        int u,v; cin>>u>>v;\n        cout<<lca(u,v)<<'\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n\nusing namespace std;\n\nconst int sz = 1e5 + 13;\nconst int logsz = 10;\n\nint n;\n\nint p[sz][logsz];\nint t[sz], level[sz];\n\nvector<vector<int> > g (sz);\n\nvoid dfs(int u, int parent){\n    for(auto v: g[u]){\n        if(v != parent){\n            level[v] = level[u] + 1;\n            t[v] = u;\n            dfs(v, u);\n        }\n    }\n}\n\nvoid preprocess(){\n    t[0] = -1;\n    dfs(0, -1);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; (1<<j) < n; ++j)\n            p[i][j] = -1;\n    for(int i = 0; i < n; ++i)\n        p[i][0] = t[i];\n    for(int j = 1; (1<<j) < n; ++j)\n        for(int i = 0; i < n; ++i) if(p[i][j-1] != -1)\n            p[i][j] = p[p[i][j-1]][j-1];\n}\n\nint lca(int u, int v){\n    if(level[u] < level[v]){u ^= v; v ^= u; u ^= v;}\n    int log;\n    for(log = 1; (1<<log) < level[u]; ++log);\n    log--;\n    for(int i = log; i >= 0; --i)\n        if(level[u]  - (1<< i) >= level[v])\n            u = p[u][i];\n    if(u == v)\n        return u;\n    for(int i = log; i>= 0; --i)\n        if(p[u][i] != -1 && p[u][i] != p[v][i]){\n            u = p[u][i]; v = p[v][i];\n        }\n    return t[u];\n}\n\n\nint main(){\n    cin>>n;\n    for(int i = 0; i < n; ++i){\n        int k;\n        cin>>k;\n        for(int j = 0; j < k; ++j){\n            int x;\n            cin>>x;\n            g[i].push_back(x);\n            g[x].push_back(i);\n        }\n    }\n    preprocess();\n    int q;\n    cin>>q;\n    for(int i = 0; i < q; ++i){\n        int u,v;\n        cin>>u>>v;\n        cout<<lca(u,v)<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nvector<int> vec[100010];\nint table[20][100010];\nint dep[100010];\n\nint bin;\n\nvoid dfs(int num,int par,int d){\n    table[0][num] = par;\n    dep[num] = d;\n    bin = max(bin,(int)log2(d));\n    for(int i=0;i<vec[num].size();i++){\n        dfs(vec[num][i],num,d+1);\n    }\n}\n\nint lca(int u,int v){\n   if(dep[u] > dep[v]) swap(u,v);\n   for(int i=bin;i>=0;i--){\n       if( ((dep[v]-dep[u])>>i) & 1) v = table[i][v];\n   }\n   if(u == v) return u;\n   for(int i=bin;i>=0;i--){\n       if(table[i][u] != table[i][v]){\n           u = table[i][u];\n           v = table[i][v];\n       }\n   }\n   return table[0][u];\n}\n\nint main()\n{\n    int n,k,c,q,u,v;\n    \n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        for(int j=0;j<k;j++){\n            scanf(\"%d\",&c);\n            vec[i].push_back(c);\n        }\n    }\n    \n    bin = 0;\n    dfs(0,-1,0);\n    for(int i=0;i<bin;i++){\n        for(int j=0;j<n;j++){\n            if(table[i][j] == -1) table[i+1][j] = -1;\n            else table[i+1][j] = table[i][ table[i][j] ];\n        }\n    }\n    \n    scanf(\"%d\",&q);\n    for(int i=0;i<q;i++){\n        scanf(\"%d %d\",&u,&v);\n        printf(\"%d\\n\",lca(u,v));\n    }\n    \n    return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int>E[200000];\nint par[200000],d[200000],sub[200000];\nint chain[200000];\n\nvoid dfs(int v,int p,int dep){\n\tpar[v]=p;d[v]=dep;\n\tsub[v]=1;\n\tfor(int u:E[v]){\n\t\tif(u==p)continue;\n\t\tdfs(u,v,dep+1);\n\t\tsub[v]+=sub[u];\n\t}\n}\nvoid hld(int v,int k){\n\tchain[v]=k;\n\tif(E[v].empty())return;\n\tint Max=0,id=-1;\n\tfor(int u:E[v]){\n\t\tif(Max<sub[u]){\n\t\t\tMax=sub[u];\n\t\t\tid=u;\n\t\t}\n\t}\n\tfor(int u:E[v]){\n\t\tif(u==id)hld(u,chain[v]);\n\t\telse hld(u,u);\n\t}\n}\nint lca(int u,int v){\n\twhile(chain[u]!=chain[v]){\n\t\tif(d[chain[u]]>d[chain[v]])swap(u,v);\n\t\tv=par[chain[v]];\n\t}\n\treturn d[u]<d[v]?u:v;\n}\n\nint main(){\n\tint n;scanf(\"%d\",&n);\n\trep(i,n){\n\t\tint k;scanf(\"%d\",&k);\n\t\trep(j,k){\n\t\t\tint c;scanf(\"%d\",&c);\n\t\t\tE[i].push_back(c);\n\t\t}\n\t}\n\tdfs(0,-1,0);\n\thld(0,0);\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tprintf(\"%d\\n\",lca(u,v));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,-1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs=vector<int>(1,0)) {\n    int c=0;\n    for(int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int,int>;\n    stack<T> st;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      int v,&i;\n      tie(v,i) = st.top();\n      if(i<(int)G[v].size()){\n\tint u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tint res=0;\n\tfor(int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if (vid[u] > vid[v]) swap(u, v);\n      f(max(vid[head[v]], vid[u]), vid[v]);\n      if (head[u] != head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] != head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/11/07\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n/*\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned main(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/11/07\nhttps://yukicoder.me/problems/no/529\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< vector< int > > graph;\n\nstruct CentroidPathDecomposition\n{\n  struct Centroid\n  {\n    int ParIndex, ParDepth, Deep;\n    vector< int > node;\n\n    inline int size()\n    {\n      return (node.size());\n    }\n\n    inline int& operator[](int k)\n    {\n      return (node[k]);\n    }\n\n    inline pair< int, int > Up()\n    {\n      return (make_pair(ParIndex, ParDepth));\n    }\n  };\n\n  vector< int > SubTreeSize, NextPath;\n  vector< int > TreeIndex, TreeDepth;\n  vector< Centroid > Centroids;\n\n  void BuildSubTreeSize()\n  {\n    stack< pair< int, int > > s;\n    s.emplace(0, -1);\n\n    while(!s.empty()) {\n      auto p = s.top();\n      if(~SubTreeSize[p.first]) {\n        if(~p.second) {\n          if(NextPath[p.second] == -1 || SubTreeSize[p.first] > SubTreeSize[NextPath[p.second]]) {\n            NextPath[p.second] = p.first;\n          }\n          SubTreeSize[p.second] += SubTreeSize[p.first];\n        }\n        s.pop();\n      } else {\n        SubTreeSize[p.first] = 1;\n        for(int& to : graph[p.first]) {\n          if(p.second != to) {\n            s.emplace(to, p.first);\n          }\n        }\n      }\n    }\n  }\n\n  void BuildPath()\n  {\n    stack< pair< int, int > > s;\n    Centroids.push_back((Centroid) {-1, -1, 0});\n    s.emplace(0, -1);\n    TreeIndex[0] = 0;\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      TreeDepth[p.first] = Centroids[TreeIndex[p.first]].size();\n      for(auto& to : graph[p.first]) {\n        if(p.second != to) {\n          if(to == NextPath[p.first]) {\n            TreeIndex[to] = TreeIndex[p.first];\n          } else {\n            TreeIndex[to] = Centroids.size();\n            Centroids.push_back(\n              (Centroid) {TreeIndex[p.first], TreeDepth[p.first], Centroids[TreeIndex[p.first]].Deep + 1});\n          }\n          s.emplace(to, p.first);\n        }\n      }\n      Centroids[TreeIndex[p.first]].node.push_back(p.first);\n    }\n  }\n\n  void AddEdge(int x, int y)\n  {\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n\n  void Build()\n  {\n    BuildSubTreeSize();\n    BuildPath();\n  }\n\n  inline int size()\n  {\n    return (Centroids.size());\n  }\n\n  inline pair< int, int > Information(int idx)\n  {\n    return (make_pair(TreeIndex[idx], TreeDepth[idx]));\n  }\n\n  inline Centroid& operator[](int k)\n  {\n    return (Centroids[k]);\n  }\n\n  inline int LCA(int a, int b) // ??????????????¨??????\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    return (Centroids[TreeIdxA][TreeDepthA]);\n  }\n\n  CentroidPathDecomposition(int SZ)\n  {\n    graph.resize(SZ);\n    SubTreeSize.resize(SZ, -1);\n    NextPath.resize(SZ, -1);\n    TreeIndex.resize(SZ);\n    TreeDepth.resize(SZ);\n  }\n};\n\nint main()\n{\n  int N, Q;\n  scanf(\"%d\", &N);\n  CentroidPathDecomposition tree(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int c;\n      scanf(\"%d\", &c);\n      graph[i].push_back(c);\n    }\n  }\n  tree.Build();\n  scanf(\"%d\", &Q);\n  for(int i = 0; i < Q; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", tree.LCA(u, v));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) ord[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour& euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  // std::freopen(\"in_large.txt\", \"r\", stdin);\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  int s = 0;\n  for (int v : et.id) s += v;\n  LCA lca(et);\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst int sqrtN = 512;\nconst int logN = 32;\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nstruct LowestCommonAncestor{\n\tvector<vector<int>> g, parent;\n\tvector<int> depth;\n\tbool built = false;\n\tint N;\n\t\n\tLowestCommonAncestor(int n) : N(n) {\n\t\tg.resize(N);\n\t\tparent.resize(logN, vector<int>(N));\n\t\tdepth.resize(N);\n\t}\n\t\n\tvoid add_edge(int u, int v){\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int par = -1, int d = 0){\n\t\tparent[0][v] = par;\n\t\tdepth[v] = d;\n\t\t\n\t\tfor(auto e:g[v]){\n\t\t\tif(e == par) continue;\n\t\t\tdfs(e, v, d + 1);\n\t\t}\n\t}\n\t\n\tvoid build(){\n\t\tdfs(0);\n\t\tREP(k, 0, logN - 1){\n\t\t\tREP(i, 0, N){\n\t\t\t\tif(parent[k][i] < 0) parent[k + 1][i] = -1;\n\t\t\t\telse parent[k + 1][i] = parent[k][parent[k][i]];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint get(int u, int v){\n\t\tif(!built) build(); built = true;\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\t\n\t\tREP(k, 0, logN) if(((depth[v] - depth[u]) >> k) & 1) v = parent[k][v];\t\n\t\tif(u == v) return u;\n\t\t\n\t\tRREP(k, logN - 1, 0){\n\t\t\tif(parent[k][u] == parent[k][v]) continue;\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\t\t\t\n\t\t}\n\t\t\n\t\treturn parent[0][u];\n\t}\n};\n\nint main(){\n\tint n; cin >> n;\n\tLowestCommonAncestor lca(n);\n\tREP(i, 0, n){\n\t\tint k; cin >> k;\n\t\tREP(j, 0, k){\n\t\t\tint a; cin >> a;\n\t\t\tlca.add_edge(i, a);\n\t\t}\n\t}\n\tint q; cin >> q;\n\tREP(i, 0, q){\n\t\tint a, b; cin >> a >> b;\n\t\t\n\t\tcout << lca.get(a, b) << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nint et[200000];\nint depth[200000];\nint id[100000];\n\nstruct ST\n{\n\tvector<pii> data;\n\tint size;\n\tST(int n)\n\t{\n\t\tsize = 1;\n\t\twhile (size < n)size *= 2;\n\n\t\tdata.resize(2 * size - 1);\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = pii(INF, -1);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[size - 1 + i] = pii(depth[i], et[i]);\n\t\t}\n\n\t\tint k = size - 1;\n\t\twhile (--k > 0)\n\t\t{\n\t\t\tdata[k] = min(data[2 * k + 1], data[2 * k + 2]);\n\t\t}\n\t}\n\n\tpii find(int s, int t, int k,int l, int r)\n\t{\n\t\tif (r == -1)\n\t\t{\n\t\t\tr = size;\n\t\t}\n\t\tif (t <= l || r <= s)\n\t\t{\n\t\t\treturn pii(INF, -1);\n\t\t}\n\t\tif (s <= l&&r <= t)\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\n\t\treturn min(find(s, t, 2 * k + 1, l, (l + r) / 2), find(s, t, 2 * k + 2, (l + r) / 2, r));\n\t}\n};\n\nvoid ET(int n, int p, int& eti, int d)\n{\n\tif (id[n] == 0)\n\t{\n\t\tid[n] = eti;\n\t}\n\tet[eti] = n;\n\tdepth[eti] = d;\n\teti++;\n\n\tfor (auto& e : G[n])\n\t{\n\t\tif (e != p)\n\t\t{\n\t\t\tET(e, n, eti, d + 1);\n\t\t\tet[eti] = n;\n\t\t\tdepth[eti] = d;\n\t\t\teti++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tid[0] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0; j < k; j++)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\n\tint eti = 0;\n\tET(0, -1, eti, 0);\n\n\tST st(eti);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tprintf(\"%d\\n\", st.find(id[u], id[v] + 1, 0, 0, -1).second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// template version 1.15\nusing namespace std;\n#include <bits/stdc++.h>\n\n// varibable settings\n#define int long long\nconst int INF=1e18;\n\n// define basic macro {{{\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rrep(i,n) rrepi(i,0,n)\n#define rrepi(i,a,b) for(int i=(int)((b)-1);i>=(int)(a);--i)\n#define rrep(...) _overload3(__VA_ARGS__,rrepi,_rrep,)(__VA_ARGS__)\n#define each(i,a) for (auto&& i : a)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define mt(a, b, c) make_tuple(a, b, c)\n#define ub upper_bound\n#define lb lower_bound\n#define posl(A, x) (lower_bound(all(A), x)-A.begin())\n#define posu(A, x) (upper_bound(all(A),x)-A.begin())\ntemplate<class T> inline void chmax(T &a, const T &b) { if((a) < (b)) (a) = (b); }\ntemplate<class T> inline void chmin(T &a, const T &b) { if((a) > (b)) (a) = (b); }\n\n#define divceil(a,b) ((a)+(b)-1)/(b)\n#define is_in(x, a, b) ((a)<=(x) && (x)<(b))\n#define uni(x) sort(all(x));x.erase(unique(all(x)),x.end())\n#define slice(l, r) substr(l, r-l)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> iii;\n\ntemplate<typename T> using PQ = priority_queue<T, vector<T>, greater<T>>;\nstruct Fast { Fast(){ std::cin.tie(0); ios::sync_with_stdio(false); } } fast;\n\n#if defined(PCM) || defined(LOCAL)\n  #include \"lib/dump.hpp\"\n#else\n  #define dump(...) 42\n  #define dump_1d(...) 42\n  #define dump_2d(...) 42\n  #define cerrendl 42\n#endif\n//}}}\n\ntemplate<typename T> struct SegmentTree { // {{{\n  private:\n    using F = function<T(T,T)>;\n    int n;  // 元の配列のサイズ\n    int N;  // n以上の最小の2冪\n    vector<T> node;\n    F merge;\n    T identity;\n\n  public:\n    SegmentTree(){}\n    SegmentTree(vector<T> a, F f, T id):merge(f), identity(id) {\n      n = a.size();\n      N = 1; while(N < n) N *= 2;\n      node.resize(2*N-1, identity);\n      for(int i=0; i<n; i++) node[i+N-1] = a[i];\n      for(int i=N-2; i>=0; i--) node[i] = merge(node[2*i+1], node[2*i+2]);\n    }\n    SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}\n\n    T& operator[](int i) { return node[i+N-1]; }\n\n    void update(int x, T val) {\n      x += (N - 1);\n      node[x] = val;\n      while(x > 0) {\n        x = (x - 1) / 2;\n        node[x] = merge(node[2*x+1], node[2*x+2]);\n      }\n    }\n\n    void add(int x, T val) {\n      x += (N - 1);\n      node[x] += val;\n      while(x > 0) {\n        x = (x - 1) / 2;\n        node[x] = merge(node[2*x+1], node[2*x+2]);\n      }\n    }\n\n    // query for [l, r)\n    T query(int a, int b, int k=0, int l=0, int r=-1) {\n      if(r < 0) r = N;\n      if(r <= a || b <= l) return identity;\n      if(a <= l && r <= b) return node[k];\n\n      T vl = query(a, b, 2*k+1, l, (l+r)/2);\n      T vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return merge(vl, vr);\n    }\n\n    friend ostream& operator<<(ostream &os, SegmentTree<T>& sg){ //\n      os << \"[\";\n      for(int i=0; i<sg.n; i++){\n        os << sg[i] << (i==sg.n-1?\"]\\n\":\", \");\n      }\n      return os;\n    }\n};\n// }}}\nstruct tree{/*{{{*/\n  int n;\n  vector<int> par;  // par[i]: dfs木における親\n  vector<int> cost;  // par[i]: dfs木における親への辺のコスト\n  vector<int> dfstrv; // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す\n  vector<int> ord;  // ord[u]: uのdfs木における訪問順\n  vector<int> pos;  // pos[u]: uのdfs終了時のカウンター\n  vector<int> psize; // psize[u]: uのpartial tree size\n  // vの部分木は[ord[v], pos[v])\n  // ordとdfstrvは逆変換\n\n  vector<int> depth;  // depth[i]: dfs木でのiの深さ\n  vector<vector<pair<int, int>>> g; // 辺(隣接リスト)\n  vector<vector<int>> children;\n  vector<int> euler_tour;\n  vector<int> et_fpos;  // euler_tour first occurence position\n  SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)\n\n  int _counter = 0;\n\n  tree(int n):\n    n(n),par(n),cost(n,1),ord(n),pos(n),psize(n),depth(n),g(n),children(n),et_fpos(n)\n  {};\n\n  void add_edge(int u, int v, int cost){\n    g[u].emplace_back(v, cost);\n    g[v].emplace_back(u, cost);\n  }\n  void add_edge(int u, int v){\n    g[u].emplace_back(v, 1);\n    g[v].emplace_back(u, 1);\n  }\n\n  void build(int root){\n    _counter = 0;\n    par[root] = -1;\n    cost[root] = INF;\n    _dfs_tree(root, -1, 0);\n    _dfs_et(root);\n    vector<int> ini(2*n-1); rep(i, 2*n-1) ini[i] = ord[euler_tour[i]];\n    _seg = SegmentTree<int>(ini, [](auto a, auto b){return min(a,b);}, 1e18);\n  }\n\n  void _dfs_tree(int u, int pre, int _depth){\n    dfstrv.pb(u);\n    ord[u] = _counter;\n    depth[u] = _depth;\n\n    _counter++;\n    each(el, g[u]){\n      int v = el.first;\n      if (v==pre) continue;\n\n      children[u].pb(v);\n      par[v] = u;\n      cost[v] = el.second;\n      _dfs_tree(v, u, _depth+1);\n    }\n    pos[u] = _counter;\n    psize[u] = pos[u] - ord[u];\n  }\n\n  void _dfs_et(int u){\n    et_fpos[u] = euler_tour.size();\n    euler_tour.pb(u);\n    each(v, children[u]){\n      _dfs_et(v);\n      euler_tour.pb(u);\n    }\n  }\n\n  int lca(int u, int v){\n    if (u==v) return u;\n\n    if (et_fpos[u]>et_fpos[v]) swap(u, v);\n    return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];\n  }\n};/*}}}*/\n\nsigned main() {\n  int n;cin>>n;\n  tree tr(n);\n\n  rep(u, n){\n    int k;cin>>k;\n    rep(_, k){\n      int v;cin>>v;\n      tr.add_edge(u, v);\n    }\n  }\n  tr.build(0);\n\n  int Q;cin>>Q;\n  rep(q, Q){\n    int u,v;cin>>u>>v;\n    cout << tr.lca(u, v) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> P[100010];\nint depth[100010];\nint parent[30][100010];//parent[いくつ上の階層か][ノード]\nint root;\n\nvoid dfs(int v,int p,int d){\n  parent[0][v]=p;\n  depth[v]=d;\n  for(int i=0; i<P[v].size(); i++){\n    if(P[v][i]!=p){\n        dfs(P[v][i], v, d+1);\n    }\n  }\n}\nvoid init(int V){\n  dfs(root, -1, 0);\n  for(int k=0; k+1<30; k++){\n    for(int v=0; v<V; v++){\n      if(parent[k][v]<0) parent[k+1][v]=-1;\n      else parent[k+1][v]=parent[k][parent[k][v]];\n    }\n  }\n}\n\nint lca(int u, int v){\n    if(depth[u]>depth[v]) swap(u,v);//根から遠い位置にある方をvにする\n    for(int k=0; k<30; k++){\n        //cout << \"k=\" << k << \"\\n\";\n        //cout << \"depth[\"<<v<<\"], depth[\"<<u<<\"]=\"<<depth[v]<<\" \"<<depth[u]<<\"\\n\";\n        if((depth[v]-depth[u])>>k&1){//深さはいくつ違うのか\n            v=parent[k][v];\n            //cout << v <<\"\\n\";\n        }\n        if(u==v) return u;\n    }\n    for(int k=29; k>=0; k--){\n        if(parent[k][u]!=parent[k][v]){\n            u=parent[k][u];\n            v=parent[k][v];\n            //cout << \"u, v=\" << u <<\", \" << v <<\"\\n\";\n        }\n    }\n    return parent[0][u];\n}\n\nint main(){\n  root=0;\n  cin >> n;\n  int k, c;\n  for(int i=0; i<n; i++){\n      cin >> k;\n      while(k--){\n          cin >> c;\n          P[i].push_back(c);\n      }\n  }\n  init(n);\n  int q;\n  cin >> q;\n  while(q--){\n      //cout << \"----------------\" <<\"\\n\";\n      int u, v;\n      cin >> u >> v;\n      cout << lca(u, v) << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<typename T> class Monoid{\npublic:\n\tvirtual T e()=0,c(T,T)=0;\n};\n\nclass MiniMonoid:public Monoid<int>{\npublic:\n\tvector<int>& vs;\n\tMiniMonoid(vector<int>& vs):vs(vs){};\n\tint e(){return -1;}\n\tint c(int a,int b){\n\t\tif(b==-1)return a;if(a==-1)return b;\n\t\treturn min(vs[a],vs[b])==vs[a]?a:b;// left most\n\t}\n};\n\ntemplate<typename T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;Monoid<T>& m;\n\tSegmentTree(int n,Monoid<T>& m):size(n),n2(upper_pow2(size)),m(m){\n\t\tdat=vector<T>(n2*2,m.e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return m.e();//out of range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\ntemplate<typename T> class SegmentTreei{\npublic:\n\tvector<T> vs;MiniMonoid mm;SegmentTree<T> seg;\n\tSegmentTreei(int n):vs(n),mm(vs),seg(n,mm){}\n\tvoid set(int v,T a){ vs[v]=a;seg.set(v,v);}\n};\n\ntypedef vector<vector<int>> Graph;\nclass EularTourLCA{\n\tpublic:\n\tGraph& g;int r;\n\tvector<int> id,depth,vs;\n\tSegmentTreei<int> rmq;\n\tEularTourLCA(Graph & g,int r):g(g),r(r),rmq(SegmentTreei<int>(2*g.size()-1)){\n\t\tid=vector<int>(g.size());\n\t\tdepth=vector<int>(2*g.size()-1);\n\t\tvs=vector<int>(2*g.size()-1);\n\t\tint k=0;dfs(-1,r,0,k);\n\t\tREP(i,vs.size())rmq.set(i,depth[i]);\n\t};\n\tvoid dfs(int p,int s,int d,int& k){\n\t\tid[s]=k;vs[k]=s;depth[k++]=d;\n\t\tfor(int t:g[s])if(t!=p){\n\t\t\tdfs(s,t,d+1,k);\n\t\t\tvs[k]=s;\n\t\t\tdepth[k++]=d;\n\t\t}\n\t}\n\tint lca(int u,int v){ return vs[rmq.seg.query(min(id[u],id[v]),max(id[u],id[v])+1)];}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tGraph g(n);\n\t\tREP(i,n){\n\t\t\tint k;cin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint t;cin >> t;\n\t\t\t\tg[i].push_back(t); g[t].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tEularTourLCA lca(g,0);\n\t\tint q;cin >>q;\n\t\tREP(i,q){\n\t\t\tint u,v;cin >> u >> v;\n\t\t\tcout << lca.lca(u,v) <<endl;\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 100005\n#define pb push_back\n\nint n, k, q, table[20][N], d[N], s, tmp, cnt;\nvector <int> ve[N];\nbool used[N];\n\nvoid dfs(int v){\n\tused[v] = 1;\n\td[v] = cnt;\n\ttmp = max(tmp, cnt);\n\tfor (auto x : ve[v])\n\t\tif (!used[x]){\n\t\t\tcnt++;\n\t\t\ttable[0][x] = v;\n\t\t\tdfs(x);\n\t\t\tcnt--;\n\t\t}\n}\n\nint main (){\n\tcin >> n;\n\tint u, v;\n\tfor (int i = 0;i < n;i++){\n\t\tcin >> k;\n\t\twhile (k--){\n\t\t\tcin >> v;\n\t\t\tve[i].pb(v);\n\t\t}\n\t}\n\tdfs(0);\n\ttable[0][0] = -1;\n\ts = log(tmp);\n\tfor (int i = 1;i <= s;i++)\n\t\tfor (int j = 0;j < n;j++)\n\t\t\tif (table[i - 1][j] == -1) table[i][j] = -1;\t\t\t\n\t\t\telse table[i][j] = table[i - 1][table[i - 1][j]];\n\tcin >> q;\n\twhile (q--){\n\t\tcin >> u>> v;\n\t\tif (d[u] < d[v]) swap(u, v);\n\t\ttmp = d[u] - d[v];\n\t\tcnt = 0;\n\t\twhile(cnt <= s){\n\t\t\tif (tmp % 2) u = table[cnt][u];\n\t\t\ttmp /= 2;\n\t\t\tcnt++;\n\t\t} \n\t\tif (u == v){\n\t\t\tcout << u<< endl;\n\t\t\tbreak;\n\t\t}\n\t\tcnt = s;\n\t\twhile(cnt >= 0){\n\t\t\tif (table[cnt][u] != table[cnt][v]){\n\t\t\t\tu = table[cnt][u];\n\t\t\t\tv = table[cnt][v];\n\t\t\t}\n\t\t\tcnt--;\n\t\t}\n\t\tcout << table[0][u]<< endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nclass LCA {\nprivate:\n\tconst std::vector<std::vector<int>>& graph; // graph's list expression\n\tint root;\n\tint n; // the number of nodes\n\tint log2n; // = floor(log2(n))\n\tstd::vector<std::vector<int>> parent; // parent[x][v] = a parent(above 2^x) of v (nonexistence -> -1)\n\tstd::vector<int> depth; // the depth of each node\n\npublic:\n\tLCA(const std::vector<std::vector<int>>& graph, int root) :\n\t\tgraph(graph), root(root), n(graph.size()), \n\t\tlog2n(std::max((signed)std::floor(std::log2(n)), 1)),\n\t\tparent(log2n, std::vector<int>(n, 0)), depth(n, 0)\n\t{\n\t\tinit();\n\t}\n\n\t// Check the depth of each node(node \"v\" -> parent is \"p\", depth is \"d\")\n\tvoid dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (int i = 0; i < graph[v].size(); ++i) {\n\t\t\tif (graph[v][i] != p) {\n\t\t\t\tdfs(graph[v][i], v, d + 1); // Check each child of v\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initialize\n\tvoid init() {\n\t\t// Initialize \"parent[0]\" and \"depth\"\n\t\tdfs(root, -1, 0);\n\n\t\t// Initialize \"parent\"\n\t\tfor (int k = 0; k < log2n - 1; ++k) {\n\t\t\tfor (int v = 0; v < n; ++v) {\n\t\t\t\tif (parent[k][v] < 0) { // If parent above 2^k of v is nonexistence\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find LCA of (u, v)\n\tint lca(int u, int v) {\n\t\t// go up parent while depth of u and v is same\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2n; ++k) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v]; // go up to 2^k if k-th binary is 1\n\t\t\t}\n\t\t}\n\n\t\tif (u == v) return u; // this case is that v is in u's subtree\n\n\t\t// Find LCA by binary searching\n\t\tfor (int k = log2n - 1; k >= 0; --k) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n) {\n\t\tVAR(int, k);\n\t\tVEC(int, c, k);\n\t\tREP(j, k) {\n\t\t\tg[i].emplace_back(c[j]);\n\t\t}\n\t}\n\tLCA lca(g, 0);\n\tVAR(int, Q);\n\tREP(q, Q) {\n\t\tVAR(int, u, v);\n\t\tOUT(lca.lca(u, v))BR;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n#define IN(x, a, b) x >= a and x < b\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename T> constexpr T INF = numeric_limits<T>::max() / 2;\n#pragma endregion\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  int logn = log2(n);\n  vector<vector<int>> next(logn + 1, vector<int>(n, -1));\n  vector<int> depth(n, 0);\n  // next[0][0] = -1;\n  REP(i, n) {\n    int k;\n    cin >> k;\n    REP(j, k) {\n      int c;\n      cin >> c;\n      next[0][c] = i;\n      depth[c] = depth[i] + 1;\n    }\n  }\n\n  REP(k, logn) {\n    REP(i, n) {\n      if (next[k][i] == -1) {\n        next[k + 1][i] = -1;\n      } else {\n        next[k + 1][i] = next[k][next[k][i]];\n      }\n    }\n  }\n\n  int q;\n  cin >> q;\n  REP(i, q) {\n    int u, v;\n    cin >> u >> v;\n    if (depth[u] > depth[v]) {\n      int Q = depth[u] - depth[v];\n      for (int k = logn - 1; k >= 0; k--) {\n        if ((Q >> k) & 1) {\n          u = next[k][u];\n        }\n      }\n    } else if (depth[u] < depth[v]) {\n      int Q = depth[v] - depth[u];\n      for (int k = logn; k >= 0; k--) {\n        if ((Q >> k) & 1) {\n          v = next[k][v];\n        }\n      }\n    }\n\n    if (u == v) {\n      cout << u << '\\n';\n      continue;\n    }\n\n    for (int k = logn - 1; k >= 0; k--) {\n      if (next[k][u] != next[k][v] and next[k][u] != -1 and next[k][v] != -1) {\n        u = next[k][u];\n        v = next[k][v];\n      }\n    }\n    cout << next[0][u] << '\\n';\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <cstdlib>\n#include <vector>\n\ntemplate <typename T>\nstruct RMQ {\n  using Index = int;\n  using BitIndex = int;\n\n  const std::vector<T>& A;\n  const int N, S, L, LG_L;\n\n  std::vector<int> lg;\n  BitIndex* const small;\n  Index* const large;\n\n  bool f(Index a, Index b) const {\n    if (A[a] != A[b]) return A[a] < A[b];\n    return a < b;\n  }\n  RMQ(const std::vector<T>& A) : RMQ(A, A.size()) {}\n  Index query(Index l, Index r) const {\n    const int a = l / S, b = r / S;\n    if (a == b) return query_small(l, r);\n\n    Index ans = F(query_small(l, a * S + (S - 1)), query_small(b * S, r));\n    if (a + 1 <= b - 1) ans = F(ans, query_large(a + 1, b - 1));\n    return ans;\n  }\n  ~RMQ() {\n    std::free(small);\n    std::free(large);\n  }\nprivate:\n  inline Index F(Index a, Index b) const { return f(a, b) ? a : b; }\n\n  RMQ(const std::vector<T>& A, int N) : RMQ(A, N, std::__lg(N) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S) : RMQ(A, N, S, (N + S - 1) / S) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L) : RMQ(A, N, S, L, std::__lg(L) + 1) {}\n  RMQ(const std::vector<T>& A, int N, int S, int L, int LG_L)\n      : A(A), N(N), S(S), L(L), LG_L(LG_L), lg(1 << S), small((BitIndex*)std::malloc(N * sizeof(BitIndex))), large((Index*)std::malloc(L * LG_L * sizeof(Index))) {\n    assert(small != nullptr);\n    assert(large != nullptr);\n    for (int i = 1, sz = lg.size(); i < sz; i++) {\n      lg[i] = std::__lg(i);\n    }\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      large[li * LG_L + 0] = i;\n      for (int si = 0; si < S && i + si < N; si++) {\n        large[li * LG_L + 0] = F(large[li * LG_L + 0], i + si);\n      }\n    }\n    for (int x = 0; x < LG_L - 1; x++) {\n      for (int li = 0; li + (1 << x) < L; li++) {\n        large[li * LG_L + x + 1] = F(large[li * LG_L + x], large[(li + (1 << x)) * LG_L + x]);\n      }\n    }\n    Index st[32];\n    for (int li = 0; li < L; li++) {\n      int i = li * S;\n      int sti = 0;\n      for (int si = 0; si < S && i + si < N; si++) {\n        while (sti > 0 && f(i + si, st[sti - 1])) --sti;\n        small[i + si] |= 1 << si;\n        if (sti > 0) small[i + si] |= small[st[sti - 1]];\n        st[sti] = i + si;\n        ++sti;\n      }\n    }\n  }\n  inline int ntz(int x) const { return lg[x & -x]; }\n  inline int bitmask(int l, int r) const { return ((1 << (r - l + 1)) - 1) << l; }\n  inline Index query_small(Index l, Index r) const { return (l - l % S) + ntz(small[r] & bitmask(l % S, r % S)); }\n  inline Index query_large(Index l, Index r) const {\n    int x = lg[r - l + 1];\n    return F(large[l * LG_L + x], large[(r - (1 << x) + 1) * LG_L + x]);\n  }\n};\n#include <vector>\n#include <stack>\n\nstruct EulerTour {\n  using tree_type = std::vector<std::vector<int>>;\n  tree_type T;\n  std::vector<int> id, depth;\n  std::vector<int> ord;\n\n  EulerTour(int N) : T(N), ord(N) {}\n\n  void add_edge(int s, int t) {\n    T[s].push_back(t);\n    T[t].push_back(s);\n  }\n\n  void build(int root) {\n    id.reserve(T.size() * 3);\n    depth.reserve(T.size() * 3);\n    traverse(root);\n    id.shrink_to_fit();\n    depth.shrink_to_fit();\n  }\n\n  void traverse(int u, int p=-1, int d=0) {\n    struct Frame {\n      int u, p, d;\n      int i = 0;\n      Frame(int u, int p, int d) : u(u), p(p), d(d) {}\n    };\n    std::stack<Frame> s;\n\n    s.emplace(u, p, d);\n    while (!s.empty()) {\n      auto& f = s.top();\n      if (f.i == 0) ord[f.u] = id.size();\n      id.push_back(f.u);\n      depth.push_back(f.d);\n\n      bool call = false;\n      while (f.i < T[f.u].size()) {\n        int v = T[f.u][f.i];\n        ++f.i;\n        if (v != f.p) {\n          s.emplace(v, f.u, f.d + 1);\n          call = true;\n          break;\n        }\n      }\n      if (!call) s.pop();\n    }\n  }\n};\n#include <vector>\n\nstruct LCA {\n  EulerTour euler_tour;\n  const RMQ<int> rmq;\n\n  LCA(EulerTour&& euler_tour) : euler_tour(euler_tour), rmq(euler_tour.depth) {}\n\n  int query(int u, int v) const {\n    int l = euler_tour.ord[u];\n    int r = euler_tour.ord[v];\n    if (r < l) std::swap(r, l);\n    int x = rmq.query(l, r);\n    return euler_tour.id[x];\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T=int>\nT rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\ntemplate<typename T=int>\nvoid wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  // std::freopen(\"in_large.txt\", \"r\", stdin);\n  int N = rd();\n  EulerTour et(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    et.T[i].reserve(k);\n    for (int j = 0; j < k; j++) {\n      et.T[i].push_back(rd());\n    }\n  }\n  et.build(0);\n  LCA lca(move(et));\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(lca.query(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string.h>\n#include <algorithm>\n#define P pair<int,int>\nusing namespace std;\n\nint Count;\nvoid dfs(int n,int dep,vector<vector<int>>& T,vector<P>& ET,vector<bool>& f,vector<int>& index) {\n\tf[n] = true;\n\tET.emplace_back(make_pair(n,dep));\n\tindex[n] = Count; Count++;\n\tfor (int next : T[n]) {\n\t\tif (f[next] == true) continue;\n\t\tdfs(next,dep + 1, T, ET, f,index);\n\t\tET.emplace_back(make_pair(n,dep));\n\t\tCount++;\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<int> index(n);\n\tvector<bool> f(n,false);\n\tvector<vector<int>> T(n);\n\tvector<P> ET;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tT[i].emplace_back(c);\n\t\t\tT[c].emplace_back(i);\n\t\t}\n\t}\n\tdfs(0,0, T, ET, f,index);\n\tvector<int> V;\n\tfor (P i : ET) {\n\t\tV.emplace_back(i.second);\n\t}\n\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tvector<int>::iterator minIt;\n\t\tif (index[u] < index[v]) {\n\t\t\tminIt = min_element(V.begin() + index[u], V.begin() + index[v]);\n\t\t}\n\t\telse {\n\t\t\tminIt = min_element(V.begin() + index[v], V.begin() + index[u]);\n\t\t}\n\t\tauto minIndex = distance(V.begin(), minIt);\n\t\tcout << ET[minIndex].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n// verify : https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_A\ntemplate<class Monoid> struct SegmentTree {\nprivate:\n    using Func = std::function<Monoid(Monoid, Monoid)>;\n    Func F;\n    Monoid UNITY;\n    int n;\n    std::vector<Monoid> node;\npublic:\n    SegmentTree() {}\n\n    // val で埋める\n    SegmentTree(int m, const Monoid &val, const Func f, const Monoid &unity) {\n        F = f;\n        UNITY = unity;\n        n = 1; while (n < m) n <<= 1;\n        node.resize(n * 2 - 1, UNITY);\n        if (val != UNITY) {\n            for (int i = 0; i < m; i++) node[i] = val;\n            build();\n        }\n    }\n\n    SegmentTree(const std::vector<Monoid>& v, const Func f, const Monoid &unity) {\n        F = f;\n        UNITY = unity;\n        int sz = v.size();\n        n = 1; while (n < sz) n <<= 1;\n        node.resize(n * 2 - 1, UNITY);\n        for (int i = 0; i < sz; i++) node[i + n - 1] = v[i];\n        build();\n    }\n\n    // 最後に build が必要\n    void set(int k, const Monoid &x) {\n        node[n + k - 1] = x;\n    }\n\n    void build() {\n        for (int i = n - 2; i >= 0; i--) node[i] = F(node[2 * i + 1], node[2 * i + 2]);\n    }\n\n    void update_query(int x, const Monoid &val) {\n        if (x >= n || x < 0) return;\n        x += n - 1;\n        node[x] = val;\n        while (x > 0) {\n            x = (x - 1) >> 1;\n            node[x] = F(node[2 * x + 1], node[2 * x + 2]);\n        }\n    }\n\n    /*\n    // 再帰のためお蔵\n    Monoid query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return UNITY;\n        if (a <= l && r <= b) return node[k];\n        Monoid vl = query(a, b, 2 * k + 1, l, (r - l) / 2 + l);\n        Monoid vr = query(a, b, 2 * k + 2, (r - l) / 2 + l, r);\n        return F(vl, vr);\n    }\n    */\n\n    // [a,b)\n    Monoid get_query(int a, int b) {\n        Monoid L = UNITY, R = UNITY;\n        for (a += n, b += n; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = F(L, node[a++ - 1]);\n            if (b & 1) R = F(node[--b - 1], R);\n        }\n        return F(L, R);\n    }\n\n    Monoid operator[](int x)const {\n        return node[n + x - 1];\n    }\n\n    int size() {\n        return n;\n    }\n\n    void print() {\n        for (int i = 0; i < n; i++) {\n            std::cout << i << \"\\t: \" << node[n + i - 1] << std::endl;\n        }\n    }\n};\n\n// 最近共通祖先(EulerTour)\n// verify : https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_C\n// <O(N),O(lonN)>\nstruct LowestCommonAncestor {\nprivate:\n    int V;\n    const int INF = 1e9 + 6;\n    std::vector< int > ord, dep, id;\n    SegmentTree< std::pair< int, int > > st; // (value,index)\n    void dfs(int u, int p, int k, const std::vector< std::vector< int > > &Tree) {\n        id[u] = (int)ord.size();\n        ord.push_back(u);\n        dep[u] = k;\n        for (auto v : Tree[u]) {\n            if (v != p) {\n                dfs(v, u, k + 1, Tree);\n                ord.push_back(u);\n            }\n        }\n    }\n\npublic:\n\n    // Tree以外を与えるとバグる\n    LowestCommonAncestor(const std::vector< std::vector< int > > &G, int root = 0) {\n        build(G, root);\n    }\n\n    void build(const std::vector< std::vector< int > > &G, int root = 0) {\n        V = G.size();\n        dep.resize(V);\n        id.resize(V, -1);\n        ord.reserve(2 * V - 2);\n        dfs(root, -1, 0, G);\n        st = SegmentTree< std::pair< int, int > >(2 * V - 2, {INF, -1}, [](std::pair< int, int > a, std::pair< int, int > b) { return std::min(a, b); }, {INF, -1});\n        for (int i = 0; i < 2 * V - 2; i++) {\n            st.set(i, {dep[ord[i]], i});\n        }\n        st.build();\n    }\n\n    // u, vのlca O(logN)\n    int lca(int u, int v) {\n        return ord[st.get_query(std::min(id[u], id[v]), std::max(id[u], id[v]) + 1).second];\n    }\n\n    // u, vの距離 O(logN)\n    int dist(int u, int v) {\n        int lca_ = lca(u, v);\n        return dep[u] + dep[v] - 2 * dep[lca_];\n    }\n\n    int depth(int v) {\n        return dep[v];\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> G(n);\n    for (int i = 0; i < n; i++) {\n        int k; cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    LowestCommonAncestor lca(G, 0);\n    int q; cin >> q;\n    for (int _ = 0; _ < q; _++) {\n        int x, y; cin >> x >> y;\n        cout << lca.lca(x, y) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T = long long>\nstruct edge {\n\tT len;\n\tint from;\n\tint to;\n\tbool operator<(const edge a) const {\n\t\tif(len != a.len) return len < a.len;\n\t\tif(from != a.from) return from < a.from;\n\t\treturn to < a.to;\n\t}\n\tbool operator>(const edge a) const {\n\t\tif(len != a.len) return len > a.len;\n\t\tif(from != a.from) return from > a.from;\n\t\treturn to > a.to;\n\t}\n};\ntemplate <class T = long long>\nstruct graph {\t// 0-indexed\n\tT const INF = numeric_limits<T>::max() / 3;\n\tvector<vector<edge<T>>> edges;\n\tbool directed, weight;\n\tint ver;\n\n\t// constructor\n\tgraph(int vertex, bool direction = 0, bool weigh = 0) : edges(vertex) {\n\t\tver = vertex;\n\t\tdirected = direction;\n\t\tweight = weigh;\n\t\tedges.resize(vertex);\n\t}\n\n\t//辺の追加 (0-indexed)\n\tvoid update(int from, int to, T len = 1, bool direction = 1) {\n\t\tedge<T> e;\n\t\te.len = len;\n\t\te.from = from;\n\t\te.to = to;\n\t\tedges[from].push_back(e);\n\t\tif(!direction) {\n\t\t\tswap(e.to, e.from);\n\t\t\tedges[to].push_back(e);\n\t\t}\n\t}\n\n\t//入力受取 (1-indexed)\n\tvoid input(int edge_num, int index = 1) {\n\t\tfor(int i = 0; i < edge_num; i++) {\n\t\t\tint a;\n\t\t\tint b;\n\t\t\tcin >> a >> b;\n\t\t\ta -= index;\n\t\t\tb -= index;\n\t\t\tT c;\n\t\t\tif(weight)\n\t\t\t\tcin >> c;\n\t\t\telse\n\t\t\t\tc = 1;\n\t\t\tupdate(a, b, c, directed);\n\t\t}\n\t}\n\n\t// 辺の長さを全て1とみたときの単一始点最短経路 (無理なときはINF)\n\tvector<T> bfs(int start) {\n\t\t// https://atcoder.jp/contests/abc007/submissions/me\n\t\tvector<T> ret(ver, INF);\n\t\tqueue<int> q;\n\t\tq.push(start);\n\t\tret[start] = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to] != INF) continue;\n\t\t\t\tq.push(e.to);\n\t\t\t\tret[e.to] = ret[now] + 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//長さが負のpathがないときの単一始点最短経路<vll> O((ver)log(ver)+(edge))\n\tvector<T> dijkstra(int start) {\n\t\tvector<T> ret(ver, (T)INF);\n\t\t// pqup<pair<T, int>> p;\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //{dist,place}\n\t\tpriority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> p;  //{dist,place}\n\t\tp.push({0, start});\n\t\tret[start] = 0;\n\n\t\twhile(!p.empty()) {\n\t\t\tT dist = p.top().first;\n\t\t\tint place = p.top().second;\n\t\t\tp.pop();\n\t\t\tif(ret[place] < dist) continue;\n\t\t\tfor(auto &next : edges[place]) {\n\t\t\t\tint nextplace = next.to;\n\t\t\t\tT dis = next.len;\n\t\t\t\tif(chmin(ret[nextplace], dist + dis)) {\n\t\t\t\t\tp.push({ret[nextplace], nextplace});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//単一始点最短経路 O((ver)*(edge))\n\t//辿り着けないとき ret[i] = INF;\n\t//ある頂点までのコストが無限に小さくなり得るとき→ ret[i] = -INF;\n\tvector<T> BellmanFord(int start) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/problems/GRL_1_B\n\t\tvector<T> ret(ver, INF);\n\t\tret[start] = 0;\n\t\tfor(int loop = 0; loop < ver - 1; loop++) {\n\t\t\tfor(int v = 0; v < ver; v++) {\n\t\t\t\tif(ret[v] == INF) continue;\n\t\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\t\tchmin(ret[e.to], ret[v] + e.len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//無限降下点の検索\n\t\tqueue<int> q;\n\t\tvector<bool> chk(ver, 0);\n\t\tfor(int v = 0; v < ver; v++) {\n\t\t\tif(ret[v] == INF) continue;\n\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\tif(chmin(ret[e.to], ret[v] + e.len)) {\n\t\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < ver; i++)\n\t\t\tif(chk[i]) ret[i] = -INF;\n\n\t\treturn ret;\n\t}\n\n\t//閉路に含まれない頂点列挙\n\t//要素数がver未満なら閉路が存在、そうでなければ閉路は存在しない\n\tvector<int> topo_sort() {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_4_A\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_4_B\n\t\tassert(directed);\n\t\tvector<int> num_input(ver);\n\t\t// 入次数\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tfor(auto e : edges[i]) {\n\t\t\t\tnum_input[e.to]++;\n\t\t\t}\n\t\t}\n\t\t// 入次数が0のノードをqueueで管理する\n\t\tqueue<int> que;\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tif(num_input[i] == 0) {\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t\tvector<int> ans;\n\t\twhile(!que.empty()) {\n\t\t\tauto node = que.front();\n\t\t\tque.pop();\n\t\t\tans.push_back(node);\n\t\t\t// 頂点の削除\n\t\t\tfor(auto e : edges[node]) {\n\t\t\t\tnum_input[e.to]--;\n\t\t\t\t// 行き先の入次数が0になったらqueueに追加\n\t\t\t\tif(num_input[e.to] == 0) {\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//{{端点、端点},直径の大きさ}\n\tpair<pair<int, int>, T> DiameterOfTree(bool weigh = true) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_A\n\t\tvector<T> vec;\n\t\tvec = weigh ? dijkstra(0) : bfs(0);\n\t\tint v1 = -1;\n\t\tT dia = -1;\n\t\tfor(int i = 0; i < ver; i++)\n\t\t\tif(chmax(dia, vec[i])) v1 = i;\n\n\t\tvec = weigh ? dijkstra(v1) : bfs(v1);\n\t\tdia = -1;\n\t\tint v2 = -1;\n\t\tfor(int i = 0; i < ver; i++)\n\t\t\tif(chmax(dia, vec[i])) v2 = i;\n\n\t\tpair<pair<int, int>, T> ans = {{v1, v2}, dia};\n\t\treturn ans;\n\t}\n\n\t//無向木構造を根から葉に伸びる有向木構造に書き換える\n\tgraph<T> RootToLeaf(int root) {\t // 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvector<bool> chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(now, e.to, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\t//無向木構造を葉から根に伸びる有向木構造に書き換える\n\tgraph<T> LeafToRoot(int root) {\t // 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvector<bool> chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(e.to, now, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\tret.update(root, root, 0);\n\t\treturn ret;\n\t}\n\n\t// LeafToRootのvector版.par[i]=iの親の頂点\n\tvector<int> par(int root) {\t // 0-indexed\n\t\tvector<int> ret(ver, -1);\n\t\tret[root] = root;  // rootの親はroot\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to] != -1) continue;\n\t\t\t\tret[e.to] = now;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\tvector<edge<T>> ParentAndDistance(int root) {  // 0-indexed\n\t\tvector<edge<T>> ret(ver);\n\t\tfor(int i = 0; i < ver; i++) ret[i].to = -1;\n\t\tret[root].to = root;  // rootの親はroot\n\t\tret[root].len = 0;\t  // rootの親との距離は0\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to].to != -1) continue;\n\t\t\t\tret[e.to].to = now;\n\t\t\t\tret[e.to].len = e.len;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\t//隣接sheet.主にwarshall用\n\tvector<vector<T>> GraphArray(void) {\n\t\tvector<vector<T>> ret(ver, vector<T>(ver, INF));\n\t\tfor(int from = 0; from < ver; from++) {\n\t\t\tfor(auto &e : edges[from]) {\n\t\t\t\tret[from][e.to] = e.len;\n\t\t\t}\n\t\t\tret[from][from] = 0;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tgraph<T> Prim(int start = 0) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_2_A\n\t\tgraph<T> ret(ver, 0, 1);\n\t\tpriority_queue<edge<T>, vector<edge<T>>, greater<edge<T>>> p;\n\t\tfor(auto &e : edges[start]) {\n\t\t\tp.push(e);\n\t\t}\n\t\tvector<bool> chk(ver, 0);\n\t\tchk[start] = 1;\n\t\twhile(!p.empty()) {\n\t\t\tauto ed = p.top();\n\t\t\tp.pop();\n\t\t\tif(chk[ed.to]) continue;\n\t\t\tchk[ed.to] = 1;\n\t\t\tret.update(ed.from, ed.to, ed.len);\n\t\t\tfor(auto &e : edges[ed.to]) {\n\t\t\t\tp.push(e);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//各頂点を根としたときの木の高さ\n\tvector<T> height(int start = 0) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_B\n\t\tvector<T> fir(ver, -1), sec(ver, -1);\n\t\tfunction<T(int, int)> dfs = [&](int now, int par) {\n\t\t\tT f = 0, s = 0;\t // startを根としたときのnowからの深さ1番目、2番目\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(e.to == par) continue;\n\t\t\t\tchmax(s, dfs(e.to, now) + e.len);\n\t\t\t\tif(f < s) swap(f, s);\n\t\t\t}\n\t\t\tsec[now] = s;\n\t\t\treturn fir[now] = f;\n\t\t};\n\t\tdfs(start, -1);\n\t\tfunction<void(int, int, T, T, T)> sol = [&](int now, int par, T parf, T pars, T parlen) {\n\t\t\tif(fir[now] + parlen == parf) parf = pars;\n\t\t\tchmax(sec[now], parf + parlen);\n\t\t\tif(fir[now] < sec[now]) swap(fir[now], sec[now]);\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(e.to == par) continue;\n\t\t\t\tsol(e.to, now, fir[now], sec[now], e.len);\n\t\t\t}\n\t\t\treturn;\n\t\t};\n\t\tsol(start, -1, -1, -1, -1);\n\t\treturn fir;\n\t}\n\n\t// lowest common ancestor\n\t// max-flow -> 別ファイル\n\t// 強連結成分分解\n\t// HL分解\n};\n\nstruct LCA {\n\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_C\n\tint ver;\n\tint h;\t//最大ダブリング回数\n\tint rt;\n\tvector<int> par;\n\tvector<vector<int>> anc;\n\tvector<int> depth;\n\n\tLCA(int _ver, vector<int> _par) : ver(_ver), par(_par), depth(_ver, -1) {\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tif(i == par[i]) rt = i;\n\t\t}\n\t\tanc.push_back(_par);\n\t\tvector<int> nxt(_ver);\n\t\tbool f = 1;\n\t\tint i = 0;\n\t\twhile(f) {\n\t\t\tf = 0;\n\t\t\tfor(int j = 0; j < _ver; j++) {\n\t\t\t\tif((nxt[j] = anc[i][anc[i][j]]) != rt) {\n\t\t\t\t\tf = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tanc.push_back(nxt);\n\t\t\ti++;\n\t\t}\n\t\th = (int)anc.size();\n\t}\n\n\tint dep(int now) {\n\t\tif(depth[now] != -1) return depth[now];\n\t\tif(now == rt) return depth[rt] = 0;\n\t\treturn depth[now] = dep(par[now]) + 1;\n\t}\n\n\tint Lowest_Common_Ancestor(int x, int y) {\n\t\tint dx = dep(x), dy = dep(y);\n\t\t// 深さを揃える\n\t\tif(dx < dy) {\n\t\t\tint diff = dy - dx;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tif(diff & (1 << i)) {\n\t\t\t\t\ty = anc[i][y];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint diff = dx - dy;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tif(diff & (1 << i)) {\n\t\t\t\t\tx = anc[i][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x == y) return x;\n\t\tfor(int i = h - 1; i > -1; i--) {\n\t\t\tif(anc[i][x] != anc[i][y]) {\n\t\t\t\tx = anc[i][x];\n\t\t\t\ty = anc[i][y];\n\t\t\t}\n\t\t}\n\t\treturn par[x];\n\t}\n\n\tint distance(int x, int y) { return dep(x) + dep(y) - 2 * dep(Lowest_Common_Ancestor(x, y)); }\n};\n\ntemplate <class T>\t// WarshallFloyd\nvoid warshall(vector<vector<T>> &v, T dekai = numeric_limits<T>::max()) {\n\tint n = v.size();\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\tif(v[j][i] == dekai || v[i][k] == dekai) continue;\n\t\t\t\tv[j][k] = min(v[j][k], v[j][i] + v[i][k]);\n\t\t\t}\n\treturn;\n}\n\n#pragma region macros_and_aliases\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define foa(s, v) for(auto &s : v)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pq priority_queue\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vb = vector<bool>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing qll = queue<long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n#define debug(var)              \\\n\tstd::cout << #var << \" : \"; \\\n\tview(var)\ntemplate <typename T>\nvoid view(T e) {\n\tstd::cout << e << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<T> &v) {\n\tfor(const auto &e : v) {\n\t\tstd::cout << e << \" \";\n\t}\n\tstd::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv) {\n\tfor(const auto &v : vv) {\n\t\tview(v);\n\t}\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\n#pragma endregion\n#pragma region constants\n\nlong long const limLL = 9223372036854775807;  // POW(2,63)-1 ~ 9.22e18\nlong long const dekai = 3e16;\nconst long double pi = acos(-1);\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ddx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint ddy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\n#pragma endregion\n#pragma region precedures\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n#pragma endregion\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint n, q;\n\tcin >> n;\n\tvector<int> par(n);\n\tpar[0] = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tpar[c] = i;\n\t\t}\n\t}\n\n\tLCA l(n, par);\n\tcin >> q;\n\tvector<int> ans(q);\n\tfor(int i = 0; i < q; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tans[i] = l.Lowest_Common_Ancestor(u, v);\n\t}\n\tfor(int i = 0; i < q; i++) {\n\t\tcout << ans[i] << \"\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<climits>\n#include<algorithm>\n\nconst int INF = INT_MAX;\nconst int NIL = -1;\n\nunsigned long long int leftMostBit(unsigned long long int x) {\n    if(x == 0) return 0;\n    x = (x & 0x55555555) << 1 | (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) << 2 | (x >> 2) & 0x33333333;\n    x = (x & 0x0f0f0f0f) << 4 | (x >> 4) & 0x0f0f0f0f;\n    x = (x << 24) | ((x & 0xff00) << 8) | ((x >> 8) & 0xff00) | (x >> 24);\n    unsigned long long int deBruijnSequence[32] = {0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14};\n    return 31 - deBruijnSequence[((x & -x) * 0x076be629U) >> 27];\n}\n\nclass RangeMinimumQuery {\npublic:\n    RangeMinimumQuery(int s) {\n        size_ = 1 << leftMostBit(s);\n        if(size_ != s) size_ <<= 1;\n        node_ = std::vector<int>((size_ << 1) - 1, INF);\n    }\n    int find(int left, int right) const {\n        return query(left, right, 0, 0, size_ - 1);\n    }\n    int find_index(int left, int right) const {\n        return query_index(left, right, 0, 0, size_ - 1);\n    }\n    void update(int index, int value) {\n        int i = index + size_ - 1;\n        node_[i] = value;\n        while((i = parent(i)) != NIL) node_[i] = std::min(node_[left_child(i)], node_[right_child(i)]);\n    }\n\nprivate:\n    int parent(int node) const {return node == 0 ? NIL : (node - 1) >> 1;}\n    int left_child(int node) const {return (node << 1) + 1;}\n    int right_child(int node) const {return (node << 1) + 2;}\n    int query(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return std::min(vl, vr);\n    }\n    int query_index(int a, int b, int k, int l, int r) const {\n        if(b < l || r < a) return INF;\n        if(a <= l && r <= b) return node_[k];\n        int vl = query_index(a, b, left_child(k), l, (l + r) / 2);\n        int vr = query_index(a, b, right_child(k), (l + r) / 2 + 1, r);\n        return node_[vl] < node_[vr] ? left_child(k) : right_child(k);\n    }\n\n    int size_;\n    std::vector<int> node_;\n};\n\n\n// 根付き木\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n    int size() const {return node_.size();}\n    int lowest_common_ancestor(int u, int v) const {\n        RangeMinimumQuery rmq(size());\n        for(int i = 0; i < size(); ++i) rmq.update(i, depth(i));\n        return rmq.find_index(std::min(u, v), std::max(u, v)) - 1;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n\n\n/*\n// LCA: O(n)\n#include<vector>\n#include<algorithm>\n\nclass RootedTree {\npublic:\n    RootedTree(const int n) :node_(n) {}\n    void add(const int v, const int c) {\n        node_[v].child.push_back(c);\n        node_[c].parent = v;\n        node_[c].depth = node_[v].depth + 1;\n    }\n//     int lowest_common_ancestor(int u, int v) const {\n//         while(depth(u) > depth(v)) u = parent(u);\n//         while(depth(u) < depth(v)) v = parent(v);\n//         while(u != v) {\n//             u = parent(u);\n//             v = parent(v);\n//         }\n//         return u;\n//     }\n    int lowest_common_ancestor(int u, int v) const {\n        while(u != v) {\n            if(depth(u) < depth(v)) v = parent(u);\n            else                    u = parent(v);\n        }\n        return u;\n    }\nprivate:\n    static const int NIL = -1;\n    struct Node {\n        int parent;\n        int depth;\n        std::vector<int> child;\n        Node() :parent(NIL), depth(1), child(0) {}\n    };\n    int depth(const int v) const {return v != NIL ? node_[v].depth : 0;}\n    int parent(const int v) const {return v != NIL ? node_[v].parent : NIL;}\n    std::vector<Node> node_;\n};\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    RootedTree t(n);\n\n    for(int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for(int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            t.add(i, c);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cout << t.lowest_common_ancestor(u, v) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n#include<cstdlib>\n#include <utility>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\nconst int nCk_MAX = 510000;//nCkの前計算で使うかもしれない 普段は入ってないよ\nconst int MIN_FLOW_MAX_V = 10000;\n\nstruct all_init {\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin,cout高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcout.tie(nullptr);\n\t\tcin.tie(nullptr);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//コンストラクタによって簡単に値を入れられるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\n\tint from, to;\n\tll cost;\n\tll capa;\n\n\tedge(int s, int d) : from(s), to(d) { cost = 0; capa = 0; }\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) { capa = 0; }\n\tedge(int s, int d, ll x, ll y) :from(s), to(d), cost(x), capa(y) {}\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n#define ALL(vec_etc) vec_etc.begin(),vec_etc.end()\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最小値が入る\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& Vec) {\n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>\nvoid resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head);\n\tfor (auto& v : vec) { resize(v, tail...); }\n}\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll PowMod(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll Gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? Gcd(b, a % b) : a;\n}\nll Lcm(ll a, ll b) {//最小公倍数\n\treturn a / Gcd(a, b) * b;\n}\nbool isPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nll MergeCount(vector<int> &a) {\n\t//反転数を数える\n\tll count = 0;\n\tint n = a.size();\n\tif (n > 1) {\n\t\tvector<int> b(a.begin(), a.begin() + n / 2);\n\t\tvector<int> c(a.begin() + n / 2, a.end());\n\t\tcount += MergeCount(b);\n\t\tcount += MergeCount(c);\n\t\tfor (int i = 0, j = 0, k = 0; i < n; ++i)\n\t\t\tif (k == c.size())       a[i] = b[j++];\n\t\t\telse if (j == b.size())  a[i] = c[k++];\n\t\t\telse if (b[j] <= c[k])   a[i] = b[j++];\n\t\t\telse { a[i] = c[k++]; count += n / 2 - j; }\n\t}\n\treturn count;\n}\nbool  WarshallFloyd(vector<vector<ll>> &c, int V) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\nvector<ll> Dijkstra(int i, vector<vector<edge>> graph) {\n\t//i:始点\n\t//graph:重み付きグラフ\n\tint n = graph.size();\n\tvector<ll> d(n, LONGINF);\n\td[i] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\n\tq.push(make_pair(0, i));//第一引数:コスト 第二引数:頂点\n\twhile (!q.empty()) {\n\t\tpair<ll, int> p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto x : graph[v]) {\n\t\t\tif (d[x.to] > d[v] + x.cost) {\n\t\t\t\td[x.to] = d[v] + x.cost;\n\t\t\t\tq.push(make_pair(d[x.to], x.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nbool BellmanFord(int start, int E, int V, vector<edge> Edge, vector<ll> &d) {\n\t//第一引数:start 始点\n\t//第二引数:E 辺の数\n\t//第三引数:V 頂点数\n\t//第四引数:Edge 辺の重み付きのグラフ\n\t//第五引数:d 各頂点への距離を入れる配列(答えが入る)\n\tfill(d.begin(), d.end(), LONGINF);\n\td[start] = 0;\n\tvector<bool> t(V, false);\n\t/*\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tt[e.to] = true;\n\t\t\t\tif (i == V - 1) {//どこかに閉路があることを感知する\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[e.from]) {\n\t\t\t\tt[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tif (t[V - 1]) {\n\t//V-1は頂点番号n-1で、始点からn-1までに負の閉路を検出したい場合には、\n\t//コメントアウトを解除すること。\n\t\treturn false;\n\t}\n\t*/\n\treturn true;\n}\nbool TopologicalSort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> ArticulationNode(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//与えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\nedge tree_diameter(const vector<vector<edge>> &g) {\n\t//重み付きグラフ(木)を受け取り、その木の直径を求める\n\t//返り値はfrom,to,costを持った構造体\n\n\tint start = 0;//どの始点から始めても良いので、0から始める\n\n\tstatic const auto bfs = [](const vector<vector<edge>> &g, int s, queue<int> &q, vector<ll> &dist) {\n\t\twhile (!q.empty()) { q.pop(); }\n\t\tq.push(s);\n\t\tint n = g.size();\n\t\tdist.assign(n, LONGINF);\n\t\tdist[s] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto &e : g[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] == LONGINF) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tvector<ll> dist;\n\tqueue<int> q;\n\tbfs(g, start, q, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (u == -1 || dist[i] > dist[u])) u = i;\n\tbfs(g, u, q, dist);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (v == -1 || dist[i] > dist[v])) v = i;\n\tll d = dist[v];\n\tif (u > v) swap(u, v);//念のため辞書順\n\treturn edge(u, v, d);\n}\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\nclass Dinic {\n\t//最大流を求める\nprivate:\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<ll>> cap, flow;\n\tvector<vector<int>> g;\n\tll inf;\npublic:\n\tDinic(const vector<vector<edge>> &graph) :\n\t\tn(graph.size()),\n\t\tcap(n, vector<ll>(n)),//\n\t\tflow(n, vector<ll>(n)),\n\t\tg(n, vector<int>()),\n\t\tinf(LONGINF) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.from, v = e.to;\n\t\t\t\tll c = e.capa;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline ll residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tll solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tll res = 0;\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v])\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tll augment(int v, ll lim) {\n\t\tll res = 0;\n\t\tif (v == t) return lim;\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst ll aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\nclass MinimumCostFlow {\nprivate:\n\n\tusing Flow = ll;\n\tusing Cost = ll;\n\tstruct Edge {\n\t\tint d;\n\t\tFlow c, f;\n\t\tCost w;\n\t\tint r, is_r;\n\t\tEdge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n\t\t\t: d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\npublic:\n\n\tMinimumCostFlow(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n\n\tvoid add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n\t\tint rsrc = g[dst].size();\n\t\tint rdst = g[src].size();\n\t\tg[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n\t\tg[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n\t}\n\n\tCost solve(int s, int t, Flow f) {\n\t\tCost res = 0;\n\n\t\tvector<Cost> h(n + 10), dist(n);\n\t\tvector<int> prevv(n + 10), preve(n + 10);\n\n\t\tusing pcv = pair<Cost, int>;\n\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LONGINF);\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(0, s);\n\t\t\twhile (q.size()) {\n\t\t\t\tCost cd;\n\t\t\t\tint v;\n\t\t\t\ttie(cd, v) = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tif (dist[v] < cd) continue;\n\t\t\t\tfor (int i = 0; i < (int)(g[v].size()); ++i) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif (residue(e) == 0) continue;\n\t\t\t\t\tif (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n\t\t\t\t\t\tdist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n\t\t\t\t\t\tprevv[e.d] = v;\n\t\t\t\t\t\tpreve[e.d] = i;\n\t\t\t\t\t\tq.emplace(dist[e.d], e.d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist[t] == LONGINF) return -1;  // 経路が見つからなかった\n\n\t\t\t// s-t 間を最短路に沿って目一杯流す\n\t\t\tfor (int i = 0; i < n; ++i) h[i] += dist[i];\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tchmin(d, residue(g[prevv[v]][preve[v]]));\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.f += d;\n\t\t\t\tg[v][e.r].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tFlow residue(const Edge &e) { return e.c - e.f; }\n\n\t// 流量を表示\n\tvoid show() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < (int)(g[i].size()); ++j) {\n\t\t\t\tEdge &e = g[i][j];\n\t\t\t\tif (e.is_r) continue;\n\t\t\t\tcout << i << \"->\" << e.d << \"(flow:\" << e.f << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\nclass BipartiteMatching {\nprivate:\n\tint V;\n\tvector<int> match;\n\tvector<bool> used;\n\tvector<vector<int>> g;\n\tvector<pair<int, int>> match_pair;\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tint w = match[u];\n\t\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch_pair.emplace_back(make_pair(u, v));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\npublic:\n\tBipartiteMatching(int n) {\n\t\tV = n;\n\t\tresize(match, n);\n\t\tresize(used, n);\n\t\tresize(g, n);\n\t}\n\n\tvoid add_edge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\n\tint MatchingSolve() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\t\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<pair<int,int>> get_pair() {\n\t\tfor (auto x : match_pair) {\n\t\t\tcout << x.first << \"  \" << x.second << endl;\n\t\t}\n\t\treturn match_pair;\n\t}\n\n};\n\nclass Lca {\nprivate:\n\tint n;\n\tint log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\n\tvoid dfs(const vector<vector<edge>> &g, int v,int p,int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (e.to != p) { dfs(g, e.to, v, d + 1); }\n\t\t}\n\t}\n\npublic:\n\tLca(const vector<vector<edge>> &g, int root) {\n\t\tn = g.size();\n\t\tlog2_n = (int)log2(n) + 1;\n\t\tresize(parent, log2_n, n);\n\t\tresize(depth, n);\n\t\t\n\t\tdfs(g, root, -1, 0);\n\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0) {\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) { swap(u, v); }//u≦v\n\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) { return u; }\n\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nint main() {\n\tint n; cin >> n;\n\tvector<vector<edge>> g(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x; cin >> x;\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tint c; cin >> c;\n\t\t\tg[i].emplace_back(i,c);\n\t\t}\n\t}\n\n\tLca l(g, 0);\n\tint q; cin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tcout << l.get(u, v) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct LinkCutTree {\n  vector<int>left,right,parent;\n\n  LinkCutTree(int n):left(n,-1),right(n,-1),parent(n,-1){}\n\n  bool is_root(int id){\n    return parent[id]<0 || (left[parent[id]]!=id && right[parent[id]]!=id);\n  }\n\n  void connect(int ch, int p, bool isL){\n    (isL ? left : right)[p] = ch;\n    if(ch >= 0)parent[ch] = p;\n  }\n\n  void rotate(int id){\n    int p = parent[id], q = parent[p];\n    bool isL = id==left[p], isRoot = is_root(p);\n\n    connect((isL ? right : left)[id], p, isL);\n    connect(p, id, !isL);\n\n    if(!isRoot)connect(id,q,p==left[q]);\n    else parent[id]=q;\n  }\n\n  void splay(int id){\n    while(!is_root(id)){\n      int p = parent[id];\n      if(!is_root(p))rotate( (id==left[p])^(p==left[parent[p]]) ? p : id );\n      rotate(id);\n    }\n  }\n\n  int expose(int id){\n    int last = -1;\n    for(int y=id; y>=0; y=parent[y])\n      splay(y), left[y]=last, last=y;\n    splay(id);\n    return last;\n  }\n\n  int find_root(int id){\n    expose(id);\n    while(right[id]!=-1)id=right[id];\n    return id;\n  }\n\n  void link(int ch, int p){\n    expose(ch);\n    if(right[ch]>=0)return;\n    parent[ch]=p;\n  }\n\n  void cut(int id){\n    expose(id);\n    if(right[id]<0)return;\n    parent[right[id]]=-1;\n    right[id]=-1;\n  }\n\n  int lca(int ch, int p){\n    if(find_root(ch)!=find_root(p))return -1;\n    expose(ch);\n    return expose(p);\n  }\n};\n\nint main(void){\n  int n;\n  cin >> n;\n\n  LinkCutTree tree(n);\n  \n  for(int i=0;i<n;i++){\n    int k,t;\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> t;\n      tree.link(t,i);\n    }\n  }\n  int q;\n  cin >> q;\n  for(int i=0;i<q;i++){\n    int u,v;\n    cin >> u >> v;\n    cout << tree.lca(u,v) << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define si(i) scanf(\"%d\", &i)\n#define sll(i) scanf(\"%lld\", &i)\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define nl '\\n'\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair< int, int > pii;\n\nint n, l[100005];\nint f[100005][17];\n\nint main(){\n    si(n);\n    int nn = ceil( log2(n) );\n    memset( f[0], -1, sizeof f[0]);\n    for( int i = 0 ; i < n ; i++ ){\n        int k; si(k);\n        for( int j = 0 ; j < k ; j++ ){\n            int c; si(c);\n            f[0][c] = i;\n            l[c] = l[i] + 1;\n        }\n    }\n    for( int i = 1 ; i <= nn ; i++ ){\n        for( int j = 0 ; j < n ; j++ ){\n            int x = f[i - 1][j];\n            if( x == -1 ){\n                f[i][j] = -1;\n                continue;\n            }\n            int y = f[i - 1][x];\n            f[i][j] = y;\n        }\n    }\n    int _q; si(_q);\n    while( _q-- ){\n        int u, v;\n        si(u); si(v);\n        if( l[u] < l[v] ) swap( u, v );\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( ( 1 << i ) <= l[u] - l[v] ){\n                u = f[i][u];\n            }\n        }\n        if( u == v ){\n            cout << u << nl;\n            continue;\n        }\n        for( int i = nn ; i >= 0 ; i-- ){\n            if( f[i][u] == f[i][u] ) continue;\n            u = f[i][u];\n            v = f[i][v];\n        }\n        cout << f[0][u] << nl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nclass LCA {\nprivate:\n\tconst std::vector<std::vector<int>>& graph; // graph's list expression\n\tint root;\n\tint n; // the number of nodes\n\tint log2n; // = floor(log2(n))\n\tstd::vector<std::vector<int>> parent; // parent[x][v] = a parent(above 2^x) of v (nonexistence -> -1)\n\tstd::vector<int> depth; // the depth of each node\n\npublic:\n\tLCA(const std::vector<std::vector<int>>& graph, int root) :\n\t\tgraph(graph), root(root), n(graph.size()), \n\t\tlog2n(std::floor(std::log2(n) + 1)),\n\t\tparent(log2n, std::vector<int>(n, 0)), depth(n, 0)\n\t{\n\t\tinit();\n\t}\n\n\t// Check the depth of each node(node \"v\" -> parent is \"p\", depth is \"d\")\n\tvoid dfs(int v, int p, int d) {\n\t\tstd::stack<int> stack;\n\t\tstack.push(v);\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\twhile (!stack.empty()) {\n\t\t\tint now = stack.top(); stack.pop();\n\t\t\tfor (int i = 0; i < graph[now].size(); ++i) {\n\t\t\t\tint to = graph[now][i];\n\t\t\t\tif (to == parent[0][now]) continue;\n\t\t\t\tparent[0][to] = now;\n\t\t\t\tdepth[to] = depth[now] + 1;\n\t\t\t\tstack.push(to); // Check each child of v\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initialize\n\tvoid init() {\n\t\t// Initialize \"parent[0]\" and \"depth\"\n\t\tdfs(root, -1, 0);\n\n\t\t// Initialize \"parent\"\n\t\tfor (int k = 0; k < log2n - 1; ++k) {\n\t\t\tfor (int v = 0; v < n; ++v) {\n\t\t\t\tif (parent[k][v] < 0) { // If parent above 2^k of v is nonexistence\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find LCA of (u, v)\n\tint lca(int u, int v) {\n\t\t// go up parent while depth of u and v is same\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2n; ++k) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v]; // go up to 2^k if k-th binary is 1\n\t\t\t}\n\t\t}\n\n\t\tif (u == v) return u; // this case is that v is in u's subtree\n\n\t\t// Find LCA by binary searching\n\t\tfor (int k = log2n - 1; k >= 0; --k) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n) {\n\t\tVAR(int, k);\n\t\tVEC(int, c, k);\n\t\tREP(j, k) {\n\t\t\tg[i].emplace_back(c[j]);\n\t\t}\n\t}\n\tLCA lca(g, 0);\n\tVAR(int, Q);\n\tREP(q, Q) {\n\t\tVAR(int, u, v);\n\t\tOUT(lca.lca(u, v))BR;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <vector>\n#include <algorithm>        // swap()\n\nusing namespace std;\nstatic const int MAX_V = 100000;\nstatic const int MAX_LOG_V = 17; // ceil(log(MAX_V))\n\nvector<int> G[MAX_V];\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid\ndfs(int v, int p, int d)\n{\n\tparent[0][v] = p;\n\tdepth[v] = d;\n\tfor (unsigned int i = 0; i < G[v].size(); ++i)\n\t{\n\t\tif (G[v][i] != p)\n\t\t\tdfs(G[v][i], v, d + 1);\n\t}\n}\n\nvoid\ninit_lca(int V)\n{\n\tdfs(0, -1, 0);\n\tfor (int k = 0; k + 1 < MAX_LOG_V; ++k)\n\t{\n\t\tfor (int v = 0; v < V; ++v)\n\t\t{\n\t\t\tif (parent[k][v] < 0)\n\t\t\t\tparent[k + 1][v] = -1;\n\t\t\telse\n\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t}\n\t}\n}\n\nint\nlca(int u, int v)\n{\n\tif (depth[u] > depth[v])\n\t\tswap(u, v);\n\n\tfor (int k = 0; k < MAX_LOG_V; ++k)\n\t{\n\t\tif (((depth[v] - depth[u]) >> k) & 1)\n\t\t\tv = parent[k][v];\n\t}\n\n\tif (u == v)\n\t\treturn u;\n\n\tfor (int k = MAX_LOG_V - 1; k >= 0; --k)\n\t{\n\t\tif (parent[k][u] != parent[k][v])\n\t\t{\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\n\treturn parent[0][u];\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint V;\n\tint q;\n\n\tscanf(\"%d\", &V);\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tint k;\n\t\tint c;\n\n\t\tscanf(\"%d\", &k);\n\t\tfor (int j = 0; j < k; ++j)\n\t\t{\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\n\tinit_lca(V);\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tint u, v;\n\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tprintf(\"%d\\n\", lca(u, v));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nvector<int> chi[100000];\nint fir[100000], dep = 0;\nvector< pair<int, int> > et; //Euler Tour\n\nint min(int a, int b) {\n  return a < b ? a : b;\n}\n\nvoid dfs(int a) {\n   int i;\n   if(fir[a] == -1) fir[a] = et.size();\n   et.push_back(make_pair(a, dep));\n   for(i = 0; i < chi[a].size(); ++i) {\n     dep++;\n     dfs(chi[a][i]);\n     dep--;\n     et.push_back(make_pair(a, dep));\n   }\n}\n\nint main(void) {\n  int i, j, k, n, c, now, q, u, v;\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; ++i) fir[i] = -1;\n  for(i = 0; i < n; ++i) {\n    scanf(\"%d\", &k);\n    for(j = 0; j < k; ++j) {\n       scanf(\"%d\", &c);\n       chi[i].push_back(c);\n    }\n  }\n  dfs(0);\n  int sm = 1;\n  while(sm < et.size()) sm *= 2;\n  pair<int, int> seg[sm * 2];\n  int las[sm * 2];\n  for(i = sm; i < sm * 2; ++i) {\n    if(i < sm + et.size()) seg[i].first = et[i - sm].second, seg[i].second = et[i - sm].first;\n    else seg[i] = make_pair(1000000, 1000000);\n    if(i % 2) {\n      now = i / 2;\n      while(now) seg[now] = min(seg[now * 2], seg[now * 2 + 1]), now /= 2;\n    }\n  }\n  now = 1;\n  for(i = 1; i < sm * 2; ++i) {\n    if(now * 2 == i) now *= 2;\n    las[i] = (sm / now) * (i - now + 1) - 1;\n  }\n  scanf(\"%d\", &q);\n  for(i = 0; i < q; ++i) {\n    int t;\n    scanf(\"%d%d\", &u, &v);\n    if(fir[u] > fir[v]) t = u, u = v, v = t;\n    now = sm + fir[u];\n    pair<int, int> min = make_pair(1000000, 1000000);\n    while( 1 ) {\n      while(!(now % 2)) now /= 2;\n      while(las[now] > fir[v]) now *= 2;\n      if(min > seg[now]) min = seg[now];\n      if(las[now] == fir[v]) break;\n      now++;\n    }\n    printf(\"%d\\n\", min.second);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// HL 分解\n// 頂点 v を根とする部分木: [ in[v], out[v] )\n// 頂点 v から見た heavy edge chain の頭: head[v]\nstruct HLD {\n    vector< vector<int> > G;\n    vector<int> sub, par, depth, in, out, rev, head;\n    \n    void dfs_sub(int cur) {\n        for(auto& to : G[cur]) {\n            if(par[cur] == to) continue;\n            par[to] = cur;\n            depth[to] = depth[cur] + 1;\n            dfs_sub(to);\n            sub[cur] += sub[to];\n            if(sub[to] > sub[ G[cur][0] ]) swap(to, G[cur][0]);\n        }\n    }\n    void dfs_hld(int cur, int& ptr) {\n        in[cur] = ptr; rev[ptr++] = cur;\n        for(auto to : G[cur]) {\n            if(par[cur] == to) continue;\n            head[to] = (to == G[cur][0] ? head[cur] : to);\n            dfs_hld(to, ptr);\n        }\n        out[cur] = ptr;\n    }\n\n    HLD(int N) : G(N), sub(N, 1), par(N, -1), depth(N),\n                 in(N), out(N), rev(N), head(N) {}\n    void add_edge(int u, int v) {\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    void build(int root=0) {\n        int ptr = 0; dfs_sub(root); dfs_hld(root, ptr);\n    }\n    int lca(int u, int v) {\n        while(1) {\n            if(in[u] > in[v]) swap(u, v);\n            if(head[u] == head[v]) return u;\n            v = par[head[v]];\n        }\n    }\n    int distance(int u, int v) {\n        return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n    }\n};\n\n\nvoid GRL_5_C() {\n    int N; cin >> N;\n    HLD hl(N);\n    for(int i=0; i<N; i++) {\n        int c; cin >> c;\n        for(int j=0; j<c; j++) {\n            int u = i, v; cin >> v;\n            hl.add_edge(u, v);\n        }\n    }\n    hl.build();\n\n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++) {\n        int u, v; cin >> u >> v;\n        cout << hl.lca(u, v) << endl;\n    }\n}\n\nint main() {\n    GRL_5_C(); // LCA\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct HLDecomposition {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, heavy, parent, depth, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),heavy(n,-1),parent(n),depth(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs=vector<int>(1,0)) {\n    int c=0;\n    for(int r:rs){\n      dfs(r, -1);\n      bfs(r, c++);\n    }\n  }\n  \n  using T = tuple<int,int,int,int,int,int>;\n  int dfs(int curr,int prev) {\n    stack<T> st;\n    int result;\n    int sub,max_sub,i,next;\n  ENTRYPOINT:\n    parent[curr] = prev;\n    sub=1;\n    max_sub=0;\n    for(i=0;i<(int)G[curr].size();i++){\n      next=G[curr][i];\n      if(next!=prev) {\n\tdepth[next]=depth[curr]+1;\n\t{\n\t  st.emplace(curr,prev,sub,max_sub,i,next);\n\t  prev=curr;curr=next;\n\t  goto ENTRYPOINT;\n\t}\n      RETURNPOINT:\n\tT t=st.top();st.pop();\n\ttie(curr,prev,sub,max_sub,i,next)=t;\n\t\n\tint sub_next=result;\n\tsub+=sub_next;\n\tif(max_sub<sub_next)\n\t  max_sub=sub_next,heavy[curr]=next;\n      }\n    }\n    while(!st.empty()){\n      result=sub;\n      goto RETURNPOINT;\n    }\n    return sub;\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=heavy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(int j:G[i])\n\t  if(j!=parent[i]&&j!=heavy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if (vid[u] > vid[v]) swap(u, v);\n      f(max(vid[head[v]], vid[u]), vid[v]);\n      if (head[u] != head[v]) v=parent[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(int u, int v, const function<void(int, int)>& f) {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] != head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=parent[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=parent[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return depth[u]+depth[v]-2*depth[lca(u,v)];\n  }\n};\n//END CUT HERE\n\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  HLDecomposition lca(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lca.add_edge(i,c);\n    }\n  }\n  lca.build();\n  int q;\n  cin>>q;\n  while(q--){\n    int u,v;\n    cin>>u>>v;\n    cout<<lca.lca(u,v)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/11/07\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\n*/\n\n/*\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n   void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n   void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n   bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nsigned main(){\n  int n,e,q;\n  scanf(\"%d %d %d\",&n,&e,&q);\n  \n  BiconectedGraph big(n);\n  big.input(e,-1);\n\n  int E=0,V=big.build();\n  HLDecomposition hl(V);\n  for(int i=0;i<V;i++)\n    for(int j:big.T[i])\n      if(i<j) hl.add_edge(i,j),E++;\n  \n  hl.build();\n  SegmentTree<int,int> rmq(V,\n\t\t\t   [](int a,int b){return max(a,b);},\n\t\t\t   [](int a,int b){return b;},\n\t\t\t   -1);\n  vector<priority_queue<int> > pq(V);\n  map<int,int> m;\n  int num=0;\n  for(int i=0;i<q;i++){\n    int d;\n    scanf(\"%d\",&d);\n    if(d==1){\n      int u,w;\n      scanf(\"%d %d\",&u,&w);\n      u--;\n      u=big.belong[u];\n      u=hl.vid[u];\n      m[w]=u;\n      if(pq[u].empty()||pq[u].top()<w) rmq.update(u,w);\n      pq[u].push(w);\n      num++;\n    }\n    if(d==2){\n      int s,t;\n      scanf(\"%d %d\",&s,&t);\n      s--;t--;\n      s=big.belong[s];\n      t=big.belong[t];\n      int ans=-1;\n      hl.for_each(s, t, [&](int l, int r) {\n\t  ans = max(ans,rmq.query(l, r + 1));\n\t});\n      printf(\"%d\\n\",ans);\n      if(~ans){\n\tint k=m[ans];\n\tpq[k].pop();\n\trmq.update(k,(!pq[k].empty()?pq[k].top():-1));\t\t \n\tnum--;\n      }\n    }\n  }\n  return 0;\n}\n\n/* verified on 2017/11/07\nhttps://yukicoder.me/problems/no/529\n*/"
  },
  {
    "language": "C++",
    "code": "// TODO: \n// https://www.geeksforgeeks.org/sqrt-square-root-decomposition-set-2-lca-tree-osqrth-time/\n#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100001\n\nint block_sz;          // block size = sqrt(height)\nint depth[MAXN];       // stores depth for each node.\nint parent[MAXN];      // stores first parent for each node.\nint jump_parent[MAXN]; // stores first ancestor in previous block.\nvector<int> adj[MAXN];\n\nvoid addEdge(int u, int v){\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\n\nint LCANaive(int u,int v){\n    if(u == v)              return u;\n    if(depth[u] > depth[v]) swap(u, v);\n    v = parent[v];\n    return LCANaive(u, v);\n}\n\n// precalculating the required parameters associated with every node.\nvoid dfs(int cur, int prev){\n    // marking depth of cur node\n    depth[cur] = depth[prev] + 1;\n    \n    // marking parent of cur node\n    parent[cur] = prev;\n    \n    // making jump_parent of cur node\n    // if it is first node of the block then its jump_parent is its cur parent.\n    if (depth[cur] % block_sz == 0) jump_parent[cur] = parent[cur];\n    // if it is not the first node of this block then its jump_parent is jump_parent of its parent.\n    else                            jump_parent[cur] = jump_parent[prev];\n    \n    // propogating the marking down the subtree\n    for(int i = 0; i < adj[cur].size(); ++i) if(adj[cur][i] != prev) dfs(adj[cur][i], cur);\n}\n\n// using sqrt decomposition trick\nint LCASQRT(int u, int v){\n    while(jump_parent[u] != jump_parent[v]){\n        // maintaining depth[v] > depth[u]\n        if(depth[u] > depth[v]) swap(u, v);\n        // climb to its jump parent\n        v = jump_parent[v];\n    }\n    // u and v have same jump_parent\n    return LCANaive(u, v);\n} \n\nvoid preprocess(int height){\n    block_sz = sqrt(height);\n    depth[0] = -1;\n    // precalclating 1) depth.  2) parent.  3) jump_parent for each node\n    dfs(0, 0);\n}\n\nint main(){\n    \n    // 1. 入力情報取得.\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0, s, t, w; i < N; ++i){\n        int k;\n        scanf(\"%d\", &k);\n        for(int j = 0; j < k; ++j){\n            int c;\n            scanf(\"%d\", &c);\n            addEdge(i, c);\n        }\n    }\n    \n    // 2. 事前処理.\n    preprocess(MAXN);\n    \n    // 3. 各判定クエリに対し, 出力を行う.\n    int Q;\n    scanf(\"%d\", &Q);\n    for(int i = 0; i < Q; i++){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        printf(\"%d\\n\", LCASQRT(u, v));\n    }\n    \n    // 4. 後処理.\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid DFS(const Graph& g,int p,int v,int d,vi& tour,vi& ds)\n{\n\ttour.push_back(v);\n\tds.push_back(d);\n\tfor(auto e:g[v]) if(e.dst!=p){\n\t\tDFS(g,e.src,e.dst,d+1,tour,ds);\n\t\ttour.push_back(v);\n\t\tds.push_back(d);\n\t}\n}\n\nint NextPow2(int x)\n{\n\tx--;\n\tfor(int i=1;i<32;i*=2) x|=x>>i;\n\treturn x+1;\n}\nconst int I=numeric_limits<int>::max();\nint F(int a,int b){return min(a,b);}\n\nstruct SegmentTree{\n\tint size;\n\tvi data,index;\n\tSegmentTree(int n):size(NextPow2(n)),data(size,I),index(size*2){\n\t\tiota(size+all(index),0);\n\t\tperi(i,1,size) index[i]=index[i*2];\n\t}\n\tSegmentTree(const vi& a):size(NextPow2(a.size())),data(size,I),index(size*2){\n\t\tcopy(all(a),begin(data));\n\t\tiota(size+all(index),0);\n\t\tperi(i,1,size){\n\t\t\tint u=index[i*2],v=index[i*2+1];\n\t\t\tindex[i]=data[u]==F(data[u],data[v])?u:v;\n\t\t}\n\t}\n\tvoid Update(int i,int x){\n\t\tdata[i]=x;\n\t\tfor(i+=size;i/=2;){\n\t\t\tint u=index[i*2],v=index[i*2+1];\n\t\t\tindex[i]=data[u]==F(data[u],data[v])?u:v;\n\t\t}\n\t}\n\tint QueryIndex(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return -1;\n\t\tif(a<=l && r<=b) return index[i];\n\t\tint u=QueryIndex(a,b,i*2,l,(l+r)/2),v=QueryIndex(a,b,i*2+1,(l+r)/2,r);\n\t\tif(u==-1 || v==-1) return u!=-1?u:v;\n\t\treturn data[u]==F(data[u],data[v])?u:v;\n\t}\n\tint QueryIndex(int a,int b){\n\t\treturn QueryIndex(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tGraph g(n);\n\t\trep(u,n){\n\t\t\tint k; cin>>k;\n\t\t\trep(i,k){\n\t\t\t\tint v; cin>>v;\n\t\t\t\tg[u].emplace_back(u,v);\n\t\t\t\tg[v].emplace_back(v,u);\n\t\t\t}\n\t\t}\n\t\tvi tour,ds;\n\t\tDFS(g,-1,0,0,tour,ds);\n\t\tvi fs(n,INF);\n\t\trep(i,tour.size()) if(fs[tour[i]]==INF) fs[tour[i]]=i;\n\t\t\n\t\tSegmentTree st(ds);\n\t\tint q; cin>>q;\n\t\trep(_,q){\n\t\t\tint u,v; cin>>u>>v;\n\t\t\tif(fs[u]>fs[v]) swap(u,v);\n\t\t\tcout<<tour[st.QueryIndex(fs[u],fs[v]+1)]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass heavy_light_decomposition {\n\tconst int n;\n\tvector<vector<int>> g;\n\tvector<int> in, out, size, head, par;\n\tint it;\n\tvoid erase_par(int v, int prev) {\n\t\tpar[v] = prev;\n\t\tfor (auto& u : g[v]) {\n\t\t\tif (u == g[v].back()) break;\n\t\t\tif (u == prev) swap(u, g[v].back());\n\t\t\terase_par(u, v);\n\t\t}\n\t\tg[v].pop_back();\n\t}\n\tvoid dfs1(int v) {\n\t\tfor (auto& u : g[v]) {\n\t\t\tdfs1(u);\n\t\t\tsize[v] += size[u];\n\t\t\tif (size[u] > size[g[v][0]]) swap(u, g[v][0]);\n\t\t}\n\t}\n\tvoid dfs2(int v) {\n\t\tin[v] = it++;\n\t\tfor (auto u : g[v]) {\n\t\t\thead[u] = (u == g[v][0] ? head[v] : u);\n\t\t\tdfs2(u);\n\t\t}\n\t\tout[v] = it;\n\t}\npublic:\n\theavy_light_decomposition(int n_)\n\t\t: n(n_), g(n), in(n, -1), out(n, -1), size(n, 1), head(n), par(n, -1), it(0) {}\n\theavy_light_decomposition(const vector<vector<int>>& G)\n\t\t: n(G.size()), g(G), in(n, -1), out(n, -1), size(n, 1), head(n), par(n, -1), it(0) {}\n\tvoid add_edge(int u, int v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvoid build(int rt = 0) {\n\t\tfor (auto v : g[rt]) erase_par(v, rt);\n\t\tdfs1(rt);\n\t\thead[rt] = rt;\n\t\tdfs2(rt);\n\t}\n\tint get_id(int v) {\n\t\treturn in[v];\n\t}\n\tint get_lca(int u, int v) {\n\t\twhile (true) {\n\t\t\tif (in[u] > in[v]) swap(u, v);\n\t\t\tif (head[u] == head[v]) return u;\n\t\t\tv = par[head[v]];\n\t\t}\n\t}\n\tvoid path_query(int u, int v, function<void(int, int)> f) {\n\t\twhile (true) {\n\t\t\tif (in[u] > in[v]) swap(u, v);\n\t\t\tf(max(in[head[v]], in[u]), in[v] + 1);\n\t\t\tif (head[u] == head[v]) return;\n\t\t\tv = par[head[v]];\n\t\t}\n\t}\n\tvoid path_query(int u, int v, function<void(int, int, bool)> f) {\n\t\twhile (true) {\n\t\t\tif (in[u] <= in[v]) {\n\t\t\t\tf(max(in[head[v]], in[u]), in[v] + 1, false);\n\t\t\t\tif (head[u] == head[v]) return;\n\t\t\t\tv = par[head[v]];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf(max(in[head[u]], in[v]), in[u] + 1, true);\n\t\t\t\tif (head[u] == head[v]) return;\n\t\t\t\tu = par[head[u]];\n\t\t\t}\n\t\t}\n\t}\n\tvoid edge_path_query(int u, int v, function<void(int, int)> f) {\n\t\twhile (true) {\n\t\t\tif (in[u] > in[v]) swap(u, v);\n\t\t\tif (head[u] != head[v]) {\n\t\t\t\tf(max(in[head[v]], in[u]), in[v] + 1);\n\t\t\t\tv = par[head[v]];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (u != v) f(in[u] + 1, in[v] + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvoid edge_path_query(int u, int v, function<void(int, int, bool)> f) {\n\t\twhile (true) {\n\t\t\tif (in[u] > in[v]) {\n\t\t\t\tif (head[u] != head[v]) {\n\t\t\t\t\tf(max(in[head[u]], in[v]), in[u] + 1, true);\n\t\t\t\t\tu = par[head[u]];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (u != v) f(in[v] + 1, in[u] + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (head[u] != head[v]) {\n\t\t\t\t\tf(max(in[head[v]], in[u]), in[v] + 1, false);\n\t\t\t\t\tv = par[head[v]];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (u != v) f(in[u] + 1, in[v] + 1, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid subtree_query(int v, function<void(int, int)> f) {\n\t\tf(in[v], out[v]);\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\tcin >> n;\n\theavy_light_decomposition hld(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\thld.add_edge(i, c);\n\t\t}\n\t}\n\thld.build();\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tprintf(\"%d\\n\", hld.get_lca(u, v));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n#include <random>\n#include <iterator>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\n\nstruct Hld {\n    vector<int> a, ia, par, head;\n\n    template<class G>\n    Hld(const G& g, int root) {\n        build(g, root);\n    }\n    \n    template<class G>\n    void build(const G& g, int root) {\n        int n = g.size();\n        vector<int> size(n);\n        dfs_size(g, size, root, -1);\n        ia.resize(n);\n        par.resize(n);\n        dfs_build(g, size, root, -1, 0);\n    }\n\n    template<class G>\n    void dfs_size(const G& g, vector<int>& size, int u, int p) {\n        size[u] = 1;\n        for (int v : g[u]) {\n            if (v == p) continue;\n            dfs_size(g, size, v, u);\n            size[u] += size[v];\n        }\n    }\n\n    template<class G>\n    void dfs_build(const G& g, const vector<int>& size, int u, int p, int h) {\n        ia[u] = a.size();\n        par[a.size()] = p == -1 ? -1 : ia[p];\n        a.push_back(u);\n        head.push_back(h);\n        int heavy_v = -1, max_size = 0;\n        for (int v : g[u]) {\n            if (size[v] > max_size) {\n                heavy_v = v;\n                max_size = size[v];\n            }\n        }\n        if (heavy_v != -1) dfs_build(g, size, heavy_v, u, h);\n        for (int v : g[u]) {\n            if (v == p || v == heavy_v) continue;\n            dfs_build(g, size, v, u, head.size());\n        }\n    }\n\n    int lca(int u, int v) {\n        u = ia[u];\n        v = ia[v];\n        while (true) {\n            if (u > v) swap(u, v);\n            if (head[u] == head[v]) return a[u];\n            v = par[head[v]];\n        }\n    }\n};\n\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; ++j) {\n            int c;\n            cin >> c;\n            g[i].push_back(c);\n        }\n    } \n    Hld hld(g, 0);\n\n    for (int u = 0; u < n; ++u) {\n        // cerr << u << \" g:\" << hld.a[u] << \" head:\" << hld.head[u] << \" par:\" << hld.par[u] << endl;\n    }\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << hld.lca(u, v) << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing lint = long long;\n\nstruct lca_t {\n    int logn{0}, preorderpos{0};\n    vector<int> invpreorder, height;\n    vector<vector<int>> jump_binary, edges;\n    lca_t(int n, vector<vector<int>>& adj) : \n    edges(adj), height(n), invpreorder(n) { \n        while((1<<(logn+1)) <= n) ++logn;\n        jump_binary.assign(n+1, vector<int>(logn+1, 0));\n        dfs(0, -1, 0);\n    } \n    void dfs(int v, int p, int h) { \n        invpreorder[v] = preorderpos++;\n        height[v] = h;\n        jump_binary[v][0] = p < 0 ? v : p;\n        for (int l = 1; l <= logn; ++l)\n            jump_binary[v][l] = jump_binary[jump_binary[v][l-1]][l-1];\n        for (int u : edges[v]) {\n            if (u == p) continue; \n            dfs(u, v, h + 1);\n        }\n    }\n    int climb(int v, int dist) { \n        for (int l = 0; l <= logn; ++l)\n            if (dist & (1 << l)) v = jump_binary[v][l];\n        return v;\n    }\n    int query(int a, int b) { \n        if (height[a] < height[b]) swap(a, b);\n        a = climb(a, height[a] - height[b]);\n        if (a == b) return a;\n        for (int l = logn; l >= 0; --l) \n            if (jump_binary[a][l] != jump_binary[b][l]) \n                a = jump_binary[a][l], b = jump_binary[b][l];\n        return jump_binary[a][0];\n    } \n    int dist(int a, int b) {\n        return height[a] + height[b] - 2 * height[query(a,b)];\n    }\n    bool is_parent(int p, int v) { \n        if (height[p] > height[v]) return false;\n        return p == climb(v, height[v] - height[p]);\n    }\n    bool on_path(int x, int a, int b) {\n        int v = query(a, b);\n        return is_parent(v, x) && (is_parent(x, a) || is_parent(x, b));\n    }\n    int get_kth_on_path(int a, int b, int k) {\n        int v = query(a, b);\n        int x = height[a] - height[v], y = height[b] - height[v];\n        if (k < x) return climb(a, k);\n        else return climb(b, x + y - k);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    int n;\n    cin >> n;\n    vector<vector<int>> edges(n);\n    for (int i = 0; i < n; ++i) {\n        int node;\n        cin >> node;\n        for (int j = 0; j < node; ++j) {\n            int v;\n            cin >> v;\n            edges[i].push_back(v);\n            edges[v].push_back(i);\n        }\n    }\n    lca_t lca(n, edges);\n    int q;\n    cin >> q;\n    while (q--) {\n        int u, v;\n        cin >> u >> v;\n        cout << lca.query(u, v) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\nconst int logn=18;\n\nint n,q,l,sec,st[maxn],ed[maxn];\nint up[maxn][logn];\nvector<int>G[maxn];\n\nvoid dfs(int u,int p) {\n\tst[u]=sec++;\n\tup[u][0]=p;\n\tfor (int i=1;i<=l;i++)\n\t\tup[u][i]=up[up[u][i-1]][i-1];\n\tfor (int v:G[u])\n\t\tif (v!=p) dfs(v,u);\n\ted[u]=sec;\n}\n\nbool upper(int u,int v) {\n\treturn st[u]<st[v] && ed[u]>=ed[v];\n}\n\nint lca(int u,int v) {\n\tif (u==v) return u;\n\tif (upper(u,v)) return u;\n\tif (upper(v,u)) return v;\n\tfor (int i=l;i>=0;i--) \n\t\tif (!upper(up[u][i],v))\n\t\t\tu=up[u][i];\n\treturn up[u][0];\n}\n\nint main() {\n\tcin>>n;\n\tfor (int i=0;i<n;i++) {\n\t\tint m; cin>>m;\n\t\tfor (int j=0;j<m;j++) {\n\t\t\tint v; cin>>v;\n\t\t\tG[i].pb(v);\n\t\t}\n\t}\n\twhile ((1<<l)<=n) l++;\n\tdfs(0,0);\n\tcin>>q;\n\tfor (int i=0;i<q;i++) {\n\t\tint u,v; cin>>u>>v;\n\t\tcout<<lca(u,v)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n// #define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 30;\nvector<int> G[MAX_V];\nint root;\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    dfs(root, -1, 0);\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u]) >> k & 1){\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];    \n}\n\nsigned main(){\n    int n;\n    root = 0;\n    cin >> n;\n    rep(i, 0, n){\n        int k;\n        cin >> k;\n        rep(j, 0, k){\n            int c;\n            cin >> c;\n            G[i]. push_back(c);\n            // G[c]. push_back(i);\n        }\n    }\n    init(n);\n    int q;\n    cin >> q;\n    rep(i, 0, q){\n        int u, v;\n        cin >> u >> v;\n        int tmp = lca(u, v);\n        cout << tmp << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\n// -------------8<------- start of library -------8<------------------------\nstruct LowestCommonAncestor {\n    const int root, INF, n;\n    int size, no;\n    std::vector<std::vector<int>> adj;\n    std::vector<int> ord, idx;\n    std::vector<std::pair<int, int>> dep;\n\n    LowestCommonAncestor(int _n, int _r = 0) :\n        root(_r), INF(INT_MAX), n(_n), adj(n), ord(2 * n - 1), idx(n) {}\n\n    void add_edge(int u, int v) { adj[u].push_back(v); adj[v].push_back(u); }\n\n    void Dfs(int cur, int p, int d) {\n        ord[no] = cur;\n        idx[cur] = no;\n        dep[size - 1 + no++] = std::make_pair(d, cur);\n        for (int nxt : adj[cur]) {\n            if (nxt == p) continue;\n            Dfs(nxt, cur, d + 1);\n            ord[no] = cur;\n            dep[size - 1 + no++] = std::make_pair(d, cur);\n        }\n    }\n\n    void Preprocessing() {\n        for (size = 1; size < 2 * n - 1; ) size <<= 1;\n        dep.resize(2 * size - 1);\n\n        no = 0;\n        Dfs(root, -1, 0);\n\n        for (int i = size - 2; 0 <= i; --i) {\n            if (dep[2 * i + 1] < dep[2 * i + 2]) dep[i] = dep[2 * i + 1];\n            else dep[i] = dep[2 * i + 2];\n        }\n    }\n\n    int rmq(int l, int r) {\n        std::pair<int, int> res(INF, INF);\n        l += size - 1;\n        r += size - 1;\n        while (l < r) {\n            if ((l & 1) == 0) res = std::min(res, dep[l]);\n            if ((r & 1) == 0) res = std::min(res, dep[r - 1]);\n            l >>= 1;\n            r = (r - 1) >> 1;\n        }\n        return res.second;\n    }\n\n    int query(int u, int v) {\n        if (idx[v] < idx[u]) std::swap(u, v);\n        return rmq(idx[u], idx[v] + 1);\n    }\n};\n// -------------8<------- end of library ---------8-------------------------\n\nint main() {\n    std::cin.tie(0); std::ios::sync_with_stdio(false);\n\n    // AOJ GRL_5_C: Tree - Lowest Common Ancestor\n    int n;\n    std::cin >> n;\n\n    LowestCommonAncestor lca(n, 0);\n    for (int v = 0, deg, c; v < n; ++v) {\n        std::cin >> deg;\n        while (deg--) {\n            std::cin >> c;\n            lca.add_edge(v, c);\n        }\n    }\n    lca.Preprocessing();\n\n    int q, u, v;\n    std::cin >> q;\n    while (q--) {\n        std::cin >> u >> v;\n        std::cout << lca.query(u, v) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> Pi;\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\n#define fi first\n#define se second\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T> ostream& operator<<(ostream& s,const complex<T>& d) {return s<<\"(\"<<d.real()<<\", \"<<d.imag()<< \")\";}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const pair<T1,T2>& d) {return s<<\"(\"<<d.first<<\", \"<<d.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d){\n\tint len=d.size();\n\trep(i,len){\n\t\ts<<d[i];if(i<len-1) s<<\" \";\n\t}\n\treturn s;\n}\ntemplate<typename T> ostream& operator<<(ostream& s,const vector<vector<T>>& d){\n\tint len=d.size();\n\trep(i,len){\n\t\ts<<d[i]<<endl;\n\t}\n\treturn s;\n}\ntemplate<typename T> ostream& operator<<(ostream& s,const set<T>& v){\n\ts<<\"{ \";\n\tfor(auto itr=v.begin();itr!=v.end();++itr) {\n\t\tif (itr!=v.begin()) {s<< \", \";}\n\t\ts<<(*itr);\n\t}\n\ts<<\" }\";\n\treturn s;\n}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const map<T1,T2>& m){\n\ts<<\"{\"<<endl;\n\tfor(auto itr=m.begin();itr!=m.end();++itr){\n\t\ts<<\" \"<<(*itr).first<<\" : \"<<(*itr).second<<endl;\n\t}\n\ts<<\"}\"<<endl;\n\treturn s;\n}\n\nconst ll mod=1e9+7;\nconst ll inf=1e15;\nconst int INF=1e9;\n\nstruct LCA{\nprivate:\n\tvector<vector<int>> v;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\tint h = 0;\n\tvoid dfs(int n,int m,int d){\n\t\tparent[0][n] = m;\n\t\tdepth[n] = d;\n\t\tfor(auto x:v[n]){\n\t\t\tif(x!=m) dfs(x,n,d+1);\n\t\t}\n\t}\npublic:\n\tLCA(int N,int root,vector<vector<int>>& tree){\n\t\twhile((1<<h)<=N) h++;\n\t\tv = tree;\n\t\tparent = vector<vector<int>>(h,vector<int>(N,0));\n\t\tdepth = vector<int>(N,0);\n\t\tdfs(root,-1,0);\n\t\tfor(int j=0;j+1<h;j++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(parent[j][i]<0) parent[j+1][i] = -1;\n\t\t\t\telse parent[j+1][i] = parent[j][parent[j][i]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int n,int m){\n\t\tif(depth[n]>depth[m]) swap(n,m);\n\t\tfor(int j=0;j<h;j++){\n\t\t\tif((depth[m]-depth[n]) >> j&1) m = parent[j][m];\n\t\t}\n\t\tif(n==m) return n;\n\t\tfor(int j=h-1;j>=0;j--){\n\t\t\tif(parent[j][n]!=parent[j][m]){\n\t\t\t\tn = parent[j][n];\n\t\t\t\tm = parent[j][m];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][n];\n\t}\n\tint dep(int n){return depth[n];}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tint root=0;\n\tvector<vector<int>> g(n);\n\trep(i,n){\n\t\tint k;\n\t\tcin>>k;\n\t\trep(j,k){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tg[i].push_back(c);\n\t\t}\n\t}\n\tLCA lca(n,root,g);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tcout<<lca.lca(a,b)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//????°???±????\\??????????\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define MAX_V 100000\n\nvector<int> G[MAX_V];\nvector<int> depth,vs;\nint id[MAX_V]={};\n\ntemplate<class T>\nclass segtree{\nprivate:\n    vector<T> dat;\n    int _size;\n    T _init;\n    \npublic:\n    segtree(int __size=0 , T init=numeric_limits<T>::max() ):_size(__size) , _init(init) , dat(4*__size,init){\n        if(__size==0)return ;\n        int x=1;\n        while(x<_size)x*=2;\n        _size = x;\n    }\n    \n    int size(){\n        return _size;\n    }\n    \n    void update(int m,T x){\n        int i = m+_size;\n        dat[i] = x;\n        while(i!=1){\n            dat[i/2] = min(dat[i],dat[i^1]);\n            i/=2;\n        }\n    }\n    \n    // call find(s,t)\n    T find(int s,int t,int num=1,int a=0,int b=-1){\n        if(b==-1)b=_size-1; //I couldn't \"int b=_size\".\n        if(b<s||t<a)return _init;\n        if(s<=a&&b<=t)return dat[num];\n        return min( find(s,t,num*2,a,(a+b)/2) , find(s,t,num*2+1,(a+b)/2+1,b) );\n    }\n};\n\n\nvoid dfs(int d,int num){\n    depth.pb(d);\n    vs.pb(num);\n    rep(i,G[num].size()){\n        dfs(d+1,G[num][i]);\n        depth.pb(d);\n        vs.pb(num);\n    }\n    return ;\n}\n\n\nvoid init(){\n    dfs(1,0);\n    rep(i,vs.size()){\n        if(id[ vs[i] ]==0)id[ vs[i] ]=i;\n    }\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int b;\n            cin>>b;\n            G[i].pb(b);\n        }\n    }\n    init();                                                         // aranging depth[] , vs[] and id[]\n    segtree<pii> st(depth.size(),pii((1LL<<31)-1,(1LL<<31)-1));         // the number of elements is depth.size()\n    rep(i,depth.size()){                                            //initialize\n        st.update(i,pii(depth[i],vs[i]));\n    }\n    int a,b;\n    int q;\n    cin>>q;\n    rep(i,q){\n        cin>>a>>b;\n        cout<<st.find(min(id[a],id[b]),max(id[a],id[b])).second<<endl;  // is equal to LCA(a,b)\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\nvector<int>X[MAX_N], D[MAX_N], C;\nint Depth[MAX_N], a[MAX_N], b[MAX_N], N, Q, A, B;\nstack<int>S;\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A; for (int j = 0; j < A; j++) { cin >> B; X[i].push_back(B); }\n\t}\n\tfor (int i = 0; i < MAX_N; i++) { Depth[i] = 1 << 30; a[i] = -1; }\n\tDepth[0] = 0; S.push(0); int cnt = 1; a[0] = 0; cin >> Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) { Depth[X[i][j]] = Depth[i] + 1; }\n\t}\n\twhile (!S.empty()) {\n\t\tint A = S.top();\n\t\tfor (int i = 0; i < X[A].size(); i++) {\n\t\t\tif (a[X[A][i]] == -1) { S.push(X[A][i]); a[X[A][i]] = cnt; b[cnt] = X[A][i]; cnt++; goto E; }\n\t\t}\n\t\tS.pop(); E:;\n\t}\n\tfor (int i = 0; i < N; i++) { D[Depth[i]].push_back(a[i]); }\n\tfor (int i = 0; i < N; i++) { sort(D[i].begin(), D[i].end()); }\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> A >> B; int W = min(Depth[A], Depth[B]); A = a[A]; B = a[B];\n\t\tint L = 1, R = W, M;\n\t\tif (W == 0 || (Depth[A] == 1 && Depth[B] == 1)) { cout << \"0\" << endl; continue; }\n\t\twhile (true) {\n\t\t\tint M = (L + R) / 2;\n\t\t\tint pos1 = upper_bound(D[M - 1].begin(), D[M - 1].end(), A) - D[M - 1].begin(); pos1--;\n\t\t\tint pos2 = upper_bound(D[M - 1].begin(), D[M - 1].end(), B) - D[M - 1].begin(); pos2--;\n\t\t\tint pos3 = upper_bound(D[M].begin(), D[M].end(), A) - D[M].begin(); pos3--;\n\t\t\tint pos4 = upper_bound(D[M].begin(), D[M].end(), B) - D[M].begin(); pos4--;\n\t\t\tbool p1 = false, p2 = false; if (pos1 == pos2) { p1 = true; }if (pos3 == pos4) { p2 = true; }\n\t\t\tif (p1 == true && p2 == false) {\n\t\t\t\tcout << b[D[M - 1][pos1]] << endl; break;\n\t\t\t}\n\t\t\tif (p1 == true && p2 == true) { L = M + 1; }\n\t\t\tif (p1 == false && p2 == false) { R = M; }\n\t\t\tif (p1 == true && p2 == true && M == W) {\n\t\t\t\tcout << b[D[M][pos3]] << endl; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <vector>\n\nstruct HLDecomposition {\n  struct Node {\n    int ord, par, depth;\n    int idx;\n    int path_id = -1;\n    Node() {}\n  };\n\n  const int N;\n  std::vector<std::vector<int>> tree, pathes;\n  std::vector<Node> nodes;\n  std::vector<int> Q;\n\n  HLDecomposition(int N) : N(N), tree(N), nodes(N) {}\n  void add_edge(int u, int v) {\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n  void build(int root = 0) {\n    Q.reserve(N);\n    Q.push_back(root);\n    nodes[root].par = -1;\n    nodes[root].depth = 0;\n    for (int i = 0; i < Q.size(); i++) {\n      int u = Q[i];\n      auto& U = nodes[u];\n      U.ord = i;\n      for (int v : tree[u]) {\n        if (U.par == v) continue;\n        auto& V = nodes[v];\n        V.par = u;\n        V.depth = U.depth + 1;\n        Q.push_back(v);\n      }\n    }\n    decomposition();\n  }\n  void for_each(int u, int v, std::function<void(int, int, int)> f) const {\n    while (nodes[u].path_id != nodes[v].path_id) {\n      int head_u = pathes[nodes[u].path_id][0];\n      int head_v = pathes[nodes[v].path_id][0];\n      if (nodes[head_u].depth > nodes[head_v].depth) {\n        std::swap(u, v);\n        std::swap(head_u, head_v);\n      }\n      f(nodes[v].path_id, 0, nodes[v].idx + 1);\n      v = nodes[head_v].par;\n    }\n    if (nodes[v].idx < nodes[u].idx) std::swap(u, v);\n    f(nodes[v].path_id, nodes[u].idx, nodes[v].idx + 1);\n  }\n  int lca(int u, int v) const {\n    int x;\n    for_each(u, v, [&](int p, int l, int r) { x = pathes[p][l]; });\n    return x;\n  }\n  void decomposition() {\n    std::vector<int> subtree_size(N, 1);\n    for (int i = N - 1; i > 0; i--) {\n      subtree_size[nodes[Q[i]].par] += subtree_size[Q[i]];\n    }\n    for (int u : Q) {\n      auto& U = nodes[u];\n      if (U.path_id == -1) {\n        U.path_id = pathes.size();\n        pathes.emplace_back();\n      }\n      pathes[U.path_id].push_back(u);\n\n      int max_subsize = -1, selected = -1;\n      for (int v : tree[u]) {\n        if (U.par == v) continue;\n        if (max_subsize >= subtree_size[v]) continue;\n        max_subsize = subtree_size[v];\n        selected = v;\n      }\n      if (selected != -1) nodes[selected].path_id = U.path_id;\n    }\n    for (auto&& path : pathes) {\n      for (int i = 0; i < path.size(); i++) {\n        nodes[path[i]].idx = i;\n      }\n    }\n  }\n};\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n// clang-format off\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}if(m)x=-x;return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n\nint main() {\n  int N = rd();\n  HLDecomposition hl(N);\n  for (int i = 0; i < N; i++) {\n    int k = rd();\n    for (int j = 0; j < k; j++) {\n      hl.add_edge(i, rd());\n    }\n  }\n  hl.build(0);\n  int Q = rd();\n  for (int i = 0; i < Q; i++) {\n    int u = rd(), v = rd();\n    wr(hl.lca(u, v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdint>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::uint_fast32_t;\n\nprivate:\n\tstd::vector<std::pair<bool, size_type>> tree;\n\npublic:\n\tUnionFind(const size_type size) : tree(size, std::make_pair(1, 1)) {}\n\tsize_type find(const size_type x) {\n\t\tassert(x < size());\n\t\tif (tree[x].first)\n\t\t\treturn x;\n\t\treturn tree[x].second = find(tree[x].second);\n\t}\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (tree[x].second < tree[y].second)\n\t\t\tstd::swap(x, y);\n\t\ttree[x].second += tree[y].second;\n\t\ttree[y] = std::make_pair(0, x);\n\t\treturn true;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn tree[find(x)].second;\n\t}\n\tsize_type size() const noexcept { return tree.size(); }\n\tbool empty() const noexcept { return tree.empty(); }\n};\n\n#include <cstddef>\n#include <functional>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\n\ntemplate <class GraphContainer, class UnionFindDataStructure>\nstd::vector<typename GraphContainer::size_type> TarjansOfflineLCA(\n\tconst GraphContainer &graph, const typename GraphContainer::size_type root,\n\tconst std::vector<std::pair<typename GraphContainer::size_type,\n\ttypename GraphContainer::size_type>> &queries) {\n\tusing size_type = typename GraphContainer::size_type;\n\tconst size_type size_ = graph.size();\n\tUnionFindDataStructure uft(size_);\n\tstd::vector<size_type> ret(queries.size(), size_), anc(size_);\n\tstd::vector<std::vector<std::size_t>> qset(size_);\n\tstd::stack<std::pair<size_type, size_type>> st;\n\n\tfor (std::size_t i = 0; i < queries.size(); ++i) {\n\t\tqset[queries[i].first].emplace_back(i);\n\t\tqset[queries[i].second].emplace_back(i);\n\t}\n\n\tst.emplace(root, 0);\n\n\tstd::function<void(const size_type, const size_type)> dfs =\n\t\t[&](const size_type v, const size_type prev) {\n\t\tanc[v] = v;\n\t\tfor (const auto e : graph[v]) {\n\t\t\tif (e.to != prev) {\n\t\t\t\tdfs(e.to,v);\n\t\t\t\tuft.unite(v, e.to);\n\t\t\t\tanc[uft.find(v)] = v;\n\t\t\t}\n\t\t}\n\t\tfor (const auto e : qset[v])\n\t\t\tif (ret[e] == size_)\n\t\t\t\tret[e] = v;\n\t\t\telse\n\t\t\t\tret[e] = anc[uft.find(ret[e])];\n\t};\n\tdfs(root, size_);\n\treturn ret;\n}\n\nstruct edge {\n\tint to;\n\tedge(int x):to(x){}\n};\n#include<iostream>\nint main() {\n\tint n;\n\tstd::cin >> n;\n\tusing Graph = std::vector<std::vector<edge>>;\n\tGraph g(n);\n\tfor (int i = 0;i < n;++i) {\n\t\tint k, c;\n\t\tstd::cin >> k;\n\t\twhile (k--) {\n\t\t\tstd::cin >> c;\n\t\t\tg[i].emplace_back( c );\n\t\t}\n\t}\n\tint q;\n\tstd::cin >> q;\n\tusing S = typename Graph::size_type;\n\tstd::vector<std::pair<S, S>> Q;\n\twhile (q--) {\n\t\tS u, v;\n\t\tstd::cin >> u >> v;\n\t\tQ.emplace_back(u, v);\n\t}\n\tconst auto ans=TarjansOfflineLCA<Graph, UnionFind>(g, 0, Q);\n\tfor (const auto e : ans)\n\t\tstd::cout << e << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORa(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define FORs(i,st) for(auto i : st)\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define ALL(c) (c).begin(), (c).end()\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n \n# define FORq(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n \nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n \n \nstruct Query {\n  int v, id; // 相手の頂点とクエリ id\n  Query(int v, int i) : v(v), id(i) { }\n};\nvoid visit(const Graph &g, int u, int w,\n    vector<vector<Query>> &qs, vector<int> &color,\n    vector<int> &ancestor, UnionFind &uf, vector<int>& ans) {\n  ancestor[ uf.root(u) ] = u;\n  FORq(e, g[u]) if (e->dst != w) {\n    visit(g, e->dst, u, qs, color, ancestor, uf, ans);\n    uf.unionSet( e->src, e->dst );\n    ancestor[ uf.root(u) ] = u;\n  }\n  color[u] = 1;\n  for(auto const& q : qs[u]) {\n    if (q.v >= 0 && color[q.v]) ans[q.id] = ancestor[ uf.root(q.v) ];\n  }\n}\nvoid leastCommonAncestor(const Graph &g, int r, vector<vector<Query>> &qs, vector<int>& ans) {\n  UnionFind uf(g.size());\n  vector<int> color(g.size()), ancestor(g.size());\n  visit(g, r, -1, qs, color, ancestor, uf, ans);\n}\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n \n    ll n;\n    cin>>n;\n    Graph g(n);\n    FOR(i,0,n){\n      ll round;\n      cin>>round;\n      FOR(j,0,round){\n        ll t1 = i;\n        ll t2;\n        cin>>t2;\n        g[t1].push_back(Edge(t1,t2,1));\n      }\n    }\n \n    int q;\n    cin>>q;\n    vector<vector<Query>> qs(n);\n \n    FOR(i,0,q){\n      int in1,in2;\n      cin>>in1>>in2;\n      qs[in1].emplace_back(in2, i);\n      qs[in2].emplace_back(in1, i);\n    }\n    vector<int> ans(q);\n    leastCommonAncestor(g,0,qs, ans);\n \n    FOR(i,0,q){\n      cout<< ans[i] <<endl;\n    }\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\nimport Control.Applicative\nimport Control.Monad\nimport Data.Array\nimport Data.Bits\nimport qualified Data.ByteString.Char8 as C\nimport Data.Graph (buildG, dff, Vertex)\nimport Data.Maybe\nimport Data.List\nimport Data.Tree (levels)\n\nmain = readLn >>= \\n -> join $ sub n <$> replicateM n get\n\nsub n bs = readLn >>= \\q -> sol n bs <$> replicateM q get >>= put\n\nget = fmap fst . mapMaybe C.readInt . C.words <$> C.getLine\n\nput = mapM_ print\n\nsol n bs = fmap (\\[u,v] -> lca u v)\n  where\n  -- vertex indices\n  as = [0..n-1] :: [Vertex]\n\n  -- graph as a tree\n  g = buildG (0,n-1) . join $ zipWith (\\a b -> fmap ((,) a) (tail b)) as bs\n\n  -- root lookups (assume (-1) as a parent of the tree root 0)\n  rt = array (0,n-1) $ dfs (-1) [] 0\n    where\n    dfs w ps u = (u,w):foldl' (dfs u) ps (g!u)\n\n  -- vertex levels by using Data.Graph.dff and Data.Tree.levels\n  -- dff: a spanning forest by DFS starting from each vertex\n  -- levels: the list of nodes at each level of the tree \n  lvs = array (0,n-1) . sort\n    . concat . zipWith (fmap . flip (,)) [1..]\n    . concat . fmap levels $ dff g :: Array Vertex Int\n\n  -- Lowest Common Ancestor (LCA) by binary search\n  lca !u !v\n    | u == v        = u\n    | lvs!u > lvs!v = lca (rtk j u) v\n    | lvs!u < lvs!v = lca u (rtk j v)\n    | otherwise     = lca u' v'\n    where\n    j = logBase2 $ abs (lvs!u - lvs!v)\n    (u',v') = loop (logBase2 n) (u,v)\n    loop k (x,y)\n      | k==0      = (x',y')\n      | x'/=y'    = (x',y')\n      | otherwise = loop (k `div` 2) (x,y)\n      where\n      x' = rtk k x\n      y' = rtk k y\n\n  -- (2^k)-th parent lookups : TBD memoize\n  rtk 0 = (rt!)\n  rtk k = rtk (k-1) . rtk (k-1)\n\n  -- leading bit position\n  logBase2 x = finiteBitSize x - countLeadingZeros x - 1\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\nimport Control.Applicable\nimport Control.Monad\nimport Data.Array\nimport Data.Bits\nimport qualified Data.ByteString.Char8 as C\nimport Data.Graph (buildG, dff, Vertex)\nimport Data.Maybe\nimport Data.List\nimport Data.Tree (levels)\n\nmain = readLn >>= \\n -> join $ sub n <$> replicateM n get\n\nsub n bs = readLn >>= \\q -> sol n bs <$> replicateM q get >>= put\n\nget = fmap fst . mapMaybe C.readInt . C.words <$> C.getLine\n\nput = mapM_ print\n\nsol n bs = fmap (\\[u,v] -> lca u v)\n  where\n  -- vertex indices\n  as = [0..n-1] :: [Vertex]\n\n  -- graph as a tree\n  g = buildG (0,n-1) . join $ zipWith (\\a b -> fmap ((,) a) (tail b)) as bs\n\n  -- root lookups (assume (-1) as a parent of the tree root 0)\n  rt = array (0,n-1) $ dfs (-1) [] 0\n    where\n    dfs w ps u = (u,w):foldl' (dfs u) ps (g!u)\n\n  -- vertex levels by using Data.Graph.dff and Data.Tree.levels\n  -- dff: a spanning forest by DFS starting from each vertex\n  -- levels: the list of nodes at each level of the tree \n  lvs = array (0,n-1) . sort\n    . concat . zipWith (fmap . flip (,)) [1..]\n    . concat . fmap levels $ dff g :: Array Vertex Int\n\n  -- Lowest Common Ancestor (LCA) by binary search\n  lca !u !v\n    | u == v        = u\n    | lvs!u > lvs!v = lca (rtk j u) v\n    | lvs!u < lvs!v = lca u (rtk j v)\n    | otherwise     = lca u' v'\n    where\n    j = logBase2 $ abs (lvs!u - lvs!v)\n    (u',v') = loop (logBase2 n) (u,v)\n    loop k (x,y)\n      | k==0      = (x',y')\n      | x'/=y'    = (x',y')\n      | otherwise = loop (k `div` 2) (x,y)\n      where\n      x' = rtk k x\n      y' = rtk k y\n\n  -- (2^k)-th parent lookups : TBD memoize\n  rtk 0 = (rt!)\n  rtk k = rtk (k-1) . rtk (k-1)\n\n  -- leading bit position\n  logBase2 x = finiteBitSize x - countLeadingZeros x - 1\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE BangPatterns #-}\n\nimport           Control.Applicative\nimport           Control.Monad\nimport           Control.Monad.ST\nimport           Data.Bits\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\nimport           Data.Char\nimport           Data.Function\nimport           Data.Tuple\nimport qualified Data.Vector                 as V\nimport qualified Data.Vector.Generic         as G\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport           Data.Word\nimport           Unsafe.Coerce\n\nmain :: IO ()\nmain = do\n    n <- readLn\n    tree <- V.replicateM n $\n        U.unsafeTail.U.unfoldr (B.readInt.B.dropWhile isSpace) <$> B.getLine\n    q <- readLn\n    qs <- U.unfoldrN q (readInt2.B.dropWhile isSpace) <$> B.getContents\n    putStr.unlines.map show.U.toList $ solve tree qs\n\nsolve :: Graph -> U.Vector (Int, Int) -> U.Vector Int\nsolve gr = U.map (uncurry $ queryLCA lca)\n  where\n    !lca = buildLCA gr\n\nreadInt2 :: B.ByteString -> Maybe ((Int,Int), B.ByteString)\nreadInt2 bs = Just ((x,y),bsy)\n  where\n    Just (x, bsx) = B.readInt bs\n    Just (y, bsy) = B.readInt $ B.unsafeTail bsx\n\nfloorLog2 :: Int -> Int\nfloorLog2 x = fromIntegral $ unsafeShiftR y 52 - 1023\n  where\n    y :: Word64\n    y = unsafeCoerce (fromIntegral x :: Double)\n\nunsafeIndex2 :: (G.Vector u a, G.Vector v (u a))\n             => v (u a) -> Int -> Int -> a\nunsafeIndex2 vv i j = G.unsafeIndex (G.unsafeIndex vv i) j\n{-# INLINE unsafeIndex2 #-}\n\ntype Vertex = Int\ntype Graph = V.Vector (U.Vector Vertex)\n\nnewtype RMQ a = RMQ {rmqTable :: V.Vector (U.Vector (a, Int))}\n\nbuildRMQ :: (U.Unbox a, Ord a) => U.Vector a -> RMQ a\nbuildRMQ vec = RMQ\n    . V.scanl' (\\acc i -> U.zipWith min acc $ U.drop i acc) veci\n    $ V.iterateN (floorLog2 $ U.length vec) (*2) 1\n  where\n    veci = U.map swap $ U.indexed vec\n\nqueryMin :: (U.Unbox a, Ord a) => RMQ a -> Int -> Int -> a\nqueryMin rmq l r = fst $ min x y\n  where\n    lg = floorLog2 $ r - l\n    x = unsafeIndex2 (rmqTable rmq) lg l\n    y = unsafeIndex2 (rmqTable rmq) lg $ r - unsafeShiftL 1 lg + 1\n{-# INLINE queryMin #-}\n\nqueryMinIndex :: (U.Unbox a, Ord a) => RMQ a -> Int -> Int -> Int\nqueryMinIndex rmq l r = snd $ min x y\n  where\n    lg = floorLog2 $ r - l\n    x = unsafeIndex2 (rmqTable rmq) lg l\n    y = unsafeIndex2 (rmqTable rmq) lg $ r - unsafeShiftL 1 lg + 1\n{-# INLINE queryMinIndex #-}\n\nnothing :: Int\nnothing = -1\n\ndata LCA = LCA (U.Vector Vertex) (U.Vector Int) (RMQ Vertex)\n\nbuildLCA :: Graph -> LCA\nbuildLCA tree =  runST $ do\n    eulertour <- UM.replicate (2 * V.length tree - 1) nothing\n    idx <-UM.replicate (V.length tree) nothing\n    depth <- UM.replicate (2 * V.length tree - 1) nothing\n\n    void $ fix `flip` 0 `flip` nothing `flip` 0 `flip` 0 $ \\dfs v p d i -> do\n        UM.unsafeWrite eulertour i v\n        UM.unsafeWrite idx v i\n        UM.unsafeWrite depth i d\n\n        U.foldM' `flip` (i + 1) `flip` V.unsafeIndex tree v $ \\j u ->\n            if u == p\n            then return j\n            else do\n                k <- dfs u v (d + 1) j\n                UM.unsafeWrite eulertour k v\n                UM.unsafeWrite depth k d\n                return $ k + 1\n\n    LCA <$> U.unsafeFreeze eulertour\n        <*> U.unsafeFreeze idx\n        <*> (buildRMQ <$> U.unsafeFreeze depth)\n\nqueryLCA :: LCA -> Vertex -> Vertex -> Vertex\nqueryLCA (LCA eulertour idx rmq) v u = U.unsafeIndex eulertour\n    $ queryMinIndex rmq (min i j) (max i j)\n  where\n    !i = U.unsafeIndex idx v\n    !j = U.unsafeIndex idx u\n{-# INLINE queryLCA #-}"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE BangPatterns #-}\n\nimport           Control.Applicative\nimport           Control.Monad\nimport           Control.Monad.ST\nimport           Data.Bits\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\nimport           Data.Char\nimport           Data.Function\nimport           Data.Tuple\nimport qualified Data.Vector                 as V\nimport qualified Data.Vector.Generic         as G\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport           Data.Word\nimport           Unsafe.Coerce\n\nmain :: IO ()\nmain = do\n    n <- readLn\n    tree <- V.replicateM n $\n        U.unsafeTail.U.unfoldr (B.readInt.B.dropWhile isSpace) <$> B.getLine\n    q <- readLn\n    qs <- U.unfoldrN q (readInt2.B.dropWhile isSpace) <$> B.getContents\n    putStr.unlines.map show.U.toList $ solve tree qs\n\nsolve :: Graph -> U.Vector (Int, Int) -> U.Vector Int\nsolve gr = U.map (uncurry $ queryLCA lca)\n  where\n    !lca = buildLCA gr\n\nreadInt2 :: B.ByteString -> Maybe ((Int,Int), B.ByteString)\nreadInt2 bs = Just ((x,y),bsy)\n  where\n    Just (x, bsx) = B.readInt bs\n    Just (y, bsy) = B.readInt $ B.unsafeTail bsx\n\nfloorLog2 :: Int -> Int\nfloorLog2 x = fromIntegral $ unsafeShiftR y 52 - 1023\n  where\n    y :: Word64\n    y = unsafeCoerce (fromIntegral x :: Double)\n\nunsafeIndex2 :: (G.Vector u a, G.Vector v (u a))\n             => v (u a) -> Int -> Int -> a\nunsafeIndex2 vv i j = G.unsafeIndex (G.unsafeIndex vv i) j\n{-# INLINE unsafeIndex2 #-}\n\ntype Vertex = Int\ntype Graph = V.Vector (U.Vector Vertex)\n\nnewtype RMQ a = RMQ {rmqTable :: V.Vector (U.Vector (a, Int))}\n\nbuildRMQ :: (U.Unbox a, Ord a) => U.Vector a -> RMQ a\nbuildRMQ vec = RMQ\n    . V.scanl' (\\acc i -> U.zipWith min acc $ U.drop i acc) veci\n    $ V.iterateN (floorLog2 $ U.length vec) (*2) 1\n  where\n    veci = U.map swap $ U.indexed vec\n\nqueryMin :: (U.Unbox a, Ord a) => RMQ a -> Int -> Int -> a\nqueryMin rmq l r\n    | l < r = fst $ min x y\n    | l == r = fst $ unsafeIndex2 (rmqTable rmq) 0 l\n    | otherwise = error \"queryMin\"\n  where\n    lg = floorLog2 $ r - l\n    x = unsafeIndex2 (rmqTable rmq) lg l\n    y = unsafeIndex2 (rmqTable rmq) lg $ r - unsafeShiftL 1 lg + 1\n{-# INLINE queryMin #-}\n\nqueryMinIndex :: (U.Unbox a, Ord a) => RMQ a -> Int -> Int -> Int\nqueryMinIndex rmq l r\n    | l < r = snd $ min x y\n    | l == r = snd $ unsafeIndex2 (rmqTable rmq) 0 l\n    | otherwise = error \"queryMinIndex\"\n  where\n    lg = floorLog2 $ r - l\n    x = unsafeIndex2 (rmqTable rmq) lg l\n    y = unsafeIndex2 (rmqTable rmq) lg $ r - unsafeShiftL 1 lg + 1\n{-# INLINE queryMinIndex #-}\n\nnothing :: Int\nnothing = -1\n\ndata LCA = LCA (U.Vector Vertex) (U.Vector Int) (RMQ Vertex)\n\nbuildLCA :: Graph -> LCA\nbuildLCA tree =  runST $ do\n    eulertour <- UM.replicate (2 * V.length tree - 1) nothing\n    idx <-UM.replicate (V.length tree) nothing\n    depth <- UM.replicate (2 * V.length tree - 1) nothing\n\n    void $ fix `flip` 0 `flip` nothing `flip` 0 `flip` 0 $ \\dfs v p d i -> do\n        UM.unsafeWrite eulertour i v\n        UM.unsafeWrite idx v i\n        UM.unsafeWrite depth i d\n\n        U.foldM' `flip` (i + 1) `flip` V.unsafeIndex tree v $ \\j u ->\n            if u == p\n            then return j\n            else do\n                k <- dfs u v (d + 1) j\n                UM.unsafeWrite eulertour k v\n                UM.unsafeWrite depth k d\n                return $ k + 1\n\n    LCA <$> U.unsafeFreeze eulertour\n        <*> U.unsafeFreeze idx\n        <*> (buildRMQ <$> U.unsafeFreeze depth)\n\nqueryLCA :: LCA -> Vertex -> Vertex -> Vertex\nqueryLCA (LCA eulertour idx rmq) v u = U.unsafeIndex eulertour\n    $ queryMinIndex rmq (min i j) (max i j)\n  where\n    !i = U.unsafeIndex idx v\n    !j = U.unsafeIndex idx u\n{-# INLINE queryLCA #-}"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n\nimport Control.Monad\nimport Data.Array\nimport Data.Bits\nimport qualified Data.ByteString.Char8 as C\nimport Data.Graph (buildG, dff, Vertex)\nimport Data.Maybe\nimport Data.List\nimport Data.Tree (levels)\n\nmain = readLn >>= \\n -> join $ sub n <$> replicateM n get\n\nsub n bs = readLn >>= \\q -> sol n bs <$> replicateM q get >>= put\n\nget = fmap fst . mapMaybe C.readInt . C.words <$> C.getLine\n\nput = mapM_ print\n\nsol n bs = fmap (\\[u,v] -> lca u v)\n  where\n  -- vertex indices\n  as = [0..n-1] :: [Vertex]\n\n  -- graph as a tree\n  g = buildG (0,n-1) . join $ zipWith (\\a b -> fmap ((,) a) (tail b)) as bs\n\n  -- root lookups (assume (-1) as a parent of the tree root 0)\n  rt = array (0,n-1) $ dfs (-1) [] 0\n    where\n    dfs w ps u = (u,w):foldl' (dfs u) ps (g!u)\n\n  -- vertex levels by using Data.Graph.dff and Data.Tree.levels\n  -- dff: a spanning forest by DFS starting from each vertex\n  -- levels: the list of nodes at each level of the tree \n  lvs = array (0,n-1) . sort\n    . concat . zipWith (fmap . flip (,)) [1..]\n    . concat . fmap levels $ dff g :: Array Vertex Int\n\n  -- Lowest Common Ancestor (LCA) by binary search\n  lca !u !v\n    | u == v        = u\n    | lvs!u > lvs!v = lca (rtk j u) v\n    | lvs!u < lvs!v = lca u (rtk j v)\n    | otherwise     = lca u' v'\n    where\n    j = logBase2 $ abs (lvs!u - lvs!v)\n    (u',v') = loop (logBase2 n) (u,v)\n    loop k (x,y)\n      | k==0      = (x',y')\n      | x'/=y'    = (x',y')\n      | otherwise = loop (k `div` 2) (x,y)\n      where\n      x' = rtk k x\n      y' = rtk k y\n\n  -- (2^k)-th parent lookups : TBD memoize\n  rtk 0 = (rt!)\n  rtk k = rtk (k-1) . rtk (k-1)\n\n  -- leading bit position\n  logBase2 x = finiteBitSize x - countLeadingZeros x - 1\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n\tint i, node;\n\tint middle = (left + right) / 2;\n\tif(right - left < 40) {\n\t\tfor(i=left,node=root;i<=right;i++) {\n//\t\t\tprintf(\"%d %d %d %d\\n\", so[i], si[i], right, left);\n\t\t\tif(so[i] == si[i]) {\n\t\t\t\treturn so[i];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tif(so[middle] != si[middle]) {\n\t\treturn binary_search(middle, right, so, si, root);\n\t}\n\t\n\treturn binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tint last;\n\tif(source == sink) return source;\n\tso = si = 0;\n\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\tso_list[so++] = node;\n\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\tsi_list[si++] = node;\n\n\tif(si > so) {\n\t\tlast = si - so;\n\t\treturn binary_search(0, so, so_list, &si_list[last], root);\n\t}\n\t\n\tlast = so - si;\n\treturn binary_search(0, si, &so_list[last], si_list, root);\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint S[4*100010];\nint N[100010];\nint T;\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return a<0||b<0?a<0?b:a:N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<n;i++)S[T+i]=i;\n  for(   ;i<T;i++)S[T+i]=-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],d[100010],r=0,fi[100010],ID[100010];\nvoid ldfs(int s){\n  int i;\n  fi[s]=r;\n  N[r]=d[s];\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(d[to[i]])continue;\n    d[to[i]]=d[s]+1;\n    ldfs(to[i]);\n    N[r]=d[s];\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  d[p]=1;\n  r=0;\n  ldfs(p);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b]),1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",ID[i],N[i]);printf(\"\\n\");\n  //for(i=0;i<n;i++)printf(\"%d %d\\n\",i,fi[i]);printf(\"\\n\");\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",ID[alca(i,j)]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ GRL_5_C Lowest Common Ancestor\n// 2018.5.5 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse {\n//\t\tif (n < 0) pc('-'), n = -n;\n\t\ti = 0; while (n) ob[i++] = n%10 + '0', n/=10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n\tpc('\\n');\n}\n\n\n#define INF 0x30303030\n\n// セグメント木の初期化\nint seg[1<<19][2]; int sz;\n\nvoid segtree(int n, int init_val)\n{\n\tint i;\n\n\tsz = 2; while (sz < n) sz <<= 1;\n\tn = sz << 1;\n//\tmemset(seg, init_val, n << 2);\n\tfor (i = 0; i < n; i++) seg[i][0] = init_val;\n}\n\n// RMQのインデックス部分を一括して更新\nvoid update()\n{\n\tint i, k, n, p;\n\n\tn = sz;\twhile (n > 0) {\n\t\tfor (p = n-1, i = 0; i < n; i+=2, p+=2) {\n\t\t\tk = p >> 1;\n\t\t\tif (seg[p][0] <= seg[p+1][0]) {\n\t\t\t\tseg[k][0] = seg[p  ][0], seg[k][1] = seg[p  ][1];\n\t\t\t} else {\n\t\t\t\tseg[k][0] = seg[p+1][0], seg[k][1] = seg[p+1][1];\n\t\t\t}\n\t\t}\n\t\tn >>= 1;\n\t}\n}\n\n\nint query2(int a, int b, int k, int l, int r, int *id) \n{\n\tint m, lmin, rmin;\n\tint lid, rid;\n\n\tif (r <= a || b <= l) { *id = 0; return INF; }\n\tif (a <= l && r <= b) { *id = seg[k][1]; return seg[k][0]; }\n\tk <<= 1, m = (l+r) >> 1;\n    lmin = query2(a, b, k+1, l, m, &lid);\n    rmin = query2(a, b, k+2, m, r, &rid);\n\tif (lmin > rmin) lmin = rmin, lid = rid;\n\t*id = lid;\n    return lmin; \n}\n\n// 空間 [a, b] 内の最小値\nint range_min_query(int a, int b)\n{\n\tint id;\n\tquery2(a, b+1, 0, 0, sz, &id);\n\treturn id;\n}\n\n\n// LCA\n#define MAX_V  100005\nint hi[MAX_V], *to[MAX_V];\nint root;\nint vs[MAX_V << 1];\nint depth[MAX_V << 1];\nint id[MAX_V];\n\nvoid dfs(int v, int p, int d, int *k)\n{\n\tint i;\n\n\tid[v] = *k;\n\tvs[*k] = v;\n\tdepth[(*k)++] = d;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\tif (to[v][i] != p) {\n\t\t\tdfs(to[v][i], v, d+1, k);\n\t\t\tvs[*k] = v;\n\t\t\tdepth[(*k)++] = d;\n\t\t}\n\t}\n}\n\nint lca(int u, int v)\n{\n\tint min, max;\n\tif (id[u] < id[v]) min = id[u], max = id[v];\n\telse               min = id[v], max = id[u];\n\treturn vs[range_min_query(min, max)];\n}\n\nint main()\n{\n\tint n, q, i, j, k, u, v;\n\tint *memo;\n\n\tn = in();\n\tmemo = malloc(n<<3);\n\ti = 0; for (u = 0; u < n; u++) {\n\t\tk = in();\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tmemo[i++] = u, memo[i++] = v = in();\n\t\t\thi[u]++, hi[v]++;\n\t\t}\n\t}\n\n\tfor (u = 0; u < n; u++) if (hi[u]) to[u] = malloc(hi[u]<<2);\n\tmemset(hi, 0, n<<2);\n\tj = 0; while (j < i) {\n\t\tu = memo[j++], v = memo[j++];\n\t\tto[u][hi[u]++] = v, to[v][hi[v]++] = u;\n\t}\n\n\troot = 0, k = 0;\n\tdfs(root, -1, 0, &k);\n\n\tn = (n<<1)-1;\n\tsegtree(n, INF);\n\n\tj = sz-1;\n\tfor (u = 0; u < n; u++) seg[j][0] = depth[u], seg[j++][1] = u;\n\tupdate();\n\n\tq = in();\n\twhile (q--) {\n\t\tu = in(), v = in();\n\t\tout(lca(u, v));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint S[4*100010];\nint N[100010];\nint T;\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return (a<0||b<0)?(a<0?b:a):N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<n;i++)S[T+i]=i;\n  for(   ;i<T;i++)S[T+i]=-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){//printf(\"%d %d %d %d %d\\n\",a,b,i,l,r);\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],d[100010],r=0,fi[100010],ID[100010];\nvoid ldfs(int s){\n  int i;\n  fi[s]=r;\n  N[r]=d[s];\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(d[to[i]])continue;\n    d[to[i]]=d[s]+1;\n    ldfs(to[i]);\n    N[r]=d[s];\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  d[p]=1;\n  r=0;\n  ldfs(p);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b])+1,1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);//printf(\"\\n\");\n  //for(i=1;i<2*T;i++)printf(\"%d %d\\n\",S[i],N[S[i]]);printf(\"\\n\");\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",ID[i],N[i]);printf(\"\\n\");\n  //for(i=0;i<n;i++)printf(\"%d %d\\n\",i,fi[i]);printf(\"\\n\");\n  scanf(\"%d\",&n);//printf(\"%d\\n\\n\",sout(0,0,1,0,T));\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",alca(i,j));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint solve(int source, int sink, int root) {\n\tint node, so_visit, si_visit;\n\tint i, j;\n\tif(source == sink) return source;\n\tso = si = 0;\n\tso_visit = si_visit = 0;\n\t\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\n\t// ルートから順番に追ってみて、同じ親じゃなくなったら\n\t// ひとつ前のノードを結果とする\n\tnode = root;\n\tfor(i=si-1, j=so-1; i>= 0 && j>=0; i--, j--) {\n\t\tif(so_list[j] != si_list[i]) {\n\t\t\treturn node;\n\t\t}\n\n\t\tnode = so_list[j];\n\t}\n\t\n\treturn node;\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint S[4*200010];\nint N[200010];\nint T;\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return (a<0||b<0)?(a<0?b:a):N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<n;i++)S[T+i]=i;\n  for(   ;i<T;i++)S[T+i]=-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){//printf(\"%d %d %d %d %d\\n\",a,b,i,l,r);\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],d[100010],r=0,fi[100010],ID[200010];\nvoid ldfs(int s){\n  int i;\n  fi[s]=r;\n  N[r]=d[s];\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(d[to[i]])continue;\n    d[to[i]]=d[s]+1;\n    ldfs(to[i]);\n    N[r]=d[s];\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  d[p]=1;\n  r=0;\n  ldfs(p);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b])+1,1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);//printf(\"\\n\");\n  //for(i=1;i<2*T;i++)printf(\"%d %d\\n\",S[i],N[S[i]]);printf(\"\\n\");\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",ID[i],N[i]);printf(\"\\n\");\n  //for(i=0;i<n;i++)printf(\"%d %d\\n\",i,fi[i]);printf(\"\\n\");\n  scanf(\"%d\",&n);//printf(\"%d\\n\\n\",sout(0,0,1,0,T));\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",ID[alca(i,j)]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint* tree_cache[MAX_NODE];\nint t_size[MAX_NODE];\n\nvoid init_tree(int root, int* leafs, int leaf_size) {\n\tint i,j,node,id;\n\tint cache[MAX_NODE];\n\t\n\t// 葉の要素だけ実体化する\n\tfor(i=0;i<leaf_size;i++) {\n\t\tid = leafs[i];\n\t\tcache[0] = id;\n\t\tfor(j=1;j<MAX_NODE;j++) {\n\t\t\tnode = parent[cache[j-1]];\n\t\t\tcache[j] = node;\n\t\t\tif(node == root) {\n\t\t\t\tt_size[id] = j + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttree_cache[id] = (int*)malloc(t_size[id]*sizeof(int));\n\t\tfor(j=0;j<t_size[id];j++) tree_cache[id][j] = cache[j];\n\n\t\t// 途中の要素はポインタを設定\n\t\tfor(j=1;j<t_size[id];j++) {\n\t\t\tnode = tree_cache[id][j];\n\t\t\ttree_cache[node] = &tree_cache[id][j];\n\t\t\tt_size[node] = t_size[id] - j;\n\t\t}\n\t}\n}\n\n\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n\tint i, node;\n\tint middle = (left + right) / 2;\n\tif(right - left < 40) {\n\t\tfor(i=left,node=root;i<=right;i++) {\n\t\t\tif(so[i] == si[i]) {\n\t\t\t\treturn so[i];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tif(so[middle] != si[middle]) {\n\t\treturn binary_search(middle, right, so, si, root);\n\t}\n\t\n\treturn binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tint last;\n\tint* p_so_list;\n\tint* p_si_list;\n\tint so, si;\n\tif(source == sink) return source;\n\tso = si = 0;\n\n\tp_so_list = tree_cache[source];\n\tso = t_size[source];\n\tp_si_list = tree_cache[sink];\n\tsi = t_size[sink];\n\n\tif(si > so) {\n\t\tlast = si - so;\n\t\treturn binary_search(0, so, p_so_list, &p_si_list[last], root);\n\t}\n\t\n\tlast = so - si;\n\treturn binary_search(0, si, &p_so_list[last], p_si_list, root);\n\t\n}\n\nint main(void) {\n\tint i, j, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint leafs[MAX_NODE];\n\tint leaf_size = 0;\n\tint root;\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) leafs[leaf_size++] = i;\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tt_size[i] = -1;\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinit_tree(root, leafs, leaf_size);\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint T,S[4*200010],N[200010];\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return (a<0||b<0)?(a<0?b:a):N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<T;i++)S[T+i]=i<n?i:-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){//printf(\"%d %d %d %d %d\\n\",a,b,i,l,r);\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],d[100010],r=0,fi[100010],ID[200010];\nvoid ldfs(int s){\n  int i;\n  N[fi[s]=r]=d[s];\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(fi[to[i]])continue;\n    d[to[i]]=d[s]+1;\n    ldfs(to[i]);\n    N[r]=d[s];\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  d[p]=1;\n  r=0;\n  ldfs(p);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b])+1,1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",ID[alca(i,j)]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint* route[MAX_NODE];\nint* r_size[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint solve(int source, int sink, int root) {\n\tint node, so_visit, si_visit;\n\tint i, j;\n\tif(source == sink) return source;\n\tso = si = 0;\n\tso_visit = si_visit = 0;\n\t\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\troute[source] = (int*)malloc(so*sizeof(int));\n\tmemcpy(route[source], so_list, sizeof(so*sizeof(int)));\n\tr_size[node] = so;\n\t\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\troute[node] = (int*)malloc(si*sizeof(int));\n\tmemcpy(route[node], si_list, sizeof(si*sizeof(int)));\n\tr_size[node] = si;\n\n\t// ルートから順番に追ってみて、同じ親じゃなくなったら\n\t// ひとつ前のノードを結果とする\n\tnode = root;\n\tfor(i=si-1, j=so-1; i>= 0 && j>=0; i--, j--) {\n\t\tif(so_list[j] != si_list[i]) {\n\t\t\treturn node;\n\t\t}\n\n\t\tnode = so_list[j];\n\t}\n\t\n\treturn node;\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\troute[i] = NULL;\n\t\tr_size[i] = 0;\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint S[4*100010];\nint N[100010];\nint T;\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return (a<0||b<0)?(a<0?b:a):N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<n;i++)S[T+i]=i;\n  for(   ;i<T;i++)S[T+i]=-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){//printf(\"%d %d %d %d %d\\n\",a,b,i,l,r);\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],d[100010],r=0,fi[100010],ID[100010];\nvoid ldfs(int s){\n  int i;\n  fi[s]=r;\n  N[r]=d[s];\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(d[to[i]])continue;\n    d[to[i]]=d[s]+1;\n    ldfs(to[i]);\n    N[r]=d[s];\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  d[p]=1;\n  r=0;\n  ldfs(p);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b])+1,1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);//printf(\"\\n\");\n  //for(i=1;i<2*T;i++)printf(\"%d %d\\n\",S[i],N[S[i]]);printf(\"\\n\");\n  //for(i=0;i<r;i++)printf(\"%d %d\\n\",ID[i],N[i]);printf(\"\\n\");\n  //for(i=0;i<n;i++)printf(\"%d %d\\n\",i,fi[i]);printf(\"\\n\");\n  scanf(\"%d\",&n);//printf(\"%d\\n\\n\",sout(0,0,1,0,T));\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",ID[alca(i,j)]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define swap(a, b, type) do {type t = a; a = b; b = t;} while(0)\nstruct node {\n  int id;\n  struct node *next;\n};\n\nstruct node **list;\nint **parent, *depth;\n\nvoid Insert(int a, int b);\nvoid dfs(int v, int p, int d);\nvoid init(int logv, int vsize);\nint lca(int u, int v, int logv);\nint main(void)\n{\n  int i, j, n, k, c, q, n2 = 1, logn = 0;\n  scanf(\"%d\", &n);\n  do {\n    n2 *= 2;\n    logn++;\n  } while (n > n2);\n  list = (struct node**)malloc(sizeof(struct node*) * n);\n  parent = (int**)malloc(sizeof(int*) * logn);\n  depth = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < logn; i++) parent[i] = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    list[i] = NULL;\n    scanf(\"%d\", &k);\n    if (!k) continue;\n    for (j = 0; j < k; j++) {\n      scanf(\"%d\", &c);\n      Insert(i, c);\n    }\n  }\n  init(logn, n);\n  scanf(\"%d\", &q);\n  for (i = 0; i < q; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    printf(\"%d\\n\", lca(u, v, logn));\n  }\n  for (i = 0; i < n; i++) free(list[i]);\n  for (i = 0; i < logn; i++) free(parent[i]);\n  free(list);\n  free(parent);\n  free(depth);\n}\n\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next = list[a];\n  list[a] = p;\n}\n\nvoid dfs(int v, int p, int d)\n{\n  struct node *n;\n  parent[0][v] = p;\n  depth[v] = d;\n  for (n = list[v]; n != NULL; n = n->next) {\n    if (n->id != p) dfs(n->id, v, d + 1);\n  }\n}\n\nvoid init(int logv, int vsize)\n{\n  int i, j;\n  dfs(0, -1, 0);\n  for (i = 0; i + 1 < logv; i++) {\n    for (j = 0; j < vsize; j++) {\n      if (parent[i][j] < 0) parent[i+1][j] = -1;\n      else parent[i+1][j] = parent[i][parent[i][j]];\n    }\n  }\n}\n\nint lca(int u, int v, int logv)\n{\n  int i;\n  if (depth[u] > depth[v]) swap(u, v, int);\n  for (i = 0; i < logv; i++) {\n    if ((depth[v] - depth[u]) >> i & 1) v = parent[i][v];\n  }\n  if (u == v) return u;\n  for (i = logv - 1; i >= 0; i--) {\n    if (parent[i][u] != parent[i][v]) {\n      u = parent[i][u];\n      v = parent[i][v];\n    }\n  }\n  return parent[0][u];\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tint i, j, ii, jj, last;\n\tif(source == sink) return source;\n\tso = si = 0;\n\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\n\t// ルートから順番に追ってみて、同じ親じゃなくなったら\n\t// ひとつ前のノードを結果とする\n\tnode = root;\n\tlast = si > so ? si : so;\n\tfor(i=si-1, j=so-1, ii=si-last, jj=so-last;(i>= 0 && j>=0);i--,j--,ii++,jj++) {\n\t\tif(so_list[j] != si_list[i]) {\n\t\t\treturn node;\n\t\t}\n\t\tnode = so_list[j];\n\t\t\n\t\tif(so_list[jj] == si_list[ii]) {\n\t\t\treturn so_list[jj];\n\t\t}\n\t}\n\t\n\treturn node;\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint T,S[4*200010],N[200010];\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return (a<0||b<0)?(a<0?b:a):N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<T;i++)S[T+i]=i<n?i:-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){//printf(\"%d %d %d %d %d\\n\",a,b,i,l,r);\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],r=0,fi[100010],ID[200010];\nvoid ldfs(int s,int d){\n  int i;\n  N[fi[s]=r]=d;\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(fi[to[i]]+1)continue;\n    ldfs(to[i],d+1);\n    N[r]=d;\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  ldfs(p,r=0);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b])+1,1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=fi[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",ID[alca(i,j)]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint is_visits[MAX_NODE];\nint _result;\nint _root;\n\nint solve(int source, int sink, int now_node, int p_node) {\n\tint i,size,result;\n\tif(is_visits[now_node] == 1) return -1;\n\tif(now_node == sink) return p_node;\n\tif(_root == now_node) {\n\t\t_result = _root;\n\t\treturn _root;\n\t}\n\n\tis_visits[now_node] = 1;\n\tfor(i=0,size=n_size[now_node];i<size;i++) {\n\t\tif(sink == node[now_node][i]) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t\tif(is_visits[node[now_node][i]] == 1) continue;\n\t\t\n\t\tresult = solve(source, sink, node[now_node][i], p_node);\n\t\tif(sink == result) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t}\n\t\n\tif(_result >= 0) {\n\t\treturn _result;\n\t}\n\treturn solve(source, sink, parent[now_node], parent[now_node]);\n}\n\nint main(void) {\n\tint i, j, x, m, n, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tn_size[i] = m;\n\t\tif(m>0) node[i] = (int*)malloc(m*sizeof(int));\n\t\t\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &node[i][j]);\n\t\t\tis_root[node[i][j]] = -1;\n\t\t\tparent[node[i][j]] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\t_root = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\t_result = -1;\n\t\tfor(j=0;j<n;j++) is_visits[j] = 0;\t// 訪れたかどうか\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tif(source == sink) {\n\t\t\tprintf(\"%d\\n\", source);\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", solve(source, sink, source, source));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint* route[MAX_NODE];\nint* r_size[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint solve(int source, int sink, int root) {\n\tint node, so_visit, si_visit;\n\tint i, j;\n\tif(source == sink) return source;\n\tso = si = 0;\n\tso_visit = si_visit = 0;\n\t\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\troute[source] = (int*)malloc(so*sizeof(int));\n\tmemcpy(route[source], so_list, sizeof(so*sizeof(int)));\n\tr_size[node] = so;\n\t\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\troute[node] = (int*)malloc(si*sizeof(int));\n\tmemcpy(route[node], si_list, sizeof(si*sizeof(int)));\n\tr_size[node] = si;\n\n\t// ルートから順番に追ってみて、同じ親じゃなくなったら\n\t// ひとつ前のノードを結果とする\n\tnode = root;\n\tfor(i=si-1, j=so-1; i>= 0 && j>=0; i--, j--) {\n\t\tif(so_list[j] != si_list[i]) {\n\t\t\treturn node;\n\t\t}\n\n\t\tnode = so_list[j];\n\t}\n\t\n\treturn node;\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\troute[i] = NULL;\n\t\tr_size[i] = 0;\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define bit(n,m)(((n)>>(m))&1)\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g,c;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[200010];//適宜変える\n\tint id[100010];//適宜変える\n}G;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\nint csort(const void*a,const void*b){\n\tll p=(*(E*)a).c,q=(*(E*)b).c;\n\treturn p<q?-1:p>q?1:0;\n}\n\nG g;\nvoid readgraph(){\n\t//適宜変える\n\tll n;\n\tscanf(\"%lld\",&n);\n\tll m=0;\n\trep(i,0,n){\n\t\tll k;\n\t\tscanf(\"%lld\",&k);\n\t\twhile(k--){\n\t\t\tll t;\n\t\t\tscanf(\"%lld\",&t);\n\t\t\tg.e[m].s=i;\n\t\t\tg.e[m].g=t;\n\t\t\tm++;\n\t\t}\n\t}\n\tg.vcnt=n;\n\tg.ecnt=m;\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\n\n//LCA\n//*\n#define VCNT 100010\nint dep[VCNT];\nint oya[20][VCNT];\n#undef VCNT\nvoid lcainitdfs(int v){\n\trep(i,g.id[v],g.id[v+1]){\n\t\tif(!dep[g.e[i].g]){\n\t\t\toya[0][g.e[i].g]=v;\n\t\t\tdep[g.e[i].g]=dep[v]+1;\n\t\t\tlcainitdfs(g.e[i].g);\n\t\t}\n\t}\n}\nvoid lcainit(int root){\n\tdep[root]=1;\n\tlcainitdfs(root);\n\trep(k,1,20)rep(v,0,g.vcnt)oya[k][v]=oya[k-1][oya[k-1][v]];\n}\nint lca(int u,int v){\n\tint du=dep[u];\n\tint dv=dep[v];\n\tif(du<dv){\n\t\tint t;\n\t\tt=du;du=dv;dv=t;\n\t\tt= u; u= v; v=t;\n\t}\n\trep(k,0,20)if(bit(du-dv,k))u=oya[k][u];\n \n\tif(u==v)return u;\n\tfor(int k=19;k>=0;k--)if(oya[k][u]!=oya[k][v]){\n\t\tu=oya[k][u];\n\t\tv=oya[k][v];\n\t}\n\treturn oya[0][u];\n}\n//*/\n\nint main(){\n\treadgraph();\n\tlcainit(0);\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tprintf(\"%d\\n\",lca(x,y));\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint solve(int source, int sink, int root) {\n\tint node, so_visit, si_visit;\n\tint i, j;\n\tif(source == sink) return source;\n\tso = si = 0;\n\tso_visit = si_visit = 0;\n\t\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\t\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\n\t// ルートから順番に追ってみて、同じ親じゃなくなったら\n\t// ひとつ前のノードを結果とする\n\tnode = root;\n\tfor(i=si-1, j=so-1; i>= 0 && j>=0; i--, j--) {\n\t\tif(so_list[j] != si_list[i]) {\n\t\t\treturn node;\n\t\t}\n\n\t\tnode = so_list[j];\n\t}\n\t\n\treturn node;\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tn_size[i] = m;\n\t\tif(m>0) node[i] = (int*)malloc(m*sizeof(int));\n\t\t\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &node[i][j]);\n\t\t\tis_root[node[i][j]] = -1;\n\t\t\tparent[node[i][j]] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tif(source == sink) return source;\n\tso = si = 0;\n\t\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\t\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\t\n\t// ルートから順番に追ってみて、同じ親じゃなくなったら\n\t// ひとつ前のノードを結果とする\n\tnode = root;\n\tfor(;--si && --so;) {\n\t\tif(so_list[so] != si_list[si]) {\n\t\t\treturn node;\n\t\t}\n\t\tnode = so_list[so];\n\t}\n\t\n\treturn node;\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tn_size[i] = m;\n\t\tif(m>0) node[i] = (int*)malloc(m*sizeof(int));\n\t\t\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &node[i][j]);\n\t\t\tis_root[node[i][j]] = -1;\n\t\t\tparent[node[i][j]] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_NODE (100000)\n#define MAX_DEPTH (16)\n#define MAX_PAIR (4096)\n\ntypedef struct _Pair{\n    int source;\n    int sink;\n    int result;\n} Pair;\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\nint tree_cache[MAX_NODE][MAX_DEPTH];\nint t_size[MAX_NODE];\n\nPair _pair[MAX_NODE];\nint _ps = 0;\n\nvoid init_cache(int root, int n) {\n    int i,j,node;\n    for(i=0;i<n;i++) {\n        t_size[i] = -1;\n        tree_cache[i][0] = i;\n        for(j=1;j<MAX_DEPTH;j++) {\n            node = parent[tree_cache[i][j-1]];\n            tree_cache[i][j] = node;\n            if(node == root) {\n                printf(\"ddd %d\\n\", j+1);\n                t_size[i] = j + 1;\n                break;\n            }\n        }\n    }\n}\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n    int i, node;\n    int middle = (left + right) / 2;\n    if(right - left < 40) {\n        for(i=left,node=root;i<=right;i++) {\n            if(so[i] == si[i]) {\n                return so[i];\n            }\n        }\n        return node;\n    }\n    \n    if(so[middle] != si[middle]) {\n        return binary_search(middle, right, so, si, root);\n    }\n    \n    return binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n    int node;\n    int last;\n    int result;\n    int i;\n    int* p_so_list = so_list;\n    int* p_si_list = si_list;\n    if(source == sink) return source;\n    so = si = 0;\n    for(i=0;i<_ps;i++) {\n        if(_pair[i].source == source && _pair[i].sink == sink) {\n            return _pair[i].result;\n        }\n    }\n\n    // sourceからrootへ行く際に通るnodeを登録\n    if(t_size[source] == -1) {\n        node = source;\n        while(node != root) {\n            so_list[so++] = node;\n            node = parent[node];\n        }\n        so_list[so++] = node;\n    } else {\n        p_so_list = tree_cache[source];\n        so = t_size[source];\n    }\n\n    // sinkからrootへ行く際に通るnodeを登録\n    if(t_size[sink] == -1) {\n        node = sink;\n        while(node != root) {\n            si_list[si++] = node;\n            node = parent[node];\n        }\n        si_list[si++] = node;\n    } else {\n        p_si_list = tree_cache[sink];\n        si = t_size[sink];\n    }\n\n    _pair[_ps].source = source;\n    _pair[_ps].sink = sink;\n    if(si > so) {\n        last = si - so;\n        return _pair[_ps++].result = binary_search(0, so, p_so_list, &p_si_list[last], root);\n    }\n    \n    last = so - si;\n    return _pair[_ps++].result = binary_search(0, si, &p_so_list[last], p_si_list, root);\n    \n}\n\nint main(void) {\n    int i, j, m, n, t, q;\n    int source, sink;\n    int is_root[MAX_NODE] = {0};\n    int root;\n    \n    scanf(\"%d\\n\", &n);\n    for(i=0;i<n;i++) {\n        scanf(\"%d\", &m);\n\n        for(j=0;j<m;j++) {\n            scanf(\"%d\", &t);\n            is_root[t] = -1;\n            parent[t] = i;\n        }\n    }\n    \n    // ルート\n    root = 0;\n    for(i=0;i<n;i++) {\n        if(is_root[i] == 0) {\n            root = i;\n            break;\n        }\n    }\n    \n    // 浅いものはあらかじめ作っておく\n    init_cache(root, n);\n    \n    scanf(\"%d\\n\", &q);\n    for(i=0;i<q;i++) {\n        scanf(\"%d %d\\n\" ,&source, &sink);\n        printf(\"%d\\n\", solve(source, sink, root));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_NODE (100000)\n#define MAX_DEPTH (16)\n#define MAX_PAIR (4096)\n\ntypedef struct _Pair{\n    int source;\n    int sink;\n    int result;\n} Pair;\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\nint tree_cache[MAX_NODE][MAX_DEPTH];\nint t_size[MAX_NODE];\n\nPair _pair[MAX_NODE];\nint _ps = 0;\n\nvoid init_cache(int root, int n) {\n    int i,j,node;\n    for(i=0;i<n;i++) {\n        t_size[i] = -1;\n        tree_cache[i][0] = i;\n        for(j=1;j<MAX_DEPTH;j++) {\n            node = parent[tree_cache[i][j-1]];\n            tree_cache[i][j] = node;\n            if(node == root) {\n                t_size[i] = j + 1;\n                break;\n            }\n        }\n    }\n}\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n    int i, node;\n    int middle = (left + right) / 2;\n    if(right - left < 40) {\n        for(i=left,node=root;i<=right;i++) {\n            if(so[i] == si[i]) {\n                return so[i];\n            }\n        }\n        return node;\n    }\n    \n    if(so[middle] != si[middle]) {\n        return binary_search(middle, right, so, si, root);\n    }\n    \n    return binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n    int node;\n    int last;\n    int result;\n    int i;\n    int* p_so_list = so_list;\n    int* p_si_list = si_list;\n    if(source == sink) return source;\n    so = si = 0;\n    for(i=0;i<_ps;i++) {\n        if(_pair[i].source == source && _pair[i].sink == sink) {\n            return _pair[i].result;\n        }\n    }\n\n    // sourceからrootへ行く際に通るnodeを登録\n    if(t_size[source] == -1) {\n        node = source;\n        while(node != root) {\n            so_list[so++] = node;\n            node = parent[node];\n        }\n        so_list[so++] = node;\n    } else {\n        p_so_list = tree_cache[source];\n        so = t_size[source];\n    }\n\n    // sinkからrootへ行く際に通るnodeを登録\n    if(t_size[sink] == -1) {\n        node = sink;\n        while(node != root) {\n            si_list[si++] = node;\n            node = parent[node];\n        }\n        si_list[si++] = node;\n    } else {\n        p_si_list = tree_cache[sink];\n        si = t_size[sink];\n    }\n\n    _pair[_ps].source = source;\n    _pair[_ps].sink = sink;\n    if(si > so) {\n        last = si - so;\n        return _pair[_ps++].result = binary_search(0, so, p_so_list, &p_si_list[last], root);\n    }\n    \n    last = so - si;\n    return _pair[_ps++].result = binary_search(0, si, &p_so_list[last], p_si_list, root);\n    \n}\n\nint main(void) {\n    int i, j, m, n, t, q;\n    int source, sink;\n    int is_root[MAX_NODE] = {0};\n    int root;\n    \n    scanf(\"%d\\n\", &n);\n    for(i=0;i<n;i++) {\n        scanf(\"%d\", &m);\n\n        for(j=0;j<m;j++) {\n            scanf(\"%d\", &t);\n            is_root[t] = -1;\n            parent[t] = i;\n        }\n    }\n    \n    // ルート\n    root = 0;\n    for(i=0;i<n;i++) {\n        if(is_root[i] == 0) {\n            root = i;\n            break;\n        }\n    }\n\t\n\tfor(i=0;i<MAX_NODE;i++) {\n\t\t\n\t}\n    \n    // 浅いものはあらかじめ作っておく\n    init_cache(root, n);\n    \n    scanf(\"%d\\n\", &q);\n    for(i=0;i<q;i++) {\n        scanf(\"%d %d\\n\" ,&source, &sink);\n        printf(\"%d\\n\", solve(source, sink, root));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_NODE (100000)\n#define MAX_DEPTH (64)\n#define MAX_PAIR (4096)\n\ntypedef struct _Pair{\n    int source;\n    int sink;\n    int result;\n} Pair;\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\nint tree_cache[MAX_NODE][MAX_DEPTH];\nint t_size[MAX_NODE];\n\nPair _pair[MAX_NODE];\nint _ps = 0;\n\nvoid init_cache(int root, int n) {\n    int i,j,node;\n    for(i=0;i<n;i++) {\n        t_size[i] = -1;\n        tree_cache[i][0] = i;\n        for(j=1;j<MAX_DEPTH;j++) {\n            node = parent[tree_cache[i][j-1]];\n            tree_cache[i][j] = node;\n            if(node == root) {\n                t_size[i] = j + 1;\n                break;\n            }\n        }\n    }\n}\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n    int i, node;\n    int middle = (left + right) / 2;\n    if(right - left < 40) {\n        for(i=left,node=root;i<=right;i++) {\n            if(so[i] == si[i]) {\n                return so[i];\n            }\n        }\n        return node;\n    }\n    \n    if(so[middle] != si[middle]) {\n        return binary_search(middle, right, so, si, root);\n    }\n    \n    return binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n    int node;\n    int last;\n    int result;\n    int i;\n    int* p_so_list = so_list;\n    int* p_si_list = si_list;\n    if(source == sink) return source;\n    so = si = 0;\n    for(i=0;i<_ps;i++) {\n        if(_pair[i].source == source && _pair[i].sink == sink) {\n            return _pair[i].result;\n        }\n    }\n\n    // sourceからrootへ行く際に通るnodeを登録\n    if(t_size[source] == -1) {\n        node = source;\n        while(node != root) {\n            so_list[so++] = node;\n            node = parent[node];\n        }\n        so_list[so++] = node;\n    } else {\n        p_so_list = tree_cache[source];\n        so = t_size[source];\n    }\n\n    // sinkからrootへ行く際に通るnodeを登録\n    if(t_size[sink] == -1) {\n        node = sink;\n        while(node != root) {\n            si_list[si++] = node;\n            node = parent[node];\n        }\n        si_list[si++] = node;\n    } else {\n        p_si_list = tree_cache[sink];\n        si = t_size[sink];\n    }\n\n    _pair[_ps].source = source;\n    _pair[_ps].sink = sink;\n    if(si > so) {\n        last = si - so;\n        return _pair[_ps++].result = binary_search(0, so, p_so_list, &p_si_list[last], root);\n    }\n    \n    last = so - si;\n    return _pair[_ps++].result = binary_search(0, si, &p_so_list[last], p_si_list, root);\n    \n}\n\nint main(void) {\n    int i, j, m, n, t, q;\n    int source, sink;\n    int is_root[MAX_NODE] = {0};\n    int root;\n    \n    scanf(\"%d\\n\", &n);\n    for(i=0;i<n;i++) {\n        scanf(\"%d\", &m);\n\n        for(j=0;j<m;j++) {\n            scanf(\"%d\", &t);\n            is_root[t] = -1;\n            parent[t] = i;\n        }\n    }\n    \n    // ルート\n    root = 0;\n    for(i=0;i<n;i++) {\n        if(is_root[i] == 0) {\n            root = i;\n            break;\n        }\n    }\n\t\n\tfor(i=0;i<MAX_NODE;i++) {\n\t\t\n\t}\n    \n    // 浅いものはあらかじめ作っておく\n    init_cache(root, n);\n    \n    scanf(\"%d\\n\", &q);\n    for(i=0;i<q;i++) {\n        scanf(\"%d %d\\n\" ,&source, &sink);\n        printf(\"%d\\n\", solve(source, sink, root));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n\tint i, node;\n\tint middle = (left + right) / 2;\n\tif(right - left < 16) {\n\t\tfor(i=left,node=root;i<=right;i++) {\n//\t\t\tprintf(\"%d %d %d %d\\n\", so[i], si[i], right, left);\n\t\t\tif(so[i] == si[i]) {\n\t\t\t\treturn so[i];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tif(so[middle] != si[middle]) {\n\t\treturn binary_search(middle, right, so, si, root);\n\t}\n\t\n\treturn binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tint last;\n\tif(source == sink) return source;\n\tso = si = 0;\n\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\tso_list[so++] = node;\n\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\tsi_list[si++] = node;\n\n\tif(si > so) {\n\t\tlast = si - so;\n\t\treturn binary_search(0, so, so_list, &si_list[last], root);\n\t}\n\t\n\tlast = so - si;\n\treturn binary_search(0, si, &so_list[last], si_list, root);\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint is_visits[MAX_NODE];\nint _result;\n\nint solve(int source, int sink, int now_node, int p_node) {\n\tint i,size,result;\n\tif(is_visits[now_node] == 1) return -1;\n\tif(now_node == sink) return p_node;\n\n\tis_visits[now_node] = 1;\n\tfor(i=0,size=n_size[now_node];i<size;i++) {\n\t\tif(sink == node[now_node][i]) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t\tif(is_visits[node[now_node][i]] == 1) continue;\n\t\t\n\t\tresult = solve(source, sink, node[now_node][i], p_node);\n\t\tif(sink == result) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t}\n\t\n\tif(_result >= 0) {\n\t\treturn _result;\n\t}\n\treturn solve(source, sink, parent[now_node], parent[now_node]);\n}\n\nint main(void) {\n\tint i, j, x, m, n, q;\n\tint source, sink;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tn_size[i] = m;\n\t\tif(m>0) node[i] = (int*)malloc(m*sizeof(int));\n\t\t\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &node[i][j]);\n\t\t\tparent[node[i][j]] = i;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\t_result = -1;\n\t\tfor(j=0;j<n;j++) is_visits[j] = 0;\t// 訪れたかどうか\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tif(source == sink) {\n\t\t\tprintf(\"%d\\n\", source);\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", solve(source, sink, source, source));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint binary_search(int left, int right, int* so, int* si) {\n\tint i, node;\n\tint middle = (left + right) / 2;\n\tif(right - left < 40) {\n\t\tfor(i=left,node=so[left];i<=right;i++) {\n\t\t\tif(so[i] == si[i]) {\n\t\t\t\treturn so[i];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tif(so[middle] != si[middle]) {\n\t\treturn binary_search(middle, right, so, si);\n\t}\n\t\n\treturn binary_search(left, middle, so, si);\n}\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tint last;\n\tif(source == sink) return source;\n\tso = si = 0;\n\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\tsi_list[so++] = node;\n\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\tsi_list[si++] = node;\n\n\tif(si > so) {\n\t\tlast = si - so;\n\t\treturn binary_search(0, so, so_list, &si_list[last]);\n\t}\n\t\n\tlast = so - si;\n\treturn binary_search(0, si, &so_list[last], si_list);\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint is_visits[MAX_NODE];\nint _result;\n\nint solve(int source, int sink, int now_node, int p_node) {\n\tint i,size,result;\n\tif(is_visits[now_node] == 1) return -1;\n\tif(source == sink) return source;\n\tif(now_node == sink) return p_node;\n\n\tis_visits[now_node] = 1;\n\tfor(i=0,size=n_size[now_node];i<size;i++) {\n\t\tif(sink == node[now_node][i]) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t\tif(is_visits[node[now_node][i]] == 1) continue;\n\t\t\n\t\tresult = solve(source, sink, node[now_node][i], now_node);\n\t\tif(sink == result) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t}\n\t\n\tif(_result >= 0) {\n\t\treturn _result;\n\t}\n\treturn solve(source, sink, parent[now_node], parent[now_node]);\n}\n\nint main(void) {\n\tint i, j, x, m, n, q;\n\tint source, sink;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tn_size[i] = m;\n\t\tif(m>0) node[i] = (int*)malloc(m*sizeof(int));\n\t\t\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &node[i][j]);\n\t\t\tparent[node[i][j]] = i;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\t_result = -1;\n\t\tfor(j=0;j<n;j++) is_visits[j] = 0;\t// 訪れたかどうか\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, source, source));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n#define MAX_DEPTH (16)\n\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\nint tree_cache[MAX_NODE][MAX_DEPTH];\nint t_size[MAX_NODE];\n\nvoid init_cache(int root, int n) {\n\tint i,j,node;\n\tfor(i=0;i<n;i++) {\n\t\ttree_cache[i][0] = i;\n\t\tfor(j=1;j<MAX_DEPTH;j++) {\n\t\t\tnode = parent[tree_cache[i][j-1]];\n\t\t\ttree_cache[i][j] = node;\n\t\t\tif(node == root) {\n\t\t\t\tt_size[i] = j + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n\tint i, node;\n\tint middle = (left + right) / 2;\n\tif(right - left < 40) {\n\t\tfor(i=left,node=root;i<=right;i++) {\n\t\t\tif(so[i] == si[i]) {\n\t\t\t\treturn so[i];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tif(so[middle] != si[middle]) {\n\t\treturn binary_search(middle, right, so, si, root);\n\t}\n\t\n\treturn binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tint last;\n\tint* p_so_list = so_list;\n\tint* p_si_list = si_list;\n\tif(source == sink) return source;\n\tso = si = 0;\n\n\t// sourceからrootへ行く際に通るnodeを登録\n\tif(t_size[source] == -1) {\n\t\tnode = source;\n\t\twhile(node != root) {\n\t\t\tso_list[so++] = node;\n\t\t\tnode = parent[node];\n\t\t}\n\t\tso_list[so++] = node;\n\t} else {\n\t\tp_so_list = tree_cache[source];\n\t\tso = t_size[source];\n\t}\n\n\t// sinkからrootへ行く際に通るnodeを登録\n\tif(t_size[sink] == -1) {\n\t\tnode = sink;\n\t\twhile(node != root) {\n\t\t\tsi_list[si++] = node;\n\t\t\tnode = parent[node];\n\t\t}\n\t\tsi_list[si++] = node;\n\t} else {\n\t\tp_si_list = tree_cache[sink];\n\t\tsi = t_size[sink];\n\t}\n\n\tif(si > so) {\n\t\tlast = si - so;\n\t\treturn binary_search(0, so, p_so_list, &p_si_list[last], root);\n\t}\n\t\n\tlast = so - si;\n\treturn binary_search(0, si, &p_so_list[last], p_si_list, root);\n\t\n}\n\nint main(void) {\n\tint i, j, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tt_size[i] = -1;\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// 浅いものはあらかじめ作っておく\n\tinit_cache(root, n);\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint is_visits[MAX_NODE];\nint _result;\n\nint solve(int source, int sink, int now_node, int p_node) {\n\tint i,size,result;\n\tif(is_visits[now_node] == 1) return -1;\n\tif(source == sink) return parent[source];\n\tif(now_node == sink) return p_node;\n\n\tis_visits[now_node] = 1;\n\tfor(i=0,size=n_size[now_node];i<size;i++) {\n\t\tif(sink == node[now_node][i]) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t\tif(is_visits[node[now_node][i]] == 1) continue;\n\t\t\n\t\tresult = solve(source, sink, node[now_node][i], p_node);\n\t\tif(sink == result) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t}\n\t\n\tif(_result >= 0) {\n\t\treturn _result;\n\t}\n\treturn solve(source, sink, parent[now_node], parent[now_node]);\n}\n\nint main(void) {\n\tint i, j, x, m, n, q;\n\tint source, sink;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tn_size[i] = m;\n\t\tif(m>0) node[i] = (int*)malloc(m*sizeof(int));\n\t\t\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &node[i][j]);\n\t\t\tparent[node[i][j]] = i;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\t_result = -1;\n\t\tfor(j=0;j<n;j++) is_visits[j] = 0;\t// 訪れたかどうか\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, source, source));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint is_visits[MAX_NODE];\nint _result;\n\nint solve(int source, int sink, int now_node, int p_node) {\n\tint i,size,result;\n\tif(is_visits[now_node] == 1) return -1;\n\tif(source == sink) return parent[source];\n\tif(now_node == sink) return p_node;\n\n\tis_visits[now_node] = 1;\n\tfor(i=0,size=n_size[now_node];i<size;i++) {\n\t\tif(sink == node[now_node][i]) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t\tif(is_visits[node[now_node][i]] == 1) continue;\n\t\t\n\t\tresult = solve(source, sink, node[now_node][i], p_node);\n\t\tif(sink == result) {\n\t\t\t_result = p_node;\n\t\t\treturn p_node;\n\t\t}\n\t}\n\t\n\tif(_result >= 0) {\n\t\treturn _result;\n\t}\n\treturn solve(source, sink, parent[now_node], parent[now_node]);\n}\n\nint main(void) {\n\tint i, j, x, m, n, q;\n\tint source, sink;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tn_size[i] = m;\n\t\tif(m>0) node[i] = (int*)malloc(m*sizeof(int));\n\t\t\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &node[i][j]);\n\t\t\tparent[node[i][j]] = i;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\t_result = -1;\n\t\tfor(j=0;j<n;j++) is_visits[j] = 0;\t// 訪れたかどうか\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, source, parent[source]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint T,S[4*200010],N[200010];\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return (a<0||b<0)?(a<0?b:a):N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<T;i++)S[T+i]=i<n?i:-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){//printf(\"%d %d %d %d %d\\n\",a,b,i,l,r);\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],d[100010],r=0,fi[100010],ID[200010];\nvoid ldfs(int s){\n  int i;\n  N[fi[s]=r]=d[s];\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(d[to[i]])continue;\n    d[to[i]]=d[s]+1;\n    ldfs(to[i]);\n    N[r]=d[s];\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  d[p]=1;\n  r=0;\n  ldfs(p);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b])+1,1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",ID[alca(i,j)]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint* tree_cache[MAX_NODE];\nint t_size[MAX_NODE];\n\nvoid init_tree(int root, int* leafs, int leaf_size) {\n\tint i,j,node,id;\n\tint cache[MAX_NODE];\n\t\n\t// 葉の要素だけ実体化する\n\tfor(i=0;i<leaf_size;i++) {\n\t\tid = leafs[i];\n\t\tcache[0] = id;\n\t\tfor(j=1;j<MAX_NODE;j++) {\n\t\t\tnode = parent[cache[j-1]];\n\t\t\tcache[j] = node;\n\t\t\tif(node == root) {\n\t\t\t\tt_size[id] = j + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttree_cache[id] = (int*)malloc(t_size[id]*sizeof(int));\n\t\tfor(j=0;j<t_size[id];j++) tree_cache[id][j] = cache[j];\n\n\t\t// 途中の要素はポインタを設定\n\t\tfor(j=1;j<t_size[id];j++) {\n\t\t\tnode = tree_cache[id][j];\n\t\t\ttree_cache[node] = &tree_cache[id][j];\n\t\t\tt_size[node] = t_size[id] - j;\n\t\t}\n\t}\n}\n\nvoid clear_tree(int* leafs, int leaf_size) {\n\tint i;\n\tfor(i=0;i<leaf_size;i++) \n\t\tfree(tree_cache[leafs[i]]);\n}\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n\tint i, node;\n\tint middle = (left + right) / 2;\n\tif(right - left < 40) {\n\t\tfor(i=left,node=root;i<=right;i++) {\n\t\t\tif(so[i] == si[i]) {\n\t\t\t\treturn so[i];\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tif(so[middle] != si[middle]) {\n\t\treturn binary_search(middle, right, so, si, root);\n\t}\n\t\n\treturn binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n\tint node;\n\tint last;\n\tint* p_so_list;\n\tint* p_si_list;\n\tint so, si;\n\tif(source == sink) return source;\n\tso = si = 0;\n\n\tp_so_list = tree_cache[source];\n\tso = t_size[source];\n\tp_si_list = tree_cache[sink];\n\tsi = t_size[sink];\n\n\tif(si > so) {\n\t\tlast = si - so;\n\t\treturn binary_search(0, so, p_so_list, &p_si_list[last], root);\n\t}\n\t\n\tlast = so - si;\n\treturn binary_search(0, si, &p_so_list[last], p_si_list, root);\n\t\n}\n\nint main(void) {\n\tint i, j, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint leafs[MAX_NODE];\n\tint leaf_size = 0;\n\tint root;\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\t\tif(m == 0) leafs[leaf_size++] = i;\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\tt_size[i] = -1;\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinit_tree(root, leafs, leaf_size);\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\t\n\tclear_tree(leafs, leaf_size);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint parent[MAX_NODE] = {0};\nint* tree_cache[MAX_NODE];\nint t_size[MAX_NODE];\n\nvoid init_tree(int root, int* leafs, int leaf_size) {\n    int i,j,node,id;\n    int cache[MAX_NODE];\n    \n    // 葉の要素だけ実体化する\n    for(i=0;i<leaf_size;i++) {\n        id = leafs[i];\n        cache[0] = id;\n        for(j=1;j<MAX_NODE;j++) {\n            node = parent[cache[j-1]];\n            cache[j] = node;\n            if(node == root) {\n                t_size[id] = j + 1;\n                break;\n            }\n        }\n        tree_cache[id] = (int*)malloc(t_size[id]*sizeof(int));\n        for(j=0;j<t_size[id];j++) tree_cache[id][j] = cache[j];\n\n        // 途中の要素はポインタを設定\n        for(j=1;j<t_size[id];j++) {\n            node = tree_cache[id][j];\n            tree_cache[node] = &tree_cache[id][j];\n            t_size[node] = t_size[id] - j;\n        }\n    }\n}\n\nint binary_search(int left, int right, int* so, int* si, int root) {\n    int i, node;\n    int middle = (left + right) / 2;\n    if(right - left < 40) {\n        for(i=left,node=root;i<=right;i++) {\n            if(so[i] == si[i]) {\n                return so[i];\n            }\n        }\n        return node;\n    }\n    \n    if(so[middle] != si[middle]) {\n        return binary_search(middle, right, so, si, root);\n    }\n    \n    return binary_search(left, middle, so, si, root);\n}\n\nint solve(int source, int sink, int root) {\n    int node;\n    int last;\n    int* p_so_list;\n    int* p_si_list;\n    int so, si;\n    if(source == sink) return source;\n    so = si = 0;\n\n    p_so_list = tree_cache[source];\n    so = t_size[source];\n    p_si_list = tree_cache[sink];\n    si = t_size[sink];\n\n    if(si > so) {\n        last = si - so;\n        return binary_search(0, so, p_so_list, &p_si_list[last], root);\n    }\n    \n    last = so - si;\n    return binary_search(0, si, &p_so_list[last], p_si_list, root);\n    \n}\n\nint main(void) {\n    int i, j, m, n, t, q;\n    int source, sink;\n    int is_root[MAX_NODE] = {0};\n    int leafs[MAX_NODE];\n    int leaf_size = 0;\n    int root;\n\n    scanf(\"%d\\n\", &n);\n    for(i=0;i<n;i++) {\n        scanf(\"%d\", &m);\n        if(m == 0) leafs[leaf_size++] = i;\n\n        for(j=0;j<m;j++) {\n            scanf(\"%d\", &t);\n            is_root[t] = -1;\n            parent[t] = i;\n        }\n    }\n    \n    // ルート\n    root = 0;\n    for(i=0;i<n;i++) {\n        t_size[i] = -1;\n        if(is_root[i] == 0) {\n            root = i;\n            break;\n        }\n    }\n\n    init_tree(root, leafs, leaf_size);\n    \n    scanf(\"%d\\n\", &q);\n    for(i=0;i<q;i++) {\n        scanf(\"%d %d\\n\" ,&source, &sink);\n        printf(\"%d\\n\", solve(source, sink, root));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint T,S[4*200010],N[200010];\nint MIN(int a,int b){return a<b?a:b;}\nint MAX(int a,int b){return a<b?b:a;}\n//????????¢??°?????????MIN???\nint hyoka(int a,int b){return (a<0||b<0)?(a<0?b:a):N[a]<N[b]?a:b;}\n//?????°??¨?????????n?????°???d??§?????????????§????\nvoid sset(int n){\n  int i;\n  for(T=1;T<n;T*=2);\n  for(i=0;i<T;i++)S[T+i]=i<n?i:-1;\n  for(i=T-1;i;i--)S[i]=hyoka(S[i*2],S[i*2+1]);\n}\n//?????°??¨???update??¢??°\n//i???????????°??????n????????´???????§????\nvoid sud(int i,int n){for(N[i+=T]=n;i/=2;)S[i]=hyoka(S[i*2],S[i*2+1]);}\n//?????°??¨???find??¢??°\n//[a,b)????????????????????????sout(a,b,1,0,T);\nint sout(int a,int b,int i,int l,int r){//printf(\"%d %d %d %d %d\\n\",a,b,i,l,r);\n  if(r<=a||b<=l)return -1;\n  if(a<=l&&r<=b)return S[i];\n  return hyoka(sout(a,b,i*2,l,(l+r)/2),sout(a,b,i*2+1,(l+r)/2,r));\n}\nint ta[100010],to[100010],nt[100010],d[100010],r=0,fi[100010],ID[200010];\nvoid ldfs(int s){\n  int i;\n  N[fi[s]=r]=d[s];\n  ID[r++]=s;\n  for(i=ta[s];i+1;i=nt[i]){\n    if(d[to[i]])continue;\n    d[to[i]]=d[s]+1;\n    ldfs(to[i]);\n    N[r]=d[s];\n    ID[r++]=s;\n  }\n}\nvoid slca(int p){\n  d[p]=1;\n  ldfs(p);\n  sset(r);\n}\nint alca(int a,int b){return sout(MIN(fi[a],fi[b]),MAX(fi[a],fi[b])+1,1,0,T);}\nint main(){\n  int n,m,i,j,e=0;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)ta[i]=-1;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d\",&j);\n      nt[e]=ta[i];\n      to[e]=j;\n      ta[i]=e++;\n    }\n  }\n  slca(0);\n  while(n--){\n    scanf(\"%d %d\",&i,&j);\n    printf(\"%d\\n\",ID[alca(i,j)]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ GRL_5_C Lowest Common Ancestor\n// 2018.5.5 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse {\n//\t\tif (n < 0) pc('-'), n = -n;\n\t\ti = 0; while (n) ob[i++] = n%10 + '0', n/=10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n\tpc('\\n');\n}\n\n\n#define INF 0x30303030\n\n// セグメント木の初期化\nint seg[1<<19]; int sz;\n\nvoid segtree(int n, int init_val)\n{\n\tint i;\n\n\tsz = 2; while (sz < n) sz <<= 1;\n\tn = sz << 1;\n//\tmemset(seg, init_val, n << 2);\n\tfor (i = 0; i < n; i++) seg[i] = init_val;\n}\n\n// RMQのインデックス部分を一括して更新\nvoid update()\n{\n\tint i, k, n, p, v;\n\n\tn = sz;\twhile (n > 0) {\n\t\tfor (p = n-1, i = 0; i < n; i+=2, p+=2) {\n\t\t\tk = p >> 1;\n\t\t\tv = seg[p+1]; if (v > seg[p]) v = seg[p];\n\t\t\tseg[k] = v;\n\t\t}\n\t\tn >>= 1;\n\t}\n}\n\nint query2(int a, int b, int k, int l, int r) \n{\n\tint m, lmin, rmin;\n\n\tif (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return seg[k];\n\tk <<= 1, m = (l+r) >> 1;\n    lmin = query2(a, b, k+1, l, m);\n    rmin = query2(a, b, k+2, m, r);\n\tif (lmin > rmin) lmin = rmin;\n    return lmin; \n}\n\n// 空間 [a, b] 内の最小値\nint range_min_query(int a, int b)\n{\n\treturn query2(a, b+1, 0, 0, sz);\n}\n\n\n// LCA\n#define MAX_V  100005\nint hi[MAX_V], *to[MAX_V];\nint root;\nint vs[MAX_V << 1];\nint depth[MAX_V << 1];\nint id[MAX_V];\n\nvoid dfs(int v, int p, int d, int *k)\n{\n\tint i;\n\n\tid[v] = *k;\n\tvs[*k] = v;\n\tdepth[(*k)++] = d;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\tif (to[v][i] != p) {\n\t\t\tdfs(to[v][i], v, d+1, k);\n\t\t\tvs[*k] = v;\n\t\t\tdepth[(*k)++] = d;\n\t\t}\n\t}\n}\n\nint lca(int u, int v)\n{\n\tint min, max;\n\tif (id[u] < id[v]) min = id[u], max = id[v];\n\telse               min = id[v], max = id[u];\n\treturn vs[range_min_query(min, max)];\n}\n\nint main()\n{\n\tint n, q, j, k, u, v, sz;\n\tint *memo;\n\n\tn = in();\n\tmemo = malloc(n<<3);\n\tsz = 0; for (u = 0; u < n; u++) {\n\t\tk = in();\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tmemo[sz++] = u, memo[sz++] = v = in();\n\t\t\thi[u]++, hi[v]++;\n\t\t}\n\t}\n\n\tfor (u = 0; u < n; u++) if (hi[u]) to[u] = malloc(hi[u]<<2);\n\tmemset(hi, 0, n<<2);\n\tj = 0; while (j < sz) {\n\t\tu = memo[j++], v = memo[j++];\n\t\tto[u][hi[u]++] = v, to[v][hi[v]++] = u;\n\t}\n\n\troot = 0;\n\tk = 0;\n\tdfs(root, -1, 0, &k);\n\tn = (n<<1)-1;\n\tsegtree(n, INF);\n\n\tj = sz-1;\n\tfor (u = 0; u < n; u++) seg[j++] = depth[u];\n\tupdate();\n\n\tq = in();\n\twhile (q--) {\n\t\tu = in(), v = in();\n\t\tout(lca(u, v));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NODE (100000)\n\nint* node[MAX_NODE];\nint* route[MAX_NODE];\nint* r_size[MAX_NODE];\nint n_size[MAX_NODE] = {0};\nint parent[MAX_NODE] = {0};\nint so_list[MAX_NODE];\nint si_list[MAX_NODE];\nint so;\nint si;\n\nint solve(int source, int sink, int root) {\n\tint node, so_visit, si_visit;\n\tint i, j;\n\tif(source == sink) return source;\n\tso = si = 0;\n\tso_visit = si_visit = 0;\n\t\n\t// sourceからrootへ行く際に通るnodeを登録\n\tnode = source;\n\twhile(node != root) {\n\t\tso_list[so++] = node;\n\t\tnode = parent[node];\n\t}\n\n\t// sinkからrootへ行く際に通るnodeを登録\n\tnode = sink;\n\twhile(node != root) {\n\t\tsi_list[si++] = node;\n\t\tnode = parent[node];\n\t}\n\n\t// ルートから順番に追ってみて、同じ親じゃなくなったら\n\t// ひとつ前のノードを結果とする\n\tnode = root;\n\tfor(i=si-1, j=so-1; i>= 0 && j>=0; i--, j--) {\n\t\tif(so_list[j] != si_list[i]) {\n\t\t\treturn node;\n\t\t}\n\n\t\tnode = so_list[j];\n\t}\n\t\n\treturn node;\n\t\n}\n\nint main(void) {\n\tint i, j, x, m, n, t, q;\n\tint source, sink;\n\tint is_root[MAX_NODE] = {0};\n\tint root;\n\t\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\", &m);\n\n\t\tfor(j=0;j<m;j++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tis_root[t] = -1;\n\t\t\tparent[t] = i;\n\t\t}\n\t}\n\t\n\t// ルート\n\troot = 0;\n\tfor(i=0;i<n;i++) {\n\t\troute[i] = NULL;\n\t\tr_size[i] = 0;\n\t\tif(is_root[i] == 0) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\\n\", &q);\n\tfor(i=0;i<q;i++) {\n\t\tscanf(\"%d %d\\n\" ,&source, &sink);\n\t\tprintf(\"%d\\n\", solve(source, sink, root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable{\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", 1024L*1024*64).start();\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tGraph g = new Graph(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint k = io.nextInt();\n\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\tg.addBidirectionalEdge(i, io.nextInt());\n\t\t\t}\n\t\t}\n\t\tHLDecomposition hl = g.rootedTree(0).hlDecomposition();\n\t\tint q = io.nextInt();\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tio.println(hl.lca(io.nextInt(), io.nextInt()));\n\t\t}\n\t\tio.flush();\n\t}\n\n}\n//be careful for stack overflow\nclass Graph {\n\tint n;\n\tArrayList<Integer>[] edge;\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tedge = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tedge[i] = new ArrayList<>();\n\t\t}\n\t}\n\tpublic void addBidirectionalEdge(int u,int v) {\n\t\tedge[u].add(v);\n\t\tedge[v].add(u);\n\t}\n\tpublic RootedTree rootedTree(int root) {\n\t\treturn new RootedTree(this,root);\n\t}\n}\nclass RootedTree {\n\tint n;\n\tint root;\n\tArrayList<Integer>[] child;\n\tint[] parent;\n\tint[] in,out;\n\tint[] subTreeSize;\n\t@SuppressWarnings(\"unchecked\")\n\tpublic RootedTree(Graph g,int root) {\n\t\tthis.n = g.n;\n\t\tthis.root = root;\n\t\tchild = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tparent = new int[n];\n\t\tin = new int[n];\n\t\tout = new int[n];\n\t\tsubTreeSize = new int[n];\n\t\tk = 0;\n\t\tdfs(root,-1,g);\n\t}\n\tint k;\n\tprivate void dfs(int v,int p,Graph g) {\n\t\tin[v] = k++;\n\t\tparent[v] = p;\n\t\tsubTreeSize[v] = 1;\n\t\tfor(int u:g.edge[v]) {\n\t\t\tif (u == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchild[v].add(u);\n\t\t\tdfs(u,v,g);\n\t\t\tsubTreeSize[v] += subTreeSize[u];\n\t\t}\n\t\tout[v] = k++;\n\t}\n\tpublic boolean isAncestor(int parent,int child) {\n\t\treturn in[parent] <= in[child] && out[child] <= out[parent];\n\t}\n\tpublic HLDecomposition hlDecomposition() {\n\t\treturn new HLDecomposition(this);\n\t}\n}\nclass HLDecomposition {\n\tRootedTree r;\n\tint[] pathId;\n\tint[] pathIndex;\n\tint[] pathRoot;\n\tint pathnum;\n\tint[] pathSize;\n\tpublic HLDecomposition(RootedTree r) {\n\t\tthis.r = r;\n\t\tint n = r.n;\n\t\tpathId = new int[n];\n\t\tpathIndex = new int[n];\n\t\tpathRoot = new int[n];\n\t\tpathSize = new int[n];\n\t\tpathnum = 1;\n\t\tdfs(r.root,0,0,0);\n//\t\tSystem.out.println(Arrays.toString(pathId));\n//\t\tSystem.out.println(Arrays.toString(pathIndex));\n//\t\tSystem.out.println(Arrays.toString(pathRoot));\n//\t\tSystem.out.println(pathnum);\n//\t\tSystem.out.println(Arrays.toString(pathSize));\n\t}\n\tprivate void dfs(int v,int pid,int pindex,int proot) {\n\t\tpathId[v] = pid;\n\t\tpathIndex[v] = pindex;\n\t\tpathRoot[v] = proot;\n\t\tif (r.child[v].size() == 0) {\n\t\t\tpathSize[pid] = pindex + 1;\n\t\t\treturn;\n\t\t}\n\t\tint maxsize = -1;\n\t\tint maxu = -1;\n\t\tfor(int u:r.child[v]) {\n\t\t\tif (r.subTreeSize[u] > maxsize) {\n\t\t\t\tmaxsize = r.subTreeSize[u];\n\t\t\t\tmaxu = u;\n\t\t\t}\n\t\t}\n\t\tfor(int u:r.child[v]) {\n\t\t\tif (u == maxu) {\n\t\t\t\tdfs(u,pid,pindex+1,proot);\n\t\t\t}else{\n\t\t\t\tdfs(u,pathnum++,0,u);\n\t\t\t}\n\t\t}\n\t}\n//\tpublic ArrayList<Query> query(int first,int last) {\n//\t\tArrayList<Query> head = new ArrayList<>();\n//\t\tArrayList<Query> tail = new ArrayList<>();\n//\t\twhile(pathId[first] != pathId[last]) {\n//\t\t\tif (r.level[first] >= r.level[last]) {\n//\t\t\t\thead.add(new Query(pathId[first] , pathIndex[first], 0));\n//\t\t\t\tfirst = pathParent[first];\n//\t\t\t}else{\n//\t\t\t\ttail.add(new Query(pathId[last],0,pathIndex[last]));\n//\t\t\t\tlast = pathParent[last];\n//\t\t\t}\n//\t\t}\n//\t\thead.add(new Query(pathId[first],pathIndex[first],pathIndex[last]));\n//\t\tfor(int i=tail.size()-1;i>=0;i--) {\n//\t\t\thead.add(tail.get(i));\n//\t\t}\n//\t\treturn head;\n//\t}\n//\tpublic ArrayList<Query> queryIgnoreDirection(int u,int v) {\n//\t\tArrayList<Query> ans = query(u,v);\n//\t\tfor(Query p:ans) {\n//\t\t\tif (p.first > p.last) {\n//\t\t\t\tint temp = p.first;\n//\t\t\t\tp.first = p.last;\n//\t\t\t\tp.last = temp;\n//\t\t\t}\n//\t\t}\n//\t\treturn ans;\n//\t}\n\tpublic int lca(int u,int v) {\n\t\twhile(!r.isAncestor(pathRoot[u], v)) {\n\t\t\tu = r.parent[pathRoot[u]];\n\t\t}\n\t\twhile(!r.isAncestor(pathRoot[v], u)) {\n\t\t\tv = r.parent[pathRoot[v]];\n\t\t}\n\t\treturn r.isAncestor(u, v) ? u : v;\n\t}\n\tstatic class Query {\n\t\tint pathId;\n\t\tint first,last;\n\t\tpublic Query(int pathId,int first,int last) {\n\t\t\tthis.pathId = pathId;\n\t\t\tthis.first = first;\n\t\t\tthis.last = last;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn pathId + \":[\" + first + \",\" + last + \"]\";\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class TarjanLCA {\n\n        Node root;\n        List<Node> nodeList;\n        boolean[] checked;\n        int[] ancestor;\n        LinkedList<Query>[] queryArray;\n        int[] results;\n        UnionFind uf;\n        static int nextQueryId = 0;\n\n        @SuppressWarnings(\"unchecked\")\n        public TarjanLCA(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            queryArray = new LinkedList[n];\n            for (int i = 0; i < n; i++) {\n                queryArray[i] = new LinkedList<Query>();\n            }\n            checked = new boolean[n];\n            uf = new UnionFind(n);\n            ancestor = new int[n];\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public void addQuery(int node1, int node2) {\n            Query query = new Query(node2, nextQueryId++);\n            queryArray[node1].add(query);\n            if (node1 != node2) {\n                query = new Query(node1, query.order);\n                queryArray[node2].add(query);\n            }\n        }\n\n        public int[] computeAnswers() {\n            results = new int[nextQueryId];\n            boolean[] expanded = new boolean[nodeList.size()];\n            Stack<Node> dfsStack = new Stack<Node>();\n            dfsStack.push(root);\n\n            while (!dfsStack.isEmpty()) {\n                Node current = dfsStack.peek();\n                if (!expanded[current.id]) {\n                    ancestor[current.id] = current.id;\n                    for (Node child : current.children) {\n                        dfsStack.push(child);\n                    }\n                    expanded[current.id] = true;\n                } else {\n                    checked[current.id] = true;\n                    ListIterator<Query> it = queryArray[current.id].listIterator();\n                    while (it.hasNext()) {\n                        Query q = it.next();\n                        if (checked[q.idOther]) {\n//                            it.remove();\n                            results[q.order] = nodeList.get(ancestor[uf.find(q.idOther)]).id;\n                        }\n                    }\n                    \n                    if (current.parent != null) {\n                        int childId = current.id;\n                        int parentId = current.parent.id;\n                        uf.union(parentId, childId);\n                        ancestor[uf.find(childId)] = parentId;\n                    }\n\n                    dfsStack.pop();\n                }\n            }\n\n            return results;\n        }\n\n        static class Query {\n\n            final int idOther;\n            final int order;\n\n            public Query(int idOther, int order) {\n                this.idOther = idOther;\n                this.order = order;\n            }\n        }\n\n        static class Node {\n\n            int id;\n            Node parent;\n            List<Node> children;\n\n            public Node(int id) {\n                children = new ArrayList<Node>();\n                this.id = id;\n            }\n\n            public Node(int id, Node parent) {\n                this.id = id;\n                this.parent = parent;\n                children = new ArrayList<Node>();\n                if (parent != null) {\n                    parent.children.add(this);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TarjanLCA tarjan = new TarjanLCA(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            tarjan.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            tarjan.addQuery(node1, node2);\n        }\n        for (int lca : tarjan.computeAnswers()) {\n            out.println(lca);\n        }\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static class UnionFind {\n\n        int[] id;\n        int count;\n        int[] weight;  // size indexed by root id\n\n        public UnionFind(int n) {\n            id = new int[n];\n            weight = new int[n];\n            count = n;\n            for (int idx = 0; idx < id.length; idx++) {\n                id[idx] = idx;\n                weight[idx] = 1;\n            }\n        }\n\n        public void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return;\n            }\n            // make smaller root point to larger one\n            if (weight[pRoot] < weight[qRoot]) {\n                id[pRoot] = qRoot;\n                weight[qRoot] += weight[pRoot];\n            } else {\n                id[qRoot] = pRoot;\n                weight[pRoot] += weight[qRoot];\n            }\n            count--;\n        }\n\n        // path compression\n        public int find(int p) {\n            if (id[p] != p) {\n                id[p] = find(id[p]);\n            }\n            return id[p];\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public int count() {\n            return count;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] depth;\n\tstatic int[][] parents;\n\n\tstatic void initLca(int[][][] g, int r) {\n\t\tint n = g.length;\n\t\tint[] parent = new int[n];\n\t\tdepth = new int[n]; // todo global\n\t\tdfsLca(g, parent, depth, r, -1, 0);\n\n\t\tparents = parents(parent); // todo global\n\t}\n\n\tstatic void dfsLca(int[][][] g, int[] parent, int[] depth, int cur, int prev, int d) {\n\t\tparent[cur] = prev;\n\t\tdepth[cur] = d;\n\n\t\tfor (int[] to : g[cur]) {\n\t\t\tif (to[0] == prev) continue;\n\t\t\tdfsLca(g, parent, depth, to[0], cur, d+1);\n\t\t}\n\t}\n\n\tstatic int[][] parents(int[] parent) {\n\t\tint n = parent.length;\n\t\tint logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n-1))+1;\n\n\t\tint[][] res = new int[logN][n];\n\t\tres[0] = parent;\n\n\t\tfor (int k=0; k<logN-1; k++) {\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tif (res[k][i] < 0) res[k+1][i] = -1;\n\t\t\t\telse res[k+1][i] = res[k][res[k][i]];\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic int lca(int u, int v, int[][] parents, int[] depth) {\n\t\tif (depth[u] > depth[v]) {\n\t\t\tint t = u; u = v; v = t;\n\t\t}\n\n\t\tint logN = parents.length;\n\t\tint n = parents[0].length;\n\n\t\tfor (int k=0; k<logN; k++) {\n\t\t\tif (((depth[v] - depth[u])>>k&1) == 1) {\n\t\t\t\tv = parents[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\n\t\tfor (int k=logN-1; k>=0; k--) {\n\t\t\tif (parents[k][u] != parents[k][v]) {\n\t\t\t\tu = parents[k][u];\n\t\t\t\tv = parents[k][v];\n\t\t\t}\n\t\t}\n\n\t\treturn parents[0][u];\n\t}\n\n\tstatic int[][][] undirectedGraph(int n, int[] v1, int[] v2, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : v1) cnt[i]++;\n\t\tfor (int i : v2) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<v1.length; i++) {\n\t\t\tint s = v1[i];\n\t\t\tint t = v2[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\n\t\t\tg[t][--cnt[t]][0] = s;\n\t\t\tg[t][cnt[t]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic void solve() {\n\t\tint n = in.nextInt();\n\t\tint r = -1;\n\n\t\tArrayList<int[]> list = new ArrayList<>();\n\t\tboolean[] refed = new boolean[n];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint k = in.nextInt();\n\t\t\tfor (int j=0; j<k; j++) {\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tlist.add(new int[]{i, c});\n\t\t\t\trefed[c] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (!refed[i]) {\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\n\t\tint e = list.size();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = list.get(i)[0];\n\t\t\tt[i] = list.get(i)[1];\n\t\t\tc[i] = 0;\n\t\t}\n\n\t\tint[][][] g = undirectedGraph(n, s, t, c);\n\t\tinitLca(g, r);\n\n\t\tint q = in.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tout.println(lca(u, v, parents, depth));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main implements Runnable {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] depth;\n\tstatic int[][] parents;\n\n\tstatic void initLca(int[][][] g, int r) {\n\t\tint n = g.length;\n\t\tint[] parent = new int[n];\n\t\tdepth = new int[n]; // todo global\n\t\tdfsLca(g, parent, depth, r, -1, 0);\n\n\t\tparents = parents(parent); // todo global\n\t}\n\n\tstatic void dfsLca(int[][][] g, int[] parent, int[] depth, int cur, int prev, int d) {\n\t\tparent[cur] = prev;\n\t\tdepth[cur] = d;\n\n\t\tfor (int[] to : g[cur]) {\n\t\t\tif (to[0] == prev) continue;\n\t\t\tdfsLca(g, parent, depth, to[0], cur, d+1);\n\t\t}\n\t}\n\n\tstatic int[][] parents(int[] parent) {\n\t\tint n = parent.length;\n\t\tint logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n-1))+1;\n\n\t\tint[][] res = new int[logN][n];\n\t\tres[0] = parent;\n\n\t\tfor (int k=0; k<logN-1; k++) {\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tif (res[k][i] < 0) res[k+1][i] = -1;\n\t\t\t\telse res[k+1][i] = res[k][res[k][i]];\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic int lca(int u, int v, int[][] parents, int[] depth) {\n\t\tif (depth[u] > depth[v]) {\n\t\t\tint t = u; u = v; v = t;\n\t\t}\n\n\t\tint logN = parents.length;\n\t\tint n = parents[0].length;\n\n\t\tfor (int k=0; k<logN; k++) {\n\t\t\tif (((depth[v] - depth[u])>>k&1) == 1) {\n\t\t\t\tv = parents[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\n\t\tfor (int k=logN-1; k>=0; k--) {\n\t\t\tif (parents[k][u] != parents[k][v]) {\n\t\t\t\tu = parents[k][u];\n\t\t\t\tv = parents[k][v];\n\t\t\t}\n\t\t}\n\n\t\treturn parents[0][u];\n\t}\n\n\tstatic int[][][] undirectedGraph(int n, int[] v1, int[] v2, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : v1) cnt[i]++;\n\t\tfor (int i : v2) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<v1.length; i++) {\n\t\t\tint s = v1[i];\n\t\t\tint t = v2[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\n\t\t\tg[t][--cnt[t]][0] = s;\n\t\t\tg[t][cnt[t]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tpublic void run() {\n\t\tint n = in.nextInt();\n\t\tint r = -1;\n\n\t\tArrayList<int[]> list = new ArrayList<>();\n\t\tboolean[] refed = new boolean[n];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint k = in.nextInt();\n\t\t\tfor (int j=0; j<k; j++) {\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tlist.add(new int[]{i, c});\n\t\t\t\trefed[c] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (!refed[i]) {\n\t\t\t\tr = i;\n\t\t\t}\n\t\t}\n\n\t\tint e = list.size();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = list.get(i)[0];\n\t\t\tt[i] = list.get(i)[1];\n\t\t\tc[i] = 0;\n\t\t}\n\n\t\tint[][][] g = undirectedGraph(n, s, t, c);\n\t\tinitLca(g, r);\n\n\t\tint q = in.nextInt();\n\t\twhile (q-- > 0) {\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tout.println(lca(u, v, parents, depth));\n\t\t}\n\n\t\tout.flush();\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class Main {\n\n    static class TarjanLCA {\n\n        Node root;\n        List<Node> nodeList;\n        boolean[] checked;\n        int[] ancestor;\n        LinkedList<Query> queryList;\n        int[] results;\n        UnionFind uf;\n\n        public TarjanLCA(int n) {\n            queryList = new LinkedList<Query>();\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n\n        }\n\n        public void addQuery(int node1, int node2) {\n            Query query = new Query(node1, node2);\n            queryList.add(query);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int[] computeAnswers() {\n            results = new int[Query.nextOrder];\n            checked = new boolean[nodeList.size()];\n            uf = new UnionFind(nodeList.size());\n            ancestor = new int[nodeList.size()];\n\n            LCA(root);\n\n            return results;\n        }\n\n        private void LCA(Node node) {\n            int id = node.name;\n            ancestor[id] = id;\n            for (Node child : node.children) {\n                LCA(child);\n                if (queryList.isEmpty()) {\n                    return;\n                }\n                int childId = child.name;\n                uf.union(id, childId);\n                ancestor[uf.find(childId)] = id;\n            }\n            checked[id] = true;\n\n            ListIterator<Query> it = queryList.listIterator();\n            while (it.hasNext()) {\n                Query q = it.next();\n                int id1 = q.name1;\n                int id2 = q.name2;\n                if (checked[id1] && checked[id2] && uf.connected(id, id1) && uf.connected(id, id2)) {\n                    it.remove();\n                    results[q.order] = nodeList.get(id).name;\n                }\n            }\n\n        }\n\n        static class Query {\n\n            final int name1;\n            final int name2;\n            int order;\n            static int nextOrder = 0;\n\n            public Query(int name1, int name2) {\n                this.name1 = name1;\n                this.name2 = name2;\n                order = nextOrder++;\n            }\n        }\n\n        static class Node {\n\n            int name;\n            Node parent;\n            List<Node> children;\n\n            public Node(int id) {\n                children = new ArrayList<Node>();\n                name = id;\n            }\n\n            public Node(int name, Node parent) {\n                this.name = name;\n                this.parent = parent;\n                children = new ArrayList<Node>();\n                if (parent != null) {\n                    parent.children.add(this);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TarjanLCA tarjan = new TarjanLCA(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx<childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            tarjan.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            tarjan.addQuery(node1, node2);\n        }\n        for (int lca : tarjan.computeAnswers()) {\n            out.println(lca);\n        }\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static class UnionFind {\n\n        int[] id;\n        int count;\n        int[] weight;  // size indexed by root id\n\n        public UnionFind(int n) {\n            id = new int[n];\n            weight = new int[n];\n            count = n;\n            for (int idx = 0; idx < id.length; idx++) {\n                id[idx] = idx;\n                weight[idx] = 1;\n            }\n        }\n\n        public void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return;\n            }\n            // make smaller root point to larger one\n            if (weight[pRoot] < weight[qRoot]) {\n                id[pRoot] = qRoot;\n                weight[qRoot] += weight[pRoot];\n            } else {\n                id[qRoot] = pRoot;\n                weight[pRoot] += weight[qRoot];\n            }\n            count--;\n        }\n\n        // path compression\n        public int find(int p) {\n            if (id[p] != p) {\n                id[p] = find(id[p]);\n            }\n            return id[p];\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public int count() {\n            return count;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    public static Node lowestCommonAncestor(TreeHelper treeHelper, int id1, int id2) {\n        List<Node> pAncestors = new ArrayList<Node>();\n        List<Node> qAncestors = new ArrayList<Node>();\n        Stack<Node> ancestors = new Stack<Node>();\n        Stack<Node> dfsStack = new Stack<Node>();\n        dfsStack.push(treeHelper.root);\n\n        Node p = treeHelper.getNodeAt(id1);\n        Node q = treeHelper.getNodeAt(id2);\n        if (p == null || q == null) {\n            return null;\n        }\n        while (p != null || q != null) {  // when p or q is found, they are set to null\n            if (dfsStack.isEmpty()) {\n                break;\n            }\n            Node current = dfsStack.peek();\n            if (ancestors.isEmpty() || ancestors.peek() != current) {\n                // current not expanded\n                for (Node child : current.children) {\n                    dfsStack.push(child);\n                }\n                ancestors.push(current);\n            } else {\n                if (p == current) {\n                    pAncestors.addAll(ancestors);\n                    p = null;\n                }\n                if (q == current) {\n                    // q and p cannot match same node\n                    qAncestors.addAll(ancestors);\n                    q = null;\n                }\n                dfsStack.pop();\n                ancestors.pop();\n            }\n        }\n\n        for (int i = 0; i < pAncestors.size(); i++) {\n            if (i + 1 < pAncestors.size() && i + 1 < qAncestors.size()\n                    && qAncestors.get(i + 1) == pAncestors.get(i + 1)) {\n                continue;\n            } else {\n                return pAncestors.get(i);\n            }\n        }\n        // should not reach here\n        return null;\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            out.println(lowestCommonAncestor(treeHelper, node1, node2).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        SegmentTree segTree;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n                } else {\n                    dfsStack.pop();\n                    depth--;\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n                    }\n                }\n            }\n            segTree = new SegmentTree(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1VisitIdx = h[n1.id];\n            int n2VisitIdx = h[n2.id];\n            int leftVisitIdx = Math.min(n1VisitIdx, n2VisitIdx);\n            int rightVisitIdx = Math.max(n1VisitIdx, n2VisitIdx);\n            int minIdx = segTree.queryIndex(leftVisitIdx, rightVisitIdx);\n            int lcaIdx = euler[minIdx];\n            return treeHelper.nodeList.get(lcaIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n    public static class SegmentTree {\n\n        int[] tree;\n        int n;\n        int[] rawArray;\n\n        public SegmentTree(int[] rawArray) {\n            n = 1;\n            while (n < rawArray.length) {\n                n <<= 1;\n            }\n            tree = new int[2 * n - 1];\n            this.rawArray = rawArray;\n            initTree(0, 0, n - 1, rawArray);\n        }\n\n        /**\n         * @param idx of tree[]\n         * @param rangeBegin of raw[]\n         * @param rangeEnd of raw[]\n         */\n        private void initTree(int idx, int rangeBegin, int rangeEnd, int[] rawArray) {\n            if (rangeBegin >= rawArray.length) {\n                return;\n            }\n            if (rangeBegin == rangeEnd) {\n                tree[idx] = rangeBegin;\n            } else {\n                initTree(idx * 2 + 1, rangeBegin, (rangeEnd + rangeBegin) / 2, rawArray);\n                initTree(idx * 2 + 2, (rangeEnd + rangeBegin) / 2 + 1, rangeEnd, rawArray);\n                tree[idx] = rawArray[tree[idx * 2 + 1]] < rawArray[tree[idx * 2 + 2]] ? tree[idx * 2 + 1] : tree[idx * 2 + 2];\n            }\n        }\n\n        /**\n         *\n         * @param left\n         * @param right\n         * @return index of min\n         */\n        public int queryIndex(int left, int right) {\n            return queryIndex(0, 0, n - 1, left, right);\n        }\n\n        public void update(int idx, int newValue) {\n            rawArray[idx] = newValue;\n            int treeIdx = idx + n - 1;\n            tree[treeIdx] = idx;\n            while (treeIdx > 0) {\n                treeIdx = (treeIdx - 1) / 2;\n                tree[treeIdx] = rawArray[tree[treeIdx * 2 + 1]] < rawArray[tree[treeIdx * 2 + 2]]\n                        ? tree[treeIdx * 2 + 1] : tree[treeIdx * 2 + 2];\n            }\n        }\n\n        /**\n         * Invariant: rangeBegin <= left <= right <= rangeEnd\n         */\n        private int queryIndex(int idx, int rangeBegin, int rangeEnd, int left, int right) {\n            int leftMinIdx = -1;\n            int rightMinIdx = -1;\n            if (rangeBegin == rangeEnd) {\n                return tree[idx];\n            }\n            if (left == rangeBegin && right == rangeEnd) {\n                return tree[idx];\n            }\n            int rangeMid = (rangeBegin + rangeEnd) / 2;\n            if (left <= rangeMid) {\n                leftMinIdx = queryIndex(idx * 2 + 1, rangeBegin, rangeMid, left, Math.min(right, rangeMid));\n            }\n            if (rangeMid + 1 <= right) {\n                rightMinIdx = queryIndex(idx * 2 + 2, rangeMid + 1, rangeEnd, Math.max(left, rangeMid + 1), right);\n            }\n\n            if (leftMinIdx == -1) {\n                return rightMinIdx;\n            } else if (rightMinIdx == -1) {\n                return leftMinIdx;\n            } else {\n                return rawArray[leftMinIdx] < rawArray[rightMinIdx] ? leftMinIdx : rightMinIdx;\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] g = new ArrayList[n];\n\t\t\tg = Stream.generate(ArrayList::new).limit(n).toArray(List[]::new);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint m = in.nextInt();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tg[i].add(in.nextInt());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLCA lca = new LCA(g, 0);\n\t\t\tint q = in.nextInt();\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tint u = in.nextInt();\n\t\t\t\tint v = in.nextInt();\n\t\t\t\tint l = lca.lca(u, v);\n\t\t\t\tout.println(l);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tpublic static class LCA {\n\n\t\tprivate final int logN;\n\t\tprivate final int n;\n\t\tprivate final List<Integer>[] graph;\n\t\tprivate final int[][] par;\n\t\tpublic final int[] depth;\n\n\t\tpublic LCA(List<Integer>[] g, int root) {\n\t\t\tthis.graph = g;\n\t\t\tthis.n = g.length;\n\t\t\tthis.logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\t\tthis.par = new int[logN][n];\n\t\t\tthis.depth = new int[n];\n\n\t\t\tinit(root);\n\t\t}\n\n\t\tprivate void init(int root) {\n\t\t\tbfs(root);\n\t\t\tfor (int k = 0; k < logN - 1; k++) {\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (par[k][v] < 0)\n\t\t\t\t\t\tpar[k + 1][v] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpar[k + 1][v] = par[k][par[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void bfs(int v) {\n\t\t\tArrays.fill(depth, Integer.MAX_VALUE);\n\t\t\tArrayDeque<Integer> queue = new ArrayDeque<Integer>();\n\t\t\tqueue.add(v);\n\t\t\tdepth[v] = 0;\n\t\t\tpar[0][v] = -1;\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tint now = queue.poll();\n\t\t\t\tfor (int p : graph[now]) {\n\t\t\t\t\tif (depth[p] > depth[now] + 1) {\n\t\t\t\t\t\tdepth[p] = depth[now] + 1;\n\t\t\t\t\t\tqueue.add(p);\n\t\t\t\t\t\tpar[0][p] = now;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic int lca(int u, int v) {\n\t\t\tif (depth[u] > depth[v]) {\n\t\t\t\tint tmp = u;\n\t\t\t\tu = v;\n\t\t\t\tv = tmp;\n\t\t\t}\n\t\t\tfor (int k = 0; k < logN; k++) {\n\t\t\t\tif (((depth[v] - depth[u]) >> k & 1) == 1)\n\t\t\t\t\tv = par[k][v];\n\t\t\t}\n\t\t\tif (u == v)\n\t\t\t\treturn u;\n\n\t\t\tfor (int k = logN - 1; k >= 0; k--) {\n\t\t\t\tif (par[k][u] != par[k][v]) {\n\t\t\t\t\tu = par[k][u];\n\t\t\t\t\tv = par[k][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn par[0][u];\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint n = sc.nextInt();\n\t\tGraph g = new Graph(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint k = sc.nextInt();\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tg.add(i, c);\n\t\t\t}\n\t\t}\n\n\t\tLCA lca = new LCA(g, 0);\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tint l = lca.lca(u, v);\n\t\t\tSystem.out.println(l);\n\t\t}\n\t}\n\n}\n\nclass LCA {\n\tprivate final int logN;\n\tprivate final int n;\n\tprivate final Graph graph;\n\tprivate final int[][] par;\n\tpublic final int[] depth;\n\n\tpublic LCA(Graph g, int root) {\n\t\tthis.graph = g;\n\t\tthis.n = g.size();\n\t\tthis.logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tthis.par = new int[logN][n];\n\t\tthis.depth = new int[n];\n\n\t\tinit(root);\n\t}\n\n\tprivate void init(int root) {\n\t\t// dfs(root, -1, 0);\n\t\tbfs(root);\n\t\tfor (int k = 0; k < logN - 1; k++) {\n\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\tif (par[k][v] < 0)\n\t\t\t\t\tpar[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tpar[k + 1][v] = par[k][par[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void bfs(int v) {\n\t\tArrays.fill(depth, Integer.MAX_VALUE);\n\t\tArrayDeque<Integer> queue = new ArrayDeque<Integer>();\n\t\tqueue.add(v);\n\t\tdepth[v] = 0;\n\t\tpar[0][v] = -1;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint now = queue.poll();\n\t\t\tfor (Graph.Path p : graph.get(now)) {\n\t\t\t\tif (depth[p.to] > depth[now] + 1) {\n\t\t\t\t\tdepth[p.to] = depth[now] + 1;\n\t\t\t\t\tqueue.add(p.to);\n\t\t\t\t\tpar[0][p.to] = now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int lca(int u, int v) {\n\t\tif (depth[u] > depth[v]) {\n\t\t\tint tmp = u;\n\t\t\tu = v;\n\t\t\tv = tmp;\n\t\t}\n\t\tfor (int k = 0; k < logN; k++) {\n\t\t\tif (((depth[v] - depth[u]) >> k & 1) == 1)\n\t\t\t\tv = par[k][v];\n\t\t}\n\t\tif (u == v)\n\t\t\treturn u;\n\n\t\tfor (int k = logN - 1; k >= 0; k--) {\n\t\t\tif (par[k][u] != par[k][v]) {\n\t\t\t\tu = par[k][u];\n\t\t\t\tv = par[k][v];\n\t\t\t}\n\t\t}\n\t\treturn par[0][u];\n\t}\n}\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(n, 1)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(n, 1)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nclass Graph {\n\tpublic static class Path implements Comparable<Path> {\n\t\tpublic final int from;\n\t\tpublic final int to;\n\t\tpublic final long cost;\n\n\t\tpublic Path(int from, int to, long cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Path o) {\n\t\t\treturn Long.compare(this.cost, o.cost);\n\t\t}\n\t}\n\n\tprivate final List<List<Path>> edgeList;\n\tprivate final int size;\n\n\tpublic Graph(int n) {\n\t\tthis.size = n;\n\t\tthis.edgeList = new ArrayList<List<Path>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tthis.edgeList.add(new ArrayList<Path>());\n\t\t}\n\t}\n\n\tpublic void add(int from, int to, long cost) {\n\t\tthis.edgeList.get(from).add(new Path(from, to, cost));\n\t}\n\n\tpublic void addBoth(int v1, int v2, long cost) {\n\t\tthis.add(v1, v2, cost);\n\t\tthis.add(v2, v1, cost);\n\t}\n\n\tpublic void add(int from, int to) {\n\t\tthis.edgeList.get(from).add(new Path(from, to, 1));\n\t}\n\n\tpublic void addBoth(int v1, int v2) {\n\t\tthis.add(v1, v2, 1);\n\t\tthis.add(v2, v1, 1);\n\t}\n\n\tpublic List<Path> get(int from) {\n\t\treturn this.edgeList.get(from);\n\t}\n\n\tpublic int size() {\n\t\treturn this.size;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\n\npublic class Main {\n\n    static class TarjanLCA {\n\n        Node root;\n        List<Node> nodeList;\n        boolean[] checked;\n        int[] ancestor;\n        LinkedList<Query> queryList;\n        int[] results;\n        UnionFind uf;\n\n        public TarjanLCA(int n) {\n            queryList = new LinkedList<Query>();\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n\n        }\n\n        public void addQuery(int node1, int node2) {\n            Query query = new Query(node1, node2);\n            queryList.add(query);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int[] computeAnswers() {\n            results = new int[Query.nextOrder];\n            checked = new boolean[nodeList.size()];\n            uf = new UnionFind(nodeList.size());\n            ancestor = new int[nodeList.size()];\n\n            LCA(root);\n\n            return results;\n        }\n\n        private void LCA(Node node) {\n            int id = node.name;\n            ancestor[id] = id;\n            for (Node child : node.children) {\n                LCA(child);\n                if (queryList.isEmpty()) {\n                    return;\n                }\n                int childId = child.name;\n                uf.union(id, childId);\n                ancestor[uf.find(childId)] = id;\n            }\n            checked[id] = true;\n\n            ListIterator<Query> it = queryList.listIterator();\n            while (it.hasNext()) {\n                Query q = it.next();\n                int id1 = q.name1;\n                int id2 = q.name2;\n                if (checked[id1] && checked[id2] && uf.connected(id, id1) && uf.connected(id, id2)) {\n                    it.remove();\n                    results[q.order] = nodeList.get(id).name;\n                }\n            }\n\n        }\n\n        static class Query {\n\n            final int name1;\n            final int name2;\n            int order;\n            static int nextOrder = 0;\n\n            public Query(int name1, int name2) {\n                this.name1 = name1;\n                this.name2 = name2;\n                order = nextOrder++;\n            }\n        }\n\n        static class Node {\n\n            int name;\n            Node parent;\n            List<Node> children;\n\n            public Node(int id) {\n                children = new ArrayList<Node>();\n                name = id;\n            }\n\n            public Node(int name, Node parent) {\n                this.name = name;\n                this.parent = parent;\n                children = new ArrayList<Node>();\n                if (parent != null) {\n                    parent.children.add(this);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TarjanLCA tarjan = new TarjanLCA(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx<childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            tarjan.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            tarjan.addQuery(node1, node2);\n        }\n        for (int lca : tarjan.computeAnswers()) {\n            out.println(lca);\n        }\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static class UnionFind {\n\n        int[] id;\n        int count;\n        int[] weight;  // size indexed by root id\n\n        public UnionFind(int n) {\n            id = new int[n];\n            weight = new int[n];\n            count = n;\n            for (int idx = 0; idx < id.length; idx++) {\n                id[idx] = idx;\n                weight[idx] = 1;\n            }\n        }\n\n        public void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return;\n            }\n            // make smaller root point to larger one\n            if (weight[pRoot] < weight[qRoot]) {\n                id[pRoot] = qRoot;\n                weight[qRoot] += weight[pRoot];\n            } else {\n                id[qRoot] = pRoot;\n                weight[pRoot] += weight[qRoot];\n            }\n            count--;\n        }\n\n        // path compression\n        public int find(int p) {\n            if (id[p] != p) {\n                id[p] = find(id[p]);\n            }\n            return id[p];\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public int count() {\n            return count;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.*;\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.print(out);\n        pw.flush();\n        pw.close();\n    }\n    public static void solve(StringBuilder out) {\n        int n = In.ni();\n        Tree t = new Tree(n);\n        for (int u = 0; u < n; u++) {\n            int k = In.ni();\n            for (int j = 0; j < k; j++) {\n                int v = In.ni();\n                t.addEdge(u, v);\n            }\n        }\n        DoublingLCA lca = new DoublingLCA(t);\n        int q = In.ni();\n        for (int i = 0; i < q; i++) {\n            int u = In.ni();\n            int v = In.ni();\n            out.append(lca.query(u, v)).append('\\n');\n        }\n    }\n}\n\nfinal class Ints {\n    private static final char[] hex = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    private Ints(){}\n\n    public static int max(final int... a) {\n        int ret = Integer.MIN_VALUE;\n        for (final int e : a) {\n            ret = Math.max(ret, e);\n        }\n        return ret;\n    }\n\n    public static int min(final int... a) {\n        int ret = Integer.MAX_VALUE;\n        for (final int e : a) {\n            ret = Math.min(ret, e);\n        }\n        return ret;\n    }\n\n    public static int reduce(final IntBinaryOperator func, final int... a) {\n        int ret = a[0];\n        for (int i = 1; i < a.length; i++) {\n            ret = func.applyAsInt(ret, a[i]);\n        }\n        return ret;\n    }\n\n    public static boolean isPowerOfTwo(final int n) {\n        return n != 0 && (-n & n) == n;\n    }\n\n    public static int ceilExponent(final int n) {\n        return 31 - Integer.numberOfLeadingZeros(n) + (isPowerOfTwo(n) ? 0 : 1);\n    }\n\n    public static int floorExponent(final int n) {\n        return 31 - Integer.numberOfLeadingZeros(n) + (n == 0 ? 1 : 0);\n    }\n\n    public static String join(final String sep, final int... a) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n}\n\n\n\nfinal class MathUtil{\n    private static final long UNDER32_MASK = 0xffff_ffffl;\n\n    private MathUtil(){}\n\n    /**\n     * caluculate a ^ b NOT considering overflow. so if you want to calculate a ^ b\n     * (mod p), use ModUtil.pow(a, b).\n     * \n     * @param a base\n     * @param b exponent\n     * @return a ^ b\n     */\n    public static long pow(final int a, long b) {\n        long ret = 1l;\n        for (long c = 1, ac = a; b > 0; ac *= ac, c <<= 1) {\n            if ((-b & b) == c) {\n                ret *= ac;\n                b &= ~(-b & b);\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Caluculate the combination nCr NOT considering overflow.\n     * \n     * @param n left\n     * @param r right\n     * @return nCr\n     */\n    public static long comb(long n, long r) {\n        if (n < r)\n            return 0;\n        r = Math.min(r, n - r);\n        long res = 1;\n        for (long d = 1; d <= r; d++) {\n            res *= n--;\n            res /= d;\n        }\n        return res;\n    }\n\n    public static long ceilSqrt(final long n) {\n        long l = -1;\n        long r = n;\n        while (r - l > 1) {\n            final long m = (r + l) >> 1;\n            if (m * m >= n) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        return r;\n    }\n\n    public static long floorSqrt(final long n) {\n        long l = 0;\n        long r = n + 1;\n        while (r - l > 1) {\n            final long m = (r + l) >> 1;\n            if (m * m > n) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        return l;\n    }\n\n    public static long int2ToLong(final int upper, final int lower) {\n        return ((long) upper << Integer.SIZE) | lower;\n    }\n\n    public static int upper32(final long l) {\n        return (int) (l >>> Integer.SIZE);\n    }\n\n    public static int lower32(final long l) {\n        return (int) (l & UNDER32_MASK);\n    }\n}\n\n\n\nfinal class In {\n    public static final FastScanner fsc = new FastScanner();\n\n    public static int ni() {\n        return fsc.nextInt();\n    }\n\n    public static int ni(final IntUnaryOperator f) {\n        return f.applyAsInt(fsc.nextInt());\n    }\n\n    public static int[] ni(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> fsc.nextInt());\n        return a;\n    }\n\n    public static int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> ni(f));\n        return a;\n    }\n\n    public static int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        Arrays.setAll(a, i -> ni(m));\n        return a;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (final IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        } else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(final int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        final long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n            throw new NumberFormatException();\n        }\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\n\n\n\nfinal class IntArrayList implements Iterable<Integer> {\n    private int[] a;\n    private int tail = 0;\n\n    private static final int DEFAULT_SIZE = 64;\n\n    public IntArrayList(final int capacity) {\n        this.a = new int[Math.max(1, capacity)];\n    }\n\n    public IntArrayList() {\n        this(DEFAULT_SIZE);\n    }\n\n    public void add(final int v) {\n        if (tail == a.length) {\n            resize(2);\n        }\n        a[tail++] = v;\n    }\n\n    public int removeLast() {\n        return a[tail--];\n    }\n\n    public int get(final int i) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::get(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        return a[i];\n    }\n\n    public void set(final int i, final int v) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::set(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        a[i] = v;\n    }\n\n    private void resize(final double grow) {\n        final int[] b = new int[(int) Math.ceil(a.length * grow)];\n        System.arraycopy(a, 0, b, 0, a.length);\n        a = b;\n    }\n\n    public int size() {\n        return tail;\n    }\n\n    public void reverse(final int begin, final int end) {\n        IntArrays.reverse(a, begin, end);\n    }\n\n    public void reverse() {\n        IntArrays.reverse(a, 0, tail);\n    }\n\n    public int[] toArray() {\n        final int[] ret = new int[tail];\n        System.arraycopy(a, 0, ret, 0, tail);\n        return ret;\n    }\n\n    public boolean addIf(final int v, final IntPredicate p) {\n        if (p.test(v)) {\n            add(v);\n            return true;\n        }\n        return false;\n    }\n\n    public PrimitiveIterator.OfInt iterator() {\n        return new IntArrayListIterator();\n    }\n\n    private class IntArrayListIterator implements PrimitiveIterator.OfInt {\n        private int i = 0;\n\n        public boolean hasNext() {\n            return i < tail;\n        }\n\n        public int nextInt() {\n            return a[i++];\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for int arrays.\n * 2. methods that receives arrays and return some results (except for int arrays).\n */\nfinal class IntArrays {\n\n    private IntArrays(){}\n\n    public static void swap(final int[] a, final int u, final int v) {\n        final int tmp = a[u];\n        a[u] = a[v];\n        a[v] = tmp;\n    }\n\n    public static void reverse(final int[] a, final int begin, final int end) {\n        for (int i = begin; i < begin + (end - begin) / 2; i++) {\n            swap(a, i, begin + end - i - 1);\n        }\n    }\n\n    public static void reverse(final int[] a) {\n        reverse(a, 0, a.length);\n    }\n\n    public static void sortDescending(final int[] a) {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static int reduce(final int[] a, final IntBinaryOperator op) {\n        int ret = a[0];\n        for (int i = 1; i < a.length; i++) {\n            ret = op.applyAsInt(ret, a[i]);\n        }\n        return ret;\n    }\n\n    public static void map(final int[] a, final IntUnaryOperator op) {\n        Arrays.setAll(a, i -> op.applyAsInt(a[i]));\n    }\n\n    public static void filter(final int[] src, final int[] dst, final IntPredicate p) {\n        int idx = 0;\n        for (final int e : src) {\n            if (p.test(e)) {\n                dst[idx++] = e;\n            }\n        }\n    }\n\n    public static void filterIndex(final int[] dst, final int beginIndex, final int endIndex, final IntPredicate p) {\n        for (int i = beginIndex, idx = 0; i < endIndex; i++) {\n            if (p.test(i)) {\n                dst[idx++] = i;\n            }\n        }\n    }\n\n    public static void filterIndex(final int dst[], final int endIndex, final IntPredicate p) {\n        filterIndex(dst, 0, endIndex, p);\n    }\n\n    public static void accumulate(final int[] a, final IntBinaryOperator op) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] = op.applyAsInt(a[i - 1], a[i]);\n        }\n    }\n\n    public static void accumulate(final int[] a) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] += a[i - 1];\n        }\n    }\n\n    public static int unique(int[] a) {\n        final HashSet<Integer> set = new HashSet<>();\n        for (final int e : a) {\n            set.add(e);\n        }\n        final int m = set.size();\n        final int[] b = new int[m];\n        int index = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (set.contains(a[i])) {\n                b[index++] = a[i];\n                set.remove(a[i]);\n            }\n        }\n        a = b;\n        return m;\n    }\n\n    public static void permute(int[] a, int[] p) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                swap(a, j, p[j]);\n                settled[j] = true;\n            }\n        }\n    }\n\n    public static void transpose(int[][] a) {\n        final int n = a.length;\n        final int m = a[0].length;\n        final int[][] ret = new int[m][n];\n        for (int j = 0; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                ret[j][i] = a[i][j];\n            }\n        }\n        a = ret;\n    }\n\n    public static int compare(final int[] a, final int[] b) {\n        for (int i = 0; i < a.length; i++) {\n            if (i >= b.length) {\n                return -1;\n            } else if (a[i] > b[i]) {\n                return 1;\n            } else if (a[i] < b[i]) {\n                return -1;\n            }\n        }\n        if (a.length < b.length) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    public static boolean equals(final int[] a, final int[] b) {\n        return compare(a, b) == 0;\n    }\n\n    public static String join(final int[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String joinWithPrefixAndSuffix(final int[] a, final IntFunction<String> idxToPre,\n            final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n}\n\n\n\nfinal class DoublingLCA {\n    private final int[] dep;\n    private final Doubling ancestor;\n\n    public DoublingLCA(final Tree t) {\n        this.dep = t.dep();\n        this.ancestor = new Doubling(t.parent(), Ints.max(this.dep));\n    }\n\n    public int query(final int u, int v) {\n        if (dep[u] > dep[v]) {\n            return query(v, u);\n        }\n        v = ancestor.query(v, dep[v] - dep[u]);\n        return ancestor.biStepUntil(u, v, (x, y) -> x == y)[0];\n    }\n}\n\n\n\n\nfinal class Tree {\n    public final int n;\n    public final int root;\n\n    private final IntArrayList[] adj;\n    private final int[] par;\n    private final int[] dep;\n\n    protected boolean bfs = false;\n\n    public Tree(final int n, final int root) {\n        this.n = n;\n        this.root = root;\n        this.adj = new IntArrayList[n];\n        for (int i = 0; i < n; i++) {\n            adj[i] = new IntArrayList();\n        }\n        this.par = new int[n];\n        this.dep = new int[n];\n    }\n\n    public Tree(final int n) {\n        this(n, 0);\n    }\n\n    public void addEdge(final int from, final int to) {\n        adj[from].add(to);\n        adj[to].add(from);\n    }\n\n    public int getEdge(final int from, final int index) {\n        return adj[from].get(index);\n    }\n\n    public IntArrayList getEdges(final int i) {\n        return adj[i];\n    }\n\n    public int out(final int i) {\n        return adj[i].size();\n    }\n\n    public int parent(final int i) {\n        return parent()[i];\n    }\n\n    public int[] parent() {\n        if (!bfs) {\n            bfs();\n            bfs = true;\n        }\n        return par;\n    }\n\n    public int dep(final int i) {\n        return dep()[i];\n    }\n\n    public int[] dep() {\n        if (!bfs) {\n            bfs();\n            bfs = true;\n        }\n        return dep;\n    }\n\n    private void bfs() {\n        final IntQueue que = new IntQueue(n);\n        que.add(root);\n        par[root] = root;\n        while (que.size() > 0) {\n            final int v = que.poll();\n            final PrimitiveIterator.OfInt iter = getEdges(v).iterator();\n            while (iter.hasNext()) {\n                final int u = iter.nextInt();\n                if (u != par[v]) {\n                    dep[u] = dep[v] + 1;\n                    par[u] = v;\n                    que.add(u);\n                }\n            }\n        }\n    }\n}\n\n\n\n@FunctionalInterface\ninterface IntBiPredicate {\n    static final int INT_BIT = 32;\n    static final long MASK = 0xffff_ffffl;\n\n    public boolean test(int x, int y);\n\n    default public IntPredicate curry(final int x) {\n        return y -> test(x, y);\n    }\n\n    default public LongPredicate toLongPredicate() {\n        return l -> test((int) (l >>> INT_BIT), (int) (l & MASK));\n    }\n\n    default public IntBiPredicate negate() {\n        return (x, y) -> !test(x, y);\n    }\n\n    default public IntBiPredicate and(final IntBiPredicate other) {\n        return (x, y) -> test(x, y) && other.test(x, y);\n    }\n\n    default public IntBiPredicate or(final IntBiPredicate other) {\n        return (x, y) -> test(x, y) || other.test(x, y);\n    }\n\n    default public IntBiPredicate xor(final IntBiPredicate other) {\n        return (x, y) -> test(x, y) ^ other.test(x, y);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * Queue for int type.\n */\nfinal class IntQueue implements Iterable<Integer> {\n    private static final int DEFAULT_SIZE = 64;\n\n    private int[] q;\n    private int head = 0;\n    private int tail = 0;\n\n    public IntQueue(final int capacity) {\n        this.q = new int[capacity];\n    }\n\n    public IntQueue() {\n        this(DEFAULT_SIZE);\n    }\n\n    public int peek() {\n        if (head == tail) {\n            throw new NoSuchElementException(\"No Elements.\");\n        }\n        return q[head];\n    }\n\n    public int getFromHead(int index) {\n        if (head + index >= tail || index < 0) {\n            throw new NoSuchElementException(\"Index out of bounds.\");\n        }\n        return q[head + index];\n    }\n\n    public int getFromTail(int index) {\n        if (head + index >= tail || index < 0) {\n            throw new NoSuchElementException(\"Index out of bounds.\");\n        }\n        return q[tail - 1 - index];\n    }\n\n    public void add(final int v) {\n        if (tail == q.length) {\n            grow();\n        }\n        q[tail++] = v;\n    }\n\n    public int poll() {\n        if (head == tail) {\n            throw new NoSuchElementException(\"No Elements.\");\n        }\n        return q[head++];\n    }\n\n    public int size() {\n        return tail - head;\n    }\n\n    private void grow() {\n        final int[] grown = new int[q.length << 1];\n        final int len = size();\n        System.arraycopy(q, head, grown, 0, len);\n        q = grown;\n        tail = len;\n        head = 0;\n    }\n\n    public PrimitiveIterator.OfInt iterator() {\n        return new IntQueueIterator();\n    }\n\n    private class IntQueueIterator implements PrimitiveIterator.OfInt {\n        private int i = head;\n\n        public boolean hasNext() {\n            return i < tail;\n        }\n\n        public int nextInt() {\n            return q[i++];\n        }\n    }\n}\n\n\n\nfinal class Longs {\n    private static final char[] hex = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    private Longs(){}\n\n    public static long max(final long... a) {\n        long ret = Long.MIN_VALUE;\n        for (final long e : a) {\n            ret = Math.max(ret, e);\n        }\n        return ret;\n    }\n\n    public static long min(final long... a) {\n        long ret = Long.MAX_VALUE;\n        for (final long e : a) {\n            ret = Math.min(ret, e);\n        }\n        return ret;\n    }\n\n    public static long reduce(final LongBinaryOperator func, final long... a) {\n        long ret = a[0];\n        for (int i = 1; i < a.length; i++) {\n            ret = func.applyAsLong(ret, a[i]);\n        }\n        return ret;\n    }\n\n    public static boolean isPowerOfTwo(final long n) {\n        return n != 0 && (-n & n) == n;\n    }\n\n    public static int ceilExponent(final long n) {\n        return 63 - Long.numberOfLeadingZeros(n) + (isPowerOfTwo(n) ? 0 : 1);\n    }\n\n    public static int floorExponent(final long n) {\n        return 63 - Long.numberOfLeadingZeros(n) + (n == 0 ? 1 : 0);\n    }\n\n    public static int ceilExponent(final long n, final int base) {\n        if (base == 2) {\n            return ceilExponent(n);\n        }\n        int i = 0;\n        long m = 1;\n        while (m < n) {\n            i++;\n            final long r = m * base;\n            if ((m | base) >> 31 != 0 && r / base != m) {\n                break;\n            }\n            m = r;\n        }\n        return i;\n    }\n\n    /**\n     * Caluculate the ceil of a/b. Returns the smallest integer greater than or\n     * equal to a/b while 'a/b' rounds fractional parts to ZERO.\n     * \n     * @param a\n     * @param b\n     * @return the smallest integer greater than or equal to a/b\n     */\n    public static long cld(final long a, final long b) {\n        if (a > 0 && b > 0)\n            return (a + b - 1) / b;\n        else if (a < 0 && b < 0)\n            return (a + b + 1) / b;\n        else\n            return a / b;\n    }\n\n    /**\n     * Caluculate the floor of a/b. Returns the largest integer less than or equal\n     * to a/b while 'a/b' rounds fractional parts to ZERO.\n     * \n     * @param a\n     * @param b\n     * @return the largest integer less than or equal to a/b\n     */\n    public static long fld(final long a, final long b) {\n        if (a <= 0 && b > 0)\n            return (a - b + 1) / b;\n        else if (a > 0 && b <= 0)\n            return (a - b - 1) / b;\n        else\n            return a / b;\n    }\n\n    public static String join(final String sep, final long... a) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String toBinaryString(long n) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < Long.SIZE; i++, n >>= 1) {\n            sb.append(n & 1);\n            if ((i & 3) == 3) {\n                sb.append('_');\n            }\n        }\n        return sb.reverse().toString();\n    }\n\n    public static String toHexString(long n) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0, t = Long.SIZE >> 2; i < t; i++, n >>= 4) {\n            sb.append(hex[(int) n & 0xf]);\n            if ((i & 3) == 3) {\n                sb.append('_');\n            }\n        }\n        return sb.reverse().toString();\n    }\n}\n\n\n\n\nfinal class Doubling {\n    private final int[][] doubling;\n    private final int height;\n    private final int n;\n\n    public Doubling(final int[] a, final long maxStep) {\n        this.n = a.length;\n        this.height = Longs.ceilExponent(maxStep) + 2;\n        this.doubling = new int[height][n];\n        build(a);\n    }\n\n    public int getHeight() {\n        return height;\n    }\n\n    public int query(int i, long step) {\n        int h = height - 1;\n        while (step > 0) {\n            if ((step & (1l << h)) != 0) {\n                i = doubling[h][i];\n                step ^= 1l << h;\n            }\n            h--;\n        }\n        return i;\n    }\n\n    public int step(final int i, final int exponent) {\n        return doubling[exponent][i];\n    }\n\n    public int stepWhile(int i, final IntPredicate p) {\n        int h = height - 1;\n        while (h >= 0) {\n            if (p.test(doubling[h][i])) {\n                i = doubling[h][i];\n            }\n            h--;\n        }\n        return i;\n    }\n\n    public int stepUntil(final int i, final IntPredicate p) {\n        return p.test(i) ? i : doubling[0][stepWhile(i, p.negate())];\n    }\n\n    public int[] biStep(final int u, final int v, final int exponent) {\n        final int us = doubling[exponent][u];\n        final int vs = doubling[exponent][v];\n        return new int[]{us, vs};\n    }\n\n    private long biStep(final long uv, final int exponent) {\n        final int u = MathUtil.upper32(uv);\n        final int v = MathUtil.lower32(uv);\n        return MathUtil.int2ToLong(doubling[exponent][u], doubling[exponent][v]);\n    }\n\n    public int[] biStepWhile(final int u, final int v, final IntBiPredicate p) {\n        final long ret = biStepWhile(MathUtil.int2ToLong(u, v), p.toLongPredicate());\n        return new int[]{MathUtil.upper32(ret), MathUtil.lower32(ret)};\n    }\n\n    private long biStepWhile(long uv, final LongPredicate p) {\n        int h = height - 1;\n        while (h >= 0) {\n            final long step = biStep(uv, h);\n            if (p.test(step)) {\n                uv = step;\n            }\n            h--;\n        }\n        return uv;\n    }\n\n    public int[] biStepUntil(final int u, final int v, final IntBiPredicate p) {\n        final long ret = biStepUntil(MathUtil.int2ToLong(u, v), p.toLongPredicate());\n        return new int[]{MathUtil.upper32(ret), MathUtil.lower32(ret)};\n    }\n\n    private long biStepUntil(final long uv, final LongPredicate p) {\n        return p.test(uv) ? uv : biStep(biStepWhile(uv, p.negate()), 0);\n    }\n\n    public int[] parallelStep(final int[] a, final int exponent) {\n        final int[] ret = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            ret[i] = doubling[exponent][a[i]];\n        }\n        return ret;\n    }\n\n    public int[] parallelStepWhile(final int[] a, final Predicate<int[]> p) {\n        int[] ret = a.clone();\n        int h = height - 1;\n        while (h >= 0) {\n            final int[] step = parallelStep(ret, h);\n            if (p.test(step)) {\n                ret = step;\n            }\n            h--;\n        }\n        return ret;\n    }\n\n    public int[] parallelStepUntil(final int[] a, final Predicate<int[]> p) {\n        return p.test(a) ? a.clone() : parallelStep(parallelStepWhile(a, p.negate()), 0);\n    }\n\n    private void build(final int[] a) {\n        doubling[0] = a.clone();\n        for (int h = 1; h < height; h++) {\n            for (int i = 0; i < n; i++) {\n                doubling[h][i] = doubling[h - 1][doubling[h - 1][i]];\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        RMQ_SparseTable rmq;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n//            System.out.println(treeHelper.root.id + \": 0\");\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n//                    System.out.println(child.id + \": \" + depth);\n                } else {\n                    depth--;\n                    dfsStack.pop();\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n//                        System.out.println(dfsStack.peek().node.id + \": \" + depth);\n                    }\n                }\n            }\n//            System.out.println(\"h\");\n//            for (int i = 0; i < h.length; i++) {\n//                System.out.println(h[i]);\n//            }\n//            System.out.println(\"euler\");\n//            for (int i = 0; i < euler.length; i++) {\n//                System.out.println(euler[i]);\n//            }\n//            System.out.println(\"l\");\n//            for (int i = 0; i < level.length; i++) {\n//                System.out.println(level[i]);\n//            }\n            rmq = new RMQ_SparseTable(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1Idx = h[n1.id];\n            int n2Idx = h[n2.id];\n            int lcaIdx = euler[rmq.query(n1Idx, n2Idx)];\n            return treeHelper.nodeList.get(lcaIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n    public static class RMQ_SparseTable {\n\n        private int cache[][];\n\n        public RMQ_SparseTable(int[] a) {\n            cache = new int[a.length][];\n            for (int i = 0; i < a.length; i++) {\n                int len = a.length - i;\n                len = (int) (Math.log(len) / Math.log(2)) + 1;\n                cache[i] = new int[len];\n                cache[i][0] = a[i];\n            }\n\n            for (int power = 1; power < cache[0].length; power++) {\n                for (int idx = 0; idx < a.length && power < cache[idx].length; idx++) {\n                    cache[idx][power] = Math.min(cache[idx][power - 1],\n                            cache[idx + (1 << (power - 1))][power - 1]);\n                }\n            }\n\n        }\n\n        public int query(int left, int right) {\n            int maxPower = (int) (Math.log(right - left + 1) / Math.log(2));\n            return Math.min(cache[left][maxPower], cache[right - (1 << maxPower) + 1][maxPower]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    List<List<Integer>> graph;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new LinkedList<>());\n        }\n        for (int i = 0; i < n; i++) {\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                int c = sc.nextInt();\n                graph.get(i).add(c);\n                graph.get(c).add(i);\n            }\n        }\n        LowestCommonAncestor lca = new LowestCommonAncestor(graph);\n        int q = sc.nextInt();\n        for (int i = 0; i < q; i++) {\n            System.out.println(lca.lca(sc.nextInt(), sc.nextInt()));\n        }\n    }\n\n    class LowestCommonAncestor {\n        List<List<Integer>> graph;\n        int[][] parents;\n        int[] depth;\n\n        LowestCommonAncestor(List<List<Integer>> graph) {\n            this.graph = graph;\n            int n = graph.size();\n            int logN = (int)Math.ceil(Math.log(n)/Math.log(2)+1e-10);\n            parents = new int[logN][n];\n            depth = new int[n];\n            init(0, -1, 0);\n            initParents();\n        }\n\n        int lca(int u, int v) {\n            if (depth[u] > depth[v]) {\n                int temp = u;\n                u = v;\n                v = temp;\n            }\n            for (int i = 0; i < parents.length; i++) {\n                if (((depth[v] - depth[u]) >> i & 1) > 0) {\n                    v = parents[i][v];\n                }\n            }\n            if (u == v) {\n                return u;\n            }\n            for (int i = parents.length - 1; i >= 0; i--) {\n                if (parents[i][u] != parents[i][v]) {\n                    u = parents[i][u];\n                    v = parents[i][v];\n                }\n            }\n            return parents[0][u];\n        }\n\n        void init(int v, int p, int d) {\n            parents[0][v] = p;\n            depth[v] = d;\n            for (int next : graph.get(v)) {\n                if (next != p) {\n                    init(next, v, d + 1);\n                }\n            }\n        }\n\n        void initParents() {\n            for (int i = 0; i < parents.length - 1; i++) {\n                for (int j = 0; j < parents[0].length; j++) {\n                    if (parents[i][j] < 0) {\n                        parents[i + 1][j] = -1;\n                    } else {\n                        parents[i + 1][j] = parents[i][parents[i][j]];\n                    }\n                }\n            }\n        }\n    }\n\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\n \npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Node[] V;\n\tstatic int knum = 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\t\n\t\twhile(Math.pow(2, knum) <= n) {\n\t\t\tknum++;\n\t\t}\n\t\t\n\t\tV = new Node[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tV[i] = new Node();\n\t\t}\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int j=0; j<k; j++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tV[i].child.add(c);\n\t\t\t\tV[c].parent[0] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tV[1].dfs(0);\n\t\t\n\t\tfor(int k=1; k<=knum; k++) {\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(V[i].parent[k-1] == -1) {\n\t\t\t\t\tV[i].parent[k] = -1;\n\t\t\t\t} else {\n\t\t\t\t\tV[i].parent[k] = V[V[i].parent[k-1]].parent[k-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q = sc.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tans.append(lca(u, v));\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\t\n\tstatic class Node {\n\t\tint[] parent = new int[knum+1];\n\t\tHashSet<Integer> child = new HashSet<>();\n\t\tint depth;\n\t\t\n\t\tvoid dfs(int d) {\n\t\t\tdepth = d;\n\t\t\tfor(int x : child) {\n\t\t\t\tV[x].dfs(d+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int lca(int u, int v) {\n\t\tif(V[u].depth > V[v].depth) {\n\t\t\treturn lca(v, u);\n\t\t}\n\t\t\n\t\tfor(int k=0; k<=knum; k++) {\n\t\t\tif(((V[v].depth - V[u].depth) >> k & 1) == 1) {\n\t\t\t\tv = V[v].parent[k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (u == v) {\n\t\t\treturn u;\n\t\t}\n\t\t\n\t\tfor(int k=knum; k>=0; k--) {\n\t\t\tif(V[u].parent[k] != V[v].parent[k]) {\n\t\t\t\tu = V[u].parent[k];\n\t\t\t\tv = V[v].parent[k];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn V[u].parent[0];\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main {\n\tstatic boolean DEBUG;\n\tpublic static void main(String[] args) {\n\t\tDEBUG = args.length > 0 && args[0].equals(\"-DEBUG\");\n\t\tSolver solver = new Solver();\n\t\tsolver.solve();\n\t\tsolver.exit();\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif(ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif(buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprivate int readByte() { if(hasNextByte()) return buffer[ptr++]; else return -1;}\n\t\tprivate boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tprivate StringBuilder sb = new StringBuilder();\n\t\tpublic String next() {\n\t\t\tif(!hasNext()) throw new NoSuchElementException();\n\t\t\tsb.setLength(0);\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif(!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif(b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif(b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t}else{\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Solver {\n\t\tFastScanner sc = new FastScanner();\n\t\tpublic Solver() { }\n\n\t\tString ns() { return sc.next(); }\n\t\tString[] ns(int n) {\n\t\t\tString a[] = new String[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(); }\n\t\t\treturn a;\n\t\t}\n\t\tString[][] ns(int n, int m) {\n\t\t\tString a[][] = new String[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ns(m); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[] nc(int n) {\n\t\t\tString str = ns();\n\t\t\tif(n < 0) n = str.length();\n\t\t\tchar a[] = new char[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = str.charAt(i); }\n\t\t\treturn a;\n\t\t}\n\t\tchar[][] nc(int n, int m) {\n\t\t\tchar a[][] = new char[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nc(m); }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[] nb(int n, char t) {\n\t\t\tchar c[] = nc(-1);\n\t\t\tif(n < 0) n = c.length;\n\t\t\tboolean a[] = new boolean[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = c[i] == t; }\n\t\t\treturn a;\n\t\t}\n\t\tboolean[][] nb(int n, int m, char t) {\n\t\t\tboolean a[][] = new boolean[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nb(m, t); }\n\t\t\treturn a;\n\t\t}\n\t\tint ni() { return (int)sc.nextLong(); }\n\t\tint[] ni(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(); }\n\t\t\treturn a;\n\t\t}\n\t\tint[][] ni(int n, int m) {\n\t\t\tint a[][] = new int[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = ni(m); }\n\t\t\treturn a;\n\t\t}\n\t\tlong nl() { return sc.nextLong(); }\n\t\tlong[] nl(int n) {\n\t\t\tlong a[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(); }\n\t\t\treturn a;\n\t\t}\n\t\tlong[][] nl(int n, int m) {\n\t\t\tlong a[][] = new long[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nl(m); }\n\t\t\treturn a;\n\t\t}\n\t\tdouble nd() { return Double.parseDouble(sc.next()); }\n\t\tdouble[] nd(int n) {\n\t\t\tdouble a[] = new double[n];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nd(); }\n\t\t\treturn a;\n\t\t}\n\t\tdouble[][] nd(int n, int m) {\n\t\t\tdouble a[][] = new double[n][m];\n\t\t\tfor(int i = 0; i < n; i ++) { a[i] = nd(m); }\n\t\t\treturn a;\n\t\t}\n\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tPrintWriter err = new PrintWriter(System.err);\n\t\tvoid prt() { out.print(\"\"); }\n\t\t<T> void prt(T a) { out.print(a); }\n\t\tvoid prtln() { out.println(\"\"); }\n\t\t<T> void prtln(T a) { out.println(a); }\n\t\tvoid prtln(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(long element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(double... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(char... a) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\tprtln(sb.toString().trim());\n\t\t}\n\t\tvoid prtln(int[][] a) { for(int[] element : a){ prtln(element); } }\n\t\tvoid prtln(long[][] a) { for(long[] element : a){ prtln(element); } }\n\t\tvoid prtln(double[][] a) { for(double[] element : a){ prtln(element); } }\n\t\tvoid prtln(String[][] a) { for(String[] element : a){ prtln(element); } }\n\t\tvoid prtln(char[][] a) { for(char[] element : a){ prtln(element); } }\n\t\tString errconvert(int a) { return isINF(a) ? \"_\" : String.valueOf(a); }\n\t\tString errconvert(long a) { return isINF(a) ? \"_\" : String.valueOf(a); }\n\t\tvoid errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }\n\t\tvoid errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }\n\t\tvoid errprt() { if(DEBUG) { err.print(\"\"); } }\n\t\t<T> void errprt(T a) { if(DEBUG) { err.print(a); } }\n\t\tvoid errprt(boolean a) { if(DEBUG) { errprt(a ? \"#\" : \".\"); } }\n\t\tvoid errprtln() { if(DEBUG) { err.println(\"\"); } }\n\t\tvoid errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }\n\t\tvoid errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }\n\t\t<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }\n\t\tvoid errprtln(boolean a) { if(DEBUG) { errprtln(a ? \"#\" : \".\"); } }\n\t\tvoid errprtln(int... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int element : a){ sb.append(errconvert(element)+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(long... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(long element : a){ sb.append(errconvert(element)+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(double... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(double element : a){ sb.append(element+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(String... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(String element : a){ sb.append(element+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(char... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(char element : a){ sb.append(element); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(boolean... a) {\n\t\t\tif(DEBUG) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(boolean element : a){ sb.append((element ? \"#\" : \".\")+\" \"); }\n\t\t\t\terrprtln(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t\tvoid errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }\n\t\tvoid errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }\n\n\t\tvoid reply(boolean b) { prtln(b ? \"Yes\" : \"No\"); }\n\t\tvoid REPLY(boolean b) { prtln(b ? \"YES\" : \"NO\"); }\n\n\t\tvoid flush() { out.flush(); if(DEBUG) { err.flush(); } }\n\t\tvoid exit() { flush(); System.exit(0); }\n\t\tvoid assertion(boolean b) { if(!b) throw new AssertionError(); }\n\n\t\tint min(int a, int b) { return Math.min(a, b); }\n\t\tlong min(long a, long b) { return Math.min(a, b); }\n\t\tdouble min(double a, double b) { return Math.min(a, b); }\n\t\tint min(int... x) {\n\t\t\tint min = x[0];\n\t\t\tfor(int val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tlong min(long... x) {\n\t\t\tlong min = x[0];\n\t\t\tfor(long val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tdouble min(double... x) {\n\t\t\tdouble min = x[0];\n\t\t\tfor(double val : x) { min = min(min, val); }\n\t\t\treturn min;\n\t\t}\n\t\tint max(int a, int b) { return Math.max(a, b); }\n\t\tlong max(long a, long b) { return Math.max(a, b); }\n\t\tdouble max(double a, double b) { return Math.max(a, b); }\n\t\tint max(int... x) {\n\t\t\tint max = x[0];\n\t\t\tfor(int val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong max(long... x) {\n\t\t\tlong max = x[0];\n\t\t\tfor(long val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tdouble max(double... x) {\n\t\t\tdouble max = x[0];\n\t\t\tfor(double val : x) { max = max(max, val); }\n\t\t\treturn max;\n\t\t}\n\t\tlong sum(int... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(int element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong sum(long... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(long element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tdouble sum(double... a) {\n\t\t\tdouble sum = 0;\n\t\t\tfor(double element : a) { sum += element; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong sum(boolean... a) {\n\t\t\tlong sum = 0;\n\t\t\tfor(boolean element : a) { sum += element ? 1 : 0; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(int[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(long[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }\n\t\t\treturn sum;\n\t\t}\n\t\tdouble[] sums(double[] a) {\n\t\t\tdouble sum[] = new double[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }\n\t\t\treturn sum;\n\t\t}\n\t\tlong[] sums(boolean[] a) {\n\t\t\tlong sum[] = new long[a.length + 1];\n\t\t\tsum[0] = 0;\n\t\t\tfor(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + (a[i] ? 1 : 0); }\n\t\t\treturn sum;\n\t\t}\n\t\tlong[][] sums(int[][] a) {\n\t\t\tlong sum[][] = new long[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tlong[][] sums(long[][] a) {\n\t\t\tlong sum[][] = new long[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tdouble[][] sums(double[][] a) {\n\t\t\tdouble sum[][] = new double[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tlong[][] sums(boolean[][] a) {\n\t\t\tlong sum[][] = new long[a.length + 1][a[0].length + 1];\n\t\t\tfill(sum, 0);\n\t\t\tfor(int i = 0; i < a.length; i ++) {\n\t\t\t\tfor(int j = 0; j < a[i].length; j ++) {\n\t\t\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + (a[i][j] ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\tint constrain(int x, int l, int r) { return min(max(x, min(l, r)), max(l, r)); }\n\t\tlong constrain(long x, long l, long r) { return min(max(x, min(l, r)), max(l, r)); }\n\t\tdouble constrain(double x, double l, double r) { return min(max(x, min(l, r)), max(l, r)); }\n\n\t\tint abs(int x) { return x >= 0 ? x : - x; }\n\t\tlong abs(long x) { return x >= 0 ? x : - x; }\n\t\tdouble abs(double x) { return x >= 0 ? x : - x; }\n\t\tint signum(int x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }\n\t\tint signum(long x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }\n\t\tint signum(double x) { return x > 0 ? 1 : x < 0 ? -1 : 0; }\n\t\tlong round(double x) { return Math.round(x); }\n\t\tlong floor(double x) { return (long)Math.floor(x); }\n\t\tint divfloor(int a, int b) { return signum(a) == signum(b) ? a / b : - divceil(abs(a), abs(b)); }\n\t\tlong divfloor(long a, long b) { return signum(a) == signum(b) ? a / b : - divceil(abs(a), abs(b)); }\n\t\tlong ceil(double x) { return (long)Math.ceil(x); }\n\t\tint divceil(int a, int b) { return a >= 0 && b > 0 ? (a + b - 1) / b\n\t\t\t\t\t\t\t\t\t\t\t: a < 0 && b < 0 ? divceil(abs(a), abs(b))\n\t\t\t\t\t\t\t\t\t\t\t: - divfloor(abs(a), abs(b)); }\n\t\tlong divceil(long a, long b) { return a >= 0 && b > 0 ? (a + b - 1) / b\n\t\t\t\t\t\t\t\t\t\t\t: a < 0 && b < 0 ? divceil(abs(a), abs(b))\n\t\t\t\t\t\t\t\t\t\t\t: - divfloor(abs(a), abs(b)); }\n\t\tdouble sqrt(int x) { return Math.sqrt((double)x); }\n\t\tdouble sqrt(long x) { return Math.sqrt((double)x); }\n\t\tdouble sqrt(double x) { return Math.sqrt(x); }\n\t\tlong fact(int n) {\n\t\t\tlong ans = 1;\n\t\t\tfor(int i = 1; i <= n; i ++) ans *= i;\n\t\t\treturn ans;\n\t\t}\n\t\tdouble pow(double x, double y) { return Math.pow(x, y); }\n\t\tlong pow(long x, long y) {\n\t\t\tlong ans = 1;\n\t\t\tfor(; y > 0; y /= 2) {\n\t\t\t\tif(y % 2 != 0) ans *= x;\n\t\t\t\tx *= x;\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tint gcd(int a, int b) {\n\t\t\twhile(true) {\n\t\t\t\tif(b == 0) return a;\n\t\t\t\tint tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp % b;\n\t\t\t}\n\t\t}\n\t\tlong gcd(long a, long b) {\n\t\t\twhile(true) {\n\t\t\t\tif(b == 0) return a;\n\t\t\t\tlong tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp % b;\n\t\t\t}\n\t\t}\n\t\tlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\t\tint gcd(int[] array) {\n\t\t\tint gcd = 0;\n\t\t\tfor(int i = 0; i < array.length; i ++) { gcd = gcd(gcd, array[i]); }\n\t\t\treturn gcd;\n\t\t}\n\t\tlong gcd(long[] array) {\n\t\t\tlong gcd = 0;\n\t\t\tfor(int i = 0; i < array.length; i ++) { gcd = gcd(gcd, array[i]); }\n\t\t\treturn gcd;\n\t\t}\n\n\t\tlong[] mulMat(long[][] mat1, long[] mat2) {\n\t\t\tlong mul[] = new long[mat2.length];\n\t\t\tfor(int i = 0; i < mul.length; i ++) {\n\t\t\t\tfor(int j = 0; j < mat2.length; j ++) {\n\t\t\t\t\tmul[i] += mat1[i][j] * mat2[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mul;\n\t\t}\n\t\tlong[][] mulMat(long[][] mat1, long[][] mat2) {\n\t\t\tlong mul[][] = new long[mat1.length][mat2[0].length];\n\t\t\tfor(int i = 0; i < mul.length; i ++) {\n\t\t\t\tfor(int j = 0; j < mul[i].length; j ++) {\n\t\t\t\t\tfor(int k = 0; k < mat2.length; k ++) {\n\t\t\t\t\t\tmul[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mul;\n\t\t}\n\t\tlong[][] powMat(long[][] mat, long y) {\n\t\t\tint num = mat.length;\n\t\t\tlong[][] ans = new long[num][num];\n\t\t\tfill(ans, 0);\n\t\t\tfor(int i = 0; i < num; i ++) ans[i][i] = 1;\n\t\t\tlong[][] x = new long[num][num];\n\t\t\tfor(int i = 0; i < num; i ++) for(int j = 0; j < num; j ++) x[i][j] = mat[i][j];\n\t\t\tfor(; y > 0; y /= 2) {\n\t\t\t\tif(y % 2 != 0) ans = mulMat(ans, x);\n\t\t\t\tx = mulMat(x, x);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\tint upperToInt(char a) { return a - 'A'; }\n\t\tint lowerToInt(char a) { return a - 'a'; }\n\t\tint numToInt(char a) { return a - '0'; }\n\t\tint charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }\n\t\tchar intToUpper(int a) { return (char)(a + 'A'); }\n\t\tchar intToLower(int a) { return (char)(a + 'a'); }\n\t\tchar intToNum(int a) { return (char)(a + '0'); }\n\t\tint[] charToInt(char[] a) {\n\t\t\tint array[] = new int[a.length];\n\t\t\tfor(int i = 0; i < a.length; i ++) { array[i] = charToInt(a[i]); }\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[] div(long a) {\n\t\t\tList<Long> divList = new ArrayList<Long>();\n\t\t\tfor(long i = 1; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tdivList.add(i);\n\t\t\t\t\tif(i * i != a) { divList.add(a / i); };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong div[] = new long[divList.size()];\n\t\t\tfor(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }\n\t\t\treturn div;\n\t\t}\n\n\t\tlong[][] factor(long a) {\n\t\t\tList<Long> factorList = new ArrayList<Long>();\n\t\t\tList<Long> degreeList = new ArrayList<Long>();\n\t\t\tfor(long i = 2; i * i <= a; i ++) {\n\t\t\t\tif(a % i == 0) {\n\t\t\t\t\tlong count = 0;\n\t\t\t\t\twhile(a % i == 0) {\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tfactorList.add(i);\n\t\t\t\t\tdegreeList.add(count);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a > 1) {\n\t\t\t\tfactorList.add(a);\n\t\t\t\tdegreeList.add(1L);\n\t\t\t}\n\t\t\tlong factor[][] = new long[factorList.size()][2];\n\t\t\tfor(int i = 0; i < factorList.size(); i ++) {\n\t\t\t\tfactor[i][0] = factorList.get(i);\n\t\t\t\tfactor[i][1] = degreeList.get(i);\n\t\t\t}\n\t\t\tArrays.sort(factor, (sort1, sort2) -> Long.compare(sort1[0], sort2[0]));\n\t\t\treturn factor;\n\t\t}\n\n\t\tboolean isPrime(long x) {\n\t\t\tboolean ok = x > 1;\n\t\t\tfor(long i = 2; i * i <= x; i ++) {\n\t\t\t\tok &= x % i != 0;\n\t\t\t\tif(!ok) return ok;\n\t\t\t}\n\t\t\treturn ok;\n\t\t}\n\t\tboolean[] prime(int num) {\n\t\t\tboolean prime[] = new boolean[num];\n\t\t\tfill(prime, true);\n\t\t\tprime[0] = false;\n\t\t\tprime[1] = false;\n\t\t\tfor(int i = 2; i < num; i ++) {\n\t\t\t\tif(prime[i]) {\n\t\t\t\t\tfor(int j = 2; i * j < num; j ++) {\n\t\t\t\t\t\tprime[i * j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn prime;\n\t\t}\n\n\t\tlong[][] countElements(long[] a, boolean sort) {\n\t\t\tint len = a.length;\n\t\t\tlong array[] = new long[len];\n\t\t\tfor(int i = 0; i < len; i ++) {\n\t\t\t\tarray[i] = a[i];\n\t\t\t}\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add(array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\t\tlong[][] countElements(String str, boolean sort) {\n\t\t\tint len = str.length();\n\t\t\tchar array[] = str.toCharArray();\n\t\t\tif(sort) { Arrays.sort(array); }\n\t\t\tList<Long> elem = new ArrayList<Long>();\n\t\t\tList<Long> cnt = new ArrayList<Long>();\n\t\t\tlong tmp = 1;\n\t\t\tfor(int i = 1; i <= len; i ++) {\n\t\t\t\tif(i == len || array[i] != array[i - 1]) {\n\t\t\t\t\telem.add((long)array[i - 1]);\n\t\t\t\t\tcnt.add(tmp);\n\t\t\t\t\ttmp = 1;\n\t\t\t\t}else {\n\t\t\t\t\ttmp ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong counts[][] = new long[elem.size()][2];\n\t\t\tfor(int i = 0; i < elem.size(); i ++) {\n\t\t\t\tcounts[i][0] = elem.get(i);\n\t\t\t\tcounts[i][1] = cnt.get(i);\n\t\t\t}\n\t\t\treturn counts;\n\t\t}\n\n\t\tint[] baseConvert(long x, int n, int len) {\n\t\t\tint digit[] = new int[len];\n\t\t\tint i = 0;\n\t\t\tlong tmp = x;\n\t\t\twhile(tmp > 0 && i < len) { digit[i ++] = (int)(tmp % n); tmp /= n; }\n\t\t\treturn digit;\n\t\t}\n\t\tint[] baseConvert(long x, int n) {\n\t\t\tlong tmp = x;\n\t\t\tint len = 0;\n\t\t\twhile(tmp > 0) { tmp /= n; len ++; }\n\t\t\treturn baseConvert(x, n, len);\n\t\t}\n\t\tint[] baseConvert(int x, int n, int len) {\n\t\t\tint digit[] = new int[len];\n\t\t\tint i = 0;\n\t\t\tint tmp = x;\n\t\t\twhile(tmp > 0 && i < len) { digit[i ++] = (int)(tmp % n); tmp /= n; }\n\t\t\treturn digit;\n\t\t}\n\t\tint[] baseConvert(int x, int n) {\n\t\t\tint tmp = x;\n\t\t\tint len = 0;\n\t\t\twhile(tmp > 0) { tmp /= n; len ++; }\n\t\t\treturn baseConvert(x, n, len);\n\t\t}\n\t\tlong[] baseConvert(long x, long n, int len) {\n\t\t\tlong digit[] = new long[len];\n\t\t\tint i = 0;\n\t\t\tlong tmp = x;\n\t\t\twhile(tmp > 0 && i < len) { digit[i ++] = tmp % n; tmp /= n; }\n\t\t\treturn digit;\n\t\t}\n\t\tlong[] baseConvert(long x, long n) {\n\t\t\tlong tmp = x;\n\t\t\tint len = 0;\n\t\t\twhile(tmp > 0) { tmp /= n; len ++; }\n\t\t\treturn baseConvert(x, n, len);\n\t\t}\n\n\t\tint numDigits(long a) { return Long.toString(a).length(); }\n\t\tlong bitFlag(int a) { return 1L << (long)a; }\n\t\tboolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }\n\n\t\tlong countString(String str, String a) { return (str.length() - str.replace(a, \"\").length()) / a.length(); }\n\t\tlong countStringAll(String str, String a) { return str.length() - str.replaceAll(a, \"\").length(); }\n\n\n\n\n\n\t\tvoid reverse(String[] array) {\n\t\t\tfor(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }\n\t\t}\n\t\tvoid reverse(int[] array) {\n\t\t\tfor(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }\n\t\t}\n\t\tvoid reverse(long[] array) {\n\t\t\tfor(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }\n\t\t}\n\t\tvoid reverse(double[] array) {\n\t\t\tfor(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }\n\t\t}\n\t\tvoid reverse(char[] array) {\n\t\t\tfor(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }\n\t\t}\n\t\tvoid reverse(boolean[] array) {\n\t\t\tfor(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }\n\t\t}\n\t\t<T> void reverse(T[] array) {\n\t\t\tfor(int i = 0; i < array.length / 2; i ++) { swap(array, i, array.length - i - 1); }\n\t\t}\n\t\tvoid fill(int[] array, int x) { Arrays.fill(array, x); }\n\t\tvoid fill(long[] array, long x) { Arrays.fill(array, x); }\n\t\tvoid fill(double[] array, double x) { Arrays.fill(array, x); }\n\t\tvoid fill(char[] array, char x) { Arrays.fill(array, x); }\n\t\tvoid fill(boolean[] array, boolean x) { Arrays.fill(array, x); }\n\t\tvoid fill(int[][] array, int x) { for(int[] a : array) { fill(a, x); } }\n\t\tvoid fill(long[][] array, long x) { for(long[] a : array) { fill(a, x); } }\n\t\tvoid fill(double[][] array, double x) { for(double[] a : array) { fill(a, x); } }\n\t\tvoid fill(char[][] array, char x) { for(char[] a : array) { fill(a, x); } }\n\t\tvoid fill(boolean[][] array, boolean x) { for(boolean[] a : array) { fill(a, x); } }\n\t\tvoid fill(int[][][] array, int x) { for(int[][] a : array) { fill(a, x); } }\n\t\tvoid fill(long[][][] array, long x) { for(long[][] a : array) { fill(a, x); } }\n\t\tvoid fill(double[][][] array, double x) { for(double[][] a : array) { fill(a, x); } }\n\t\tvoid fill(char[][][] array, char x) { for(char[][] a : array) { fill(a, x); } }\n\t\tvoid fill(boolean[][][] array, boolean x) { for(boolean[][] a : array) { fill(a, x); } }\n\n\t\tint[] resize(int[] array, int m, int x) {\n\t\t\tint resized[] = new int[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }\n\t\t\treturn resized;\n\t\t}\n\t\tlong[] resize(long[] array, int m, int x) {\n\t\t\tlong resized[] = new long[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }\n\t\t\treturn resized;\n\t\t}\n\t\tdouble[] resize(double[] array, int m, int x) {\n\t\t\tdouble resized[] = new double[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }\n\t\t\treturn resized;\n\t\t}\n\t\tchar[] resize(char[] array, int m, int x) {\n\t\t\tchar resized[] = new char[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }\n\t\t\treturn resized;\n\t\t}\n\t\tboolean[] resize(boolean[] array, int m, int x) {\n\t\t\tboolean resized[] = new boolean[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }\n\t\t\treturn resized;\n\t\t}\n\t\tObject[] resize(Object[] array, int m, int x) {\n\t\t\tObject resized[] = new Object[m];\n\t\t\tfor(int i = max(0, - x); i < array.length && i + x < m; i ++) { resized[i + x] = array[i]; }\n\t\t\treturn resized;\n\t\t}\n\n\t\tvoid shuffleArray(int[] array){\n\t\t\tint n = array.length;\n\t\t\tRandom rnd = new Random();\n\t\t\tfor(int i = 0; i < n; i ++){\n\t\t\t\tint tmp = array[i];\n\t\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\t\tarray[i] = array[randomPos];\n\t\t\t\tarray[randomPos] = tmp;\n\t\t\t}\n\t\t}\n\t\tvoid shuffleArray(long[] array){\n\t\t\tint n = array.length;\n\t\t\tRandom rnd = new Random();\n\t\t\tfor(int i = 0; i < n; i ++){\n\t\t\t\tlong tmp = array[i];\n\t\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\t\tarray[i] = array[randomPos];\n\t\t\t\tarray[randomPos] = tmp;\n\t\t\t}\n\t\t}\n\t\tvoid shuffleArray(double[] array){\n\t\t\tint n = array.length;\n\t\t\tRandom rnd = new Random();\n\t\t\tfor(int i = 0; i < n; i ++){\n\t\t\t\tdouble tmp = array[i];\n\t\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\t\tarray[i] = array[randomPos];\n\t\t\t\tarray[randomPos] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tvoid swap(String[] array, int i, int j) {\n\t\t\tString tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(int[] array, int i, int j) {\n\t\t\tint tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(long[] array, int i, int j) {\n\t\t\tlong tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(double[] array, int i, int j) {\n\t\t\tdouble tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(char[] array, int i, int j) {\n\t\t\tchar tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\tvoid swap(boolean[] array, int i, int j) {\n\t\t\tboolean tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\t\t<T> void swap(T[] array, int i, int j) {\n\t\t\tT tmp = array[i];\n\t\t\tarray[i] = array[j];\n\t\t\tarray[j] = tmp;\n\t\t}\n\n\t\tlong INF = (long)1e18 + 7;\n\t\tboolean isINF(long a) { return abs(a) > INF / 1000; }\n\t\tboolean isPlusINF(long a) { return a > 0 && isINF(a); }\n\t\tboolean isMinusINF(long a) { return isPlusINF(- a); }\n\t\tint I_INF = (int)1e9 + 7;\n\t\tboolean isINF(int a) { return abs(a) > I_INF / 1000; }\n\t\tboolean isPlusINF(int a) { return a > 0 && isINF(a); }\n\t\tboolean isMinusINF(int a) { return isPlusINF(- a); }\n\n\n\n\n\t\t// graph\n\t\tclass Graph {\n\t\t\tint numNode;\n\t\t\tint numEdge;\n\t\t\tboolean directed;\n\t\t\tEdge edges[];\n\t\t\tNode nodes[];\n\t\t\tNode reversedNodes[];\n\n\t\t\tGraph(int numNode, int numEdge, boolean directed) {\n\t\t\t\tthis.numNode = numNode;\n\t\t\t\tthis.numEdge = numEdge;\n\t\t\t\tthis.directed = directed;\n\t\t\t\tnodes = new Node[numNode];\n\t\t\t\treversedNodes = new Node[numNode];\n\t\t\t\tfor(int i = 0; i < numNode; i ++) {\n\t\t\t\t\tnodes[i] = new Node(i);\n\t\t\t\t\treversedNodes[i] = new Node(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid init(Edge[] edges) {\n\t\t\t\tthis.edges = edges;\n\t\t\t\tfor(Edge edge : edges) {\n\t\t\t\t\tnodes[edge.source].add(edge.target, edge.cost);\n\t\t\t\t\tif(directed) {\n\t\t\t\t\t\treversedNodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnodes[edge.target].add(edge.source, edge.cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid clearNodes() {\n\t\t\t\tfor(Node n : nodes) { n.clear(); }\n\t\t\t\tfor(Node n : reversedNodes) { n.clear(); }\n\t\t\t}\n\t\t}\n\n\t\tclass Node extends ArrayList<Edge> {\n\t\t\tint id;\n\n\t\t\tNode(int id) {\n\t\t\t\tthis.id = id;\n\t\t\t}\n\t\t\tvoid add(int target, long cost) {\n\t\t\t\tadd(new Edge(id, target, cost));\n\t\t\t}\n\t\t}\n\n\t\tclass Edge implements Comparable<Edge> {\n\t\t\tint source;\n\t\t\tint target;\n\t\t\tlong cost;\n\t\t\tEdge(int source, int target, long cost) {\n\t\t\t\tthis.source = source;\n\t\t\t\tthis.target = target;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(Edge e) {\n\t\t\t\treturn Long.compare(this.cost, e.cost);\n\t\t\t}\n\t\t}\n\npublic void solve() {\n\tint numNode = ni();\n\tint numEdge = numNode - 1;\n\tGraph g = new Graph(numNode, numEdge, false);\n\tEdge edges[] = new Edge[numEdge];\n\tint index = 0;\n\tfor(int i = 0; i < numNode; i ++) {\n\t\tint m = ni();\n\t\tfor(int j = 0; j < m; j ++) {\n\t\t\tint a = i;\n\t\t\tint b = ni();\n\t\t\tlong c = 1;\n\t\t\tedges[index ++] = new Edge(a, b, c);\n\t\t}\n\t}\n\tg.init(edges);\n\tLCA lca = new LCA(numNode);\n\tlca.init(0, g.nodes);\n\tint query = ni();\n\tfor(int q = 0; q < query; q ++) {\n\t\tint u = ni();\n\t\tint v = ni();\n\t\tprtln(lca.get(u, v));\n\t}\n}\n\nclass LCA {\n\tint numNode;\n\tDoubling db;\n\tint[] depth;\n\tEdge[] edges;\n\n\tpublic LCA(int numNode) {\n\t\tthis.numNode = numNode;\n\t\tthis.db = new Doubling(numNode, numNode);\n\t\tthis.depth = new int[numNode];\n\t\tthis.edges = new Edge[numNode];\n\t}\n\n\tvoid init(int root, Node nodes[]) { // O(VlogV)\n\t\tbfs(nodes, root);\n\t\tdb.init(edges);\n\t}\n\n\tvoid bfs(Node nodes[], int start) {\n\t\tArrays.fill(depth, -1);\n\t\tdepth[start] = 0;\n\t\tedges[start] = new Edge(start, -1, 0);\n\n\t\tDeque<Integer> s = new ArrayDeque<>();\n\t\ts.addLast(start);\n\t\tdepth[start] = 0;\n\t\twhile(!s.isEmpty()) {\n\t\t\tint crt = s.removeFirst();\n\t\t\tfor(Edge e : nodes[crt]) {\n\t\t\t\tif(depth[e.target] < 0) {\n\t\t\t\t\tdepth[e.target] = depth[e.source] + 1;\n\t\t\t\t\tedges[e.target] = new Edge(e.target, e.source, e.cost);\n\t\t\t\t\ts.addLast(e.target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint get(int u, int v) { // O(logV)\n\t\tif(depth[u] > depth[v]) {\n\t\t\tint t = u;\n\t\t\tu = v;\n\t\t\tv = t;\n\t\t}\n\t\tlong cost = 0;\n\n\t\tfor(int k = 0; k < db.log; k ++) {\n\t\t\tif(isFlagged(depth[v] - depth[u],k)) {\n\t\t\t\tv = db.next[k][v];\n\t\t\t\tcost += db.val[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u == v) { return u; }\n\n\t\tfor (int k = db.log - 1; k >= 0; k --) {\n\t\t\tif(db.next[k][u] != db.next[k][v]) {\n\t\t\t\tu = db.next[k][u];\n\t\t\t\tcost += db.val[k][u];\n\t\t\t\tv = db.next[k][v];\n\t\t\t\tcost += db.val[k][v];\n\t\t\t}\n\t\t}\n\t\treturn db.next[0][u];\n\t}\n}\n\nclass Doubling {\n\tint num;\n\tint log;\n\tint next[][];\n\tlong val[][];\n\tDoubling(int num, long max) {\n\t\tthis.num = num;\n\t\tlog = Long.numberOfTrailingZeros(Long.highestOneBit(max)) + 1;\n\t\tnext = new int[log][num];\n\t\tval = new long[log][num];\n\t}\n\n\tvoid init(Edge[] edges) { // O(NlogM)\n\t\tfor(Edge e : edges) {\n\t\t\tnext[0][e.source] = e.target;\n\t\t\tval[0][e.source] = e.cost;\n\t\t}\n\n\t\tfor(int k = 0; k + 1 < log; k ++) {\n\t\t\tfor(int v = 0; v < num; v ++) {\n\t\t\t\tif(next[k][v] < 0) {\n\t\t\t\t\tnext[k + 1][v] = -1;\n\t\t\t\t\tval[k + 1][v] = 0;\n\t\t\t\t}else {\n\t\t\t\t\tnext[k + 1][v] = next[k][next[k][v]];\n\t\t\t\t\tval[k + 1][v] = val[k][v] + val[k][next[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tEdge get(int x, long q) { // O(logQ)\n\t\tEdge e = new Edge(x, x, 0);\n\t\tfor(int k = log - 1; k >= 0; k --) {\n\t\t\tif(e.target < 0) {\n\t\t\t\te.cost = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(isFlagged(q, k)) {\n\t\t\t\te.cost += val[k][e.target];\n\t\t\t\te.target = next[k][e.target];\n\t\t\t}\n\t\t}\n\t\treturn e;\n\t}\n\n\tlong bisect(int x, long q) {\n\t\tlong ans = 0;\n\t\tEdge e = new Edge(x, x, 0);\n\t\tfor(int k = log - 1; k >= 0; k --) {\n\t\t\tif(e.target < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(e.cost + val[k][e.target] <= q) {\n\t\t\t\te.cost += val[k][e.target];\n\t\t\t\te.target = next[k][e.target];\n\t\t\t\tans += bitFlag(k);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        RMQ_SparseTable rmq;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n                } else {\n                    dfsStack.pop();\n                    depth--;\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n                    }\n                }\n            }\n            rmq = new RMQ_SparseTable(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1VisitIdx = h[n1.id];\n            int n2VisitIdx = h[n2.id];\n            int leftVisitIdx = Math.min(n1VisitIdx, n2VisitIdx);\n            int rightVisitIdx = Math.max(n1VisitIdx, n2VisitIdx);\n\n            int minVisitIdx = rmq.query(leftVisitIdx, rightVisitIdx);\n            int lcaNodeIdx = euler[minVisitIdx];\n            return treeHelper.nodeList.get(lcaNodeIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n    public static class RMQ_SparseTable {\n\n        private final int cache[][];\n        private final int[] rawArray;\n\n        public RMQ_SparseTable(int[] a) {\n            rawArray = a;\n            cache = new int[a.length][];\n            for (int i = 0; i < a.length; i++) {\n                int len = a.length - i;\n                len = (int) (Math.log(len) / Math.log(2)) + 1;\n                cache[i] = new int[len];\n                cache[i][0] = i;\n            }\n\n            for (int power = 1; power < cache[0].length; power++) {\n                for (int idx = 0; idx < a.length && power < cache[idx].length; idx++) {\n                    if (a[cache[idx][power - 1]] < a[cache[idx + (1 << (power - 1))][power - 1]]) {\n                        cache[idx][power] = cache[idx][power - 1];\n                    } else {\n                        cache[idx][power] = cache[idx + (1 << (power - 1))][power - 1];\n                    }\n                }\n            }\n\n        }\n\n        /**\n         * left <= right\n         * @param left zero-based\n         * @param right zero-based\n         * @return index to input array\n         */\n        public int query(int left, int right) {\n            int maxPower = (int) (Math.log(right - left + 1) / Math.log(2));\n            if (rawArray[cache[left][maxPower]] < rawArray[cache[right - (1 << maxPower) + 1][maxPower]]) {\n                return cache[left][maxPower];\n            } else {\n                return cache[right - (1 << maxPower) + 1][maxPower];\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.stream.Stream;\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final long INF = Long.MAX_VALUE / 2;\n\tint len;\n\tint[][] up;\n\tint[] tin;\n\tint[] tout;\n\tint time;\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static void solve() {\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\tint n = ni();\n\t\tList<Integer>[] tree = Stream.generate(ArrayList::new).limit(n).toArray(List[]::new);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k = ni();\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint t = ni();\n\t\t\t\ttree[i].add(t);\n\t\t\t\ttree[t].add(i);\n\t\t\t}\n\t\t}\n\t\tMain t = new Main(tree, 0);\n\t\tint q = ni();\n\t\twhile(q-->0){\n\t\t\tpr.println(t.lca(ni(),ni()));\n\t\t}\n\t\tpr.flush();\n\t}\n\tvoid dfs(List<Integer>[] tree, int u, int p) {\n\t\ttin[u] = time++;\n\t\tup[0][u] = p;\n\t\tfor (int i = 1; i < len; i++)\n\t\t\tup[i][u] = up[i - 1][up[i - 1][u]];\n\t\tfor (int v : tree[u])\n\t\t\tif (v != p)\n\t\t\t\tdfs(tree, v, u);\n\t\ttout[u] = time++;\n\t}\n\n\tpublic Main(List<Integer>[] tree, int root) {\n\t\tint n = tree.length;\n\t\tlen = 1;\n\t\twhile ((1 << len) <= n) ++len;\n\t\tup = new int[len][n];\n\t\ttin = new int[n];\n\t\ttout = new int[n];\n\t\tdfs(tree, root, root);\n\t}\n\n\tboolean isParent(int parent, int child) {\n\t\treturn tin[parent] <= tin[child] && tout[child] <= tout[parent];\n\t}\n\n\tpublic int lca(int a, int b) {\n\t\tif (isParent(a, b))\n\t\t\treturn a;\n\t\tif (isParent(b, a))\n\t\t\treturn b;\n\t\tfor (int i = len - 1; i >= 0; i--)\n\t\t\tif (!isParent(up[i][a], b))\n\t\t\t\ta = up[i][a];\n\t\treturn up[0][a];\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\t//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        RMQ_SparseTable rmq;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n                } else {\n                    dfsStack.pop();\n                    depth--;\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n                    }\n                }\n            }\n            rmq = new RMQ_SparseTable(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1VisitIdx = h[n1.id];\n            int n2VisitIdx = h[n2.id];\n            int minIdx = rmq.query(n1VisitIdx, n2VisitIdx);\n            int lcaIdx = euler[minIdx];\n            return treeHelper.nodeList.get(lcaIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n    public static class RMQ_SparseTable {\n\n        private int cache[][];\n        private final int[] rawArray;\n\n        public RMQ_SparseTable(int[] a) {\n            rawArray = a;\n            cache = new int[a.length][];\n            for (int i = 0; i < a.length; i++) {\n                int len = a.length - i;\n                len = (int) (Math.log(len) / Math.log(2)) + 1;\n                cache[i] = new int[len];\n                cache[i][0] = i;\n            }\n\n            for (int power = 1; power < cache[0].length; power++) {\n                for (int idx = 0; idx < a.length && power < cache[idx].length; idx++) {\n                    if (a[cache[idx][power - 1]] < a[cache[idx + (1 << (power - 1))][power - 1]]) {\n                        cache[idx][power] = cache[idx][power - 1];\n                    } else {\n                        cache[idx][power] = cache[idx + (1 << (power - 1))][power - 1];\n                    }\n                }\n            }\n\n        }\n\n        /**\n         *\n         * @param left zero-based\n         * @param right zero-based\n         * @return index to input array\n         */\n        public int query(int left, int right) {\n            int maxPower = (int) (Math.log(right - left + 1) / Math.log(2));\n            if (rawArray[cache[left][maxPower]] < rawArray[cache[right - (1 << maxPower) + 1][maxPower]]) {\n                return cache[left][maxPower];\n            } else {\n                return cache[right - (1 << maxPower) + 1][maxPower];\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class TarjanLCA {\n\n        Node root;\n        List<Node> nodeList;\n        boolean[] checked;\n        int[] ancestor;\n        LinkedList<Query>[] queryArray;\n        int[] results;\n        UnionFind uf;\n        static int nextQueryId = 0;\n\n        @SuppressWarnings(\"unchecked\")\n        public TarjanLCA(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            queryArray = new LinkedList[n];\n            for (int i = 0; i < n; i++) {\n                queryArray[i] = new LinkedList<Query>();\n            }\n            checked = new boolean[n];\n            uf = new UnionFind(n);\n            ancestor = new int[n];\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n\n        }\n\n        public void addQuery(int node1, int node2) {\n            Query query = new Query(node2, nextQueryId++);\n            queryArray[node1].add(query);\n            if (node1 != node2) {\n                query = new Query(node1, query.order);\n                queryArray[node2].add(query);\n            }\n        }\n\n        public int[] computeAnswers() {\n            results = new int[nextQueryId];\n            boolean[] expanded = new boolean[nodeList.size()];\n            Stack<Node> dfsStack = new Stack<Node>();\n            dfsStack.push(root);\n\n            while (!dfsStack.isEmpty()) {\n                Node current = dfsStack.peek();\n                if (!expanded[current.id]) {\n                    ancestor[current.id] = current.id;\n                    for (Node child : current.children) {\n                        dfsStack.push(child);\n                    }\n                    expanded[current.id] = true;\n                } else {\n                    int childId = current.id;\n                    if (current.parent != null) {\n                        int parentId = current.parent.id;\n                        uf.union(parentId, childId);\n                        ancestor[uf.find(childId)] = parentId;\n                    }\n\n                    checked[current.id] = true;\n                    ListIterator<Query> it = queryArray[current.id].listIterator();\n                    while (it.hasNext()) {\n                        Query q = it.next();\n                        if (checked[q.idOther]) {\n                            it.remove();\n                            results[q.order] = nodeList.get(ancestor[uf.find(q.idOther)]).id;\n                        }\n                    }\n                    dfsStack.pop();\n                }\n            }\n\n            return results;\n        }\n\n        private void LCA(Node node) {\n            int id = node.id;\n            ancestor[id] = id;\n            for (Node child : node.children) {\n                LCA(child);\n                int childId = child.id;\n                uf.union(id, childId);\n                ancestor[uf.find(childId)] = id;\n            }\n            checked[id] = true;\n\n            ListIterator<Query> it = queryArray[id].listIterator();\n            while (it.hasNext()) {\n                Query q = it.next();\n                if (checked[q.idOther]) {\n                    it.remove();\n                    results[q.order] = nodeList.get(ancestor[uf.find(q.idOther)]).id;\n                }\n            }\n\n        }\n\n        static class Query {\n\n            final int idOther;\n            final int order;\n\n            public Query(int idOther, int order) {\n                this.idOther = idOther;\n                this.order = order;\n            }\n        }\n\n        static class Node {\n\n            int id;\n            Node parent;\n            List<Node> children;\n\n            public Node(int id) {\n                children = new ArrayList<Node>();\n                this.id = id;\n            }\n\n            public Node(int id, Node parent) {\n                this.id = id;\n                this.parent = parent;\n                children = new ArrayList<Node>();\n                if (parent != null) {\n                    parent.children.add(this);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TarjanLCA tarjan = new TarjanLCA(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            tarjan.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            tarjan.addQuery(node1, node2);\n        }\n        for (int lca : tarjan.computeAnswers()) {\n            out.println(lca);\n        }\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static class UnionFind {\n\n        int[] id;\n        int count;\n        int[] weight;  // size indexed by root id\n\n        public UnionFind(int n) {\n            id = new int[n];\n            weight = new int[n];\n            count = n;\n            for (int idx = 0; idx < id.length; idx++) {\n                id[idx] = idx;\n                weight[idx] = 1;\n            }\n        }\n\n        public void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return;\n            }\n            // make smaller root point to larger one\n            if (weight[pRoot] < weight[qRoot]) {\n                id[pRoot] = qRoot;\n                weight[qRoot] += weight[pRoot];\n            } else {\n                id[qRoot] = pRoot;\n                weight[pRoot] += weight[qRoot];\n            }\n            count--;\n        }\n\n        // path compression\n        public int find(int p) {\n            if (id[p] != p) {\n                id[p] = find(id[p]);\n            }\n            return id[p];\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public int count() {\n            return count;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class TarjanLCA {\n\n        boolean[] checked;\n        int[] ancestor;\n        LinkedList<Query>[] queryArray;\n        int[] results;\n        UnionFind uf;\n        static int nextQueryId = 0;\n        final TreeHelper treeHelper;\n\n        @SuppressWarnings(\"unchecked\")\n        public TarjanLCA(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            queryArray = new LinkedList[n];\n            for (int i = 0; i < n; i++) {\n                queryArray[i] = new LinkedList<Query>();\n            }\n            checked = new boolean[n];\n            uf = new UnionFind(n);\n            ancestor = new int[n];\n        }\n\n        public void addQuery(int node1, int node2) {\n            Query query = new Query(node2, nextQueryId++);\n            queryArray[node1].add(query);\n            if (node1 != node2) {\n                query = new Query(node1, query.order);\n                queryArray[node2].add(query);\n            }\n        }\n\n        public int[] computeAnswers() {\n            results = new int[nextQueryId];\n            boolean[] expanded = new boolean[treeHelper.n];\n\n            Stack<Node> dfsStack = new Stack<Node>();\n            dfsStack.push(treeHelper.root);\n\n            while (!dfsStack.isEmpty()) {\n                Node current = dfsStack.peek();\n                if (!expanded[current.id]) {\n                    ancestor[current.id] = current.id;\n                    for (Node child : current.children) {\n                        dfsStack.push(child);\n                    }\n                    expanded[current.id] = true;\n                } else {\n                    checked[current.id] = true;\n                    ListIterator<Query> it = queryArray[current.id].listIterator();\n                    while (it.hasNext()) {\n                        Query q = it.next();\n                        if (checked[q.idOther]) {\n                            results[q.order] = treeHelper.getNodeAt(ancestor[uf.find(q.idOther)]).id;\n                        }\n                    }\n\n                    if (current.parent != null) {\n                        int childId = current.id;\n                        int parentId = current.parent.id;\n                        uf.union(parentId, childId);\n                        ancestor[uf.find(childId)] = parentId;\n                    }\n\n                    dfsStack.pop();\n                }\n            }\n\n            return results;\n        }\n\n        static class Query {\n\n            final int idOther;\n            final int order;\n\n            public Query(int idOther, int order) {\n                this.idOther = idOther;\n                this.order = order;\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        TarjanLCA tarjan = new TarjanLCA(treeHelper);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            tarjan.addQuery(node1, node2);\n        }\n        for (int lca : tarjan.computeAnswers()) {\n            out.println(lca);\n        }\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static class UnionFind {\n\n        int[] id;\n        int count;\n        int[] weight;  // size indexed by root id\n\n        public UnionFind(int n) {\n            id = new int[n];\n            weight = new int[n];\n            count = n;\n            for (int idx = 0; idx < id.length; idx++) {\n                id[idx] = idx;\n                weight[idx] = 1;\n            }\n        }\n\n        public void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return;\n            }\n            // make smaller root point to larger one\n            if (weight[pRoot] < weight[qRoot]) {\n                id[pRoot] = qRoot;\n                weight[qRoot] += weight[pRoot];\n            } else {\n                id[qRoot] = pRoot;\n                weight[pRoot] += weight[qRoot];\n            }\n            count--;\n        }\n\n        // path compression\n        public int find(int p) {\n            if (id[p] != p) {\n                id[p] = find(id[p]);\n            }\n            return id[p];\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public int count() {\n            return count;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n         \n        int n = sc.nextInt();\n        RootedTree t = new RootedTree(n);\n        \n        for(int i=0;i<n;i++){\n        \tint k = sc.nextInt();\n        \tfor(int j=0;j<k;j++){\n        \t\tt.addChild(i,sc.nextInt());\n        \t}\n        }\n        \n        t.makeDepthTable();\n        t.makeLCATable();\n        \n        int q = sc.nextInt();\n        \n        for(int i=0;i<q;i++){\n        \tSystem.out.println(t.LCA(sc.nextInt(),sc.nextInt()));\n        }\n        \n    }\n\n}\n\nclass RootedTree {\n\tint[] parent;\n\tNodeList[] child;\n\tint[] depth; //深さのテーブル。makeDepthTableを呼ぶまで作成されない。\n\tint[][] LCAtable; //LCA用テーブル。makeLCATableを呼ぶまで作成されない。[k][v]が2^k回親を辿ったときに到達する頂点。\n\t\n\tpublic RootedTree(int vnum){\n\t\tparent = new int[vnum];\n\t\tparent[0] = -1;\n\t\t\n\t\tchild= new NodeList[vnum];\n\t\t\n\t\tfor(int i=0;i<vnum;i++){\n\t\t\tchild[i] = new NodeList();\n\t\t}\n\t\t\n\t}\n\t\n\tint vnum(){\n\t\treturn parent.length;\n\t}\n\t\n\t//親に子を登録（同時に子に親を登録）\n\tvoid addChild(int par, int chil){\n\t\tchild[par].add(chil);\n\t\tparent[chil] = par;\n\t}\n\t\n\tNodeList getChildren(int n){\n\t\treturn child[n];\n\t}\n\t\n\tint getParent(int n){\n\t\treturn parent[n];\n\t}\n\t\n\t//深さのテーブルを作る（bfs）\n\tvoid makeDepthTable(){\n\t\tdepth = new int[vnum()];\n\t\tArrays.fill(depth,-1);\n\t\tdepth[0] = 0;\n\t\t\n\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\tq.add(0);\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint p = q.pollFirst();\n\t\t\t\n\t\t\tfor(int c:getChildren(p)){\n\t\t\t\tdepth[c] = depth[p]+1;\n\t\t\t\tq.add(c);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//LCA用のテーブルを作る\n\tvoid makeLCATable(){\n\t\tint logV = log2ceil(vnum()-1);\n\t\tLCAtable = new int[logV][vnum()];\n\t\t\n\t\tfor(int v=0;v<vnum();v++){\n\t\t\tLCAtable[0][v] = parent[v];\n\t\t}\n\t\t\n        for(int k=0;k<logV-1;k++) {\n            for(int v=0;v<vnum();v++) {\n                if(LCAtable[k][v] < 0) {\n                \tLCAtable[k+1][v] = -1;\n                }else {\n                \tLCAtable[k+1][v] = LCAtable[k][LCAtable[k][v]];\n                }\n            }\n        }\n\t}\n\t//log_2(N)の天井\n\tstatic int log2ceil(int n){\n\t\tif(n<=1){\n\t\t\treturn 1; //意図的\n\t\t}\n\t\treturn Integer.numberOfTrailingZeros(Integer.highestOneBit(n-1))+1;\n\t}\n\t//2のn乗（ビット演算）\n\tstatic int twoPow(int n){\n\t\treturn 1<<n;\n\t}\n\t\n\t//aとbのLCA(Lowest Common Ancestor)をLCAテーブルと深さテーブルを用いて求める\n\tint LCA(int u, int v){\n\t\tint logV = log2ceil(vnum());\n\t\t\n        if( depth[u] > depth[v] ) {\n            int t = u; u = v; v = t;\n        }\n\n        for (int k = 0; k < logV; k++) {\n            if(((depth[v] - depth[u]) >> k & 1) == 1) {\n                v = LCAtable[k][v];\n            }\n        }\n        if( u == v ) return u;\n\n        for (int k = logV-1; k >= 0; k--) {\n            if( LCAtable[k][u] != LCAtable[k][v] ) {\n                u = LCAtable[k][u];\n                v = LCAtable[k][v];\n            }\n        }\n        return LCAtable[0][u];\n\t}\n\t\n\tclass NodeList extends ArrayList<Integer>{\n\t\tprivate static final long serialVersionUID = -2846301604366508341L;\n\t}\n}\n\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t// int n = sc.nextInt();\n\t\t// int q = sc.nextInt();\n\t\t// int[] w = new int[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// w[i] = sc.nextInt();\n\t\t// }\n\t\t// HLDecomposition hl = new HLDecomposition(n);\n\t\t// ArrayList<Integer>[] g = new ArrayList[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// int s = sc.nextInt() - 1;\n\t\t// int e = sc.nextInt() - 1;\n\t\t// hl.ae(s, e);\n\t\t// }\n\t\t// hl.pre();\n\t\tint n = sc.nextInt();\n\t\tHLDecomposition hl = new HLDecomposition(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint k = sc.nextInt();\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\thl.ae(i, c);\n\t\t\t}\n\t\t}\n\t\thl.pre();\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tpw.println(hl.lca(u, v));\n\t\t}\n\t\tpw.close();\n\t}\n\n\tclass HLDecomposition {\n\t\tint n;\n\t\tint[] depth;\n\t\tint[] head;\n\t\tint[] heavy;\n\t\tint[] parent;\n\t\tint[] sz;// ??¨?????¨?????§??????\n\t\tArrayList<Integer>[] g;\n\t\tint[] id;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic HLDecomposition(int n) {\n\t\t\tthis.n = n;\n\t\t\tdepth = new int[n];\n\t\t\thead = new int[n];\n\t\t\theavy = new int[n];\n\t\t\tparent = new int[n];\n\t\t\tid = new int[n];\n\t\t\tsz = new int[n];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tArrays.fill(head, -1);\n\t\t\tArrays.fill(id, -1);\n\t\t\tArrays.fill(parent, -1);\n\t\t}\n\n\t\tvoid ae(int a, int b) {\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\n\t\tvoid pre() {\n\t\t\tdfs(0, -1);\n\t\t\tbfs();\n\t\t}\n\n\t\tvoid bfs() {\n\t\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\t\tint gen = 0;\n\t\t\tpend.add(0);\n\t\t\twhile (!pend.isEmpty()) {\n\t\t\t\tint v = pend.pollFirst();\n\t\t\t\tint top = v;\n\t\t\t\tfor (; v != -1; v = heavy[v]) {\n\t\t\t\t\tid[v] = gen++;\n\t\t\t\t\thead[v] = top;\n\t\t\t\t\tfor (int d : g[v]) {\n\t\t\t\t\t\tif (d == parent[v] || d == heavy[v]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpend.add(d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint lca(int u, int v) {\n\t\t\tif (head[u] != head[v]) {\n\t\t\t\tif (depth[head[u]] < depth[head[v]]) {\n\t\t\t\t\tint tmp = u;\n\t\t\t\t\tu = v;\n\t\t\t\t\tv = tmp;\n\t\t\t\t}\n\t\t\t\treturn lca(parent[head[u]], v);\n\t\t\t} else {\n\t\t\t\tif (depth[u] > depth[v]) {\n\t\t\t\t\tint tmp = u;\n\t\t\t\t\tu = v;\n\t\t\t\t\tv = tmp;\n\t\t\t\t}\n\t\t\t\treturn u;\n\t\t\t}\n\t\t}\n\n\t\tint dfs(int c, int p) {\n\t\t\tparent[c] = p;\n\t\t\tint s = 1;\n\t\t\tint to = -1;\n\t\t\tfor (int d : g[c]) {\n\t\t\t\tif (d == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tdepth[d] = depth[c] + 1;\n\t\t\t\ts += dfs(d, c);\n\t\t\t\tif (to == -1 || sz[d] > sz[to]) {\n\t\t\t\t\tto = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[c] = s;\n\t\t\theavy[c] = to;\n\t\t\treturn s;\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// int n = sc.nextInt();\n\t\t// int q = sc.nextInt();\n\t\t// int[] w = new int[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// w[i] = sc.nextInt();\n\t\t// }\n\t\t// HLDecomposition hl = new HLDecomposition(n);\n\t\t// ArrayList<Integer>[] g = new ArrayList[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// int s = sc.nextInt() - 1;\n\t\t// int e = sc.nextInt() - 1;\n\t\t// hl.ae(s, e);\n\t\t// }\n\t\t// hl.pre();\n\t\tint n = sc.nextInt();\n\t\tHLDecomposition hl = new HLDecomposition(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint k = sc.nextInt();\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\thl.ae(i, c);\n\t\t\t}\n\t\t}\n\t\thl.pre();\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tSystem.out.println(hl.lca(u, v));\n\t\t}\n\t}\n\n\tclass HLDecomposition {\n\t\tint n;\n\t\tint[] depth;\n\t\tint[] head;\n\t\tint[] heavy;\n\t\tint[] parent;\n\t\tint[] sz;// ??¨?????¨?????§??????\n\t\tArrayList<Integer>[] g;\n\t\tint[] id;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic HLDecomposition(int n) {\n\t\t\tthis.n = n;\n\t\t\tdepth = new int[n];\n\t\t\thead = new int[n];\n\t\t\theavy = new int[n];\n\t\t\tparent = new int[n];\n\t\t\tid = new int[n];\n\t\t\tsz = new int[n];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tArrays.fill(head, -1);\n\t\t\tArrays.fill(id, -1);\n\t\t\tArrays.fill(parent, -1);\n\t\t}\n\n\t\tvoid ae(int a, int b) {\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\n\t\tvoid pre() {\n\t\t\tdfs(0, -1);\n\t\t\tbfs();\n\t\t}\n\n\t\tvoid bfs() {\n\t\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\t\tint gen = 0;\n\t\t\tpend.add(0);\n\t\t\twhile (!pend.isEmpty()) {\n\t\t\t\tint v = pend.pollFirst();\n\t\t\t\tint top = v;\n\t\t\t\tfor (; v != -1; v = heavy[v]) {\n\t\t\t\t\tid[v] = gen++;\n\t\t\t\t\thead[v] = top;\n\t\t\t\t\tfor (int d : g[v]) {\n\t\t\t\t\t\tif (d == parent[v] || d == heavy[v]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpend.add(d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint lca(int u, int v) {\n\t\t\tif (head[u] != head[v]) {\n\t\t\t\tif (depth[head[u]] < depth[head[v]]) {\n\t\t\t\t\tint tmp = u;\n\t\t\t\t\tu = v;\n\t\t\t\t\tv = tmp;\n\t\t\t\t}\n\t\t\t\treturn lca(parent[head[u]], v);\n\t\t\t} else {\n\t\t\t\tif (depth[u] > depth[v]) {\n\t\t\t\t\tint tmp = u;\n\t\t\t\t\tu = v;\n\t\t\t\t\tv = tmp;\n\t\t\t\t}\n\t\t\t\treturn u;\n\t\t\t}\n\t\t}\n\n\t\tint dfs(int c, int p) {\n\t\t\tparent[c] = p;\n\t\t\tint s = 1;\n\t\t\tint to = -1;\n\t\t\tfor (int d : g[c]) {\n\t\t\t\tif (d == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tdepth[d] = depth[c] + 1;\n\t\t\t\ts += dfs(d, c);\n\t\t\t\tif (to == -1 || sz[d] > sz[to]) {\n\t\t\t\t\tto = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[c] = s;\n\t\t\theavy[c] = to;\n\t\t\treturn s;\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class Main {\n\n    static class TarjanLCA {\n\n        Node root;\n        List<Node> nodeList;\n        boolean[] checked;\n        int[] ancestor;\n        LinkedList<Query> queryList;\n        LinkedList<Query>[] queryArray;\n        int[] results;\n        UnionFind uf;\n\n        public TarjanLCA(int n) {\n            queryList = new LinkedList<Query>();\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n\n        }\n\n        public void addQuery(int node1, int node2) {\n            Query query = new Query(node1, node2);\n            queryList.add(query);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int[] computeAnswers() {\n            results = new int[Query.nextOrder];\n            checked = new boolean[nodeList.size()];\n            uf = new UnionFind(nodeList.size());\n            ancestor = new int[nodeList.size()];\n            queryArray = new LinkedList[nodeList.size()];\n            for (int i = 0; i < nodeList.size(); i++) {\n                queryArray[i] = new LinkedList<Query>();\n            }\n            for (Query q : queryList) {\n                queryArray[q.name1].add(q);\n                if (q.name1 != q.name2) {\n                    queryArray[q.name2].add(q);\n                }\n            }\n\n            LCA(root);\n\n            return results;\n        }\n\n        private void LCA(Node node) {\n            int id = node.name;\n            ancestor[id] = id;\n            for (Node child : node.children) {\n                LCA(child);\n                int childId = child.name;\n                uf.union(id, childId);\n                ancestor[uf.find(childId)] = id;\n            }\n            checked[id] = true;\n\n            ListIterator<Query> it = queryArray[id].listIterator();\n            while (it.hasNext()) {\n                Query q = it.next();\n                int id1 = q.name1;\n                int id2 = q.name2;\n                if (checked[id1] && checked[id2]) {\n                    it.remove();\n                    int idd = (id1 == id ? id2 : id1);\n//                    results[q.order] = nodeList.get(uf.find(idd)).name;\n                    results[q.order] = nodeList.get(ancestor[uf.find(idd)]).name;\n//                    System.out.println(\"!!!\" + results[q.order]);\n                }\n            }\n\n        }\n\n        static class Query {\n\n            final int name1;\n            final int name2;\n            int order;\n            static int nextOrder = 0;\n\n            public Query(int name1, int name2) {\n                this.name1 = name1;\n                this.name2 = name2;\n                order = nextOrder++;\n            }\n        }\n\n        static class Node {\n\n            int name;\n            Node parent;\n            List<Node> children;\n\n            public Node(int id) {\n                children = new ArrayList<Node>();\n                name = id;\n            }\n\n            public Node(int name, Node parent) {\n                this.name = name;\n                this.parent = parent;\n                children = new ArrayList<Node>();\n                if (parent != null) {\n                    parent.children.add(this);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TarjanLCA tarjan = new TarjanLCA(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            tarjan.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            tarjan.addQuery(node1, node2);\n        }\n        for (int lca : tarjan.computeAnswers()) {\n            out.println(lca);\n        }\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static class UnionFind {\n\n        int[] id;\n        int count;\n        int[] weight;  // size indexed by root id\n\n        public UnionFind(int n) {\n            id = new int[n];\n            weight = new int[n];\n            count = n;\n            for (int idx = 0; idx < id.length; idx++) {\n                id[idx] = idx;\n                weight[idx] = 1;\n            }\n        }\n\n        public void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return;\n            }\n            // make smaller root point to larger one\n            if (weight[pRoot] < weight[qRoot]) {\n                id[pRoot] = qRoot;\n                weight[qRoot] += weight[pRoot];\n            } else {\n                id[qRoot] = pRoot;\n                weight[pRoot] += weight[qRoot];\n            }\n            count--;\n        }\n\n        // path compression\n        public int find(int p) {\n            if (id[p] != p) {\n                id[p] = find(id[p]);\n            }\n            return id[p];\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public int count() {\n            return count;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        RMQ_SparseTable rmq;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n//            System.out.println(treeHelper.root.id + \": 0\");\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n//                    System.out.println(child.id + \": \" + depth);\n                } else {\n                    depth--;\n                    dfsStack.pop();\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n//                        System.out.println(dfsStack.peek().node.id + \": \" + depth);\n                    }\n                }\n            }\n//            System.out.println(\"h\");\n//            for (int i = 0; i < h.length; i++) {\n//                System.out.println(h[i]);\n//            }\n//            System.out.println(\"euler\");\n//            for (int i = 0; i < euler.length; i++) {\n//                System.out.println(euler[i]);\n//            }\n//            System.out.println(\"l\");\n//            for (int i = 0; i < level.length; i++) {\n//                System.out.println(level[i]);\n//            }\n            rmq = new RMQ_SparseTable(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1Idx = h[n1.id];\n            int n2Idx = h[n2.id];\n            int lcaIdx = euler[rmq.query(n1Idx, n2Idx)];\n            return treeHelper.nodeList.get(lcaIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n    public static class RMQ_SparseTable {\n\n        private int cache[][];\n\n        public RMQ_SparseTable(int[] a) {\n            cache = new int[a.length][];\n            for (int i = 0; i < a.length; i++) {\n                int len = a.length - i;\n                len = (int) (Math.log(len) / Math.log(2)) + 1;\n                cache[i] = new int[len];\n                cache[i][0] = a[i];\n            }\n\n            for (int power = 1; power < cache[0].length; power++) {\n                for (int idx = 0; idx < a.length && power < cache[idx].length; idx++) {\n                    cache[idx][power] = Math.min(cache[idx][power - 1],\n                            cache[idx + (1 << (power - 1))][power - 1]);\n                }\n            }\n\n        }\n\n        public int query(int left, int right) {\n            int maxPower = (int) (Math.log(right - left + 1) / Math.log(2));\n            return Math.min(cache[left][maxPower], cache[right - (1 << maxPower) + 1][maxPower]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// int n = sc.nextInt();\n\t\t// int q = sc.nextInt();\n\t\t// int[] w = new int[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// w[i] = sc.nextInt();\n\t\t// }\n\t\t// HLDecomposition hl = new HLDecomposition(n);\n\t\t// ArrayList<Integer>[] g = new ArrayList[n];\n\t\t// for (int i = 0; i < n; ++i) {\n\t\t// int s = sc.nextInt() - 1;\n\t\t// int e = sc.nextInt() - 1;\n\t\t// hl.ae(s, e);\n\t\t// }\n\t\t// hl.pre();\n\t\tint n = sc.nextInt();\n\t\tHLDecomposition hl = new HLDecomposition(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint k = sc.nextInt();\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\thl.ae(i, c);\n\t\t\t}\n\t\t}\n\t\thl.pre();\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tSystem.out.println(hl.lca(u, v));\n\t\t}\n\t}\n\n\tclass HLDecomposition {\n\t\tint n;\n\t\tint[] depth;\n\t\tint[] head;\n\t\tint[] heavy;\n\t\tint[] parent;\n\t\tint[] sz;// ??¨?????¨?????§??????\n\t\tArrayList<Integer>[] g;\n\t\tint[] id;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic HLDecomposition(int n) {\n\t\t\tthis.n = n;\n\t\t\tdepth = new int[n];\n\t\t\thead = new int[n];\n\t\t\theavy = new int[n];\n\t\t\tparent = new int[n];\n\t\t\tid = new int[n];\n\t\t\tsz = new int[n];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tArrays.fill(head, -1);\n\t\t\tArrays.fill(id, -1);\n\t\t\tArrays.fill(parent, -1);\n\t\t}\n\n\t\tvoid ae(int a, int b) {\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\n\t\tvoid pre() {\n\t\t\tdfs(0, -1);\n\t\t\tbfs();\n\t\t}\n\n\t\tvoid bfs() {\n\t\t\tArrayDeque<Integer> pend = new ArrayDeque<>();\n\t\t\tint gen = 0;\n\t\t\tpend.add(0);\n\t\t\twhile (!pend.isEmpty()) {\n\t\t\t\tint v = pend.pollFirst();\n\t\t\t\tint top = v;\n\t\t\t\tfor (; v != -1; v = heavy[v]) {\n\t\t\t\t\tid[v] = gen++;\n\t\t\t\t\thead[v] = top;\n\t\t\t\t\tfor (int d : g[v]) {\n\t\t\t\t\t\tif (d == parent[v] || d == heavy[v]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpend.add(d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint lca(int u, int v) {\n\t\t\tif (head[u] != head[v]) {\n\t\t\t\tif (depth[head[u]] < depth[head[v]]) {\n\t\t\t\t\tint tmp = u;\n\t\t\t\t\tu = v;\n\t\t\t\t\tv = tmp;\n\t\t\t\t}\n\t\t\t\treturn lca(parent[head[u]], v);\n\t\t\t} else {\n\t\t\t\tif (depth[u] > depth[v]) {\n\t\t\t\t\tint tmp = u;\n\t\t\t\t\tu = v;\n\t\t\t\t\tv = tmp;\n\t\t\t\t}\n\t\t\t\treturn u;\n\t\t\t}\n\t\t}\n\n\t\tint dfs(int c, int p) {\n\t\t\tparent[c] = p;\n\t\t\tint s = 1;\n\t\t\tint to = -1;\n\t\t\tfor (int d : g[c]) {\n\t\t\t\tif (d == p)\n\t\t\t\t\tcontinue;\n\t\t\t\tdepth[d] = depth[c] + 1;\n\t\t\t\ts += dfs(d, c);\n\t\t\t\tif (to == -1 || sz[d] > sz[to]) {\n\t\t\t\t\tto = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsz[c] = s;\n\t\t\theavy[c] = to;\n\t\t\treturn s;\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        SegmentTree segTree;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n                } else {\n                    dfsStack.pop();\n                    depth--;\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n                    }\n                }\n            }\n            segTree = new SegmentTree(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1VisitIdx = h[n1.id];\n            int n2VisitIdx = h[n2.id];\n            int leftVisitIdx = Math.min(n1VisitIdx, n2VisitIdx);\n            int rightVisitIdx = Math.max(n1VisitIdx, n2VisitIdx);\n            int minIdx = segTree.query(leftVisitIdx, rightVisitIdx);\n            int lcaIdx = euler[minIdx];\n            return treeHelper.nodeList.get(lcaIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n        public static class SegmentTree {\n\n        int[] tree;\n        int[] raw;\n        int rawLen;\n\n        public SegmentTree(int[] arr) {\n            int len = Integer.highestOneBit(arr.length) << 2;\n            tree = new int[len];\n            raw = arr;\n            rawLen = raw.length;\n            initTree(1, 0, arr.length - 1);\n        }\n\n        /**\n         * @param idx of tree[]\n         * @param rangeBegin of raw[]\n         * @param rangeEnd of raw[]\n         */\n        private void initTree(int idx, int rangeBegin, int rangeEnd) {\n            if (rangeBegin == rangeEnd) {\n                tree[idx] = raw[rangeBegin];\n            } else {\n                initTree(idx * 2, rangeBegin, (rangeEnd + rangeBegin) / 2);\n                initTree(idx * 2 + 1, (rangeEnd + rangeBegin) / 2 + 1, rangeEnd);\n                tree[idx] = tree[idx * 2] < tree[idx * 2 + 1] ? tree[idx * 2] : tree[idx * 2 + 1];\n            }\n        }\n\n        /**\n         * left <= right\n         *\n         * @param left\n         * @param right\n         * @return\n         */\n        public int query(int left, int right) {\n            return query(1, 0, rawLen - 1, left, right);\n        }\n\n        public void update(int idx, int newValue) {\n            update(idx, newValue, 1, 0, rawLen - 1);\n        }\n\n        /**\n         * Invariant: rangeBegin <= left <= right <= rangeEnd\n         */\n        private int query(int treeNodeIdx, int rangeBegin, int rangeEnd, int left, int right) {\n            int leftResult = Integer.MAX_VALUE;\n            int rightResult = Integer.MAX_VALUE;;\n            if (rangeBegin == rangeEnd) {\n                return tree[treeNodeIdx];\n            }\n            if (left == rangeBegin && right == rangeEnd) {\n                return tree[treeNodeIdx];\n            }\n            int rangeMid = (rangeBegin + rangeEnd) / 2;\n            if (left <= rangeMid) {\n                leftResult = query(treeNodeIdx * 2, rangeBegin, rangeMid, left, Math.min(right, rangeMid));\n            }\n            if (rangeMid + 1 <= right) {\n                rightResult = query(treeNodeIdx * 2 + 1, rangeMid + 1, rangeEnd, Math.max(left, rangeMid + 1), right);\n            }\n\n            return Math.min(leftResult, rightResult);\n\n        }\n\n        private void update(int idxToUpdate, int newValue, int idx, int rangeBegin, int rangeEnd) {\n            if (rangeBegin == rangeEnd) {\n                tree[idx] = newValue;\n            } else {\n                int rangeMid = (rangeBegin + rangeEnd) / 2;\n                if (idxToUpdate > rangeMid) {\n                    update(idxToUpdate, newValue, idx * 2 + 1, rangeMid + 1, rangeEnd);\n                } else {\n                    update(idxToUpdate, newValue, idx * 2, rangeBegin, rangeMid);\n                }\n                tree[idx] = tree[idx * 2] < tree[idx * 2 + 1] ? tree[idx * 2] : tree[idx * 2 + 1];\n            }\n        }\n\n    }\n\n        \n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    int n;\n    List<List<Integer>> graph;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new LinkedList<>());\n        }\n        for (int i = 0; i < n; i++) {\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                int c = sc.nextInt();\n                graph.get(i).add(c);\n                graph.get(c).add(i);\n            }\n        }\n        LowestCommonAncestor lca = new LowestCommonAncestor(graph);\n        int q = sc.nextInt();\n        for (int i = 0; i < q; i++) {\n            System.out.println(lca.lca(sc.nextInt(), sc.nextInt()));\n        }\n    }\n\n    class LowestCommonAncestor {\n        List<List<Integer>> graph;\n        int[][] parents;\n        int[] depth;\n\n        LowestCommonAncestor(List<List<Integer>> graph) {\n            this.graph = graph;\n            int n = graph.size();\n            int logN = (int)Math.ceil(Math.log(n)/Math.log(2)+1e-10);\n            parents = new int[logN][n];\n            depth = new int[n];\n            init(0, -1, 0);\n            initParents();\n        }\n\n        int lca(int u, int v) {\n            if (depth[u] > depth[v]) {\n                int temp = u;\n                u = v;\n                v = temp;\n            }\n            for (int i = 0; i < parents.length; i++) {\n                if (((depth[v] - depth[u]) >> i & 1) > 0) {\n                    v = parents[i][v];\n                }\n            }\n            if (u == v) {\n                return u;\n            }\n            for (int i = parents.length - 1; i >= 0; i--) {\n                if (parents[i][u] != parents[i][v]) {\n                    u = parents[i][u];\n                    v = parents[i][v];\n                }\n            }\n            return parents[0][u];\n        }\n\n        void init(int v, int p, int d) {\n            Deque<State> stack = new LinkedList<>();\n            stack.push(new State(v, p, d));\n            while (!stack.isEmpty()) {\n                State s = stack.pop();\n                parents[0][s.v] = s.p;\n                depth[s.v] = s.d;\n                for (int next : graph.get(s.v)) {\n                    if (next != s.p) {\n                        stack.push(new State(next, s.v, s.d + 1));\n                    }\n                }\n            }\n        }\n\n        void initParents() {\n            for (int i = 0; i < parents.length - 1; i++) {\n                for (int j = 0; j < parents[0].length; j++) {\n                    if (parents[i][j] < 0) {\n                        parents[i + 1][j] = -1;\n                    } else {\n                        parents[i + 1][j] = parents[i][parents[i][j]];\n                    }\n                }\n            }\n        }\n    }\n\n    class State {\n        int v;\n        int p;\n        int d;\n\n        State(int v, int p, int d) {\n            this.v = v;\n            this.p = p;\n            this.d = d;\n        }\n    }\n\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\n \npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Node[] V;\n\tstatic int knum = 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\t\n\t\twhile(Math.pow(2, knum) <= n) {\n\t\t\tknum++;\n\t\t}\n\t\t\n\t\tV = new Node[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tV[i] = new Node();\n\t\t}\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tint k = sc.nextInt();\n\t\t\tfor(int j=0; j<k; j++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tV[i].child.add(c);\n\t\t\t\tV[c].parent[0] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tV[0].dfs(0);\n\t\t\n\t\tfor(int k=1; k<=knum; k++) {\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(V[i].parent[k-1] == -1) {\n\t\t\t\t\tV[i].parent[k] = -1;\n\t\t\t\t} else {\n\t\t\t\t\tV[i].parent[k] = V[V[i].parent[k-1]].parent[k-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint q = sc.nextInt();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor(int i=0; i<q; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tans.append(lca(u, v));\n\t\t\tans.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\t\n\tstatic class Node {\n\t\tint[] parent = new int[knum+1];\n\t\tHashSet<Integer> child = new HashSet<>();\n\t\tint depth;\n\t\t\n\t\tvoid dfs(int d) {\n\t\t\tdepth = d;\n\t\t\tfor(int x : child) {\n\t\t\t\tV[x].dfs(d+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int lca(int u, int v) {\n\t\tif(V[u].depth > V[v].depth) {\n\t\t\treturn lca(v, u);\n\t\t}\n\t\t\n\t\tfor(int k=0; k<=knum; k++) {\n\t\t\tif(((V[v].depth - V[u].depth) >> k & 1) == 1) {\n\t\t\t\tv = V[v].parent[k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (u == v) {\n\t\t\treturn u;\n\t\t}\n\t\t\n\t\tfor(int k=knum; k>=0; k--) {\n\t\t\tif(V[u].parent[k] != V[v].parent[k]) {\n\t\t\t\tu = V[u].parent[k];\n\t\t\t\tv = V[v].parent[k];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn V[u].parent[0];\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class TarjanLCA {\n\n        Node root;\n        List<Node> nodeList;\n        boolean[] checked;\n        int[] ancestor;\n        LinkedList<Query>[] queryArray;\n        int[] results;\n        UnionFind uf;\n        static int nextQueryId = 0;\n\n        @SuppressWarnings(\"unchecked\")\n        public TarjanLCA(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            queryArray = new LinkedList[n];\n            for (int i = 0; i < n; i++) {\n                queryArray[i] = new LinkedList<Query>();\n            }\n            checked = new boolean[n];\n            uf = new UnionFind(n);\n            ancestor = new int[n];\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n\n        }\n\n        public void addQuery(int node1, int node2) {\n            Query query = new Query(node2, nextQueryId++);\n            queryArray[node1].add(query);\n            if (node1 != node2) {\n                query = new Query(node1, query.order);\n                queryArray[node2].add(query);\n            }\n        }\n\n        public int[] computeAnswers() {\n            results = new int[nextQueryId];\n            boolean[] expanded = new boolean[nodeList.size()];\n            Stack<Node> dfsStack = new Stack<Node>();\n            dfsStack.push(root);\n\n            while (!dfsStack.isEmpty()) {\n                Node current = dfsStack.peek();\n                if (!expanded[current.id]) {\n                    ancestor[current.id] = current.id;\n                    for (Node child : current.children) {\n                        dfsStack.push(child);\n                    }\n                    expanded[current.id] = true;\n                } else {\n                    checked[current.id] = true;\n                    ListIterator<Query> it = queryArray[current.id].listIterator();\n                    while (it.hasNext()) {\n                        Query q = it.next();\n                        if (checked[q.idOther]) {\n                            it.remove();\n                            results[q.order] = nodeList.get(ancestor[uf.find(q.idOther)]).id;\n                        }\n                    }\n                    \n                    if (current.parent != null) {\n                        int childId = current.id;\n                        int parentId = current.parent.id;\n                        uf.union(parentId, childId);\n                        ancestor[uf.find(childId)] = parentId;\n                    }\n\n                    dfsStack.pop();\n                }\n            }\n\n            return results;\n        }\n\n        static class Query {\n\n            final int idOther;\n            final int order;\n\n            public Query(int idOther, int order) {\n                this.idOther = idOther;\n                this.order = order;\n            }\n        }\n\n        static class Node {\n\n            int id;\n            Node parent;\n            List<Node> children;\n\n            public Node(int id) {\n                children = new ArrayList<Node>();\n                this.id = id;\n            }\n\n            public Node(int id, Node parent) {\n                this.id = id;\n                this.parent = parent;\n                children = new ArrayList<Node>();\n                if (parent != null) {\n                    parent.children.add(this);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TarjanLCA tarjan = new TarjanLCA(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            tarjan.createChild(parentIdx, children);\n        }\n        int q = nextInt();\n        while (q-- > 0) {\n            int node1 = nextInt();\n            int node2 = nextInt();\n            tarjan.addQuery(node1, node2);\n        }\n        for (int lca : tarjan.computeAnswers()) {\n            out.println(lca);\n        }\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n    public static class UnionFind {\n\n        int[] id;\n        int count;\n        int[] weight;  // size indexed by root id\n\n        public UnionFind(int n) {\n            id = new int[n];\n            weight = new int[n];\n            count = n;\n            for (int idx = 0; idx < id.length; idx++) {\n                id[idx] = idx;\n                weight[idx] = 1;\n            }\n        }\n\n        public void union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return;\n            }\n            // make smaller root point to larger one\n            if (weight[pRoot] < weight[qRoot]) {\n                id[pRoot] = qRoot;\n                weight[qRoot] += weight[pRoot];\n            } else {\n                id[qRoot] = pRoot;\n                weight[pRoot] += weight[qRoot];\n            }\n            count--;\n        }\n\n        // path compression\n        public int find(int p) {\n            if (id[p] != p) {\n                id[p] = find(id[p]);\n            }\n            return id[p];\n        }\n\n        public boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n\n        public int count() {\n            return count;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int N;\n    static int[][] G;\n    static int Q;\n    static int[] U;\n    static int[] V;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        G = new int[N][];\n        for (int i = 0; i < N; i++) {\n            int k = sc.nextInt();\n            G[i] = sc.nextIntArray(k);\n        }\n        Q = sc.nextInt();\n        U = new int[Q];\n        V = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            U[i] = sc.nextInt();\n            V[i] = sc.nextInt();\n        }\n\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i : solve()) {\n            pw.println(i);\n        }\n        pw.flush();\n    }\n\n    static int[] solve() {\n        LCA lca = new LCA(N);\n        lca.init(0, G);\n\n        int[] ans = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = lca.apply(U[i], V[i]);\n        }\n        return ans;\n    }\n\n    static class LCA {\n\n        final int V;\n        final int LOG_V;\n        final int[][] parent;\n        final int[] depth;\n\n        public LCA(int V) {\n            this.V = V;\n            this.LOG_V = Integer.numberOfTrailingZeros(Integer.highestOneBit(V - 1)) + 1;\n            this.parent = new int[LOG_V][V];\n            this.depth = new int[V];\n        }\n\n        void init(int root, int[][] G) {\n            bfs(root, G);\n\n            for (int k = 0; k+1 < LOG_V; k++) {\n                for (int v = 0; v < V; v++) {\n                    if( parent[k][v] < 0 ) {\n                        parent[k+1][v] = -1;\n                    } else {\n                        parent[k+1][v] = parent[k][parent[k][v]];\n                    }\n                }\n            }\n        }\n\n        private void bfs(int root, int[][] G) {\n            ArrayDeque<State> q = new ArrayDeque<>();\n            q.add( new State(root, -1, 0) );\n\n            while(!q.isEmpty()) {\n                State state = q.poll();\n\n                parent[0][state.v] = state.p;\n                depth[state.v] = state.d;\n\n                for (int i = 0; i < G[state.v].length; i++) {\n                    if( G[state.v][i] != state.p ) {\n                        q.add(new State(G[state.v][i], state.v, state.d+1));\n                    }\n                }\n            }\n        }\n\n        static class State {\n            int v, p, d;\n\n            public State(int v, int p, int d) {\n                this.v = v;\n                this.p = p;\n                this.d = d;\n            }\n        }\n\n        int apply(int u, int v) {\n            if( depth[u] > depth[v] ) {\n                int t = u; u = v; v = t;\n            }\n\n            for (int k = 0; k < LOG_V; k++) {\n                if(((depth[v] - depth[u]) >> k & 1) == 1) {\n                    v = parent[k][v];\n                }\n            }\n            if( u == v ) return u;\n\n            for (int k = LOG_V-1; k >= 0; k--) {\n                if( parent[k][u] != parent[k][v] ) {\n                    u = parent[k][u];\n                    v = parent[k][v];\n                }\n            }\n            return parent[0][u];\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.stream.Stream;\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final long INF = Long.MAX_VALUE / 2;\n\tint len;\n\tint[][] up;\n\tint[] tin;\n\tint[] tout;\n\tint time;\n\tprivate static void solve() {\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\tint n = ni();\n\t\tList<Integer>[] tree = Stream.generate(ArrayList::new).limit(n).toArray(List[]::new);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k = ni();\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint t = ni();\n\t\t\t\ttree[i].add(t);\n\t\t\t\ttree[t].add(i);\n\t\t\t}\n\t\t}\n\t\tMain t = new Main(tree, 0);\n\t\tint q = ni();\n\t\twhile(q-->0){\n\t\t\tpr.println(t.lca(ni(),ni()));\n\t\t}\n\t\tpr.flush();\n\t}\n\tvoid dfs(List<Integer>[] tree, int u, int p) {\n\t\ttin[u] = time++;\n\t\tup[0][u] = p;\n\t\tfor (int i = 1; i < len; i++)\n\t\t\tup[i][u] = up[i - 1][up[i - 1][u]];\n\t\tfor (int v : tree[u])\n\t\t\tif (v != p)\n\t\t\t\tdfs(tree, v, u);\n\t\ttout[u] = time++;\n\t}\n\n\tpublic Main(List<Integer>[] tree, int root) {\n\t\tint n = tree.length;\n\t\tlen = 1;\n\t\twhile ((1 << len) <= n) ++len;\n\t\tup = new int[len][n];\n\t\ttin = new int[n];\n\t\ttout = new int[n];\n\t\tdfs(tree, root, root);\n\t}\n\n\tboolean isParent(int parent, int child) {\n\t\treturn tin[parent] <= tin[child] && tout[child] <= tout[parent];\n\t}\n\n\tpublic int lca(int a, int b) {\n\t\tif (isParent(a, b))\n\t\t\treturn a;\n\t\tif (isParent(b, a))\n\t\t\treturn b;\n\t\tfor (int i = len - 1; i >= 0; i--)\n\t\t\tif (!isParent(up[i][a], b))\n\t\t\t\ta = up[i][a];\n\t\treturn up[0][a];\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\t//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        SegmentTree segTree;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n                } else {\n                    dfsStack.pop();\n                    depth--;\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n                    }\n                }\n            }\n            segTree = new SegmentTree(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1VisitIdx = h[n1.id];\n            int n2VisitIdx = h[n2.id];\n            int minIdx = segTree.query(n1VisitIdx, n2VisitIdx);\n            int lcaIdx = euler[minIdx];\n            return treeHelper.nodeList.get(lcaIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n    public static class SegmentTree {\n\n        int[] tree;\n        int[] raw;\n        int rawLen;\n\n        public SegmentTree(int[] arr) {\n            int len = Integer.highestOneBit(arr.length) << 2;\n            tree = new int[len];\n            raw = arr;\n            rawLen = raw.length;\n            initTree(1, 0, arr.length - 1);\n        }\n\n        /**\n         * @param treeNodeIdx of tree[]\n         * @param rangeBegin of raw[]\n         * @param rangeEnd of raw[]\n         */\n        private void initTree(int treeNodeIdx, int rangeBegin, int rangeEnd) {\n            if (rangeBegin == rangeEnd) {\n                tree[treeNodeIdx] = raw[rangeBegin];\n            } else {\n                initTree(treeNodeIdx * 2, rangeBegin, (rangeEnd + rangeBegin) / 2);\n                initTree(treeNodeIdx * 2 + 1, (rangeEnd + rangeBegin) / 2 + 1, rangeEnd);\n                tree[treeNodeIdx] = tree[treeNodeIdx * 2] < tree[treeNodeIdx * 2 + 1] ? tree[treeNodeIdx * 2] : tree[treeNodeIdx * 2 + 1];\n            }\n        }\n\n        /**\n         * \n         * @param left\n         * @param right\n         * @return index not value\n         */\n        public int query(int left, int right) {\n            return query(1, 0, rawLen - 1, left, right);\n        }\n\n        /**\n         * Invariant: rangeBegin <= left <= right <= rangeEnd\n         * @param treeNodeIdx treeNodeIdx of tree[]\n         * @param rangeBegin\n         * @param rangeEnd\n         * @param left\n         * @param right\n         * @return index to raw array\n         */\n        private int query(int treeNodeIdx, int rangeBegin, int rangeEnd, int left, int right) {\n            Integer leftResult = null;\n            Integer rightResult = null;\n            if (rangeBegin == rangeEnd) {\n                return rangeBegin;\n            }\n            int rangeMid = (rangeBegin + rangeEnd) / 2;\n            if (left <= rangeMid) {\n                leftResult = query(treeNodeIdx * 2, rangeBegin, rangeMid, left, Math.min(right, rangeMid));\n            }\n            if (rangeMid + 1 <= right) {\n                rightResult = query(treeNodeIdx * 2 + 1, rangeMid + 1, rangeEnd, Math.max(left, rangeMid + 1), right);\n            }\n            if (leftResult == null) {\n                return rightResult;\n            } else if (rightResult == null) {\n                return leftResult;\n            } else {\n                return raw[leftResult] < raw[rightResult] ? leftResult : rightResult;\n            }\n        }\n\n    }\n        \n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Main {\n\n    static class Node {\n\n        int id;\n        Node parent;\n        List<Node> children;\n\n        public Node(int id) {\n            children = new ArrayList<Node>();\n            this.id = id;\n        }\n\n        public Node(int id, Node parent) {\n            this.id = id;\n            this.parent = parent;\n            children = new ArrayList<Node>();\n            if (parent != null) {\n                parent.children.add(this);\n            }\n        }\n    }\n\n    static class TreeHelper {\n\n        Node root;\n        List<Node> nodeList;\n        int n;\n\n        public TreeHelper(int n) {\n            nodeList = new ArrayList<Node>();\n            for (int i = 0; i < n; i++) {\n                nodeList.add(new Node(i));\n            }\n            root = nodeList.get(0);\n            this.n = n;\n        }\n\n        public void createChild(int parentId, int[] children) {\n            Node parent = nodeList.get(parentId);\n            for (int childId : children) {\n                Node child = nodeList.get(childId);\n                parent.children.add(child);\n                child.parent = parent;\n            }\n        }\n\n        public Node getNodeAt(int idx) {\n            return nodeList.get(idx);\n        }\n    }\n\n    static class ReductionToRMQ {\n\n        int[] euler;\n        int[] level;\n        int[] h;\n        TreeHelper treeHelper;\n        SegmentTree segTree;\n\n        public ReductionToRMQ(TreeHelper treeHelper) {\n            this.treeHelper = treeHelper;\n            int n = treeHelper.n;\n            euler = new int[2 * n - 1];\n            level = new int[2 * n - 1];\n            h = new int[n];\n            int depth = 0;\n            int visitIdx = 0;\n\n            Stack<NodeWithIterator> dfsStack = new Stack<NodeWithIterator>();\n            dfsStack.push(new NodeWithIterator(treeHelper.root));\n            while (!dfsStack.isEmpty()) {\n                Iterator<Node> it = dfsStack.peek().it;\n                if (it.hasNext()) {\n                    Node child = it.next();\n                    dfsStack.push(new NodeWithIterator(child));\n                    depth++;\n                    visitIdx++;\n                    euler[visitIdx] = child.id;\n                    level[visitIdx] = depth;\n                    h[child.id] = visitIdx;\n                } else {\n                    dfsStack.pop();\n                    depth--;\n                    if (!dfsStack.isEmpty()) {\n                        visitIdx++;\n                        euler[visitIdx] = dfsStack.peek().node.id;\n                        level[visitIdx] = depth;\n                    }\n                }\n            }\n            segTree = new SegmentTree(level);\n        }\n\n        public Node lca(Node n1, Node n2) {\n            int n1VisitIdx = h[n1.id];\n            int n2VisitIdx = h[n2.id];\n            int leftVisitIdx = Math.min(n1VisitIdx, n2VisitIdx);\n            int rightVisitIdx = Math.max(n1VisitIdx, n2VisitIdx);\n            int minIdx = segTree.query(leftVisitIdx, rightVisitIdx);\n            int lcaIdx = euler[minIdx];\n            return treeHelper.nodeList.get(lcaIdx);\n        }\n\n        class NodeWithIterator {\n\n            final Node node;\n            final Iterator<Node> it;\n\n            public NodeWithIterator(Node node) {\n                this.node = node;\n                it = node.children.iterator();\n            }\n        }\n    }\n\n    public static class SegmentTree {\n\n        int[] tree;\n        int[] raw;\n        int rawLen;\n\n        public SegmentTree(int[] arr) {\n            int len = Integer.highestOneBit(arr.length) << 2;\n            tree = new int[len];\n            raw = arr;\n            rawLen = raw.length;\n            initTree(1, 0, arr.length - 1);\n        }\n\n        /**\n         * @param treeNodeIdx of tree[]\n         * @param rangeBegin of raw[]\n         * @param rangeEnd of raw[]\n         */\n        private void initTree(int treeNodeIdx, int rangeBegin, int rangeEnd) {\n            if (rangeBegin == rangeEnd) {\n                tree[treeNodeIdx] = raw[rangeBegin];\n            } else {\n                initTree(treeNodeIdx * 2, rangeBegin, (rangeEnd + rangeBegin) / 2);\n                initTree(treeNodeIdx * 2 + 1, (rangeEnd + rangeBegin) / 2 + 1, rangeEnd);\n                tree[treeNodeIdx] = tree[treeNodeIdx * 2] < tree[treeNodeIdx * 2 + 1] ? tree[treeNodeIdx * 2] : tree[treeNodeIdx * 2 + 1];\n            }\n        }\n\n        /**\n         * \n         * @param left\n         * @param right\n         * @return index not value\n         */\n        public int query(int left, int right) {\n            return query(1, 0, rawLen - 1, left, right);\n        }\n\n        /**\n         * Invariant: rangeBegin <= left <= right <= rangeEnd\n         * @param treeNodeIdx treeNodeIdx of tree[]\n         * @param rangeBegin\n         * @param rangeEnd\n         * @param left\n         * @param right\n         * @return index to raw array\n         */\n        private int query(int treeNodeIdx, int rangeBegin, int rangeEnd, int left, int right) {\n            Integer leftResult = null;\n            Integer rightResult = null;\n            if (rangeBegin == rangeEnd) {\n                return rangeBegin;\n            }\n            int rangeMid = (rangeBegin + rangeEnd) / 2;\n            if (left <= rangeMid) {\n                leftResult = query(treeNodeIdx * 2, rangeBegin, rangeMid, left, Math.min(right, rangeMid));\n            }\n            if (rangeMid + 1 <= right) {\n                rightResult = query(treeNodeIdx * 2 + 1, rangeMid + 1, rangeEnd, Math.max(left, rangeMid + 1), right);\n            }\n            if (leftResult == null) {\n                return rightResult;\n            } else if (rightResult == null) {\n                return leftResult;\n            } else {\n                return raw[leftResult] < raw[rightResult] ? leftResult : rightResult;\n            }\n        }\n\n    }\n        \n    public static void main(String[] args) throws IOException {\n        int n = nextInt();\n        TreeHelper treeHelper = new TreeHelper(n);\n        for (int parentIdx = 0; parentIdx < n; parentIdx++) {\n            int childNum = nextInt();\n            int[] children = new int[childNum];\n            for (int childIdx = 0; childIdx < childNum; childIdx++) {\n                children[childIdx] = nextInt();\n            }\n            treeHelper.createChild(parentIdx, children);\n        }\n        ReductionToRMQ rmqSolver = new ReductionToRMQ(treeHelper);\n\n        int q = nextInt();\n        while (q-- > 0) {\n            int id1 = nextInt();\n            int id2 = nextInt();\n            out.println(rmqSolver.lca(treeHelper.getNodeAt(id1), treeHelper.getNodeAt(id2)).id);\n        }\n\n        out.flush();\n    }\n\n    private static final StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    private static final PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static String nextString() throws IOException {\n        in.nextToken();\n        return in.sval;\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int();\n        var HL = new HeavyLightDecomposition(N);\n        for (int i = 0; i < N; i++)\n        {\n            int num = Reader.Int();\n            for (int t = 0; t < num; t++)\n                HL.AddEdge(i, Reader.Int());\n        }\n        int Q = Reader.Int();\n        var table = Reader.IntTable(Q);\n        HL.Build();\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        foreach (var q in table)\n            Console.WriteLine(HL.LCA(q[0], q[1]));\n        Console.Out.Flush();\n    }\n\n    class HeavyLightDecomposition\n    {\n        public readonly int N;\n        List<int>[] E;\n        int[] Y, X, Size, Parent;\n        List<List<int>> Path; // debug\n        List<int> PathDepth;\n\n        public HeavyLightDecomposition(int n)\n        {\n            N = n;\n            Y = new int[N]; X = new int[N];\n            Size = new int[N]; Parent = new int[N];\n            Path = new List<List<int>>();\n            Path.Add(new List<int>());\n            PathDepth = new List<int>();\n            PathDepth.Add(0);\n            E = new List<int>[N];\n            for (int i = 0; i < N; i++) E[i] = new List<int>();\n        }\n        public void AddEdge(int a, int b)\n        {\n            E[a].Add(b);\n            E[b].Add(a);\n        }\n        public void Build(int root = 0)\n        {\n            CountSize(root, -1);\n            CompressPath(0, 0, 0);\n        }\n        int CountSize(int a, int parent)\n        {\n            Parent[a] = parent;\n            Size[a] = 1;\n            var e = E[a];\n            for (int i = 0; i < e.Count; i++)\n                if (e[i] == parent) { e.RemoveAt(i); i--; }\n                else\n                {\n                    int size = CountSize(e[i], a);\n                    Size[a] += size;\n                    if (size > Size[e[0]]) { int t = e[0]; e[0] = e[i]; e[i] = t; }\n                }\n            return Size[a];\n        }\n        void CompressPath(int a, int pathId, int depth)\n        {\n            Y[a] = pathId;\n            X[a] = Path[pathId].Count;\n            Path[pathId].Add(a);\n            if (E[a].Count == 0) return;\n            CompressPath(E[a][0], pathId, depth);\n            for (int i = 1; i < E[a].Count; i++)\n            {\n                Path.Add(new List<int>());\n                PathDepth.Add(depth + 1);\n                CompressPath(E[a][i], Path.Count - 1, depth + 1);\n            }\n        }\n\n        public int LCA(int a, int b)\n        {\n            int pa = Y[a], pb = Y[b];\n            if (pa == pb) return (X[a] < X[b]) ? a : b;\n            if (PathDepth[pa] >= PathDepth[pb]) return LCA(Parent[Path[pa][0]], b);\n            return LCA(a, Parent[Path[pb][0]]);\n        }\n\n        public void debug()\n        {\n            for (int pi = 0; pi < Path.Count; pi++)\n            {\n                Console.Write(\"Path \" + pi.ToString().PadLeft(2) + \" depth:\" + PathDepth[pi] + \" - \");\n                Console.WriteLine(string.Join(\", \", Path[pi]));\n            }\n        }\n    }\n\n}\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()); return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing static Template;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing Pi = Pair<int, int>;\nusing Number = System.Int64;\n\nclass Solver\n{\n    public void Solve()\n    {\n        var num = Input.num;\n        var t = new LowestCommonAncestor(num);\n        for (var i = 0; i < num; i++)\n        {\n            int k = Input.Next<int>();\n            for (var j = 0; j < k; j++)\n                t.AddEdge(i, Input.Next<int>());\n        }\n        var q = Input.num;\n        t.Build();\n        while (q-- > 0)\n        {\n            int u, v;\n            Input.Make(out u, out v);\n            WriteLine(t.LCA(u, v));\n        }\n    }\n}\n\nclass LowestCommonAncestor\n{\n    private List<int>[] edge;\n    private int num, lb;\n    private int[][] parent;\n    private int[] depth;\n    public LowestCommonAncestor(int num)\n    { this.num = num; edge = Create(num, () => new List<int>()); }\n    public void AddEdge(int u, int v)\n    {\n        edge[u].Add(v); edge[v].Add(u);\n    }\n    public void Build(int root = 0)\n    {\n        for (lb = 31; lb >= 0; lb--)\n            if ((1 & num >> lb) == 1)\n                break;\n        parent = Create(lb + 1, () => Create(num, () => -1));\n        depth = new int[num];\n        var st = new Stack<int>();\n        st.Push(-1);\n        st.Push(root);\n        while (st.Any())\n        {\n            int i=st.Pop(),p = st.Pop();\n            parent[0][i] = p;\n            foreach (var e in edge[i])\n                if (e != p)\n                {\n                    depth[e] = depth[i] + 1;\n                    st.Push(i);st.Push(e);\n                }\n        }\n        for (var i = 1; i <= lb; i++)\n            for (var j = 0; j < num; j++)\n                if (parent[i - 1][j] != -1)\n                {\n                    parent[i][j] = parent[i - 1][parent[i - 1][j]];\n                }\n    }\n    public int LCA(int u, int v)\n    {\n        if (depth[u] > depth[v])\n            swap(ref u, ref v);\n        for (var i = lb; i >= 0; i--)\n            if ((1 & (depth[v] - depth[u]) >> i) == 1)\n                v = parent[i][v];\n        if (u == v) return u;\n        for (var i = lb; i >= 0; i--)\n            if (parent[i][u] != parent[i][v])\n            { u = parent[i][u]; v = parent[i][v]; }\n        return parent[0][u];\n    }\n}\n#region Template\npublic class Template\n{\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == 1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == -1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T v1, ref T v2)\n    { var t = v2; v2 = v1; v1 = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f)\n        => Enumerable.Repeat(0, n).Select(_ => f()).ToArray();\n    public static void Fail() => Fail(\"No\");\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n    static void Main(string[] args)\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        var p = new Solver();\n        for (var i = 1; i > 0; --i)\n            p.Solve();\n        Console.Out.Flush();\n    }\n}\n\npublic class Input\n{\n    public static string read => Console.ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => Convert.ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => Convert.ToInt64(read);\n    public static char[][] grid(int h)\n        => Create(h, () => read.ToCharArray());\n    public static int[] ar1D(int n)\n        => Create(n, () => num);\n    public static long[] arL1D(int n)\n        => Create(n, () => numL);\n    public static string[] strs(int n)\n        => Create(n, () => read);\n    public static int[][] ar2D(int n)\n        => Create(n, () => ar);\n    public static long[][] arL2D(int n)\n        => Create(n, () => arL);\n    public static List<T>[] edge<T>(int n)\n        => Create(n, () => new List<T>());\n    public static void Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        v1 = Next<T1>();\n        v2 = Next<T2>();\n    }\n    public static void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        Make(out v1, out v2);\n        v3 = Next<T3>();\n    }\n    public static void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4)\n    {\n        Make(out v1, out v2, out v3);\n        v4 = Next<T4>();\n    }\n    public static void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5)\n    {\n        Make(out v1, out v2, out v3, out v4);\n        v5 = Next<T5>();\n    }\n    public static void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6)\n    {\n        Make(out v1, out v2, out v3, out v4, out v5);\n        v6 = Next<T6>();\n    }\n    static Input()\n    {\n        sc = new Queue<string>();\n        dic = new Dictionary<Type, Func<string, object>>();\n        dic[typeof(int)] = s => int.Parse(s);\n        dic[typeof(long)] = s => long.Parse(s);\n        dic[typeof(char)] = s => char.Parse(s);\n        dic[typeof(double)] = s => double.Parse(s);\n        dic[typeof(uint)] = s => uint.Parse(s);\n        dic[typeof(ulong)] = s => ulong.Parse(s);\n        dic[typeof(string)] = s => s;\n    }\n    private static Dictionary<Type, Func<string, object>> dic;\n    private static Queue<string> sc;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T Next<T>() { if (sc.Count == 0) foreach (var item in read.Split(' ')) sc.Enqueue(item); return (T)dic[typeof(T)](sc.Dequeue()); }\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { v1 = Input.Next<T1>(); v2 = Input.Next<T2>(); }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { v3 = Input.Next<T3>(); }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n}\n#endregion\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic int n = int.Parse(Console.ReadLine());\nstatic List<int>[] nextList = new List<int>[n];\nstatic List<int>[] childrenList = new List<int>[n];\nstatic int[] depths = new int[n];//木の深さ\n\n\tstatic void Main()\n\t{\n    for(int i = 0; i < n; i++)\n    {\n      childrenList[i] = new List<int>();\n      int[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),int.Parse);\n      for(int j = 0; j < nums[0]; j++)\n      {\n        childrenList[i].Add(nums[j+1]);\n      }\n    }\n\n    int[] vertexParents = VertexParents();\n    SearchDepths(0,0);\n    int[,] treeParents = TreeParents(0,vertexParents);\n    \n    int q = int.Parse(Console.ReadLine());\n\n    for(int i = 0; i < q; i++)\n    {\n      int[] numsa = Array.ConvertAll(Console.ReadLine().Split(' '),int.Parse);\n      Console.WriteLine(LowestCommonAncester(treeParents,numsa[0],numsa[1]));\n    }\n\t}\n\n  static void MakeChildrenList(int rootNum)\n  {//nextListからchildrenListを、引数を0-indexの根の番号としてO(頂点数)で作る\n    for(int i = 0; i < nextList[rootNum].Count(); i++)\n    {\n      childrenList[rootNum].Add(nextList[rootNum][i]);\n      nextList[nextList[rootNum][i]].Remove(rootNum);//木の逆走を防ぐ\n      MakeChildrenList(nextList[rootNum][i]);\n    }\n  }\n\n  static int[] VertexParents()\n  {//頂点数nとchildrenListから、各頂点の親（根は-1）をO(n)で返す\n    int[] answers = new int[n];\n    for(int i = 0; i < n; i++) answers[i] = -1;\n\n    for(int i = 0; i < n; i++)\n    {\n      for(int j = 0; j < childrenList[i].Count; j++)\n      {\n        answers[childrenList[i][j]] = i;\n      }\n    }\n\n    return answers;\n  }\n\n  static void SearchDepths(int vertexNum, int depth)\n  {//頂点数nとchildrenListから、引数の頂点の深さ及び、その子の深さをO(頂点数)で設定\n    depths[vertexNum] = depth;//深さを設定\n\n    for(int i = 0; i < childrenList[vertexNum].Count; i++)\n    {\n      SearchDepths(childrenList[vertexNum][i],depth+1);//子の深さを設定\n    }\n  }\n\n  static int[,] TreeParents(int rootVertex, int[] parents)\n  {//頂点数n、0-indexで根の番号、各頂点の親（根は-1）として、\n  //O(nlogn)で2^i個上の親を返す。いない場合は-1。\n    int[,] answers = new int[n,24];\n    for(int i = 0; i < n; i++)\n    {\n      for(int j = 0; j < 24; j++)\n      {\n        answers[i,j] = -1;\n      }\n    }\n    for(int i = 0; i < n; i++) answers[i,0] = parents[i];\n\n    for(int i = 1; i < 24; i++)\n    {\n      for(int j = 0; j < n; j++)\n      {\n        if(answers[j,i-1] != -1) answers[j,i] = answers[answers[j,i-1],i-1];\n        else answers[j,i] = -1;\n      }\n    }\n    \n    return answers;\n  }\n\n  static int SearchParent(int[,] treeParents, int vertexNum, int parentCount)\n  {//TreeParents()で求めた親から、引数の頂点からparentCountだけ上の親番号をO(log頂点数)で返す。\n    if(vertexNum == -1) return -1;\n  \n    for(int i = 0; i < 24; i++)\n    {\n      if((parentCount & (1<<i)) != 0) vertexNum = treeParents[vertexNum,i];\n      if(vertexNum == -1) return -1;\n    }\n    return vertexNum;\n  }\n\n  static int LowestCommonAncester(int[,] treeParents, int vertexA, int vertexB)\n  {//TreeParents()で求めた親とdepthsから、2頂点の最小共通祖先をO((log頂点数)^2)で返す。\n    if(depths[vertexA] > depths[vertexB])\n      vertexA = SearchParent(treeParents, vertexA, depths[vertexA]-depths[vertexB]);\n    else if(depths[vertexA] < depths[vertexB])\n      vertexB = SearchParent(treeParents, vertexB, depths[vertexB]-depths[vertexA]);\n\n    return (SearchParent(treeParents, vertexA, SearchAncester(0,1<<23,-1,treeParents,vertexA,vertexB)));\n  }\n\n  static int SearchAncester(int min, int max, int MinorMax,\n    int[,] treeParents, int vertexA, int vertexB)//二分探索法で最小値-1最大値1を求める\n  {\n    while (true)\n    {\n      int mid = min + (max - min) / 2;\n      if(MinorMax == 1)\n      {\n        if(CheckAncester(mid,treeParents,vertexA,vertexB)) min = mid;//さらに大きくても成り立つかも\n        else max = mid;\n      }else\n      {\n        if(CheckAncester(mid,treeParents,vertexA,vertexB)) max = mid;//さらに小さくても成り立つかも\n        else min = mid;\n      }\n\n      if(max - min <= 1)\n      {\n        if(MinorMax == 1)\n        {\n          if(CheckAncester(max,treeParents,vertexA,vertexB)) return max;//最大値で成り立つかの確認を優先\n          else return min;\n        }else\n        {\n          if(CheckAncester(min,treeParents,vertexA,vertexB)) return min;//最小値で成り立つかの確認を優先\n          else return max;\n        }\n\n      break;\n      }  \n    }\n  }\n\n  static bool CheckAncester(int testNum, int[,] treeParents, int vertexA, int vertexB)\n  {\n    if(SearchParent(treeParents,vertexA,testNum) != SearchParent(treeParents,vertexB,testNum)\n      && SearchParent(treeParents,vertexA,testNum) != -1) return false;\n\n    return true;\n  }  \n\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int();\n        var HL = new HeavyLightDecomposition(N);\n        for (int i = 0; i < N; i++)\n        {\n            int num = Reader.Int();\n            for (int t = 0; t < num; t++)\n                HL.AddEdge(i, Reader.Int());\n        }\n        int Q = Reader.Int();\n        var table = Reader.IntTable(Q);\n        HL.Build();\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        foreach (var q in table)\n            Console.WriteLine(HL.LCA(q[0], q[1]));\n        Console.Out.Flush();\n    }\n\n    class HeavyLightDecomposition\n    {\n        public readonly int N;\n        List<int>[] E;\n        int[] Y, X, Size, Parent;\n        List<List<int>> Path; // debug\n        List<int> PathDepth;\n\n        public HeavyLightDecomposition(int n)\n        {\n            N = n;\n            Y = new int[N]; X = new int[N];\n            Size = new int[N]; Parent = new int[N];\n            Path = new List<List<int>>();\n            Path.Add(new List<int>());\n            PathDepth = new List<int>();\n            PathDepth.Add(0);\n            E = new List<int>[N];\n            for (int i = 0; i < N; i++) E[i] = new List<int>();\n        }\n        public void AddEdge(int a, int b)\n        {\n            E[a].Add(b);\n            E[b].Add(a);\n        }\n        public void Build(int root = 0)\n        {\n            CountSize(root, -1);\n            CompressPath(0, 0, 0);\n        }\n        int CountSize(int a, int parent)\n        {\n            Parent[a] = parent;\n            Size[a] = 1;\n            var e = E[a];\n            for (int i = 0; i < e.Count; i++)\n                if (e[i] == parent) { e.RemoveAt(i); i--; }\n                else\n                {\n                    int size = CountSize(e[i], a);\n                    Size[a] += size;\n                    if (size > Size[e[0]]) { int t = e[0]; e[0] = e[i]; e[i] = t; }\n                }\n            return Size[a];\n        }\n        void CompressPath(int a, int pathId, int depth)\n        {\n            Y[a] = pathId;\n            X[a] = Path[pathId].Count;\n            Path[pathId].Add(a);\n            if (E[a].Count == 0) return;\n            CompressPath(E[a][0], pathId, depth);\n            for (int i = 1; i < E[a].Count; i++)\n            {\n                Path.Add(new List<int>());\n                PathDepth.Add(depth + 1);\n                CompressPath(E[a][i], Path.Count - 1, depth + 1);\n            }\n        }\n\n        public int LCA(int a, int b)\n        {\n            int pa = Y[a], pb = Y[b];\n            if (pa == pb) return (X[a] < X[b]) ? a : b;\n            if (PathDepth[pa] >= PathDepth[pb]) return LCA(Parent[Path[pa][0]], b);\n            return LCA(a, Parent[Path[pb][0]]);\n        }\n\n    }\n\n}\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()); return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int();\n        var E = new List<int>[N];\n\n        for (int i = 0; i < N; i++)\n        {\n            E[i] = new List<int>();\n            int num = Reader.Int();\n            for (int t = 0; t < num; t++)\n                E[i].Add(Reader.Int());\n        }\n        int Q = Reader.Int();\n        var table = Reader.IntTable(Q);\n        var lca = new LowestCommonAncestor(0, E);\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        foreach (var q in table)\n            Console.WriteLine(lca.Get(q[0], q[1]));\n        Console.Out.Flush();\n    }\n\n    class LowestCommonAncestor\n    {\n        List<int>[] G;\n        RangeMinQueryIndex Rmq;\n        List<int> Vs = new List<int>();\n        List<int> Depth = new List<int>();\n        int[] Id;\n\n        public LowestCommonAncestor(int root, List<int>[] G)\n        {\n            this.G = G;\n            Init(root);\n        }\n        public int Get(int a, int b)\n        {\n            int L = Math.Min(Id[a], Id[b]);\n            int R = Math.Max(Id[a], Id[b]) + 1;\n            int i = Rmq.Get(L, R);\n            return Vs[i];\n        }\n        private void Init(int root)\n        {\n            Id = new int[G.Length];\n            DFS(root, -1, 0);\n            Rmq = new RangeMinQueryIndex(Depth.Count);\n            for (int i = 0; i < Depth.Count; i++)\n                Rmq.Set(i, Depth[i]);\n        }\n        private void DFS(int v, int prev, int d)\n        {\n            Id[v] = Vs.Count;\n            Vs.Add(v);\n            Depth.Add(d);\n            foreach (int next in G[v])\n                if (next != prev)\n                {\n                    DFS(next, v, d + 1);\n                    Vs.Add(v);\n                    Depth.Add(d);\n                }\n        }\n    }\n\n    class RangeMinQueryIndex\n    {\n        private static readonly int INF = (int)1e9;\n        public readonly int N;\n        private readonly int[] tree;\n        private readonly int[] index;\n\n        public RangeMinQueryIndex(int N)\n        {\n            while (N < 2 || (N & (N - 1)) != 0) { N += N & -N; }\n            this.N = N;\n            tree = new int[N * 2];\n            index = new int[N * 2];\n            for (int i = 0; i < tree.Length; i++) tree[i] = INF;\n        }\n        public void Set(int i, int val)\n        {\n            int id = i;\n            i += N - 1;\n            tree[i] = val;\n            index[i] = id;\n            while (i > 0)\n            {\n                i = (i - 1) / 2;\n                int L = i * 2 + 1, R = i * 2 + 2;\n                if (tree[L] <= tree[R]) { tree[i] = tree[L]; index[i] = index[L]; }\n                else { tree[i] = tree[R]; index[i] = index[R]; }\n            }\n        }\n        // [L, R)\n        public int Get(int L, int R) { int v = -1; return Rec(0, ref v, 0, N, L, R); }\n        private int Rec(int i, ref int val, int currL, int currR, int L, int R)\n        {\n            if (currL >= R || currR <= L) { val = INF; return -1; }\n            if (currL >= L && currR <= R) { val = tree[i]; return index[i]; }\n            int mid = (currL + currR) / 2;\n            int Lv = INF, Rv = INF;\n            int Li = Rec(i * 2 + 1, ref Lv, currL, mid, L, R);\n            int Ri = Rec(i * 2 + 2, ref Rv, mid, currR, L, R);\n            if (Lv <= Rv) { val = Lv; return Li; }\n            val = Rv; return Ri;\n        }\n    }\n}\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()); return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing static Assistant.Input;\nusing static Assistant.Debug;\nusing System.Linq;\nusing Assistant;\nusing System.Text;\n\nnamespace AOJ_GRL_5_C\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = ReadInt;\n            List<int>[] child = new List<int>[n].Select(x => new List<int>()).ToArray();\n            for (int i = 0; i < n; i++)\n            {\n                int k = ReadInt;\n                for (int j = 0; j < k; j++)\n                {\n                    child[i].Add(ReadInt);\n                }\n            }\n\n            List<LCA.Edge>[] edges = new List<LCA.Edge>[n];\n            for (int i = 0; i < n; i++)\n            {\n                edges[i] = new List<LCA.Edge>();\n                foreach (var c in child[i])\n                {\n                    edges[i].Add(new LCA.Edge() { to = c });\n                }\n            }\n\n            LCA lca = new LCA(edges);\n\n            int q = ReadInt;\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < q; i++)\n            {\n                int u = ReadInt;\n                int v = ReadInt;\n\n                int ans = lca.Query(u, v);\n                sb.AppendLine(ans.ToString());\n            }\n\n            Console.Write(sb);\n        }\n\n    }\n\n    /* LCA(G, root): 木 G に対する根を root として Lowest Common Ancestor を求めるクラス\n    query(u,v): u と v の LCA を求める。計算量 O(logn)\n    前処理: O(nlogn)時間, O(nlogn)空間\n    */\n    class LCA\n    {\n        public struct Edge\n        {\n            public int to;\n        }\n\n        int[,] parent;  // parent[k][u]:= u の 2^k 先の親\n        int[] dist;     // root からの距離\n\n        // 初期化\n        public LCA(List<Edge>[] G, int root = 0)\n        {\n            int V = G.Length;\n            int K = 1;\n            while ((1 << K) < V) K++;\n            parent = new int[K, V];\n            for (int i = 0; i < V; i++)\n            {\n                parent[K - 1, i] = -1;\n            }\n            dist = new int[V].Select(x => -1).ToArray();\n            Dfs(G, root, -1, 0);\n            for (int k = 0; k + 1 < K; k++)\n            {\n                for (int v = 0; v < V; v++)\n                {\n                    if (parent[k, v] < 0)\n                    {\n                        parent[k + 1, v] = -1;\n                    }\n                    else\n                    {\n                        parent[k + 1, v] = parent[k, parent[k, v]];\n                    }\n                }\n            }\n            //DrawMapforDebug(parent);\n        }\n\n        // 根からの距離と1つ先の頂点を求める\n        void Dfs(List<Edge>[] G, int v, int p, int d)\n        {\n            parent[0, v] = p;\n            dist[v] = d;\n            foreach (var e in G[v])\n            {\n                if (e.to != p) Dfs(G, e.to, v, d + 1);\n            }\n        }\n\n        public int Query(int u, int v)\n        {\n            if (dist[u] < dist[v])\n            {\n                int temp = v;\n                v = u; u = temp;// u の方が深いとする\n            }\n            int K = parent.GetLength(0);\n\n            // LCA までの距離を同じにする\n            for (int k = 0; k < K; k++)\n            {\n                if ((((dist[u] - dist[v]) >> k) & 1) > 0)\n                {\n                    u = parent[k, u];\n                }\n            }\n\n            // 二分探索で LCA を求める⇒重要\n            if (u == v) return u;\n            for (int k = K - 1; k >= 0; k--)\n            {\n                if (parent[k, u] != parent[k, v])\n                {\n                    u = parent[k, u];\n                    v = parent[k, v];\n                }\n            }\n            return parent[0, u];\n        }\n\n        public int Distance(int u, int v)\n        {\n            return dist[u] + dist[v] - 2 * dist[Query(u, v)];\n        }\n\n        public bool IsOnPath(int u, int v, int a)\n        {\n            return Distance(u, a) + Distance(a, v) == Distance(u, v);\n        }\n\n    }\n}\n\nnamespace Assistant\n{\n    static class Input\n    {\n        static List<string> line = new List<string>();\n        static int index = 0;\n        static String ReadNext()\n        {\n            if (line.Count <= index) line.AddRange(Console.ReadLine().Split());\n            return line[index++];\n        }\n        public static int ReadInt => int.Parse(ReadNext());\n        public static long ReadLong => long.Parse(ReadNext());\n        public static int[] ReadInts => Console.ReadLine().Split().Select(int.Parse).ToArray();\n        public static long[] NextLongs => Console.ReadLine().Split().Select(long.Parse).ToArray();\n    }\n\n    static class Debug\n    {\n        //drawmap\n        //drawarray\n        /// <summary>\n        /// 二次元配列の可視化メソッド\n        /// </summary>\n        /// <param name=\"map\"></param>\n        static public void DrawMapforDebug(int[,] map, int mode = 1)\n        {\n            int W = map.GetLength(0);\n            int H = map.GetLength(1);\n\n            int[,] map2 = new int[W + 1, H + 1];\n            for (int i = 0; i < W + 1; i++)\n            {\n                for (int j = 0; j < H + 1; j++)\n                {\n                    if (i == 0 && j == 0) map2[i, j] = 0;\n                    else if (i == 0) map2[i, j] = j - 1;\n                    else if (j == 0) map2[i, j] = i - 1;\n                    else map2[i, j] = map[i - 1, j - 1];\n                }\n            }\n\n            for (int i = 0; i < W + 1; i++)\n            {\n                for (int j = 0; j < H + 1; j++)\n                {\n                    if (mode == 0) Console.Write(map2[i, j] % 10);\n                    if (mode == 1) Console.Write(map2[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace LowestCommonAncestor\n{\n    class LowestCommonAncestor\n    {\n        Dictionary<int, List<int>> G;\n        int N, logN;\n        int[,] parent;\n        int[] depth;\n\n        public LowestCommonAncestor(Dictionary<int, List<int>> G, int V)\n        {\n            this.G = G;\n            N = V;\n            logN = (int)Math.Log(N, 2) + 1;\n            parent = new int[N, logN];\n            depth = new int[N];\n\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < logN; j++)\n                    parent[i, j] = -1;\n        }\n\n        public void Init(int v, int par, int d)\n        {\n            parent[v, 0] = par;\n            depth[v] = d;\n\n            foreach (var u in G[v])\n            {\n                if (u != par) Init(u, v, d + 1);\n            }\n        }\n\n        public void Build()\n        {\n            for (int d = 1; (1 << d) < N; d++)\n            {\n                for (int i = 0; i < N; i++)\n                {\n                    if (parent[i, d - 1] != -1)\n                    {\n                        parent[i, d] = parent[parent[i, d - 1], d - 1];\n                    }\n                }\n            }\n        }\n\n        public int Query(int u, int v)\n        {\n            if (depth[u] < depth[v])\n            {\n                int temp = u;\n                u = v;\n                v = temp;\n            }\n\n            for (int i = logN - 1; i >= 0; i--)\n            {\n                if (depth[u] - (1 << i) >= depth[v])\n                {\n                    u = parent[u, i];\n                }\n            }\n\n            if (u == v) return u;\n\n            for (int i = logN - 1; i >= 0; i--)\n            {\n                if (parent[u, i] != -1 && parent[u, i] != parent[v, i])\n                {\n                    u = parent[u, i];\n                    v = parent[v, i];\n                }\n            }\n            return parent[u, 0];\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int V = int.Parse(Console.ReadLine());\n\n            Dictionary<int, List<int>> G = new Dictionary<int, List<int>>();\n            for (int i = 0; i < V; i++) G.Add(i, new List<int>());\n\n            for (int i = 0; i < V; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int k = int.Parse(input[0]);\n\n                for (int j = 1; j <= k; j++)\n                {\n                    int c = int.Parse(input[j]);\n                    G[i].Add(c);\n                    G[c].Add(i);\n                }\n            }\n\n            LowestCommonAncestor lca = new LowestCommonAncestor(G, V);\n            lca.Init(0, -1, 0);\n            lca.Build();\n\n            StringBuilder sb = new StringBuilder();\n            int q = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < q; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int u = int.Parse(input[0]);\n                int v = int.Parse(input[1]);\n\n                int p = lca.Query(u, v);\n                sb.AppendLine(p.ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic List<int>[] li;\n\tstatic bool[] b;\n\tstatic int[] h;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint n=sc.I;\n\t\tli=new List<int>[n+1];\n\t\tb=new bool[n+1];\n\t\th=new int[n+1];\n\t\tfor(int i=1;i<=n;i++){li[i]=new List<int>();}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint[] e=sc.Ia;\n\t\t\tfor(int j = 1;j<=e[0];j++) {\n\t\t\t\tli[i].Add(e[j]+1);\n\t\t\t\tli[e[j]+1].Add(i);\n\t\t\t}\n\t\t}\n\t\tvar da=new Alca(li,true);\n\t\tint q=sc.I;\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<q;i++) {\n\t\t\tint[] e=sc.Ia;\n\t\t\tsb.Append((da.Lca(e[0]+1,e[1]+1)-1)+\"\\n\");\n\t\t}\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Alca{\n\tprivate List<int>[] li;\n\tprivate readonly int[] at,ix,de,l;\n\tprivate readonly int[][] g;\n\tprivate int f=0;\n\tpublic Alca(List<int>[] li,bool bo){\n\t\tint n=li.Length,z=(n<<1)-1,m=z;\n\t\tthis.li=li;\n\t\tat=new int[z];\n\t\tix=new int[n];\n\t\tde=new int[n];\n\t\tif(bo){Fu1(1,1);}\n\t\telse{\n\t\t\tfor(int i = 1;i<n;i++) {\n\t\t\t\tif(de[i]==0){Fu1(i,1);f++;}\n\t\t\t}\n\t\t}\n\t\tm=(int)Log(m,2)+1;\n\t\tg=new int[m][];\n\t\tg[0]=new int[z];\n\t\tl=new int[z+1];\n\t\tfor(int i=0;i<z;i++){\n\t\t\tg[0][i]=i;\n\t\t\tl[i+1]=l[i>>1]+1;\n\t\t}\n\t\tfor(int i=1,k=1;i<m;i++,k<<=1){\n\t\t\tint p=z+1-(k<<1);\n\t\t\tg[i]=new int[p];\n\t\t\tfor(int j=0;j<p;j++){g[i][j]=de[at[g[i-1][j]]]<de[at[g[i-1][j+k]]]?g[i-1][j]:g[i-1][j+k];}\n\t\t}\n\t}\n\tpublic int Lca(int a,int b){return Get(ix[a],ix[b]);}\n\tpublic int Di(int a,int b){\n\t\tint p=Get(ix[a],ix[b]);\n\t\treturn p!=0?de[a]+de[b]-(de[p]<<1):-1;\n\t}\n\tprivate int Get(int a,int b){\n\t\tif(a>b){a^=b;b^=a;a^=b;}\n\t\tint p=l[b-a];\n\t\treturn at[de[at[g[p][a]]]<de[at[g[p][b+1-(1<<p)]]]?g[p][a]:g[p][b+1-(1<<p)]];\n\t}\n\tprivate void Fu1(int a,int g){\n\t\tat[f]=a;\n\t\tde[a]=g;\n\t\tix[a]=f;\n\t\tf++;\n\t\tfor(int i=0;i<li[a].Count;i++){\n\t\t\tif(de[li[a][i]]==0){\n\t\t\t\tFu1(li[a][i],g+1);\n\t\t\t\tat[f]=a;\n\t\t\t\tf++;\n\t\t\t}\n\t\t}\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\nclass TwoEdgeDecomposition {\n  private int n;\n  private int[] ord;\n  private int[] low;\n  private List< int >[] graph;\n\n  private int ord_ = 0;\n  private int cmp_ = 0;\n\n\n  public SortedSet< Tuple< int, int > > bridges { get; }\n  public int[] cmp { get; }\n  public List< SortedSet< int > > quotient { get; }\n\n  void dfs(int crr, int prv) {\n    low[crr] = ord[crr] = ord_++;\n    foreach (int nxt in graph[crr]) {\n      if (nxt == prv) continue;\n      if (ord[nxt] != -1) {\n        low[crr] = Min(low[crr], ord[nxt]);\n        continue;\n      }\n      dfs(nxt, crr);\n      low[crr] = Min(low[crr], low[nxt]);\n      if (ord[crr] < low[nxt]) {\n        cmp_++;\n        bridges.Add(new Tuple< int, int >(crr, nxt));\n        bridges.Add(new Tuple< int, int >(nxt, crr));\n      }\n    }\n    cmp[crr] = cmp_;\n    return;\n  }\n\n  public TwoEdgeDecomposition(int n) {\n    this.n = n;\n    ord = Enumerable.Repeat(-1, n).ToArray();\n    low = new int[n];\n    graph = Enumerable.Repeat(0, n).Select(_ => new List< int >()).ToArray();\n    bridges = new SortedSet< Tuple< int, int > >();\n    cmp = new int[n];\n    quotient = new List< SortedSet< int > >();\n  }\n  public void insert(int i, int j) {\n    graph[i].Add(j);\n    graph[j].Add(i);\n  }\n  public void build() {\n\n    foreach (int i in Enumerable.Range(0, n)) {\n      if (ord[i] == -1) dfs(i, i);\n    }\n\n    cmp_++;\n    foreach (int _ in Enumerable.Range(0, cmp_)) {\n      quotient.Add(new SortedSet< int >());\n    }\n    foreach (int i in Enumerable.Range(0, n)) {\n      foreach (int j in graph[i]) {\n        if (cmp[i] == cmp[j]) continue;\n        quotient[cmp[i]].Add(cmp[j]);\n      }\n    }\n  }\n};\n\nclass LowestCommonAncestor {\n  private int n;\n  private int lg;\n  private List< int >[] graph;\n  private int[] prt;\n  private int[] depth;\n  private int[,] table;\n\n  private void dfs(int crr) {\n    foreach (int nxt in graph[crr]) {\n      if (nxt == prt[crr]) continue;\n      prt[nxt] = crr;\n      depth[nxt] = depth[crr] + 1;\n      dfs(nxt);\n    }\n  }\n\n  public LowestCommonAncestor(int n) {\n    this.n = n;\n    lg = 30;\n    graph = Enumerable.Repeat(0, n).Select(_ => new List< int >()).ToArray();\n    prt = new int[n];\n    depth = Enumerable.Repeat(0, n).ToArray();\n    table = new int[lg + 1, n];\n  }\n  public void insert(int i, int j) {\n    graph[i].Add(j);\n    graph[j].Add(i);\n  }\n  public void build(int root = 0) {\n    dfs(root);\n    prt[root] = prt[root];\n\n    foreach (int i in Enumerable.Range(0, lg)) {\n      foreach (int j in Enumerable.Range(0, n)) {\n        table[i, j] = i == 0\n          ? prt[j]\n          : table[i - 1, table[i - 1, j]];\n      }\n    }\n  }\n  public int lca(int u, int v) {\n    if (depth[u] > depth[v]) {\n      int tmp = u;\n      u = v;\n      v = tmp;\n    }\n    int diff = depth[v] - depth[u];\n    foreach (int i in Enumerable.Range(0, lg + 1).Reverse()) {\n      if (Pow(2, i) < depth[v] - depth[u]) {\n        v = table[i, v];\n        diff -= (int)Pow(2, i);\n        Debug.Assert(diff == depth[v] - depth[u]);\n      }\n    }\n    if (depth[u] < depth[v]) {\n      v = prt[v];\n    }\n    Debug.Assert(depth[u] == depth[v]);\n    if (u == v) return u;\n    foreach (int i in Enumerable.Range(0, lg + 1).Reverse()) {\n      int new_u = table[i, u];\n      int new_v = table[i, v];\n      if (new_u != new_v) {\n        u = new_u;\n        v = new_v;\n      }\n    }\n    Debug.Assert(u != v);\n    u = prt[u];\n    v = prt[v];\n    Debug.Assert(u == v);\n    return u;\n  }\n  public int dist(int u, int v) => depth[u] + depth[v] - 2 * depth[lca(u, v)];\n}\n\npublic static class Program {\n  public static void Main() {\n    int n = int.Parse(Console.ReadLine());\n    var lca = new LowestCommonAncestor(n);\n    foreach (int i in Enumerable.Range(0, n)) {\n      foreach (int j in Console.ReadLine().Split().Skip(1).Select(int.Parse)) {\n        lca.insert(i, j);\n      }\n    }\n    lca.build();\n\n    int q = int.Parse(Console.ReadLine());\n    foreach (int _ in Enumerable.Range(0, q)) {\n      int[] uv = Console.ReadLine().Split().Select(int.Parse).ToArray();\n      int u = uv[0];\n      int v = uv[1];\n      int ans = lca.lca(u, v);\n      Console.WriteLine(ans);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace LowestCommonAncestor\n{\n    class LowestCommonAncestor\n    {\n        Dictionary<int, List<int>> G;\n        int N, logN;\n        int[,] parent;\n        int[] depth;\n\n        public LowestCommonAncestor(Dictionary<int, List<int>> G, int V)\n        {\n            this.G = G;\n            N = V;\n            logN = (int)Math.Log(N, 2) + 1;\n            parent = new int[N, logN];\n            depth = new int[N];\n\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < logN; j++)\n                    parent[i, j] = -1;\n        }\n\n        public void Init(int v, int p, int d)\n        {\n            parent[v, 0] = p;\n            depth[v] = d;\n\n            foreach (var u in G[v])\n            {\n                if (u != p) Init(u, v, d + 1);\n            }\n        }\n\n        public void Build()\n        {\n            for (int d = 1; (1 << d) < N; d++)\n            {\n                for (int i = 0; i < N; i++)\n                {\n                    if (parent[i, d - 1] != -1)\n                    {\n                        parent[i, d] = parent[parent[i, d - 1], d - 1];\n                    }\n                }\n            }\n        }\n\n        public int Query(int u, int v)\n        {\n            if (depth[u] < depth[v])\n            {\n                int temp = u;\n                u = v;\n                v = temp;\n            }\n\n            for (int i = logN - 1; i >= 0; i--)\n            {\n                if (depth[u] - (1 << i) >= depth[v])\n                {\n                    u = parent[u, i];\n                }\n            }\n\n            if (u == v) return u;\n\n            for (int i = logN - 1; i >= 0; i--)\n            {\n                if (parent[u, i] != -1 && parent[u, i] != parent[v, i])\n                {\n                    u = parent[u, i];\n                    v = parent[v, i];\n                }\n            }\n            return parent[u, 0];\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int V = int.Parse(Console.ReadLine());\n\n            Dictionary<int, List<int>> G = new Dictionary<int, List<int>>();\n            for (int i = 0; i < V; i++) G.Add(i, new List<int>());\n\n            for (int i = 0; i < V; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int k = int.Parse(input[0]);\n\n                for (int j = 1; j <= k; j++)\n                {\n                    int c = int.Parse(input[j]);\n                    G[i].Add(c);\n                    G[c].Add(i);\n                }\n            }\n\n            LowestCommonAncestor lca = new LowestCommonAncestor(G, V);\n            lca.Init(0, -1, 0);\n            lca.Build();\n\n            StringBuilder sb = new StringBuilder();\n            int q = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < q; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int u = int.Parse(input[0]);\n                int v = int.Parse(input[1]);\n\n                int p = lca.Query(u, v);\n                sb.AppendLine(p.ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass C\n{\n\tstatic int[] Read() => Console.ReadLine().Split().Select(int.Parse).ToArray();\n\tstatic void Main()\n\t{\n\t\tvar n = int.Parse(Console.ReadLine());\n\t\tmap = new int[n].Select(_ => Read().Skip(1).ToArray()).ToArray();\n\t\tvar q = int.Parse(Console.ReadLine());\n\t\tvar qs = new int[q].Select(_ => Read()).ToArray();\n\n\t\ttour = new List<int>();\n\t\torder = Array.ConvertAll(new int[n], _ => new List<int>());\n\t\tminDepth = new ST_Min(2 * n);\n\t\tEulerTourDfs(0, 0);\n\n\t\tConsole.WriteLine(string.Join(\"\\n\", qs.Select(x => Lca(x[0], x[1]))));\n\t}\n\n\tstatic int[][] map;\n\tstatic List<int> tour;\n\tstatic List<int>[] order;\n\tstatic ST_Min minDepth;\n\tstatic void EulerTourDfs(int v, int depth)\n\t{\n\t\torder[v].Add(tour.Count);\n\t\tminDepth.SetMin(tour.Count, depth);\n\t\tforeach (var nv in map[v])\n\t\t{\n\t\t\ttour.Add(v);\n\t\t\tEulerTourDfs(nv, depth + 1);\n\t\t\ttour.Add(-nv);\n\t\t\torder[v].Add(tour.Count);\n\t\t\tminDepth.SetMin(tour.Count, depth);\n\t\t}\n\t}\n\n\tstatic int Lca(int u, int v)\n\t{\n\t\tif (u == v) return u;\n\t\tif (order[u][0] > order[v][0]) { var t = u; u = v; v = t; }\n\t\tif (order[u].Last() > order[v][0]) return u;\n\t\treturn tour[minDepth.ArgMin(order[u].Last(), order[v][0])];\n\t}\n}\n\nclass ST_Min\n{\n\tstruct KI\n\t{\n\t\tpublic int k, i;\n\t}\n\n\tint kMax;\n\tList<long[]> vs = new List<long[]> { new long[1] };\n\tpublic ST_Min(int n)\n\t{\n\t\tfor (int c = 1; c < n; vs.Add(new long[c <<= 1])) ;\n\t\tforeach (var a in vs)\n\t\t\tfor (int i = 0; i < a.Length; i++)\n\t\t\t\ta[i] = long.MaxValue;\n\t\tkMax = vs.Count - 1;\n\t}\n\n\tKI[] GetLevels(int i)\n\t{\n\t\tvar r = new List<KI>();\n\t\tfor (int k = kMax; k >= 0; --k, i >>= 1) r.Add(new KI { k = k, i = i });\n\t\treturn r.ToArray();\n\t}\n\n\tKI[] GetRange(int minIn, int maxEx)\n\t{\n\t\tvar r = new List<KI>();\n\t\tfor (int k = kMax, f = 1; k >= 0 && minIn < maxEx; --k, f <<= 1)\n\t\t{\n\t\t\tif ((minIn & f) != 0) r.Add(new KI { k = k, i = (minIn += f) / f - 1 });\n\t\t\tif ((maxEx & f) != 0) r.Add(new KI { k = k, i = (maxEx -= f) / f });\n\t\t}\n\t\treturn r.ToArray();\n\t}\n\n\tpublic long Get(int i) => vs[kMax][i];\n\n\tpublic void SetMin(int i, long v)\n\t{\n\t\tforeach (var x in GetLevels(i)) vs[x.k][x.i] = Math.Min(vs[x.k][x.i], v);\n\t}\n\n\tpublic long Submin(int minIn, int maxEx) => GetRange(minIn, maxEx).Select(x => vs[x.k][x.i]).Aggregate(Math.Min);\n\n\tpublic int ArgMin(int minIn, int maxEx)\n\t{\n\t\tvar m = Submin(minIn, maxEx);\n\t\tvar ki = GetRange(minIn, maxEx).First(x => vs[x.k][x.i] == m);\n\n\t\tfor (int j; ki.k < kMax; ki = new KI { k = ki.k + 1, i = j })\n\t\t{\n\t\t\tj = 2 * ki.i;\n\t\t\tif (vs[ki.k + 1][j] > m) j++;\n\t\t}\n\t\treturn ki.i;\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing static System.Numerics.BigInteger;\nusing static Program.IO.Scanner;\n\nusing Number = System.Int64;\n#region IO\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\tstatic public class Scanner {\n\t\tpublic static StreamScanner sc = new StreamScanner(Console.OpenStandardInput());\n\t\tpublic static int ri => sc.Integer();\n\t\tpublic static long rl => sc.Long();\n\t\tpublic static string rs => sc.Scan();\n\t\tpublic static double rd => sc.Double();\n\t}\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n\n}\n\n#endregion\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t//solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar HL = new HLTree(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tvar k = ri;\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tvar v = ri;\n\t\t\t\t\tHL.AddEdge(i, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tHL.Build(0);\n\t\t\tvar Q = ri;\n\t\t\tfor (int i = 0; i < Q; i++) {\n\t\t\t\tvar u = ri;\n\t\t\t\tvar v = ri;\n\t\t\t\tvar lca = HL.LCA(u, v);\n\t\t\t\tConsole.WriteLine(lca);\n\t\t\t}\n\n\t\t}\n\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic T[][] Enumerate<T>(int n, int m, Func<int, int, T> f) {\n\t\t\treturn Enumerate(n, x => Enumerate(m, y => f(x, y)));\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n#region HLTree\npublic class HLTree {\n\tint n;\n\tpublic List<int>[] G;\n\tint[] sz, par, d;\n\t//[L,R)\n\tint[] L, R, head;\n\tpublic HLTree(int N) {\n\t\tn = N;\n\t\tG = new List<int>[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tG[i] = new List<int>();\n\t\tsz = new int[n];\n\t\tpar = new int[n];\n\t\td = new int[n];\n\t\thead = new int[n];\n\t\tL = new int[n];\n\t\tR = new int[n];\n\t}\n\tpublic void AddEdge(int u, int v) { G[u].Add(v); G[v].Add(u); }\n\tpublic void Build(int root = 0) {\n\t\tdfs(root);\n\t\tint ptr = 0;\n\t\tdecomposite(root, ref ptr);\n\n\t}\n\tvoid dfs(int r) {\n\t\tvar iter = new int[n];\n\t\tvar stack = new Stack<int>();\n\t\tstack.Push(r); d[r] = 0; par[r] = -1;\n\t\twhile (stack.Count > 0) {\n\t\t\tvar u = stack.Peek();\n\t\t\tvar g = G[u];\n\t\t\tif (iter[u] < g.Count) {\n\t\t\t\tvar v = g[iter[u]++];\n\t\t\t\tif (v == par[u]) continue;\n\t\t\t\telse {\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tstack.Push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsz[u]++;\n\t\t\t\tfor (int i = 0; i < g.Count; i++) {\n\t\t\t\t\tif (g[i] == par[u]) continue;\n\t\t\t\t\tsz[u] += sz[g[i]];\n\t\t\t\t\tif (sz[g[i]] > sz[g[0]]) { var tmp = g[0]; g[0] = g[i]; g[i] = tmp; }\n\t\t\t\t}\n\t\t\t\tstack.Pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid decomposite(int cur, ref int ptr) {\n\t\tvar u = cur;\n\t\tfor (; ; ) {\n\t\t\tL[u] = ptr++;\n\t\t\thead[u] = cur;\n\t\t\tif (G[u].Count > 0 && d[G[u][0]] > d[u]) u = G[u][0];\n\t\t\telse break;\n\t\t}\n\t\tfor (; ; ) {\n\t\t\tvar g = G[u];\n\t\t\tfor (int p = 1; p < g.Count; p++)\n\t\t\t\tif (d[g[p]] > d[u]) decomposite(g[p], ref ptr);\n\t\t\tR[u] = ptr;\n\t\t\tif (u == cur) break;\n\t\t\tu = par[u];\n\t\t}\n\t}\n\n\n\tstatic void Swap<T>(ref T u, ref T v) { var tmp = u; u = v; v = tmp; }\n\tpublic int LCA(int u, int v) {\n\t\twhile (head[u] != head[v]) {\n\t\t\tif (d[head[u]] > d[head[v]]) Swap(ref u, ref v);\n\t\t\tv = par[head[v]];\n\t\t}\n\t\tif (d[u] > d[v]) Swap(ref u, ref v);\n\t\treturn u;\n\t}\n}\n\n#endregion\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        var n = FastIO.Int();\n        var g = new List<int>[n];\n        for (int i = 0; i < n; i++) g[i] = new List<int>();\n        for (int i = 0; i < n; i++)\n        {\n            var k = FastIO.Int();\n            for (int j = 0; j < k; j++)\n            {\n                var c = FastIO.Int();\n                g[i].Add(c);\n                g[c].Add(i);\n            }\n        }\n        var hld = new HLD(g);\n        hld.Build(0);\n        var q = FastIO.Int();\n        for (int i = 0; i < q; i++)\n        {\n            var u = FastIO.Int();\n            var v = FastIO.Int();\n            WriteLine(hld.LCA(u, v));\n        }\n        Out.Flush();\n    }\n}\n\npublic class HLD\n{\n    List<int>[] tree;\n    int[] size, l, par, head;\n\n    public HLD(List<int>[] g)\n    {\n        var len = g.Length;\n        size = new int[len];\n        l = new int[len];\n        par = new int[len];\n        head = new int[len];\n        tree = g;\n    }\n\n    public void Build(int root)\n    {\n        DFSS(root, -1);\n        var k = 0;\n        DFSD(root, -1, ref k);\n    }\n\n    void DFSS(int v, int p)\n    {\n        par[v] = p;\n        for (int i = 0; i < tree[v].Count; i++)\n        {\n            var u = tree[v][i];\n            if (u == p) continue;\n            DFSS(u, v);\n            size[v] += size[u];\n            var h = tree[v][0];\n            if (size[h] < size[u])\n            {\n                tree[v][0] = u;\n                tree[v][i] = h;\n            }\n        }\n        size[v]++;\n    }\n\n    void DFSD(int v, int p, ref int k)\n    {\n        l[v] = k++;\n        foreach (var u in tree[v])\n        {\n            if (u == p) continue;\n            head[u] = u == tree[v][0] ? head[v] : u;\n            DFSD(u, v, ref k);\n        }\n    }\n\n    void Swap<T>(ref T l, ref T r)\n    {\n        var t = l;\n        l = r;\n        r = t;\n    }\n\n    public int LCA(int u, int v)\n    {\n        while (true)\n        {\n            if (l[u] > l[v]) Swap(ref u, ref v);\n            if (head[u] == head[v]) return u;\n            v = par[head[v]];\n        }\n    }\n}\n\npublic static class FastIO\n{\n    static System.IO.Stream str = System.Console.OpenStandardInput();\n    const int size = 1024;\n    static byte[] buffer = new byte[size];\n    static int ptr;\n    static int len;\n\n    static byte Read()\n    {\n        if (ptr == len)\n        {\n            len = str.Read(buffer, 0, size);\n            if (len == 0) return 0;\n            ptr = 0;\n        }\n        return buffer[ptr++];\n    }\n\n    public static int Int()\n    {\n        var c = Read();\n        while (c < 0x21)\n        {\n            c = Read();\n        }\n        var n = false;\n        if (c == '-')\n        {\n            n = true;\n            c = Read();\n        }\n        var ret = 0;\n        while (c > 0x20)\n        {\n            ret = ret * 10 + c - '0';\n            c = Read();\n        }\n        return n ? -ret : ret;\n    }\n\n    public static long Long()\n    {\n        var c = Read();\n        while (c < 0x21)\n        {\n            c = Read();\n        }\n        var n = false;\n        if (c == '-')\n        {\n            n = true;\n            c = Read();\n        }\n        var ret = 0L;\n        while (c > 0x20)\n        {\n            ret = ret * 10 + c - '0';\n            c = Read();\n        }\n        return n ? -ret : ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using System.Text;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\n//using System.Numerics;\n//using static System.Math;\n//using pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    void chmax<T>(ref T a, T b) where T : IComparable<T> { a = a.CompareTo(b) < 0 ? b : a; }\n    void chmin<T>(ref T a, T b) where T : IComparable<T> { a = a.CompareTo(b) < 0 ? a : b; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        var H = new HLTree(N);\n        for (int i = 0; i < N; i++)\n        {\n            int k = cin.nextint;\n            for (int j = 0; j < k; j++)\n            {\n                H.AddEdge(i, cin.nextint);\n            }\n        }\n        H.Build();\n        int Q = cin.nextint;\n        for (int i = 0; i < Q; i++)\n        {\n            WriteLine(H.GetLCA(cin.nextint, cin.nextint));\n        }\n    }\n\n}\n\nclass HLTree\n{\n    int n;\n    List<int>[] G;\n    int[] subtreeSize;\n    int[] maxsize;\n    int[] par;\n    int[] d;\n\n    Chain[] go;\n    int[] pos;\n    List<Chain> chains;\n    public HLTree(int N)\n    {\n        n = N;\n        G = new List<int>[n];\n        chains = new List<Chain>();\n        for (int i = 0; i < n; i++)\n            G[i] = new List<int>();\n        subtreeSize = new int[n];\n        maxsize = new int[n];\n        par = new int[n];\n        d = new int[n];\n        go = new Chain[n];\n        pos = new int[n];\n    }\n    public void AddEdge(int u, int v)\n    {\n        G[u].Add(v); G[v].Add(u);\n    }\n    public void Build(int root = 0)\n    {\n        computeSubtreeSize(root);\n        Decomposite(-1, root, 0);\n\n    }\n    void computeSubtreeSize(int r)\n    {\n        var stack = new Stack<int>();\n        stack.Push(r);\n        var iter = new int[n];\n        par[r] = -1;\n        //dfs\n        while (stack.Count > 0)\n        {\n            var cur = stack.Peek();\n            if (iter[cur] == G[cur].Count)\n            {\n                stack.Pop();\n                subtreeSize[cur]++;\n                if (par[cur] != -1)\n                {\n                    subtreeSize[par[cur]] += subtreeSize[cur];\n                    maxsize[par[cur]] = Math.Max(maxsize[par[cur]], subtreeSize[cur]);\n                }\n                continue;\n            }\n            var next = G[cur][iter[cur]++];\n            if (next == par[cur]) continue;\n            par[next] = cur;\n            d[next] = d[cur] + 1;\n            stack.Push(next);\n        }\n\n    }\n    void Decomposite(int from, int cur, int lv)\n    {\n        var chain = new Chain(from, lv);\n        chains.Add(chain);\n        chain.Add(cur);\n        while (cur != from)\n        {\n            var next = cur;\n            go[cur] = chain;\n            pos[cur] = chain.Count;\n            foreach (var to in G[cur])\n            {\n                if (to == from) continue;\n                if (maxsize[cur] == subtreeSize[to])\n                {\n                    maxsize[cur] = -1;\n                    next = to;\n                    chain.Add(to);\n                }\n                else Decomposite(cur, to, lv + 1);\n            }\n\n            from = cur;\n            cur = next;\n\n        }\n        chain.Init();\n\n    }\n    public int GetLCA(int u, int v)\n    {\n        while (go[u] != go[v])\n        {\n            if (go[u].Level < go[v].Level) v = go[v].From;\n            else u = go[u].From;\n        }\n        if (d[u] <= d[v]) return u;\n        else return v;\n    }\n}\nclass Chain\n{\n    const bool DEBUG = true;\n    public int From { get; set; }\n    public int Level { get; set; }\n    public int Count { get; private set; }\n    List<int> heavy;\n    public Chain(int from, int lv)\n    {\n        From = from;\n        Level = lv;\n        heavy = new List<int>();\n    }\n    public void Add(int v)\n    {\n        if (DEBUG)\n            heavy.Add(v);\n        Count++;\n    }\n    public void Init()\n    {\n\n    }\n}\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Threading.Tasks;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        var T = new HLTree(N);\n        for (int i = 0; i < N; i++)\n        {\n            var A = cin.scanint;\n            for (int j = 1; j < A.Length; j++)\n            {\n                T.AddEdge(i, A[j]);\n            }\n        }\n        T.Build();\n        int Q = cin.nextint;\n        for (int i = 0; i < Q; i++)\n        {\n            WriteLine(T.GetLCA(cin.nextint, cin.nextint));\n        }\n\n    }\n}\n\n/// <OriginalAuthor>camypaper</OriginalAuthor>\nclass HLTree\n{\n    readonly int n;\n    readonly List<int>[] G;\n    readonly int[] subtreeSize;\n    readonly int[] maxsize;\n    readonly int[] par;\n    readonly int[] depth;\n    readonly Chain[] go;\n    readonly int[] pos;\n    List<Chain> chains;\n    public HLTree(int N)\n    {\n        n = N;\n        G = new List<int>[n];\n        chains = new List<Chain>();\n        for (int i = 0; i < n; i++)\n            G[i] = new List<int>();\n        subtreeSize = new int[n];\n        maxsize = new int[n];\n        par = new int[n];\n        depth = new int[n];\n        go = new Chain[n];\n        pos = new int[n];\n    }\n    public void AddEdge(int u, int v)\n    {\n        G[u].Add(v); G[v].Add(u);\n    }\n    public void Build(int root = 0)\n    {\n        computeSubtreeSize(root);\n        Decomposite(-1, root, 0);\n    }\n    void computeSubtreeSize(int r)\n    {\n        var stack = new Stack<int>();\n        stack.Push(r);\n        var iter = new int[n];\n        par[r] = -1;\n        //dfs\n        while (stack.Count > 0)\n        {\n            var cur = stack.Peek();\n            if (iter[cur] == G[cur].Count)\n            {\n                stack.Pop();\n                subtreeSize[cur]++;\n                if (par[cur] != -1)\n                {\n                    subtreeSize[par[cur]] += subtreeSize[cur];\n                    maxsize[par[cur]] = Math.Max(maxsize[par[cur]], subtreeSize[cur]);\n                }\n                continue;\n            }\n            var next = G[cur][iter[cur]++];\n            if (next == par[cur]) continue;\n            par[next] = cur;\n            depth[next] = depth[cur] + 1;\n            stack.Push(next);\n        }\n    }\n    void Decomposite(int from, int cur, int lv)\n    {\n        var chain = new Chain(from, lv);\n        chains.Add(chain);\n        chain.Add(cur);\n        while (cur != from)\n        {\n            var next = cur;\n            go[cur] = chain;\n            pos[cur] = chain.Count;\n            foreach (var to in G[cur])\n            {\n                if (to == from) continue;\n                if (maxsize[cur] == subtreeSize[to])\n                {\n                    maxsize[cur] = -1;\n                    next = to;\n                    chain.Add(to);\n                }\n                else Decomposite(cur, to, lv + 1);\n            }\n\n            from = cur;\n            cur = next;\n\n        }\n        chain.Init();\n    }\n    // 頂点aから頂点bへの距離は depth(a) + depth(b) - 2 * depth(lca(a, b))\n    public int GetLCA(int u, int v)\n    {\n        while (go[u] != go[v])\n        {\n            if (go[u].Level < go[v].Level) v = go[v].From;\n            else u = go[u].From;\n        }\n        if (depth[u] <= depth[v]) return u;\n        else return v;\n    }\n    public int this[int u]\n    {\n        get { return depth[u]; }\n    }\n}\n\nclass Chain\n{\n    public int From { get; set; }\n    public int Level { get; set; }\n    public int Count { get; private set; }\n    List<int> heavy;\n    public Chain(int from, int lv)\n    {\n        From = from;\n        Level = lv;\n        heavy = new List<int>();\n    }\n    public void Add(int v)\n    {\n        //heavy.Add(v);\n        Count++;\n    }\n    public void Init()\n    {\n\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function Main(input) {\n    var arr = input.split(\"\\n\");\n    var n = parseInt(arr[0], 10);\n    var nodes = new Array();\n    for (i = 0; i < n; i++) {\n        nodes.push(new Node(i));\n    }\n    for (i = 0; i < n; i++) {\n        var arr2 = arr[i + 1].split(\" \");\n        for (j = 0; j < arr2[0]; j++) {\n            var c = parseInt(arr2[j + 1], 10);\n            nodes[c].setParent(nodes[i]);\n        }\n    }\n    var q = parseInt(arr[n + 1], 10);\n    var node = new Node();\n    for (i = 0; i < q; i++) {\n        var arr2 = arr[n + i + 2].split(\" \");\n        var u = arr2[0];\n        var v = arr2[1];\n        console.log(node.findLCA(nodes[u], nodes[v]));\n    }\n}\n\nfunction Node(number) {\n    this.number = number;\n    this.parent = this;\n    this.setParent = function(node){\n        this.parent = node;\n    };\n    this.getPath = function(){\n        var p = this;\n        var path = new Array();\n        path.push(p);\n        while (p != p.parent) {\n            p = p.parent;\n            path.push(p);\n        }\n        return path;\n    };\n    this.search = function(path) {\n        var p = this;\n        while (path.indexOf(p) == -1) {\n            p = p.parent;\n            if(p == p.parent) {\n                break;\n            }\n        }\n        return p.number;\n    };\n    this.findLCA = function(x, y) {\n        return x.search(y.getPath());\n    };\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "function Main(input) {\n    var arr = input.split(\"\\n\");\n    var n = parseInt(arr[0], 10);\n    var nodes = new Array();\n    for (i = 0; i < n; i++) {\n        nodes.push(new Node(i));\n    }\n    for (i = 0; i < n; i++) {\n        var arr2 = arr[i + 1].split(\" \");\n        for (j = 0; j < arr2[0]; j++) {\n            var c = parseInt(arr2[j + 1], 10);\n            nodes[c].setParent(nodes[i]);\n        }\n    }\n    var q = parseInt(arr[n + 1], 10);\n    var node = new Node();\n    for (i = 0; i < q; i++) {\n        var arr2 = arr[n + i + 2].split(\" \");\n        var u = arr2[0];\n        var v = arr2[1];\n        console.log(node.findLCA(nodes[u], nodes[v]));\n    }\n}\n\nfunction Node(number) {\n    this.number = number;\n    this.parent = this;\n    this.setParent = function(node){\n        this.parent = node;\n    }\n    this.getPath = function(){\n        var p = this.parent;\n        var path = new Array();\n        path.push(p);\n        while (p != p.parent) {\n            p = p.parent;\n            path.push(p);\n        }\n        return path;\n    };\n    this.search = function(path) {\n        var p = this;\n        while(path.indexOf(p) == -1) {\n            p = p.parent;\n            if(p == p.parent) {\n                break;\n            }\n        }\n        return p.number;\n    }\n    this.findLCA = function(x, y) {\n        return x.search(y.getPath());\n    }\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$c = Array.new(n){ Array.new }\nn.times do |i|\n  a = gets.split.map(&:to_i)[1..-1]\n  a.each{ |j| $c[i] << j }\n  a.each{ |j| $c[j] << i }\nend\n$depth = Array.new(n)\n$parent = Array.new(n)\n$max = (Math.log(n) / Math.log(2)).ceil\n$dp = Array.new(n){ Array.new($max) }\n\ndef dfs(a, pre, dep)\n  $depth[a] = dep\n  $parent[a] = pre\n  $dp[a][0] = pre\n  (1...$max).each do |i|\n    if $dp[a][i-1] != -1 then $dp[a][i] = $dp[$dp[a][i-1]][i-1]\n    else $dp[a][i] = -1\n    end\n  end\n  $c[a].each do |i|\n    next if i == pre\n    dfs(i, a, dep+1)\n  end\nend\n\ndef lca(a, b)\n  if $depth[a] > $depth[b] then a, b = b, a \n  end\n  dh = $depth[b] - $depth[a]\n  i = 0\n  while (1 << i) <= dh\n    if (dh>>i) % 2 == 1 then b = $dp[b][i]\n    end\n    i += 1\n  end\n  return a if a == b\n  ret = -1\n  ($max-1).downto(0) do |i|\n    if $dp[a][i] == $dp[b][i] then ret = $dp[a][i]\n    else\n      a = $dp[a][i]\n      b = $dp[b][i]\n    end\n  end\n  return ret\nend\n\ndfs(0,-1,0)\nq = gets.to_i\nq.times do\n  a, b = gets.split.map(&:to_i)\n  p lca(a,b)\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$c = Array.new(n)\nn.times{ |i| $c[i] = gets.split.map(&:to_i)[1..-1] }\n$depth = Array.new(n)\n$max = (Math.log(n) / Math.log(2)).ceil\n$dp = Array.new(n){ Array.new($max) }\n \ndef bfs\n  arr = []\n  arr << [0,-1,0]\n  until arr.empty?\n    a,pre,dep = arr.shift\n    $depth[a] = dep\n    $dp[a][0] = pre\n    (1...$max).each do |i|\n      if $dp[a][i-1] != -1 then $dp[a][i] = $dp[$dp[a][i-1]][i-1]\n      else $dp[a][i] = -1\n      end\n    end\n    $c[a].each do |i|\n      next if i == pre\n      arr << [i, a, dep+1]\n    end\n  end\nend\n \ndef lca(a, b)\n  a, b = b, a if $depth[a] > $depth[b]\n  dh = $depth[b] - $depth[a]\n  i = 0\n  while (1<<i) <= dh\n    b = $dp[b][i] if dh&(1<<i) == 1\n    i += 1\n  end\n  return a if a == b\n  ($max-1).downto(0) do |i|\n    if $dp[a][i] != $dp[b][i]\n      a = $dp[a][i]; b = $dp[b][i] \n    end\n  end\n  $dp[a][0]\nend\n \nbfs\ngets.to_i.times do\n  a, b = gets.split.map(&:to_i)\n  p lca a, b\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$c = Array.new(n)\nn.times{ |i| $c[i] = gets.split.map(&:to_i)[1..-1] }\n$depth = Array.new(n)\n$max = (Math.log(n) / Math.log(2)).ceil\n$dp = Array.new(n){ Array.new($max) }\n\ndef bfs\n  arr = []\n  arr << [0,-1,0]\n  until arr.empty?\n    a,pre,dep = arr.shift\n    $depth[a] = dep\n    $dp[a][0] = pre\n    (1...$max).each do |i|\n      if $dp[a][i-1] != -1 then $dp[a][i] = $dp[$dp[a][i-1]][i-1]\n      else $dp[a][i] = -1\n      end\n    end\n    $c[a].each do |i|\n      next if i == pre\n      arr << [i, a, dep+1]\n    end\n  end\nend\n\ndef lca(a, b)\n  a, b = b, a if $depth[a] > $depth[b]\n  dh = $depth[b] - $depth[a]\n  i = 0\n  while (1 << i) <= dh\n    b = $dp[b][i] if (dh>>i) % 2 == 1\n    i += 1\n  end\n  return a if a == b\n  ret = -1\n  ($max-1).downto(0) do |i|\n    if $dp[a][i] == $dp[b][i] then ret = $dp[a][i]\n    else\n      a = $dp[a][i]; b = $dp[b][i]\n    end\n  end\n  ret\nend\n\nbfs\ngets.to_i.times do\n  a, b = gets.split.map(&:to_i)\n  p lca a, b\nend"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :child, :parent\n  def initialize\n    @child = []\n  end\nend\n\ndef dfs(root, g)\n  stack = [root]\n  path = []\n  done = {}\n  while stack.size > 0\n    s = stack[-1]\n    flag = true\n    g[s].child.each{|t|\n      next if done[t]\n      stack << t\n      done[t] = true\n      flag = false\n      break\n    }\n    if flag\n      path[s] = stack.clone\n      stack.pop\n    end\n  end\n  return path\nend\n\n$checked = {}\nn = gets.to_i\ng = Array.new(n){Node.new}\nn.times{|i|\n  g[i].child = gets.split.map(&:to_i)\n  g[i].child.shift\n}\n\npath = dfs(0, g)\nq = gets.to_i\nq.times{\n  u, v = gets.split.map(&:to_i)\n  common = path[u] & path[v]\n  p common[-1]\n}"
  },
  {
    "language": "Ruby",
    "code": "#Doubling lca\nclass Node\n  attr_accessor :child, :depth, :parent\n  def initialize\n    @child = []\n    @depth = 0\n    @parent = []\n  end\nend\n\ndef dfs(root, g)\n  stack = [root]\n  done = {}\n  g[root].depth = 0\n  g[root].parent[0] = -1\n  while stack.size > 0\n    s = stack[-1]\n    flag = true\n    g[s].child.each{|t|\n      next if done[t]\n      stack << t\n      g[t].depth = g[s].depth + 1\n      g[t].parent[0] = s\n      done[t] = true\n      flag = false\n      break\n    }\n    if flag\n      stack.pop\n    end\n  end\nend\n\nn = gets.to_i\ng = Array.new(n){Node.new}\nn.times{|i|\n  g[i].child = gets.split.map(&:to_i)\n  g[i].child.shift\n}\n\ndfs(0, g)\n\nk = 0\nwhile k < Math.log2(n)\n  v = 0\n  while v < n\n    if g[v].parent[k] < 0\n      g[v].parent[k+1] = -1\n    else\n      g[v].parent[k+1] = g[g[v].parent[k]].parent[k]\n    end\n    v += 1\n  end\n  k += 1\nend\n\nq = gets.to_i\nq.times{\n  u, v = gets.split.map(&:to_i)\n  u, v = v, u if g[u].depth > g[v].depth\n  k = 0\n  while k < Math.log2(n) + 1\n    if (g[v].depth - g[u].depth) >> k & 1 == 1\n      v = g[v].parent[k]\n    end\n    k += 1\n  end\n  if u == v\n    puts u\n    next\n  end\n  k = (Math.log2(n) - 1).to_i\n  while k >= 0\n    if g[u].parent[k] != g[v].parent[k]\n      u = g[u].parent[k]\n      v = g[v].parent[k]\n    end\n    k -= 1\n  end\n  puts g[u].parent[0]\n}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$c = Array.new(n){ Array.new }\nn.times do |i|\n  a = gets.split.map(&:to_i)[1..-1]\n  a.each{ |j| $c[i] << j }\nend\n$depth = Array.new(n)\n$max = (Math.log(n) / Math.log(2)).ceil\n$dp = Array.new(n){ Array.new($max) }\n\ndef bfs\n  arr = Array.new\n  arr << [0,-1,0]\n  while not arr.empty?\n    a,pre,dep = arr.shift\n    $depth[a] = dep\n    $dp[a][0] = pre\n    (1...$max).each do |i|\n      if $dp[a][i-1] != -1 then $dp[a][i] = $dp[$dp[a][i-1]][i-1]\n      else $dp[a][i] = -1\n      end\n    end\n    $c[a].each do |i|\n      next if i == pre\n      arr << [i, a, dep+1]\n    end\n  end\nend\n\ndef lca(a, b)\n  if $depth[a] > $depth[b] then a, b = b, a \n  end\n  dh = $depth[b] - $depth[a]\n  i = 0\n  while (1 << i) <= dh\n    if (dh>>i) % 2 == 1 then b = $dp[b][i]\n    end\n    i += 1\n  end\n  return a if a == b\n  ret = -1\n  ($max-1).downto(0) do |i|\n    if $dp[a][i] == $dp[b][i] then ret = $dp[a][i]\n    else\n      a = $dp[a][i]\n      b = $dp[b][i]\n    end\n  end\n  return ret\nend\n\nbfs\nq = gets.to_i\nq.times do\n  a, b = gets.split.map(&:to_i)\n  p lca(a,b)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :child, :parent\n  def initialize\n    @child = []\n  end\nend\n\ndef dfs(root, g)\n  stack = [root]\n  path = []\n  done = {}\n  while stack.size > 0\n    s = stack[-1]\n    flag = true\n    g[s].child.each{|t|\n      next if done[t]\n      stack << t\n      done[t] = true\n      flag = false\n      break\n    }\n    if flag\n      path[s] = stack.clone\n      stack.pop\n    end\n  end\n  return path\nend\n\n$checked = {}\nn = gets.to_i\ng = Array.new(n){Node.new}\nn.times{|i|\n  g[i].child = gets.split.map(&:to_i)\n  g[i].child.shift\n}\n\nchked = Hash.new{|h,k| h[k] = {}}\npath = dfs(0, g)\nq = gets.to_i\nq.times{\n  u, v = gets.split.map(&:to_i)\n  u, v = v, u if u > v\n  unless chked[u][v]\n    common = path[u] & path[v]\n    chked[u][v] = common[-1]\n  end\n  puts chked[u][v]\n}"
  },
  {
    "language": "Ruby",
    "code": "#Doubling lca\nclass Node\n  attr_accessor :child, :depth, :parent\n  def initialize\n    @child = []\n    @depth = 0\n    @parent = []\n  end\nend\n\ndef dfs(root, g)\n  stack = [root]\n  done = {}\n  g[root].depth = 0\n  g[root].parent[0] = -1\n  while stack.size > 0\n    s = stack[-1]\n    flag = true\n    g[s].child.each{|t|\n      next if done[t]\n      stack << t\n      g[t].depth = g[s].depth + 1\n      g[t].parent[0] = s\n      done[t] = true\n      flag = false\n      break\n    }\n    if flag\n      stack.pop\n    end\n  end\nend\n\nn = gets.to_i\ng = Array.new(n){Node.new}\nn.times{|i|\n  g[i].child = gets.split.map(&:to_i)\n  g[i].child.shift\n}\n\ndfs(0, g)\n\nk = 0\nwhile k < Math.log2(n)\n  v = 0\n  while v < n\n    if g[v].parent[k] < 0\n      g[v].parent[k+1] = -1\n    else\n      g[v].parent[k+1] = g[g[v].parent[k]].parent[k]\n    end\n    v += 1\n  end\n  k += 1\nend\n\nq = gets.to_i\nq.times{\n  u, v = gets.split.map(&:to_i)\n  u, v = v, u if g[u].depth > g[v].depth\n  k = 0\n  while k < Math.log2(n) + 1\n    if (g[v].depth - g[u].depth) >> k & 1 == 1\n      v = g[v].parent[k]\n    end\n    k += 1\n  end\n  if u == v\n    puts u\n    next\n  end\n  k = (Math.log2(n) - 1).to_i\n  while k >= 0\n    if g[u].parent[k] != g[v].parent[k]\n      u = g[u].parent[k]\n      v = g[v].parent[k]\n    end\n    k -= 1\n  end\n  puts g[u].parent[0]\n}"
  },
  {
    "language": "Ruby",
    "code": "#Doubling lca\nclass Node\n  attr_accessor :child, :depth, :parent\n  def initialize\n    @child = []\n    @depth = 0\n    @parent = []\n  end\nend\n\ndef dfs(root, g)\n  stack = [root]\n  g[root].depth = 0\n  g[root].parent[0] = -1\n  while stack.size > 0\n    s = stack[-1]\n    t = g[s].child.shift\n    if t\n      stack << t\n      g[t].depth = g[s].depth + 1\n      g[t].parent[0] = s\n    else\n      stack.pop\n    end\n  end\nend\n\nn = gets.to_i\ng = Array.new(n){Node.new}\nn.times{|i|\n  g[i].child = gets.split.map(&:to_i)\n  g[i].child.shift\n}\n\ndfs(0, g)\nk = 0\nwhile k < Math.log2(n)\n  v = 0\n  while v < n\n    if g[v].parent[k] < 0\n      g[v].parent[k+1] = -1\n    else\n      g[v].parent[k+1] = g[g[v].parent[k]].parent[k]\n    end\n    v += 1\n  end\n  k += 1\nend\n\nq = gets.to_i\nq.times{\n  u, v = gets.split.map(&:to_i)\n  u, v = v, u if g[u].depth > g[v].depth\n  k = 0\n  while k < Math.log2(n) + 1\n    if (g[v].depth - g[u].depth) >> k & 1 == 1\n      v = g[v].parent[k]\n    end\n    k += 1\n  end\n  if u == v\n    puts u\n    next\n  end\n  k = (Math.log2(n) - 1).to_i\n  while k >= 0\n    if g[u].parent[k] != g[v].parent[k]\n      u = g[u].parent[k]\n      v = g[v].parent[k]\n    end\n    k -= 1\n  end\n  puts g[u].parent[0]\n}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$c = Array.new(n){ Array.new }\nn.times do |i|\n  a = gets.split.map(&:to_i)[1..-1]\n  a.each{ |j| $c[i] << j }\nend\n$depth = Array.new(n)\n$parent = Array.new(n)\n$max = (Math.log(n) / Math.log(2)).ceil\n$dp = Array.new(n){ Array.new($max) }\n\ndef dfs(a, pre, dep)\n  $depth[a] = dep\n  $parent[a] = pre\n  $dp[a][0] = pre\n  (1...$max).each do |i|\n    if $dp[a][i-1] != -1 then $dp[a][i] = $dp[$dp[a][i-1]][i-1]\n    else $dp[a][i] = -1\n    end\n  end\n  $c[a].each do |i|\n    next if i == pre\n    dfs(i, a, dep+1)\n  end\nend\n\ndef lca(a, b)\n  if $depth[a] > $depth[b] then a, b = b, a \n  end\n  dh = $depth[b] - $depth[a]\n  i = 0\n  while (1 << i) <= dh\n    if (dh>>i) % 2 == 1 then b = $dp[b][i]\n    end\n    i += 1\n  end\n  return a if a == b\n  ret = -1\n  ($max-1).downto(0) do |i|\n    if $dp[a][i] == $dp[b][i] then ret = $dp[a][i]\n    else\n      a = $dp[a][i]\n      b = $dp[b][i]\n    end\n  end\n  return ret\nend\n\ndfs(0,-1,0)\nq = gets.to_i\nq.times do\n  a, b = gets.split.map(&:to_i)\n  p lca(a,b)\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\ntree = Hash[(0..n-1).map {|i| [i, {}] }]\nparent = Hash[(0..n-1).map {|i| [i, nil] }]\nn.times do |i|\n  k, *neighbours = gets.split.map(&:to_i)\n  neighbours.each do |j|\n    tree[i][j] = 0\n    parent[j] = i\n  end\nend\n\nsubtree_size = Hash[(0..n-1).map {|i| [i, 1] }]\nout_degree = (0..n-1).map {|i| tree[i].size }\nqueue = (0..n-1).select {|i| out_degree[i] == 0 }\npaths = []\nuntil queue.empty?\n  i = queue.shift\n  tree[i].each_key do |j|\n    subtree_size[i] += subtree_size[j]\n  end\n  j = parent[i]\n  if j\n    out_degree[j] -= 1\n    queue << j if out_degree[j] == 0\n  end\nend\n\n# Heavy-Light Decomposition\nqueue = [0]\nposition = {}\nord = 0\nuntil queue.empty?\n  i = queue.shift\n  path = [i]\n  loop do\n    heavy = true\n    tree[i].each_key.sort_by {|j| -subtree_size[j]}.each do |j|\n      if heavy\n        path << j\n        i = j\n        heavy = false\n      else\n        queue << j\n      end\n    end\n    break if heavy\n  end\n  path.unshift parent[path[0]] if parent[path[0]]\n  (1..path.size - 1).each do |i|\n    position[path[i]] = [path, i, ord]\n  end\n  paths << path\n  ord += 1\nend\n\nposition[0] = [paths[0], 0, 0]\n\nq = gets.to_i\nq.times do\n  u, v = gets.split.map(&:to_i)\n  path1, i, o1  = position[u]\n  path2, j, o2  = position[v]\n  until o1 == o2\n    if o1 > o2\n      path1, i, o1  = position[u = path1[0]]\n    else\n      path2, j, o2  = position[v = path2[0]]\n    end\n  end\n  puts i < j ? path1[i] : path1[j]\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "#Doubling lca\nclass Node\n  attr_accessor :child, :depth, :parent\n  def initialize\n    @child = []\n    @depth = 0\n    @parent = []\n  end\nend\n\ndef dfs(root, g)\n  stack = [root]\n  g[root].depth = 0\n  g[root].parent[0] = -1\n  while stack.size > 0\n    s = stack[-1]\n    t = g[s].child.shift\n    if t\n      stack << t\n      g[t].depth = g[s].depth + 1\n      g[t].parent[0] = s\n    else\n      stack.pop\n    end\n  end\nend\n\nn = gets.to_i\ng = Array.new(n){Node.new}\nn.times{|i|\n  g[i].child = gets.split.map(&:to_i)\n  g[i].child.shift\n}\n\ndfs(0, g)\nk = 0\nwhile k < Math.log2(n)\n  v = 0\n  while v < n\n    if g[v].parent[k] < 0\n      g[v].parent[k+1] = -1\n    else\n      g[v].parent[k+1] = g[g[v].parent[k]].parent[k]\n    end\n    v += 1\n  end\n  k += 1\nend\n\nq = gets.to_i\nknown = Hash.new{|h, key| h[key] = {}}\n\nq.times{\n  u, v = gets.split.map(&:to_i)\n  u, v = v, u if g[u].depth > g[v].depth\n  uu = u\n  vv = v\n  unless known[uu][vv]\n    k = 0\n    while k < Math.log2(n) + 1\n      if (g[v].depth - g[u].depth) >> k & 1 == 1\n        v = g[v].parent[k]\n      end\n      k += 1\n    end\n    if u == v\n      known[uu][vv] = u\n    else\n      k = (Math.log2(n) - 1).to_i\n      while k >= 0\n        if g[u].parent[k] != g[v].parent[k]\n          u = g[u].parent[k]\n          v = g[v].parent[k]\n        end\n        k -= 1\n      end\n      known[uu][vv] =  g[u].parent[0]\n    end\n  end\n  puts known[uu][vv]\n}"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n$c = Array.new(n)\nn.times{ |i| $c[i] = gets.split.map(&:to_i)[1..-1] }\n$depth = Array.new(n)\n$max = (Math.log(n) / Math.log(2)).ceil\n$dp = Array.new(n){ Array.new($max) }\n \ndef bfs\n  arr = []\n  arr << [0,-1,0]\n  until arr.empty?\n    a,pre,dep = arr.shift\n    $depth[a] = dep\n    $dp[a][0] = pre\n    (1...$max).each do |i|\n      if $dp[a][i-1] != -1 then $dp[a][i] = $dp[$dp[a][i-1]][i-1]\n      else $dp[a][i] = -1\n      end\n    end\n    $c[a].each do |i|\n      next if i == pre\n      arr << [i, a, dep+1]\n    end\n  end\nend\n \ndef lca(a, b)\n  a, b = b, a if $depth[a] > $depth[b]\n  dh = $depth[b] - $depth[a]\n  i = 0\n  while (1 << i) <= dh\n    b = $dp[b][i] if (dh>>i) % 2 == 1\n    i += 1\n  end\n  return a if a == b\n  ($max-1).downto(0) do |i|\n    if $dp[a][i] != $dp[b][i]\n      a = $dp[a][i]; b = $dp[b][i] \n    end\n  end\n  $dp[a][0]\nend\n \nbfs\ngets.to_i.times do\n  a, b = gets.split.map(&:to_i)\n  p lca a, b\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar infty = 1000000000\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\ntype DirectedGraphNodeID int\n\ntype DirectedGraphNode struct {\n\tkey       DirectedGraphNodeID\n\tparent    *DirectedGraphNode\n\tadjacents []*DirectedGraphNode\n\n\tl int\n\th int\n}\n\nvar currentMaxNodeID = 0\n\nfunc getLowestCommonAncestor(leftNode, rightNode *DirectedGraphNode) *DirectedGraphNode {\n\tif leftNode.l <= rightNode.l && rightNode.h <= leftNode.h {\n\t\treturn leftNode\n\t} else if rightNode.l <= leftNode.l && leftNode.h <= rightNode.h {\n\t\treturn rightNode\n\t}\n\treturn getLowestCommonAncestor(leftNode.parent, rightNode)\n}\n\nfunc fillRange(parent *DirectedGraphNode) (int, int) {\n\tcurrentMaxNodeID++\n\tif len(parent.adjacents) == 0 {\n\t\tparent.l = currentMaxNodeID\n\t\tparent.h = currentMaxNodeID\n\t} else {\n\t\tparent.l = currentMaxNodeID\n\t\tfor _, adjacent := range parent.adjacents {\n\t\t\t_, _ = fillRange(adjacent)\n\t\t\t// fmt.Println(adjacent.key, l, h, parent.l, parent.h)\n\t\t}\n\t\tcurrentMaxNodeID++\n\t\tparent.h = currentMaxNodeID\n\t}\n\treturn parent.l, parent.h\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tnNodes := nextInt()\n\tnodes := make([]*DirectedGraphNode, nNodes)\n\tfor iNode := 0; iNode < nNodes; iNode++ {\n\t\tnode := DirectedGraphNode{\n\t\t\tkey: DirectedGraphNodeID(iNode),\n\t\t\tl:   infty,\n\t\t\th:   -infty,\n\t\t}\n\t\tnodes[iNode] = &node\n\t}\n\tfor iNode := 0; iNode < nNodes; iNode++ {\n\t\tnChildren := nextInt()\n\t\tparentNode := nodes[iNode]\n\t\tfor iChild := 0; iChild < nChildren; iChild++ {\n\t\t\tiChildNode := nextInt()\n\t\t\tchildNode := nodes[iChildNode]\n\t\t\tchildNode.parent = parentNode\n\t\t\tparentNode.adjacents = append(parentNode.adjacents, childNode)\n\t\t}\n\t}\n\n\tfillRange(nodes[0])\n\n\tnQueries := nextInt()\n\tfor iQuery := 0; iQuery < nQueries; iQuery++ {\n\t\tleftNodeID := DirectedGraphNodeID(nextInt())\n\t\trightNodeID := DirectedGraphNodeID(nextInt())\n\n\t\tleftNode := nodes[leftNodeID]\n\t\trightNode := nodes[rightNodeID]\n\t\tlca := getLowestCommonAncestor(leftNode, rightNode)\n\t\tfmt.Println(lca.key)\n\t}\n\n\t// for _, node := range nodes {\n\t// \tfmt.Println(node.key, node.l, node.h)\n\t// }\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc init() {\n\tReadString = newReadString(os.Stdin)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc newReadString(ior io.Reader) func() string {\n\tr := bufio.NewScanner(ior)\n\t// r.Buffer(make([]byte, 1024), int(1e+11)) // for AtCoder\n\tr.Buffer(make([]byte, 1024), int(1e+9)) // for Codeforces\n\t// Split sets the split function for the Scanner. The default split function is ScanLines.\n\t// Split panics if it is called after scanning has started.\n\tr.Split(bufio.ScanWords)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\n// ReadInt64 returns as integer as int64.\nfunc ReadInt64() int64 {\n\treturn readInt64()\n}\nfunc ReadInt64_2() (int64, int64) {\n\treturn readInt64(), readInt64()\n}\nfunc ReadInt64_3() (int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64()\n}\nfunc ReadInt64_4() (int64, int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64(), readInt64()\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadInt64Slice returns as int64 slice that has n integers.\nfunc ReadInt64Slice(n int) []int64 {\n\tb := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt64()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n// Strtoi is a wrapper of strconv.Atoi().\n// If strconv.Atoi() returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintInts64Line(A ...int64) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.FormatInt(A[i], 10) // 64bit int version\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintDebug is wrapper of fmt.Fprintf(os.Stderr, format, a...)\nfunc PrintDebug(format string, a ...interface{}) {\n\tfmt.Fprintf(os.Stderr, format, a...)\n}\n\n/********** FAU standard libraries **********/\n\n//fmt.Sprintf(\"%b\\n\", 255) \t// binary expression\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*\nASCII code\n\nASCII   10進数  ASCII   10進数  ASCII   10進数\n!       33      \"       34      #       35\n$       36      %       37      &       38\n'       39      (       40      )       41\n*       42      +       43      ,       44\n-       45      .       46      /       47\n0       48      1       49      2       50\n3       51      4       52      5       53\n6       54      7       55      8       56\n9       57      :       58      ;       59\n<       60      =       61      >       62\n?       63      @       64      A       65\nB       66      C       67      D       68\nE       69      F       70      G       71\nH       72      I       73      J       74\nK       75      L       76      M       77\nN       78      O       79      P       80\nQ       81      R       82      S       83\nT       84      U       85      V       86\nW       87      X       88      Y       89\nZ       90      [       91      \\       92\n]       93      ^       94      _       95\n`       96      a       97      b       98\nc       99      d       100     e       101\nf       102     g       103     h       104\ni       105     j       106     k       107\nl       108     m       109     n       110\no       111     p       112     q       113\nr       114     s       115     t       116\nu       117     v       118     w       119\nx       120     y       121     z       122\n{       123     |       124     }       125\n~       126             127\n*/\n\n/*******************************************************************/\n\nconst (\n\t// General purpose\n\tMOD          = 1000000000 + 7\n\tALPHABET_NUM = 26\n\tINF_INT64    = math.MaxInt64\n\tINF_BIT60    = 1 << 60\n\tINF_INT32    = math.MaxInt32\n\tINF_BIT30    = 1 << 30\n\tNIL          = -1\n\n\t// for dijkstra, prim, and so on\n\tWHITE = 0\n\tGRAY  = 1\n\tBLACK = 2\n)\n\nvar G [][]int\n\nfunc main() {\n\tn := ReadInt()\n\tG = make([][]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tk := ReadInt()\n\t\tfor j := 0; j < k; j++ {\n\t\t\tc := ReadInt()\n\t\t\tG[i] = append(G[i], c)\n\t\t\tG[c] = append(G[c], i)\n\t\t}\n\t}\n\n\t// root = 0\n\t// V = n\n\t// initialize()\n\n\tsolver := NewLCASolver(G, 0, n)\n\n\tq := ReadInt()\n\tfor i := 0; i < q; i++ {\n\t\tu, v := ReadInt2()\n\t\t// fmt.Println(lca(u, v))\n\t\tfmt.Println(solver.LCA(u, v))\n\t}\n}\n\nconst (\n\tMAX_V     = 100000 + 5 // maximum node number of a tree\n\tMAX_LOG_V = 100 + 1    // maximum log(n)\n)\n\ntype LCASolver struct {\n\t// Graph info\n\tG    [][]int // graph as adjacent list\n\troot int     // root node ID\n\tn    int     // node number\n\n\t// data structure for answer LCA\n\tparent [MAX_LOG_V][MAX_V]int\n\tdepth  [MAX_V]int\n}\n\nfunc NewLCASolver(G [][]int, root, n int) *LCASolver {\n\ts := new(LCASolver)\n\ts.G, s.root, s.n = G, root, n\n\ts.initialize()\n\treturn s\n}\n\nfunc (s *LCASolver) initialize() {\n\ts.dfs(s.root, -1, 0)\n\tfor k := 0; k+1 < MAX_LOG_V; k++ {\n\t\tfor v := 0; v < s.n; v++ {\n\t\t\tif s.parent[k][v] < 0 {\n\t\t\t\ts.parent[k+1][v] = -1\n\t\t\t} else {\n\t\t\t\ts.parent[k+1][v] = s.parent[k][s.parent[k][v]]\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *LCASolver) dfs(v, p, d int) {\n\ts.parent[0][v] = p\n\ts.depth[v] = d\n\tfor _, to := range s.G[v] {\n\t\tif to != p {\n\t\t\ts.dfs(to, v, d+1)\n\t\t}\n\t}\n}\n\nfunc (s *LCASolver) LCA(u, v int) int {\n\tif s.depth[u] > s.depth[v] {\n\t\tu, v = v, u\n\t}\n\tfor k := 0; k < MAX_LOG_V; k++ {\n\t\tif ((s.depth[v] - s.depth[u]) >> uint(k) & 1) == 1 {\n\t\t\tv = s.parent[k][v]\n\t\t}\n\t}\n\n\tif u == v {\n\t\treturn u\n\t}\n\n\tfor k := MAX_LOG_V - 1; k >= 0; k-- {\n\t\tif s.parent[k][u] != s.parent[k][v] {\n\t\t\tu, v = s.parent[k][u], s.parent[k][v]\n\t\t}\n\t}\n\n\treturn s.parent[0][u]\n}\n\n/*\n- まずは全探索を検討しましょう\n- MODは最後にとりましたか？\n- ループを抜けた後も処理が必要じゃありませんか？\n- 和・積・あまりを求められたらint64が必要ではありませんか？\n- いきなりオーバーフローはしていませんか？\n- MOD取る系はint64必須ですよ？\n*/\n\n/*******************************************************************/\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tdefer writer.Flush()\n\tn := ReadInt()\n\tadjL := make([][]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tadjL[i] = ReadInts(ReadInt())\n\t}\n\t// 親ノードへのダブリング\n\tparent := make([][]int, 20)\n\tfor k := 0; k < 20; k++ {\n\t\tparent[k] = make([]int, n)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tfor _, v := range adjL[i] {\n\t\t\tparent[0][v] = i\n\t\t}\n\t}\n\tfor k := 1; k < 20; k++ {\n\t\tfor v := 1; v < n; v++ {\n\t\t\tparent[k][v] = parent[k-1][parent[k-1][v]]\n\t\t}\n\t}\n\t// n回上に辿った親ノード\n\tfindNthParent := func(v int, n int) int {\n\t\tif n <= 0 {\n\t\t\treturn v\n\t\t}\n\t\tfor k := 0; k < 20; k++ {\n\t\t\tif n>>uint(k)&1 == 1 {\n\t\t\t\tv = parent[k][v]\n\t\t\t}\n\t\t}\n\t\treturn v\n\t}\n\n\t// 各ノードの深さを調べる\n\tdepth := make([]int, n)\n\tvar dfs func(v int, d int)\n\tdfs = func(v int, d int) {\n\t\tdepth[v] = d\n\t\tfor _, u := range adjL[v] {\n\t\t\tdfs(u, d+1)\n\t\t}\n\t}\n\tdfs(0, 0)\n\n\tfor q := ReadInt(); q > 0; q-- {\n\t\tu, v := ReadInt(), ReadInt()\n\t\t// u, v の高さを揃うまで親を辿る\n\t\tu = findNthParent(u, depth[u]-depth[v])\n\t\tv = findNthParent(v, depth[v]-depth[u])\n\t\tif u == v {\n\t\t\tPrintln(u)\n\t\t\tcontinue\n\t\t}\n\t\t// 共通の親を2分探索で見つける\n\t\tfor k := 20 - 1; k >= 0; k-- {\n\t\t\tif parent[k][u] != parent[k][v] {\n\t\t\t\tu = parent[k][u]\n\t\t\t\tv = parent[k][v]\n\t\t\t}\n\t\t}\n\t\tPrintln(parent[0][u])\n\t}\n}\n\nvar reader = bufio.NewReader(os.Stdin)\n\nfunc Scan(a ...interface{}) {\n\tif _, err := fmt.Fscan(reader, a...); err != nil {\n\t\tpanic(err)\n\t}\n}\nfunc ReadInt() (i int) { Scan(&i); return }\nfunc ReadInts(n int) []int {\n\tv := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tScan(&v[i])\n\t}\n\treturn v\n}\n\nvar writer = bufio.NewWriter(os.Stdout)\n\nfunc Println(a ...interface{}) { fmt.Fprintln(writer, a...) }\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar (\n\tN, Q int\n\ttree RootedTree\n)\n\nfunc readVariables() {\n\tN = nextInt()\n\ttree = NewLCA(N, 0)\n\tfor i := 0; i < N; i++ {\n\t\tk := nextInt()\n\t\tfor j := 0; j < k; j++ {\n\t\t\tw := nextInt()\n\t\t\ttree.AddEdge(i, w)\n\t\t}\n\t}\n\tQ = nextInt()\n}\n\nfunc main() {\n\treadVariables()\n\tfor q := 0; q < Q; q++ {\n\t\tu, v := nextInt(), nextInt()\n\t\tlca := tree.Lca(u, v)\n\t\tfmt.Println(lca)\n\t}\n}\n\n/* Template */\n\nvar scanner *bufio.Scanner\n\nfunc init() {\n\tMax := 1001001\n\tscanner = bufio.NewScanner(os.Stdin)\n\tscanner.Buffer(make([]byte, 0, Max), Max)\n\tscanner.Split(bufio.ScanWords)\n}\n\n//nextInt converts next token from stdin and returns integer value.\n//nextInt panics when conversion into an integer fails.\nfunc nextInt() int {\n\tif !scanner.Scan() {\n\t\tpanic(\"No more token.\")\n\t}\n\tnum, err := strconv.Atoi(scanner.Text())\n\tif err != nil {\n\t\tpanic(\"nextInt(): cannot convert to int: \" + scanner.Text())\n\t}\n\treturn num\n}\n\nfunc nextStr() string {\n\tif !scanner.Scan() {\n\t\tpanic(\"No more token.\")\n\t}\n\treturn scanner.Text()\n}\n\n// MinInt returns minimum argument\nfunc MinInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}\n\n//MaxInt returns maximum argument\nfunc MaxInt(x, y int) int {\n\tif x < y {\n\t\treturn y\n\t} else {\n\t\treturn x\n\t}\n}\n\n//AbsInt returns |x| for x\nfunc AbsInt(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n//ModPow calculates integer power with modulo operation\n//if modulo <= 1, it powers w/o module operation\n//if base < 0, return value might be negative too.\nfunc ModPow(base, exponent, modulo int) (result int) {\n\tresult = 1\n\tfor exponent > 0 {\n\t\tif exponent%2 == 1 {\n\t\t\tresult *= base\n\t\t\tif modulo > 1 {\n\t\t\t\tresult %= modulo\n\t\t\t}\n\t\t}\n\t\tbase *= base\n\t\tif modulo > 1 {\n\t\t\tbase %= modulo\n\t\t}\n\t\texponent /= 2\n\t}\n\treturn\n}\n\n//Gcd\nfunc Gcd(vals ...int) (result int) {\n\tif len(vals) == 0 {\n\t\treturn\n\t}\n\tresult = vals[0]\n\tfor i := 1; i < len(vals); i++ {\n\t\tresult = gcd(result, vals[i])\n\t}\n\treturn\n}\n\nfunc gcd(x, y int) int {\n\tx, y = AbsInt(x), AbsInt(y)\n\tfor y > 0 {\n\t\tx, y = y, x%y\n\t}\n\treturn x\n}\n\n//Lcm\nfunc Lcm(vals ...int) (result int) {\n\tif len(vals) == 0 {\n\t\treturn\n\t}\n\tresult = vals[0]\n\tfor i := 1; i < len(vals); i++ {\n\t\tresult = lcm(result, vals[i])\n\t}\n\treturn\n}\n\nfunc lcm(x, y int) int {\n\treturn x * y / gcd(x, y)\n}\n\ntype Tree struct {\n\tSize int\n\tAdj  [][]int\n}\n\ntype RootedTree struct {\n\tTree\n\tRoot        int\n\tDepth       []int\n\tParent      [][]int //Parent[v][k] = 2^k th parent of v\n\tmaxLogSize  int\n\tinitialized bool\n}\n\n/*\nNewLCA returns rooted tree of size n.\n*/\nfunc NewLCA(size, root int) RootedTree {\n\ttree := Tree{\n\t\tSize: size,\n\t\tAdj:  make([][]int, size),\n\t}\n\tMaxLogSize := int(math.Ceil(math.Log2(float64(size)))) + 1\n\trootedTree := RootedTree{\n\t\tTree:       tree,\n\t\tRoot:       root,\n\t\tDepth:      make([]int, size),\n\t\tParent:     make([][]int, size),\n\t\tmaxLogSize: MaxLogSize,\n\t}\n\treturn rootedTree\n}\n\n/*\nInit prepares for incoming Lca() queries.\n*/\nfunc (t *RootedTree) Init() {\n\tfor i := 0; i < t.Size; i++ {\n\t\tt.Parent[i] = make([]int, t.maxLogSize)\n\t}\n\tt.dfs(t.Root, -1, 0)\n\tfor k := 0; k < t.maxLogSize-1; k++ {\n\t\tfor v := 0; v < t.Size; v++ {\n\t\t\tif t.Parent[v][k] == -1 {\n\t\t\t\tt.Parent[v][k+1] = -1\n\t\t\t} else {\n\t\t\t\tt.Parent[v][k+1] = t.Parent[t.Parent[v][k]][k]\n\t\t\t}\n\t\t}\n\t}\n\tt.initialized = true\n}\n\nfunc (t *RootedTree) dfs(v, parent, depth int) {\n\tt.Parent[v][0] = parent\n\tt.Depth[v] = depth\n\tfor _, w := range t.Adj[v] {\n\t\tif w == parent {\n\t\t\tcontinue\n\t\t}\n\t\tt.dfs(w, v, depth+1)\n\t}\n}\n\n/*\nAddEdge adds new edge connecting the v-th and the w-th node to the rooted tree instance.\n*/\nfunc (t *RootedTree) AddEdge(v, w int) {\n\tt.Adj[v] = append(t.Adj[v], w)\n\tt.Adj[w] = append(t.Adj[w], v)\n}\n\n/*\nLca returns the lowest common ancestor of the v-th and w-th node.\n*/\nfunc (t *RootedTree) Lca(v, w int) int {\n\tif !t.initialized {\n\t\tt.Init()\n\t}\n\tif t.Depth[v] < t.Depth[w] {\n\t\tv, w = w, v //ensure v >= w, v is not shallower than w\n\t}\n\tfor k := 0; k < t.maxLogSize; k++ {\n\t\tif (t.Depth[v]-t.Depth[w])>>uint64(k)&1 == 1 {\n\t\t\tv = t.Parent[v][k]\n\t\t}\n\t}\n\tif v == w {\n\t\treturn v\n\t}\n\tfor k := t.maxLogSize - 1; k >= 0; k-- {\n\t\tif t.Parent[v][k] != t.Parent[w][k] {\n\t\t\tv = t.Parent[v][k]\n\t\t\tw = t.Parent[w][k]\n\t\t}\n\t}\n\treturn t.Parent[v][0]\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\n\nvoid main() {\n    auto n = readln.chomp.to!int;\n    auto g = new int[][](n);\n    foreach (i; 0..n) {\n        auto s = readln.split.map!(to!int).array;\n        auto k = s.front;\n        foreach (j; 1..k+1) {\n            g[i] ~= s[j];\n            g[s[j]] ~= i;\n        }\n    }\n\n    auto lca = new LowestCommonAncestor(g, 0);\n\n    auto q = readln.chomp.to!int;\n    while (q--) {\n        auto s = readln.split.map!(to!int);\n        auto x = s[0];\n        auto y = s[1];\n        writeln(lca.lca(x, y));\n    }\n}\n\n\nclass LowestCommonAncestor {\n    import std.algorithm : swap;\n    import std.conv : to;\n    import std.typecons : Tuple, tuple;\n    import core.bitop : bsr;\n\n    int n, root, lgn;\n    int[][] graph;\n    int[] depth;\n    int[][] dp;\n\n    this(const int[][] graph, int root) {\n        n = graph.length.to!int;\n        this.root = root;\n        this.graph = new int[][](n);\n        foreach (i; 0..n) this.graph[i] = graph[i].dup;\n\n        lgn = bsr(n) + 3;\n        depth = new int[](n);\n        dp = new int[][](lgn, n);\n\n        construct;\n    }\n\n    int lca(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        int diff = depth[a] - depth[b];\n        foreach_reverse (i; 0..lgn) if (diff & (1<<i)) a = dp[i][a];\n\n        if (a == b) return a;\n\n        int K = lgn;\n        while (dp[0][a] != dp[0][b]) {\n            foreach_reverse (k; 0..lgn) {\n                if (dp[k][a] != dp[k][b]) {\n                    a = dp[k][a];\n                    b = dp[k][b];\n                    K = k;\n                }\n            }\n        }\n\n        return dp[0][a];\n    }\n\n    private void construct() {\n        auto stack = new Tuple!(int, int, int)[](n+10);\n        int sp = 0;\n        stack[0] = tuple(root, -1, 0);\n        while (sp >= 0) {\n            auto u = stack[sp][0];\n            auto p = stack[sp][1];\n            auto d = stack[sp][2];\n            sp -= 1;\n            dp[0][u] = p;\n            depth[u] = d;\n            foreach (v; graph[u]) if (v != p) stack[++sp] = tuple(v, u, d+1);\n        }\n\n        foreach (k; 0..lgn-1)\n            foreach (i; 0..n)\n                dp[k+1][i] = (dp[k][i] == -1) ? -1 : dp[k][dp[k][i]];\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.algorithm, std.array, std.range, std.conv,\n    std.typecons, std.math, std.container, std.format, std.numeric;\n\nlong[] parent;\nlong[][] children;\nlong[] depth;\nlong[][] ancestor_table;\n\nvoid calc_depth(long i, long d)\n{\n    depth[i] = d;\n    foreach (c; children[i])\n    {\n        calc_depth(c, d + 1);\n    }\n}\n\nvoid make_table(long n, long size)\n{\n    foreach (i; 0 .. size)\n    {\n        foreach (j; 0 .. n)\n        {\n            if (i == 0)\n            {\n                ancestor_table[j][i] = parent[j];\n            }\n            else\n            {\n                auto k = ancestor_table[j][i - 1];\n                if (k == -1)\n                {\n                    ancestor_table[j][i] = -1;\n                }\n                else\n                {\n                    ancestor_table[j][i] = ancestor_table[k][i - 1];\n                }\n            }\n        }\n    }\n}\n\nlong get_nth_parent(long p, long n)\n{\n    long i = 0;\n    while (n != 0 && p != -1)\n    {\n        if (n & 1)\n        {\n            p = ancestor_table[p][i];\n        }\n        i++;\n        n /= 2;\n    }\n    return p;\n}\n\nlong lca(long u, long v, long n)\n{\n    if (depth[u] > depth[v])\n    {\n        swap(u, v);\n    }\n\n    v = get_nth_parent(v, depth[v] - depth[u]);\n    assert(depth[u] == depth[v]);\n    // long ok = 0;\n    // while (get_nth_parent(u, ok) != get_nth_parent(v, ok))\n    // {\n    //     ok++;\n    // }\n    // return get_nth_parent(u, ok);\n\n    long ok = depth[v], ng = -1;\n    while (abs(ng - ok) > 1)\n    {\n        long m = (ok + ng) / 2;\n        if (get_nth_parent(u, m) == get_nth_parent(v, m))\n        {\n            ok = m;\n        }\n        else\n        {\n            ng = m;\n        }\n    }\n\n    return get_nth_parent(v, ok);\n}\n\nvoid main(string[] args)\n{\n    long n;\n    readf(\"%d\\n\", &n);\n    parent = new long[](n);\n    children = new long[][](n);\n\n    parent.fill(-1);\n    foreach (i; 0 .. n)\n    {\n        auto cs = readln.strip.split(\" \").to!(long[]);\n        foreach (c; cs[1 .. $])\n        {\n            parent[c] = i;\n            children[i] ~= c;\n        }\n    }\n\n    depth = new long[](n);\n    calc_depth(0, 0);\n\n    long size = 0;\n    for (long i = 1; i < n; i *= 2)\n    {\n        size++;\n    }\n\n    ancestor_table = new long[][](n, size);\n    make_table(n, size);\n\n    long q;\n    readf(\"%d\\n\", &q);\n    long u, v;\n    foreach (i; 0 .. q)\n    {\n        readf(\"%d %d\\n\", &u, &v);\n        long ans = lca(u, v, n);\n        writeln(ans);\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.array, std.range, std.algorithm, std.container;\nimport std.math, std.random, std.bigint, std.datetime, std.format;\nvoid main(string[] args){ if(args.length > 1) if(args[1] == \"-debug\") DEBUG = 1; solve(); }\nvoid log()(){ writeln(\"\"); } void log(T, A ...)(T t, lazy A a){ if(DEBUG) write(t, \" \"), log(a); } bool DEBUG = 0; \nstring rstring(){ static string[] ss; while(!ss.length) ss = readln.chomp.split; string res = ss[0]; ss.popFront; return res; }\nT rtype(T)(){ return rstring.to!T; } alias rint = rtype!int, rlong = rtype!long, rreal = rtype!real;\nT[] rtypes(T)(int n){ return n.iota.map!(i => rtype!T()).array; } alias rint = rtypes!int, rlong = rtypes!long, rreal = rtypes!real;\nT[][] rtypess(T)(int n, int m){ return n.iota.map!(i => rtypes!T(m)).array; } alias rint = rtypess!int, rlong = rtypess!long, rreal = rtypess!real;\nT chmin(T)(ref T x, T y){ if(x > y) x = y; return x; } T chmax(T)(ref T x, T y){ if(x < y) x = y; return x; }\n\n// ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- //\n\nvoid solve(){\n\tint n = rint;\n\tNode[] nodes;\n\tforeach(i; 0 .. n) nodes ~= new Node(i);\n\tforeach(nd; nodes) foreach(_; 0 .. rint) nd.connectTo(nodes[rint]);\n\n\tNode.root = nodes[0];\n\n\tforeach(_; 0 .. rint){\n\t\tNode p = nodes[rint], q = nodes[rint];\n\t\tp.lca(q).id.writeln;\n\t}\n}\n\n// 最小共通祖先, lca, 最低共通祖先, Lowest Common Ancestor, Least Common Ancestor\n// パスの長さ, 木上の距離, ツリー上の距離, ツリーでの最短経路の長さ\n// ※ループがある場合や、森になっている場合は非対応\nclass Node{\n\tstatic Node[] all; // 存在する全てのノード\n\tint id;\n\tNode[] nodes; // 隣接ノード（親も子も含む）\n\tint depth; // 根は 0\n\tNode[] parents; // 1代前、2代前、4代前、8代前、…… の親（いない場合は打切り）\n\tprivate bool isDone;\n\n\t// 頂点を作成（根付き木は壊れる）\n\tthis(int id){\n\t\tthis.id = id;\n\t\tall ~= this;\n\t\t_root = null;\n\t}\n\n\t// 辺を作成（根付き木は壊れる）\n\tvoid connectTo(Node nd){\n\t\tthis.nodes ~= nd, nd.nodes ~= this;\n\t\t_root = null;\n\t}\n\n\t// 根付き木にする（木になってない場合は未定義）\n\tprivate static Node _root;\n\tstatic Node root(){ return _root; }\n\tstatic Node root(Node r){\n\n\t\t// parents[0] を設定する\n\t\tforeach(nd; all) nd.isDone = 0;\n\t\tr.parents = [], r.depth = 0;\n\t\tNode[] ndq = [r];\n\t\tfor(int i = 0; i < ndq.length; i ++){\n\t\t\tNode p = ndq[i];\n\t\t\tp.isDone = 1;\n\t\t\tforeach(q; p.nodes) if(! q.isDone){\n\t\t\t\tq.parents = [p], q.depth = p.depth + 1;\n\t\t\t\tndq ~= q;\n\t\t\t}\n\t\t}\n\n\t\t// parents[1] 以降を設定する（30 はマジックナンバー、log(2;N) 程度）\n\t\tforeach(i; 1 .. 30) foreach(nd; all){\n\t\t\tif(i <= nd.parents.length){\n\t\t\t\tNode par = nd.parents[i - 1];\n\t\t\t\tif(i <= par.parents.length) nd.parents ~= par.parents[i - 1];\n\t\t\t}\n\t\t}\n\n\t\treturn _root = r;\n\t}\n\t\n\t// 2点間の距離\n\tint distTo(Node nd){\n\t\tNode p = this.lca(nd);\n\t\treturn (this.depth - p.depth) + (nd.depth - p.depth);\n\t}\n\n\t// 最小共通祖先\n\tNode lca(Node nd){\n\t\tassert(root);\n\t\tif(this.depth > nd.depth) return nd.lca(this);\n\t\tif(this.depth < nd.depth) foreach_reverse(p; nd.parents) if(p.depth >= this.depth) return lca(p);\n\t\tforeach_reverse(i, p; nd.parents) if(this.parents[i].id != p.id){\n\t\t\treturn this.parents[i].lca(p);\n\t\t}\n\t\tif(this.id == nd.id) return this; else return this.parents[0];\n\t}\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.range;\nimport std.algorithm, std.array, std.typecons, std.container;\nimport std.math, std.numeric, std.random, core.bitop;\n\nenum inf = 1_001_001_001;\nenum infl = 1_001_001_001_001_001_001L;\n\n\nstruct LCA {\n    int N, L, root;\n    int[] depth;\n    int[][] dp;\n\n    this(int[][] adj, int root) {\n        import std.conv : to;\n\n        N = adj.length.to!int;\n        while ((1 << L) <= N) L++;\n        this.root = root;\n        depth = new int[](N);\n        dp = new int[][](N, L);\n        dfs(adj, this.root, -1);\n\n        foreach (i ; 1 .. L) {\n            foreach (v ; 0 .. N) {\n                if ((1 << i) > depth[v]) continue;\n                dp[v][i] = dp[dp[v][i - 1]][i - 1];\n            }\n        }\n    }\n\n    void clear() {\n        N = L = root = 0;\n        depth.destroy();\n        dp.destroy();\n    }\n\n    void dfs(int[][] adj, int v, int p) {\n        dp[v][] = -1;\n        dp[v][0] = p;\n        depth[v] = (p == -1 ? 0 : depth[p] + 1);\n        foreach (u ; adj[v]) if (u != p) {\n            dfs(adj, u, v);\n        }\n    }\n\n    int query(int u, int v) {\n        import std.algorithm : swap;\n\n        if (depth[u] > depth[v]) swap(u, v);\n        // depth[u] <= depth[v]\n        int dif = depth[v] - depth[u];\n\n        // v を引き上げて u と v の深さを揃える\n        foreach_reverse (i ; 0 .. L) {\n            if (dif & 1 << i) {\n                v = dp[v][i];\n            }\n        }\n\n        if (u == v) return u;\n\n        // u と v を lca(u, v) の一つ下まで引き上げる\n        foreach_reverse (i ; 0 .. L) {\n            if (dp[u][i] != dp[v][i]) {\n                u = dp[u][i];\n                v = dp[v][i];\n            }\n        }\n\n        return dp[u][0];\n    }\n\n    alias opCall = query;\n\n    int dist(int u, int v) {\n        return depth[u] + depth[v] - 2 * depth[query(u, v)];\n    }\n}\n\nunittest {\n    auto adj = [[1, 2, 3],\n                [0, 4, 5],\n                [0, 6],\n                [0, 7, 8],\n                [1],\n                [1, 9],\n                [2],\n                [3],\n                [3],\n                [5]];\n\n    auto lca = LCA(adj, 0);\n\n    assert(lca(4, 9) == 1);\n    assert(lca(1, 3) == 0);\n    assert(lca(1, 9) == 1);\n    assert(lca(6, 6) == 6);\n    assert(lca(9, 8) == 0);\n\n    assert(lca.dist(0, 9) == 3);\n    assert(lca.dist(4, 9) == 3);\n    assert(lca.dist(0, 6) == 2);\n    assert(lca.dist(9, 8) == 5);\n    assert(lca.dist(0, 0) == 0);\n}\n\n\n\nvoid main() {\n    int N;\n    scan(N);\n    auto adj = new int[][](N, 0);\n    foreach (i ; 0 .. N) {\n        auto ln = readln.split.to!(int[]);\n        foreach (u ; ln[1 .. $]) {\n            adj[i] ~= u;\n            adj[u] ~= i;\n        }\n    }\n\n    auto lca = LCA(adj, 0);\n    \n    int Q;\n    scan(Q);\n\n    foreach (_ ; 0 .. Q) {\n        int u, v;\n        scan(u, v);\n        writeln(lca(u, v));\n    }\n}\n\n\n\n\n\n\nvoid scan(T...)(ref T args) {\n    auto line = readln.split;\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront;\n    }\n    assert(line.empty);\n}\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\nbool chmin(T, U...)(ref T x, U args) {\n    bool isChanged;\n    foreach (arg; args) if (x > arg) {\n        x = arg;\n        isChanged = true;\n    }\n    return isChanged;\n}\n\nbool chmax(T, U...)(ref T x, U args) {\n    bool isChanged;\n    foreach (arg; args) if (x < arg) {\n        x = arg;\n        isChanged = true;\n    }\n    return isChanged;\n}\n\nvoid yes(bool ok, string y = \"Yes\", string n = \"No\") {\n    return writeln(ok ? y : n);\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nimport core.bitop;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nclass Tree {\n    int N; // Graph(Tree)???????????°\n    int[][] G; // Graph(Tree)?????£??\\???????????¨???\n    int[] D; // ????????????root??????????????¢\n    int LOG_N; // log2(N)?????????\n    int[][] P; // P[k][v] : ??????v???2^k?????????????\\?\n    void dfs(int prev, int index, int d) {\n        P[0][index] = prev;\n        D[index] = d;\n        for (int i = 0; i < G[index].size; i++) {\n            int next = G[index][i];\n            if (next == prev) continue;\n            dfs(index, next, d + 1);\n        }\n    }\n    this(int[][] G) {\n        this.N = G.size;\n        this.G = G;\n        this.LOG_N = bsr(N) + 1;\n        this.P = new int[][](LOG_N, N);\n        this.D = new int[N]; D[] = -1;\n        dfs(-1, 0, 0);\n        for (int k = 0; k < LOG_N - 1; k++) {\n            for (int v = 0; v < N; v++) {\n                if (P[k][v] < 0) P[k + 1][v] = -1;\n                else P[k + 1][v] = P[k][ P[k][v] ];\n            }\n        }\n    }\n    // ??????v???n?????????????????????\n    int nth_parent(int v, int n) {\n        for (int k = 0; k < LOG_N; k++)\n            if (n & (1 << k)) v = P[k][v];\n        return v;\n    }\n    // 2??????u??¨v???LCA?????????\n    int lca(int u, int v) {\n        if (D[u] > D[v]) swap(u, v);\n        v = nth_parent(v, D[v] - D[u]);\n        if (u == v) return u;\n        for (int k = LOG_N - 1; k >= 0; k--) {\n            if (P[k][u] != P[k][v]) {\n                u = P[k][u];\n                v = P[k][v];\n            }\n        }\n        return P[0][u];\n    }\n    // 2??????u??¨v????????¢?????????\n    int dist(int u, int v) {\n        int root = lca(u, v);\n        return (D[u] - D[root]) + (D[v] - D[root]);\n    }\n}\n\nvoid main() {\n    int N = readln.chomp.to!int;\n    auto G = new int[][N];\n    for (int i = 0; i < N; i++) {\n        int k; scanf(\"%d \", &k);\n        for (int j = 0; j < k; j++) {\n            int c; scanf(\"%d\", &c);\n            G[i] ~= c;\n        }\n    }\n    auto t = new Tree(G);\n    int Q; scanf(\"%d\", &Q);\n    for (int q = 0; q < Q; q++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        writeln(t.lca(u, v));\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(100000)\n\nfrom math import log2\n\n\ndef build():\n    dfs(tree, 0, -1, 0)\n    pk0 = parent[0]\n    for k in range(1, logn):\n        pk1 = parent[k]\n        for v in range(n):\n            pkv = pk0[v]\n            pk1[v] = -1 if pkv < 0 else pk0[pkv]\n        pk0 = pk1\n\n\ndef dfs(tree, v, p, d):\n    parent[0][v] = p\n    depth[v] = d\n    for child in tree[v]:\n        if child != p:\n            dfs(tree, child, v, d + 1)\n\n\ndef get(u, v):\n    du, dv = depth[u], depth[v]\n    if du > dv:\n        u, v = v, u\n        du, dv = dv, du\n    for k in range(logn):\n        if (dv - du) >> k & 1:\n            v = parent[k][v]\n    if u == v:\n        return u\n    for k in range(logn - 1, -1, -1):\n        pk = parent[k]\n        if pk[u] != pk[v]:\n            u, v = pk[u], pk[v]\n    return parent[0][u]\n\n\nn = int(input())\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nlogn = int(log2(n)) + 1\nparent = [[0] * n for _ in range(logn)]\ndepth = [0] * n\nbuild()\n\nq = int(input())\nfor _ in range(q):\n    print(get(*map(int, input().split())))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n# Post Order順を使用して判定する\n# q = 100000では3分近くかかり、実用に耐えず\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass LowestCommonAncestor:\n    def __init__(self, graph, root):\n        self.graph = graph\n        self.root = root\n        self._cache = {}\n        self._dfs()\n\n    def _dfs(self):\n        n = self.graph.v\n        visited = [False] * n\n        parent = [None] * n\n        post_order = [0] * n\n\n        stack = [self.root]\n        i = 0\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n                for e in self.graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        parent[w] = v\n                        stack.append(w)\n            else:\n                post_order[v] = i\n                i += 1\n\n        self.post_order = post_order\n        self.parent = parent\n\n    def find(self, v, w):\n        pos = self.post_order\n        i = pos[v]\n        j = pos[w]\n        if i > j:\n            i, j = j, i\n            v, w = w, v\n\n        vv = v\n        while i < j:\n            if (vv, w) in self._cache:\n                vv = self._cache[(vv, w)]\n                break\n            vv = self.parent[vv]\n            i = pos[vv]\n\n        self._cache[(v, w)] = vv\n        return vv\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    lca = LowestCommonAncestor(g, 0)\n    q = int(input())\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        print(lca.find(v, w))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.nodes = [i for i in range(n)]\n        self.sizes = [1 for _ in range(n)]\n\n    def union(self, p, q):\n        rp = self.root(p)\n        rq = self.root(q)\n        if self.sizes[rp] > self.sizes[rq]:\n            self.nodes[rq] = rp\n            self.sizes[rp] += self.sizes[rq]\n        else:\n            self.nodes[rp] = rq\n            self.sizes[rq] += self.sizes[rp]\n\n    def connected(self, p, q):\n        return self.root(p) == self.root(q)\n\n    def root(self, p):\n        while p != self.nodes[p]:\n            self.nodes[p] = self.nodes[self.nodes[p]]\n            p = self.nodes[p]\n\n        return p\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass WeightedEdge(Edge):\n    __slots__ = ('v', 'w', 'weight')\n\n    def __init__(self, v, w, weight):\n        super().__init__(v, w)\n        self.weight = weight\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\ndef lca(graph, root, queries):\n    index = [[] for _ in range(graph.v)]\n    for v, w in queries:\n        index[v].append((v, w))\n        index[w].append((v, w))\n\n    visited = [False] * graph.v\n    parents = [None] * graph.v\n    uf = UnionFind(graph.v)\n    res = {}\n    stack = [root]\n    while stack:\n        v = stack.pop()\n        if not visited[v]:\n            visited[v] = True\n            stack.append(v)\n            for e in graph.adj(v):\n                w = e.other(v)\n                if not visited[w]:\n                    stack.append(w)\n                    parents[w] = v\n        else:\n            p = parents[v]\n            rest = []\n            for i, j in index[v]:\n                if uf.connected(i, j) and (i, j) not in res:\n                    res[(i, j)] = v\n                else:\n                    rest.append((i, j))\n            index[v] = None\n            if p is not None:\n                uf.union(p, v)\n                index[p].extend(rest)\n\n    return res\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    q = int(input())\n    qs = []\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        qs.append((v, w))\n\n    res = lca(g, 0, qs)\n    for v, w in qs:\n        print(res[(v, w)])\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import math\nfrom collections import defaultdict\n\ndef dfs(here, p, d, parent, depth, connect):\n    parent[0][here] = p\n    depth[here] = d\n    for next_v in connect[here]:\n        dfs(next_v, here, d + 1, parent, depth, connect)\n\ndef lca(v1, v2, parent):\n    v1, v2 = max(v1, v2), min(v1, v2)\n    for i in range(max_log):\n        if depth[v1] - depth[v2] >> i & 1:\n            v1 = parent[i][v1]\n    if v1 == v2:\n        return v2\n    for i in range(max_log - 1, -1, -1):\n        if parent[i][v1] != parent[i][v2]:\n            v1 = parent[i][v1]\n            v2 = parent[i][v2]\n    return parent[0][v2]\n\nconnect = defaultdict(list)\nv_num = int(input())\nroot = 0\nfor i in range(v_num):\n    edge = [int(n) for n in input().split(\" \")]\n    connect[i].extend(edge[1:])\ndepth = [-1 for n in range(v_num)]\nmax_log = int(math.log(v_num, 2))\nparent = [[-1 for n in range(v_num)] for m in range(max_log)]\ndfs(root, -1, 0, parent, depth, connect)\nfor i in range(max_log - 1):\n    for v in range(v_num):\n        parent[i + 1][v] = -1 if parent[i][v] < 0 else parent[i][parent[i][v]]\nq_num = int(input())\nfor _ in range(q_num):\n    v1, v2 = (int(n) for n in input().split(\" \") )\n    print(lca(v1, v2, parent))"
  },
  {
    "language": "Python",
    "code": "from math import log2\n\n\ndef build():\n    dfs()\n    pk0 = parent[0]\n    for pk1 in parent[1:]:\n        for v in range(n):\n            pkv = pk0[v]\n            pk1[v] = -1 if pkv < 0 else pk0[pkv]\n        pk0 = pk1\n\n\ndef dfs():\n    stack = [(0, -1, 0)]\n    while stack:\n        v, p, d = stack.pop()\n        parent[0][v] = p\n        depth[v] = d\n        stack.extend((child, v, d + 1) for child in tree[v])\n\n\ndef get(u, v):\n    du, dv = depth[u], depth[v]\n    if du > dv:\n        u, v = v, u\n        du, dv = dv, du\n    for k, pk in enumerate(parent):\n        if (dv - du) >> k & 1:\n            v = pk[v]\n    if u == v:\n        return u\n    for pk in parent[logn - 1:None:-1]:\n        pku, pkv = pk[u], pk[v]\n        if pku != pkv:\n            u, v = pku, pkv\n    return parent[0][u]\n\n\nn = int(input())\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nlogn = int(log2(n)) + 1\nparent = [[0] * n for _ in range(logn)]\ndepth = [0] * n\nbuild()\n\nq = int(input())\nfor _ in range(q):\n    print(get(*map(int, input().split())))"
  },
  {
    "language": "Python",
    "code": "class Edge:\n    def __init__(self, dst, weight):\n        self.dst, self.weight = dst, weight\n\n    def __lt__(self, e):\n        return self.weight > e.weight\n\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, src, dst, weight):\n        self.E[src].append(Edge(dst, weight))\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid = [0] * g.V\n        self.head = [-1] * g.V\n        self.heavy = [-1] * g.V\n        self.parent = [-1] * g.V\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, v, par=-1):\n        self.parent[v] = par\n        sub, max_sub = 1, 0\n        for e in self.g.E[v]:\n            child = e.dst\n            if child != par:\n                child_sub = self.dfs(child, v)\n                sub += child_sub\n                if child_sub > max_sub:\n                    max_sub = child_sub\n                    self.heavy[v] = child\n        return sub\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for e in self.g.E[v]:\n                    if e.dst != self.parent[v] and e.dst != self.heavy[v]:\n                        que.append(e.dst)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = Graph(N)\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g.add_edge(i, c, 1)\n        g.add_edge(c, i, 1)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n8\n3 1 2 3\n2 4 5\n0\n0\n0\n2 6 7\n0\n0\n4\n4 6\n4 7\n4 3\n5 2\n\noutput:\n1\n1\n0\n0\n\"\"\"\n\nimport sys\nimport math\n\n\ndef rmq_init(node, begin, end):\n    if begin == end:\n        M[node] = begin\n    else:\n        rmq_init(2 * node, begin, (begin + end) // 2)\n        rmq_init(2 * node + 1, (begin + end) // 2 + 1, end)\n        if depth[M[2 * node]] <= depth[M[2 * node + 1]]:\n            M[node] = M[2 * node]\n        else:\n            M[node] = M[2 * node + 1]\n\n    return M\n\n\ndef rmq_query(node, begin, end, s, t):\n    if s > end or t < begin:\n        return -1\n    if begin >= s and end <= t:\n        return M[node]\n\n    p1 = rmq_query(2 * node, begin, (begin + end) // 2, s, t)\n    p2 = rmq_query(2 * node + 1, (begin + end) // 2 + 1, end, s, t)\n\n    if p1 == -1:\n        M[node] = p2\n        return p2\n    if p2 == -1:\n        M[node] = p1\n        return p1\n\n    if depth[p1] <= depth[p2]:\n        M[node] = p1\n        return p1\n\n    M[node] = p2\n    return p2\n\n\ndef dfs(current, parent, c_depth):\n    global timer\n    ids[current] = timer\n    vs[timer] = current\n    depth[timer] = c_depth\n    timer += 1\n\n    for adj in adj_table[current]:\n        if adj != parent:\n            dfs(adj, current, c_depth + 1)\n            vs[timer] = current\n            depth[timer] = c_depth\n            timer += 1\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        # assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    ext_length = 2 * v_num - 1\n    vs, depth = ([-1] * ext_length for _ in range(2))\n    ids = [-1] * v_num\n\n    root = 0\n    timer = 0\n    dfs(root, -1, 0)\n    M = [-1] * (pow(2, math.ceil(math.log2(ext_length)) + 1) + 1)\n    # print(vs, depth, ids)\n\n    rmq_init(node=1, begin=0, end=ext_length - 1)\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        q_min = min(ids[q1], ids[q2])\n        q_max = max(ids[q1], ids[q2])\n        vs_idx = rmq_query(node=1, begin=0, end=ext_length - 1, s=q_min, t=q_max)\n        print(vs[vs_idx])"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nimport resource\nMAX_N = 202020\nsys.setrecursionlimit(MAX_N)\nE = [[] for i in range(MAX_N)]\ndepth = [0]*MAX_N\nK = (int)(math.log2(MAX_N) + 10)\n\n#db[i][j] = 頂点jの2^i個上の頂点\n#iは高々、log2(頂点数)の切り上げを超えない。(このコードでは念のため少し余裕を持たせている。)\ndb = [[-1]*(MAX_N) for i in range(K)] \n\n#根からの深さを記録するためのdfs\ndef dfs(now,parent,d):\n    #nowの2^0(=1)個上は、親頂点である。\n    db[0][now] = parent\n    depth[now] = d\n    for to in E[now]:\n        if(to != parent):dfs(to,now,d+1)\n\n#ダブリング\ndef doubling():\n    for i in range(K-1):\n        for j in range(MAX_N):\n            if(db[i][j] < 0):\n                #頂点jの2^i個上が-1→jの2^i個上は根を飛び越えてしまっているので、2^(i+1) 個上も当然根を飛び越えている。\n                db[i+1][j] = -1\n            else:\n                #頂点jの2^i個上がdb[i][j]→頂点jの2^(i+1) 個次の頂点は、「jの2^i個次の頂点」の「2^i個次の頂点」である。\n                db[i+1][j] = db[i][db[i][j]]\n\ndef LCA(u,v):\n    #uのほうが浅い場合は、swapする。(これにより、一般性を失わずuを深いほうにできる。)\n    if(depth[u] < depth[v]):u,v = v,u\n    if(u == v):return u\n\n    \n\n    #uとvについて、根からの距離をそろえる\n    #iの降順に見ていっていることに注意\n    #uの2^i個上がまだvの深さ以上の場合、2^i個さかのぼる\n    for i in range(K-1,-1,-1):\n        if(db[i][u] == -1):continue\n        if(depth[db[i][u]] >= depth[v]):u = db[i][u]\n    #この時点でuとvの深さは等しい。\n    if(u == v):return u\n\n    #u,vの2^i個上の頂点について、等しいなら2^i個さかのぼり、そうでないならとどまる、という動きの繰り返し\n    #iの降順に見ていっていることに注意\n    for i in range(K-1,-1,-1):\n        if(db[i][u] != db[i][v]):\n            u = db[i][u]\n            v = db[i][v]\n    #上り終わった後のuの親がLCAとなっている。\n    return db[0][u]\n    \n\n\n\nn = int(input())\nfor i in range(n):\n    li = list(map(int,input().split()))\n    for j in range(li[0]):E[i].append(li[j+1])\n\ndfs(0,-1,0)\ndoubling()\n\nq = int(input())\nfor i in range(q):\n    u,v =li = list(map(int,input().split()))\n    print(LCA(u,v))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass LowestCommonAncestor:\n    def __init__(self, graph, root):\n        self.graph = graph\n        self.root = root\n        self.descendants = self._dfs()\n\n    def _dfs(self):\n        n = self.graph.v\n        descendants = [set() for _ in range(n)]\n        visited = [False] * n\n        edge_to = [None] * n\n\n        stack = [self.root]\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n                for e in self.graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        edge_to[w] = v\n                        stack.append(w)\n            else:\n                p = edge_to[v]\n                if p is not None:\n                    descendants[p].add(v)\n                    descendants[p].update(descendants[v])\n\n        return descendants\n\n    def find(self, i, j):\n        checked = [False] * self.graph.v\n        pair = {i, j}\n        v = self.root\n        while True:\n            checked[v] = True\n            for e in self.graph.adj(v):\n                w = e.other(v)\n                if not checked[w]:\n                    if pair <= self.descendants[w]:\n                        v = w\n                        break\n            else:\n                return v\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    lca = LowestCommonAncestor(g, 0)\n    q = int(input())\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        print(lca.find(v, w))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * len(g), [-1] * len(g), [-1] * len(g), [-1] * len(g)\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1, False)]\n        sub, max_sub = [1] * len(self.g), [(0, -1)] * len(self.g)\n        while stack:\n            v, par, flag = stack.pop()\n            if not flag:\n                self.parent[v] = par\n                stack.append((v, par, True))\n                stack.extend((c, v, False) for c in self.g[v] if c != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    if sub[v] > max_sub[0]:\n                        max_sub[par] = (sub[v], v)\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for c in self.g[v]:\n                    if c != self.parent[v] and c != self.heavy[v]:\n                        que.append(c)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = [[] for _ in range(N)]\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g[i].append(c)\n        g[c].append(i)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "from math import log2\n\n\ndef build():\n    dfs(tree, 0, -1, 0)\n    pk0 = parent[0]\n    for k in range(1, logn):\n        pk1 = parent[k]\n        for v in range(n):\n            pkv = pk0[v]\n            pk1[v] = -1 if pkv < 0 else pk0[pkv]\n        pk0 = pk1\n\n\ndef dfs(tree, v, p, d):\n    parent[0][v] = p\n    depth[v] = d\n    for child in tree[v]:\n        if child != p:\n            dfs(tree, child, v, d + 1)\n\n\ndef get(u, v):\n    du, dv = depth[u], depth[v]\n    if du > dv:\n        u, v = v, u\n        du, dv = dv, du\n    for k in range(logn):\n        if (dv - du) >> k & 1:\n            v = parent[k][v]\n    if u == v:\n        return u\n    for k in range(logn - 1, -1, -1):\n        pk = parent[k]\n        if pk[u] != pk[v]:\n            u, v = pk[u], pk[v]\n    return parent[0][u]\n\n\nn = int(input())\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nlogn = int(log2(n)) + 1\nparent = [[0] * n for _ in range(logn)]\ndepth = [0] * n\nbuild()\n\nq = int(input())\nfor _ in range(q):\n    print(get(*map(int, input().split())))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom functools import lru_cache\nimport sys\nbuff_readline = sys.stdin.buffer.readline\nreadline = sys.stdin.readline\n\nINF = 2**60\n\n\ndef read_int():\n    return int(buff_readline())\n\n\ndef read_int_n():\n    return list(map(int, buff_readline().split()))\n\n\nclass Doubling():\n    def __init__(self, a0):\n        \"\"\"\n        a0 is an array-like object which contains ai, 0 <= i < N.\n        ai is the next value of i.\n        \"\"\"\n        N = len(a0)\n        self.N = N\n        self.nt = [[None] * N for i in range(N.bit_length()+1)]\n        for i, a in enumerate(a0):\n            self.nt[0][i] = a\n\n        for i in range(1, len(self.nt)):\n            for j in range(N):\n                if self.nt[i-1][j] is None:\n                    self.nt[i][j] = None\n                else:\n                    self.nt[i][j] = self.nt[i-1][self.nt[i-1][j]]\n\n    def apply(self, i, n):\n        \"\"\"\n        Apply n times from i\n        \"\"\"\n        j = i\n        for k in range(n.bit_length()):\n            m = 1 << k\n            if m & n:\n                j = self.nt[k][j]\n            if j is None:\n                break\n        return j\n\n\nclass LCA():\n    def __init__(self, g, root):\n        s = [root]\n        self.N = len(g)\n        self.p = [None] * self.N\n        self.d = [INF] * self.N\n\n        self.p[root] = root\n        self.d[root] = 0\n        while s:\n            u = s.pop()\n            for v in g[u]:\n                if self.d[v] is INF:\n                    self.p[v] = u\n                    self.d[v] = self.d[u] + 1\n                    s.append(v)\n\n        self.doubling = Doubling(self.p)\n\n    def query(self, u, v):\n        if self.d[u] > self.d[v]:\n            u, v = v, u\n        o = self.d[v] - self.d[u]\n        v = self.doubling.apply(v, o)\n\n        if u == v:\n            return u\n\n        for k in range(len(self.doubling.nt)-1, -1, -1):\n            if self.doubling.nt[k][u] != self.doubling.nt[k][v]:\n                u = self.doubling.nt[k][u]\n                v = self.doubling.nt[k][v]\n        return self.doubling.nt[0][u]\n\n\ndef slv(N, KC, Q, UV):\n    g = [list() for _ in range(N)]\n    for u, (k, *c) in enumerate(KC):\n        for v in c:\n            g[u].append(v)\n            g[v].append(u)\n\n    lca = LCA(g, 0)\n\n    ans = []\n    for u, v in UV:\n        i = lca.query(u, v)\n        ans.append(i)\n\n    return ans\n\n\ndef main():\n    N = read_int()\n    KC = [read_int_n() for _ in range(N)]\n    Q = read_int()\n    UV = [read_int_n() for _ in range(Q)]\n    print(*slv(N, KC, Q, UV), sep='\\n')\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN = int(readline())\nG = [None]*N\nfor v in range(N):\n    k, *G[v] = map(int, readline().split())\n\nS = []\n\nFS = [0]*N\ndepth = [0]*N\n\n*it, = map(iter, G)\nP = [-1]*N\n\nstk = [0]\ndepth[0] = 0\nFS[0] = 0\nwhile stk:\n    v = stk[-1]\n    p = P[v]\n    S.append(v)\n\n    w = next(it[v], -1)\n    while w != -1:\n        if w != p:\n            P[w] = v\n            depth[w] = len(stk)\n            FS[w] = len(S)\n            stk.append(w)\n            break\n        w = next(it[v], -1)\n    else:\n        stk.pop()\n\nL = len(S)\nlg = [0]*(L + 1)\nfor i in range(2, L+1):\n    lg[i] = lg[i >> 1] + 1\nst = [None]*(lg[L] + 1)\nst0 = st[0] = S\nb = 1\nfor i in range(lg[L]):\n    st0 = st[i+1] = [p if depth[p] <= depth[q] else q for p, q in zip(st0, st0[b:])]\n    b <<= 1\n\ndef query(u, v):\n    x = FS[u]; y = FS[v]\n    if x > y:\n        x, y = y, x\n    l = lg[y - x + 1]\n    px = st[l][x]; py = st[l][y - (1 << l) + 1]\n    return px if depth[px] <= depth[py] else py\n\nQ = int(readline())\nans = []\nfor q in range(Q):\n    u, v = map(int, readline().split())\n    ans.append(query(u, v))\nwrite(\"\\n\".join(map(str, ans)))\nwrite(\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy,itertools,bisect,collections,heapq\n\ndef main():\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n    NI = lambda : int(sys.stdin.readline())\n\n    n = NI()\n    m = n.bit_length()+1\n    root = [[-1] * n for _ in range(m)]\n    rev = [0] * n\n    depth = [0] * n\n    for i in range(n):\n        x = LI()\n        for a in x[1:]:\n            root[0][a] = i\n            depth[a] = depth[i] + 1\n    for k in range(1,m):\n        for i in range(n):\n            root[k][i] = root[k-1][root[k-1][i]]\n\n    q = NI()\n    for _ in range(q):\n        u,v = LI()\n        if depth[u] < depth[v] : u,v = v, u\n        d = depth[u] - depth[v]\n        bit = 1\n        for i in range(d.bit_length()):\n            if d & bit: u = root[i][u]\n            bit <<= 1\n\n        j = depth[u].bit_length() - 1\n        while j >= 0:\n            if root[j][u] != root[j][v]:\n                u = root[j][u]\n                v = root[j][v]\n            j -= 1\n        if u == v:\n            print(u)\n        else:\n            print(root[0][u])\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nn = int(input())\nli = [list(map(int, input().split()))[1:] for _ in range(n)]\n\n\ndef prepare(n: int, con: list):\n\tsz = n.bit_length()\n\tparent = [[0] * n for _ in range(sz)]\n\tparent[0][0] = -1\n\tdepth = [-1] * n\n\tdepth[0] = 0\n\tq = [0]\n\twhile q:\n\t\tcur = q.pop()\n\t\tfor nxt in con[cur]:\n\t\t\tif depth[nxt] < 0:\n\t\t\t\tdepth[nxt] = depth[cur] + 1\n\t\t\t\tparent[0][nxt] = cur\n\t\t\t\tq.append(nxt)\n\tfor k in range(sz - 1):\n\t\tfor i in range(n):\n\t\t\tif parent[k][i] < 0:\n\t\t\t\tparent[k + 1][i] = -1\n\t\t\telse:\n\t\t\t\tparent[k + 1][i] = parent[k][parent[k][i]]\n\treturn sz, depth, parent\n\n\nsz, depth, parent = prepare(n, li)\n\n\ndef lca(u, v):\n\tif depth[u] > depth[v]:\n\t\tu, v = v, u\n\tfor k in range(sz):\n\t\tif ((depth[v] - depth[u]) >> k & 1):\n\t\t\tv = parent[k][v]\n\tif u == v:\n\t\treturn u\n\tfor k in range(sz - 1, -1, -1):\n\t\tif parent[k][u] != parent[k][v]:\n\t\t\tu, v = parent[k][u], parent[k][v]\n\treturn parent[0][u]\n\n\nans = []\nfor _ in range(int(input())):\n\tu, v = map(int, input().split())\n\tans.append(lca(u, v))\nprint(\"\\n\".join(map(str, ans)))\n\n"
  },
  {
    "language": "Python",
    "code": "import math\nfrom collections import defaultdict\n\ndef dfs(here, p, d, parent, depth, connect):\n    parent[0][here] = p\n    depth[here] = d\n    for next_v in connect[here]:\n        dfs(next_v, here, d + 1, parent, depth, connect)\n\ndef lca(v1, v2, parent, depth):\n    if depth[v2] > depth[v1]:\n        v1, v2 = v2, v1\n    for i in range(max_log):\n        if depth[v1] - depth[v2] >> i & 1:\n            v1 = parent[i][v1]\n    if v1 == v2:\n        return v2\n    for i in range(max_log - 1, -1, -1):\n        if parent[i][v1] != parent[i][v2]:\n            v1 = parent[i][v1]\n            v2 = parent[i][v2]\n    return parent[0][v2]\n\nconnect = defaultdict(list)\nv_num = int(input())\nroot = 0\nfor i in range(v_num):\n    edge = [int(n) for n in input().split(\" \")]\n    connect[i].extend(edge[1:])\ndepth = [-1 for n in range(v_num)]\nmax_log = int(math.log(v_num, 2))\nparent = [[-1 for n in range(v_num)] for m in range(max_log)]\ndfs(root, -1, 0, parent, depth, connect)\nfor i in range(max_log - 1):\n    for v in range(v_num):\n        parent[i + 1][v] = -1 if parent[i][v] < 0 else parent[i][parent[i][v]]\nq_num = int(input())\nfor _ in range(q_num):\n    v1, v2 = (int(n) for n in input().split(\" \") )\n    print(lca(v1, v2, parent, depth))"
  },
  {
    "language": "Python",
    "code": "class Lca:\n    def __init__(self, E, root):\n        import sys\n        sys.setrecursionlimit(500000)\n        self.root = root\n        self.E = E  # V<V>\n        self.n = len(E)  # 頂点数\n        self.logn = 0\n        while self.n > (1<<self.logn):\n            self.logn += 1\n\n        # parent[n][v] = ノード v から 1<<n 個親をたどったノード\n        self.parent = [[-1]*self.n for _ in range(self.logn)]\n\n        self.depth = [0] * self.n\n        self.dfs(root, -1, 0)\n        for k in range(self.logn-1):\n            for v in range(self.n):\n                p_ = self.parent[k][v]\n                if p_ >= 0:\n                    self.parent[k+1][v] = self.parent[k][p_]\n\n    def dfs(self, v, p, dep):\n        # ノード番号、親のノード番号、深さ\n        self.parent[0][v] = p\n        self.depth[v] = dep\n        for e in self.E[v]:\n            if e != p:\n                self.dfs(e, v, dep+1)\n\n    def get(self, u, v):\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u  # self.depth[u] <= self.depth[v]\n        dep_diff = self.depth[v]-self.depth[u]\n        for k in range(self.logn):\n            if dep_diff >> k & 1:\n                v = self.parent[k][v]\n        if u==v:\n            return u\n        for k in range(self.logn-1, -1, -1):\n            if self.parent[k][u] != self.parent[k][v]:\n                u = self.parent[k][u]\n                v = self.parent[k][v]\n        return self.parent[0][u]\n\nn = int(input())\nE = [[] for _ in range(n)]\nfor i in range(n):\n    kc = list(map(int, input().split()))\n    k = kc[0]\n    for c in kc[1:]:\n        E[i].append(c)\n        E[c].append(i)\nlca = Lca(E, 0)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(lca.get(u, v))\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef lca(x, y):\n    if d[x] < d[y]:\n        x,y = y,x\n    dy = d[y]\n    k = d[x]-dy\n    while k:\n        x = p[x][int(math.log(k,2))]\n        k = d[x]-dy\n\n    if x == y:\n        return x\n\n    for i in range(h)[::-1]:\n        if p[x][i] != p[y][i]:\n            x = p[x][i]\n            y = p[y][i]\n    return p[x][0]\nif __name__ == \"__main__\":\n    n = int(input())\n    d = [0]*n\n    d[0] = 1\n    p = [[] for i in range(n)]\n    p[0].append(0)\n    for i in range(n):\n        vi = map(int, input().split()[1:])\n        nd = d[i]+1\n        for j in vi:\n            p[j].append(i)\n            d[j] = nd\n    h = int(math.log(max(d),2))+1\n    for i in range(h-1):\n        for x in range(n):\n            p[x].append(p[p[x][i]][i])\n    q = int(input())\n    for _ in range(q):\n        x,y = map(int, input().split())\n        print(lca(x,y))\n\n"
  },
  {
    "language": "Python",
    "code": "from math import log2\n\n\ndef build():\n    dfs()\n    pk0 = parent[0]\n    for k in range(1, logn):\n        pk1 = parent[k]\n        for v in range(n):\n            pkv = pk0[v]\n            pk1[v] = -1 if pkv < 0 else pk0[pkv]\n        pk0 = pk1\n\n\ndef dfs():\n    stack = [(0, -1, 0)]\n    while stack:\n        v, p, d = stack.pop()\n        parent[0][v] = p\n        depth[v] = d\n        stack.extend((child, v, d + 1) for child in tree[v])\n\n\ndef get(u, v):\n    du, dv = depth[u], depth[v]\n    if du > dv:\n        u, v = v, u\n        du, dv = dv, du\n    for k in range(logn):\n        if (dv - du) >> k & 1:\n            v = parent[k][v]\n    if u == v:\n        return u\n    for k in range(logn - 1, -1, -1):\n        pk = parent[k]\n        if pk[u] != pk[v]:\n            u, v = pk[u], pk[v]\n    return parent[0][u]\n\n\nn = int(input())\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nlogn = int(log2(n)) + 1\nparent = [[0] * n for _ in range(logn)]\ndepth = [0] * n\nbuild()\n\nq = int(input())\nfor _ in range(q):\n    print(get(*map(int, input().split())))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\n\nclass LCA:\n    def __init__(self, n):\n        self.edges = [[] for _ in range(n)]\n        self.n = n\n        self.logn = len(bin(n)[2:])\n        self.parent = [[-1] * self.n for _ in range(self.logn)]\n        self.depth = [0] * self.n\n\n    def add(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\n    def initialize(self, root=0):\n        self.dfs(root, -1, 0)\n        for k in range(self.logn - 1):\n            for v in range(self.n):\n                p_ = self.parent[k][v]\n                if p_ >= 0:\n                    self.parent[k + 1][v] = self.parent[k][p_]\n\n    def dfs(self, v, p, dep):\n        self.parent[0][v] = p\n        self.depth[v] = dep\n        for e in self.edges[v]:\n            if e != p:\n                self.dfs(e, v, dep + 1)\n\n    def get_lca(self, u, v):\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n        dep_diff = self.depth[v] - self.depth[u]\n        for k in range(self.logn):\n            if (dep_diff >> k & 1) != 0:\n                v = self.parent[k][v]\n        if u == v:\n            return u\n        for k in range(self.logn - 1, -1, -1):\n            if self.parent[k][u] != self.parent[k][v]:\n                u = self.parent[k][u]\n                v = self.parent[k][v]\n        return self.parent[0][u]\n\n\nN = int(input())\nlca = LCA(N)\nfor i in range(N):\n    kc = list(map(int, input().split()))\n    k = kc[0]\n    for c in kc[1:]:\n        lca.add(i, c)\n\nlca.initialize()\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(lca.get_lca(u, v))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math\nfrom collections import defaultdict\n\ndef dfs(here, p, d, parent, depth, connect):\n    parent[0][here] = p\n    depth[here] = d\n    for next_v in connect[here]:\n        dfs(next_v, here, d + 1, parent, depth, connect)\n\ndef lca(v1, v2, parent, depth):\n    if depth[v2] > depth[v1]:\n        v1, v2 = v2, v1\n    for i in range(max_log):\n        if depth[v1] - depth[v2] >> i & 1:\n            v1 = parent[i][v1]\n    if v1 == v2:\n        return v2\n    for i in range(max_log - 1, -1, -1):\n        if parent[i][v1] != parent[i][v2]:\n            v1 = parent[i][v1]\n            v2 = parent[i][v2]\n    return parent[0][v2]\n\nconnect = defaultdict(list)\nv_num = int(input())\nroot = 0\nfor i in range(v_num):\n    edge = [int(n) for n in input().split(\" \")]\n    connect[i].extend(edge[1:])\ndepth = [-1 for n in range(v_num)]\nmax_log = max(int(math.log(v_num, 2)), 1)\nparent = [[-1 for n in range(v_num)] for m in range(max_log)]\ndfs(root, -1, 0, parent, depth, connect)\nfor i in range(max_log - 1):\n    for v in range(v_num):\n        parent[i + 1][v] = -1 if parent[i][v] < 0 else parent[i][parent[i][v]]\nq_num = int(input())\nfor _ in range(q_num):\n    v1, v2 = (int(n) for n in input().split(\" \") )\n    print(lca(v1, v2, parent, depth))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef dfs(v, v_parent, v_depth):\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if (depth[v] - depth[u]) >> k & 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num))\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        # assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys, math, itertools, collections, bisect\ninput = lambda: sys.stdin.buffer.readline().rstrip().decode('utf-8')\ninf = float('inf') ;mod = 10**9+7\nmans = inf ;ans = 0 ;count = 0 ;pro = 1\nsys.setrecursionlimit(10**6)\n\n# n = int(input())\n# G = [[] for i in range(n)]\n# for i in range(n-1):\n#   a,b = map(int,input().split())\n#   # a-=1;b-=1\n#   G[a].append(b)\n#   G[b].append(a)\n\nn=int(input())\nG = [[] for i in range(n)]\nfor i in range(n):\n  data = list(map(int,input().split()))\n  for j in range(1,len(data)):\n    G[i].append(data[j])\n\ndepth = [0] * n\nparent = [[0] * n for i in range(20)]\ndef setdepth(node,pre,d):\n  depth[node] = d\n  parent[0][node] = pre\n  for vi in G[node]:\n    if vi == pre: continue\n    setdepth(vi,node,d + 1)\n\nsetdepth(0,-1,0)\n\nfor k in range(19):\n  for v in range(n):\n    if parent[k][v] < 0: parent[k+1][v] = -1\n    else: parent[k+1][v] = parent[k][parent[k][v]]\n\ndef lca(u,v):\n  # 高度調整\n  if depth[u] > depth[v]: u,v = v,u\n  for k in range(20):\n    if (depth[v] - depth[u]) >> k & 1:\n      v = parent[k][v]\n  # 2部探索\n  if u == v:\n    return u\n  for k in range(19,-1,-1):\n    if parent[k][u] != parent[k][v]:\n      u = parent[k][u]\n      v = parent[k][v]\n  return parent[0][u]\n\nQ = int(input())\nfor _ in range(Q):\n  x,y = map(int,input().split())\n  # x-=1;y-=1\n  print(lca(x,y))\n  # print(depth[x] + depth[y] - 2 * depth[lca(x,y)] + 1)\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_right as br\nimport sys\nsys.setrecursionlimit(100000)\nn = int(input())\nparent = [[None] * 20 for _ in range(n)]\nfor i in range(n):\n  clst = list(map(int, input().split()))[1:]\n  for c in clst:\n    parent[c][0] = i\n\nfor i in range(1, 20):\n  for j in range(n):\n    if parent[j][i - 1] != None:\n      parent[j][i] = parent[parent[j][i - 1]][i - 1]\n\nheight = [None for _ in range(n)]\nheight[0] = 0\n\ndef make_height(x):\n  if height[x] != None:return\n  if height[parent[x][0]] != None:\n    make_height(parent[x][0])\n  height[x] = height[parent[x][0]] + 1\n\nfor i in range(n):\n  make_height(i)\n\nbins = [2 ** i for i in range(20)]\n\ndef retro(p, num):\n  if num == 0:return p\n  ind = br(bins, num) - 1\n  return retro(parent[p][ind], num - bins[ind])\n\ndef _lca(u, v):\n  if u == v:\n    return u\n  for i in range(1, 20):\n    if parent[u][i] == parent[v][i]:\n      return _lca(parent[u][i - 1], parent[v][i - 1])\n\ndef lca(u, v):\n  if height[u] < height[v]:\n    v = retro(v, height[v] - height[u])\n  if height[u] > height[v]:\n    u = retro(u, height[u] - height[v])\n  return _lca(u, v)\n\nq = int(input())\nfor _ in range(q):\n  u, v = map(int, input().split())\n  print(lca(u, v))\n\n"
  },
  {
    "language": "Python",
    "code": "import math\nfrom collections import deque\n\ndef create_table(N, A):\n    num_block = int(-(-math.log2(N)//1)) + 1\n    dp = [[-1]*num_block for i in range(N)]\n    for i in range(N):\n        dp[i][0] = i\n    for k in range(1, num_block):\n        for i in range(N):\n            e = min(N-1, i + (1 << (k - 1)))\n            former = dp[i][k-1]\n            later = dp[e][k-1]\n            if A[former] > A[later]:\n                dp[i][k] = later\n            else:\n                dp[i][k] = former\n            if e == N-1:\n                break\n    return dp\n\ndef query(i, j, dp, A):\n    if i == j:\n      return i\n    length = int(math.log2(abs(i-j)))\n    former = dp[i][length]\n    later = dp[j-(1<<length)+1][length]\n    if A[former] > A[later]:\n        return later\n    return former\n      \ndef run():\n  N = int(input())\n  g = {}\n  for n in range(N):\n    kc = list(map(int, input().split()))\n    g[n] = kc[1:]\n  Q = int(input())\n  uv = [tuple(map(int, input().split())) for q in range(Q)]\n  euler = []\n  depths = []\n  order = [-1]*N\n  def dfs(now, pred, d):\n    stacks = deque([(now, pred, d)])\n    while stacks:\n      now, pred, d = stacks.pop()\n      euler.append(now)\n      depths.append(d)\n      if order[now] != -1:\n        continue\n      if order[now] == -1:\n        order[now] = len(euler) - 1\n      for nxt in g[now]:\n        if nxt == pred:\n          continue\n        stacks.append((now, pred, d))\n        stacks.append((nxt, now, d+1))\n  dfs(0, -1, 0)\n  #RMQ\n  len_li = len(depths)\n  dp = create_table(len_li, depths)\n  #LCA\n  for u, v in uv:\n    o1, o2 = order[u], order[v]\n    o1, o2 = min([o1, o2]), max([o1, o2])\n    o = query(o1, o2, dp, depths)\n    print(euler[o])\n    if len(uv) == 1:\n      exit()\n  \nif __name__ == '__main__':\n  run()\n"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef lca(x, y):\n    if d[x] < d[y]:\n        x,y = y,x\n    dy = d[y]\n    k = d[x]-dy#abs(depth)\n    #Align depth\n    while k:\n        x = p[x][int(math.log(k,2))]\n        k = d[x]-dy\n\n    if x == y:\n        return x\n\n    for i in range(h)[::-1]:\n        #print(h)\n        if p[x][i] != p[y][i]:\n            x = p[x][i]\n            y = p[y][i]\n    return p[x][0]\n  \nif __name__ == \"__main__\":\n    n = int(input())\n    #depth\n    d = [0] * n\n    d[0] = 1\n    #parent\n    p = [[] for i in range(n)]\n    p[0].append(0)\n    for i in range(n):\n        vi = map(int, input().split()[1:])\n        nd = d[i] + 1\n        for j in vi:\n            p[j].append(i)\n            d[j] = nd\n    \n    #print(p)\n    #print(d)\n    \n    h = int(math.log(max(d),2)) + 1\n    for i in range(h - 1):\n        for x in range(n):\n            p[x].append(p[p[x][i]][i])\n    #print(p)\n    \n    q = int(input())\n    for _ in range(q):\n        x,y = map(int, input().split())\n        print(lca(x,y))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef dfs(v, v_parent, v_depth):\n    # print(parent, v, v_parent)\n    if not parent:\n        return v_parent\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if ((depth[v] - depth[u]) >> k) % 2 == 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    # with open('test.txt', 'r') as f:\n    #     _input = f.readlines()\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num))\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        # assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "class HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * len(g), [-1] * len(g), [-1] * len(g), [-1] * len(g)\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1)]\n        sub, max_sub = [1] * len(self.g), [(0, -1)] * len(self.g)\n        used = [False] * len(self.g)\n\n        while stack:\n            v, par = stack.pop()\n            if not used[v]:\n                used[v] = True\n                self.parent[v] = par\n                stack.append((v, par))\n                stack.extend((c, v) for c in self.g[v] if c != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for c in self.g[v]:\n                    if c != self.parent[v] and c != self.heavy[v]:\n                        que.append(c)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = [[] for _ in range(N)]\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g[i].append(c)\n        g[c].append(i)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "import math\nfrom collections import deque\n\ndef input(f):\n    n, = map(int, f.readline().split())\n    k = [None for _ in range(n)]\n    c = [[] for _ in range(n)]\n    for i in range(n):\n        tmp = map(int, f.readline().split())\n        k[i] = tmp.pop(0)\n        c[i] = tmp[:]\n    q, = map(int, f.readline().split())\n    u = [None for _ in range(q)]\n    v = [None for _ in range(q)]\n    for i in range(q):\n        u[i], v[i] = map(int, f.readline().split())\n    \n    return n, k, c, q, u, v\n\ndef solve(n, k, c, q, u, v):\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(k[i]):\n            graph[i].append(c[i][j])\n    \n    logn = int(math.log(n, 2))+1\n    pa = [[None for _ in range(n)] for _ in range(logn+1)]\n    depth = [None for _ in range(n)]\n    \n    def build():\n        que = deque()\n        que.append(0)\n        depth[0] = 0\n        while que:\n            cur = que.popleft()\n            for child in c[cur]:\n                depth[child] = depth[cur] + 1\n                que.append(child)\n            \n        for i in range(n):\n            for child in c[i]:\n                pa[0][child] = i\n        for i in range(logn):\n            for j in range(n):\n                if pa[i][j] != None:\n                    pa[i+1][j] = pa[i][pa[i][j]]\n    \n    def query(u, v):\n        while depth[u] != depth[v]:\n            if depth[v] < depth[u]:\n                u, v = v, u\n            d = depth[v] - depth[u]\n            for k in range(logn):\n                if d & 1:\n                    v = pa[k][v]\n                d = d >> 1\n        for nk in range(logn):\n            k = logn - nk - 1\n            if pa[k][u] != pa[k][v]:\n                u = pa[k][u]\n                v = pa[k][v]\n        if u == v:\n            return u\n        return pa[0][u]\n    \n    depth[0] = 0\n    build()\n\n    for i in range(q):\n        yield query(u[i], v[i])\n    \nwith open('/dev/stdin') as f:\n    for res in solve(*input(f)):\n        print(res)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * len(g), [-1] * len(g), [-1] * len(g), [-1] * len(g)\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1, False)]\n        sub, max_sub = [1] * len(self.g), [(0, -1)] * len(self.g)\n        while stack:\n            v, par, flag = stack.pop()\n            if not flag:\n                self.parent[v] = par\n                stack.append((v, par, True))\n                stack.extend((c, v, False) for c in self.g[v] if c != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    if sub[v] > max_sub[par][0]:\n                        max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for c in self.g[v]:\n                    if c != self.parent[v] and c != self.heavy[v]:\n                        que.append(c)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = [[] for _ in range(N)]\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g[i].append(c)\n        g[c].append(i)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "class Lca:\n    def __init__(self, E, root):\n        import sys\n        sys.setrecursionlimit(500000)\n        self.root = root\n        self.E = E  # V<V>\n        self.n = len(E)  # 頂点数\n        self.logn = 1  # n < 1<<logn  ぴったりはだめ\n        while self.n >= (1<<self.logn):\n            self.logn += 1\n\n        # parent[n][v] = ノード v から 1<<n 個親をたどったノード\n        self.parent = [[-1]*self.n for _ in range(self.logn)]\n\n        self.depth = [0] * self.n\n        self.dfs(root, -1, 0)\n        for k in range(self.logn-1):\n            for v in range(self.n):\n                p_ = self.parent[k][v]\n                if p_ >= 0:\n                    self.parent[k+1][v] = self.parent[k][p_]\n\n    def dfs(self, v, p, dep):\n        # ノード番号、親のノード番号、深さ\n        self.parent[0][v] = p\n        self.depth[v] = dep\n        for e in self.E[v]:\n            if e != p:\n                self.dfs(e, v, dep+1)\n\n    def get(self, u, v):\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u  # self.depth[u] <= self.depth[v]\n        dep_diff = self.depth[v]-self.depth[u]\n        for k in range(self.logn):\n            if dep_diff >> k & 1:\n                v = self.parent[k][v]\n        if u==v:\n            return u\n        for k in range(self.logn-1, -1, -1):\n            if self.parent[k][u] != self.parent[k][v]:\n                u = self.parent[k][u]\n                v = self.parent[k][v]\n        return self.parent[0][u]\n\nn = int(input())\nE = [[] for _ in range(n)]\nfor i in range(n):\n    kc = list(map(int, input().split()))\n    k = kc[0]\n    for c in kc[1:]:\n        E[i].append(c)\n        E[c].append(i)\nlca = Lca(E, 0)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(lca.get(u, v))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n# Post Order順を使用して判定する\n# q = 100000では時間がかかり過ぎ、実用に耐えず\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass LowestCommonAncestor:\n    def __init__(self, graph, root):\n        self.graph = graph\n        self.root = root\n        self._cache = {}\n        self._dfs()\n\n    def _dfs(self):\n        n = self.graph.v\n        visited = [False] * n\n        parent = [None] * n\n        post_order = [0] * n\n\n        stack = [self.root]\n        i = 0\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n                for e in self.graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        parent[w] = v\n                        stack.append(w)\n            else:\n                post_order[v] = i\n                i += 1\n\n        self.post_order = post_order\n        self.parent = parent\n\n    def find(self, v, w):\n        pos = self.post_order\n        i = pos[v]\n        j = pos[w]\n        if i > j:\n            i, j = j, i\n            v, w = w, v\n\n        vv = v\n        while i < j:\n            if (vv, w) in self._cache:\n                vv = self._cache[(vv, w)]\n                break\n            vv = self.parent[vv]\n            i = pos[vv]\n\n        self._cache[(v, w)] = vv\n        return vv\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    lca = LowestCommonAncestor(g, 0)\n    q = int(input())\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        print(lca.find(v, w))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.nodes = [i for i in range(n)]\n        self.sizes = [1 for _ in range(n)]\n\n    def union(self, p, q):\n        rp = self.root(p)\n        rq = self.root(q)\n        if self.sizes[rp] > self.sizes[rq]:\n            self.nodes[rq] = rp\n            self.sizes[rp] += self.sizes[rq]\n        else:\n            self.nodes[rp] = rq\n            self.sizes[rq] += self.sizes[rp]\n\n    def connected(self, p, q):\n        return self.root(p) == self.root(q)\n\n    def root(self, p):\n        while p != self.nodes[p]:\n            self.nodes[p] = self.nodes[self.nodes[p]]\n            p = self.nodes[p]\n\n        return p\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass WeightedEdge(Edge):\n    __slots__ = ('v', 'w', 'weight')\n\n    def __init__(self, v, w, weight):\n        super().__init__(v, w)\n        self.weight = weight\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\ndef lca(graph, root, queries):\n    index = [set() for _ in range(graph.v)]\n    for v, w in queries:\n        index[v].add((v, w))\n\n    visited = [False] * graph.v\n    stored = [False] * graph.v\n    parents = [None] * graph.v\n    uf = UnionFind(graph.v)\n    res = {}\n    stack = [root]\n    while stack:\n        v = stack.pop()\n        if not visited[v]:\n            visited[v] = True\n            stack.append(v)\n            for e in graph.adj(v):\n                w = e.other(v)\n                if not visited[w]:\n                    stack.append(w)\n                    parents[w] = v\n        else:\n            stored[v] = True\n            p = parents[v]\n            rest = set()\n            for i, j in index[v]:\n                if stored[i] and stored[j]:\n                    if uf.connected(i, j) and (i, j) not in res:\n                        res[(i, j)] = v\n                    else:\n                        rest.add((i, j))\n                else:\n                    index[j].add((i, j))\n            index[v] = None\n            if p is not None:\n                uf.union(p, v)\n                index[p].update(rest)\n\n    return res\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    q = int(input())\n    qs = []\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        qs.append((v, w))\n\n    res = lca(g, 0, qs)\n    for v, w in qs:\n        print(res[(v, w)])\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nclass Tree():\n    def __init__(self,n,edge):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        for e in edge:\n            self.tree[e[0]-1].append(e[1]-1)\n            self.tree[e[1]-1].append(e[0]-1)\n\n    def setroot(self,root):\n        self.root = root\n        self.parent = [None for _ in range(self.n)]\n        self.parent[root] = -1\n        self.depth = [None for _ in range(self.n)]\n        self.depth[root] = 0\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            for adj in self.tree[node]:\n                if self.parent[adj] is None:\n                    self.parent[adj] = node\n                    self.depth[adj] = self.depth[node]+1\n                    stack.append(adj)\n\n    def construct_lca(self):\n        L = (self.n-1).bit_length()\n        self.k_parent = [self.parent]\n        prev = self.parent\n        for k in range(L):\n            array = [0 for _ in range(self.n)]\n            for i in range(self.n):\n                if prev[i] == -1:\n                    continue\n                array[i] = prev[prev[i]]\n            self.k_parent.append(array)\n            prev = array\n\n    def lca(self,u,v):\n        d = self.depth[v]-self.depth[u]\n        if d < 0: u,v,d = v,u,-d\n        for k in self.k_parent:\n            if d & 1: v = k[v]\n            d >>= 1\n        if u == v:\n            return u\n        for k in reversed(self.k_parent):\n            pu,pv = k[u],k[v]\n            if pu != pv: u,v = pu,pv\n        return self.k_parent[0][u]\n\nN = int(input())\nE = []\n\nfor i in range(N):\n    raw_input = list(map(int,input().split()))\n    for j in range(raw_input[0]):\n        E.append((i+1,raw_input[j+1]+1))\n\nt = Tree(N,E)\nt.setroot(0)\nt.construct_lca()\n\nQ = int(input())\nA = []\n\nfor _ in range(Q):\n    u,v = map(int,input().split())\n    A.append(t.lca(u,v))\n\nprint(*A,sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\nsys.setrecursionlimit(int(1e6))\n\n\ndef dfs(v, v_parent, v_depth):\n    # print(parent, v, v_parent)\n    if not parent:\n        return v_parent\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if (depth[v] - depth[u]) >> k & 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num))\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        # assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass LowestCommonAncestor:\n    def __init__(self, graph, root):\n        self.graph = graph\n        self.root = root\n        self._dfs()\n\n    def _dfs(self):\n        n = self.graph.v\n        visited = [False] * n\n        parent = [None] * n\n        post_order = [0] * n\n\n        stack = [self.root]\n        i = 0\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n                for e in self.graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        parent[w] = v\n                        stack.append(w)\n            else:\n                post_order[v] = i\n                i += 1\n\n        self.post_order = post_order\n        self.parent = parent\n\n    def find(self, v, w):\n        ps = self.parent\n        pos = self.post_order\n        i = pos[v]\n        j = pos[w]\n        if i > j:\n            i, j = j, i\n            v, w = w, v\n\n        while i < j and v != self.root:\n            v = ps[v]\n            i = pos[v]\n        return v\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    lca = LowestCommonAncestor(g, 0)\n    q = int(input())\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        print(lca.find(v, w))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass LowestCommonAncestor():\n    \"\"\"根付き木に対して、二頂点の共通の祖先で最も近いところにある頂点を求める\n    初期化(ダブリング配列parent[k][v]の構築): O(NlogN)\n    lcaを求めるクエリ: O(logN)\n    \"\"\"\n    \n    def __init__(self, tree, root):\n        self.n = len(tree)\n        self.depth = [0] * self.n\n        self.log_size = (self.n).bit_length()\n        self.parent = [[-1] * self.n for i in range(self.log_size)]\n\n        # 親を2^0回たどって到達する頂点、つまり現在の頂点に対する親の頂点を求める\n        # parent[0][現在の頂点] = 親の頂点\n        q = deque([(root, -1, 0)]) # (現在の地点, 親の頂点, 現在の頂点と親の頂点間の距離) \n        while q:\n            v, par, dist = q.pop()\n            self.parent[0][v] = par\n            self.depth[v] = dist\n            for child_v in tree[v]:\n                if child_v != par:\n                    self.depth[child_v] = dist + 1\n                    q.append((child_v, v, dist + 1))\n\n        # ダブリングで親を2^k回たどって到達する頂点を求める\n        for k in range(1, self.log_size):\n            for v in range(self.n):\n                self.parent[k][v] = self.parent[k-1][self.parent[k-1][v]]\n            \n    def lca(self, u, v):\n        # u, vのうち深いところにある方から|depth[u] - depth[v]|だけ親をたどる\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n        for k in range(self.log_size):\n            if (self.depth[v] - self.depth[u] >> k) & 1:\n                v = self.parent[k][v]\n        if u == v:\n            return u\n          \n        # 二分探索でLCAを求める\n        for k in reversed(range(self.log_size)):\n            if self.parent[k][u] != self.parent[k][v]:\n                u = self.parent[k][u]\n                v = self.parent[k][v]\n        return self.parent[0][u]\n\n\nn = int(input())\ninfo = [list(map(int, input().split())) for i in range(n)]\ntree = [[] for i in range(n)]\nfor i in range(n):\n    for j in info[i][1:]:\n        tree[i].append(j)\n        tree[j].append(i)\n\nlca = LowestCommonAncestor(tree, 0)\n\nq = int(input())\nquery = [list(map(int, input().split())) for i in range(q)]\nfor i in range(q):\n    u, v = query[i]\n    print(lca.lca(u, v))\n"
  },
  {
    "language": "Python",
    "code": "import sys,math\nsys.setrecursionlimit(1000000)\nINF = float(\"inf\")\n\nN = int(sys.stdin.readline())\nc = tuple(tuple(map(int,sys.stdin.readline().rstrip().split()))[1:] for _ in range(N)) # multi line with multi param\nQ = int(sys.stdin.readline())\nuv = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(Q)) # multi line with multi param\nG = [list() for _ in range(N)]\n\nfor i,children in enumerate(c):\n    G[i] = children\n\nsquare = [i**2 for i in range(i,40)]\nimport bisect\n#LN = bisect.bisect_left(square,N)+2\nLN = math.ceil(math.log2(N))+1\ndepth = [0]*N\nparents = [[0]*N for _ in range(LN)]\n\ndef dfs(v,p,l):\n    parents[0][v] = p\n    depth[v] = l\n    for i in G[v]:\n        if i != p:\n            dfs(i,v,l+1)\n\ndfs(0,-1,0)\n\nfor k in range(LN-1):#-1?\n    for v in range(N):\n        if parents[k][v] < 0:\n            parents[k+1][v] = -1\n        else:\n            parents[k+1][v] = parents[k][parents[k][v]]\n\ndef query(u,v):\n    if depth[u] > depth[v]:\n        u,v = v,u\n    while depth[v] != depth[u]:\n        v = parents[int(math.log2(depth[v]-depth[u]))][v]\n    # for k in range(LN)[::-1]:\n    #     if ((depth[v]-depth[u])>>k & 1):\n    #         v = parents[k][v]\n    assert(depth[u]==depth[v])\n    if u == v:\n        return u\n    for k in range(LN)[::-1]:\n        if parents[k][v] != parents[k][u]:\n            v = parents[k][v]\n            u = parents[k][u]\n    return parents[0][u]\n\nans = []\nfor u,v in uv:\n    print(query(u,v))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * len(g), [-1] * len(g), [-1] * len(g), [-1] * len(g)\n        self.dfs(root)\n        self.bfs(root)\n \n    def dfs(self, root):\n        stack = [(root, -1)]\n        sub, max_sub = [1] * len(self.g), [(0, -1)] * len(self.g)\n        used = [False] * len(self.g)\n \n        while stack:\n            v, par = stack.pop()\n            if not used[v]:\n                used[v] = True\n                self.parent[v] = par\n                stack.append((v, par))\n                stack.extend((c, v) for c in self.g[v] if c != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n \n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for c in self.g[v]:\n                    if c != self.parent[v] and c != self.heavy[v]:\n                        que.append(c)\n                k += 1\n                v = self.heavy[v]\n \n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n \nN = int(input())\ng = [[] for _ in range(N)]\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g[i].append(c)\n        g[c].append(i)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom math import log\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v,p,d):\n    parent[0][v]=p\n    depth[v]=d\n    for i in xrange(len(G[v])):\n        if G[v][i]!=p:\n            dfs(G[v][i],v,d+1)\n\ndef init(vn,root):\n    dfs(root,-1,0)\n    k=0\n    while k+1<log(vn,2):\n        for v in xrange(vn):\n            if parent[k][v]<0:\n                parent[k+1][v]=-1\n            else:\n                parent[k+1][v]=parent[k][parent[k][v]]\n        k+=1\n\ndef lca(u,v,vn):\n    if depth[u]>depth[v]:u,v=v,u\n    k=0\n    while k<log(vn,2):\n        if (depth[v]-depth[u])>>k&1:\n            v=parent[k][v]\n        k+=1\n    if u==v:return u\n    for k in xrange(int(log(vn,2))-1,-1,-1):\n        if parent[k][u]!=parent[k][v]:\n            u=parent[k][u]\n            v=parent[k][v]\n    return parent[0][u]\n\n\nvn=int(raw_input())        #????????°\nG=[[] for _ in xrange(vn)] #??£??\\?????????\nparent=[[-1]*vn for _ in xrange(int(log(vn,2))+1)] #parent[k][u]:??????u??????2^k????????????????????£?????¨????????????\ndepth=[0]*vn               #depth[u]:??????u?????????????????±??????????????±??????0\nroot=0                     #??????????????????\n\nfor i in xrange(vn):\n    en=map(int,raw_input().split())\n    c=en[1:]          #????????????i??????\n    G[i]=c\n\ninit(vn,root)\n\nq=int(raw_input())\nfor _ in xrange(q):\n    u,v=map(int,raw_input().split())\n    print(lca(u,v,vn))"
  },
  {
    "language": "Python",
    "code": "import sys\nstdin = sys.stdin\ninf = 1 << 60\nmod = 1000000007\n \nni      = lambda: int(ns())\nnin     = lambda y: [ni() for _ in range(y)]\nna      = lambda: list(map(int, stdin.readline().split()))\nnan     = lambda y: [na() for _ in range(y)]\nnf      = lambda: float(ns())\nnfn     = lambda y: [nf() for _ in range(y)]\nnfa     = lambda: list(map(float, stdin.readline().split()))\nnfan    = lambda y: [nfa() for _ in range(y)]\nns      = lambda: stdin.readline().rstrip()\nnsn     = lambda y: [ns() for _ in range(y)]\nncl     = lambda y: [list(ns()) for _ in range(y)]\nnas     = lambda: stdin.readline().split()\n\nsys.setrecursionlimit(10 ** 7)\n\nclass LCA:\n    def __init__(self, G, root=0):\n        V = len(G)\n        K = 1\n        while 1 << K < V:\n            K += 1\n        self.parent = [[-1] * V for _ in range(K)]\n        self.dist = [-1] * V\n        self.dfs(G, root, -1, 0)\n        for k in range(K - 1):\n            for v in range(V):\n                if self.parent[k][v] < 0:\n                    self.parent[k + 1][v] = -1\n                else:\n                    self.parent[k + 1][v] = self.parent[k][self.parent[k][v]]\n    \n    def dfs(self, G, v, p, d):\n        self.parent[0][v] = p\n        self.dist[v] = d\n        for nv in G[v]:\n            if nv != p:\n                self.dfs(G, nv, v, d + 1)\n    \n    def query(self, u, v):\n        if self.dist[u] < self.dist[v]:\n            u, v = v, u\n        K = len(self.parent)\n        for k in range(K):\n            if (self.dist[u] - self.dist[v]) >> k & 1:\n                u = self.parent[k][u]\n        \n        if u == v:\n            return u\n        for k in range(K - 1, -1, -1):\n            if self.parent[k][u] != self.parent[k][v]:\n                u = self.parent[k][u]\n                v = self.parent[k][v]\n\n        return self.parent[0][u]\n    \n    def get_dist(self, u, v):\n        return self.dist[u] + self.dist[v] - 2 * self.dist[self.query(u, v)]\n    \n    def on_path(self, u, v, a):\n        return self.get_dist(u, a) + self.get_dist(a, v) == self.get_dist(u, v)\n\nn = ni()\nkc = nan(n)\nq = ni()\nuv = nan(q)\n\ng = [[] for _ in range(n)]\nfor i in range(n):\n    k = kc[i][0]\n    c = kc[i][1:]\n    for j in range(k):\n        g[i].append(c[j])\n\nlca = LCA(g)\nfor i in range(q):\n    u, v = uv[i]\n    print(lca.query(u, v))\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nreadline = stdin.readline\n \n \ndef main():\n    n = int(readline())\n    g = dict()\n    for i in range(n):\n        nodes = list(map(int, readline().split()))\n        g[i] = nodes[1:]\n    print(g)\n    \n    euler, height = euler_tour(g, n)\n    index = defaultdict(list)\n    for i in range(len(euler)):\n        index[euler[i]].append(i)\n    rmql = [(height[i], i) for i in euler]\n    rmq = segment_tree(rmql,min,(float('inf'),))\n \n    q = int(readline())\n    for i in range(q):\n        u, v = map(int, readline().split())\n        l, r = index[u][0], index[v][-1]\n        if l > r:\n            l, r = index[v][0], index[u][-1]\n        print(rmq.find(l, r)[1])\n \n \ndef euler_tour(g, size):\n    height = [None] * size\n    euler = []\n    root = 0\n    dfs_stack = [(root, None, 0)]\n    while dfs_stack:\n        u, prev, h = dfs_stack.pop()\n        height[u] = h\n        euler.append(prev)\n        if g[u]:\n            dfs_stack.extend((v, u, h + 1) for v in g[u])\n        else:\n            euler.append(u)\n    return euler[1:], height\n     \nimport math\nclass segment_tree:\n    def __init__(self, dat, query, default=0):\n        self.offset = 2 ** math.ceil(math.log(len(dat), 2))\n        self.table = [default] * self.offset + dat + [default] * (self.offset - len(dat))\n        self.query = query\n        for i in reversed(range(1, self.offset)):\n            self.table[i] = self.query(self.table[2 * i], self.table[2 * i + 1])\n \n    # [l, r] closed-interval\n    def find(self, l, r):\n        return self.query(self.__range(l,r))\n \n    def __range(self, l, r):\n        l += self.offset\n        r += self.offset\n        while l <= r:\n            if l & 1:\n                yield self.table[l]\n                l += 1\n            l >>= 1\n            if r & 1 == 0:\n                yield self.table[r]\n                r -= 1\n            r >>= 1\n         \n    def update(self, i, x):\n        i += self.offset\n        self.table[i] = x\n        while 1 < i:\n            i >>= 1\n            self.table[i] = self.query(self.table[2 * i], self.table[2 * i + 1])\nmain()"
  },
  {
    "language": "Python",
    "code": "#fake answer?\n\nimport math\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(200000)\n\ndef dfs(here, p, d, parent, depth, connect):\n    parent[0][here] = p\n    depth[here] = d\n    for next_v in connect[here]:\n        dfs(next_v, here, d + 1, parent, depth, connect)\n\ndef lca(v1, v2, parent, depth):\n    if depth[v2] > depth[v1]:\n        v1, v2 = v2, v1\n    for i in range(max_log):\n        if depth[v1] - depth[v2] >> i & 1:\n            v1 = parent[i][v1]\n    if v1 == v2:\n        return v2\n    for i in range(max_log - 1, -1, -1):\n        if parent[i][v1] != parent[i][v2]:\n            v1 = parent[i][v1]\n            v2 = parent[i][v2]\n    return parent[0][v1]\n\nconnect = defaultdict(list)\nv_num = int(input())\nroot = 0\nfor i in range(v_num):\n    edge = [int(n) for n in input().split(\" \")]\n    connect[i].extend(edge[1:])\ndepth = [-1 for n in range(v_num)]\nmax_log = max(int(math.log(v_num, 2)), 1)\nparent = [[-1 for n in range(v_num)] for m in range(max_log)]\ndfs(root, -1, 0, parent, depth, connect)\nfor i in range(max_log - 1):\n    for v in range(v_num):\n        parent[i + 1][v] = -1 if parent[i][v] < 0 else parent[i][parent[i][v]]\nq_num = int(input())\nfor _ in range(q_num):\n    v1, v2 = (int(n) for n in input().split(\" \") )\n    print(lca(v1, v2, parent, depth))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\nsys.setrecursionlimit(int(1e6))\n\n\ndef dfs(v, v_parent, v_depth):\n    # print(parent, v, v_parent)\n    if not parent:\n        return 0\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if (depth[v] - depth[u]) >> k & 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num))\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        # assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass Edge:\n    def __init__(self, dst, weight):\n        self.dst, self.weight = dst, weight\n\n    def __lt__(self, e):\n        return self.weight > e.weight\n\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, src, dst, weight):\n        self.E[src].append(Edge(dst, weight))\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * g.V, [-1] * g.V, [-1] * g.V, [-1] * g.V\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1, False)]\n        sub, max_sub = [1] * self.g.V, [(0, -1)] * self.g.V\n        while stack:\n            v, par, flag = stack.pop()\n            if not flag:\n                self.parent[v] = par\n                stack.append((v, par, True))\n                stack.extend((e.dst, v, False) for e in self.g.E[v] if e.dst != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for e in self.g.E[v]:\n                    if e.dst != self.parent[v] and e.dst != self.heavy[v]:\n                        que.append(e.dst)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = Graph(N)\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g.add_edge(i, c, 1)\n        g.add_edge(c, i, 1)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "class Edge:\n    def __init__(self, dst, weight):\n        self.dst, self.weight = dst, weight\n\n    def __lt__(self, e):\n        return self.weight > e.weight\n\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, src, dst, weight):\n        self.E[src].append(Edge(dst, weight))\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * g.V, [-1] * g.V, [-1] * g.V, [-1] * g.V\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1)]\n        sub, max_sub = [1] * self.g.V, [(0, -1)] * self.g.V\n        used = [False] * self.g.V\n\n        while stack:\n            v, par = stack.pop()\n            if not used[v]:\n                used[v] = True\n                self.parent[v] = par\n                stack.append((v, par))\n                stack.extend((e.dst, v) for e in self.g.E[v] if e.dst != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for e in self.g.E[v]:\n                    if e.dst != self.parent[v] and e.dst != self.heavy[v]:\n                        que.append(e.dst)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = Graph(N)\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g.add_edge(i, c, 1)\n        g.add_edge(c, i, 1)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n8\n3 1 2 3\n2 4 5\n0\n0\n0\n2 6 7\n0\n0\n4\n4 6\n4 7\n4 3\n5 2\n\noutput:\n1\n1\n0\n0\n\"\"\"\n\nimport sys\n\nsys.setrecursionlimit(int(1e5))\n\n\nclass UnionFind(object):\n    __slots__ = ('size', 'height_rank', 'ancestors')\n\n    def __init__(self, size):\n        self.size = int(size)\n        self.height_rank = [0] * self.size\n        self.ancestors = [i for i in range(self.size)]\n\n    def find(self, x):\n        if x != self.ancestors[x]:\n            self.ancestors[x] = self.find(self.ancestors[x])\n        return self.ancestors[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def __link(self, x, y):\n        if self.height_rank[x] > self.height_rank[y]:\n            self.ancestors[y] = x\n        else:\n            self.ancestors[x] = y\n            if self.height_rank[x] == self.height_rank[y]:\n                self.height_rank[y] += 1\n\n    def union(self, x, y):\n        self.__link(self.find(x), self.find(y))\n\n\ndef graph_Tarjan(current, uf, adj_table, g_ancestors, vs, queries_table):\n    for adj in adj_table[current]:\n        graph_Tarjan(adj, uf, adj_table, g_ancestors, vs, queries_table)\n        uf.union(current, adj)\n        g_ancestors[uf.find(current)] = current\n\n    vs[current] = True\n\n    for v in queries_table[current]:\n        if vs[v]:\n            print(g_ancestors[uf.find(v)])\n\n    return None\n\n\ndef cmd_exec(queries, v_num, c_edges):\n    # get adj_table\n    adj_table = tuple([] for _ in range(v_num))\n    queries_table = tuple([] for _ in range(v_num))\n    g_ancestors = [i for i in range(v_num)]\n    vs = [False] * v_num\n\n    for parent, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        assert len(children) == c_num\n        adj_table[parent].extend(children)\n\n    for query in queries:\n        q1, q2 = map(int, query)\n        queries_table[q1].append(q2)\n        queries_table[q2].append(q1)\n\n    root = 0\n    uf = UnionFind(size=v_num)\n    graph_Tarjan(root, uf, adj_table, g_ancestors, vs, queries_table)\n\n    return None\n\n\ndef solve():\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n    cmd_exec(queries=c_queries, v_num=v_num, c_edges=c_edges)\n\n    return None\n\n\nif __name__ == '__main__':\n    solve()"
  },
  {
    "language": "Python",
    "code": "from math import log2\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\ndef main():\n    N = int( input())\n    LogN = int( log2(N))+1 # log of edge number\n    E = [ list( map( int, input().split()))[1:] for i in range(N)]\n    parent = [[-1]*(LogN) for _ in range(N)]\n    start = 0\n    deq = deque([0])\n    depth = [-1]*N\n    depth[start] = 0\n    while deq: #calculate depth and calculate the parent of each vertex by 2**0 = 1\n        v = deq.popleft()\n        nextdepth = depth[v] + 1\n        for w in E[v]:\n            if depth[w] == -1:\n                depth[w] = nextdepth\n                parent[w][0] = v\n                deq.append(w)\n\n    for k in range(LogN-1):\n        for v in range(N):\n            if (parent[v][k] < 0):\n                parent[v][k+1] = -1\n            else:\n                parent[v][k+1] = parent[ parent[v][k]][k]\n\n    Q = int( input())\n    for _ in range(Q):\n        u, v = map( int, input().split())\n        if depth[u] > depth[v]:\n            u, v = v, u\n        for k in range(LogN):\n            if( (depth[v] - depth[u]) >> k & 1):\n                v = parent[v][k]\n        if u == v:\n            print(u)\n            continue\n        for k in range(LogN-1, -1, -1):\n            if parent[u][k] != parent[v][k]:\n                u = parent[u][k]\n                v = parent[v][k]\n        print(parent[u][0])\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nclass Tree:\n    def __init__(self, N):\n        self.N = N\n        self.D = (self.N-1).bit_length()\n        self.E = defaultdict(dict)\n    \n    def add_edge(self, init, end, weight, undirected=False):\n        self.E[init][end] = weight\n        if undirected: self.E[end][init] = weight\n    \n    def dfs(self, root):\n        # parents[v]: the parent of the vertex v\n        # depth[v]: the depth of the vertex v from the root\n        # dist[v]: the distance of the vertex v from the root.\n        self.parent = [None] * self.N\n        self.depth = [-1] * self.N\n        self.dist = [float('inf')] * self.N\n        self.parent[root] = -1; self.depth[root] = 0; self.dist[root] = 0;\n        stack = [root]\n        while stack:\n            v = stack.pop()\n            for u in self.E[v].keys():\n                if self.depth[u] != -1: continue\n                self.parent[u] = v\n                self.depth[u] = self.depth[v] + 1\n                self.dist[u] = self.dist[v] + self.E[v][u]\n                stack.append(u)\n    \n    def doubling(self):\n        # O(N log N) time\n        self.next = [self.parent]\n        for d in range(1, self.D):\n            self.next.append([self.next[d-1][self.next[d-1][v]] if self.next[d-1][v] != -1 else -1 for v in range(self.N)])\n    \n    def lca(self, u, v):\n        # O(log N) time\n        # the depth of v is set to be no less than that of u\n        if self.depth[u] > self.depth[v]: u, v = v, u\n        # find the ancestor of v with the same depth as that of u\n        diff = self.depth[v] - self.depth[u]\n        for i in range(diff.bit_length()):\n            if diff & 1: v = self.next[i][v]\n            diff >>= 1\n        if u == v: return u\n        for i in range(self.D-1, -1, -1):\n            pu, pv = self.next[i][u], self.next[i][v]\n            if pu != pv: u, v = pu, pv\n        return self.next[0][u]\n\nn = int(input())\ntr = Tree(n)\nfor i in range(n):\n    k, *C, = map(int, input().split())\n    for c in C:\n        tr.add_edge(i, c, 1, undirected=True)\ntr.dfs(0)\ntr.doubling()\nq = int(input())\nfor _ in range(q):\n    u, v = map(int, input().split())\n    print(tr.lca(u, v))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nclass LCA:\n  def __init__(self,n,s,edge):\n    self.logn=n.bit_length()\n    self.parent=[n*[-1]for _ in range(self.logn)]\n    self.dist=[0]*n\n    stack=[s]\n    visited={s}\n    for i in stack:\n      for j in edge[i]:\n        if j in visited:continue\n        stack.append(j)\n        visited.add(j)\n        self.parent[0][j]=i\n        self.dist[j]=self.dist[i]+1\n        for k in range(1,self.logn):self.parent[k][j]=self.parent[k-1][self.parent[k-1][j]]\n  def query(self,a,b):\n    if self.dist[a]<self.dist[b]:a,b=b,a\n    if self.dist[a]>self.dist[b]:\n      for i in range(self.logn):\n        if (self.dist[a]-self.dist[b])&(1<<i):a=self.parent[i][a]\n    if a==b:return a\n    for i in range(self.logn-1,-1,-1):\n      if self.parent[i][a]!=self.parent[i][b]:\n        a=self.parent[i][a]\n        b=self.parent[i][b]\n    return self.parent[0][a]\n  def path_range(self,a,b):return self.dist[a]+self.dist[b]-2*self.dist[self.query(a,b)]\n  def x_in_abpath(self,x,a,b):return self.path_range(a,x)+self.path_range(b,x)==self.path_range(a,b)\nn=int(input())\nedge=[[]for _ in range(n)]\nfor i in range(n):\n  k=list(map(int,input().split()))\n  for j in range(k[0]):edge[i].append(k[j+1])\nlca=LCA(n,0,edge)\nq=int(input())\nfor u,v in [list(map(int,input().split()))for _ in range(q)]:\n  print(lca.query(u,v))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom math import log\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef dfs(v,p,d):\n    parent[0][v]=p\n    depth[v]=d\n    for i in xrange(len(G[v])):\n        if G[v][i]!=p:\n            dfs(G[v][i],v,d+1)\n\ndef init(vn,root):\n    dfs(root,-1,0)\n    k=0\n    while k+1<log(vn,2):\n        for v in xrange(vn):\n            if parent[k][v]<0:\n                parent[k+1][v]=-1\n            else:\n                parent[k+1][v]=parent[k][parent[k][v]]\n        k+=1\n\ndef lca(u,v,vn):\n    if depth[u]>depth[v]:u,v=v,u\n    k=0\n    while k<log(vn,2):\n        if (depth[v]-depth[u])>>k&1:\n            v=parent[k][v]\n        k+=1\n    if u==v:return u\n    for k in xrange(int(log(vn,2))-1,-1,-1):\n        if parent[k][u]!=parent[k][v]:\n            u=parent[k][u]\n            v=parent[k][v]\n    return parent[0][u]\n\n\nvn=int(raw_input())        #????????°\nG=[[] for _ in xrange(vn)] #??£??\\?????????\nparent=[[-1]*vn for _ in xrange(int(log(vn,2))+1)] #parent[k][u]:??????u??????2^k????????????????????£?????¨????????????\ndepth=[0]*vn               #depth[u]:??????u?????????????????±??????????????±??????0\nroot=0                     #??????????????????\n\nfor i in xrange(vn):\n    en=map(int,raw_input().split())\n    c=en[1:]          #????????????i??????\n    G[i]=c\n\ninit(vn,root)\n\nq=int(raw_input())\nfor _ in xrange(q):\n    u,v=map(int,raw_input().split())\n    print(lca(u,v,vn))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef dfs(v, v_parent, v_depth):\n    # print(parent, v, v_parent)\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if ((depth[v] - depth[u]) >> k) & 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    # with open('test.txt', 'r') as f:\n    # _input = f.readlines()\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num)) + 1\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0.0 0.0\n2.0 0.0\n1.0 1.0\n\noutput:\n1.41421356237\n\"\"\"\n\nimport sys\nfrom operator import attrgetter\n\n\nclass ClosestPair(object):\n    def __init__(self, in_data):\n        \"\"\"\n        Init closest pairs points set.\n        \"\"\"\n        self.p_num = int(in_data[0])\n        points = map(lambda x: x.split(), in_data[1:])\n        p_list = [complex(float(x), float(y)) for x, y in points]\n        # pre_sort by axis_X\n        self.p_list = sorted(p_list, key=attrgetter('real'))\n\n    def closest_pair(self, array, array_length):\n        if array_length <= 1:\n            return float('inf')\n        mid_idx = array_length // 2\n        div_line = array[mid_idx].real\n        d_min = min(self.closest_pair(array[:mid_idx], mid_idx),\n                    self.closest_pair(array[mid_idx:], array_length - mid_idx))\n\n        # sort array_part by axis_Y while recursively comparing\n        array.sort(key=attrgetter('imag'))\n\n        min_stack = list()\n        for ele in array:\n            size = len(min_stack)\n\n            # eliminate p which distance(p,div_line) >= d\n            if abs(ele.real - div_line) >= d_min:\n                continue\n\n            for j in range(size):\n                alt = ele - min_stack[size - j - 1]\n                if alt.imag >= d_min:\n                    break\n                d_min = min(d_min, abs(alt))\n\n            min_stack.append(ele)\n\n        return d_min\n\n    def solve(self):\n        return self.closest_pair(array=self.p_list, array_length=self.p_num)\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    case = ClosestPair(in_data=_input)\n    print('{:.6f}'.format(case.solve()))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef dfs(v, v_parent, v_depth):\n    # print(parent, v, v_parent)\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if ((depth[v] - depth[u]) >> k) & 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    # with open('test.txt', 'r') as f:\n        # _input = f.readlines()\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num))\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\n\n\nclass Edge:\n    def __init__(self, dst, weight):\n        self.dst, self.weight = dst, weight\n\n    def __lt__(self, e):\n        return self.weight > e.weight\n\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, src, dst, weight):\n        self.E[src].append(Edge(dst, weight))\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid = [0] * g.V\n        self.head = [-1] * g.V\n        self.heavy = [-1] * g.V\n        self.parent = [-1] * g.V\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, v, par=-1):\n        self.parent[v] = par\n        sub, max_sub = 1, 0\n        for e in self.g.E[v]:\n            child = e.dst\n            if child != par:\n                child_sub = self.dfs(child, v)\n                sub += child_sub\n                if child_sub > max_sub:\n                    max_sub = child_sub\n                    self.heavy[v] = child\n        return sub\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for e in self.g.E[v]:\n                    if e.dst != self.parent[v] and e.dst != self.heavy[v]:\n                        que.append(e.dst)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = Graph(N)\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g.add_edge(i, c, 1)\n        g.add_edge(c, i, 1)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nreadline = stdin.readline\n \n \ndef main():\n    n = int(readline())\n    g = dict()\n    for i in range(n):\n        nodes = list(map(int, readline().split()))\n        g[i] = nodes[1:]\n    \n    euler, height = euler_tour(g, n)\n    index = defaultdict(list)\n    for i in range(len(euler)):\n        index[euler[i]].append(i)\n    rmql = [(height[i], i) for i in euler]\n    rmq = segment_tree(rmql,min,(float('inf'),))\n \n    q = int(readline())\n    for i in range(q):\n        u, v = map(int, readline().split())\n        l, r = index[u][0], index[v][-1]\n        if l > r:\n            l, r = index[v][0], index[u][-1]\n        print(rmq.find(l, r)[1])\n \n \ndef euler_tour(g, size):\n    height = [None] * size\n    euler = []\n    root = 0\n    dfs_stack = [(root, None, 0)]\n    while dfs_stack:\n        u, prev, h = dfs_stack.pop()\n        height[u] = h\n        euler.append(prev)\n        if g[u]:\n            dfs_stack.extend((v, u, h + 1) for v in g[u])\n        else:\n            euler.append(u)\n    return euler[1:], height\n     \nimport math\nclass segment_tree:\n    def __init__(self, dat, query, default=0):\n        self.offset = 2 ** math.ceil(math.log(len(dat), 2))\n        self.table = [default] * self.offset + dat + [default] * (self.offset - len(dat))\n        self.query = query\n        for i in reversed(range(1, self.offset)):\n            self.table[i] = self.query(self.table[2 * i], self.table[2 * i + 1])\n \n    # [l, r] closed-interval\n    def find(self, l, r):\n        return self.query(self.__range(l,r))\n \n    def __range(self, l, r):\n        l += self.offset\n        r += self.offset\n        while l <= r:\n            if l & 1:\n                yield self.table[l]\n                l += 1\n            l >>= 1\n            if r & 1 == 0:\n                yield self.table[r]\n                r -= 1\n            r >>= 1\n         \n    def update(self, i, x):\n        i += self.offset\n        self.table[i] = x\n        while 1 < i:\n            i >>= 1\n            self.table[i] = self.query(self.table[2 * i], self.table[2 * i + 1])\nmain()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\n\ndef dfs(v, v_parent, v_depth):\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if (depth[v] - depth[u]) >> k & 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num))\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        # assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\ninput:\n16\n3 1 2 3\n3 4 5 6\n0\n2 7 8\n0\n2 9 10\n2 14 15\n0\n0\n0\n3 11 12 13\n0\n0\n0\n0\n0\n10\n1 3\n4 5\n4 9\n4 10\n4 13\n9 13\n9 14\n9 8\n13 14\n13 7\n\noutput:\n0\n1\n1\n1\n1\n5\n1\n0\n1\n0\n\"\"\"\n\nimport sys\nimport math\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef dfs(v, v_parent, v_depth):\n    # print(parent, v, v_parent)\n    if not parent:\n        return 0\n    parent[0][v] = v_parent\n    depth[v] = v_depth\n    for adj in adj_table[v]:\n        if adj != v_parent:\n            dfs(adj, v, v_depth + 1)\n\n    return None\n\n\ndef dfs_init():\n    dfs(root, -1, 0)\n    for k in range(v_log - 1):\n        for v in range(v_num):\n            if parent[k][v] < 0:\n                parent[k + 1][v] = -1\n            else:\n                parent[k + 1][v] = parent[k][parent[k][v]]\n\n    return None\n\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    for k in range(v_log):\n        if (depth[v] - depth[u]) >> k & 1:\n            v = parent[k][v]\n\n    if u == v:\n        return u\n\n    for k in range(v_log - 1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n\n    return parent[0][u]\n\n\ndef cmd_exec():\n    for query in c_queries:\n        q1, q2 = map(int, query)\n        print(lca(q1, q2))\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num = int(_input[0])\n    c_edges = map(lambda x: x.split(), _input[1:v_num + 1])\n    q_num = int(_input[v_num + 1])\n    c_queries = map(lambda x: x.split(), _input[v_num + 2:])\n\n    v_log = math.floor(math.log2(v_num))\n    parent = [[-1] * v_num for _ in range(v_log)]\n    depth = [-1] * v_num\n    root = 0\n\n    adj_table = tuple([] for _ in range(v_num))\n    for idx, edge in enumerate(c_edges):\n        c_num, *children = map(int, edge)\n        # assert len(children) == c_num\n        adj_table[idx].extend(children)\n\n    dfs_init()\n    cmd_exec()"
  },
  {
    "language": "Python",
    "code": "from math import log2\nimport time\nimport sys\n\nMOD = 10 ** 9 + 7\n\ndef lca(u, v):\n    if level[u] < level[v]: u, v = v, u\n\n    up = int(log2(level[u]))\n    while up >= 0:\n    \tif level[u] - (1 << up) >= level[v]:\n    \t\tu = par[u][up]\n    \tup -= 1\n\n    if u == v: return v\n\n    up = int(log2(level[u]))\n    while up >= 0:\n    \tif par[u][up] and par[v][up] != par[u][up]:\n    \t\tu, v = par[u][up], par[v][up]\n    \tup -= 1\n\n    return par[u][0]\n\nn = int(input())\n\nadj = {}\nu = 0\nfor _ in range(n):\n    c, *v_list = [int(item) for item in sys.stdin.readline().strip().split()]\n    adj[u] = []\n    for v in v_list:\n        adj[u].append(v)\n    u += 1\n\nstart = 0\n\nQ = [start]\ndone = [0] * (n + 1)\npar = [[0] * (int(log2(n)) + 1) for _ in range(n + 1)]\nlevel = [0] * (n + 1)\nlevel[start] = 1\n\nwhile Q:\n    current = Q.pop()\n    for nxt in adj[current]:\n        if done[nxt]: continue\n        done[current] = 1\n        level[nxt] = level[current] + 1\n        par[nxt][0] = current\n        Q.append(nxt)\n\nlvl = 1\nwhile (1 << lvl) < n:\n\tfor i in range(0, n):\n\t\tif par[i][lvl - 1]: par[i][lvl] = par[par[i][lvl - 1]][lvl - 1]\n\tlvl += 1\n\nq = int(input())\nfor _ in range(q):\n\tu, v = [int(item) for item in sys.stdin.readline().strip().split()]\n\t_lca = lca(u, v)\n\tprint(_lca)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs():\n    depth[0] = 0\n    queue = deque([])\n    queue.append(0)\n    \n    while queue:\n        current_node = queue.popleft()\n        \n        for next_node in adj_list[current_node]:\n            if depth[next_node] == -1:\n                parent[0][next_node] = current_node\n                depth[next_node] = depth[current_node] + 1\n                queue.append(next_node)\n    \ndef init():\n    bfs() #initialize depth and parent[0]\n    \n    for k in range(1, log_size):\n        for v in range(N):\n            if parent[k-1][v] < 0:\n                parent[k][v] = -1\n            else:\n                parent[k][v] = parent[k-1][parent[k-1][v]]\n\ndef lca(u, v): #return lowest common ancestor when 0 is root node\n    if depth[u] > depth[v]:\n        u, v = v, u\n    \n    for k in range(log_size):\n        if (depth[v]-depth[u])>>k & 1:\n            v = parent[k][v]\n    \n    if u == v:\n        return u\n    \n    for k in range(log_size-1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            u = parent[k][u]\n            v = parent[k][v]\n    \n    return parent[0][u]\n    \nN = int(input())\nlog_size = N.bit_length() #ceil(log)\ndepth = [-1] * N\nparent = [[-1] * N for _ in range(log_size)]\nadj_list = [[] for _ in range(N)]\n\nfor i in range(N):\n    kc = list(map(int, input().split()))\n    \n    for ci in kc[1:]:\n        adj_list[i].append(ci)\n        adj_list[ci].append(i)\n\ninit()\nq = int(input())\n\nfor _ in range(q):\n    ui, vi = map(int, input().split())\n    print(lca(ui, vi))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.nodes = [i for i in range(n)]\n        self.sizes = [1 for _ in range(n)]\n\n    def union(self, p, q):\n        rp = self.root(p)\n        rq = self.root(q)\n        if self.sizes[rp] > self.sizes[rq]:\n            self.nodes[rq] = rp\n            self.sizes[rp] += self.sizes[rq]\n        else:\n            self.nodes[rp] = rq\n            self.sizes[rq] += self.sizes[rp]\n\n    def connected(self, p, q):\n        return self.root(p) == self.root(q)\n\n    def root(self, p):\n        while p != self.nodes[p]:\n            self.nodes[p] = self.nodes[self.nodes[p]]\n            p = self.nodes[p]\n\n        return p\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass WeightedEdge(Edge):\n    __slots__ = ('v', 'w', 'weight')\n\n    def __init__(self, v, w, weight):\n        super().__init__(v, w)\n        self.weight = weight\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\ndef lca(graph, root, queries):\n    index = [[] for _ in range(graph.v)]\n    for v, w in queries:\n        index[v].append((v, w))\n        index[w].append((v, w))\n\n    visited = [False] * graph.v\n    parents = [None] * graph.v\n    uf = UnionFind(graph.v)\n    res = {}\n    stack = [root]\n    while stack:\n        v = stack.pop()\n        if not visited[v]:\n            visited[v] = True\n            stack.append(v)\n            for e in graph.adj(v):\n                w = e.other(v)\n                if not visited[w]:\n                    stack.append(w)\n                    parents[w] = v\n        else:\n            p = parents[v]\n            rest = []\n            for i, j in index[v]:\n                if uf.connected(i, j) and (i, j) not in res:\n                    res[(i, j)] = v\n                else:\n                    rest.append((i, j))\n            index[v] = None\n            if p is not None:\n                uf.union(p, v)\n                index[p].extend(rest)\n            print(p, v, len(res), len(rest))\n\n    return res\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    q = int(input())\n    qs = []\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        qs.append((v, w))\n\n    res = lca(g, 0, qs)\n    for v, w in qs:\n        print(res[(v, w)])\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# 参考　https://tjkendev.github.io/procon-library/python/graph/lca-segment-tree.html\n\n# N: 頂点数\n# G[v]: 頂点vの子頂点 (親頂点は含まない)\n\nimport sys\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nG = [[] for _ in range(N)]\nfor v in range(N):\n    for j, nv in enumerate(map(int, input().split())):\n        if j == 0:\n            continue\n        G[v].append(nv)  \n\n# Euler Tour の構築\nS = []\nF = [0]*N\ndepth = [0]*N\ndef dfs(v, d):\n    F[v] = len(S)\n    depth[v] = d\n    S.append(v)\n    for w in G[v]:\n        dfs(w, d+1)\n        S.append(v)\ndfs(0, 0)\n\n# 存在しない範囲は深さが他よりも大きくなるようにする\nINF = (N, None)\n\n# LCAを計算するクエリの前計算\nM = 2*N\nM0 = 2**(M-1).bit_length()\ndata = [INF]*(2*M0)\nfor i, v in enumerate(S):\n    data[M0-1+i] = (depth[v], i)\nfor i in range(M0-2, -1, -1):\n    data[i] = min(data[2*i+1], data[2*i+2])\n\n# LCAの計算 (generatorで最小値を求める)\ndef _query(a, b):\n    yield INF\n    a += M0; b += M0\n    while a < b:\n        if b & 1:\n            b -= 1\n            yield data[b-1]\n        if a & 1:\n            yield data[a-1]\n            a += 1\n        a >>= 1; b >>= 1\n\n# LCAの計算 (外から呼び出す関数)\ndef query(u, v):\n    fu = F[u]; fv = F[v]\n    if fu > fv:\n        fu, fv = fv, fu\n    return S[min(_query(fu, fv + 1))[1]]\n\nans_list = []\n\nq = int(input())\nfor _ in range(q):\n    u, v = map(int, input().split())\n    ans = query(u, v)\n    ans_list.append(ans)\n\nprint(*ans_list, sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "from math import log2\n\n\ndef build():\n    global parent\n    dfs()\n    pk0 = parent[0]\n    for pk1 in parent[1:]:\n        for v in range(n):\n            pkv = pk0[v]\n            pk1[v] = -1 if pkv < 0 else pk0[pkv]\n        pk0 = pk1\n\n\ndef dfs():\n    global depth, parent, tree\n    stack = [(0, -1, 0)]\n    while stack:\n        v, p, d = stack.pop()\n        parent[0][v] = p\n        depth[v] = d\n        stack.extend((child, v, d + 1) for child in tree[v])\n\n\ndef lca(u: int, v: int) -> int:\n    global depth, parent\n    du, dv = depth[u], depth[v]\n    if du > dv:\n        u, v = v, u\n        du, dv = dv, du\n    for k, pk in enumerate(parent):\n        if (dv - du) >> k & 1:\n            v = pk[v]\n    if u == v:\n        return u\n    for pk in parent[logn - 1:None:-1]:\n        pku, pkv = pk[u], pk[v]\n        if pku != pkv:\n            u, v = pku, pkv\n    return parent[0][u]\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    tree = []\n    for _ in range(n):\n        _, *children = map(lambda x: int(x), input().split())\n        tree.append(set(children))\n\n    logn = int(log2(n)) + 1\n    parent = [[0] * n for _ in range(logn)]\n    depth = [0] * n\n    build()\n\n    q = int(input())\n    for _ in range(q):\n        u, v = map(lambda x: int(x), input().split())\n        print(lca(u, v))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nn = input()\n\nC = [None]*n\nP = [None]*n\nfor i in xrange(n):\n    ipt = map(int, raw_input().split())\n    C[i] = ipt[1:]\n    for c in C[i]:\n        P[c] = i\nLEV = (n+1).bit_length()\nparent = [[None]*(LEV + 1) for i in xrange(n)]\nfor i in xrange(n):\n    parent[i][0] = P[i]\nfor k in xrange(1, LEV):\n    for i in xrange(n):\n        if parent[i][k] is None:\n            parent[i][k+1] = None\n        else:\n            parent[i][k+1] = parent[parent[i][k]][k]\ndepth = [None]*n\ndeq = deque()\ndeq.append(0)\ndepth[0] = 0\nwhile deq:\n    v = deq.popleft()\n    for c in C[v]:\n        deq.append(c)\n        depth[c] = depth[v] + 1\n\nq = input()\nfor t in xrange(q):\n    u, v = map(int, raw_input().split())\n    if not depth[u] < depth[v]:\n        u, v = v, u\n    for k in xrange(LEV+1):\n        if ((depth[v] - depth[u]) >> k) & 1:\n            v = parent[v][k]\n    if u == v:\n        print u\n        continue\n\n    for k in xrange(LEV, -1, -1):\n        if parent[u][k] != parent[v][k]:\n            u = parent[u][k]\n            v = parent[v][k]\n    print parent[u][0]"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(200000)\n\ndef dfs(here, p, d, parent, depth, connect):\n    parent[0][here] = p\n    depth[here] = d\n    for next_v in connect[here]:\n        dfs(next_v, here, d + 1, parent, depth, connect)\n\ndef lca(v1, v2, parent, depth):\n    if depth[v2] > depth[v1]:\n        v1, v2 = v2, v1\n    for i in range(max_log):\n        if depth[v1] - depth[v2] >> i & 1:\n            v1 = parent[i][v1]\n    if v1 == v2:\n        return v2\n    for i in range(max_log - 1, -1, -1):\n        if parent[i][v1] != parent[i][v2]:\n            v1 = parent[i][v1]\n            v2 = parent[i][v2]\n    return parent[0][v1]\n\nconnect = defaultdict(list)\nv_num = int(input())\nroot = 0\nfor i in range(v_num):\n    edge = [int(n) for n in input().split(\" \")]\n    connect[i].extend(edge[1:])\ndepth = [-1 for n in range(v_num)]\nmax_log = max(int(math.log(v_num, 2)), 1)\nparent = [[-1 for n in range(v_num)] for m in range(max_log)]\ndfs(root, -1, 0, parent, depth, connect)\nfor i in range(max_log - 1):\n    for v in range(v_num):\n        parent[i + 1][v] = -1 if parent[i][v] < 0 else parent[i][parent[i][v]]\nq_num = int(input())\nfor _ in range(q_num):\n    v1, v2 = (int(n) for n in input().split(\" \") )\n    print(lca(v1, v2, parent, depth))"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * len(g), [-1] * len(g), [-1] * len(g), [-1] * len(g)\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1, False)]\n        sub, max_sub = [1] * len(self.g), [(0, -1)] * len(self.g)\n        while stack:\n            v, par, flag = stack.pop()\n            if not flag:\n                self.parent[v] = par\n                stack.append((v, par, True))\n                stack.extend((c, v, False) for c in self.g[v] if c != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for c in self.g[v]:\n                    if c != self.parent[v] and c != self.heavy[v]:\n                        que.append(c)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = [[] for _ in range(N)]\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g[i].append(c)\n        g[c].append(i)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nreadline = stdin.readline\n\n\ndef main():\n    n = int(readline())\n    g = dict()\n    for i in range(n):\n        g[i] = list(map(int, readline()[1:].split()))\n    euler, height = euler_tour(g, n)\n    index = defaultdict(list)\n    for i in range(len(euler)):\n        index[euler[i]].append(i)\n    rmql = [(height[i], i) for i in euler]\n    rmq = segment_tree(rmql,min,(float('inf'),))\n\n    q = int(readline())\n    for i in range(q):\n        u, v = map(int, readline().split())\n        l, r = index[u][0], index[v][-1]\n        if l > r:\n            l, r = index[v][0], index[u][-1]\n        print(rmq.find(l, r)[1])\n\n\ndef euler_tour(g, size):\n    height = [None] * size\n    euler = []\n    root = 0\n    dfs_stack = [(root, None, 0)]\n    while dfs_stack:\n        u, prev, h = dfs_stack.pop()\n        height[u] = h\n        euler.append(prev)\n        if g[u]:\n            dfs_stack.extend((v, u, h + 1) for v in g[u])\n        else:\n            euler.append(u)\n    return euler[1:], height\n    \nimport math\nclass segment_tree:\n    def __init__(self, dat, query, default=0):\n        self.offset = 2 ** math.ceil(math.log(len(dat), 2))\n        self.table = [default] * self.offset + dat + [default] * (self.offset - len(dat))\n        self.query = query\n        for i in reversed(range(1, self.offset)):\n            self.table[i] = self.query(self.table[2 * i], self.table[2 * i + 1])\n\n    # [l, r] closed-interval\n    def find(self, l, r):\n        return self.query(self.__range(l,r))\n\n    def __range(self, l, r):\n        l += self.offset\n        r += self.offset\n        while l <= r:\n            if l & 1:\n                yield self.table[l]\n                l += 1\n            l >>= 1\n            if r & 1 == 0:\n                yield self.table[r]\n                r -= 1\n            r >>= 1\n        \n    def update(self, i, x):\n        i += self.offset\n        self.table[i] = x\n        while 1 < i:\n            i >>= 1\n            self.table[i] = self.query(self.table[2 * i], self.table[2 * i + 1])\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000000)\ndy = (-1,0,1,0)\ndx = (0,1,0,-1)\n\nclass LCA():\n\n    def __init__(self,G,root = 0): #O(NlogN)\n        self.n = len(G)\n        self.G = G\n        self.root = root\n        self.K = 1 #2 ** K > nとなる最小のK\n        while (1<<self.K) <= self.n:\n            self.K += 1\n        self.parents = [[-1] * self.n for _ in range(self.K)]\n        self.dist = [0] * self.n\n        \n        self._dfs(root,0,-1)\n        for k in range(self.K - 1):\n            for v in range(self.n):\n                if self.parents[k][v] >= 0:\n                    self.parents[k + 1][v] = self.parents[k][self.parents[k][v]]\n    \n    def _dfs(self,i,d,p):\n        self.parents[0][i] = p\n        self.dist[i] = d\n        for e in self.G[i]:\n            if e != p:\n                self._dfs(e,d + 1,i)\n    \n    def qry(self,u,v): #O(logN)\n        if self.dist[u] < self.dist[v]:\n            u,v = v,u\n        \n        dif = self.dist[u] - self.dist[v]\n        for k in range(self.K):\n            if dif >> k & 1:\n                u = self.parents[k][u]\n        \n        if u == v:\n            return u\n        \n        for k in range(self.K - 1,-1,-1):\n            if self.parents[k][u] != self.parents[k][v]:\n                u = self.parents[k][u]\n                v = self.parents[k][v]\n        \n        return self.parents[0][u]\n\ndef main():\n    n = int(input())\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        a = list(map(int,input().split()))\n        k = a[0]\n        for e in a[1:]:\n            G[e].append(i)\n            G[i].append(e)\n\n    lca = LCA(G)\n    q = int(input())\n    for _ in range(q):\n        u,v = map(int,input().split())\n        print(lca.qry(u,v))\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0.0 0.0\n2.0 0.0\n1.0 1.0\n\noutput:\n1.41421356237\n\"\"\"\n\nimport sys\nfrom operator import attrgetter\n\n\nclass ClosestPair(object):\n    def __init__(self, in_data):\n        \"\"\"\n        Init closest pairs points set.\n        \"\"\"\n        self.p_num = int(in_data[0])\n        points = map(lambda x: x.split(), in_data[1:])\n        p_list = [complex(float(x), float(y)) for x, y in points]\n        # pre_sort by axis_X\n        p_list.sort(key=attrgetter('real'))\n        self.p_list = p_list\n\n    def closest_pair(self, array, array_length):\n        if array_length <= 1:\n            return float('inf')\n        mid_idx = array_length // 2\n        div_line = array[mid_idx].real\n        d_min = min(self.closest_pair(array[:mid_idx], mid_idx),\n                    self.closest_pair(array[mid_idx:], array_length - mid_idx))\n\n        # sort array_part by axis_Y while recursively comparing\n        array.sort(key=attrgetter('imag'))\n\n        min_stack = list()\n        for ele in array:\n            size = len(min_stack)\n\n            # eliminate p which distance(p,div_line) >= d\n            if abs(ele.real - div_line) >= d_min:\n                continue\n\n            for j in range(size):\n                alt = ele - min_stack[size - j - 1]\n                if alt.imag >= d_min:\n                    break\n                d_min = min(d_min, abs(alt))\n\n            min_stack.append(ele)\n\n        return d_min\n\n    def solve(self):\n        return self.closest_pair(array=self.p_list, array_length=self.p_num)\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    case = ClosestPair(in_data=_input)\n    print('{:.6f}'.format(case.solve()))"
  },
  {
    "language": "Python",
    "code": "from math import log2\n\nclass LCA:\n    N = 0\n    depth = []\n    table = []\n    \n    def init(N, par):\n        LCA.N = N\n        LCA.depth = [-1] * (N+1)\n        max_depth = 0\n        \n        # set depth\n        for i in range(1, N+1):\n            if LCA.depth[i] != -1: continue\n        \n            q = []\n            v = i\n            \n            while True:\n                q.append(v)\n                if v == par[v]:\n                    d = 1\n                    break\n                if LCA.depth[v] != -1:\n                    d = LCA.depth[v]\n                    break\n                v = par[v]\n                \n            for v in q[::-1]:\n                LCA.depth[v] = d\n                d += 1\n            max_depth = max(max_depth, d)\n                \n        t_size = int(log2(max_depth))+1\n        LCA.table = [[i for i in range(N+1)] for j in range(t_size)]\n        \n        for i in range(N+1):\n            LCA.table[0][i] = par[i]\n        \n        for i in range(1, t_size):\n            for j in range(1, N+1):\n                LCA.table[i][j] = LCA.table[i-1][LCA.table[i-1][j]]\n                \n    def move(v, m):\n        # v の m代の祖先\n        i = 0\n        while m:\n            if m % 2: v = LCA.table[i][v]\n            i += 1\n            m //= 2\n        return v\n    \n    def same(v, u):\n        # v　と uのLCA\n        v_d = LCA.depth[v]\n        u_d = LCA.depth[u]\n        \n        if v_d > u_d:\n            v, u = u, v\n            v_d, u_d = u_d, v_d\n            \n        diff = u_d - v_d\n        \n        u = LCA.move(u, diff)\n        \n        if v == u: return v\n        \n        l, r = 1, v_d\n        \n        while l < r:\n            mid = (l+r) // 2\n            \n            v_p = LCA.move(v, mid)\n            u_p = LCA.move(u, mid)\n            \n            if v_p == u_p: r = mid\n            else: l = mid+1\n        \n        return LCA.move(v, l)\n    \n    def same2(v, u):\n        # v の祖先に u がいるか\n        if v == u: return True\n        \n        v_d = LCA.depth[v]\n        u_d = LCA.depth[u]\n        \n        if v_d <= u_d: return False\n        \n        if LCA.move(v, v_d-u_d) == u: return True\n        else: return False\n\nN = int(input())\npar = [i for i in range(N+1)]\n\nfor i in range(N):\n    c = list(map(int, input().split()))\n\n    for j in c[1:]:\n        par[j] = i\n\nLCA.init(N, par)\n\nfor i in range(int(input())):\n    a, b = list(map(int, input().split()))\n    print(LCA.same(a, b))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * len(g), [-1] * len(g), [-1] * len(g), [-1] * len(g)\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1)]\n        sub, max_sub = [1] * len(self.g), [(0, -1)] * len(self.g)\n        used = [False] * len(self.g)\n        while stack:\n            v, par = stack.pop()\n            if not used[v]:\n                self.parent[v] = par\n                used[v] = True\n                stack.append((v, par))\n                stack.extend((c, v) for c in self.g[v] if c != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    if sub[v] > max_sub[par][0]:\n                        max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for c in self.g[v]:\n                    if c != self.parent[v] and c != self.heavy[v]:\n                        que.append(c)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = [[] for _ in range(N)]\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g[i].append(c)\n        g[c].append(i)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "import operator\nimport os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = int(sys.stdin.readline())\ngraph = [[] for _ in range(N)]\nfor i in range(N):\n    _, *c = list(map(int, sys.stdin.readline().split()))\n    graph[i] = c\nQ = int(sys.stdin.readline())\nUV = [list(map(int, sys.stdin.readline().split())) for _ in range(Q)]\n\n\nclass SegmentTree:\n    # http://tsutaj.hatenablog.com/entry/2017/03/29/204841\n    def __init__(self, size, fn=operator.add, default=None, initial_values=None):\n        \"\"\"\n        :param int size:\n        :param callable fn: 区間に適用する関数。引数を 2 つ取る。min, max, operator.xor など\n        :param default:\n        :param list initial_values:\n        \"\"\"\n        default = default or 0\n\n        # size 以上である最小の 2 冪\n        n = 1\n        while n < size:\n            n *= 2\n        self._size = n\n        self._fn = fn\n\n        self._tree = [default] * (self._size * 2 - 1)\n        if initial_values:\n            i = self._size - 1\n            for v in initial_values:\n                self._tree[i] = v\n                i += 1\n            i = self._size - 2\n            while i >= 0:\n                self._tree[i] = self._fn(self._tree[i * 2 + 1], self._tree[i * 2 + 2])\n                i -= 1\n\n    def set(self, i, value):\n        \"\"\"\n        i 番目に value を設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self._tree[x] = value\n\n        while x > 0:\n            x = (x - 1) // 2\n            self._tree[x] = self._fn(self._tree[x * 2 + 1], self._tree[x * 2 + 2])\n\n    def add(self, i, value):\n        \"\"\"\n        もとの i 番目と value に fn を適用したものを i 番目に設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self.set(i, self._fn(self._tree[x], value))\n\n    def get(self, from_i, to_i, k=0, L=None, r=None):\n        \"\"\"\n        [from_i, to_i) に fn を適用した結果を返す\n        :param int from_i:\n        :param int to_i:\n        :param int k: self._tree[k] が、[L, r) に fn を適用した結果を持つ\n        :param int L:\n        :param int r:\n        :return:\n        \"\"\"\n        L = 0 if L is None else L\n        r = self._size if r is None else r\n\n        if from_i <= L and r <= to_i:\n            return self._tree[k]\n\n        if to_i <= L or r <= from_i:\n            return None\n\n        ret_L = self.get(from_i, to_i, k * 2 + 1, L, (L + r) // 2)\n        ret_r = self.get(from_i, to_i, k * 2 + 2, (L + r) // 2, r)\n        if ret_L is None:\n            return ret_r\n        if ret_r is None:\n            return ret_L\n        return self._fn(ret_L, ret_r)\n\n    def __len__(self):\n        return self._size\n\n\ndef tree_eulerian_trail(graph, root=0):\n    \"\"\"\n    木のオイラー路; オイラーツアー\n    :param list of (list of int) graph:\n    :param int root:\n    :return: (trails, depths)\n    :rtype: (list of int, list of int)\n    \"\"\"\n    # 頂点の履歴\n    trails = []\n    # 深さの履歴\n    depths = []\n    # Overflow 回避のためループで\n    stack = [(root, 0, True)]\n    while stack:\n        v, d, forward = stack.pop()\n        trails.append(v)\n        depths.append(d)\n        if not forward:\n            continue\n        for u in graph[v]:\n            stack.append((v, d, False))\n            stack.append((u, d + 1, True))\n    return trails, depths\n\n\ntrails, depths = tree_eulerian_trail(graph, 0)\n# ids[v]: trails が v となる trails / depths のインデックス\nids = [0] * N\nfor i, v in enumerate(trails):\n    ids[v] = i\n\n# depths[v] から depths[u] までの最小値が LCA\nst = SegmentTree(size=len(depths), fn=min, default=(IINF, -1), initial_values=list(zip(depths, trails)))\n\n# RmQ\nfor u, v in UV:\n    iu, iv = ids[u], ids[v]\n    if iu > iv:\n        iu, iv = iv, iu\n    _, lca = st.get(iu, iv + 1)\n    print(lca)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nn = input()\n\nC = [None]*n\nP = [None]*n\nfor i in xrange(n):\n    ipt = map(int, raw_input().split())\n    C[i] = ipt[1:]\n    for c in C[i]:\n        P[c] = i\nLEV = (n+1).bit_length()\nparent = [[None]*(LEV + 1) for i in xrange(n)]\nfor i in xrange(n):\n    parent[i][0] = P[i]\nfor k in xrange(LEV):\n    for i in xrange(n):\n        if parent[i][k] is None:\n            parent[i][k+1] = None\n        else:\n            parent[i][k+1] = parent[parent[i][k]][k]\ndepth = [None]*n\ndeq = deque()\ndeq.append(0)\ndepth[0] = 0\nwhile deq:\n    v = deq.popleft()\n    for c in C[v]:\n        deq.append(c)\n        depth[c] = depth[v] + 1\n\nq = input()\nfor t in xrange(q):\n    u, v = map(int, raw_input().split())\n    if not depth[u] < depth[v]:\n        u, v = v, u\n    for k in xrange(LEV+1):\n        if ((depth[v] - depth[u]) >> k) & 1:\n            v = parent[v][k]\n    if u == v:\n        print u\n        continue\n\n    for k in xrange(LEV, -1, -1):\n        if parent[u][k] != parent[v][k]:\n            u = parent[u][k]\n            v = parent[v][k]\n    print parent[u][0]"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass Edge:\n    def __init__(self, dst, weight):\n        self.dst, self.weight = dst, weight\n\n    def __lt__(self, e):\n        return self.weight > e.weight\n\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.E = [[] for _ in range(V)]\n\n    def add_edge(self, src, dst, weight):\n        self.E[src].append(Edge(dst, weight))\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * g.V, [-1] * g.V, [-1] * g.V, [-1] * g.V\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1)]\n        sub, max_sub = [1] * self.g.V, [(0, -1)] * self.g.V\n        used = [False] * self.g.V\n\n        while stack:\n            v, par = stack.pop()\n            if not used[v]:\n                used[v] = True\n                self.parent[v] = par\n                stack.append((v, par))\n                stack.extend((e.dst, v) for e in self.g.E[v] if e.dst != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for e in self.g.E[v]:\n                    if e.dst != self.parent[v] and e.dst != self.heavy[v]:\n                        que.append(e.dst)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = Graph(N)\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g.add_edge(i, c, 1)\n        g.add_edge(c, i, 1)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\n\nclass LCA:\n    def __init__(self,N,G,r):\n        self.dist=[-1]*N\n        self.K=0\n        while(2**self.K<N):\n            self.K+=1\n        self.doubling=[[-1]*N for i in range(self.K+1)]\n        self.dfs(G,r,-1,0)\n        for k in range(1,self.K+1):\n            for i in range(1,N):\n                self.doubling[k][i]=self.doubling[k-1][self.doubling[k-1][i]]\n        \n    def dfs(self,G,v,p,d):\n        self.dist[v]=d\n        self.doubling[0][v]=p\n        for nv in G[v]:\n            if nv==p:\n                continue\n            self.dfs(G,nv,v,d+1)\n        \n    def get(self,u,v):\n        if self.dist[u]<self.dist[v]:\n            u,v=v,u\n        for k in range(self.K+1):\n            if (self.dist[u]-self.dist[v])>>k&1:\n                u=self.doubling[k][u]\n        if u==v:\n            return u\n        for k in reversed(range(self.K+1)):\n            if self.doubling[k][u]!=self.doubling[k][v]:\n                u=self.doubling[k][u]\n                v=self.doubling[k][v]\n        return self.doubling[0][u]\n    \n    def getdist(self,u,v):\n        return self.dist[u]+self.dist[v]-2*self.dist[self.get(u,v)]\n\ndef main():\n    N=int(input())\n    G=[[] for i in range(N)]\n    for i in range(N):\n        k=list(map(int,input().split()))\n        for j in range(1,len(k)):\n            G[i].append(k[j])\n            G[k[j]].append(i)\n    lca=LCA(N,G,0)\n    Q=int(input())\n    for i in range(Q):\n        a,b=map(int,input().split())\n        print(lca.get(a,b))\n\nif __name__=='__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(200000)\n\ndef dfs(here, p, d, parent, depth, connect):\n    parent[0][here] = p\n    depth[here] = d\n    for next_v in connect[here]:\n        dfs(next_v, here, d + 1, parent, depth, connect)\n\ndef lca(v1, v2, parent, depth):\n    if depth[v2] > depth[v1]:\n        v1, v2 = v2, v1\n    for i in range(max_log):\n        if depth[v1] - depth[v2] >> i & 1:\n            v1 = parent[i][v1]\n    if v1 == v2:\n        return v2\n    for i in range(max_log - 1, -1, -1):\n        if parent[i][v1] != parent[i][v2]:\n            v1 = parent[i][v1]\n            v2 = parent[i][v2]\n    return parent[0][v2]\n\nconnect = defaultdict(list)\nv_num = int(input())\nroot = 0\nfor i in range(v_num):\n    edge = [int(n) for n in input().split(\" \")]\n    connect[i].extend(edge[1:])\ndepth = [-1 for n in range(v_num)]\nmax_log = max(int(math.log(v_num, 2)), 1)\nparent = [[-1 for n in range(v_num)] for m in range(max_log)]\ndfs(root, -1, 0, parent, depth, connect)\nfor i in range(max_log - 1):\n    for v in range(v_num):\n        parent[i + 1][v] = -1 if parent[i][v] < 0 else parent[i][parent[i][v]]\nq_num = int(input())\nfor _ in range(q_num):\n    v1, v2 = (int(n) for n in input().split(\" \") )\n    print(lca(v1, v2, parent, depth))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom math import log\n\ndef dfs(v,p,d):\n    parent[0][v]=p\n    depth[v]=d\n    for i in xrange(len(G[v])):\n        if G[v][i]!=p:\n            dfs(G[v][i],v,d+1)\n\ndef init(vn,root):\n    dfs(root,-1,0)\n    k=0\n    while k+1<log(vn,2):\n        for v in xrange(vn):\n            if parent[k][v]<0:\n                parent[k+1][v]=-1\n            else:\n                parent[k+1][v]=parent[k][parent[k][v]]\n        k+=1\n\ndef lca(u,v,vn):\n    if depth[u]>depth[v]:u,v=v,u\n    k=0\n    while k<log(vn,2):\n        if (depth[v]-depth[u])>>k&1:\n            v=parent[k][v]\n        k+=1\n    if u==v:return u\n    for k in xrange(int(log(vn,2))-1,-1,-1):\n        if parent[k][u]!=parent[k][v]:\n            u=parent[k][u]\n            v=parent[k][v]\n    return parent[0][u]\n\n\nvn=int(raw_input())        #????????°\nG=[[] for _ in xrange(vn)] #??£??\\?????????\nparent=[[-1]*vn for _ in xrange(int(log(vn,2))+1)] #parent[k][u]:??????u??????2^k????????????????????£?????¨????????????\ndepth=[0]*vn               #depth[u]:??????u?????????????????±??????????????±??????0\nroot=0                     #??????????????????\n\nfor i in xrange(vn):\n    en=map(int,raw_input().split())\n    c=en[1:]          #????????????i??????\n    G[i]=c\n\ninit(vn,root)\n\nq=int(raw_input())\nfor _ in xrange(q):\n    u,v=map(int,raw_input().split())\n    print(lca(u,v,vn))"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass HeavyLightDecomposition:\n    def __init__(self, g, root=0):\n        self.g = g\n        self.vid, self.head, self.heavy, self.parent = [0] * len(g), [-1] * len(g), [-1] * len(g), [-1] * len(g)\n        self.dfs(root)\n        self.bfs(root)\n\n    def dfs(self, root):\n        stack = [(root, -1, False)]\n        sub, max_sub = [1] * len(self.g), [(0, -1)] * len(self.g)\n        while stack:\n            v, par, flag = stack.pop()\n            if not flag:\n                self.parent[v] = par\n                stack.append((v, par, True))\n                stack.extend((c, v, False) for c in self.g[v] if c != par)\n            else:\n                if par != -1:\n                    sub[par] += sub[v]\n                    max_sub[par] = max(max_sub[par], (sub[v], v))\n                self.heavy[v] = max_sub[v][1]\n\n    def bfs(self, root=0):\n        from collections import deque\n        k, que = 0, deque([root])\n        while que:\n            r = v = que.popleft()\n            while v != -1:\n                self.vid[v], self.head[v] = k, r\n                for c in self.g[v]:\n                    if c != self.parent[v] and c != self.heavy[v]:\n                        que.append(c)\n                k += 1\n                v = self.heavy[v]\n\n    def lca(self, u, v):\n        while self.head[u] != self.head[v]:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n            v = self.parent[self.head[v]]\n        else:\n            if self.vid[u] > self.vid[v]:\n                u, v = v, u\n        return u\n\nN = int(input())\ng = [[] for _ in range(N)]\nfor i in range(N):\n    for c in map(int, input().split()[1:]):\n        g[i].append(c)\n        g[c].append(i)\nhld = HeavyLightDecomposition(g)\nQ = int(input())\nfor _ in range(Q):\n    u, v = map(int, input().split())\n    print(hld.lca(u, v))"
  },
  {
    "language": "Python",
    "code": "# AOJ GRL_5_C Lowest Common Ancestor\n# calculate LCA O(logN) for each query\n\n# start form 0 node\n\n# prev[i][k]: 2^k parent of node i \n# Depth[i]: depth of node i from 0\n\n\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nLog_N = (N-1).bit_length()\n\nprev = [[-1]*(Log_N+1) for _ in range(N)]\ngraph = [[] for _ in range(N)]\nfor i in range(N):\n    K, *A = map(int, input().split())\n    graph[i] = A\n    for a in A:\n        prev[a][0] = i\n\nQ = int(input())\nQuery = [list(map(int, input().split())) for _ in range(Q)]\n\n\n# BFS\nDepth = [-1]*N\nq = [0]\nDepth[0] = 0\nd = 0\nwhile q:\n    qq = []\n    d += 1\n    for p in q:\n        for np in graph[p]:\n            if Depth[np] == -1:\n                Depth[np] = d\n                qq.append(np)\n    q = qq\n\n\n# construct\nfor k in range(Log_N):\n    for i in range(N):\n        if prev[i][k] == -1:\n            prev[i][k+1] = -1\n        else:\n            prev[i][k+1] = prev[prev[i][k]][k]\n\n# LCA\ndef LCA(u, v):\n    dd = Depth[v] - Depth[u]\n    if dd < 0:\n        u, v = v, u\n        dd = -dd\n    \n    # set same depth\n    for k in range(Log_N+1):\n        if dd & 1:\n            v = prev[v][k]\n        dd >>= 1\n    \n    if u == v:\n        return u\n    \n    for k in reversed(range(Log_N)):\n        pu = prev[u][k]\n        pv = prev[v][k]\n        if pu != pv:\n            u, v = pu, pv\n    \n    return prev[u][0]\n\n\nfor a, b in Query:\n    print(LCA(a, b))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_C: Tree - Lowest Common Ancestor\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass LowestCommonAncestor:\n    def __init__(self, graph, root):\n        self.graph = graph\n        self.root = root\n        self.descendants = self._dfs()\n\n    def _dfs(self):\n        n = self.graph.v\n        descendants = [{i} for i in range(n)]\n        visited = [False] * n\n        edge_to = [None] * n\n\n        stack = [self.root]\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n                for e in self.graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        edge_to[w] = v\n                        stack.append(w)\n            else:\n                p = edge_to[v]\n                if p is not None:\n                    descendants[p].add(v)\n                    descendants[p].update(descendants[v])\n\n        return descendants\n\n    def find(self, i, j):\n        checked = [False] * self.graph.v\n        pair = {i, j}\n        v = self.root\n        while True:\n            checked[v] = True\n            for e in self.graph.adj(v):\n                w = e.other(v)\n                if not checked[w]:\n                    if pair <= self.descendants[w]:\n                        v = w\n                        break\n            else:\n                return v\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    lca = LowestCommonAncestor(g, 0)\n    q = int(input())\n    for _ in range(q):\n        v, w = [int(i) for i in input().split()]\n        print(lca.find(v, w))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom math import log2\n\nsys.setrecursionlimit(int(1e7))\n\n\ndef doubling():\n    dfs(0, -1, 0)\n    p0 = parent[0]\n    for p1 in parent[1:]:\n        for i in range(n):\n            pi = p0[i]\n            p1[i] = -1 if pi < 0 else p0[pi]\n        p0 = p1\n\n\ndef dfs(u, p, d):\n    parent[0][u] = p\n    depth[u] = d\n    for v in tree[u]:\n        dfs(v, u, d + 1)\n\n\ndef lca(u, v):\n    du, dv = depth[u], depth[v]\n    if du > dv:\n        u, v = v, u\n        du, dv = dv, du\n    for i, p in enumerate(parent):\n        if (dv - du) >> i & 1:\n            v = p[v]\n    if u == v:\n        return u\n    for p in parent[logn - 1:None:-1]:\n        pu, pv = p[u], p[v]\n        if pu != pv:\n            u, v = pu, pv\n    return parent[0][u]\n\n\nn = int(input())\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nlogn = int(log2(n)) + 1\nparent = [[0] * n for _ in range(logn)]\ndepth = [0] * n\n\ndoubling()\n\nq = int(input())\nfor _ in range(q):\n    print(lca(*map(int, input().split())))\n\n"
  },
  {
    "language": "Python",
    "code": "from math import log2\n\n\ndef build():\n    dfs()\n    pk0 = parent[0]\n    for pk1 in parent[1:]:\n        for v in range(n):\n            pkv = pk0[v]\n            pk1[v] = -1 if pkv < 0 else pk0[pkv]\n        pk0 = pk1\n\n\ndef dfs():\n    stack = [(0, -1, 0)]\n    while stack:\n        v, p, d = stack.pop()\n        parent[0][v] = p\n        depth[v] = d\n        stack.extend((child, v, d + 1) for child in tree[v])\n\n\ndef get(u, v):\n    du, dv = depth[u], depth[v]\n    if du > dv:\n        u, v = v, u\n        du, dv = dv, du\n    for k, pk in enumerate(parent):\n        if (dv - du) >> k & 1:\n            v = pk[v]\n    if u == v:\n        return u\n    for pk in parent[logn - 1:-1:-1]:\n        pku, pkv = pk[u], pk[v]\n        if pku != pkv:\n            u, v = pku, pkv\n    return parent[0][u]\n\n\nn = int(input())\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nlogn = int(log2(n)) + 1\nparent = [[0] * n for _ in range(logn)]\ndepth = [0] * n\nbuild()\n\nq = int(input())\nfor _ in range(q):\n    print(get(*map(int, input().split())))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\ninput=sys.stdin.readline\n\n\nclass SegTree():\n    def __init__(self, l, INF):\n        self.inf = INF\n\n        N = len(l)\n        v = 1\n        while v<N:\n            v *= 2\n\n        self.size = v\n        self.node = [self.inf] * (2*self.size-1)\n        for i in range(N): # 最下段を埋める\n            self.node[i+self.size-1] = l[i]\n        for i in range(self.size-1)[::-1]:\n            self.node[i] = min(self.node[2*i+1], self.node[2*i+2]) # 上段の更新をする\n\n    def get(self, left, right, k=0, l=0, r=-1):\n        if r < 0:\n            r = self.size\n\n        if (r <= left or right <= l):\n            return self.inf\n        if (left <= l and r <= right):\n            return self.node[k]\n\n        vl = self.get(left, right, 2*k+1, l, (l+r)//2)\n        vr = self.get(left, right, 2*k+2, (l+r)//2, r)\n        return min(vl, vr)\n\n    def update(self, x, v):\n        x += self.size-1\n        self.node[x] = v\n\n        while x>0:\n            x = (x-1)//2\n            self.node[x] = min(self.node[2*x+1], self.node[2*x+2])\n\n\nclass LCA():\n    def __init__(self, N, G):\n        self.depth = [0] * (N+1)\n        self.euler_tour = []\n        self.G = G\n    \n        self.idx = {}\n        self._currentIndex = 0\n\n        self._dfs(0, 0, 0)\n        self.tree = SegTree(self.euler_tour, (2**31-1, 2**31-1))\n    \n    def _dfs(self, v, p, d):\n        self.euler_tour.append((d, v))\n        self.idx[v] = self._currentIndex\n        self._currentIndex += 1\n\n        self.depth[v] = d\n        for u in self.G[v]:\n            if u==p:continue\n            self._dfs(u, v, d+1)\n            self.euler_tour.append((d, v))\n            self._currentIndex += 1\n    \n    def get(self, u, v):\n        a, b = self.idx[u], self.idx[v]\n        a, b = (a, b) if a<b else (b, a)\n        return self.tree.get(a, b+1)[1]\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    G = {i:[] for i in range(n)}\n    for i in range(n):\n        k, *l = map(int, input().split())\n        G[i] = l\n        for j in l:\n            G[j].append(i)\n    lca = LCA(n, G)\n    q = int(input())\n    for _ in range(q):\n        u, v = map(int, input().split())\n        print(lca.get(u, v))\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        assert!(self.depth[v1] == self.depth[v0]);\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                assert!(self.parent[k][v0].is_some());\n                assert!(self.parent[k][v1].is_some());\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                assert!(self.parent[k][v0].is_some());\n                assert!(self.parent[k][v1].is_some());\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n        \n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::io::{stdin, Read, StdinLock};\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::{HashSet, HashMap, BinaryHeap};\n#[allow(unused_imports)]\nuse std::vec::Vec;\n\n#[allow(dead_code)]\nconst INF: i32 = 1000_000_000;\n#[allow(dead_code)]\nconst INFLL: i64 = 1000_000_000_000_000_000;\n#[allow(dead_code)]\nconst EPS: f64 = 1.0e-10;\n#[allow(dead_code)]\nconst MOD: i32 = 1000_000_007;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\nimpl<'a> Scanner<'a> {\n    #[allow(dead_code)]\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner {cin: cin}\n    }\n\n    #[allow(dead_code)]\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n                    .skip_while(|c| c.is_whitespace())\n                    .take_while(|c| !c.is_whitespace())\n                    .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    #[allow(dead_code)]\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n\ntrait Edge {\n    fn from(&self) -> usize;\n    fn to(&self) -> usize;\n}\n\n#[allow(dead_code)]\n#[derive(Eq, PartialEq, PartialOrd, Clone)]\nstruct WeightedEdge {\n    from: usize,\n    to: usize,\n    weight: i32,\n}\n\nimpl Edge for WeightedEdge {\n    fn from(&self) -> usize {\n        self.from\n    }\n    fn to(&self) -> usize {\n        self.to\n    }\n}\n\n#[allow(dead_code)]\nimpl WeightedEdge {\n    fn new(from: usize, to: usize, weight: i32) -> WeightedEdge {\n        WeightedEdge {\n            from: from,\n            to: to,\n            weight: weight\n        }\n    }\n}\n\nimpl Ord for WeightedEdge {\n    fn cmp(&self, other: &WeightedEdge) -> Ordering {\n        if self.weight > other.weight {\n            Ordering::Greater\n        } else if self.weight < other.weight {\n            Ordering::Less\n        } else {\n            Ordering::Equal\n        }\n    }\n}\n\n///\n///\n///\ntrait Graph<E: Edge> {\n    fn edges(&self, v: usize) -> &std::vec::Vec<E>;\n    fn node_size(&self) -> usize;\n}\n\n#[derive(Clone)]\nstruct WeightedGraph {\n    adj_list: std::vec::Vec<std::vec::Vec<WeightedEdge>>,\n}\n\n#[allow(dead_code)]\nimpl WeightedGraph {\n    fn new(n: usize) -> WeightedGraph {\n        WeightedGraph {\n            adj_list: vec![std::vec::Vec::<WeightedEdge>::new(); n],\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize, w: i32) {\n        self.adj_list[from].push(WeightedEdge::new(from, to, w));\n    }\n}\n\nimpl Graph<WeightedEdge> for WeightedGraph {\n    fn edges(&self, v: usize) -> &std::vec::Vec<WeightedEdge> {\n        &self.adj_list[v]\n    }\n\n    fn node_size(&self) -> usize {\n        self.adj_list.len()\n    }\n}\n\nstruct LowestCommonAncestor{\n    //n: usize,\n    log_n: usize,\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<usize>,\n}\n\n#[allow(dead_code)]\nimpl LowestCommonAncestor {\n    fn new<E: Edge, G: Graph<E>>(t: &G, root: usize) -> LowestCommonAncestor {\n        let mut n = t.node_size();\n        let mut log_n: usize = 0;\n        while n > 0 {\n            log_n += 1;\n            n >>= 1;\n        }\n        let log_n = log_n;\n        let n = t.node_size();\n\n        fn dfs<E: Edge>(t: &Graph<E>, v: usize, p: Option<usize>, d: usize, parent: &mut Vec<Vec<Option<usize>>>, depth: &mut Vec<usize>) {\n            parent[0][v] = p;\n            depth[v] = d;\n            for e in t.edges(v) {\n                if p.is_none() || e.to() != p.unwrap() {\n                    dfs(t, e.to(), Some(v), d + 1, parent, depth);\n                }\n            }\n        }\n\n        let mut parent: Vec<Vec<Option<usize>>> = vec![vec![None; n]; log_n];\n        let mut depth: Vec<usize> = vec![0; n];\n        dfs(t, root, None, 0, &mut parent, &mut depth);\n        for k in 0..log_n-1 {\n            for v in 0..n {\n                match parent[k][v] {\n                    Some(p) => parent[k + 1][v] = parent[k][p],\n                    None    => parent[k + 1][v] = None,\n                }\n            }\n        }\n\n        LowestCommonAncestor {\n            //n: n,\n            log_n: log_n,\n            parent: parent,\n            depth: depth\n        }\n    }\n\n    fn depth(&self, v: usize) -> usize {\n        self.depth[v]\n    }\n\n    fn dist(&self, u: usize, v: usize) -> usize {\n        self.depth[u] + self.depth[v] - 2 * self.depth[self.query(u, v)]\n    }\n\n    fn parent(&self, u: usize, k: usize) -> Option<usize> {\n        let mut res: Option<usize> = Some(u);\n        for i in 0..self.log_n {\n            if k & (1 << i) > 0 {\n                match self.parent[i][res.unwrap()] {\n                    Some(p) => res = Some(p),\n                    None    => {\n                        res = None;\n                        break;\n                    }\n                }\n            }\n        }\n        res\n    }\n\n    fn query(&self, u: usize, v: usize) -> usize {\n        let (mut u, mut v) = if self.depth(u) > self.depth(v) { (v, u) } else { (u, v) };\n        for k in 0..self.log_n {\n            if (self.depth(v) - self.depth(u)) >> k & 1 > 0 {\n                v = self.parent[k][v].unwrap();\n            }\n        }\n        let res: usize;\n        if u == v {\n            res = u;\n        } else {\n            for k in (0..self.log_n).rev() {\n                if self.parent[k][u] != self.parent[k][v] {\n                    u = self.parent[k][u].unwrap();\n                    v = self.parent[k][v].unwrap();\n                }\n            }\n            res = self.parent[0][u].unwrap();\n        }\n\n        res\n    }\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    let n: usize = sc.read();\n    let mut t = WeightedGraph::new(n);\n    for i in 0..n {\n        let k: usize = sc.read();\n        for _j in 0..k {\n            let c: usize = sc.read();\n            t.add_edge(i, c, 0);\n        }\n    }\n    let lca = LowestCommonAncestor::new(&t, 0);\n    let q: usize = sc.read();\n    for _i in 0..q {\n        let u: usize = sc.read();\n        let v: usize = sc.read();\n        println!(\"{}\", lca.query(u, v));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n        dbg!(&self.parent);\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                if self.parent[k][u].is_some() {\n                    self.parent[k+1][u] = self.parent[k][self.parent[k][u].unwrap()]\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct Adjacent {\n    pub to: usize,\n    pub id: usize,\n}\nimpl Adjacent {\n    pub fn new(to: usize, id: usize) -> Adjacent {\n        Adjacent { to: to, id: id }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize: vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(to, self.esize));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(v, self.esize));\n        self.graph[v].push(Adjacent::new(u, self.esize));\n        self.esize += 1;\n    }\n    pub fn vertexes(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n}\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Vertex {\n    l: usize,\n    r: usize,\n    d: i64,\n    p: usize,\n}\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Edge {\n    l: usize,\n    r: usize,\n}\n#[derive(Clone, Debug, Default)]\npub struct EulerTourTree {\n    root: usize,\n    vs: Vec<Vertex>,\n    es: Vec<Edge>,\n    vtrace: Vec<usize>,\n    etrace: Vec<usize>,\n}\nimpl EulerTourTree {\n    pub fn new() -> Self {\n        Default::default()\n    }\n    fn euler_tour(&mut self, u: usize, p: usize, d: i64, graph: &Graph) {\n        self.vs[u].l = self.vtrace.len();\n        self.vs[u].d = d;\n        self.vtrace.push(u);\n        for a in graph.adjacency(u) {\n            if a.to != p {\n                self.es[a.id].l = self.etrace.len();\n                self.etrace.push(a.id);\n                self.euler_tour(a.to, u, d + 1, graph);\n                self.vtrace.push(u);\n                self.es[a.id].r = self.etrace.len();\n                self.etrace.push(a.id);\n                self.vs[a.to].p = a.id;\n            }\n        }\n        self.vs[u].r = self.vtrace.len() - 1;\n    }\n    pub fn build(&mut self, root: usize, graph: &Graph) {\n        let n = graph.vsize;\n        self.root = root;\n        self.vs = vec![Default::default(); n];\n        self.es = vec![Default::default(); n - 1];\n        self.vtrace.clear();\n        self.etrace.clear();\n        self.euler_tour(root, n, 0, graph);\n    }\n    pub fn vertex_in_range(&self, u: usize, v: usize) -> (usize, usize) {\n        let (mut l, mut r) = (self.vs[u].l, self.vs[v].l);\n        if l > r {\n            std::mem::swap(&mut l, &mut r);\n        }\n        (l, r + 1)\n    }\n    pub fn subtree_range(&self, u: usize) -> (usize, usize) {\n        (self.vs[u].l, self.vs[u].r + 1)\n    }\n}\n#[derive(Clone, Debug)]\npub struct SegmentTree<M: Monoid> {\n    pub n: usize,\n    pub seg: Vec<M::T>,\n    pub m: M,\n}\nimpl<M: Monoid> SegmentTree<M> {\n    pub fn new(n: usize, m: M) -> SegmentTree<M> {\n        let n = 1 << format!(\"{:b}\", n - 1).len();\n        let seg = vec![m.mempty(); 2 * n - 1];\n        SegmentTree {\n            n: n,\n            seg: seg,\n            m: m,\n        }\n    }\n    pub fn from_vec(v: Vec<M::T>, m: M) -> SegmentTree<M> {\n        let n = 1 << format!(\"{:b}\", v.len() - 1).len();\n        let mut seg = vec![m.mempty(); 2 * n - 1];\n        for (i, x) in v.into_iter().enumerate() {\n            seg[i + n - 1] = x;\n        }\n        for i in (0..n - 1).rev() {\n            seg[i] = m.mappend(&seg[2 * i + 1], &seg[2 * i + 2]);\n        }\n        SegmentTree {\n            n: n,\n            seg: seg,\n            m: m,\n        }\n    }\n    pub fn update(&mut self, k: usize, x: M::T) {\n        let mut k = k + self.n - 1;\n        self.seg[k] = x;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.seg[k] = self.m.mappend(&self.seg[2 * k + 1], &self.seg[2 * k + 2]);\n        }\n    }\n    pub fn query(&self, l: usize, r: usize) -> M::T {\n        let mut l = l + self.n - 1;\n        let mut r = r + self.n - 1;\n        let mut vl = self.m.mempty();\n        let mut vr = self.m.mempty();\n        while l < r {\n            if l & 1 == 0 {\n                vl = self.m.mappend(&vl, &self.seg[l]);\n                l += 1;\n            }\n            if r & 1 == 0 {\n                r -= 1;\n                vr = self.m.mappend(&self.seg[r], &vr);\n            }\n            l = (l - 1) / 2;\n            r = (r - 1) / 2;\n        }\n        self.m.mappend(&vl, &vr)\n    }\n}\npub trait Monoid {\n    type T: Clone + PartialEq;\n    fn mempty(&self) -> Self::T;\n    fn mappend(&self, x: &Self::T, y: &Self::T) -> Self::T;\n}\n#[derive(Clone, Debug)]\npub struct LCAMonoid<'a> {\n    euler: &'a EulerTourTree,\n}\nimpl<'a> Monoid for LCAMonoid<'a> {\n    type T = usize;\n    fn mempty(&self) -> usize {\n        self.euler.vs.len()\n    }\n    fn mappend(&self, u: &usize, v: &usize) -> usize {\n        self.euler.ancestor(*u, *v)\n    }\n}\n#[derive(Clone, Debug)]\npub struct LowestCommonAncestor<'a> {\n    seg: SegmentTree<LCAMonoid<'a>>,\n    euler: &'a EulerTourTree,\n}\nimpl<'a> LowestCommonAncestor<'a> {\n    pub fn lca(&self, u: usize, v: usize) -> usize {\n        let (l, r) = self.euler.vertex_in_range(u, v);\n        self.seg.query(l, r)\n    }\n}\nimpl EulerTourTree {\n    pub fn ancestor(&self, u: usize, v: usize) -> usize {\n        if u >= self.vs.len() {\n            v\n        } else if v >= self.vs.len() {\n            u\n        } else if self.vs[u].d < self.vs[v].d {\n            u\n        } else {\n            v\n        }\n    }\n    pub fn gen_lca<'a>(&'a self) -> LowestCommonAncestor<'a> {\n        LowestCommonAncestor {\n            seg: SegmentTree::from_vec(self.vtrace.clone(), LCAMonoid { euler: self }),\n            euler: self,\n        }\n    }\n}\n#[allow(unused_imports)]\nuse std::io::{stdout, BufWriter, StdoutLock, Write};\nfn with_bufwriter<F: FnOnce(&mut BufWriter<StdoutLock>) -> std::io::Result<()>>(\n    f: F,\n) -> std::io::Result<()> {\n    let stdout = stdout();\n    let mut writer = BufWriter::new(stdout.lock());\n    f(&mut writer)\n}\nfn main() {\n    input! { iter = iter, n };\n    let mut g = Graph::new(n);\n    let mut e = EulerTourTree::new();\n    for u in 0..n {\n        input_inner! { iter, k, c: [usize; k] };\n        for i in 0..k {\n            g.add_undirected_edge(u, c[i]);\n        }\n    }\n    e.build(0, &g);\n    let lca = e.gen_lca();\n    input_inner! { iter, q, uv: [(usize, usize); q] };\n    with_bufwriter(|out| {\n        for &(u, v) in uv.iter() {\n            writeln!(out, \"{}\", lca.lca(u, v))?;\n        }\n        Ok(())\n    })\n    .unwrap();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let log_n = (n as f64).log2().ceil() as usize;\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::fmt::Debug;\nuse std::io::{stdin, Read};\n\nuse std::option::*;\nuse std::string::*;\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<std::cmp::Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\n\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> std::cmp::Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nmacro_rules! read {\n    (($($t:tt),*)) => {\n        ( $(read!($t)),* )\n    };\n    ([[$t:tt; $len1:expr]; $len2:expr]) => {\n        (0..$len2).map(|_| read!([$t; $len1])).collect::<Vec<_>>()\n    };\n\n    ([$t:tt; $len:expr]) => {\n        (0..$len).map(|_| read!($t)).collect::<Vec<_>>()\n    };\n\n    (chars) => {\n        read!(String).chars().collect::<Vec<char>>()\n    };\n\n    (usize1) => {\n        read!(usize) - 1\n    };\n\n    ($t:ty) => {{\n        let stdin = stdin();\n        let stdin = stdin.lock();\n        let token: String = stdin\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect();\n\n        token.parse::<$t>().unwrap()\n    }};\n}\n\nmacro_rules! input {\n    (mut $name:ident: $t:tt, $($r:tt)*) => {\n        let mut $name = read!($t);\n        input!($($r)*);\n    };\n\n    (mut $name:ident: $t:tt) => {\n        let mut $name = read!($t);\n    };\n\n    ($name:ident: $t:tt, $($r:tt)*) => {\n        let $name = read!($t);\n        input!($($r)*);\n    };\n\n    ($name:ident: $t:tt) => {\n        let $name = read!($t);\n    };\n}\n\nstruct Combination {\n    MOD: i64,\n    fac: Vec<i64>,\n    fac_inv: Vec<i64>,\n}\n\nimpl Combination {\n    pub fn new(n: i64) -> Self {\n        let MOD: i64 = 1_000_000_007;\n        let mut fac: Vec<i64> = vec![0; n as usize + 1];\n        let mut fac_inv: Vec<i64> = vec![0; n as usize + 1];\n\n        let get_inverse = |mut n: i64| -> i64 {\n            let (mut res, mut p) = (1, MOD - 2);\n\n            while p != 0 {\n                if p & 1 == 1 {\n                    res = (res * n) % MOD;\n                }\n                n = (n * n) % MOD;\n                p >>= 1;\n            }\n\n            return res;\n        };\n\n        fac[0] = 1;\n\n        for i in 1..n + 1 {\n            fac[i as usize] = (fac[i as usize - 1] * i) % MOD;\n        }\n\n        for i in 0..n + 1 {\n            fac_inv[i as usize] = get_inverse(fac[i as usize]);\n        }\n\n        Combination {\n            MOD: MOD,\n            fac: fac,\n            fac_inv: fac_inv,\n        }\n    }\n\n    fn nCr(&self, n: i64, r: i64) -> i64 {\n        if n < r {\n            return 0;\n        }\n\n        let a: i64 = self.fac[n as usize];\n        let b: i64 = self.fac_inv[(n - r) as usize];\n        let c: i64 = self.fac_inv[r as usize];\n        let bc: i64 = (b * c) % self.MOD;\n\n        return (a * bc) % self.MOD;\n    }\n\n    fn nPr(&self, n: i64, r: i64) -> i64 {\n        if n < r {\n            return 0;\n        }\n\n        let a: i64 = self.fac[n as usize];\n        let b: i64 = self.fac_inv[(n - r) as usize];\n\n        return (a * b) % self.MOD;\n    }\n\n    fn nHr(&self, n: i64, r: i64) -> i64 {\n        if n == 0 && r == 0 {\n            return 1;\n        }\n\n        return self.nCr(n + r - 1, r);\n    }\n}\n\npub trait SliceExt<T>: Iterator + Sized {\n    fn vec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Edge {\n    to: usize,\n    cost: i64,\n}\n\nfn dijkstra(graph: &Vec<Vec<Edge>>, s: usize) -> Vec<i64> {\n    use std::collections::BinaryHeap;\n    let mut dist = vec![1e18 as i64; graph.len()];\n    let mut heap = BinaryHeap::new();\n    dist[s] = 0;\n    heap.push((0, s));\n    while let Some((cost, v)) = heap.pop() {\n        if dist[v] < cost {\n            continue;\n        }\n\n        for e in &graph[v] {\n            if dist[e.to] <= dist[v] + e.cost {\n                continue;\n            }\n            dist[e.to] = dist[v] + e.cost;\n            heap.push((0, e.to));\n        }\n    }\n    return dist;\n}\n\nstruct LCA {\n    par: Vec<Vec<Option<usize>>>,\n    dist: Vec<i64>,\n}\n\nimpl LCA {\n    pub fn new(graph: &Vec<Vec<usize>>, root: &usize) -> LCA {\n        let V = graph.len();\n        let mut K = 1;\n\n        while (1 << K) < V {\n            K += 1;\n        }\n\n        let mut par = vec![vec![None; V]; K];\n        let mut dist = vec![-1; V];\n        let graph = graph.to_vec();\n\n        fn dfs(\n            v: usize,\n            p: Option<usize>,\n            d: i64,\n            graph: &Vec<Vec<usize>>,\n            par: &mut Vec<Vec<Option<usize>>>,\n            dist: &mut Vec<i64>,\n        ) {\n            par[0][v] = p;\n            dist[v] = d;\n            for &to in &graph[v] {\n                match p {\n                    Some(p) => {\n                        if to != p {\n                            dfs(to, Some(v), d + 1, graph, par, dist)\n                        }\n                    }\n                    None => dfs(to, Some(v), d + 1, graph, par, dist),\n                }\n            }\n        }\n\n        dfs(*root, None, 0, &graph, &mut par, &mut dist);\n\n        for k in 0..K - 1 {\n            for v in 0..V {\n                match par[k][v] {\n                    Some(x) => par[k + 1][v] = par[k][x],\n                    None => (),\n                }\n            }\n        }\n\n        LCA { par, dist }\n    }\n\n    pub fn query(&self, u: &usize, v: &usize) -> usize {\n        let mut u = u.clone();\n        let mut v = v.clone();\n        if self.dist[u] < self.dist[v] {\n            return self.query(&v, &u);\n        }\n\n        let K = self.par.len();\n        for k in 0..K {\n            if ((self.dist[u] - self.dist[v]) >> k & 1) == 1 {\n                u = self.par[k][u].unwrap();\n            }\n        }\n\n        if u == v {\n            return u;\n        }\n\n        for k in (0..K - 1).rev() {\n            if self.par[k][u] != self.par[k][v] {\n                u = self.par[k][u].unwrap();\n                v = self.par[k][v].unwrap();\n            }\n        }\n\n        return self.par[0][u].unwrap();\n    }\n}\n\nfn main() {\n    input!(n: usize);\n    let mut graph = vec![Vec::new(); n];\n    for i in 0..n {\n        input!(k: usize);\n        for _ in 0..k {\n            input!(c: usize);\n            graph[i].push(c);\n            graph[c].push(i);\n        }\n    }\n\n\n    let lca = LCA::new(&graph, &0);\n    input!(q: usize);\n    for _ in 0..q {\n        input!(u: usize, v: usize);\n        println!(\"{}\", lca.query(&u, &v));\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::clone::Clone;\nuse std::collections::VecDeque;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nstruct LowestCommonAncestor {\n    root: usize, \n    n: usize, \n    log_n_max: usize, \n    graph: Vec<Vec<usize>>, \n    depth: Vec<i64>, \n    parent: Vec<Vec<i64>>\n}\n\nimpl LowestCommonAncestor {\n    fn new(graph: Vec<Vec<usize>>, root: usize, n: usize, log_n_max: usize) -> Self {\n        let mut depth = vec![-1; n];\n        let mut parent: Vec<Vec<i64>> = vec![vec![-1; log_n_max]; n];\n\n        let mut stack = VecDeque::<usize>::new();\n        stack.push_front(root);\n        parent[root][0] = -1;\n        depth[root] = 0;\n        let mut used = vec![false; n];\n        used[root] = true;\n        while !stack.is_empty() {\n            let node = stack.pop_front().unwrap();\n            stack.push_front(node);\n            for &child in &graph[node] {\n                if used[child] {\n                    continue;\n                }\n                parent[child][0] = node as i64;\n                depth[child] = depth[node] + 1;\n                used[child] = true;\n                stack.push_front(child);\n            }\n\n            let head = stack.pop_front().unwrap();\n            if head != node {\n                stack.push_front(head);\n            }\n        }\n\n        for k in 0..(log_n_max-1) {\n            for i in 0..n {\n                if parent[i][k] != -1 {\n                    parent[i][k+1] = parent[parent[i][k] as usize][k];\n                }\n            }\n        }\n\n        LowestCommonAncestor {\n            root: root, \n            n: n, \n            log_n_max: log_n_max, \n            graph: graph, \n            depth: depth, \n            parent: parent, \n        }\n    }\n\n    fn get_lca(&self, u: usize, v: usize) -> usize {\n        let (mut u, mut v) = if self.depth[u] > self.depth[v] {\n            (v, u)\n        } else {\n            (u, v)   \n        };\n\n        for k in 0..self.log_n_max {\n            if (self.depth[v] - self.depth[u]) & (1 << k) != 0 {\n                v = self.parent[v][k] as usize;\n            }\n        }\n        if u == v {\n            return u;\n        }\n\n        for k in (0..self.log_n_max).rev() {\n            if self.parent[u][k] != self.parent[v][k] {\n                u = self.parent[u][k] as usize;\n                v = self.parent[v][k] as usize;\n            }\n        }\n        self.parent[u][0] as usize\n    }\n}\n\nfn main() {\n    let n: usize = read();\n    let mut graph = vec![Vec::new(); n];\n    for k in 0..n {\n        let m: usize = read();\n        for i in 0..m {\n            let c: usize = read();\n            graph[k].push(c);\n        }\n    }\n\n    let mut lca = LowestCommonAncestor::new(graph, 0, n, 30);\n\n    let q: usize  = read();\n    for _ in 0..q {\n        let u: usize = read();\n        let v: usize = read();\n        println!(\"{}\", lca.get_lca(u, v));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[macro_use]\nmod input_mcr {\n    // ref: tanakh <https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8>\n    // diff: using Parser\n    #[macro_export(local_inner_macros)]\n    macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut parser = Parser::from_str($s);\n        input_inner!{parser, $($r)*}\n    };\n    (parser = $parser:ident, $($r:tt)*) => {\n        input_inner!{$parser, $($r)*}\n    };\n    (new_stdin_parser = $parser:ident, $($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let reader = std::io::BufReader::new(stdin.lock());\n        let mut $parser = Parser::new(reader);\n        input_inner!{$parser, $($r)*}\n    };\n    ($($r:tt)*) => {\n        input!{new_stdin_parser = parser, $($r)*}\n    };\n}\n\n    #[macro_export(local_inner_macros)]\n    macro_rules! input_inner {\n    ($parser:ident) => {};\n    ($parser:ident, ) => {};\n    ($parser:ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($parser, $t);\n        input_inner!{$parser $($r)*}\n    };\n}\n\n    #[macro_export(local_inner_macros)]\n    macro_rules! read_value {\n    ($parser:ident, ( $($t:tt),* )) => {\n        ( $(read_value!($parser, $t)),* )\n    };\n    ($parser:ident, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($parser, $t)).collect::<Vec<_>>()\n    };\n    ($parser:ident, chars) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, char_) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()[0]\n    };\n    ($parser:ident, usize1) => {\n        read_value!($parser, usize) - 1\n    };\n    ($parser:ident, line) => {\n        $parser.next_line()\n    };\n    ($parser:ident, line_) => {\n        $parser.next_line().chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, i64_) => {\n        $parser.fast_i64()\n    };\n    ($parser:ident, usize_) => {\n        $parser.fast_i64() as usize\n    };\n    ($parser:ident, usize1_) => {\n        ($parser.fast_i64() - 1) as usize\n    };\n    ($parser:ident, $t:ty) => {\n        $parser.next::<$t>().expect(\"Parse error\")\n    };\n}\n\n    use std::io;\n    use std::io::BufRead;\n    use std::str;\n\n    // ref: tatsuya6502 <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e>\n    // ref: wariuni <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e#comment-7040a5ae96305e884eb9>\n    // diff: using std::io::BufRead::fill_buf()\n    pub struct Parser<R> {\n        pub reader: R,\n        buf: Vec<u8>,\n        pos: usize,\n    }\n\n    impl Parser<io::Empty> {\n        pub fn from_str(s: &str) -> Parser<io::Empty> {\n            Parser {\n                reader: io::empty(),\n                buf: s.as_bytes().to_vec(),\n                pos: 0,\n            }\n        }\n    }\n\n    impl<R: BufRead> Parser<R> {\n        pub fn new(reader: R) -> Parser<R> {\n            Parser {\n                reader: reader,\n                buf: vec![],\n                pos: 0,\n            }\n        }\n        pub fn update_buf(&mut self) {\n            self.buf.clear();\n            self.pos = 0;\n            loop {\n                let (len, complete) = {\n                    let buf2 = self.reader.fill_buf().unwrap();\n                    self.buf.extend_from_slice(buf2);\n                    let len = buf2.len();\n                    (len, buf2[len - 1] <= 0x20)\n                };\n                self.reader.consume(len);\n                if complete {\n                    break;\n                }\n            }\n        }\n        pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n            loop {\n                let mut begin = self.pos;\n                while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                    begin += 1;\n                }\n                let mut end = begin;\n                while end < self.buf.len() && (self.buf[end] > 0x20) {\n                    end += 1;\n                }\n                if begin != self.buf.len() {\n                    self.pos = end;\n                    return unsafe { str::from_utf8_unchecked(&self.buf[begin..end]) }.parse::<T>();\n                } else {\n                    self.update_buf();\n                }\n            }\n        }\n        pub fn next_line(&mut self) -> String {\n            loop {\n                let mut begin = self.pos;\n                if begin < self.buf.len() && (self.buf[begin] < 0x20) {\n                    begin += 1;\n                }\n                let mut end = begin;\n                while end < self.buf.len() && (self.buf[end] >= 0x20) {\n                    end += 1;\n                }\n                if begin != self.buf.len() {\n                    self.pos = end;\n                    return unsafe { str::from_utf8_unchecked(&self.buf[begin..end]) }.to_string();\n                } else {\n                    self.update_buf();\n                }\n            }\n        }\n        pub fn fast_i64(&mut self) -> i64 {\n            loop {\n                let mut begin = self.pos;\n                while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                    begin += 1;\n                }\n                if begin == self.buf.len() {\n                    self.update_buf();\n                    continue;\n                }\n                let mut res = 0;\n                let (is_positive, mut end) = match self.buf[begin] {\n                    b'+' => (true, begin + 1),\n                    b'-' => (false, begin + 1),\n                    _ => (true, begin),\n                };\n                while end < self.buf.len() && (self.buf[end] > 0x20) {\n                    res = res * 10 + (self.buf[end] as i64 - '0' as i64);\n                    end += 1;\n                }\n                if begin != self.buf.len() {\n                    self.pos = end;\n                    return if is_positive { res } else { -res };\n                } else {\n                    self.update_buf();\n                }\n            }\n        }\n    }\n}\n\nmod unionfind {\n    struct UnionFindNode {\n        parent: usize,\n        num: usize,\n    }\n\n    impl UnionFindNode {\n        fn new(parent: usize) -> UnionFindNode {\n            UnionFindNode {\n                parent: parent,\n                num: 1,\n            }\n        }\n    }\n\n    pub struct UnionFind(Vec<UnionFindNode>);\n\n    impl UnionFind {\n        pub fn new(n: usize) -> UnionFind {\n            let mut xs = vec![];\n            for i in 0..n {\n                xs.push(UnionFindNode::new(i));\n            }\n            UnionFind(xs)\n        }\n        pub fn root(&mut self, i: usize) -> usize {\n            let parent = self.0[i].parent;\n            if parent == i {\n                i\n            } else {\n                let res = self.root(parent);\n                self.0[i].parent = res;\n                res\n            }\n        }\n        pub fn unite(&mut self, i: usize, k: usize) {\n            let i = self.root(i);\n            let k = self.root(k);\n            if i == k {\n                return;\n            }\n            let (i, k) = if self.0[i].num < self.0[k].num {\n                (i, k)\n            } else {\n                (k, i)\n            };\n            self.0[i].parent = k;\n            self.0[k].num += self.0[i].num;\n        }\n        pub fn is_same_set(&mut self, i: usize, k: usize) -> bool {\n            self.root(i) == self.root(k)\n        }\n        pub fn num(&mut self, i: usize) -> usize {\n            let i = self.root(i);\n            self.0[i].num\n        }\n    }\n}\n\nuse input_mcr::*;\nuse std::cmp::*;\n\nuse unionfind::*;\n\nstruct RootedTreeWithLCA {\n    parent: Vec<Vec<usize>>,\n    depth: Vec<usize>,\n}\n\nimpl RootedTreeWithLCA {\n    pub fn new(ps: &[usize]) -> RootedTreeWithLCA {\n        let n = ps.len();\n        let m = n.next_power_of_two().trailing_zeros() as usize + 1;\n        let mut parent = vec![vec![]; m];\n        for k in 0..n {\n            parent[0].push(ps[k]);\n        }\n        for i in 1..m {\n            for k in 0..n {\n                let a = parent[i - 1][k];\n                let b = parent[i - 1][a];\n                parent[i].push(b);\n            }\n        }\n        let mut graph = vec![vec![]; n];\n        for i in 0..n {\n            graph[ps[i]].push(i);\n        }\n        let inf = 1 << 50;\n        let mut depth = vec![inf; n];\n        depth[0] = 0;\n        let mut q = std::collections::VecDeque::new();\n        q.push_back(0);\n        while let Some(v) = q.pop_front() {\n            for &next in &graph[v] {\n                if depth[v] + 1 < depth[next] {\n                    depth[next] = depth[v] + 1;\n                    q.push_back(next);\n                }\n            }\n        }\n        // eprintln!(\"depth = {:?}\", depth);\n        RootedTreeWithLCA {\n            parent: parent,\n            depth: depth,\n        }\n    }\n    pub fn lca(&self, x: usize, y: usize) -> usize {\n        let (mut x, mut y) = if self.depth[x] <= self.depth[y] {\n            (x, y)\n        } else {\n            (y, x)\n        };\n        let m = self.parent.len();\n        //// eprintln!(\"(1): x = {}, y = {}\", x, y);\n        for i in (0..m).rev() {\n            if (self.depth[y] - self.depth[x]) & (1 << i) != 0 {\n                y = self.parent[i][y];\n            }\n        }\n        //// eprintln!(\"(2): x = {}, y = {}\", x, y);\n        if x == y {\n            return x;\n        }\n        assert_eq!(self.depth[x], self.depth[y]);\n        for i in (0..m).rev() {\n            if self.parent[i][x] != self.parent[i][y] {\n                x = self.parent[i][x];\n                y = self.parent[i][y];\n            }\n        }\n        //// eprintln!(\"(3): x = {}, y = {}\", x, y);\n        assert_eq!(self.parent[0][x], self.parent[0][y]);\n        self.parent[0][x]\n    }\n    pub fn dist(&self, x: usize, y: usize) -> usize {\n        self.depth[x] + self.depth[y] - 2 * self.depth[self.lca(x, y)]\n    }\n}\n\nfn two_edge_connected_components(\n    n: usize,\n    es: &[(usize, usize)],\n) -> (UnionFind, RootedTreeWithLCA) {\n    let mut graph = vec![vec![]; n];\n    for &(s, t) in es {\n        graph[s].push(t);\n        graph[t].push(s);\n    }\n\n    fn dfs(\n        graph: &Vec<Vec<usize>>,\n        i: usize,\n        prev: Option<usize>,\n        count: &mut Vec<i64>,\n        ds: &mut Vec<Option<i64>>,\n        uf: &mut UnionFind,\n        new_edges: &mut Vec<(usize, usize)>,\n    ) -> i64 {\n        for &next in &graph[i] {\n            if Some(next) == prev {\n                continue;\n            }\n            if ds[next].is_none() {\n                ds[next] = Some(ds[i].unwrap() + 1);\n                let t = dfs(graph, next, Some(i), count, ds, uf, new_edges);\n                // eprintln!(\"fe: {} -> {}, t = {}\", i, next, t);\n                count[i] += t;\n                if t != 0 {\n                    uf.unite(i, next);\n                } else {\n                    new_edges.push((i, next));\n                }\n            } else if ds[next].unwrap() < ds[i].unwrap() {\n                // eprintln!(\"be: {}+1, {}-1\", next, i);\n                count[next] += 1;\n                count[i] -= 1;\n            }\n        }\n        count[i]\n    }\n\n    let mut count = vec![0; n];\n    let mut ds = vec![None; n];\n    ds[0] = Some(0);\n    let mut uf = UnionFind::new(n);\n    let mut new_edges = vec![];\n    dfs(\n        &graph,\n        0,\n        None,\n        &mut count,\n        &mut ds,\n        &mut uf,\n        &mut new_edges,\n    );\n    let mut ps: Vec<usize> = (0..n).collect();\n    for &(s, t) in &new_edges {\n        ps[uf.root(t)] = uf.root(s);\n    }\n    // eprintln!(\"ps = {:?}\", ps);\n    (uf, RootedTreeWithLCA::new(&ps))\n}\n\nfn main() {\n    input! {\n        new_stdin_parser = parser,\n        n: usize,\n    }\n    let mut ps: Vec<usize> = (0..n).collect();\n    for i in 0..n {\n        input! {\n            parser = parser,\n            m: usize,\n            xs: [usize; m],\n        }\n        for &x in &xs {\n            ps[x] = i;\n        }\n    }\n    let r_tree = RootedTreeWithLCA::new(&ps);\n    input! {\n        parser = parser,\n        q: usize,\n        qs: [(usize,usize); q],\n    }\n    for &(s, t) in &qs {\n        println!(\"{}\", r_tree.lca(s, t));\n    }\n}\n\nfn main2() {\n    input! {\n        n: usize,\n        m: usize,\n        es: [(usize1,usize1); m],\n        q: usize,\n        qs: [(usize1,usize1,usize1); q],\n    }\n    let (mut uf, r_tree) = two_edge_connected_components(n, &es);\n    for i in 0..n {\n        // eprintln!(\"root of {} = {}\", i, uf.root(i));\n    }\n    for &(a, b, c) in &qs {\n        let a = uf.root(a);\n        let b = uf.root(b);\n        let c = uf.root(c);\n        // eprintln!(\"a = {}, b = {}, c = {}\", a, b, c);\n        //// eprintln!(\"a^b = {}\", r_tree.lca(a,b));\n        //// eprintln!(\"b^a = {}\", r_tree.lca(b,a));\n        //// eprintln!(\"a^c = {}\", r_tree.lca(a,c));\n        //// eprintln!(\"c^a = {}\", r_tree.lca(c,a));\n        //// eprintln!(\"b^c = {}\", r_tree.lca(b,c));\n        //// eprintln!(\"c^b = {}\", r_tree.lca(c,b));\n        let res = r_tree.dist(a, b) + r_tree.dist(b, c) == r_tree.dist(a, c);\n        println!(\"{}\", if res { \"OK\" } else { \"NG\" });\n    }\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                if self.parent[k][u].is_some() {\n                    self.parent[k+1][u] = self.parent[k][self.parent[k][u].unwrap()]\n                } \n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (((self.depth[v1] - self.depth[v0]) >> k) & 1) > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        assert!(self.depth[v1] >= self.depth[v0]);\n        assert!(self.depth[v1] == self.depth[v0]);\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                assert!(self.parent[k][v0].is_some());\n                assert!(self.parent[k][v1].is_some());\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n    \n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                if self.parent[k][u].is_some() {\n                    self.parent[k+1][u] = self.parent[k][self.parent[k][u].unwrap()]\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let n = sc.read::<usize>();\n    let mut graph = (0..n).map(|_| Vec::new()).collect::<Vec<_>>();\n    for i in 0..n {\n        let k = sc.read::<usize>();\n        for _ in 0..k {\n            let c: usize = sc.read();\n            graph[i].push(c);\n            graph[c].push(i);\n        }\n    }\n\n    let lca = LowestCommonAncestor::new(&graph);\n\n    let q: usize = sc.read();\n    for _ in 0..q {\n        let u: usize = sc.read();\n        let v: usize = sc.read();\n        println!(\"{}\", lca.get_lca(u, v));\n    }\n}\n\nstruct LowestCommonAncestor {\n    graph: Vec<Vec<usize>>,\n    parent: Vec<Vec<i32>>,\n    depth: Vec<usize>,\n    root: usize,\n    log_v: usize,\n}\n\nimpl LowestCommonAncestor {\n    fn new(graph: &Vec<Vec<usize>>) -> LowestCommonAncestor {\n        let v = graph.len();\n        let root = 0;\n        let graph = graph.clone();\n        let mut depth = vec![0; v];\n\n        let mut log_v = 1;\n        let mut i = 1;\n        while i <= v {\n            i *= 2;\n            log_v += 1;\n        }\n        let mut parent: Vec<Vec<i32>> = vec![vec![0; v]; log_v];\n\n        let mut depth_vis = vec![false; v];\n        let mut stack = VecDeque::new();\n        stack.push_front(root);\n        parent[0][root] = -1;\n        depth[root] = 0;\n        while !stack.is_empty() {\n            let v = stack.pop_front().unwrap();\n            stack.push_front(v);\n            for u in &graph[v] {\n                let u = *u;\n                if depth_vis[u] { continue; }\n                parent[0][u] = v as i32;\n                depth[u] = depth[v] + 1;\n                depth_vis[u] = true;\n                stack.push_front(u);\n            }\n\n            let head = stack.pop_front().unwrap();\n            if head != v { stack.push_front(head); }\n        }\n\n        for k in 0..(log_v - 1) {\n            for u in 0..v {\n                parent[k + 1][u] = if parent[k][u] < 0 {\n                    -1\n                } else {\n                    parent[k][parent[k][u] as usize]\n                };\n            }\n        }\n        LowestCommonAncestor { graph: graph, parent: parent, depth: depth, root: root, log_v: log_v }\n    }\n\n    fn get_lca(&self, u: usize, v: usize) -> usize {\n        let (mut u, mut v) = if self.depth[u] <= self.depth[v] { (u, v) } else { (v, u) };\n        for k in 0..self.log_v {\n            if ((self.depth[v] - self.depth[u]) & (1 << k)) != 0 {\n                v = self.parent[k][v] as usize;\n            }\n        }\n        if u == v { return u; }\n\n        for k in (0..self.log_v).rev() {\n            if self.parent[k][u] != self.parent[k][v] {\n                u = self.parent[k][u] as usize;\n                v = self.parent[k][v] as usize;\n            }\n        }\n        return self.parent[0][u] as usize;\n    }\n\n    fn get_dist(&self, u: usize, v: usize) -> usize {\n        let lca = self.get_lca(u, v);\n        self.depth[u] + self.depth[v] - self.depth[lca] * 2\n    }\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin Lowest Common Ancestor ----------\nstruct LCA {\n    graph: Vec<Vec<usize>>,\n    path_root: Vec<usize>,\n    path_parent: Vec<usize>,\n    index: Vec<usize>\n}\n\nimpl LCA {\n    fn new(n: usize) -> Self {\n        LCA {\n            graph: vec![vec![]; n],\n            path_root: vec![],\n            path_parent: vec![],\n            index: vec![],\n        }\n    }\n    fn add_edge(&mut self, a: usize, b: usize) {\n        self.graph[a].push(b);\n        self.graph[b].push(a);\n    }\n    fn build(&mut self, root: usize) {\n        let mut q = vec![];\n        let mut stack = vec![(root, root)];\n        let graph = &mut self.graph;\n        while let Some((v, p)) = stack.pop() {\n            q.push(v);\n            if let Some(k) = graph[v].iter().position(|u| *u == p) {\n                graph[v].swap_remove(k);\n            }\n            for &u in graph[v].iter() {\n                stack.push((u, v));\n            }\n        }\n        let n = graph.len();\n        let mut size = vec![1; n];\n        for &v in q.iter().rev() {\n            if graph[v].is_empty() {\n                continue;\n            }\n            let mut max = (0, 0);\n            for (i, &u) in graph[v].iter().enumerate() {\n                size[v] += size[u];\n                if size[u] > max.0 {\n                    max = (size[u], i);\n                }\n            }\n            graph[v].swap(0, max.1);\n        }\n        let mut path_root = vec![root; n];\n        let mut path_parent = vec![root; n];\n        let mut index = vec![n; n];\n        let mut stack = vec![root];\n        let mut k = 0;\n        while let Some(v) = stack.pop() {\n            index[v] = k;\n            k += 1;\n            if graph[v].is_empty() {\n                continue;\n            }\n            for &u in graph[v].iter().skip(1) {\n                path_root[u] = u;\n                path_parent[u] = v;\n                stack.push(u);\n            }\n            let u = graph[v][0];\n            path_root[u] = path_root[v];\n            path_parent[u] = path_parent[v];\n            stack.push(u);\n        }\n        self.path_root = path_root;\n        self.path_parent = path_parent;\n        self.index = index;\n    }\n    fn query(&self, mut a: usize, mut b: usize) -> usize {\n        let path = &self.path_root;\n        let parent = &self.path_parent;\n        let index = &self.index;\n        while path[a] != path[b] {\n            if index[a] < index[b] {\n                b = parent[b];\n            } else {\n                a = parent[a];\n            }\n        }\n        if index[a] < index[b] {a} else {b}\n    }\n}\n// ---------- end Lowest Common Ancestor ----------\nuse std::io::Read;\nuse std::io::Write;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let mut lca = LCA::new(n);\n    for i in 0..n {\n        let len: usize = it.next().unwrap().parse().unwrap();\n        for _ in 0..len {\n            let c: usize = it.next().unwrap().parse().unwrap();\n            lca.add_edge(i, c);\n        }\n    }\n    lca.build(0);\n    let q: usize = it.next().unwrap().parse().unwrap();\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for _ in 0..q {\n        let a: usize = it.next().unwrap().parse().unwrap();\n        let b: usize = it.next().unwrap().parse().unwrap();\n        let ans = lca.query(a, b);\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// =========\nuse std::cmp::{max, min};\nuse std::collections::{HashMap, HashSet};\nuse std::process::exit;\n\nconst MOD: usize = 1000000007;\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n// =========\nstruct SegTree<T> {\n    // num: 葉(元データ)の数, data: ノードの値, neutral: 単位元, merge: 区間クエリ, update_point: 点更新\n    num: usize,\n    data: Vec<T>,\n    neutral: T,\n    merge: Box<Fn(T, T) -> T>,\n    update_point: Box<Fn(T, T) -> T>,\n}\n\nimpl<T: Clone + Copy + std::fmt::Debug> SegTree<T> {\n    // v...元配列, neutral...初期値かつ単位元, merge...区間クエリ, update:\n    fn new(\n        v: Vec<T>,\n        neutral: T,\n        merge: Box<Fn(T, T) -> T>,\n        update_point: Box<Fn(T, T) -> T>,\n    ) -> Self {\n        let n = v.len().checked_next_power_of_two().unwrap();\n        let mut data: Vec<T> = vec![neutral; 2 * n - 1];\n        for i in 0..v.len() {\n            data[i + n - 1] = v[i];\n        }\n        if n > 1 {\n            for i in (0..(n - 2)).rev() {\n                data[i] = merge(data[2 * i + 1], data[2 * i + 2]);\n            }\n        }\n        SegTree {\n            num: n,\n            data: data,\n            neutral: neutral,\n            merge: merge,\n            update_point: update_point,\n        }\n    }\n    // 点更新, i番目の値をxで更新\n    fn update(&mut self, i: usize, x: T) {\n        let mut i = i + self.num - 1; // 対応する葉のNodeへ\n        self.data[i] = (self.update_point)(self.data[i], x);\n        while i > 0 {\n            i = (i - 1) / 2;\n            // 親の値を更新する\n            self.data[i] = (self.merge)(self.data[i * 2 + 1], self.data[i * 2 + 2]);\n        }\n    }\n    // [a, b): クエリの区間, k: valueのNode, [l,r): k-Nodeの担当区間\n    // 0-indexedで来たら[a, b+1]をする\n    fn query(&self, a: usize, b: usize, k: usize, l: usize, r: usize) -> T {\n        if r <= a || b <= l {\n            self.neutral // 区間がかぶらないので単位元\n        } else if a <= l && r <= b {\n            self.data[k] //もろの区間なので値を返す\n        } else {\n            //半端な区間なので左右にqueryしてもう一回評価をする\n            let l_val = self.query(a, b, 2 * k + 1, l, (l + r) / 2);\n            let r_val = self.query(a, b, 2 * k + 2, (l + r) / 2, r);\n            (self.merge)(l_val, r_val)\n        }\n    }\n}\n// adjl...隣接リスト, u...今の点, depth...各頂点の深さを持つ, d...深さの値, fid...各頂点がはじめて出るet上のIndex\nfn eulertour(\n    adjl: &Vec<Vec<usize>>,\n    u: usize,\n    et: &mut Vec<usize>,\n    depth: &mut Vec<usize>,\n    d: usize,\n    fid: &mut Vec<usize>,\n) {\n    depth[u] = d;\n    fid[u] = et.len();\n    et.push(u);\n    for v in &adjl[u] {\n        eulertour(adjl, *v, et, depth, d + 1, fid);\n        et.push(u);\n    }\n}\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let n: usize = sc.read();\n    let mut adjl: Vec<Vec<usize>> = vec![vec![]; n];\n    for i in 0..n {\n        let k: usize = sc.read();\n        for _ in 0..k {\n            let c: usize = sc.read();\n            adjl[i].push(c);\n        }\n    }\n    let mut et: Vec<usize> = vec![];\n    let mut depth: Vec<usize> = vec![std::usize::MAX; n];\n    let mut fid: Vec<usize> = vec![std::usize::MAX; n];\n    eulertour(&adjl, 0, &mut et, &mut depth, 0, &mut fid);\n    let v = et\n        .iter()\n        .map(|e| (*e, depth[*e]))\n        .collect::<Vec<(usize, usize)>>();\n\n    // index, depthで持つ\n    let mut st = SegTree::<(usize, usize)>::new(\n        v,\n        (std::usize::MAX, std::usize::MAX),\n        Box::new(\n            |l: (usize, usize), r: (usize, usize)| {\n                if l.1 < r.1 {\n                    l\n                } else {\n                    r\n                }\n            },\n        ),\n        Box::new(|_old: (usize, usize), new: (usize, usize)| new),\n    );\n\n    let q: usize = sc.read();\n\n    // query 処理\n    for _ in 0..q {\n        let u: usize = sc.read();\n        let v: usize = sc.read();\n        if u == v {\n            println!(\"{:?}\", u);\n        } else if fid[u] < fid[v] {\n            println!(\"{:?}\", st.query(fid[u], fid[v], 0, 0, st.num).0);\n        } else {\n            println!(\"{:?}\", st.query(fid[v], fid[u], 0, 0, st.num).0);\n        }\n    }\n}\n\nmod tests {\n    use super::*;\n    #[test]\n    fn check() {\n        let adjl = vec![\n            vec![1, 2, 3],\n            vec![4, 5],\n            vec![],\n            vec![],\n            vec![],\n            vec![6, 7],\n            vec![],\n            vec![],\n        ];\n        let mut et: Vec<usize> = vec![];\n        let mut depth: Vec<usize> = vec![std::usize::MAX; adjl.len()];\n        let mut fid: Vec<usize> = vec![std::usize::MAX; adjl.len()];\n        eulertour(&adjl, 0, &mut et, &mut depth, 0, &mut fid);\n        assert_eq!(et, vec![0, 1, 4, 1, 5, 6, 5, 7, 5, 1, 0, 2, 0, 3, 0]);\n        println!(\"{:?}\", et);\n        println!(\"{:?}\", depth);\n        println!(\"{:?}\", fid);\n    }\n\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if ((self.depth[v1] - self.depth[v0]) >> k & 1) > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        assert!(self.depth[v1] == self.depth[v0]);\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                assert!(self.parent[k][v0].is_some());\n                assert!(self.parent[k][v1].is_some());\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                if self.parent[k][u].is_some() {\n                    self.parent[k+1][u] = self.parent[k][self.parent[k][u].unwrap()]\n                } \n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if ((self.depth[v1] - self.depth[v0]) >> k & 1) > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        assert!(self.depth[v1] == self.depth[v0]);\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                assert!(self.parent[k][v0].is_some());\n                assert!(self.parent[k][v1].is_some());\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                if self.parent[k][u].is_some() {\n                    self.parent[k+1][u] = self.parent[k][self.parent[k][u].unwrap()]\n                } \n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (((self.depth[v1] - self.depth[v0]) >> k) & 1) > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        assert!(self.depth[v1] == self.depth[v0]);\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                assert!(self.parent[k][v0].is_some());\n                assert!(self.parent[k][v1].is_some());\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let log_n = (n as f64).log2().floor() as usize;\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let log_n = (n as f64).log2().ceil() as usize;\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let log_n = (n as f64).log2().floor() as usize;\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "//{{{\n#[allow(unused_macros)]\nmacro_rules! getl {\n    ( $( $t:ty ),* ) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            let s = s.trim_right();\n            let mut ws = s.split_whitespace();\n            ($(ws.next().unwrap().parse::<$t>().unwrap()),*)\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! getl_vec {\n    ( $t:ty ) => {{\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        let s = s.trim_right();\n        s.split_whitespace()\n            .map(|x| x.parse().unwrap())\n            .collect::<Vec<$t>>()\n    }};\n}\n//}}}\n\nfn main() {\n    let n = getl!(usize);\n    let mut graph: Vec<Vec<usize>> = vec![vec![]; n];\n    for i in 0..n {\n        let v = getl_vec!(usize);\n        graph[i] = v[1..].to_owned();\n    }\n    let q = getl!(usize);\n    let mut queries = vec![];\n    for _ in 0..q {\n        let (u, v) = getl!(usize, usize);\n        queries.push((u, v));\n    }\n\n    let lca = Lca::new(0, &graph);\n\n    for (u, v) in queries {\n        let ans = lca.lca(u, v);\n        println!(\"{}\", ans);\n    }\n}\n\nstruct Lca {\n    id: Vec<usize>,\n    segtree: SegmentTree<Option<usize>>,\n}\n\nimpl<'a> Lca {\n    fn new(root: usize, graph: &Vec<Vec<usize>>) -> Lca {\n        let n = graph.len();\n        let mut k = 0;\n        let mut id = vec![0; n];\n        let mut vs = vec![0; n * 2 - 1];\n        let mut depth = vec![0; n];\n        Lca::dfs(root, None, 0, &mut k, &mut id, &mut vs, &mut depth, &graph);\n\n        let op = move |i: Option<usize>, j: Option<usize>| -> Option<usize> {\n            match (i, j) {\n                (Some(i), Some(j)) => {\n                    if depth[i] <= depth[j] {\n                        Some(i)\n                    } else {\n                        Some(j)\n                    }\n                }\n                (Some(i), None) => Some(i),\n                (None, Some(j)) => Some(j),\n                (None, None) => None,\n            }\n        };\n        let segtree = SegmentTree::new(&vs.iter().map(|x| Some(*x)).collect(), Box::new(op), None);\n\n        let lca = Lca { id: id, segtree: segtree };\n\n        lca\n    }\n\n    fn lca(&self, u: usize, v: usize) -> usize {\n        use std::cmp::{max, min};\n        self.segtree\n            .query(min(self.id[u], self.id[v]), max(self.id[u], self.id[v]) + 1)\n            .unwrap()\n    }\n\n    fn dfs(\n        v: usize,\n        parent: Option<usize>,\n        d: usize,\n        k: &mut usize,\n        id: &mut Vec<usize>,\n        vs: &mut Vec<usize>,\n        depth: &mut Vec<usize>,\n        graph: &Vec<Vec<usize>>,\n    ) {\n        id[v] = *k;\n        vs[*k] = v;\n        depth[v] = d;\n        *k += 1;\n\n        for &next in graph[v].iter().filter(|x| match parent {\n            Some(p) => **x != p,\n            None => true,\n        }) {\n            Lca::dfs(next, Some(v), d + 1, k, id, vs, depth, graph);\n            vs[*k] = v;\n            *k += 1;\n        }\n    }\n}\n\nstruct SegmentTree<T> {\n    len: usize,\n    data: Vec<T>,\n    operator: Box<Fn(T, T) -> T>,\n    unit: T,\n}\n\nimpl<T> SegmentTree<T>\nwhere\n    T: Clone + Copy,\n{\n    fn new(v: &Vec<T>, operator: Box<Fn(T, T) -> T>, unit: T) -> SegmentTree<T> {\n        let n = v.len();\n        let mut len = 1;\n        while len < n {\n            len *= 2;\n        }\n\n        let mut segtree = SegmentTree {\n            len: len,\n            data: vec![unit; 2 * len - 1],\n            operator: operator,\n            unit: unit,\n        };\n\n        for i in 0..n {\n            segtree.data[i + segtree.len - 1] = v[i];\n        }\n        for i in (0..(segtree.len - 1)).rev() {\n            segtree.data[i] = (segtree.operator)(segtree.data[2 * i + 1], segtree.data[2 * i + 2]);\n        }\n\n        segtree\n    }\n\n    #[allow(unused)]\n    fn update(&mut self, k: usize, a: T) {\n        let data = &mut self.data;\n        let mut k = k + self.len - 1;\n        data[k] = a;\n        while k > 0 {\n            k = (k - 1) / 2;\n            data[k] = (self.operator)(data[k * 2 + 1], data[k * 2 + 2]);\n        }\n    }\n\n    #[allow(unused)]\n    fn get(&self, k: usize) -> T {\n        self.data[k + self.len - 1]\n    }\n\n    fn query(&self, a: usize, b: usize) -> T {\n        self.process_query(a, b, 0, 0, self.len)\n    }\n\n    fn process_query(&self, a: usize, b: usize, k: usize, l: usize, r: usize) -> T {\n        if r <= a || b <= l {\n            return self.unit;\n        }\n\n        if a <= l && r <= b {\n            self.data[k]\n        } else {\n            let vl = self.process_query(a, b, k * 2 + 1, l, (l + r) / 2);\n            let vr = self.process_query(a, b, k * 2 + 2, (l + r) / 2, r);\n            (self.operator)(vl, vr)\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn main() {\n    let mut sc = Scanner::new();\n    let n = sc.read::<usize>();\n    let mut graph = (0..n).map(|_| Vec::new()).collect::<Vec<_>>();\n    for i in 0..n {\n        let k = sc.read::<usize>();\n        for _ in 0..k {\n            let c: usize = sc.read();\n            graph[i].push(c);\n            graph[c].push(i);\n        }\n    }\n\n    let lca = LowestCommonAncestor::new(&graph);\n\n    let q: usize = sc.read();\n    for _ in 0..q {\n        let u: usize = sc.read();\n        let v: usize = sc.read();\n        println!(\"{}\", lca.get_lca(u, v));\n    }\n}\n\nstruct LowestCommonAncestor {\n    graph: Vec<Vec<usize>>,\n    parent: Vec<Vec<i32>>,\n    depth: Vec<usize>,\n    root: usize,\n    log_v: usize,\n}\n\nimpl LowestCommonAncestor {\n    fn new(graph: &Vec<Vec<usize>>) -> LowestCommonAncestor {\n        let v = graph.len();\n        let root = 0;\n        let graph = graph.clone();\n        let mut depth = vec![0; v];\n\n        let mut log_v = 1;\n        let mut i = 1;\n        while i <= v {\n            i *= 2;\n            log_v += 1;\n        }\n        let mut parent: Vec<Vec<i32>> = vec![vec![0; v]; log_v];\n\n        let mut depth_vis = vec![false; v];\n        let mut stack = VecDeque::new();\n        stack.push_front(root);\n        parent[0][root] = -1;\n        depth[root] = 0;\n        depth_vis[root] = true;\n        while !stack.is_empty() {\n            let v = stack.pop_front().unwrap();\n            stack.push_front(v);\n            for u in &graph[v] {\n                let u = *u;\n                if depth_vis[u] { continue; }\n                parent[0][u] = v as i32;\n                depth[u] = depth[v] + 1;\n                depth_vis[u] = true;\n                stack.push_front(u);\n            }\n\n            let head = stack.pop_front().unwrap();\n            if head != v { stack.push_front(head); }\n        }\n\n        for k in 0..(log_v - 1) {\n            for u in 0..v {\n                parent[k + 1][u] = if parent[k][u] < 0 {\n                    -1\n                } else {\n                    parent[k][parent[k][u] as usize]\n                };\n            }\n        }\n\n        LowestCommonAncestor { graph: graph, parent: parent, depth: depth, root: root, log_v: log_v }\n    }\n\n    fn get_lca(&self, u: usize, v: usize) -> usize {\n        let (mut u, mut v) = if self.depth[u] <= self.depth[v] { (u, v) } else { (v, u) };\n        for k in 0..self.log_v {\n            if ((self.depth[v] - self.depth[u]) & (1 << k)) != 0 {\n                v = self.parent[k][v] as usize;\n            }\n        }\n        if u == v { return u; }\n\n        for k in (0..self.log_v).rev() {\n            if self.parent[k][u] != self.parent[k][v] {\n                u = self.parent[k][u] as usize;\n                v = self.parent[k][v] as usize;\n            }\n        }\n        return self.parent[0][u] as usize;\n    }\n\n    fn get_dist(&self, u: usize, v: usize) -> usize {\n        let lca = self.get_lca(u, v);\n        self.depth[u] + self.depth[v] - self.depth[lca] * 2\n    }\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let log_n = (n as f64).log2().floor() as usize;\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().ceil() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                if self.parent[k][u].is_some() {\n                    self.parent[k+1][u] = self.parent[k][self.parent[k][u].unwrap()]\n                } \n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (((self.depth[v1] - self.depth[v0]) >> k) & 1) > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        assert!(self.depth[v1] >= self.depth[v0]);\n        assert!(self.depth[v1] == self.depth[v0]);\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                assert!(self.parent[k][v0].is_some());\n                assert!(self.parent[k][v1].is_some());\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct LCA <'a> {\n    root: usize,\n    tree: &'a [Vec<usize>],\n    parent: Vec<Vec<Option<usize>>>,\n    depth: Vec<u32>,\n}\n\nimpl <'a> LCA<'a> {\n    fn new(root: usize, tree: &'a [Vec<usize>]) -> Self {\n        let n = tree.len();\n        let mut log_n = (n as f64).log2().floor() as usize;\n        if log_n == 0 {\n            log_n = 1;\n        }\n        assert!(log_n > 0);\n        Self {\n            root,\n            tree,\n            parent: vec![vec![None; n]; log_n],\n            depth: vec![0; n],\n        }\n    }\n    // store direct parent and depth\n    fn dfs(&mut self, u: usize, parent: Option<usize>, depth: u32) {\n        self.parent[0][u] = parent;\n        self.depth[u] = depth;\n        for i in 0 .. self.tree[u].len() {\n            let v = self.tree[u][i];\n            if Some(v) != parent {\n                self.dfs(v, Some(u), depth+1);\n            }\n        }\n    }\n    fn build(&mut self) {\n        let root = self.root;\n        self.dfs(root, None, 0);\n\n        let mut k = 0;\n        while k+1 < self.parent.len() {\n            for u in 0 .. self.tree.len() {\n                self.parent[k+1][u] = if self.parent[k][u].is_some() {\n                    self.parent[k][self.parent[k][u].unwrap()]\n                } else {\n                    None\n                }\n            }\n            k += 1;\n        }\n    }\n    fn lca(&self, u: usize, v: usize) -> usize {\n        let (mut v0, mut v1) = if self.depth[u] <= self.depth[v] {\n            (u, v)\n        } else {\n            (v, u)\n        };\n        assert!(self.depth[v1] >= self.depth[v0]);\n\n        // move v1 up until depth of v0 and v1 gets equal.\n        for k in 0 .. self.parent.len() {\n            if (self.depth[v1] - self.depth[v0]) >> k & 1 > 0 {\n                assert!(self.parent[k][v1].is_some());\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        if (v0 == v1) {\n            return v0;\n        }\n        for k in (0..self.parent.len()).rev() {\n            // LCA's parent is LCA\n            if self.parent[k][v0] != self.parent[k][v1] {\n                v0 = self.parent[k][v0].unwrap();\n                v1 = self.parent[k][v1].unwrap();\n            }\n        }\n        return self.parent[0][v0].unwrap();\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        N: usize,\n    }\n    let mut tree = vec![vec![]; N];\n    for i in 0..N {\n        input! {\n            parser = parser,\n            k: usize,\n        }\n        input! {\n            parser = parser,\n            cs: [usize; k]\n        }\n        for c in cs {\n            tree[i].push(c);\n            tree[c].push(i);\n        }\n    }\n\n    let mut lca = LCA::new(0, &tree);\n    lca.build();\n\n    input! {\n        parser = parser,\n        Q: usize,\n        qs: [(usize, usize); Q]\n    }\n    for (u,v) in qs {\n        let p = lca.lca(u, v);\n        println!(\"{}\", p);\n    }\n}\n"
  }
]