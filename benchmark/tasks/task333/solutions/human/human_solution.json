[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass UnionFind{\npublic:\n  vector<int> par, rank;\n\n  void init(int n){\n    par.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) par[x] = par[y];\n    else{\n      par[y] = par[x];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n};\n\ntypedef pair<int, int> P; // to, cost\nconst int MAX = 1005;\nmap<string, int> M;\nUnionFind uf;\nint cost[MAX],n;\nvector<P> E[MAX];\nbool used[MAX];\n\nint get_index(const string& s){\n  if(M.count(s)) return M[s];\n  else return M[s] = M.size()-1;\n}\n\nvoid init(){\n  uf.init(n);\n  M.clear();\n  for(int i = 0; i < MAX; i++) E[i].clear();\n}\n\nvoid input(){\n  for(int i = 0; i < n; i++){\n    string a,b;\n    int c,d;\n    cin >> a >> c >> b >> d;\n    cost[get_index(a)] = c;\n    get_index(b);\n    if(a == b) continue;\n    E[get_index(b)].push_back(P(get_index(a), d));\n    //    cout << b << \" -> \" << a << endl;\n    uf.unite(get_index(a), get_index(b));\n  }\n}\n\nvoid dfs(int pos, P& p){ // vertex cost\n  \n  if(used[pos]) return;\n  used[pos] = true;\n  p.first++;\n\n  for(int i = 0; i < (int)E[pos].size(); i++){\n    if(!used[E[pos][i].first]){\n      dfs(E[pos][i].first, p);\n      p.second += E[pos][i].second;\n    }\n  }\n}\n\nvoid solve(){\n  vector<int> v[MAX];\n  for(int i = 0; i < n; i++) v[uf.find(i)].push_back(i);\n \n  int ans = 0;\n\n  for(int i = 0; i < MAX; i++){\n    if(v[i].size() == 0) continue;\n    int tmp = -1;\n    for(int j = 0; j < (int)v[i].size(); j++){\n      memset(used, false, sizeof(used));\n      P p = P(0,0);\n      dfs(v[i][j],p);\n      p.second += cost[v[i][j]];\n/*******      if(v[i][j] == 0){\n        cout << p.first << \" \" << p.second << endl;\n        }*/\n      if((p.first == (int)v[i].size()) && (tmp == -1 || tmp > p.second)) tmp = p.second;\n    }\n    ans += tmp;\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  \n  while(cin >> n && n){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nstruct Edge{\n  int to,cost;\n  Edge(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\nmap<string,int> mp;\nint day1[1100],N,par[1100],mp_idx;\nvector<Edge> G[1100];\nbool used[1100];\n\ninline int getIndex(string s){\n  if( mp.find(s) == mp.end() ) return mp[s] = mp_idx++;\n  return mp[s];\n}\n\ninline void init(){\n  mp_idx = 0;\n  mp.clear();\n  rep(i,N) G[i].clear(), par[i] = i;\n}\n\nint find(int x){\n  if( par[x] == x ) return par[x];\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nvoid dfs(int cur,int &cost){\n  if( used[cur] ) return;\n  used[cur] = true;\n  rep(i,(int)G[cur].size()){\n    int to = G[cur][i].to;\n    if( !used[to] && par[cur] == par[to] ){\n      cost += G[cur][i].cost;\n      dfs(to,cost);\n    }\n  }\n}\n\ninline void compute(){\n  set<int> S;\n  rep(i,N) S.insert(find(i));\n  int cnt = S.size();\n  int mincost[N];\n  rep(i,N) mincost[i] = IINF;\n  rep(i,N){\n    int idx = par[i];\n    int cost = day1[i];\n    rep(j,N) used[j] = false;\n    dfs(i,cost);\n\n    rep(j,N) if( !used[j] ) cost += day1[j];\n    mincost[idx] = min(mincost[idx],cost);\n  }\n  int ans = 0;\n  for( int i : S ) ans += mincost[i];\n  cout << ans << endl;\n}\n\nint main(){\n  while( cin >> N, N ){\n\n    init();\n    rep(i,N){\n      string a,b;\n      int c,d;\n      cin >> a >> c >> b >> d;\n      int ia = getIndex(a);\n      day1[ia] = c;\n      int ib = getIndex(b);\n      if( ia == ib ) continue;\n      G[ib].push_back(Edge(ia,d));\n      unit(ia,ib);\n    }\n\n    compute();\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef vector<vector<int> > graph;\n\nvoid getReversedGraph(graph& G, graph* rG) {\n    *rG = graph(G.size());\n    for (int i = 0; i < (int)G.size(); i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            (*rG)[G[i][j]].push_back(i);\n        }\n    }\n}\n\nvoid getSCCGraph(graph& G, graph* SCCGraph, vector<int>* table) {\n    const int V = G.size();\n    graph rG;\n    vector<vector<int> > SCCList;\n    vector<int> postOrder;\n    bool *used = new bool[V];\n    int *nextIndex = new int[V];\n    *table = vector<int>(V);\n    getReversedGraph(G, &rG);\n\n    // DFS\n    for (int i = 0; i < V; i++) {\n        used[i] = false;\n        nextIndex[i] = 0;\n    }\n\n    for (int i = 0; i < V; i++) {\n        if (used[i]) {\n            continue;\n        }\n        used[i] = true;\n        stack<int> st;\n        st.push(i);\n        while (!st.empty()) {\n            int v = st.top();\n            if (nextIndex[v] == (int)G[v].size()) {\n                postOrder.push_back(v);\n                st.pop();\n            } else {\n                int newv = G[v][nextIndex[v]];\n                if (!used[newv]) {\n                    st.push(newv);\n                    used[newv] = true;\n                }\n                nextIndex[v]++;\n            }\n        }\n    }\n    // Reversed DFS\n    for (int i = 0; i < V; i++) {\n        used[i] = false;\n        nextIndex[i] = 0;\n    }\n\n    int it = 0;\n    for (int i = V - 1; i >= 0; i--) {\n        int index = postOrder[i];\n        if (used[index]) {\n            continue;\n        }\n        used[index] = true;\n        (*table)[index] = it;\n        stack<int> st;\n        vector<int> list;\n        st.push(index);\n        list.push_back(index);\n        while (!st.empty()) {\n            int v = st.top();\n            if (nextIndex[v] == (int)rG[v].size()) {\n                st.pop();\n            } else {\n                int newv = rG[v][nextIndex[v]];\n                if (!used[newv]) {\n                    st.push(newv);\n                    list.push_back(newv);\n                    used[newv] = true;\n                    (*table)[newv] = it;\n                }\n                nextIndex[v]++;\n            }\n        }\n        SCCList.push_back(list);\n        it++;\n    }\n\n    // create new graph;\n    const int compressedV = it;\n    *SCCGraph = graph(compressedV);\n \n    for (int i = 0; i < compressedV; i++) {\n        map<int, bool> edgeUsed;\n        for (int j = 0; j < (int)SCCList[i].size(); j++) {\n            int v = SCCList[i][j];\n            for (int k = 0; k < (int)G[v].size(); k++) {\n                int w = G[v][k];\n                // v -> w\n                if (!edgeUsed[(*table)[w]]) {\n                    edgeUsed[(*table)[w]] = true;\n                    if (i != (*table)[w]) (*SCCGraph)[i].push_back((*table)[w]);\n                }\n            }\n        }\n    }\n\n    delete[] used;\n    delete[] nextIndex;\n}\n\nbool used[2005];\n\nvoid check(int v, graph& G, bool* used) {\n    if (used[v])return;\n    used[v] = true;\n    rep(i, G[v].size()) {\n        check(G[v][i], G, used);\n    }\n}\n\nint solve(int n) {\n    string s1,s2;\n    int d1,d2;\n    graph G(n), sccG, rG;\n    vector<int> table;\n    map<string, int> toId;\n    map<int, int> plus;\n    int ans = 0;\n    int id = 0;\n    rep(i,n) {\n        cin >> s1 >> d1 >> s2 >> d2;\n        if (toId.find(s1) == toId.end()) {\n            toId[s1] = id;\n            id++;\n        }\n        if (toId.find(s2) == toId.end()) {\n            toId[s2] = id;\n            id++;\n        }\n        ans+= d2;\n        if (s1 != s2)G[toId[s2]].push_back(toId[s1]);\n        plus[toId[s1]] = d1 - d2;\n    }\n    \n    getSCCGraph(G, &sccG, &table);\n    rep(i, 2005)used[i] = false;\n    rep(i, sccG.size()) {\n        vector<int> p;\n        if (used[i])continue;\n        //cerr << i << endl;\n        //cerr << \"\\t\";\n        rep(j, table.size()) {\n            if (table[j] == i) {\n                p.push_back(plus[j]);\n                //cerr << j << \":\" << p[j] << \" \";\n            }\n        }\n        //cerr << endl;\n        sort(p.begin(), p.end());\n        ans += p[0];\n        check(i, sccG, used);\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        cout << solve(n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = 3000*1000;\nconst int N   = 2000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+= ori[a[j]];\n      else       tmp+=tool[a[j]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    assert(st[0] == now);\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,N){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    rep(i,M.size()){\n      if (!gvis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//55\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<deque>\n\nusing namespace std;\n\nint n;\nstring na[1000],su[1000];\nint d[1000],dd[1000];\nmap<string,int> m;\nvector<int> ds[1000];\nbool p[1000];\nint cut[1000];\n\nint dfs(int x){\n  if(p[x])return 0;\n  int s=p[m[su[x]]]?d[x]-dd[x]:0;\n  p[x]=true;\n  for(int i=0;i<ds[x].size();i++){\n    s+=dfs(ds[x][i]);\n  }\n  return s;\n}\n\nbool cmp(int a,int b){\n  return cut[a]>cut[b];\n}\n\nint main(){\n  while(cin>>n,n){\n    m.clear();\n    for(int i=0;i<n;i++){\n      cin>>na[i]>>d[i]>>su[i]>>dd[i];\n      m[na[i]]=i;\n    }\n    for(int i=0;i<n;i++){\n      ds[i].clear();\n    }\n    for(int i=0;i<n;i++){\n      ds[m[su[i]]].push_back(m[na[i]]);\n    }\n    for(int i=0;i<1000;i++){\n      fill(p,p+n,false);\n      cut[i]=dfs(i);\n    }\n    deque<int> ef(n);\n    for(int i=0;i<n;i++){\n      ef[i]=i;\n    }\n    sort(ef.begin(),ef.end(),cmp);\n    bool done[1000]={};\n    int a=0;\n    for(int i=0;i<n;i++){\n      for(int nt=0;nt<n;nt++){\n\tif(!done[nt]){\n\t  if(done[m[su[nt]]]){\n\t    a+=dd[nt];\n\t    done[nt]=true;\n\t    goto next;\n\t  }\n\t}\n      }\n      while(done[ef[0]]){\n\tef.pop_front();\n      }\n      a+=d[ef[0]];\n      done[ef[0]]=true;\n    next:\n      ;\n    }\n    cout<<a<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<string> s1(n), s2(n);\n        vector<int> t1(n), t2(n);\n        map<string, int> index;\n        for(int i=0; i<n; ++i){\n            cin >> s1[i] >> t1[i] >> s2[i] >> t2[i];\n            index[s1[i]] = i;\n        }\n\n        vector<int> sup(n);\n        vector<vector<int> > edges(n);\n        for(int i=0; i<n; ++i){\n            sup[i] = index[s2[i]];\n            if(s1[i] != s2[i])\n                edges[index[s2[i]]].push_back(i);\n        }\n\n        int ret = 0;\n        vector<bool> make(n, false);\n        for(int i=0; i<n; ++i){\n            if(make[i])\n                continue;\n\n            int j = i;\n            vector<bool> check(n, false);\n            while(!check[j]){\n                check[j] = true;\n                j = sup[j];\n            }\n\n            check.assign(n, false);\n            int k = j;\n            while(!check[j]){\n                if(t1[j] - t2[j] > t1[k] - t2[k])\n                    k = j;\n                check[j] = true;\n                j = sup[j];\n            }\n\n            ret += t1[k] - t2[k];\n            queue<int> q;\n            q.push(k);\n            while(!q.empty()){\n                int a = q.front();\n                q.pop();\n                ret += t2[a];\n                make[a] = true;\n\n                for(unsigned l=0; l<edges[a].size(); ++l){\n                    int b = edges[a][l];\n                    if(!make[b])\n                        q.push(b);\n                }\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<vector<int> > graph;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n\n\nvoid visit(graph& g, vector<int>& PostOrder, vector<bool>& visited, int ps)\n{\n\tvisited[ps]=1;\n\tint S=g[ps].size();\n\tREP(i,S)\n\t{\n\t\tint next=g[ps][i];\n\t\tif(visited[next]) continue;\n\t\tvisit(g, PostOrder, visited, next);\n\t}\n\t\n\tPostOrder.push_back(ps);\n}\n\nvoid walk(graph& g, vector<int>& in, int ps, int gcnt)\n{\n\tin[ps]=gcnt;\n\t\n\tint S=g[ps].size();\n\tREP(i,S)\n\t{\n\t\tint next=g[ps][i];\n\t\tif(in[next]!=-1) continue;\n\t\twalk(g,in,next,gcnt);\n\t}\n}\n\n//StronglyConnectedComponent\nint SCC(vector<int>& in, int V, graph& g, graph& rg)\n{\n\tint gcnt=0;\n\tvector<int> PostOrder;\n\tvector<bool> visited(V,false);\n\t\n\tREP(i,V)\n\t{\n\t\tif(visited[i]) continue;\n\t\tvisit(g,PostOrder,visited, i);\n\t}\n\t\t\n\tfor(int i=PostOrder.size()-1; i>=0; --i)\n\t{\n\t\tif(in[PostOrder[i]]==-1) \n\t\t{\n\t\t\twalk(rg,in,PostOrder[i],gcnt++);\n\t\t}\n\t}\n\n\treturn gcnt;\n}\n\nint recipe[1050], self[1050],reduce[1050];\n\nint dfs(int p, vector<bool>& use, graph& g, graph& c)\n{\n\tuse[p]=1;\n\n\tint ret=0;\n\tfor(int i=0; i<g[p].size(); i++)\n\t{\n\t\tint next=g[p][i];\n\t\tif(use[next]) continue;\n\t\tret+=dfs(next, use, g, c);\n\t\tret+=c[p][i];\n\t}\n\n\treturn ret;\n\n}\n\nint calc(vector<int>& v, vector<bool>& created, graph& g, graph& c)\n{\n\tvector<bool> use(10000, 1);\n\tfor(int i=0; i<v.size(); i++)\n\t\tuse[v[i]]=0;\n\n\tint ret=(1<<24);\n\tfor(int i=0; i<v.size(); i++)\n\t{\n\t\tvector<bool> u(use);\n\t\tint p=v[i], t=dfs(p,u,g,c);\n\t\tif(created[recipe[p]])  t+=reduce[p];\n\t\telse\t\t\t\t\tt+=self[p];\n\t\t\n\t\tret=min(ret, t);\n\t}\n\n\tfor(int i=0; i<v.size(); i++)\n\t\tcreated[v[i]]=1;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tgraph g(N), rg(N), c(N), rc(N);\n\n\t\tint dcnt=0;\n\t\tmap<string, int> dic;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tstring s,t;\n\t\t\tint a,b,u,v;\n\t\t\tcin >> s >> a >> t >> b;\n\n\t\t\tif(!dic.count(s)) dic[s]=dcnt++;\n\t\t\tif(!dic.count(t)) dic[t]=dcnt++;\n\t\t\t\n\t\t\tu=dic[s];\n\t\t\tv=dic[t];\n\n\t\t\t g[u].push_back(v);\n\t\t\trg[v].push_back(u);\n\t\t\t c[u].push_back(b);\n\t\t\trc[v].push_back(b);\n\n\t\t\tself[u]=a;\n\t\t\trecipe[u]=v;\n\t\t\treduce[u]=b;\n\t\t}\n\n\t\tvector<int> in(N, -1);\n\t\tint gcnt=SCC(in,N,rg,g);\n\n\t\tvector<vector<int> > loop(gcnt);\n\t\tfor(int i=0; i<N; i++)\n\t\t\tloop[in[i]].push_back(i);\n\n\t\tvector<bool> created(N, 0);\n\n\t\tint ans=0;\n\t\tfor(int i=0; i<gcnt; i++)\n\t\t{\n\t\t\tans+=calc(loop[i], created, rg, rc);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\n/*\n4\ngu 20 pa 10\nci 20 gu 10\npa 20 ci 10\nhoge 20 pa 10\n*/"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<string>\n#include<vector>\n#include<iostream>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector< vector<int> > vvi;\n\nconst int INF=1<<29;\n\nvoid GabowDFS(int u,vector<bool> &visited,vector<int> &nodes,const vvi &adj){\n\tif(visited[u]) return;\n\tvisited[u]=true;\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(!visited[v]) GabowDFS(v,visited,nodes,adj);\n\t}\n\tnodes.push_back(u);\n}\n\nvvi GabowSCC(const vvi &adj){\n\tint n=adj.size();\n\tvector<int> ord;\n\tvector<bool> visited(n);\n\trep(u,n) GabowDFS(u,visited,ord,adj);\n\n\tvvi radj(n);\n\trep(u,n) rep(i,adj[u].size()) radj[adj[u][i]].push_back(u);\n\n\tvvi sccs;\n\trep(u,n) visited[u]=false;\n\tfor(int i=n-1;i>=0;i--){\n\t\tint u=ord[i];\n\t\tvector<int> scc;\n\t\tGabowDFS(u,visited,scc,radj);\n\t\tif(scc.size()>0) sccs.push_back(scc);\n\t}\n\treturn sccs;\n}\n\nint main(){\n\tfor(int n;cin>>n,n;){\n\t\tint m=0;\n\t\tmap<string,int> f;\n\n\t\tvvi adj(n);\n\t\tint day1[1000],day2[1000];\n\t\trep(i,n){\n\t\t\tstring s1,s2;\n\t\t\tint d1,d2; cin>>s1>>d1>>s2>>d2;\n\t\t\tif(f.count(s1)==0) f[s1]=m++;\n\t\t\tif(f.count(s2)==0) f[s2]=m++;\n\n\t\t\tint u=f[s2],v=f[s1];\n\t\t\tadj[u].push_back(v);\n\t\t\tday1[v]=d1;\n\t\t\tday2[v]=d2;\n\t\t}\n\n\t\tvvi scc=GabowSCC(adj);\n\n\t\tint ans=0;\n\t\tbool tool[1000]={};\n\t\trep(i,scc.size()){\n\t\t\tint dif=INF;\n\t\t\tbool start=true;\n\t\t\trep(j,scc[i].size()){\n\t\t\t\tint u=scc[i][j];\n\t\t\t\tans+=day2[u];\n\t\t\t\tdif=min(dif,day1[u]-day2[u]);\n\t\t\t\tif(tool[u]) start=false;\n\t\t\t}\n\t\t\tif(start) ans+=dif;\n\n\t\t\trep(j,scc[i].size()){\n\t\t\t\tint u=scc[i][j];\n\t\t\t\trep(k,adj[u].size()) tool[adj[u][k]]=true;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//55\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    string na[1000],su[1000];\n    int d[1000],dd[1000];\n    map<string,int> m;\n    for(int i=0;i<n;i++){\n      cin>>na[i]>>d[i]>>su[i]>>dd[i];\n      m[na[i]]=i;\n    }\n    bool done[1000]={};\n    int a=0;\n    for(int i=0;i<n;i++){\n      int x,nd=1<<30;\n      for(int nt=0;nt<n;nt++){\n\tif(!done[nt]){\n\t  if(na[nt]==su[nt]||done[m[su[nt]]]){\n\t    a+=(na[nt]==su[nt])?d[nt]:dd[nt];\n\t    done[nt]=true;\n\t    goto next;\n\t  }\n\t  if(d[nt]-dd[nt]<nd){\n\t    nd=d[nt]-dd[nt];\n\t    x=nt;\n\t  }\n\t}\n      }\n      a+=d[x];\n      done[x]=true;\n    next:\n      ;\n    }\n    cout<<a<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef map<string,int> msi;\n\nstruct Tool {\n  string name, sup;\n  int day1, day2, i, si;\n\n  void print() {\n    printf(\"Tool: %s(%d):%d, %s(%d):%d\\n\",\n\t   name.c_str(), i, day1, sup.c_str(), si, day2);\n  }\n};\n\n/* global variables */\n\nint n;\nTool tools[MAX_N];\nmsi nhash;\nbool made[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    nhash.clear();\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      cin >> ti.name >> ti.day1 >> ti.sup >> ti.day2;\n      ti.i = i;\n      ti.si = -1;\n      nhash[ti.name] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      ti.si = nhash[ti.sup];\n      //ti.print();\n    }\n\n    int minday = 0, nu = n;\n    memset(made, false, sizeof(made));\n\n    // self dependent\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      if (i == ti.si) {\n\tmade[i] = true;\n\tnu--;\n\tminday += ti.day1;\n      }\n    }\n\n    // check if dep tool is already made\n    bool changed = true;\n    while (changed) {\n      changed = false;\n\n      for (int i = 0; i < n; i++) {\n\tTool& ti = tools[i];\n\tif (! made[i] && made[ti.si]) {\n\t  made[i] = true;\n\t  nu--;\n\t  minday += ti.day2;\n\t  changed = true;\n\t}\n      }\n    }\n    //printf(\"nu=%d, minday=%d\\n\", nu, minday);\n\n    // check loops\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      if (! made[i]) {\n\tint sumloop = tools[i].day2;\n\tmade[i] = true;\n\tvi li;\n\tfor (int j = tools[i].si; j != i; j = tools[j].si) {\n\t  made[j] = true;\n\t  sumloop += tools[j].day2;\n\t  li.push_back(j);\n\t}\n\n\tint minloop = INF;\n\tfor (vi::iterator lit = li.begin(); lit != li.end(); lit++) {\n\t  int lsum = sumloop + tools[*lit].day1 - tools[*lit].day2;\n\t  if (minloop > lsum) minloop = lsum;\n\t}\n\t//printf(\"  minloop=%d\\n\", minloop);\n\n\tminday += minloop;\n      }\n    }\n\n    cout << minday << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, ans;\nint t[1002];\nvector<P> g[1002];\nmap<string,int> name;\nbool used[1002], loop[1002];\n\nint getId(string s){\n  if(name.find(s) != name.end()){\n    return name[s];\n  }\n  int size = name.size();\n  return name[s] = size;\n}\n\nvoid solve(){\n  memset(used, 0, sizeof(used));\n\n  for(int i = 0; i < n; i++){\n    if(used[i]) continue;\n\n    memset(loop, 0, sizeof(loop));\n\n    int id = i;\n    bool flg = true;\n\n    while(!loop[id]){\n      if(used[id]){\n\tflg = false;\n\tbreak;\n      }\n\n      loop[id] = true;\n      used[id] = true;\n      id = g[id][0].first;\n    }\n    if(!flg) continue;\n\n    int start = id;\n    int minId = start;\n\n    id = g[start][0].first;\n\n    while(id != start){\n      if(t[minId] - g[minId][0].second > t[id] - g[id][0].second){\n\tminId = id;\n      }\n      id = g[id][0].first;\n    }\n\n    ans += t[minId] - g[minId][0].second;\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n, n){\n    ans = 0;\n    name.clear();\n\n    for(int i = 0; i < 1002; i++){\n      g[i].clear();\n    }\n\n    for(int i = 0; i < n; i++){\n      string FROM, TO;\n      int a, b;\n      cin >> FROM >> a >> TO >> b;\n\n      int from = getId(FROM);\n      int to = getId(TO);\n      t[from] = a;\n      g[from].push_back(P(to, b));\n      ans += b;\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<climits>\n#include<vector>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\nstruct S{int v1,v2,t;}s,t={0,0,-1};\nconst int N=1000;\nint main()\n{\n\tint n,i,j,k,r;\n\tchar x[64],y[64];\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tmap<string,int>m;\n\t\tvector<S>v;\n\t\tbool f[N]={0};\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tscanf(\"%s%d%s%d\",x,&s.v1,y,&s.v2);\n\t\t\tif(m.find(y)==m.end())m[y]=v.size(),v.push_back(t);\n\t\t\ts.t=m[y];if(m.find(x)==m.end())m[x]=v.size(),v.push_back(s);\n\t\t\telse v[m[x]]=s;\n\t\t}\n\t\tfor(r=i=0;i<v.size();++i)\n\t\t{\n\t\t\tif(f[i])continue;\n\t\t\tif(i==v[i].t)r+=v[i].v1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool c[N]={0};\n\t\t\t\tvector<int>u;\n\t\t\t\tfor(j=i;!f[i]&&!c[j];j=v[j].t)c[j]=1,u.push_back(j);\n\t\t\t\tif(i==j)\n\t\t\t\t{\n\t\t\t\t\tint a=INT_MAX,b;\n\t\t\t\t\tfor(j=0;j<u.size();++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tb=v[u[0]].v1;for(k=1;k<u.size();++k)b+=v[u[k]].v2;a=min(a,b);\n\t\t\t\t\t\tf[u[0]]=1;\t\trotate(u.begin(),u.begin()+1,u.end());}\n\t\t\t\t\tr+=a;\n\t\t\t\t}\n\t\t\t\telse r+=v[i].v2;\n\t\t\t}\n\t\t\tf[i]=1;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = 3000*1000;\nconst int N   = 1000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+=ori[a[i]];\n      else tmp+=tool[a[i]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,n){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    \n    rep(i,n){\n      if (!vis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint day1[1111],day2[1111];\nstring name[1111],sup[1111];\nconst int INF = 1000000007;\nvector<int> G[1111];\nvector<int> rG[1111];\n\nbool used[1111];\nvector<int> V[1111];\nvector<int> vs;\nvoid init(){\n  for(int i=0;i<N;i++) G[i].clear();\n  for(int i=0;i<N;i++) rG[i].clear();\n  for(int i=0;i<N;i++) V[i].clear();  \n}\nint dfs(int v){\n  if( used[v] ) return 0;\n  int res = 0;\n  used[v] = true;\n  for( int to : G[v] ){\n    res += dfs( to );\n  }\n  vs.push_back( v );\n  return res + day2[v];\n}\nvoid rdfs(int v,int cnt){\n  if( used[v] ) return;\n  used[v] = true;\n  for( int to : rG[v] ) {\n    rdfs( to, cnt );\n  }\n  V[cnt].push_back(v);\n}\nint scc(){\n  memset( used, 0, sizeof( used ) );\n  vs.clear();\n  for(int i=0;i<N;i++){\n    dfs( i );\n  }\n  memset( used, 0, sizeof( used ) );\n  reverse( vs.begin(), vs.end() );\n  int cnt = 0;\n  for(int v : vs ){\n    if( used[v] ) continue;    \n    rdfs( v, cnt++ );\n  }\n  return cnt;\n}\nvoid add_edge(int from,int to){\n  G[from].push_back( to );\n  rG[to].push_back( from );\n}\n\nint main(){\n  while( cin >> N && N ){\n    init();\n    map<string,int> H;\n    for(int i=0;i<N;i++){\n      cin >> name[i] >> day1[i] >> sup[i] >> day2[i];\n      H[name[i]] = i;\n    }\n    for(int i=0;i<N;i++)\n      add_edge( H[sup[i]], H[name[i]] );\n\n    int n = scc();\n    int res = 0;\n    memset( used, 0, sizeof( used ) );\n    for(int i=0;i<n;i++){\n      int sum = 0;\n      int min_pc = INF;\n      int nv = V[i].back();\n      if( used[nv] ) continue;\n      for( int v : V[i] ){\n        sum += day2[v];\n        min_pc = min( min_pc, day1[v] - day2[v] );\n      }\n      res += dfs(nv) + min_pc;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool used[1001];\nint n;\nvector<int> G[1001];\npii costs[1001];\nint idx=0;\nmap<string,int> indices;\nint nxt[1001];\nint in[1001];\nint sumCosts=0;\n\nvoid search1(int s){\n\tused[s]=true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch1(to);\n\t\t}\n\t\telse{\n\t\t\t// ÂHð­©µ½êAn_ÍmèÏÝÈÌÅAÁÉ½àsíÈ¢\n\t\t}\n\t}\n}\n// ü_ª ém[h©çTõðnßé\nvoid search2(int s){\n\tused[s]=true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch2(to);\n\t\t}\n\t\t// ÂHð­©µ½êAÂHÌÅÅàRXg·Ì¬³¢àÌðÌp\n\t\telse{\n\t\t\tvector<pii> v;\n\t\t\tint cur=s;\n\t\t\twhile(1){\n\t\t\t\tv.push_back(pii(costs[cur].first-costs[cur].second,cur));\n\t\t\t\tint to=nxt[cur];\n\t\t\t\tif(to==s)break;\n\t\t\t\tcur=to;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\tsumCosts+=costs[v[0].second].first;\n\t\t\tsumCosts-=costs[v[0].second].second;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tsumCosts=0;\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(used,0,sizeof(used));\n\t\tindices.clear();\n\t\tidx=0;\n\t\tfor(int i=0;i<1001;i++)G[i].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint c,d;\n\t\t\tcin>>a>>c>>b>>d;\n\t\t\tif(indices.find(a)==indices.end())indices[a]=idx++;\n\t\t\tif(indices.find(b)==indices.end())indices[b]=idx++;\n\t\t\tif(a!=b){\n\t\t\t\tG[indices[b]].push_back(indices[a]);\n\t\t\t\tin[indices[a]]++;\n\t\t\t}\n\t\t\tcosts[indices[a]]=pii(c,d);\n\t\t}\n\t\t// ü_ª³¢¨ðTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(in[i]==0){\n\t\t\t\t// ÅÌvfÍK¸æé\n\t\t\t\tsumCosts+=costs[i].first;\n\t\t\t\tsearch1(i);\n\t\t\t}\n\t\t}\n\t\t// Ü¾TõµÄ¢È¢àÌð·×ÄTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tsumCosts+=costs[i].second;\n\t\t\t\tsearch2(i);\n\t\t\t}\n\t\t}\n\t\tcout<<sumCosts<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<cassert>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = 3000*1000;\nconst int N   = 2000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+= ori[a[j]];\n      else       tmp+=tool[a[j]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    assert(st[0] == now);\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,N){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    rep(i,M.size()){\n      if (!gvis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<string> s1(n), s2(n);\n        vector<int> t1(n), t2(n);\n        map<string, int> index;\n        for(int i=0; i<n; ++i){\n            cin >> s1[i] >> t1[i] >> s2[i] >> t2[i];\n            index[s1[i]] = i;\n        }\n\n        vector<int> sup(n);\n        vector<vector<int> > edges(n);\n        for(int i=0; i<n; ++i){\n            sup[i] = index[s2[i]];\n            if(s1[i] != s2[i])\n                edges[index[s2[i]]].push_back(i);\n        }\n\n        int ret = 0;\n        vector<bool> make(n, false);\n        for(int i=0; i<n; ++i){\n            if(make[i])\n                continue;\n\n            int j = i;\n            vector<bool> check(n, false);\n            while(!check[j]){\n                check[j] = true;\n                j = sup[j];\n            }\n\n            check.assign(n, false);\n            int k = j;\n            while(!check[j]){\n                if(t1[j] - t2[j] < t1[k] - t2[k])\n                    k = j;\n                check[j] = true;\n                j = sup[j];\n            }\n\n            ret += t1[k] - t2[k];\n            queue<int> q;\n            q.push(k);\n            while(!q.empty()){\n                int a = q.front();\n                q.pop();\n                ret += t2[a];\n                make[a] = true;\n\n                for(unsigned l=0; l<edges[a].size(); ++l){\n                    int b = edges[a][l];\n                    if(!make[b])\n                        q.push(b);\n                }\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool used[1001];\nint n;\nvector<int> G[1001];\npii costs[1001];\nint idx=0;\nmap<string,int> indices;\nint nxt[1001];\nint in[1001];\nint sumCosts=0;\n\nvoid search1(int s){\n\tused[s]=true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch1(to);\n\t\t}\n\t\telse{\n\t\t\t// ÂHð­©µ½êAn_ÍmèÏÝÈÌÅAÁÉ½àsíÈ¢\n\t\t}\n\t}\n}\n// ü_ª ém[h©çTõðnßé\nvoid search2(int s){\n\tused[s]=true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch2(to);\n\t\t}\n\t\t// ÂHð­©µ½êAÂHÌÅÅàRXg·Ì¬³¢àÌðÌp\n\t\telse{\n\t\t\tvector<pii> v;\n\t\t\tv.push_back(pii(costs[s].first-costs[s].second,s));\n\t\t\tint cur=to;\n\t\t\twhile(1){\n\t\t\t\tv.push_back(pii(costs[cur].first-costs[cur].second,cur));\n\t\t\t\tint tto=nxt[cur];\n\t\t\t\tif(tto==s)break;\n\t\t\t\tcur=tto;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\tsumCosts+=costs[v[0].second].first;\n\t\t\tsumCosts-=costs[v[0].second].second;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tsumCosts=0;\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(used,0,sizeof(used));\n\t\tindices.clear();\n\t\tidx=0;\n\t\tfor(int i=0;i<1001;i++)G[i].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint c,d;\n\t\t\tcin>>a>>c>>b>>d;\n\t\t\tif(indices.find(a)==indices.end())indices[a]=idx++;\n\t\t\tif(indices.find(b)==indices.end())indices[b]=idx++;\n\t\t\tif(a!=b){\n\t\t\t\tG[indices[b]].push_back(indices[a]);\n\t\t\t\tin[indices[a]]++;\n\t\t\t}\n\t\t\tcosts[indices[a]]=pii(c,d);\n\t\t}\n\t\t// ü_ª³¢¨ðTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(in[i]==0){\n\t\t\t\t// ÅÌvfÍK¸æé\n\t\t\t\tsumCosts+=costs[i].first;\n\t\t\t\tsearch1(i);\n\t\t\t}\n\t\t}\n\t\t// Ü¾TõµÄ¢È¢àÌð·×ÄTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tsumCosts+=costs[i].second;\n\t\t\t\tsearch2(i);\n\t\t\t}\n\t\t}\n\t\tcout<<sumCosts<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = 3000*1000;\nconst int N   = 2000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+= ori[a[j]];\n      else       tmp+=tool[a[j]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,N){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    rep(i,M.size()){\n      if (!gvis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nstruct Edge{\n  int to,cost;\n  Edge(int to=IINF,int cost=IINF):to(to),cost(cost){}\n};\n\nmap<string,int> mp;\nint day1[1100],N,par[1100],mp_idx;\nvector<Edge> G[1100];\nbool used[1100];\n\ninline int getIndex(string s){\n  if( mp.find(s) == mp.end() ) return mp[s] = mp_idx++;\n  return mp[s];\n}\n\ninline void init(){\n  mp_idx = 0;\n  mp.clear();\n  rep(i,N) G[i].clear(), par[i] = i;\n}\n\nint find(int x){\n  if( par[x] == x ) return par[x];\n  return par[x] = find(par[x]);\n}\n\ninline void unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = par[y];\n}\n\nvoid dfs(int cur,int &cost){\n  if( used[cur] ) return;\n  used[cur] = true;\n  rep(i,(int)G[cur].size()){\n    int to = G[cur][i].to;\n    if( !used[to] && par[cur] == par[to] ){\n      cost += G[cur][i].cost;\n      dfs(to,cost);\n    }\n  }\n}\n\ninline void compute(){\n  set<int> S;\n  rep(i,N) S.insert(find(i));\n  int cnt = S.size();\n  int mincost[N];\n  rep(i,N) mincost[i] = IINF;\n  rep(i,N){\n    int idx = par[i];\n    int cost = day1[i];\n    rep(j,N) used[j] = false;\n    dfs(i,cost);\n    rep(j,N) if( !used[j] && par[j] == par[i] ) cost += day1[j];\n    mincost[idx] = min(mincost[idx],cost);\n  }\n  int ans = 0;\n  for( int i : S ) ans += mincost[i];\n  cout << ans << endl;\n}\n\nint main(){\n  while( cin >> N, N ){\n\n    init();\n    rep(i,N){\n      string a,b;\n      int c,d;\n      cin >> a >> c >> b >> d;\n      int ia = getIndex(a);\n      day1[ia] = c;\n      int ib = getIndex(b);\n      if( ia == ib ) continue;\n      G[ib].push_back(Edge(ia,d));\n      unit(ia,ib);\n    }\n\n    compute();\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<vector<int> > graph;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n\n\nvoid visit(graph& g, vector<int>& PostOrder, vector<bool>& visited, int ps)\n{\n\tvisited[ps]=1;\n\tint S=g[ps].size();\n\tREP(i,S)\n\t{\n\t\tint next=g[ps][i];\n\t\tif(visited[next]) continue;\n\t\tvisit(g, PostOrder, visited, next);\n\t}\n\t\n\tPostOrder.push_back(ps);\n}\n\nvoid walk(graph& g, vector<int>& in, int ps, int gcnt)\n{\n\tin[ps]=gcnt;\n\t\n\tint S=g[ps].size();\n\tREP(i,S)\n\t{\n\t\tint next=g[ps][i];\n\t\tif(in[next]!=-1) continue;\n\t\twalk(g,in,next,gcnt);\n\t}\n}\n\n//StronglyConnectedComponent\nint SCC(vector<int>& in, int V, graph& g, graph& rg)\n{\n\tint gcnt=0;\n\tvector<int> PostOrder;\n\tvector<bool> visited(V,false);\n\t\n\tREP(i,V)\n\t{\n\t\tif(visited[i]) continue;\n\t\tvisit(g,PostOrder,visited, i);\n\t}\n\t\t\n\tfor(int i=PostOrder.size()-1; i>=0; --i)\n\t{\n\t\tif(in[PostOrder[i]]==-1) \n\t\t{\n\t\t\twalk(rg,in,PostOrder[i],gcnt++);\n\t\t}\n\t}\n\n\treturn gcnt;\n}\n\nint recipe[1050], self[1050],reduce[1050];\n\nint dfs(int p, vector<bool>& use, graph& g, graph& c)\n{\n\tuse[p]=1;\n\n\tint ret=0;\n\tfor(int i=0; i<g[p].size(); i++)\n\t{\n\t\tint next=g[p][i];\n\t\tif(use[next]) continue;\n\t\tret+=dfs(next, use, g, c);\n\t\tret+=c[p][i];\n\t}\n\n\treturn ret;\n\n}\n\nint calc(vector<int>& v, vector<bool>& created, graph& g, graph& c)\n{\n\tvector<bool> use(10000, 1);\n\tfor(int i=0; i<v.size(); i++)\n\t\tuse[v[i]]=0;\n\n\tint ret=0,mn=(1<<24),r;\n\tif(v.size()==1)\n\t{\n\t\tint p=v[0];\n\t\tif(created[recipe[p]]) ret=reduce[p];\n\t\telse ret=self[p];\n\t}\n\telse\n\t{\n\t\tfor(int i=0; i<v.size(); i++)\n\t\t{\n\t\t\tint p=v[i];\n\t\t\tif(self[p]-reduce[p]<mn)\n\t\t\t{\n\t\t\t\tr=p;\n\t\t\t\tmn=self[p]-reduce[p];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<v.size(); i++)\n\t\t{\n\t\t\tint p=v[i];\n\t\t\tif(p==r) ret+=self[p];\n\t\t\telse ret+=reduce[p];\n\t\t}\n\t}\n\n\tfor(int i=0; i<v.size(); i++)\n\t\tcreated[v[i]]=1;\n\n\treturn ret;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tgraph g(N), rg(N), c(N), rc(N);\n\n\t\tint dcnt=0;\n\t\tmap<string, int> dic;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tstring s,t;\n\t\t\tint a,b,u,v;\n\t\t\tcin >> s >> a >> t >> b;\n\n\t\t\tif(!dic.count(s)) dic[s]=dcnt++;\n\t\t\tif(!dic.count(t)) dic[t]=dcnt++;\n\t\t\t\n\t\t\tu=dic[s];\n\t\t\tv=dic[t];\n\n\t\t\t g[u].push_back(v);\n\t\t\trg[v].push_back(u);\n\t\t\t c[u].push_back(b);\n\t\t\trc[v].push_back(b);\n\n\t\t\tself[u]=a;\n\t\t\trecipe[u]=v;\n\t\t\treduce[u]=b;\n\t\t}\n\n\t\tvector<int> in(N, -1);\n\t\tint gcnt=SCC(in,N,rg,g);\n\n\t\tvector<vector<int> > loop(gcnt);\n\t\tfor(int i=0; i<N; i++)\n\t\t\tloop[in[i]].push_back(i);\n\n\t\tvector<bool> created(N, 0);\n\n\t\tint ans=0;\n\t\tfor(int i=0; i<gcnt; i++)\n\t\t{\n\t\t\tans+=calc(loop[i], created, rg, rc);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint main(){\n    int n;\n    while(cin >> n && n){\n        vector<string> name(n), sup(n);\n        vector<int> high(n), low(n);\n        REP(i, n) cin >> name[i] >> high[i] >> sup[i] >> low[i];\n        map<string, int> index;\n        REP(i, n) index[ name[i] ] = i;\n        vector<int> color(n, 0);\n        int ans = 0;\n        REP(i, n) if(color[i] == 0){\n            vector<int> list;\n            int u = i;\n            while(color[u] == 0){\n                list.push_back(u);\n                color[u] = 1;\n                u = index[ sup[u] ];\n            }\n            if(color[u] == 1){\n                int min_sum = INT_MAX;\n                bool in_roop = false;\n                for(int h : list){\n                    if(h == u) in_roop = true;\n                    if(!in_roop) continue;\n                    int sum = 0;\n                    for(int li : list){\n                        sum += (li == h ? high[li] : low[li]);\n                    }\n                    if(min_sum > sum) min_sum = sum;\n                }\n                ans += min_sum;\n            }else if(color[u] == 2){\n                for(int li : list){\n                    ans += low[li];\n                }\n            }\n            for(int li : list){\n                color[li] = 2;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = 3000*1000;\nconst int N   = 2000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+= ori[a[j]];\n      else       tmp+=tool[a[j]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,N){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n      ori[i]=0;\n      tool[i]=0;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    rep(i,M.size()){\n      if (!gvis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef map<string,int> msi;\n\nstruct Tool {\n  string name, sup;\n  int day1, day2, diff, i, si;\n\n  void print() {\n    printf(\"Tool: %s(%d):%d, %s(%d):%d\\n\",\n\t   name.c_str(), i, day1, sup.c_str(), si, day2);\n  }\n};\n\n/* global variables */\n\nint n;\nTool tools[MAX_N];\nmsi nhash;\n\nbool used[MAX_N], tmpused[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    nhash.clear();\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      cin >> ti.name >> ti.day1 >> ti.sup >> ti.day2;\n      ti.diff = ti.day1 - ti.day2;\n      ti.i = i;\n      ti.si = -1;\n      nhash[ti.name] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      ti.si = nhash[ti.sup];\n      //ti.print();\n    }\n\n    memset(used, false, sizeof(used));\n\n    int minsum = 0;\n    \n    // find loops\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      if (! used[i]) {\n\tmemset(tmpused, false, sizeof(tmpused));\n\ttmpused[i] = true;\n\tint j = ti.si;\n\tfor (; ! tmpused[j]; j = tools[j].si) {\n\t  if (used[j]) break;\n\t  tmpused[j] = true;\n\t}\n\tif (used[j]) continue;\n\n\tint sumloop = tools[j].day2;\n\tint mindiff = tools[j].diff;\n\n\tused[j] = true;\n\tfor (int k = tools[j].si; k != j; k = tools[k].si) {\n\t  used[k] = true;\n\t  sumloop += tools[k].day2;\n\t  if (mindiff > tools[k].diff) mindiff = tools[k].diff;\n\t}\n\n\tminsum += sumloop + mindiff;\n      }\n    }\n    //cout << ln << endl;\n\n    // check leafs\n    bool changed = true;\n    while (changed) {\n      changed = false;\n\n      for (int i = 0; i < n; i++) {\n\tTool& ti = tools[i];\n\tif (! used[i] && used[ti.si]) {\n\t  used[i] = true;\n\t  minsum += ti.day2;\n\t  changed = true;\n\t}\n      }\n    }\n    \n    cout << minsum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint next[1010];\nint difc[1010];\nint effc[1010];\nstring str[1010];\nbool add[1010];\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    map<string,int> m;\n    int ans = 0;\n    REP(i,n){\n      string name;\n      cin>>name>>difc[i]>>str[i]>>effc[i];\n      m[name] = i;\n      add[i] = false;\n    }\n\n    REP(i,n){\n      next[i] = m[str[i]];\n    }\n\n    //non-cycle\n    REP(i,n) if(!add[i]){\n      //find-cycle\n      int j = next[i];\n      int jj;\n      vector<bool> f(n, false);\n      int diff;\n      ans += effc[i];\n      f[i] = true;\n      add[i] = true;\n\n      while(true){\n        if(f[j]){\n          //cycle\n          break;\n        }\n        if(add[j])\n          goto end;\n\n        f[j] = true;\n        ans += effc[j];\n        add[j] = true;\n\n        j = next[j];\n      }\n      diff = difc[j] - effc[j];\n      jj = next[j];\n      while(jj != j){\n        diff = max(diff, difc[jj] - effc[jj]);\n        jj = next[jj];\n      }\n      ans += diff;\n    end:;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint day1,sup_id,day2;\n\tchar name[33],sup_name[33];\n};\n\nint N,com,x,y;\nint height[1000],parent[1000],num_in[1000];\n\nInfo info[1000];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nint find(int x){\n\tif(x == parent[x])return x;\n\telse{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n\nbool isSame(int x,int y){\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)return;\n\n\tif(height[x] < height[y]){\n\t\tparent[x] = y;\n\t}else{\n\t\tparent[y] = x;\n\t\tif(height[x] == height[y])height[x]++;\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %s %d\",info[i].name,&info[i].day1,info[i].sup_name,&info[i].day2);\n\t}\n\n\tfor(int i = 0; i < N; i++)num_in[i] = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(strCmp(info[k].name,info[i].sup_name)){\n\t\t\t\tinfo[i].sup_id = k;\n\n\t\t\t\tif(i != k)num_in[i]++;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\theight[i] = 0;\n\t\tparent[i] = i;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tunite(i,info[i].sup_id);\n\t}\n\n\tvector<int> Group[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tGroup[find(i)].push_back(i);\n\t}\n\n\tint ans = 0;\n\tint min_index,minimum;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(Group[i].size() == 0)continue;\n\n\t\tmin_index = 0;\n\t\tminimum = info[Group[i][0]].day1;\n\n\t\tif(num_in[Group[i][0]] != 0){\n\n\t\t\tfor(int k = 1; k < Group[i].size(); k++){\n\t\t\t\tif(num_in[Group[i][k]] == 0){\n\t\t\t\t\tmin_index = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(info[Group[i][k]].day1 < minimum){\n\t\t\t\t\tmin_index = k;\n\t\t\t\t\tminimum = info[Group[i][k]].day1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans += info[Group[i][min_index]].day1;\n\t\tfor(int k = 0; k < Group[i].size(); k++){\n\t\t\tif(k != min_index){\n\t\t\t\tans += info[Group[i][k]].day2;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//55\n#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    string na[1000],su[1000];\n    int d[1000],dd[1000];\n    for(int i=0;i<n;i++){\n      cin>>na[i]>>d[i]>>su[i]>>dd[i];\n    }\n    bool done[1000]={};\n    int a=0;\n    for(int i=0;i<n;i++){\n      int x,nd=1<<30;\n      for(int nt=0;nt<n;nt++){\n\tif(!done[nt]){\n\t  if(na[nt]==su[nt]||done[find(na,na+n,su[nt])-na]){\n\t    a+=(na[nt]==su[nt])?d[nt]:dd[nt];\n\t    done[nt]=true;\n\t    goto next;\n\t  }\n\t  if(d[nt]-dd[nt]<nd){\n\t    nd=d[nt]-dd[nt];\n\t    x=nt;\n\t  }\n\t}\n      }\n      a+=d[x];\n      done[x]=true;\n    next:\n      ;\n    }\n    cout<<a<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\nvector<int> v[1000];\nmap<string, int> id;\nstring s[1000], t[1000];\nint d1[1000], d2[1000];\n\nbool visited[1000];\nint rec(int now) {\n  if (visited[now]) return 0;\n  visited[now] = 1;\n  int res = 0;\n  FOR(it, v[now]) {\n    if (visited[*it]) continue;\n    res += d1[*it]-d2[*it];\n    res += rec(*it);\n  }\n  return res;\n}\n\nint dfs(int now) {\n  if (visited[now]) return 0;\n  visited[now] = 1;\n  int res = 0;\n  FOR(it, v[now]) {\n    if (visited[*it]) continue;\n    res += d2[*it];\n    res += dfs(*it);\n  }\n  return res;\n  \n}\n\nint main() {\n  while(cin >> n, n) {\n    id.clear();\n    REP(i,n) {\n      cin >> s[i] >> d1[i] >> t[i] >> d2[i];\n      id[s[i]] = i;\n    }\n    REP(i,1000)\n      v[i].clear();\n    REP(i, n) {\n      v[id[t[i]]].push_back(i);\n    }\n    typedef pair<int,int> pii;\n    vector<pii> vv;\n    REP(i,n) {\n      memset(visited,0,sizeof(visited));\n      int tmp = rec(i);\n      vv.push_back(pii(tmp, i));\n    }\n    sort(ALL(vv), greater<pii>());\n    memset(visited,0,sizeof(visited));\n    int res = 0;\n    REP(i,n) {\n      int c = vv[i].second;\n      if (!visited[c]) {\n        res += d1[c] + dfs(c);\n      }\n    }\n    cout << res << endl;\n  }       \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nstruct Dscc {\npublic:\n\n\t//fst:belongs , scd:newedges\n\tpair<vector<vector<int>>, vector<vector<int>>>get(const vector<vector<int>>&edges) {\n\t\tnums.resize(edges.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\t\tvector<vector<int>>revedges(edges.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\trevedges[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint num = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tdfs(i, num, edges);\n\t\t}\n\t\tvector<int>big(nums.size());\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tbig[nums[i]] = i;\n\t\t}\n\t\treverse(big.begin(), big.end());\n\t\tunis.resize(edges.size());\n\t\tfill(unis.begin(), unis.end(), -1);\n\t\tnum = 0;\n\t\tfor (int i = 0; i < big.size(); ++i) {\n\n\t\t\tdfs2(big[i], num, revedges);\n\t\t\tnum++;\n\t\t}\n\t\tvector<int>nums;\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tnums.push_back(unis[i]);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n\n\t\tmap<int, int>mp;\n\t\tfor (int i = 0; i < nums.size(); ++i) {\n\t\t\tmp[nums[i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tunis[i] = mp[unis[i]];\n\t\t}\n\n\t\tvector<vector<int>>belongs(nums.size());\n\t\tfor (int i = 0; i < unis.size(); ++i) {\n\t\t\tbelongs[unis[i]].push_back(i);\n\t\t}\n\t\tvector<vector<int>>newedges(nums.size());\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tfor (auto j : edges[i]) {\n\t\t\t\tif (unis[i] != unis[j]) {\n\t\t\t\t\tnewedges[unis[i]].push_back(unis[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn make_pair(belongs, newedges);\n\t}\nprivate:\n\tvector<int>nums;\n\tvector<int>unis;\n\n\n\tvoid dfs(const int id, int &num, const vector<vector<int>>&edges) {\n\t\tif (nums[id] != -1)return;\n\t\telse {\n\t\t\tnums[id] = -2;\n\t\t\tfor (auto i : edges[id]) {\n\t\t\t\tdfs(i, num, edges);\n\t\t\t}\n\t\t}\n\t\tnums[id] = num++;\n\t\treturn;\n\t}\n\tvoid dfs2(const int id, const int &num, const vector<vector<int>>&edges) {\n\t\tif (unis[id] != -1)return;\n\t\telse {\n\t\t\tunis[id] = -2;\n\t\t\tfor (auto i : edges[id])\n\t\t\t\tdfs2(i, num, edges);\n\t\t}\n\t\tunis[id] = num;\n\t\treturn;\n\t}\n\n}dscc;\n\nint get_id(string st,bool flag=false) {\n\tstatic map<string,int>mp;\n\tstatic int id=0;\n\tif (flag) {\n\t\tmp.clear();\n\t\tid=0;\n\t\treturn 0;\n\t}\n\tif (mp.find(st) == mp.end()) {\n\t\tmp[st]=id++;\n\t}\n\treturn mp[st];\n}\n\nint main() {\n\twhile (true) {\n\t\tget_id(\"\", true);\n\t\tint N;cin>>N;\n\t\tif(!N)break;\n\n\t\tvector<int>oris(N);\n\t\tvector<int>acomes(N);\n\t\tvector<vector<int>>edges(N);\n\n\t\tvector<int>ids(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring ast;\n\t\t\tint b;\n\t\t\tstring cst;\n\t\t\tint d;\n\t\t\tcin>>ast>>b>>cst>>d;\n\t\t\tint a=get_id(ast);\n\t\t\tint c=get_id(cst);\n\n\t\t\toris[i]=b;\n\t\t\tacomes[i]=d;\n\t\t\tif(a!=c)edges[c].push_back(a);\n\n\t\t\tids[a]=i;\n\t\t}\n\n\t\tauto p=dscc.get(edges);\n\n\t\tvector<int>comes(p.second.size());\n\t\tfor (auto es : p.second) {\n\t\t\tfor (auto e : es) {\n\t\t\t\tcomes[e]++;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tint ans=accumulate(acomes.begin(),acomes.end(),0);\n\t\tfor(int i=0;i<p.first.size();++i){\n\t\t\tif(comes[i])continue;\n\t\t\tauto v(p.first[i]);\n\t\t\tint minus_max=-1e9;\n\t\t\tfor (auto a : v) {\n\t\t\t\tminus_max=max(minus_max,acomes[ids[a]]-oris[ids[a]]);\n\t\t\t}\n\t\t\tans-=minus_max;\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool used[1001];\nint n;\nvector<int> G[1001];\npii costs[1001];\nint idx=0;\nmap<string,int> indices;\nint nxt[1001];\nint in[1001];\nint sumCosts=0;\nbool used2[1001];\n\n// üü0Ìm[hÉÂ¢ÄTõ(ÂHÍ¶Ýµ¦È¢)\nvoid search1(int s){\n\tused[s]=true;\n\tfor(int i=0;i<(int)G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch1(to);\n\t\t}\n\t}\n}\n// ü_ª ém[h©çTõðnßé\nvoid search2(int s){\n\tused[s]=true;\n\tused2[s]=true;\n\tfor(int i=0;i<(int)G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch2(to);\n\t\t}\n\t\t// ÂHð­©µ½êAÂHÌÅÅàRXg·Ì¬³¢àÌðÌp\n\t\telse{\n\t\t\t// ¡ñÊßµ½êÅÍÈ¢ê\n\t\t\tif(!used2[to])continue;\n\t\t\tvector<pii> v;\n\t\t\tint cur=to;\n\t\t\twhile(1){\n\t\t\t\tv.push_back(pii(costs[cur].first-costs[cur].second,cur));\n\t\t\t\tif(cur==s)break;\n\t\t\t\tint tto=nxt[cur];\n\t\t\t\tcur=tto;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\tsumCosts+=costs[v[0].second].first;\n\t\t\tsumCosts-=costs[v[0].second].second;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tsumCosts=0;\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(used,0,sizeof(used));\n\t\tindices.clear();\n\t\tidx=0;\n\t\tfor(int i=0;i<1001;i++)G[i].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint c,d;\n\t\t\tcin>>a>>c>>b>>d;\n\t\t\tif(indices.find(a)==indices.end())indices[a]=idx++;\n\t\t\tif(indices.find(b)==indices.end())indices[b]=idx++;\n\t\t\tif(a!=b){\n\t\t\t\tG[indices[b]].push_back(indices[a]);\n\t\t\t\tin[indices[a]]++;\n\t\t\t}\n\t\t\tcosts[indices[a]]=pii(c,d);\n\t\t}\n\t\t// ü_ª³¢¨ðTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(in[i]==0&&!used[i]){\n\t\t\t\t// ÅÌvfÍK¸æé\n\t\t\t\tsumCosts+=costs[i].first;\n\t\t\t\tsearch1(i);\n\t\t\t}\n\t\t}\n\t\t// Ü¾TõµÄ¢È¢àÌð·×ÄTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tmemset(used2,0,sizeof(used2));\n\t\t\t\tsumCosts+=costs[i].second;\n\t\t\t\tsearch2(i);\n\t\t\t}\n\t\t}\n\t\tcout<<sumCosts<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef map<string,int> msi;\n\nstruct Tool {\n  string name, sup;\n  int day1, day2, i, si;\n\n  void print() {\n    printf(\"Tool: %s(%d):%d, %s(%d):%d\\n\",\n\t   name.c_str(), i, day1, sup.c_str(), si, day2);\n  }\n};\n\n/* global variables */\n\nint n;\nTool tools[MAX_N];\nmsi nhash;\nbool made[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    nhash.clear();\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      cin >> ti.name >> ti.day1 >> ti.sup >> ti.day2;\n      ti.i = i;\n      ti.si = -1;\n      nhash[ti.name] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      ti.si = nhash[ti.sup];\n      //ti.print();\n    }\n\n    int minday = 0, nu = n;\n    memset(made, false, sizeof(made));\n\n    // self dependent\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      if (i == ti.si) {\n\tmade[i] = true;\n\tnu--;\n\tminday += ti.day1;\n      }\n    }\n\n    // check if dep tool is already made\n    bool changed = true;\n    while (changed) {\n      changed = false;\n\n      for (int i = 0; i < n; i++) {\n\tTool& ti = tools[i];\n\tif (! made[i] && made[ti.si]) {\n\t  made[i] = true;\n\t  nu--;\n\t  minday += ti.day2;\n\t  changed = true;\n\t}\n      }\n    }\n    //printf(\"nu=%d, minday=%d\\n\", nu, minday);\n\n    // check loops\n    for (int i = 0; i < n; i++) {\n      Tool& ti = tools[i];\n      if (! made[i]) {\n\tint sumloop = tools[i].day2;\n\tmade[i] = true;\n\tvi li;\n\tfor (int j = tools[i].si; j != i; j = tools[j].si) {\n\t  made[j] = true;\n\t  sumloop += tools[j].day2;\n\t  li.push_back(j);\n\t}\n\n\tint minloop = INF;\n\tfor (vi::iterator lit = li.begin(); lit != li.end(); lit++) {\n\t  int lsum = sumloop + tools[*lit].day1 - tools[*lit].day2;\n\t  if (minloop > lsum) minloop = lsum;\n\t}\n\t//printf(\"  minloop=%d\\n\", minloop);\n\n\tminday += minloop;\n      }\n    }\n\n    cout << minday << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool used[1001];\nint n;\nvector<int> G[1001];\npii costs[1001];\nint idx=0;\nmap<string,int> indices;\nint nxt[1001];\nint in[1001];\nint sumCosts=0;\n\nvoid search1(int s){\n\tused[s]=true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch1(to);\n\t\t}\n\t\telse{\n\t\t\t// ÂHð­©µ½êAn_ÍmèÏÝÈÌÅAÁÉ½àsíÈ¢\n\t\t}\n\t}\n}\n// ü_ª ém[h©çTõðnßé\nvoid search2(int s){\n\tused[s]=true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch2(to);\n\t\t}\n\t\t// ÂHð­©µ½êAÂHÌÅÅàRXg·Ì¬³¢àÌðÌp\n\t\telse{\n\t\t\tvector<pii> v;\n\t\t\tint cur=to;\n\t\t\twhile(1){\n\t\t\t\tv.push_back(pii(costs[cur].first-costs[cur].second,cur));\n\t\t\t\tif(cur==s)break;\n\t\t\t\tint tto=nxt[cur];\n\t\t\t\tcur=tto;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\tsumCosts+=costs[v[0].second].first;\n\t\t\tsumCosts-=costs[v[0].second].second;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tsumCosts=0;\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(used,0,sizeof(used));\n\t\tindices.clear();\n\t\tidx=0;\n\t\tfor(int i=0;i<1001;i++)G[i].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint c,d;\n\t\t\tcin>>a>>c>>b>>d;\n\t\t\tif(indices.find(a)==indices.end())indices[a]=idx++;\n\t\t\tif(indices.find(b)==indices.end())indices[b]=idx++;\n\t\t\tif(a!=b){\n\t\t\t\tG[indices[b]].push_back(indices[a]);\n\t\t\t\tin[indices[a]]++;\n\t\t\t}\n\t\t\tcosts[indices[a]]=pii(c,d);\n\t\t}\n\t\t// ü_ª³¢¨ðTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(in[i]==0&&!used[i]){\n\t\t\t\t// ÅÌvfÍK¸æé\n\t\t\t\tsumCosts+=costs[i].first;\n\t\t\t\tsearch1(i);\n\t\t\t}\n\t\t}\n\t\t// Ü¾TõµÄ¢È¢àÌð·×ÄTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tsumCosts+=costs[i].second;\n\t\t\t\tsearch2(i);\n\t\t\t}\n\t\t}\n\t\tcout<<sumCosts<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nconst int LMAX=2010;\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G,rG;\n\tvector<bool>used;\n\tvi vs,cmp;\n\tSCC(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n};\nvp in;\nvvi G,rG;\nvi visit;\nint out=0;\nvoid dfs(int a){\n\tout+=in[a].second;\n\tvisit[a]=true;\n\trep(i,G[a].size())if(visit[G[a][i]]==0)\n\t\tdfs(G[a][i]);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmap<string,int>m;\n\t\tvector<string>a(n),c(n);\n\t\tvi b(n),d(n);\n\t\trep(i,n)cin>>a[i]>>b[i]>>c[i]>>d[i];\n\t\trep(i,n)m[a[i]]=i;\t\t\n\t\tSCC scc(n);\n\t\trep(i,n){\n\t\t\tif(a[i]!=c[i])scc.add_edge(m[c[i]],m[a[i]]);\n\t\t}\n\t\tint N=scc.scc();\n\t\tin=vp(N);\n\t\tG=rG=vvi(N);\n\t\trep(i,N){\n\t\t\tvi t;\n\t\t\trep(j,n)if(scc.cmp[j]==i)t.pb(j);\n\t\t\tif(t.size()==1){\n\t\t\t\tif(i!=scc.cmp[m[c[t[0]]]]){\n\t\t\t\t\trG[i].pb(scc.cmp[m[c[t[0]]]]);\n\t\t\t\t\tG[scc.cmp[m[c[t[0]]]]].pb(i);\n\t\t\t\t}\n\t\t\t\tin[i]=pii(b[t[0]],d[t[0]]);\n\t\t\t}else{\n\t\t\t\tint mi=inf,sum=0;\n\t\t\t\trep(j,t.size())sum+=d[t[j]];\n\t\t\t\trep(j,t.size())mi=min(mi,b[t[j]]-d[t[j]]);\n\t\t\t\tin[i]=pii(mi+sum,inf);\n\t\t\t}\n\t\t}\n\t\tvisit=vi(N);\n\t\tout=0;\n\t\trep(i,N)if(visit[i]==0&&rG[i].size()==0){\n\t\t\tout+=in[i].first-in[i].second;\n\t\t\tdfs(i);\n\t\t}\n\t\tcout<<out<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = 3000*1000;\nconst int N   = 1000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+=ori[a[j]];\n      else tmp+=tool[a[j]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,N){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    \n    rep(i,n){\n      if (!gvis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct tool {\n    string name,sh;\n    int ntime,stime;\n    vector<int> edge;\n    tool(string name,string sn,int ntime,int stime)\n        : name(name), sh(sn), ntime(ntime), stime(stime) {edge.clear();}\n};\n\nbool seen[1001];\n\nint dfs(vector<tool> &tv,int v) {\n    seen[v] = true;\n    int ret = 0;\n    for(int i=0; i<tv[v].edge.size(); ++i) {\n        if(seen[tv[v].edge[i]]) continue;\n        ret += (tv[tv[v].edge[i]].ntime - tv[tv[v].edge[i]].stime);\n        ret += dfs(tv,tv[v].edge[i]);\n    }\n    return ret;\n}\n\nvoid dfs2(vector<tool> &tv,int v) {\n    seen[v] = true;\n    for(int i=0; i<tv[v].edge.size(); ++i) {\n        if(seen[tv[v].edge[i]]) continue;\n        dfs2(tv,tv[v].edge[i]);\n    }\n}\n\nint main() {\n    int n;\n    string s1,s2;\n    int k1,k2;\n    while(cin>>n, n) {\n        map<string,int> idx;\n        vector<tool> tv;\n\n        int ans = 0;\n        for(int i=0; i<n; ++i) {\n            cin>>s1>>k1>>s2>>k2;\n            idx[s1] = i;\n            tv.push_back(tool(s1,s2,k1,k2));\n            ans += k1;\n        }\n\n        for(int i=0; i<n; ++i) {\n            if(idx.find(tv[i].sh) == idx.end()) continue;\n            int id = idx[tv[i].sh];\n            tv[id].edge.push_back(i);\n        }\n\n        vector<int> p(n,-1);\n        for(int i=0; i<n; ++i) {\n            memset(seen, false, sizeof(seen));\n            p[i] = dfs(tv,i);\n        }\n\n        vector<pair<int,int> > ppv(n);\n        for(int i=0; i<n; ++i) {\n            ppv.push_back(make_pair(p[i],i));\n        }\n        sort(ppv.begin(), ppv.end());\n        reverse(ppv.begin(), ppv.end());\n\n        memset(seen, false, sizeof(seen));\n        for(int i=0; i<ppv.size(); ++i) {\n            int v = ppv[i].second;\n            if(seen[v]) continue;\n            ans -= ppv[i].first;\n            dfs2(tv,v);\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\n\nstruct Info{\n\tint day1,sup_id,day2;\n\tchar name[33],sup_name[33];\n};\n\nint N;\nint height[1000],parent[1000],num_in[1000];\n\nInfo info[1000];\nvector<int> G[1000];\nvector<int> reverse_G[1000];\n\nGROUP group[1000];\nstack<int> S;\n\nbool check[1000];\nint table[1000];\n\nint group_index;\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tgroup[i].nodes.clear();\n\t\tG[i].clear();\n\t\treverse_G[i].clear();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %s %d\",info[i].name,&info[i].day1,info[i].sup_name,&info[i].day2);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(strCmp(info[k].name,info[i].sup_name)){\n\t\t\t\tinfo[i].sup_id = k;\n\n\t\t\t\tif(i != k){\n\t\t\t\t\tG[k].push_back(i);\n\t\t\t\t\treverse_G[i].push_back(k);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\n\tfor(int i = 0; i < N;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\n\tgroup_index = -1;\n\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tfor(int i = 0; i < N; i++)num_in[i] = 0;\n\n\tint to_group,min_index,minimum;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tfor(int p = 0; p < G[group[i].nodes[k]].size(); p++){\n\t\t\t\tto_group = table[G[group[i].nodes[k]][p]];\n\t\t\t\tif(to_group != i)num_in[to_group]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i <= group_index;i++){\n\t\tif(group[i].nodes.size() == 1){\n\t\t\tif(num_in[i] == 0){\n\t\t\t\tans += info[group[i].nodes[0]].day1;\n\t\t\t}else{\n\t\t\t\tans += info[group[i].nodes[0]].day2;\n\t\t\t}\n\t\t}else{\n\n\t\t\tif(num_in[i] == 0){\n\t\t\t\tmin_index = 0;\n\t\t\t\tminimum = info[group[i].nodes[0]].day1 -info[group[i].nodes[0]].day2;\n\n\t\t\t\tfor(int k = 1; k < group[i].nodes.size(); k++){\n\t\t\t\t\tif(info[group[i].nodes[k]].day1 -info[group[i].nodes[k]].day2 < minimum){\n\t\t\t\t\t\tminimum = info[group[i].nodes[k]].day1 -info[group[i].nodes[k]].day2;\n\t\t\t\t\t\tmin_index = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans += info[group[i].nodes[min_index]].day1;\n\t\t\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\t\t\tif(k != min_index){\n\t\t\t\t\t\tans += info[group[i].nodes[k]].day2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\t\t\tans += info[group[i].nodes[k]].day2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nbool used[1001];\nint n;\nvector<int> G[1001];\npii costs[1001];\nint idx=0;\nmap<string,int> indices;\nint nxt[1001];\nint in[1001];\nint sumCosts=0;\n\n// üü0Ìm[hÉÂ¢ÄTõ(ÂHÍ¶Ýµ¦È¢)\nvoid search1(int s){\n\tused[s]=true;\n\tfor(int i=0;i<(int)G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch1(to);\n\t\t}\n\t}\n}\n// ü_ª ém[h©çTõðnßé\nvoid search2(int s){\n\tused[s]=true;\n\tfor(int i=0;i<(int)G[s].size();i++){\n\t\tint to=G[s][i];\n\t\tif(!used[to]){\n\t\t\tnxt[s]=to;\n\t\t\tsumCosts+=costs[to].second;\n\t\t\tsearch2(to);\n\t\t}\n\t\t// ÂHð­©µ½êAÂHÌÅÅàRXg·Ì¬³¢àÌðÌp\n\t\telse{\n\t\t\tvector<pii> v;\n\t\t\tint cur=to;\n\t\t\twhile(1){\n\t\t\t\tif(v.size()==2000)break;\n\t\t\t\tv.push_back(pii(costs[cur].first-costs[cur].second,cur));\n\t\t\t\tif(cur==s)break;\n\t\t\t\tint tto=nxt[cur];\n\t\t\t\tcur=tto;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\tsumCosts+=costs[v[0].second].first;\n\t\t\tsumCosts-=costs[v[0].second].second;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>n&&n){\n\t\tsumCosts=0;\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(used,0,sizeof(used));\n\t\tindices.clear();\n\t\tidx=0;\n\t\tfor(int i=0;i<1001;i++)G[i].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint c,d;\n\t\t\tcin>>a>>c>>b>>d;\n\t\t\tif(indices.find(a)==indices.end())indices[a]=idx++;\n\t\t\tif(indices.find(b)==indices.end())indices[b]=idx++;\n\t\t\tif(a!=b){\n\t\t\t\tG[indices[b]].push_back(indices[a]);\n\t\t\t\tin[indices[a]]++;\n\t\t\t}\n\t\t\tcosts[indices[a]]=pii(c,d);\n\t\t}\n\t\t// ü_ª³¢¨ðTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(in[i]==0&&!used[i]){\n\t\t\t\t// ÅÌvfÍK¸æé\n\t\t\t\tsumCosts+=costs[i].first;\n\t\t\t\tsearch1(i);\n\t\t\t}\n\t\t}\n\t\t// Ü¾TõµÄ¢È¢àÌð·×ÄTõ\n\t\tfor(int i=0;i<idx;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tsumCosts+=costs[i].second;\n\t\t\t\tsearch2(i);\n\t\t\t}\n\t\t}\n\t\tcout<<sumCosts<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = INT_MAX;\nconst int N   = 2000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+= ori[a[j]];\n      else       tmp+=tool[a[j]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,N){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n      ori[i]=0;\n      tool[i]=0;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    rep(i,M.size()){\n      if (!gvis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int inf = 3000*1000;\nconst int N   = 1000;\n\nint ori[N];\nint tool[N];\nbool is_in_loop[N];\nint ans;\n\nvoid calc_loop_min(int *a,int p){\n  int ret = inf;\n  rep(i,p)is_in_loop[a[i]]=true;\n  rep(i,p){\n    int tmp = 0;\n    rep(j,p){\n      if (j == i)tmp+=ori[a[i]];\n      else tmp+=tool[a[i]];\n    }\n    ret=min(ret,tmp);\n  }\n  ans+=ret;\n}\n\nvector<int> edge[N];\nbool gvis[N];\nbool vis[N];\nvoid dfs(int now,int *st,int p){\n  if (gvis[now])return;\n  if (vis[now]){\n    calc_loop_min(st,p);\n    return;\n  }\n  vis[now]=true;\n  rep(i,edge[now].size()){\n    int next=edge[now][i];\n    st[p]=now;\n    dfs(next,st,p+1);\n  }\n  if (!is_in_loop[now]){\n    ans+=tool[now];\n  }\n  gvis[now]=true;\n}\n\nint getindex(string &a,map<string,int> &M){\n  int index = M.size();\n  if (M.find(a) == M.end())M[a]=index;\n  return M[a];\n}\n\nmain(){\n  int n;\n  int path[N];\n  while(cin >> n&&n){\n    ans=0;\n    rep(i,N){\n      is_in_loop[i]=false;\n      edge[i].clear();\n      vis[i]=false;\n      gvis[i]=false;\n    }\n\n    map<string,int> M;\n    rep(i,n){\n      string a,b;\n      int c,d;\n      int index1,index2;\n      cin>>a>>c>>b>>d;\n      index1=getindex(a,M);\n      index2=getindex(b,M);\n      edge[index2].push_back(index1);\n      ori[index1]=c;\n      tool[index1]=d;\n    }\n\n    \n    rep(i,n){\n      if (!gvis[i])dfs(i,path,0);\n    }\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2033 Rock Man\n// 2018.3.16 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()  // 非負整数の入力\n{\n\tint n = 0, c = gc();\n\twhile (!isdigit(c)) c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (isdigit(c));\n\treturn n;\n}\n\nvoid ins(char *s)  // 文字列の入力　スペース以下の文字で入力終了\n{\n\tchar c = gc();\n\twhile (isspace(c)) c = gc();\n\t*s++ = c;\n\tdo *s = gc(); while (isalpha(*s++));\n\t*(s - 1) = 0;\n}\n\n// 文字列のハッシュ関数\n#define HASHSIZ 9973\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ + 2], *hashend = hash + HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tint j;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s;\n\tfor (j = 0; *p && j < 12; j++) i = (i << 5) + (*p++ + 1 - 'a');\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n#define MAX_V 1005\nint  V;    // 頂点数\nint  *to[MAX_V], hi[MAX_V];\nint  *r_to[MAX_V], r_hi[MAX_V];\nint  vs[MAX_V], vsz;\nchar used[MAX_V];\nint  cmp[MAX_V];    // 属する強連結成分のトポロジカル順序\n\nvoid add_edge(int _from, int _to)\n{\n\tto[_from][hi[_from]++] = _to;\n\tr_to[_to][r_hi[_to]++] = _from;\n}\n\nvoid dfs(int v)\n{\n\tint i;\n\tused[v] = 1;\n\tfor (i = 0; i < hi[v]; i++) {\n\t\tif (!used[to[v][i]]) dfs(to[v][i]);\n\t}\n\tvs[vsz++] = v;\n}\n\nvoid rdfs(int v, int k)\n{\n\tint i;\n\tused[v] = 1;\n\tcmp[v] = k;\n\tfor (i = 0; i < r_hi[v]; i++) {\n\t\tif (!used[r_to[v][i]]) rdfs(r_to[v][i], k);\n\t}\n}\n\n// 強連結成分への分解\nint scc()\n{\n\tint v, i, k;\n\tmemset(used, 0, V);\n\tvsz = 0;\n\tfor (v = 0; v < V; v++) if (!used[v]) dfs(v);\n\tmemset(used, 0, V);\n\tk = 0;\n\tfor (i = vsz - 1; i >= 0; i--) {\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\t\t// 得られた強連結成分の数\n}\n\ntypedef struct { int id, sup, day1, day2, diff; } T;\nT tbl[1005];\n\nchar name[1002][35]; int sz;\nchar f[1002];    // 各強連結成分内のグループの個数。 1 か 2以上か。\n\nint sort_cmp(const void *a, const void *b) { return ((T *)a)->diff - ((T *)b)->diff; }\n\nint main()\n{\n\tint k, i, ans;\n\n\twhile (V = in()) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tsz = 0;  for (i = 0; i < V; i++) {\n\t\t\tins(name[sz]);\n\t\t\tif ((k = insert(name[sz], sz)) < 0) k = sz++;\n\t\t\ttbl[i].id = k;\n\t\t\ttbl[i].day1 = in();\n\t\t\tins(name[sz]);\n\t\t\tif ((k = insert(name[sz], sz)) < 0) k = sz++;\n\t\t\ttbl[i].sup = k;\n\t\t\ttbl[i].day2 = in();\n\t\t\ttbl[i].diff = tbl[i].day1 - tbl[i].day2;\n\t\t}\n\t\tqsort(tbl, V, sizeof(T), sort_cmp);\n\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tmemset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < V; i++) {\n\t\t\thi[tbl[i].sup]++;\n\t\t\tr_hi[tbl[i].id]++;\n\t\t}\n\n\t\tfor (i = 0; i < V; i++) {\n\t\t\tif (hi[i])   to[i] = malloc(hi[i] * sizeof(int));\n\t\t\tif (r_hi[i]) r_to[i] = malloc(r_hi[i] * sizeof(int));\n\t\t}\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tmemset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < V; i++) {\n\t\t\tif (tbl[i].sup != tbl[i].id) add_edge(tbl[i].sup, tbl[i].id);\n\t\t}\n\n\t\tscc();\t\t//強連結成分への分解\n\n\t\tmemset(f, 0, sizeof(f));\n\t\tfor (i = 0; i < V; i++) {\n\t\t\tk = cmp[tbl[i].id];\n\t\t\tif (f[k] < 2) f[k]++;\n\t\t}\n\n\t\tans = 0;\n\t\tfor (i = 0; i < V; i++) {\n\t\t\tif (r_hi[tbl[i].id] == 0) ans += tbl[i].day1;\n\t\t\telse {\n\t\t\t\tk = cmp[tbl[i].id];\n\t\t\t\tif (f[k] > 1) ans += tbl[i].day1, f[k] = -1;\n\t\t\t\telse ans += tbl[i].day2;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tfor (i = 0; i < V; i++) {\n\t\t\tif (hi[i])   free(to[i]);\n\t\t\tif (r_hi[i]) free(r_to[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Rock Man\npublic class Main{\n\n\tint n, COUNT, INF = 1<<29, res;\n\t\n\tList<E>[] edge, rev;\n\tMap<String, Integer> ref;\n\tint get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, COUNT);\n\t\treturn COUNT++;\n\t}\n\t\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tboolean[] visited;\n\tList<Integer> list;\n\tvoid dfs(int k){\n\t\tif(visited[k])return;\n\t\tvisited[k] = true;\n\t\tfor(E e:edge[k])dfs(e.t);\n\t\tlist.add(k);\n\t}\n\tint[] scc;\n\tvoid rdfs(int k, int ID){\n\t\tif(visited[k])return;\n\t\tvisited[k] = true;\n\t\tscc[k] = ID;\n\t\tfor(E e:rev[k])rdfs(e.t, ID);\n\t}\n\t\n\tint cycle(int k, int start, boolean f){\n\t\tif(k==start&&f||rev[k].isEmpty())return 0;\n\t\tE e = rev[k].get(0);\n\t\treturn e.c+cycle(e.t, start, true);\n\t}\n\tvoid make(int k){\n\t\tfor(E e:edge[k]){\n\t\t\tif(visited[e.t])continue;\n\t\t\tres += e.c; visited[e.t] = true; make(e.t);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tedge = new List[n]; rev = new List[n];\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tCOUNT = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tedge[i] = new ArrayList<E>();\n\t\t\t\trev[i] = new ArrayList<E>();\n\t\t\t}\n\t\t\tint[] cost = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = get(sc.next());\n\t\t\t\tcost[x] = sc.nextInt();\n\t\t\t\tint y = get(sc.next()), c = sc.nextInt();\n\t\t\t\tif(x==y)continue;\n\t\t\t\tedge[y].add(new E(x, c)); rev[x].add(new E(y, c));\n\t\t\t}\n\t\t\tvisited = new boolean[n];\n\t\t\tlist = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++)if(!visited[i])dfs(i);\n\t\t\tint ID = 0;\n\t\t\tscc = new int[n];\n\t\t\tvisited = new boolean[n];\n\t\t\tfor(int i=list.size()-1;i>=0;i--){\n\t\t\t\tint v = list.get(i);\n\t\t\t\tif(visited[v])continue;\n\t\t\t\trdfs(v, ID); ID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<n;i++)for(E e:edge[i]){\n\t\t\t\tif(scc[i]!=scc[e.t])deg[scc[e.t]]++;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tvisited = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(deg[scc[i]]>0||visited[i])continue;\n\t\t\t\tint p = -1;\n\t\t\t\tif(rev[i].isEmpty()){\n\t\t\t\t\tp = i;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint c = cycle(i, i, false);\n\t\t\t\t\tp = i;\n\t\t\t\t\tint min = c-rev[i].get(0).c+cost[i];\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(scc[i]!=scc[j])continue;\n\t\t\t\t\t\tint v = c-rev[j].get(0).c+cost[j];\n\t\t\t\t\t\tif(v<min){\n\t\t\t\t\t\t\tmin = v; p = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisited[p] = true; res+=cost[p];\n\t\t\t\tmake(p);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Rock Man\npublic class Main{\n\n\tint n, COUNT, INF = 1<<29, res;\n\t\n\tList<E>[] edge, rev;\n\tMap<String, Integer> ref;\n\tint get(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, COUNT);\n\t\treturn COUNT++;\n\t}\n\t\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tboolean[] visited;\n\tList<Integer> list;\n\tvoid dfs(int k){\n\t\tif(visited[k])return;\n\t\tvisited[k] = true;\n\t\tfor(E e:edge[k])dfs(e.t);\n\t\tlist.add(k);\n\t}\n\tint[] scc;\n\tvoid rdfs(int k, int ID){\n\t\tif(visited[k])return;\n\t\tvisited[k] = true;\n\t\tscc[k] = ID;\n\t\tfor(E e:rev[k])rdfs(e.t, ID);\n\t}\n\t\n\tint cycle(int k, int start, boolean f){\n\t\tif(k==start&&f||rev[k].isEmpty())return 0;\n\t\tE e = rev[k].get(0);\n\t\treturn e.c+cycle(e.t, start, true);\n\t}\n\tvoid make(int k){\n\t\tfor(E e:edge[k]){\n\t\t\tif(visited[e.t])continue;\n\t\t\tres += e.c; visited[e.t] = true; make(e.t);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tedge = new List[n]; rev = new List[n];\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tCOUNT = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tedge[i] = new ArrayList<E>();\n\t\t\t\trev[i] = new ArrayList<E>();\n\t\t\t}\n\t\t\tint[] cost = new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint x = get(sc.next());\n\t\t\t\tcost[x] = sc.nextInt();\n\t\t\t\tint y = get(sc.next()), c = sc.nextInt();\n\t\t\t\tif(x==y)continue;\n\t\t\t\tedge[y].add(new E(x, c)); rev[x].add(new E(y, c));\n\t\t\t}\n\t\t\tvisited = new boolean[n];\n\t\t\tlist = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++)if(!visited[i])dfs(i);\n\t\t\tint ID = 0;\n\t\t\tscc = new int[n];\n\t\t\tvisited = new boolean[n];\n\t\t\tfor(int i=list.size()-1;i>=0;i--){\n\t\t\t\tint v = list.get(i);\n\t\t\t\tif(visited[v])continue;\n\t\t\t\trdfs(v, ID); ID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<n;i++)for(E e:edge[i]){\n\t\t\t\tif(scc[i]!=scc[e.t])deg[scc[e.t]]++;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tvisited = new boolean[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(deg[scc[i]]>0||visited[i])continue;\n\t\t\t\tint p = -1;\n\t\t\t\tif(rev[i].isEmpty()){\n\t\t\t\t\tp = i;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint c = cycle(i, i, false);\n\t\t\t\t\tp = i;\n\t\t\t\t\tint min = c-rev[i].get(0).c+cost[i];\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(scc[i]!=scc[j])continue;\n\t\t\t\t\t\tint v = c-rev[j].get(0).c+cost[j];\n\t\t\t\t\t\tif(v<min){\n\t\t\t\t\t\t\tmin = v; p = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisited[p] = true; res+=cost[p];\n\t\t\t\tmake(p);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000) \n\ndef checkloop(pdict,product,inroute,made):\n    inroute.append(product)\n    if pdict[product][1] in made:\n        return (False,product)\n    elif pdict[product][1]==product:\n        return (False,product)\n    elif pdict[product][1] in inroute:\n        return (True,pdict[product][1])\n    else:\n        return checkloop(pdict,pdict[product][1],inroute,made)\n\ndef daysopen(pdict,product,made,notsearched):\n    if pdict[product][1] in made:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][2]\n    if pdict[product][1]==product:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][0]\n    else:\n        made.append(product)\n        notsearched.remove(product)\n        return daysopen(pdict,pdict[product][1],made,notsearched)+pdict[product][2]\n    \ndef daysloop(pdict,product,made,notsearched,inloop):\n    inloop.append(product)\n    if pdict[product][1] in inloop:\n       # print inloop\n        smallestdifference=100000\n        smallestdifferenceitem=\"\"\n        for item in inloop:\n            if smallestdifference>pdict[item][0]-pdict[item][2]:\n                smallestdifference=pdict[item][0]-pdict[item][2]\n                smallestdifferenceitem=item\n        #gotsmallestitem\n        days=pdict[smallestdifferenceitem][0]\n        made.append(smallestdifferenceitem)\n        notsearched.remove(smallestdifferenceitem)\n        inloop.remove(smallestdifferenceitem)\n        for item in inloop:\n            made.append(item)\n            notsearched.remove(item)\n            days=days+pdict[item][2]\n        return days\n    else:\n        return daysloop(pdict,pdict[product][1],made,notsearched,inloop)\n    \nwhile(1):\n    N=int(raw_input())\n    if N==0:\n        break\n    else:\n        pdict={}\n        notsearched=[]\n        notcomplete=1\n        made=[]\n        days=0\n        for i in range(N):\n            indat=raw_input().split()\n            pdict[indat[0]]=(int(indat[1]),indat[2],int(indat[3])) #name=(d1,sup,d2)\n            notsearched.append(indat[0])\n        while len(notsearched)!=0:\n            #check if loop\n            inroute=[]\n            product=notsearched[0]\n            #check if sup made\n            if pdict[product][1] in made:\n                days=days+pdict[product][2]\n                made.append(product)\n                notsearched.remove(product)\n            else:\n                [loopbool,loopstartpoint]=checkloop(pdict,product,inroute,made)\n                if loopbool:\n                    inloop=[]\n                    days=days+daysloop(pdict,loopstartpoint,made,notsearched,inloop)\n                else:\n                    days=days+daysopen(pdict,product,made,notsearched)\n        print days"
  },
  {
    "language": "Python",
    "code": "def checkloop(pdict,product,inroute):\n    inroute.append(product)\n    if pdict[product][1]==product:\n        return (False,product)\n    elif pdict[product][1] in inroute:\n        return (True,pdict[product][1])\n    else:\n        return checkloop(pdict,pdict[product][1],inroute)\n\ndef daysopen(pdict,product,made,notsearched):\n    if pdict[product][1] in made:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][2]\n    if pdict[product][1]==product:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][0]\n    else:\n        made.append(product)\n        notsearched.remove(product)\n        return daysopen(pdict,pdict[product][1],made,notsearched)+pdict[product][2]\n    \ndef daysloop(pdict,product,made,notsearched,inloop):\n    inloop.append(product)\n    if pdict[product][1] in inroute:\n        smallestdifference=100000\n        smallestdifferenceitem=\"\"\n        for item in inloop:\n            if smallestdifference>pdict[item][0]-pdict[item][2]:\n                smallestdifference=pdict[item][0]-pdict[item][2]\n                smallestdifferenceitem=item\n            #gotsmallestitem\n            days=pdict[smallestdifferenceitem][0]\n            made.append(smallestdifferenceitem)\n            notsearched.remove(smallestdifferenceitem)\n            inloop.remove(smallestdifferenceitem)\n            for item in inloop:\n                made.append(item)\n                notsearched.remove(item)\n                days=days+pdict[item][2]\n            return days\n    else:\n        return daysloop(pdict,pdict[product][1],made,notsearched,inloop)\n    \nwhile(1):\n    N=int(raw_input())\n    if N==0:\n        break\n    else:\n        pdict={}\n        notsearched=[]\n        notcomplete=1\n        made=[]\n        days=0\n        for i in range(N):\n            indat=raw_input().split()\n            pdict[indat[0]]=(int(indat[1]),indat[2],int(indat[3])) #name=(d1,sup,d2)\n            notsearched.append(indat[0])\n        while len(notsearched)!=0:\n            #check if loop\n            inroute=[]\n            product=notsearched[0]\n            #check if sup made\n            if pdict[product][1] in made:\n                days=days+pdict[product][2]\n                made.append(product)\n                notsearched.remove(product)\n            elif checkloop(pdict,product,inroute)[0]:\n                inloop=[]\n                days=days+daysloop(pdict,product,made,notsearched,inloop)\n            else:\n                days=days+daysopen(pdict,product,made,notsearched)\n        print days"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000) \n\ndef checkloop(pdict,product,inroute):\n    inroute.append(product)\n    if pdict[product][1]==product:\n        return (False,product)\n    elif pdict[product][1] in inroute:\n        return (True,pdict[product][1])\n    else:\n        return checkloop(pdict,pdict[product][1],inroute)\n\ndef daysopen(pdict,product,made,notsearched):\n    if pdict[product][1] in made:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][2]\n    if pdict[product][1]==product:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][0]\n    else:\n        made.append(product)\n        notsearched.remove(product)\n        return daysopen(pdict,pdict[product][1],made,notsearched)+pdict[product][2]\n    \ndef daysloop(pdict,product,made,notsearched,inloop):\n    inloop.append(product)\n    if pdict[product][1] in inroute:\n        smallestdifference=100000\n        smallestdifferenceitem=\"\"\n        for item in inloop:\n            if smallestdifference>pdict[item][0]-pdict[item][2]:\n                smallestdifference=pdict[item][0]-pdict[item][2]\n                smallestdifferenceitem=item\n            #gotsmallestitem\n            days=pdict[smallestdifferenceitem][0]\n            made.append(smallestdifferenceitem)\n            notsearched.remove(smallestdifferenceitem)\n            inloop.remove(smallestdifferenceitem)\n            for item in inloop:\n                made.append(item)\n                notsearched.remove(item)\n                days=days+pdict[item][2]\n            return days\n    else:\n        return daysloop(pdict,pdict[product][1],made,notsearched,inloop)\n    \nwhile(1):\n    N=int(raw_input())\n    if N==0:\n        break\n    else:\n        pdict={}\n        notsearched=[]\n        notcomplete=1\n        made=[]\n        days=0\n        for i in range(N):\n            indat=raw_input().split()\n            pdict[indat[0]]=(int(indat[1]),indat[2],int(indat[3])) #name=(d1,sup,d2)\n            notsearched.append(indat[0])\n        while len(notsearched)!=0:\n            #check if loop\n            inroute=[]\n            product=notsearched[0]\n            #check if sup made\n            if pdict[product][1] in made:\n                days=days+pdict[product][2]\n                made.append(product)\n                notsearched.remove(product)\n            elif checkloop(pdict,product,inroute)[0]:\n                inloop=[]\n                days=days+daysloop(pdict,product,made,notsearched,inloop)\n            else:\n                days=days+daysopen(pdict,product,made,notsearched)\n        print days"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000) \n\ndef checkloop(pdict,product,inroute):\n    inroute.append(product)\n    if pdict[product][1]==product:\n        return (False,product)\n    elif pdict[product][1] in inroute:\n        return (True,pdict[product][1])\n    else:\n        return checkloop(pdict,pdict[product][1],inroute)\n\ndef daysopen(pdict,product,made,notsearched):\n    if pdict[product][1] in made:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][2]\n    if pdict[product][1]==product:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][0]\n    else:\n        made.append(product)\n        notsearched.remove(product)\n        return daysopen(pdict,pdict[product][1],made,notsearched)+pdict[product][2]\n    \ndef daysloop(pdict,product,made,notsearched,inloop):\n    inloop.append(product)\n    if pdict[product][1] in inloop:\n        smallestdifference=100000\n        smallestdifferenceitem=\"\"\n        for item in inloop:\n            if smallestdifference>pdict[item][0]-pdict[item][2]:\n                smallestdifference=pdict[item][0]-pdict[item][2]\n                smallestdifferenceitem=item\n            #gotsmallestitem\n            days=pdict[smallestdifferenceitem][0]\n            made.append(smallestdifferenceitem)\n            notsearched.remove(smallestdifferenceitem)\n            inloop.remove(smallestdifferenceitem)\n            for item in inloop:\n                made.append(item)\n                notsearched.remove(item)\n                days=days+pdict[item][2]\n            return days\n    else:\n        return daysloop(pdict,pdict[product][1],made,notsearched,inloop)\n    \nwhile(1):\n    N=int(raw_input())\n    if N==0:\n        break\n    else:\n        pdict={}\n        notsearched=[]\n        notcomplete=1\n        made=[]\n        days=0\n        for i in range(N):\n            indat=raw_input().split()\n            pdict[indat[0]]=(int(indat[1]),indat[2],int(indat[3])) #name=(d1,sup,d2)\n            notsearched.append(indat[0])\n        while len(notsearched)!=0:\n            #check if loop\n            inroute=[]\n            product=notsearched[0]\n            #check if sup made\n            if pdict[product][1] in made:\n                days=days+pdict[product][2]\n                made.append(product)\n                notsearched.remove(product)\n            elif checkloop(pdict,product,inroute)[0]:\n                inloop=[]\n                days=days+daysloop(pdict,product,made,notsearched,inloop)\n            else:\n                days=days+daysopen(pdict,product,made,notsearched)\n        print days"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000) \n\ndef checkloop(pdict,product,inroute,made):\n    inroute.append(product)\n    if pdict[product][1] in made:\n        return (False,product)\n    elif pdict[product][1]==product:\n        return (False,product)\n    elif pdict[product][1] in inroute:\n        return (True,pdict[product][1])\n    else:\n        return checkloop(pdict,pdict[product][1],inroute,made)\n\ndef daysopen(pdict,product,made,notsearched):\n    if pdict[product][1] in made:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][2]\n    if pdict[product][1]==product:\n        made.append(product)\n        notsearched.remove(product)\n        return pdict[product][0]\n    else:\n        made.append(product)\n        notsearched.remove(product)\n        return daysopen(pdict,pdict[product][1],made,notsearched)+pdict[product][2]\n    \ndef daysloop(pdict,product,made,notsearched,inloop):\n    inloop.append(product)\n    if pdict[product][1] in inloop:\n       # print inloop\n        smallestdifference=100000\n        smallestdifferenceitem=\"\"\n        for item in inloop:\n            if smallestdifference>pdict[item][0]-pdict[item][2]:\n                smallestdifference=pdict[item][0]-pdict[item][2]\n                smallestdifferenceitem=item\n            #gotsmallestitem\n            days=pdict[smallestdifferenceitem][0]\n            made.append(smallestdifferenceitem)\n            notsearched.remove(smallestdifferenceitem)\n            inloop.remove(smallestdifferenceitem)\n            for item in inloop:\n                made.append(item)\n                notsearched.remove(item)\n                days=days+pdict[item][2]\n            return days\n    else:\n        return daysloop(pdict,pdict[product][1],made,notsearched,inloop)\n    \nwhile(1):\n    N=int(raw_input())\n    if N==0:\n        break\n    else:\n        pdict={}\n        notsearched=[]\n        notcomplete=1\n        made=[]\n        days=0\n        for i in range(N):\n            indat=raw_input().split()\n            pdict[indat[0]]=(int(indat[1]),indat[2],int(indat[3])) #name=(d1,sup,d2)\n            notsearched.append(indat[0])\n        while len(notsearched)!=0:\n            #check if loop\n            inroute=[]\n            product=notsearched[0]\n            #check if sup made\n            if pdict[product][1] in made:\n                days=days+pdict[product][2]\n                made.append(product)\n                notsearched.remove(product)\n            else:\n                [loopbool,loopstartpoint]=checkloop(pdict,product,inroute,made)\n                if loopbool:\n                    inloop=[]\n                    days=days+daysloop(pdict,loopstartpoint,made,notsearched,inloop)\n                else:\n                    days=days+daysopen(pdict,product,made,notsearched)\n        print days"
  }
]