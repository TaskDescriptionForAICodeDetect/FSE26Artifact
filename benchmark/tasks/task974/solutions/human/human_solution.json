[
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nlong Min(long a,long min,long hito){\n\tfor(int i=0;i<a;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\n\treturn hito;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tfor(int i=0;i<Q;i++){\n\t\tsara[Min(b[i],100000,0)]++;\n\t}\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%id\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567L\n\nclass SegTree{\npublic:\n  int n;\n  vector<long> data, sum; // data: 区間内の値，sum:区間内の実際の和\n  inline void lazy_eval(int k, int l, int r){\n    if(data[k]>0){ // 最新の更新が下に伝搬していないとき\n      sum[k] = data[k]*(r-l);\n      if(k<n-1){\n        data[2*k+1]=data[k];\n        data[2*k+2]=data[k];\n      }\n      data[k]=0;\n    }\n  }\n  void _update(int a, int b, long v, int k, int l, int r){\n    lazy_eval(k,l,r);\n    if(r<=a || b<=l) return;\n    if(a<=l && r<=b){\n      data[k] = v;\n      lazy_eval(k,l,r);\n      return;\n    }\n    int m=(l+r)/2;\n    _update(a,b,v,k*2+1,l,m);\n    _update(a,b,v,k*2+2,m,r);\n    sum[k] = sum[k*2+1] + sum[k*2+2];\n    return;\n  }\n  // [a,b) をvに更新\n  void update(int a, int b, long v){ _update(a,b,v,0,0,n); }\n\n  long _sum(int a, int b, int k, int l, int r){\n    lazy_eval(k,l,r);\n    if(r<=a || b<=l) return 0;\n    if(a<=l && r<=b) return sum[k];\n    int m=(l+r)/2;\n    long vl = _sum(a,b,k*2+1,l,m);\n    long vr = _sum(a,b,k*2+2,m,r);\n    sum[k] = sum[k*2+1] + sum[k*2+2];\n    return vl+vr;\n  }\n  // [a,b) の合計\n  long query(int a,int b){ return _sum(a,b,0,0,n); }\n\n  SegTree(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    data = vector<long>(2*n-1, 0);\n    sum = vector<long>(2*n-1, 0);\n  }\n};\n\nint main(){\n  int n,q;\n  cin>>n>>q;\n  vector<int> a(q);\n  vector<long> b(q);\n  rep(i,q) cin>>a[i]>>b[i];\n\n  SegTree st(n);\n\n  rep(i,q){\n    int li=-1,ri=a[i];\n    while(ri-li>1){\n      int mi=(li+ri)/2;\n      // [mi,a[i])を埋めなおす\n      long sumnew = st.query(mi,a[i]) + b[i];\n      long newh = sumnew/(a[i]-mi);\n      if(sumnew%(a[i]-mi)!=0) newh++;\n\n      if(st.query(mi,mi+1) > newh) li = mi;\n      else ri = mi;\n    }\n    long sumnew = st.query(ri,a[i]) + b[i];\n    long newh = sumnew/(a[i]-ri);\n    long rem = sumnew%(a[i]-ri);\n    st.update(ri+rem, a[i], newh);\n    st.update(ri, ri+rem, newh+1);\n\n//    rep(j,n) cout << st.query(j,j+1) << endl; cout<<endl;\n  }\n\n  rep(i,n) cout << st.query(i,i+1) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing int64 = long long;\n\nclass segment_tree\n{\nprivate:\n\tstd::vector<pair<int64,int>>treedat;\n\tint treesiz;\n\tpair<int64,int> inf;\n\tpair<int64,int> rawqry(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l && r <= b)return treedat[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(rawqry(a, b, k * 2 + 1, l, m), rawqry(a, b, k * 2 + 2, m, r));\n\t}\npublic:\n\tvoid update(int k, pair<int64,int> a)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tvoid update_inc(int k)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k].first++;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tint64 peek(int k)\n\t{\n\t\treturn treedat[k + treesiz - 1].first;\n\t}\n\tpair<int64, int> query(int a, int b) { return rawqry(a, b, 0, 0, treesiz); }\n\tsegment_tree(int n)\n\t{\n\t\tinf = make_pair((int64)LLONG_MAX / 128, n);\n\t\ttreesiz = 1;\n\t\twhile (treesiz < n)treesiz *= 2;\n\t\ttreedat.resize(2 * treesiz + 1);\n\t\tstd::fill(treedat.begin(), treedat.end(), inf);\n\t}\n};\n\nint64 n, q;\n\nsegment_tree *rmq;\n\nint main(void)\n{\n\tscanf(\"%lld %lld\", &n, &q);\n\trmq = new segment_tree(n);\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\trmq->update(j, make_pair((long long)0, j));\n\t}\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tif (b != 1)return -1;\n\t\tauto ret = rmq->query(0, a);\n\t\trmq->update_inc(ret.second);\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tint64 ans = rmq->peek(j);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100001];\nbool flag[100001];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (long long int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start] * (a - start + 1)*(-1) < b) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b % (a - start + 1) == 0) {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1))!=0) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1)!=0)) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b % a == 0) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false&&(b/a)!=0) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stdlib.h>\n#include<string.h>\n#include<queue>\n#define LL long long\nusing namespace std;\ninline LL read( )\n{\n  LL sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int N=100005;\nint n,Q;LL t[N*4],cov[N*4],add[N*4];\ninline void push(int p,int l,int r)\n{\n  int L=p<<1,R=L|1,mid=(l+r)>>1;\n  if(cov[p])\n    {\n      LL u=cov[p];\n      t[L]=u*(mid-l+1);t[R]=u*(r-mid);\n      cov[L]=u;cov[R]=u;add[L]=0;add[R]=0;cov[p]=0;\n    }\n  if(add[p])\n    {\n      LL u=add[p];\n      t[L]+=u*(mid-l+1);t[R]+=u*(r-mid);\n      add[L]+=u;add[R]+=u;add[p]=0;\n    }\n}\nLL v;\ninline void ch(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) {cov[p]=v;add[p]=0;t[p]=v*(r-l+1);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) ch(p<<1,l,mid,L,R);\n  else if(L>mid) ch(p<<1|1,mid+1,r,L,R);\n  else ch(p<<1,l,mid,L,mid),ch(p<<1|1,mid+1,r,mid+1,R);\n  t[p]=t[p<<1]+t[p<<1|1];\n}\ninline void up(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) {add[p]+=v;t[p]+=v*(r-l+1);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) up(p<<1,l,mid,L,R);\n  else if(L>mid) up(p<<1|1,mid+1,r,L,R);\n  else up(p<<1,l,mid,L,mid),up(p<<1|1,mid+1,r,mid+1,R);\n  t[p]=t[p<<1]+t[p<<1|1];\n}\ninline LL ask(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) return t[p];\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) return ask(p<<1,l,mid,L,R);\n  else if(L>mid) return ask(p<<1|1,mid+1,r,L,R);\n  else return ask(p<<1,l,mid,L,mid)+ask(p<<1|1,mid+1,r,mid+1,R);\n}\ninline void DFS(int p,int l,int r)\n{\n  if(l==r) {printf(\"%lld \",t[p]);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  DFS(p<<1,l,mid);\n  DFS(p<<1|1,mid+1,r);\n}\nint main( )\n{\n  int a,l,r,mid,L,len;LL b,t;\n  n=read( );Q=read( );\n  while(Q--)\n    {\n      a=read( );b=read( );\n      if(a==1) {v=b;up(1,1,n,1,1);continue;} //q[0]=inf\n      if(ask(1,1,n,a-1,a-1)-ask(1,1,n,a,a)>=b) {v=b;up(1,1,n,a,a);continue;}\n      l=2;r=a;\n      while(l<=r)\n\t{\n\t  mid=(l+r)>>1;\n\t  if(ask(1,1,n,mid-1,mid-1)*(a-mid+1)-ask(1,1,n,mid,a)<=b) r=mid-1;\n\t  else l=mid+1;\n\t}\n      L=l-1;t=ask(1,1,n,L,L);\n      //printf(\"%d\\n\",L);\n      b-=t*(a-r+1)-ask(1,1,n,r,a);\n      //cout<<b<<endl;\n      v=t;ch(1,1,n,L+1,a);\n      //DFS(1,1,n);puts(\"\");\n      len=a-L+1;\n      v=b/len;\n      if(v) up(1,1,n,L,a);//,printf(\"%d %d %lld\\n\",L,a,v);\n      b%=len;\n      if(b) v=1,up(1,1,n,L,L+b-1);//,printf(\"%d %lld\\n\",L,L+b-1);\n      //DFS(1,1,n);puts(\"\");\n    }\n  DFS(1,1,n);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll INF = (1LL<<60);\n\nstruct segtree{\n  vector<ll> t,u;\n  int n;\n   \n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    t.clear();\n    u.clear();\n    t.resize(2*n);\n    u.resize(2*n);\n    for(int i=0;i<2*n;i++)t[i]=u[i]=0;\n  }\n   \n  void delay(int k,int l,int r){\n    if(r-l==1)return;\n    t[k*2+1]+=u[k];\n    u[k*2+1]+=u[k];\n    t[k*2+2]+=u[k];\n    u[k*2+2]+=u[k];\n    u[k]=0;\n  }\n   \n  void add(int a,int b,ll x,int k,int l,int r){\n    if(b<=l || r<=a)return;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      t[k]+=x;\n      u[k]+=x;\n    }else{\n      int m=(l+r)/2;\n      add(a,b,x,k*2+1,l,m);\n      add(a,b,x,k*2+2,m,r);\n      t[k]=min(t[k*2+1],t[k*2+2]);\n    }\n  }\n   \n  ll query(int a,int b,int k,int l,int r){\n    if(b<=l || r<=a)return INF;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      return t[k];\n    }else{\n      int m=(l+r)/2;\n      ll lc=query(a,b,k*2+1,l,m);\n      ll rc=query(a,b,k*2+2,m,r);\n      return min(lc,rc);\n    }\n  }\n   \n  void add(int a,int b,ll x) {\n    add(a,b,x,0,0,n);\n  }\n   \n  ll query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n\n\nint N,Q;\nsegtree T;\n\nvoid solve(ll a,ll b){\n  while(b){\n\n    //    for(int i=0;i<N;i++)cout<<T.query(i,i+1)<<' ';cout<<endl;\n    \n    ll key=T.query(a-1,a);\n    ll left=0,right=a-1,mid;\n    while(left<right){\n      mid=(left+right)/2;\n      if(T.query(mid,mid+1)>key)left=mid+1;\n      else right=mid;\n    }\n    ll L=left, R=a;\n    //    cout<<L<<' '<<R<<endl<<endl;\n    \n    if(R-L>=b){\n      T.add(L,L+b,1);\n      break;\n    }\n\n    ll target;\n    if(L==0)target=INF;\n    else target=T.query(L-1,L);\n\n    \n    ll total;\n    if(target==INF)total=INF;\n    else total=(R-L)*(target-key);\n    \n    if(b>=total){\n      b-=total;\n      T.add(L,R, target-key );\n    }else{\n      ll esc=b/(R-L);\n      T.add(L,R, esc );\n      b-=esc*(R-L);\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  T.init(N);\n  \n  for(int i=0;i<Q;i++){\n    ll a,b;\n    scanf(\"%lld %lld\",&a,&b);\n    solve(a,b);\n  }\n  \n  for(int i=0;i<N;i++){\n    ll ans=T.query(i,i+1);\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline int in() {\n    int n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k, int l, int r) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(r - l > 1) {\n                    lazy_add[2*k+1] = lazy_add[2*k+2] = 0;\n                    lazy_update[2*k+1] = lazy_update[2*k+2] = lazy_update[k];\n                    lazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n                }\n                lazy_add[k] = 0;\n                lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(r - l > 1){\n                    lazy_add[2*k+1] += lazy_add[k]; lazy_add[2*k+2] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T> v) : sz((int)v.size()){\n            n = 1;\n            while(n < sz) n *= 2;\n            node.resize(2*n-1,numeric_limits<T>::min());\n            lazy_update.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n            lazy_add.resize(2*n-1, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n-1] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) node[i] = max(node[2*i+1],node[2*i+2]);\n        }\n        void update(int a, int b, T x, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true;\n                eval(k, l, r);\n            }else{\n                update(a, b, x, 2*k+1, l, (l+r)/2); update(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        void add(int a, int b, T x, int k=0, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k, l, r);\n            }else{\n                add(a, b, x, 2*k+1, l, (l+r)/2); add(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        T query(int a, int b, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return numeric_limits<T>::min();\n            if(a <= l && r <= b) return node[k];\n            return max(query(a, b, 2*k+1, l, (l+r)/2), query(a, b, 2*k+2, (l+r)/2, r));\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    int n = in(), q = in();\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a = in(), b = in();\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        out(sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\nLL read() {\n    char ch = getchar();\n    LL x = 0, flag = 1;\n    for (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n    for (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x * flag;\n}\nvoid write(int x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x >= 10) write(x / 10);\n    putchar(x % 10 + 48);\n}\n\nconst int Maxn = 100009;\nint n, q;\n\ntemplate <int N> struct SGMTtree {\n\tpair<LL, int> t[N << 3]; LL add[N << 3];\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ls rt << 1, l, mid\n#define rs rt << 1 | 1, mid + 1, r\n\tvoid pushup(int u) {\n\t\tt[u] = min(t[lc(u)], t[rc(u)]);\n\t}\n\tvoid pushdown(int u) {\n\t\tif (add[u]) {\n\t\t\tadd[lc(u)] += add[u]; add[rc(u)] += add[u];\n\t\t\tt[lc(u)].first += add[u]; t[rc(u)].first += add[u];\n\t\t\tadd[u] = 0;\n\t\t}\n\t}\n\n\tvoid build(int rt, int l, int r) {\n\t\tif (l == r) {\n\t\t\tt[rt] = make_pair(0, l);\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1;\n\t\tbuild(ls), build(rs);\n\t\tpushup(rt);\n\t}\n\n\tvoid modify(int rt, int l, int r, int P, int Q, LL v) {\n\t\tif (P > Q) return;\n\t\tif (P <= l && r <= Q) {\n\t\t\tadd[rt] += v; t[rt].first += v;\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) modify(ls, P, Q, v);\n\t\telse if (P >= mid + 1) modify(rs, P, Q, v);\n\t\telse modify(ls, P, Q, v), modify(rs, P, Q, v);\n\t\tpushup(rt);\n\t}\n\n\tpair<LL, int> query(int rt, int l, int r, int P, int Q) {\n\t\tif (P > Q) return {-1, INT_MIN};\n\t\tif (P <= l && r <= Q) return t[rt];\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) return query(ls, P, Q);\n\t\telse if (P >= mid + 1) return query(rs, P, Q);\n\t\telse return min(query(ls, P, Q), query(rs, P, Q));\n\t}\n#undef lc\n#undef rc\n#undef ls\n#undef rs\n}; SGMTtree <Maxn> st;\n\nvoid init() {\n\tn = read(); q = read();\n\tst.build(1, 1, n);\n}\n\nint Find(LL v, int l, int r) {\n\tint ans = -1;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (st.query(1, 1, n, mid, mid).first <= v) l = mid + 1;\n\t\telse r = mid - 1, ans = mid;\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\trep (i, 1, q) {\n\t\tint r = read(); LL v = read();\n\t\tif (r == 1) {\n\t\t\tst.modify(1, 1, n, 1, 1, v);\n\t\t\tv = 0;\n\t\t}\n\t\twhile (v) {\n\t\t\tpair<LL, int> k = st.query(1, 1, n, 1, r);\n\t\t\tint pos = Find(k.first, k.second, r);\n\t\t\tif (pos == -1) pos = r; else --pos;\n\t\t\tLL z = st.query(1, 1, n, 1, k.second - 1).first;\n\n\t\t\tif (z == -1) {\n\t\t\t\tLL rest = v % r, partly = v / r;\n\t\t\t\tst.modify(1, 1, n, 1, r, partly);\n\t\t\t\tif (rest) st.modify(1, 1, n, 1, rest, 1);\n\t\t\t\tv = 0;\n\t\t\t} else {\n\t\t\t\tif ((z - k.first) * (pos - k.second + 1) <= v) {\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, z - k.first);\n\t\t\t\t\tv -= (z - k.first) * (pos - k.second + 1);\n\t\t\t\t} else {\n\t\t\t\t\tLL rest = v % (pos - k.second + 1), partly = v / (pos - k.second + 1);\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, partly);\n\t\t\t\t\tif (rest) st.modify(1, 1, n, k.second, k.second + rest - 1, 1);\n\t\t\t\t\tv = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\n\trep (i, 1, n) \n\t\tprintf(\"%lld\\n\", st.query(1, 1, n, i, i).first);\n}\n\nint main() {\n//\tfreopen(\"ATCs8pc_3_f.in\", \"r\", stdin);\n//\tfreopen(\"ATCs8pc_3_f.out\", \"w\", stdout);\n\n\tinit();\n\tsolve();\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline int in() {\n    int n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline ll in_() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[18], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in_(), q = in_();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in_();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                    st.erase(it2);\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            h[p] += x+1;\n                        }else{\n                            st.erase(it2);\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,ll> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n\n\nint main() {\n  int n,q;\n  scanf(\"%d%d\",&n,&q);\n  map<int,ll> s;\n  s.insert(P(0,LINF));\n  s.insert(P(n,LINF));\n  auto add = [&](map<int,ll>::iterator it, int r, ll x) {\n    // cout<<it->fi<<\" \"<<r<<\" \"<<x<<endl;\n    it->se -= x;\n    if (!it->se) s.erase(it++); else ++it;\n    if (it->fi == r) {\n      it->se += x;\n    } else s.insert(P(r,x));\n  };\n  rep(qi,q) {\n    int m;\n    ll a;\n    scanf(\"%d%lld\",&m,&a);\n    while (a) {\n      auto it = s.lower_bound(m);\n      --it;\n      int w = m-it->fi;\n      ll c = min(a/w, it->se);\n      if (c) {\n        add(it,m,c);\n        a -= c*w;\n      } else {\n        add(it,it->fi+a,1);\n        break;\n      }\n    }\n    // for (auto p : s) cout<<p<<endl;\n    // cout<<\"\"<<endl;\n  }\n  vl ans(n+1);\n  for (auto p : s) ans[p.fi] = -p.se;\n  ans[0] += LINF;\n  rep(i,n) ans[i+1] += ans[i];\n  rep(i,n) printf(\"%lld\\n\",ans[i]);\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint s[100000];\nint n,q,a,b;\nint BNS(int key,int right){\n\tint left=0,mid,ret=right-1;\n\twhile(true){\n\t\tif(left>=right-1)break;\n\t\tmid=(left+right)/2;\n\t\tif(s[mid]==key)ret=min(ret,mid),right=mid;\n\t\telse left=mid;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n>>q;\n\tfor(int i=0;i<n;i++)s[i]=0;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>a>>b;\n\t\tif(b>1)return 0;\n\t\ta--;\n\t\ts[BNS(s[a],a+1)]++;\n\t}\n\tfor(int i=0;i<n;i++)cout<<s[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#include<vector>\ntemplate<typename T>\nstruct lazysegtree{\n\tint n;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,0);\n\t\tlazy.assign(2*n-1,0);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=lazy[i]*(r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazy[i];\n\t\t\t\tlazy[2*i+2]=lazy[i];\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=0;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=x;\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=dat[2*k+1]+dat[2*k+2];\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return 0;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return query(a,b,2*k+1,l,(l+r)/2)+query(a,b,2*k+2,(l+r)/2,r);\n\t}\n};\nint N,Q;\nmain()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tlazysegtree<long>P(N);\n\tfor(;Q--;)\n\t{\n\t\tint a;long b;\n\t\tscanf(\"%d%ld\",&a,&b);\n\t\tlong V;\n\t\tint l=-1,r=a;\n\t\twhile(r-l>1)\n\t\t{\n\t\t\tint m=l+r>>1;\n\t\t\tlong L=P.query(m,m+1)-1;\n\t\t\tlong pL=L;\n\t\t\tlong R=m==0?2e13:P.query(m-1,m)+1;\n\t\t\tlong S=P.query(m,a);\n\t\t\twhile(R-L>1)\n\t\t\t{\n\t\t\t\tlong M=L+R>>1;\n\t\t\t\tif(M*(a-m)-S>b)R=M;\n\t\t\t\telse L=M;\n\t\t\t}\n\t\t\tif(pL==L)l=m;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr=m;\n\t\t\t\tV=L;\n\t\t\t}\n\t\t}\n\t\tb-=V*(a-r)-P.query(r,a);\n\t\tP.update(r,a,V);\n\t\tP.update(r,r+b,V+1);\n\t}\n\tfor(int i=0;i<N;i++)printf(\"%ld\\n\",P.query(i,i+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100001];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\tmemset(res, 0, sizeof(res));\n\tres[0] =20000000000000;\n\tcin >> N >> Q;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n\t\tLL v = res[A];\n\t\tint idx = A;\n\t\tREP(i, A, 0) {\n\t\t\tLL d = res[A-i-1] - res[A-i];\n\t\t\tint i1 = i+1;\n\t\t\tif (d > 0) {\n\t\t\t\tidx = A - i;\n\t\t\t\tif ((LL)(d*i1) <= B) {\n\t\t\t\t\tv += d;\n\t\t\t\t\tB -= (LL)(d*i1);\n\t\t\t\t} else {\n\t\t\t\t\tv += (LL)(B/i1);\n\t\t\t\t\tB-= (LL)(B/i1) * i1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, A + 1, idx) {\n\t\t\tres[i] = v;\n\t\t}\n\t\tif (B > 0) {\n\t\t\tREP(i, B + 1, 1) {\n\t\t\t\tres[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, N + 1, 1) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n >> q;\n    //cout << n << \" \" << q << endl;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, 3*TEN(13)));\n    s.insert(P(n-1, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;            \n            if (d == 0) return 0;\n            if (a == pr.first) s.erase(pr);\n            if (d*(pl.second-pr.second) <= b) {\n                s.erase(pl); \n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {                \n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                if (pr.second + (b+d-1)/d == pl.second) {\n                    s.erase(pl);\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((left + right) >> 1)\n#define lson rt<<1, left, mid\n#define rson rt<<1|1, mid + 1, right\n\ntypedef long long ll;\nconst int N = 1e5 + 5;\n\nll lazy[N << 2], t[N << 2];\nint n, q;\n\nvoid push_up(int rt) {\n    t[rt] = t[rt << 1] + t[rt << 1 | 1];\n}\n\nvoid push_down(int rt, int len) {\n    if (lazy[rt]) {\n        lazy[rt << 1] = lazy[rt];\n        lazy[rt << 1 | 1] = lazy[rt];\n        t[rt << 1] = (ll) lazy[rt] * (len - len / 2);\n        t[rt << 1 | 1] = (ll) lazy[rt] * (len / 2);\n        lazy[rt] = 0;\n    }\n}\n\nvoid update(int rt, int left, int right, int l, int r, ll v) {\n    if (l == left && r == right) {\n        t[rt] = v * (right - left + 1);\n        lazy[rt] = v;\n        return;\n    }\n    push_down(rt, right - left + 1);\n    if (mid >= r) update(lson, l, r, v);\n    else if (mid < l) update(rson, l, r, v);\n    else update(lson, l, mid, v), update(rson, mid + 1, r, v);\n    push_up(rt);\n}\n\nvoid add(int rt, int left, int right, int l, int r) {\n    if (l == left && r == right) {\n        t[rt] += (right - left + 1);\n        lazy[rt] += 1;\n        return;\n    }\n    push_down(rt, right - left + 1);\n    if (mid >= r) add(lson, l, r);\n    else if (mid < l) add(rson, l, r);\n    else add(lson, l, mid), add(rson, mid + 1, r);\n    push_up(rt);\n}\n\nll query(int rt, int left, int right, int l, int r) {\n    if (l == left && r == right) {\n        return t[rt];\n    }\n    push_down(rt, right - left + 1);\n    if (mid >= r) return query(lson, l, r);\n    else if (mid < l) return query(rson, l, r);\n    else return query(lson, l, mid) + query(rson, mid + 1, r);\n}\n\npair<ll, int> left_bound(int rt, int left, int right, int r, ll sum, ll water) {\n    if (right <= 1) return {(water + sum)/ r, 1};\n    if (left >= r) return {water + query(1, 1, n, r, r), r};\n    if (mid >= r) return left_bound(lson, r, sum, water);\n\n    int len = r - mid;\n    ll orginal_sum = query(1,1,n,mid+1, r);\n    ll filling_height_ceil = ((water + orginal_sum) + (len - 1ll)) / len;\n    ll filling_height_floor = (water + orginal_sum) / len;\n    ll val_mid = query(1, 1, n, mid, mid), val_mid_1 = query(1, 1, n, mid + 1, mid + 1);\n    if (filling_height_ceil > val_mid) {\n        return left_bound(lson, r, sum, water);\n    } else if (filling_height_floor < val_mid_1) {\n        return left_bound(rson, r, sum, water);\n    } else return {filling_height_floor, mid + 1};\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> q;\n    while (q--) {\n        int a;\n        ll b;\n        cin >> a >> b;\n        ll cur_sum = query(1, 1, n, 1, a);\n        auto res = left_bound(1, 1, n, a, cur_sum, b);\n        ll original_sum = query(1, 1, n, res.second, a);\n        update(1, 1, n, res.second, a, res.first);\n        b -= res.first * (a - res.second + 1) - original_sum;\n        if (b == 0) continue;\n        add(1, 1, n, res.second, res.second + b - 1);\n    }\n    for (int i = 1; i <= n; i++) {\n        cout << query(1, 1, n, i, i) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100002];\nbool flag[100002];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (long long int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start] * (a - start + 1)*(-1) < b) {\n\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\tflag[start] = false;\n\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b % (a - start + 1) == 0) {\n\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\tif (flag[a + 1] == false && (b / (a - start + 1)) != 0) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\tif (flag[a + 1] == false && (b / (a - start + 1) != 0)) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b % a == 0) {\n\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\tif (flag[a + 1] == false && (b / a) != 0) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    ll sum, val;\n};\n\nstruct IT {\nprivate:\n    vector<Node> t;\n    int n;\n\n    void propagate(int id, int l, int r) {\n        ll &x = t[id].val;\n        if (x != -1) {\n            int m = (l+r)/2;\n            t[2*id].val = t[2*id+1].val = x;\n            t[2*id].sum = (m-l+1)*x;\n            t[2*id+1].sum = (r-m)*x;\n            x = -1;\n        }\n    }\n\n    void update(int id, int l, int r, int i, int j, ll x) {\n        if (l > j || r < i) return;\n        if (i <= l && r <= j) {\n            t[id].val = x;\n            t[id].sum = (r-l+1)*x;\n            return;\n        }\n        propagate(id, l, r);\n        int m = (l+r)/2;\n        update(2*id, l, m, i, j, x); update(2*id+1, m+1, r, i, j, x);\n        t[id].sum = t[2*id].sum + t[2*id+1].sum;\n    }\n\n    long long query(int id, int l, int r, int i, int j) {\n        if (l > j || r < i) return 0;\n        if (i <= l && r <= j) return t[id].sum;\n        propagate(id, l, r);\n        int m = (l+r)/2;\n        return query(2*id, l, m, i, j) + query(2*id+1, m+1, r, i, j);\n    }\n\npublic:\n    IT(int n): n(n) {t.assign(4*n+1, {0, -1});}\n\n    void update(int i, int j, ll x) {update(1, 1, n, i, j, x);}\n\n    long long query(int i, int j) {return query(1, 1, n, i, j);}\n};\n\nint main () {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    IT t(n);\n\n    for(int i = 0; i < q; ++i) {\n        int r; ll p;\n        scanf(\"%d%lld\", &r, &p);\n\n        int lo = 1, hi = r-1, l = r;\n        while (lo <= hi) {\n            int mid = (lo + hi)/2;\n            ll aMid = t.query(mid, mid);\n            ll x = (r-mid+1)*aMid - t.query(mid, r);\n\n            if (x <= p) {\n                l = mid;\n                hi = mid-1;\n            } else\n                lo = mid+1;\n        }\n\n        ll aL = t.query(l, l);\n        p -= (r-l+1) * aL - t.query(l, r);\n\n        ll aNew = aL + p/(r-l+1);\n        int m = l + p%(r-l+1) - 1;\n        t.update(l, m, aNew + 1);\n        t.update(m + 1, r, aNew);\n    }\n\n    for(int i = 1; i <= n; ++i)\n        printf(\"%lld \", t.query(i, i));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll INF = (1LL<<60);\n\nstruct segtree{\n  vector<ll> t,u;\n  int n;\n   \n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    t.clear();\n    u.clear();\n    t.resize(2*n);\n    u.resize(2*n);\n    for(int i=0;i<2*n;i++)t[i]=u[i]=0;\n  }\n   \n  void delay(int k,int l,int r){\n    if(r-l==1)return;\n    t[k*2+1]+=u[k];\n    u[k*2+1]+=u[k];\n    t[k*2+2]+=u[k];\n    u[k*2+2]+=u[k];\n    u[k]=0;\n  }\n   \n  void add(int a,int b,ll x,int k,int l,int r){\n    if(b<=l || r<=a)return;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      t[k]+=x;\n      u[k]+=x;\n    }else{\n      int m=(l+r)/2;\n      add(a,b,x,k*2+1,l,m);\n      add(a,b,x,k*2+2,m,r);\n      t[k]=min(t[k*2+1],t[k*2+2]);\n    }\n  }\n   \n  ll query(int a,int b,int k,int l,int r){\n    if(b<=l || r<=a)return INF;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      return t[k];\n    }else{\n      int m=(l+r)/2;\n      ll lc=query(a,b,k*2+1,l,m);\n      ll rc=query(a,b,k*2+2,m,r);\n      return min(lc,rc);\n    }\n  }\n   \n  void add(int a,int b,ll x) {\n    add(a,b,x,0,0,n);\n  }\n   \n  ll query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n\n\nint N,Q;\nsegtree T;\n\nvoid solve(int a,int b){\n  while(b){\n\n    //    for(int i=0;i<N;i++)cout<<T.query(i,i+1)<<' ';cout<<endl;\n    \n    ll key=T.query(a-1,a);\n    ll left=0,right=a-1,mid;\n    while(left<right){\n      mid=(left+right)/2;\n      if(T.query(mid,mid+1)>key)left=mid+1;\n      else right=mid;\n    }\n    ll L=left, R=a;\n    //    cout<<L<<' '<<R<<endl<<endl;\n    \n    if(R-L>=b){\n      T.add(L,L+b,1);\n      break;\n    }\n\n    ll target;\n    if(L==0)target=(1LL<<30);\n    else target=T.query(L-1,L);\n    ll total=(R-L)*(target-key);\n\n    if(total==0)break;\n    \n    if(b>=total){\n      b-=total;\n      T.add(L,R, target-key );\n    }else{\n      ll esc=b/(R-L);\n      T.add(L,R, esc );\n      b-=esc*(R-L);\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  T.init(N);\n  \n  for(int i=0;i<Q;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    solve(a,b);\n  }\n  \n  for(int i=0;i<N;i++){\n    ll ans=T.query(i,i+1);\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define maxn 200009\nusing namespace std;\nconst int INF=1e9;\nint a[maxn],b[maxn];\nint tree[maxn*4],id[maxn*4];\nint n,m;\nvoid pushup(int rt){\n    if(tree[rt<<1]<tree[rt<<1|1]){\n        tree[rt]=tree[rt<<1];\n        id[rt]=id[rt<<1];\n    }\n    else if(tree[rt<<1]>tree[rt<<1|1]){\n        tree[rt]=tree[rt<<1|1];\n        id[rt]=id[rt<<1|1];\n    }\n    else {\n        if(id[rt<<1]<id[rt<<1|1]){\n            tree[rt]=tree[rt<<1];\n            id[rt]=id[rt<<1];\n        }\n        else{\n            tree[rt]=tree[rt<<1|1];\n            id[rt]=id[rt<<1|1];\n        }\n    }\n}\nvoid build(int l,int r,int rt){\n    if(l==r){\n        tree[rt]=0;\n        id[rt]=l;\n        return;\n    }\n    int m=(l+r)>>1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\nvoid update(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        tree[rt]++;\n        return;\n    }\n    int m=(l+r)>>1;\n    if(L<=m)\n        update(L,R,lson);\n    if(R>m)\n        update(L,R,rson);\n    pushup(rt);\n}\npair<int,int> query(int L,int R,int l,int r,int rt){\n    if(L<=l&&r<=R){\n        return make_pair(tree[rt],id[rt]);\n    }\n    int m=(l+r)>>1;\n    pair<int,int> res1=make_pair(INF,INF);\n    pair<int,int>res2=res1;\n    if(L<=m)\n        res1=query(L,R,lson);\n    if(R>m)\n        res2=query(L,R,rson);\n    return min(res1,res2);\n}\nint main(){\n    cin>>n>>m;\n    build(1,n,1);\n    for(int i=1;i<=m;i++){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        pair<int,int> res=query(1,x,1,n,1);\n        int p=res.second;\n        update(p,p,1,n,1);\n    }\n    for(int i=1;i<=n;i++){\n        pair<int,int> res=query(i,i,1,n,1);\n        printf(\"%d\\n\",res.first);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n#include <ctype.h>\nusing namespace std;\nint n,q,k[100000],i,a,b,minn,minp;\nint main() {\n\tcin >> n >> q;\n\tfor (i = 0; i<n; i++) {\n\t\tk[i] = 0;\n\t}\n\tfor (size_t i = 0; i < q; i++)\n\t{\n\t\tcin >> a >> b;\n\t\tfor (size_t z = 0; z < b; z++)\n\t\t{\n\t\t\tminn = k[0]; minp = 0;\n\t\t\tfor (int j = 1; j < a; j++) {\n\t\t\t\tif (k[j] < minn)\n\t\t\t\t{\n\t\t\t\t\tminn = k[j]; minp = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk[minp]++;\t\t}\n\t}\n\tfor (i = 0; i<n; i++) {\n\t\tcout<<k[i]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n >> q;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, TEN(15)));\n    s.insert(P(n-1, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;\n            if (a == pr.first) s.erase(pr);\n            if (d*(pl.second-pr.second) <= b) {\n                s.erase(pl); \n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {\n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stdlib.h>\n#include<string.h>\n#include<queue>\n#define LL long long\nusing namespace std;\ninline LL read( )\n{\n  LL sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int N=100005;\nint n,Q;LL t[N*4],cov[N*4],add[N*4];\ninline void _cov(int p,LL v,int len)\n{\n  t[p]=v*len;\n  add[p]=0;cov[p]=v;\n}\ninline void _add(int p,LL v,int len)\n{\n  t[p]+=v*len;\n  if(cov[p]==-1) add[p]+=v;\n  else cov[p]+=v;\n}\ninline void push(int p,int l,int r)\n{\n  LL u;int L=p<<1,R=L|1,mid=(l+r)>>1;\n  if((u=add[p])) _add(L,u,mid-l+1),_add(R,u,r-mid),add[p]=0;\n  if((u=cov[p])!=-1) _cov(L,u,mid-l+1),_cov(R,u,r-mid),cov[p]=-1;\n}\nLL v;\ninline void build(int p,int l,int r)\n{\n  cov[p]=-1;if(l==r) return;\n  int mid=(l+r)>>1;build(p<<1,l,mid);build(p<<1|1,mid+1,r);\n}\ninline void ch(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) {_cov(p,v,r-l+1);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) ch(p<<1,l,mid,L,R);\n  else if(L>mid) ch(p<<1|1,mid+1,r,L,R);\n  else ch(p<<1,l,mid,L,mid),ch(p<<1|1,mid+1,r,mid+1,R);\n  t[p]=t[p<<1]+t[p<<1|1];\n}\ninline void up(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) {_add(p,v,r-l+1);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) up(p<<1,l,mid,L,R);\n  else if(L>mid) up(p<<1|1,mid+1,r,L,R);\n  else up(p<<1,l,mid,L,mid),up(p<<1|1,mid+1,r,mid+1,R);\n  t[p]=t[p<<1]+t[p<<1|1];\n}\ninline LL ask(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) return t[p];\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) return ask(p<<1,l,mid,L,R);\n  else if(L>mid) return ask(p<<1|1,mid+1,r,L,R);\n  else return ask(p<<1,l,mid,L,mid)+ask(p<<1|1,mid+1,r,mid+1,R);\n}\ninline void DFS(int p,int l,int r)\n{\n  if(l==r) {printf(\"%lld\\n\",t[p]);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  DFS(p<<1,l,mid);\n  DFS(p<<1|1,mid+1,r);\n}\nint main( )\n{\n  int a,l,r,mid,L,len;LL b,t;\n  n=read( );Q=read( );\n  build(1,1,n);\n  while(Q--)\n    {\n      a=read( );b=read( );\n      if(a==1) {v=b;up(1,1,n,1,1);continue;} //q[0]=inf\n      if(ask(1,1,n,a-1,a-1)-ask(1,1,n,a,a)>=b) {v=b;up(1,1,n,a,a);continue;}\n      l=2;r=a;\n      while(l<=r)\n\t{\n\t  mid=(l+r)>>1;\n\t  if(ask(1,1,n,mid-1,mid-1)*(a-mid+1)-ask(1,1,n,mid,a)<=b) r=mid-1;\n\t  else l=mid+1;\n\t}\n      L=l-1;t=ask(1,1,n,L,L);\n      //printf(\"%d\\n\",L);\n      b-=t*(a-r+1)-ask(1,1,n,r,a);\n      //cout<<b<<endl;\n      v=t;ch(1,1,n,L+1,a);\n      //DFS(1,1,n);puts(\"\");\n      len=a-L+1;\n      v=b/len;\n      if(v) up(1,1,n,L,a);//,printf(\"%d %d %lld\\n\",L,a,v);\n      b%=len;\n      if(b) v=1,up(1,1,n,L,L+b-1);//,printf(\"%d %lld\\n\",L,L+b-1);\n      //DFS(1,1,n);puts(\"\");\n    }\n  DFS(1,1,n);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\nlong n,q,idx;\nlong long val,lazy[1000005],st_max[1000005],st_sum[1000005];\nvoid update(long id,long l,long r,long i,long j,long long x){\n\tif(lazy[id]!=0){\n\t\tst_max[id]=lazy[id];\n\t\tst_sum[id]=(r-l+1)*lazy[id];\n\t\tif(l<r){\n\t\t    lazy[2*id]=lazy[id];\n\t\t    lazy[2*id+1]=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n\tif(l>j||r<i||i>j){\n\t\treturn;\n\t}\n\tif(l>=i&&r<=j){\n\t\tst_max[id]=x;\n\t\tst_sum[id]=(r-l+1)*x;\n\t\tif(l<r){\n\t\t    lazy[2*id]=x;\n\t\t    lazy[2*id+1]=x;\n\t\t}    \n\t\treturn;\n\t}\n\tlong mid=(l+r)/2;\n\tupdate(2*id,l,mid,i,j,x);\n\tupdate(2*id+1,mid+1,r,i,j,x);\n\tst_max[id]=max(st_max[2*id],st_max[2*id+1]);\n\tst_sum[id]=st_sum[2*id]+st_sum[2*id+1];\n}\nlong long get_max(long id,long l,long r,long i,long j){\n\tif(lazy[id]!=0){\n\t\tst_max[id]=lazy[id];\n\t\tst_sum[id]=(r-l+1)*lazy[id];\n\t\tif(l<r){\n\t\t    lazy[2*id]=lazy[id];\n\t\t    lazy[2*id+1]=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n\tif(l>j||r<i||i>j){\n\t\treturn -1e18;\n\t}\n\tif(l>=i&&r<=j){\n\t\treturn st_max[id];\n\t}\n\tlong mid=(l+r)/2;\n\treturn max(get_max(2*id,l,mid,i,j),get_max(2*id+1,mid+1,r,i,j));\n}\nlong long get_sum(long id,long l,long r,long i,long j){\n\tif(lazy[id]!=0){\n\t\tst_max[id]=lazy[id];\n\t\tst_sum[id]=(r-l+1)*lazy[id];\n\t\tif(l<r){\n\t\t    lazy[2*id]=lazy[id];\n\t\t    lazy[2*id+1]=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n\tif(l>j||r<i||i>j){\n\t\treturn 0;\n\t}\n\tif(l>=i&&r<=j){\n\t\treturn st_sum[id];\n\t}\n\tlong mid=(l+r)/2;\n\treturn get_sum(2*id,l,mid,i,j)+get_sum(2*id+1,mid+1,r,i,j);\n}\nlong search(long l,long r,long i,long long val){\n\twhile(l<r){\n\t\tlong mid=(l+r)/2;\n\t\tif((get_max(1,1,n,mid,i)*(i-mid+1)-get_sum(1,1,n,mid,i))<=val){\n\t\t\tr=mid;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\treturn l;\n}\nint main(){\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin>>n>>q;\n\tfor(int vl=1;vl<=q;vl++){\n\t\tcin>>idx>>val;\n\t\tlong pos=search(1,idx,idx,val);\n\t\tlong long dm=get_max(1,1,n,pos,idx);\n\t\tlong long dm3=idx-pos+1;\n\t\tval-=dm*dm3-get_sum(1,1,n,pos,idx);\n\t\tupdate(1,1,n,pos,idx,dm);\n\t\tlong long dm1=val/dm3;\n\t\tlong long dm2=val%dm3;\n\t\tupdate(1,1,n,pos,idx,dm+dm1);\n\t\tupdate(1,1,n,pos,pos+dm2-1,dm+dm1+1);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcout<<get_max(1,1,n,i,i)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll INF = (1LL<<60);\n\nstruct segtree{\n  vector<ll> t,u;\n  int n;\n   \n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    t.clear();\n    u.clear();\n    t.resize(2*n);\n    u.resize(2*n);\n    for(int i=0;i<2*n;i++)t[i]=u[i]=0;\n  }\n   \n  void delay(int k,int l,int r){\n    if(r-l==1)return;\n    t[k*2+1]+=u[k];\n    u[k*2+1]+=u[k];\n    t[k*2+2]+=u[k];\n    u[k*2+2]+=u[k];\n    u[k]=0;\n  }\n   \n  void add(int a,int b,ll x,int k,int l,int r){\n    if(b<=l || r<=a)return;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      t[k]+=x;\n      u[k]+=x;\n    }else{\n      int m=(l+r)/2;\n      add(a,b,x,k*2+1,l,m);\n      add(a,b,x,k*2+2,m,r);\n      t[k]=min(t[k*2+1],t[k*2+2]);\n    }\n  }\n   \n  ll query(int a,int b,int k,int l,int r){\n    if(b<=l || r<=a)return INF;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      return t[k];\n    }else{\n      int m=(l+r)/2;\n      ll lc=query(a,b,k*2+1,l,m);\n      ll rc=query(a,b,k*2+2,m,r);\n      return min(lc,rc);\n    }\n  }\n   \n  void add(int a,int b,ll x) {\n    add(a,b,x,0,0,n);\n  }\n   \n  ll query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n\n\nint N,Q;\nsegtree T;\n\nvoid solve(ll a,ll b){\n  while(b){\n\n    //    for(int i=0;i<N;i++)cout<<T.query(i,i+1)<<' ';cout<<endl;\n    \n    ll key=T.query(a-1,a);\n    ll left=0,right=a-1,mid;\n    while(left<right){\n      mid=(left+right)/2;\n      if(T.query(mid,mid+1)>key)left=mid+1;\n      else right=mid;\n    }\n    ll L=left, R=a;\n    //    cout<<L<<' '<<R<<endl<<endl;\n    \n    if(R-L>=b){\n      T.add(L,L+b,1);\n      break;\n    }\n\n    ll target;\n    if(L==0)target=(1LL<<30);\n    else target=T.query(L-1,L);\n    ll total=(R-L)*(target-key);\n\n    if(total==0)break;\n    \n    if(b>=total){\n      b-=total;\n      T.add(L,R, target-key );\n    }else{\n      ll esc=b/(R-L);\n      T.add(L,R, esc );\n      b-=esc*(R-L);\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  T.init(N);\n  \n  for(int i=0;i<Q;i++){\n    ll a,b;\n    scanf(\"%lld %lld\",&a,&b);\n    solve(a,b);\n  }\n  \n  for(int i=0;i<N;i++){\n    ll ans=T.query(i,i+1);\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n \n \nstruct st {\n\tint id, cnt;\n};\nbool operator<(st a, st b) {\n\tif (a.cnt == b.cnt)return a.id < b.id;\n\treturn a.cnt < b.cnt;\n}\nint cnt[100000];\n \nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tset<st>se;\n\tfor (int i = 1; i <= n; i++) se.insert({ i,0 });\n\trep(i, q) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tif(b!=1)abort();\n\t\tauto it = se.begin();\n\t\tfor (; (*it).id > a; it++);\n\t\tst s=(*it);\n\t\tse.erase(it);\n\t\tcnt[s.id]=s.cnt+1;\n\t\tse.insert({s.id,cnt[s.id]});\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d\\n\", cnt[i]);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n// 寿司を食べたい！！\ntypedef long long int64;\n\nstruct SegmentTree\n{\n  vector< int64 > seg, lazy;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, 0);\n    lazy.assign(2 * sz - 1, -1);\n  }\n\n  void push(int k)\n  {\n    if(lazy[k] >= 0) {\n      if(k < sz - 1) {\n        lazy[2 * k + 1] = lazy[k] >> 1LL;\n        lazy[2 * k + 2] = lazy[k] >> 1LL;\n      }\n      seg[k] = lazy[k];\n      lazy[k] = -1;\n    }\n  }\n\n  int64 query(int a, int b, int k, int l, int r)\n  {\n    push(k);\n    if(a >= r || b <= l) {\n      return (0);\n    } else if(a <= l && r <= b) {\n      return (seg[k]);\n    } else {\n      return (query(a, b, 2 * k + 1, l, (l + r) >> 1) +\n              query(a, b, 2 * k + 2, (l + r) >> 1, r));\n    }\n  }\n\n  int64 query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n\n  void update(int a, int b, int64 x, int k, int l, int r)\n  {\n    push(k);\n    if(a >= r || b <= l) {\n      return;\n    } else if(a <= l && r <= b) {\n      lazy[k] = x * (r - l);\n      push(k);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n      update(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n      seg[k] = seg[2 * k + 1] + seg[2 * k + 2];\n    }\n  }\n\n  void update(int a, int b, int64 x)\n  {\n    update(a, b, x, 0, 0, sz);\n  }\n\n};\n\nsigned main()\n{\n  int N, Q;\n\n  cin >> N >> Q;\n  SegmentTree tree(N);\n  while(Q--) {\n    int A, B;\n    cin >> A >> B;\n    int low = 0, high = A;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(tree.query(mid, mid + 1) * (A - mid) - tree.query(mid, A) > B) low = mid;\n      else high = mid;\n    }\n    if(tree.query(low, low + 1) * (A - low) - tree.query(low, A) > B) ++low;\n    int64 v = tree.query(low, A) + B;\n    int64 width = A - low;\n    tree.update(low, A, v / width + 1);\n    tree.update(low + v % width, A, v / width);\n  }\n  for(int i = 0; i < N; i++) {\n    cout << tree.query(i, i + 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100001];\nbool flag[100001];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start]* (a - start + 1)*(-1) <= b) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b % (a - start + 1) == 0) {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1))!=0) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b % (a - start + 1) / 1000]++;\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1)!=0)) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b % (a - start + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b % a == 0) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false&&b/a!=0) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100001];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\tmemset(res, 0, sizeof(res));\n\tres[0] =20000000000000;\n\tcin >> N >> Q;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n\t\tLL v = res[A];\n\t\tint idx = A;\n\t\tREP(i, A, 0) {\n\t\t\tLL d = res[A-i-1] - res[A-i];\n\t\t\tint i1 = i+1;\n\t\t\tif (d > 0) {\n\t\t\t\tidx = A - i;\n\t\t\t\tif ((LL)(d*i1) <= B) {\n\t\t\t\t\tv += d;\n\t\t\t\t\tB -= (LL)(d*i1);\n\t\t\t\t} else {\n\t\t\t\t\tv += (LL)(B/i1);\n\t\t\t\t\tB-= (LL)(B/i1) * i1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, A + 1, idx) {\n\t\t\tres[i] = v;\n\t\t}\n\t\tREP(i, idx + B, idx) {\n\t\t\tres[i]++;\n\t\t}\n\t}\n\tREP(i, N + 1, 1) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#define mp  make_pair\nusing namespace std;\n\ntypedef long long  LL;\ntypedef pair <int,LL>  PIL;\ntypedef set <PIL>::iterator  Iter;\nint n,q;\nset <PIL> S;\n\nIter pre(Iter x){x--;  return x;}\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tS.insert(mp(0,1LL<<45)),S.insert(mp(1,0)),S.insert(mp(n+1,-1));\n\tfor (int i=1,a,l; i<=q; i++)\n\t\t{\n\t\t\tLL b;\n\t\t\tscanf(\"%d %lld\",&a,&b),a++;\n\t\t\tIter x=pre(S.upper_bound(mp(a,1LL<<60))),y;\n\t\t\tx=(S.insert(mp(a,(*x).second))).first;\n\t\t\twhile (b>0)\n\t\t\t\t{\n\t\t\t\t\ty=pre(x),l=a-(*y).first;\n\t\t\t\t\tif (((*pre(y)).second-(*y).second)*l>=b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (b%l)  S.insert(mp((*y).first+b%l,(*y).second+b/l));\n\t\t\t\t\t\t\tS.erase(y),y=S.insert(mp((*y).first,(*y).second+(b+l-1)/l)).first;\n\t\t\t\t\t\t\tif ((*pre(y)).second==(*y).second)  S.erase(y);\n\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t}else  b-=((*pre(y)).second-(*y).second)*l,S.erase(y);\n\t\t\t\t}\n\t\t\tif ((*pre(x)).second==(*x).second)  S.erase(x);\n\t\t}\n\tfor (Iter x=S.begin(),y; x!=S.end(); y=x,x++)\n\t\tif ((*x).first>1)\n\t\t\tfor (int i=(*y).first; i<(*x).first; i++)\n\t\t\t\tprintf(\"%lld\\n\",(*y).second);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//start:\n//finish:\n#include<bits/stdc++.h>\n#define maxn 100005\nusing namespace std;\ntypedef long long ll;\nll a[maxn*4],flag[maxn]; \nint n,Q;\nvoid down(int x,int l,int r){\n\tint mid=(l+r)/2;\n\tif(!flag[x])return;\n\tflag[x*2]=flag[x];flag[x*2+1]=flag[x];\n\ta[x*2]=1ll*flag[x]*(mid-l+1);\n\ta[x*2+1]=1ll*flag[x]*(r-mid);\n\tflag[x]=0;\n}\nll query(int x,int l,int r,int tx,int ty){\n\tif(l>=tx && r<=ty)return a[x];\n\tdown(x,l,r);\n\tll ret=0,mid=(l+r)>>1;\n\tif(mid>=tx)ret+=query(x*2,l,mid,tx,ty);\n\tif(mid<ty)ret+=query(x*2+1,mid+1,r,tx,ty);\n\treturn ret;\n}\nvoid modify(int x,int l,int r,int tx,int ty,ll val){\n\tif(l>=tx && r<=ty){\n\t\tflag[x]=val;\n\t\ta[x]=1ll*(r-l+1)*val;return;\n\t}\n\tint mid=(l+r)/2;down(x,l,r);\n\tif(mid>=tx)modify(x*2,l,mid,tx,ty,val);\n\tif(mid<ty)modify(x*2+1,mid+1,r,tx,ty,val);\n\ta[x]=a[x*2]+a[x*2+1];\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\twhile(Q--){\n\t\tint x;ll y;\n\t\tscanf(\"%d%lld\",&x,&y);\n\t\tif(x==1){\n\t\t\tmodify(1,1,n,1,1,query(1,1,n,x,x)+y);\n\t\t\tcontinue;\n\t\t}\n\t\tif(query(1,1,n,x-1,x-1)-query(1,1,n,x,x)>=y){\n\t\t\tmodify(1,1,n,x,x,query(1,1,n,x,x)+y);continue;\n\t\t}\n\t\tint l=2,r=x,pos;\n\t\twhile(l<=r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(query(1,1,n,mid-1,mid-1)*(x-mid+1)-query(1,1,n,mid,x)<=y){\n\t\t\t\tpos=mid;r=mid-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl=mid+1;\n\t\t\t}\n\t\t}\n\t//\tcout<<\" \"<<pos<<\" \"<<query(1,1,n,1,1)<<endl;\n\t\tll val=query(1,1,n,pos-1,pos-1);\n\t\tll he=query(1,1,n,pos,x);\n\t\tmodify(1,1,n,pos,x,val);\n\t\ty-=val*(x-pos+1)-he;\n\t\tint num=x-pos+2;\n\t\tif(y/num){\n\t\t\tmodify(1,1,n,pos-1,x,val+y/num);\n\t\t}\n\t\tif(y%num){\n\t\t\tmodify(1,1,n,pos-1,pos-2+y%num,val+y/num+1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%lld\\n\",query(1,1,n,i,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nclass data {\npublic:\n  ll n, k, s;\n  data() : n(1), k(-1), s(0) {}\n};\n\nint dn;\ndata d[444444];\n\ndata unite(data a, data b) {\n  data r;\n  r.n = a.n + b.n;\n  r.k = -1;\n  r.s = a.s + b.s;\n  return r;\n}\n\nvoid deley(int i) {\n  if(d[i].k >= 0) {\n    d[i * 2 + 1].k = d[i].k;\n    d[i * 2 + 1].s = d[i * 2 + 1].n * d[i * 2 + 1].k;\n    d[i * 2 + 2].k = d[i].k;\n    d[i * 2 + 2].s = d[i * 2 + 2].n * d[i * 2 + 2].k;\n  }\n}\n\ndata init() {\n  dn = 1;\n  while(dn <= 111111) { dn *= 2; }\n  for(int i = dn - 2; i >= 0; i--) {\n    d[i] = unite(d[i * 2 + 1], d[i * 2 + 2]);\n  }\n}\n\nvoid replace_(int p, int nb, int ne, int b, int e, ll x) {\n  if(b <= nb && ne <= e) {\n    d[p].k = x;\n    d[p].s = d[p].n * d[p].k;\n    return;\n  }\n  if(ne <= b || e <= nb) {\n    return;\n  }\n  deley(p);\n  int m = (nb + ne) / 2;\n  replace_(p * 2 + 1, nb, m, b, e, x);\n  replace_(p * 2 + 2, m, ne, b, e, x);\n  d[p] = unite(d[p * 2 + 1], d[p * 2 + 2]);\n}\n\nvoid replace(int b, int e, ll x) {\n  replace_(0, 0, dn, b, e, x);\n}\n\nll sum_(int p, int nb, int ne, int e) {\n  if(ne <= e) {\n    return d[p].s;\n  }\n  if(e <= nb) {\n    return 0;\n  }\n  deley(p);\n  int m = (nb + ne) / 2;\n  return sum_(p * 2 + 1, nb, m, e) + sum_(p * 2 + 2, m, ne, e);\n}\n\nll sum(int e) {\n  return sum_(0, 0, dn, e);\n}\n\nll get(ll b, ll l) {\n  return sum(l + 1) - sum(b);\n}\n\nint main() {\n  int n, q;\n  scanf(\"%d%d\", &n, &q);\n  init();\n  replace(0, 1, (ll)10000000000000000);\n  rep(i, q) {\n    ll t, k;\n    scanf(\"%lld%lld\", &t, &k);\n    ll b = 1;\n    ll e = t + 1;\n    while(b < e - 1) {\n      ll m = (b + e) / 2;\n      if(get(m, t) + k <= get(m - 1, m - 1) * (t - m + 1)) {\n        b = m;\n      }\n      else {\n        e = m;\n      }\n    }\n    ll q = get(b, t);\n    ll r = get(b, b);\n    ll a = k - ((t - b + 1) * r - q);\n    replace(b, t + 1, r + a / (t - b + 1));\n    replace(b, b + a % (t - b + 1), r + a / (t - b + 1) + 1);\n  }\n  rep(i, n) {\n    printf(\"%lld\\n\", get(i + 1, i + 1));\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 10;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (mid == a) for(;;);\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tif (a - r + 1 == 0) for(;;);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint s[100010];\n\nint main(void){\n\tint i,j;\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint n,q;\n\tcin >> n >> q;\n\tfor(i=1;i<=q;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\n\t\tint d=s[1],p=1;\n\t\tfor(j=1;j<=a;j++){\n\t\t\tif(d==s[j]) continue;\n\t\t\tif(d>s[j]){\n\t\t\t\td=s[j]; p=j;\n\t\t\t}\n\t\t}\n\n\t\ts[p]++;\n\n\t}\n\n\tfor(i=1;i<=n;i++){\n\t\tcout << s[i] << endl;\n\t}\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\nint read() {\n    char ch = getchar();\n    int x = 0, flag = 1;\n    for (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n    for (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x * flag;\n}\nvoid write(int x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x >= 10) write(x / 10);\n    putchar(x % 10 + 48);\n}\n\nconst int Maxn = 100009;\nint n, q;\n\ntemplate <int N> struct SGMTtree {\n\tpair<LL, int> t[N << 2]; LL add[N << 2];\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ls rt << 1, l, mid\n#define rs rt << 1 | 1, mid + 1, r\n\tvoid pushup(int u) {\n\t\tt[u] = min(t[lc(u)], t[rc(u)]);\n\t}\n\tvoid pushdown(int u) {\n\t\tif (add[u]) {\n\t\t\tadd[lc(u)] += add[u]; add[rc(u)] += add[u];\n\t\t\tt[lc(u)].first += add[u]; t[rc(u)].first += add[u];\n\t\t\tadd[u] = 0;\n\t\t}\n\t}\n\n\tvoid build(int rt, int l, int r) {\n\t\tif (l == r) {\n\t\t\tt[rt] = make_pair(0, l);\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1;\n\t\tbuild(ls), build(rs);\n\t\tpushup(rt);\n\t}\n\tvoid modify(int rt, int l, int r, int P, int Q, LL v) {\n\t\tif (P <= l && r <= Q) {\n\t\t\tadd[rt] += v; t[rt].first += v;\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) modify(ls, P, Q, v);\n\t\telse if (P >= mid + 1) modify(rs, P, Q, v);\n\t\telse modify(ls, P, Q, v), modify(rs, P, Q, v);\n\t\tpushup(rt);\n\t}\n\n\tpair<LL, int> query(int rt, int l, int r, int P, int Q) {\n\t\tif (P > Q) return {-1, INT_MIN};\n\t\tif (P <= l && r <= Q) return t[rt];\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) return query(ls, P, Q);\n\t\telse if (P >= mid + 1) return query(rs, P, Q);\n\t\telse return min(query(ls, P, Q), query(rs, P, Q));\n\t}\n#undef lc\n#undef rc\n#undef ls\n#undef rs\n}; SGMTtree <Maxn> st;\n\nvoid init() {\n\tn = read(); q = read();\n\tst.build(1, 1, n);\n}\n\nint Find(LL v, int l, int r) {\n\tint ans = -1;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (st.query(1, 1, n, mid, mid).first <= v) l = mid + 1;\n\t\telse r = mid - 1, ans = mid;\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\trep (i, 1, q) {\n\t\tint r = read(); LL v = read();\n\t\tif (r == 1) {\n\t\t\tst.modify(1, 1, n, 1, 1, v);\n\t\t\tv = 0;\n\t\t}\n\t\twhile (v) {\n\t\t\tpair<LL, int> k = st.query(1, 1, n, 1, r);\n\t\t\tint pos = Find(k.first, k.second, r);\n\t\t\tif (pos == -1) pos = r; else --pos;\n\t\t\tLL z = st.query(1, 1, n, 1, k.second - 1).first;\n\n\t\t\tif (z == -1) {\n\t\t\t\tLL rest = v % r, partly = v / r;\n\t\t\t\tst.modify(1, 1, n, 1, r, partly);\n\t\t\t\tif (rest) st.modify(1, 1, n, 1, rest, 1);\n\t\t\t\tv = 0;\n\t\t\t} else {\n\t\t\t\tif ((z - k.first) * (pos - k.second + 1) <= v) {\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, z - k.first);\n\t\t\t\t\tv -= (z - k.first) * (pos - k.second + 1);\n\t\t\t\t} else {\n\t\t\t\t\tLL rest = v % (pos - k.second + 1), partly = v / (pos - k.second + 1);\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, partly);\n\t\t\t\t\tif (rest) st.modify(1, 1, n, k.second, k.second - rest + 1, 1);\n\t\t\t\t\tv = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\n\trep (i, 1, n) \n\t\tprintf(\"%lld\\n\", st.query(1, 1, n, i, i).first);\n}\n\nint main() {\n//\tfreopen(\"ATCs8pc_3_f.in\", \"r\", stdin);\n//\tfreopen(\"ATCs8pc_3_f.out\", \"w\", stdout);\n\n\tinit();\n\tsolve();\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cstdio>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ninline ll read() {\n    char ch = getchar(); ll x = 0;\n    while(ch < '0' || ch > '9') ch = getchar();\n    while(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n    return x;\n}\n\n\nconst ll INF = 1e17;\n\nstruct seg {\n    int l, r;\n    ll v;\n\n    seg() {}\n    seg(int a, int b, ll c): l(a), r(b), v(c) {}\n    bool operator <(const seg &b) const {\n        return l < b.l;\n    }\n};\n\nset <seg> s;\nset <seg>:: iterator it;\nvector <seg> del, ins;\n\nvoid print() {\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n            printf(\"(%d %d %lld) \", it->l, it->r, it->v);\n    printf(\"\\n\");\n}\n\nvoid work() {\n    ll y = read(), x = read();\n    it = s.upper_bound(seg(y, 0, 0)), --it;\n    assert(it != s.begin());\n\n    if(y+1 <= it->r) ins.push_back(seg(y+1, it->r, it->v));\n    del.push_back(*it);\n\n    int nl = it->l, nr = y, nv = it->v;\n    for(--it; 1LL*(nr-nl+1)*(it->v-nv) < x;) {\n        x -= 1LL*(nr-nl+1)*(it->v-nv);\n        del.push_back(*it);\n        nl = it->l, nv = it->v, --it;\n    }\n\n    nv += x / (nr-nl+1);\n    x  %= (nr-nl+1), nl = it->r+x+1;\n    if(nl <= nr) ins.push_back(seg(nl, nr, nv));\n    if(it->r < nl-1) ins.push_back(seg(it->r+1, nl-1, nv+1));\n\n    for(int i = 0; i < del.size(); ++i) s.erase(del[i]);\n    for(int i = 0; i < ins.size(); ++i) s.insert(ins[i]);\n    del.clear();\n    ins.clear();\n    //print();\n}\n\n\nint n, q;\nint main() {\n    n = read(), q = read();\n\n    s.insert(seg(0, 0, INF));\n    s.insert(seg(1, n, 0));\n\n    while(q--) work();\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n        for(int j = it->l; j <= it->r; ++j)\n            printf(\"%lld\\n\", it->v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 20;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else if (tree[root].stdl != tree[root].stdr) {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (mid == a) for(;;);\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, long long> P2;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, Q;\nlong long A[100000];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> Q;\n  set<P2> S;\n  S.insert(P2(P(0, N-1), 0));\n  rep(i, Q) {\n    int a;\n    long long b;\n    cin >> a >> b;\n    a--;\n    auto it = --S.upper_bound(P2(P(a+1, -1), -1));\n    P2 p = *it;\n    if (p._1._2 > a) {\n      S.erase(it);\n      S.insert(P2(P(a+1, p._1._2), p._2));\n      it = S.insert(P2(P(p._1._1, a), p._2))._1;\n    }\n    while (true) {\n      P2 cur = *it;\n      int w = cur._1._2-cur._1._1+1;\n      long long lim = INF;\n      if (it != S.begin()) {\n        lim = (--it)->_2 - cur._2;\n        it++;\n      }\n      long long up = min(lim, b/w);\n      cur._2 += up;\n      b -= up*w;\n      if (it != S.begin() && up == lim) {\n        it = S.erase(it);\n        int left = (--it)->_1._1;\n        S.erase(it);\n        it = S.insert(P2(P(left, a), cur._2))._1;\n      }\n      else {\n        S.erase(it);\n        it = S.insert(cur)._1;\n        break;\n      }\n    }\n    if (b > 0) {\n      P2 cur = *it;\n      int left = it->_1._1, border = left+b;\n      S.erase(it);\n      S.insert(P2(P(left, border-1), cur._2+1));\n      S.insert(P2(P(border, a), cur._2));\n    }\n  }\n  for (P2 p : S) {\n    int l = p._1._1, r = p._1._2, val = p._2;\n    for (int i=l; i<=r; i++) A[i] = val;\n  }\n  rep(i, N) cout << A[i] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline ll in() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in(), q = in();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            st.erase(it2);\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                st.insert(p), h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                st.insert(p), h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                st.erase(it2);\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        st.insert(p), h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            st.insert(p), h[p] += x+1;\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                st.erase(it2);\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    st.insert(p), h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    st.insert(p), h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\nconst int maxN = 100 * 1000 + 9;\n\nll segTree[4 * maxN], lazy[4 * maxN];\nbool f[4 * maxN];\n\nvoid propagate(int id, int l, int r){\n\tif(f[id])\n\t\tsegTree[id] = lazy[id] * (r - l + 1);\n\telse \n\t\tsegTree[id] += lazy[id] * (r - l + 1);\n\n\tif(l != r){\n\t\tif(f[id]){\n\t\t\tf[id * 2] = f[id * 2 + 1] = true;\n\t\t\tlazy[id * 2] = lazy[id];\n\t\t\tlazy[id * 2 + 1] = lazy[id];\n\t\t} else {\n\t\t\tlazy[id * 2] += lazy[id];\n\t\t\tlazy[id * 2 + 1] += lazy[id];\n\t\t}\n\t}\n\n\tlazy[id] = 0;\n\tf[id] = 0;\n}\n\nvoid upd(int id, int l, int r, int L, int R, ll val, bool changeTo){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\tlazy[id] = val;\n\t\tf[id] = changeTo;\n\t\tpropagate(id, l, r);\n\t\t//cerr << l << ' ' << r << ' ' << segTree[id] << '\\n';\n\t\treturn;\n\t}\n\t\n\tif(r < L || l > R){\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(id * 2, l, mid, L, R, val, changeTo);\n\tupd(id * 2 + 1, mid + 1, r, L, R, val, changeTo);\n\n\tsegTree[id] = segTree[id * 2] + segTree[id * 2 + 1];\n}\n\nll getSum(int id, int l, int r, int L, int R){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\treturn segTree[id];\n\t}\n\n\tif(r < L || l > R){\n\t\treturn 0;\n\t}\n\t\n\tint mid = (l + r) / 2;\n\treturn getSum(id * 2, l, mid, L, R) + getSum(id * 2 + 1, mid + 1, r, L, R);\n}\n\nint n, q;\n\nvoid read(){\n\tcin >> n >> q;\n}\n\nll aa[maxN];\n\nvoid brute(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tll tot = 0;\n\t\tll foo = -1;\n\t\tfor(int i = r; i > 0; i--){\n\t\t\tint len = r - i + 1;\n\t\t\ttot += aa[i];\n\t\t\tif(p - (aa[i] * len - tot) >= 0){\n\t\t\t\tfoo = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = r; i > foo; i--){\n\t\t\tp -= (aa[foo] - aa[i]);\n\t\t\taa[i] = aa[foo];\n\t\t}\n\n\t\tint P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tfor(int i = foo; i <= r; i++){\n\t\t\taa[i] += P;\n\t\t}\n\t\t\n\t\t//cerr << foo << ' ' << P << ' ' << Q << '\\n';\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\n\t\tfor(int i = foo; i <= foo + Q - 1; i++){\n\t\t\taa[i]++;\n\t\t}\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << aa[i] << ' ';\n\t}\n\tcout << '\\n';\n}\n\nvoid better(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tint lo = 1, hi = r, foo = r;\n\t\twhile(lo <= hi){\n\t\t\tint mid = (lo + hi) / 2;\n\t\t\tif(p - ((r - mid + 1) * getSum(1, 1, n, mid, mid) - getSum(1, 1, n, mid, r)) >= 0){\n\t\t\t\tfoo = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tll x = getSum(1, 1, n, foo, foo);\n\t\tp -= ((r - foo + 1) * x - getSum(1, 1, n, foo, r));\n\n\t\tupd(1, 1, n, foo, r, x, true);\n\t\t//cerr << foo << \", \" << r << \" = \" << x << '\\n';\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t\n\t\tint P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tupd(1, 1, n, foo, r, P, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\n\t\tupd(1, 1, n, foo, foo + Q - 1, 1, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t//cout << \"\\n\\n\\n\";\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << getSum(1, 1, n, i, i);\n\t\tif(i < n){\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n}\n\nvoid solv(){\n\t//if(n <= 2000){\n\t//\tbrute();\n\t//} else {\n\t//\tbetter();\n\t//}\n\n\tbetter();\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n#ifdef h4h4\n\tfreopen((FILENAME + \".inp\").c_str(), \"r\", stdin);\n\tfreopen((FILENAME + \".out\").c_str(), \"w\", stdout);\n#endif\n\t\n\tread();\n\tsolv();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nlong n,q,k[100000],i,a,b,minn,minp,maxn;\nint main() {\n\tcin >> n >> q;\n\tfor (i = 0; i<n; i++) {\n\t\tk[i] = 0;\n\t}\n\tfor (size_t i = 0; i < q; i++)\n\t{\n\t\tcin >> a >> b;\n\t\tfor (size_t z = 0; z < b; z++)\n\t\t{\n\t\t\tminn = k[0]; minp = 0; maxn = k[0];\n\t\t\tfor (long j = 1; j < a; j++) {\n\t\t\t\tif (k[j] < minn)\n\t\t\t\t{\n\t\t\t\t\tminn = k[j]; minp = j;\n\t\t\t\t}\n\t\t\t\tif (maxn < k[0])maxn = k[0];\n\t\t\t}\n\t\t\tif (b>maxn*(a-1))\n\t\t\t{\n\t\t\t\tfor (size_t w = 0; w < a; w++)\n\t\t\t\t{\n\t\t\t\t\tk[w] = (b - b%a) / a;\n\t\t\t\t}\n\t\t\t\tfor (size_t f = 0; f < b%a; f++)\n\t\t\t\t{\n\t\t\t\t\tk[f]++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk[minp]++;}\n\t}\n\tfor (i = 0; i<n; i++) {\n\t\tcout<<k[i]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\ntypedef long long ll;\ntypedef pair<pair<int, ll>, pair<int, ll> > pr_2;\nconst int MAXN = 200005;\nconst ll INF = 1e13;\nint n, Q, L, R;\nll _min[MAXN << 2], lazy[MAXN << 2];\n\nvoid pushdown(const int &o, const int &ls, const int &rs) {\n    _min[ls] += lazy[o], _min[rs] += lazy[o];\n    lazy[ls] += lazy[o], lazy[rs] += lazy[o];\n    lazy[o] = 0;\n}\n\npr_2 find_min(int o, int l, int r, const int &p) {\n    if (l == r)\n        return make_pair(make_pair(l, _min[o]), make_pair(0, INF));\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o])\n        pushdown(o, ls, rs);\n    pr_2 x, y, res;\n    if (p <= mid)\n        return find_min(ls, l, mid, p);\n    x = find_min(ls, l, mid, p), y = find_min(rs, mid + 1, r, p);\n    if (x.first.second == y.first.second)\n        return x;\n    return make_pair(y.first, x.first.second <= y.second.second ? x.first : y.second);\n}\n\nvoid update(const int &o, const int &ls, const int &rs) {\n    _min[o] = min(_min[ls], _min[rs]);\n}\n\nvoid modify(int o, int l, int r, ll v) {\n    if (L <= l && r <= R) {\n        _min[o] += v, lazy[o] += v;\n        return;\n    }\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o])\n        pushdown(o, ls, rs);\n    if (L <= mid)\n        modify(ls, l, mid, v);\n    if (R > mid)\n        modify(rs, mid + 1, r, v);\n    update(o, ls, rs);\n}\n\nvoid get_element(int o, int l, int r) {\n    if (l == r) {\n        printf(\"%lld\\n\", _min[o]);\n        return;\n    }\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o])\n        pushdown(o, ls, rs);\n    get_element(ls, l, mid), get_element(rs, mid + 1, r);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &Q);\n    int a; ll b, dif;\n    pr_2 x;\n    for (int t = 1; t <= Q; t++) {\n        scanf(\"%d %lld\", &a, &b);\n        while (b) {\n            x = find_min(1, 1, n, a);\n            dif = x.second.second - x.first.second;\n            if (dif * (a - x.first.first + 1) >= b) {\n                if (a - x.first.first + 1 < b) {\n                    L = x.first.first, R = a;\n                    modify(1, 1, n, b / (R - L + 1));\n                    b %= (R - L + 1);\n                }\n                L = x.first.first, R = L + b - 1;\n                if (L <= R)\n                    modify(1, 1, n, 1);\n                break;\n            }\n            b -= dif * (a - x.first.first + 1);\n            L = x.first.first, R = a;\n            modify(1, 1, n, dif);\n        }\n    }\n    get_element(1, 1, n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k, int l, int r) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(r - l > 1) {\n                    lazy_add[2*k+1] = lazy_add[2*k+2] = 0;\n                    lazy_update[2*k+1] = lazy_update[2*k+2] = lazy_update[k];\n                    lazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n                }\n                lazy_add[k] = 0;\n                lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(r - l > 1){\n                    lazy_add[2*k+1] += lazy_add[k]; lazy_add[2*k+2] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T> v) : sz((int)v.size()){\n            n = 1;\n            while(n < sz) n *= 2;\n            node.resize(2*n-1,numeric_limits<T>::min());\n            lazy_update.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n            lazy_add.resize(2*n-1, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n-1] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) node[i] = max(node[2*i+1],node[2*i+2]);\n        }\n        void update(int a, int b, T x, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true;\n                eval(k, l, r);\n            }else{\n                update(a, b, x, 2*k+1, l, (l+r)/2); update(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        void add(int a, int b, T x, int k=0, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k, l, r);\n            }else{\n                add(a, b, x, 2*k+1, l, (l+r)/2); add(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        T query(int a, int b, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return numeric_limits<T>::min();\n            if(a <= l && r <= b) return node[k];\n            return max(query(a, b, 2*k+1, l, (l+r)/2), query(a, b, 2*k+2, (l+r)/2, r));\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,q;\n    cin >> n >> q;\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a;\n        ll b;\n        cin >> a >> b;\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        cout << sg.query(i,i+1) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#define md double\n#define LL long long\nusing namespace std;\nconst int N=1<<20;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\ninline LL gL() {\n\tLL w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nLL e[N],sum[N],tag[N],now[N];\nint dep[N];\nint main()\n{\n\tint n=gi(),Q=gi(),i,k,t,ed,siz,L,R,l,r,H=1,mid;LL q,suf,to;\n\tfor (siz=1;siz<n+2;siz=siz<<1|1) H++;\n\tfor (dep[1]=H,i=2;i<=(siz<<1|1);i++) dep[i]=dep[i>>1]-1;\n\te[siz+1]=1LL<<40;\n#define lc (k<<1)\n#define rc (lc|1)\n#define pushdown tag[lc]=tag[rc]=e[lc]=e[rc]=tag[k],sum[lc]=sum[rc]=tag[k]<<dep[lc],tag[k]=0\n#define update e[k]=e[rc],sum[k]=sum[lc]+sum[rc]\n#define modify(k,to) tag[k]=e[k]=(to),sum[k]=(to)<<dep[k]\n\twhile (Q--) {\n\t\tL=siz+1,R=siz+(ed=gi()+1)+1;q=gL();\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=L>>i]) pushdown;\n\t\t\tif ((R>>i)!=k&&tag[k=R>>i]) pushdown;\n\t\t}\n\t\tfor (l=L,now[r=R]=0;l^r^1;l>>=1,r>>=1) {\n\t\t\tif (~l&1) now[l^1]=sum[l^1],now[l>>1]=now[l]+now[l^1]; else now[l>>1]=now[l];\n\t\t\tif (r&1) now[r^1]=sum[r^1],now[r>>1]=now[r^1]+now[r]; else now[r>>1]=now[r];\n\t\t}\n\t\tnow[l>>1]=now[l]+now[r];\n\t\tfor (k=l;(k>>=1)>1;) now[k>>1]=now[k];\n\t\tsuf=0;\n\t\tfor (k=l>>1,l=1,r=1<<dep[k];k<=siz;) {\n\t\t\tif (tag[k]) pushdown;\n\t\t\tif (ed<=(mid=(l+r)>>1)) k<<=1,r=mid;\n\t\t\telse k=k<<1|(mid=(l+r)>>1,q<=e[lc]*(ed-mid)-(r<=ed?sum[rc]:now[rc])-suf?(l=mid+1,1):(suf+=r<=ed?sum[rc]:now[rc],r=mid,0));\n\t\t}\n\t\tsuf+=sum[k];\n\t\tto=(q-(e[i]*(ed-l+1)-suf))/(ed-l+1);\n\t\tq-=to*(ed-l+1)-suf;t=--k;\n\t\tl=k,r=t+q+1;\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=l>>i]) pushdown;\n\t\t\tif ((r>>i)!=k&&tag[k=r>>i]) pushdown;\n\t\t}\n\t\tfor (;l^r^1;) {\n\t\t\tif (~l&1) modify(l^1,to+1);\n\t\t\tif (r&1) modify(r^1,to+1);\n\t\t\tk=l>>=1;update;\n\t\t\tk=r>>=1;update;\n\t\t}\n\t\twhile (k=(l>>=1)) update;\n\t\tl=t+q,r=siz+ed+1;\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=l>>i]) pushdown;\n\t\t\tif ((r>>i)!=k&&tag[k=r>>i]) pushdown;\n\t\t}\n\t\tfor (;l^r^1;) {\n\t\t\tif (~l&1) modify(l^1,to);\n\t\t\tif (r&1) modify(r^1,to);\n\t\t\tk=l>>=1;update;\n\t\t\tk=r>>=1;update;\n\t\t}\n\t\twhile (k=(l>>=1)) update;\n\t}\n\tfor (k=1;k<=siz;k++) if (tag[k]) pushdown;\n\tfor (k=1;k<=n;k++) printf(\"%lld\\n\",e[k+siz+1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cstdio>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n    char ch = getchar(); int x = 0;\n    while(ch < '0' || ch > '9') ch = getchar();\n    while(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n    return x;\n}\n\n\nconst ll INF = 1e17;\n\nstruct seg {\n    int l, r;\n    ll v;\n\n    seg() {}\n    seg(int a, int b, ll c): l(a), r(b), v(c) {}\n    bool operator <(const seg &b) const {\n        return l < b.l;\n    }\n};\n\nset <seg> s;\nset <seg>:: iterator it;\nvector <seg> del, ins;\n\nvoid print() {\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n            printf(\"(%d %d %lld) \", it->l, it->r, it->v);\n    printf(\"\\n\");\n}\n\nvoid work() {\n    ll y = read(), x = read();\n    it = s.upper_bound(seg(y, 0, 0)), --it;\n    assert(it != s.begin());\n\n    if(y+1 <= it->r) ins.push_back(seg(y+1, it->r, it->v));\n    del.push_back(*it);\n\n    int nl = it->l, nr = y, nv = it->v;\n    for(--it; 1LL*(nr-nl+1)*(it->v-nv) < x;) {\n        x -= 1LL*(nr-nl+1)*(it->v-nv);\n        del.push_back(*it);\n        nl = it->l, nv = it->v, --it;\n    }\n\n    nv += x / (nr-nl+1);\n    x  %= (nr-nl+1), nl = it->r+x+1;\n    if(nl <= nr) ins.push_back(seg(nl, nr, nv));\n    if(it->r < nl-1) ins.push_back(seg(it->r+1, nl-1, nv+1));\n\n    for(int i = 0; i < del.size(); ++i) s.erase(del[i]);\n    for(int i = 0; i < ins.size(); ++i) s.insert(ins[i]);\n    del.clear();\n    ins.clear();\n    //print();\n}\n\n\nint n, q;\nint main() {\n    n = read(), q = read();\n\n    s.insert(seg(0, 0, INF));\n    s.insert(seg(1, n, 0));\n\n    while(q--) work();\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n        for(int j = it->l; j <= it->r; ++j)\n            printf(\"%lld\\n\", it->v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\nconst int maxN = 100 * 1000 + 9;\n\nll segTree[4 * maxN], lazy[4 * maxN];\nbool f[4 * maxN];\n\nvoid propagate(int id, int l, int r){\n\tif(f[id])\n\t\tsegTree[id] = lazy[id] * (r - l + 1);\n\telse \n\t\tsegTree[id] += lazy[id] * (r - l + 1);\n\n\tif(l != r){\n\t\tif(f[id]){\n\t\t\tf[id * 2] = f[id * 2 + 1] = true;\n\t\t\tlazy[id * 2] = lazy[id];\n\t\t\tlazy[id * 2 + 1] = lazy[id];\n\t\t} else {\n\t\t\tlazy[id * 2] += lazy[id];\n\t\t\tlazy[id * 2 + 1] += lazy[id];\n\t\t}\n\t}\n\n\tlazy[id] = 0;\n\tf[id] = 0;\n}\n\nvoid upd(int id, int l, int r, int L, int R, ll val, bool changeTo){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\tlazy[id] = val;\n\t\tf[id] = changeTo;\n\t\tpropagate(id, l, r);\n\t\t//cerr << l << ' ' << r << ' ' << segTree[id] << '\\n';\n\t\treturn;\n\t}\n\t\n\tif(r < L || l > R){\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(id * 2, l, mid, L, R, val, changeTo);\n\tupd(id * 2 + 1, mid + 1, r, L, R, val, changeTo);\n\n\tsegTree[id] = segTree[id * 2] + segTree[id * 2 + 1];\n}\n\nll getSum(int id, int l, int r, int L, int R){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\treturn segTree[id];\n\t}\n\n\tif(r < L || l > R){\n\t\treturn 0;\n\t}\n\t\n\tint mid = (l + r) / 2;\n\treturn getSum(id * 2, l, mid, L, R) + getSum(id * 2 + 1, mid + 1, r, L, R);\n}\n\nint n, q;\n\nvoid read(){\n\tcin >> n >> q;\n}\n\nll aa[maxN];\n\nvoid brute(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tll tot = 0;\n\t\tll foo = -1;\n\t\tfor(int i = r; i > 0; i--){\n\t\t\tint len = r - i + 1;\n\t\t\ttot += aa[i];\n\t\t\tif(p - (aa[i] * len - tot) >= 0){\n\t\t\t\tfoo = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = r; i > foo; i--){\n\t\t\tp -= (aa[foo] - aa[i]);\n\t\t\taa[i] = aa[foo];\n\t\t}\n\n\t\tint P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tfor(int i = foo; i <= r; i++){\n\t\t\taa[i] += P;\n\t\t}\n\t\t\n\t\t//cerr << foo << ' ' << P << ' ' << Q << '\\n';\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\n\t\tfor(int i = foo; i <= foo + Q - 1; i++){\n\t\t\taa[i]++;\n\t\t}\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << aa[i] << ' ';\n\t}\n\tcout << '\\n';\n}\n\nvoid better(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tint lo = 1, hi = r, foo = r;\n\t\twhile(lo <= hi){\n\t\t\tint mid = (lo + hi) / 2;\n\t\t\tif(p - ((r - mid + 1) * getSum(1, 1, n, mid, mid) - getSum(1, 1, n, mid, r)) >= 0){\n\t\t\t\tfoo = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tll x = getSum(1, 1, n, foo, foo);\n\t\tp -= ((r - foo + 1) * x - getSum(1, 1, n, foo, r));\n\n\t\tupd(1, 1, n, foo, r, x, true);\n\t\t//cerr << foo << \", \" << r << \" = \" << x << '\\n';\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t\n\t\tint P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tupd(1, 1, n, foo, r, P, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\n\t\tupd(1, 1, n, foo, foo + Q - 1, 1, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t//cout << \"\\n\\n\\n\";\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << getSum(1, 1, n, i, i) << '\\n';\n\t}\n\tcout << '\\n';\n}\n\nvoid solv(){\n\t//if(n <= 2000){\n\t//\tbrute();\n\t//} else {\n\t//\tbetter();\n\t//}\n\n\tbetter();\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n#ifdef h4h4\n\tfreopen((FILENAME + \".inp\").c_str(), \"r\", stdin);\n\tfreopen((FILENAME + \".out\").c_str(), \"w\", stdout);\n#endif\n\t\n\tread();\n\tsolv();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long getint() {\n\tchar ch=getchar();\n\tlong long ret=0,flag=1;\n\twhile(ch<'0'||ch>'9') {\n\t\tif(ch=='-')flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') {\n\t\tret=(ret<<3)+(ret<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn ret*flag;\n}\nchar s[1000005];\nlong long T,ans,sum,n;\nlong long a[1000005];\nlong long f[2][2][1000005];\nlong long cnt[2][2][1000005];\nint main() {\n//\tfreopen(\"sushi.in\",\"r\",stdin);\n//\tfreopen(\"sushi.out\",\"w\",stdout);\n\tT=getint();\n\twhile(T--) {\n\t\tans=(1ll<<63)-1;\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tscanf(\"%s\",s);\n\t\tlong long len=strlen(s);\n\t\tfor(long long i=0; i<len; i++) {\n\t\t\ta[i]=(s[i]=='B');\n\t\t}\n\t\tfor(long long i=0; i<=(len+1)/2-2; i++) {\n\t\t\tcnt[0][a[i]][0]++;\n\t\t\tf[0][a[i]][0]+=i-cnt[0][a[i]][0]+1;\n\t\t}\n\t\tfor(long long i=1; i<len; i++) {\n\t\t\tcnt[0][0][i]=cnt[0][0][i-1];\n\t\t\tcnt[0][1][i]=cnt[0][1][i-1];\n\t\t\tcnt[0][a[i-1]][i]--;\n\t\t\tf[0][0][i]=f[0][0][i-1];\n\t\t\tf[0][1][i]=f[0][1][i-1];\n\t\t\tf[0][1-a[i-1]][i]-=cnt[0][1-a[i-1]][i];\n\t\t\tcnt[0][a[(i+(len+1)/2-2)%len]][i]++;\n\t\t\tf[0][a[(i+(len+1)/2-2)%len]][i]+=(len+1)/2-1-cnt[0][a[(i+(len+1)/2-2)%len]][i];\n\t\t}\n\t\tfor(long long i=len-1; i>=len-(len-1)/2; i--) {\n\t\t\tcnt[1][a[i]][len-1]++;\n\t\t\tf[1][a[i]][len-1]+=len-i-cnt[1][a[i]][len-1];\n\t\t}\n\t\tfor(long long i=len-2; i>=0; i--) {\n\t\t\tcnt[1][0][i]=cnt[1][0][i+1];\n\t\t\tcnt[1][1][i]=cnt[1][1][i+1];\n\t\t\tcnt[1][a[i+1]][i]--;\n\t\t\tf[1][0][i]=f[1][0][i+1];\n\t\t\tf[1][1][i]=f[1][1][i+1];\n\t\t\tf[1][1-a[i+1]][i]-=cnt[1][1-a[i+1]][i];\n\t\t\tcnt[1][a[(i-(len+1)/2+2+len)%len]][i]++;\n\t\t\tf[1][a[(i-(len+1)/2+2+len)%len]][i]+=(len+1)/2-1-cnt[1][a[(i-(len+1)/2+2+len)%len]][i];\n\t\t}\n\t\tfor(long long i=0; i<len; i++) {\n\t\t\tlong long sum=f[0][a[i]][(i+1)%len]+f[1][a[i]][(i-1+len)%len];\n\t\t\tif(!(len&1)) {\n\t\t\t\tif(a[i]==a[(i+len/2)%len]) {\n\t\t\t\t\tif(cnt[0][a[i]][(i+1)%len]>cnt[1][a[i]][(i-1+len)%len]) {\n\t\t\t\t\t\tsum+=len/2-cnt[0][a[i]][(i+1)%len];\n\t\t\t\t\t} else sum+=len/2-cnt[1][a[i]][(i-1+len)%len];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum<ans)ans=sum;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nclass LazySegmentTree {\nprivate:\n\tint size_;\n\tvector<long long> v, lazy;\n\tvoid update(int a, int b, long long x, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = x;\n\t\t\tpush(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, k * 2, l, (l + r) >> 1);\n\t\t\tupdate(a, b, x, k * 2 + 1, (l + r) >> 1, r);\n\t\t\tv[k] = merge(v[k * 2], v[k * 2 + 1]);\n\t\t}\n\t}\n\tlong long query(int a, int b, int k, int l, int r) {\n\t\tpush(k, l, r);\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return v[k];\n\t\tlong long lc = query(a, b, k * 2, l, (l + r) >> 1);\n\t\tlong long rc = query(a, b, k * 2 + 1, (l + r) >> 1, r);\n\t\treturn merge(lc, rc);\n\t}\n \npublic:\n\tLazySegmentTree() : v(vector<long long>()), lazy(vector<long long>()) {};\n\tLazySegmentTree(int n) {\n\t\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\t\tv.resize(size_ * 2);\n\t\tlazy.resize(size_ * 2);\n\t}\n\tinline void push(int k, int l, int r) {\n\t\tif (lazy[k] != 0) {\n\t\t\tv[k] = lazy[k] * (r - l);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[k * 2] = lazy[k];\n\t\t\t\tlazy[k * 2 + 1] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\tinline long long merge(long long x, long long y) {\n\t\treturn x + y;\n\t}\n\tinline void update(int l, int r, long long x) {\n\t\tupdate(l, r, x, 1, 0, size_);\n\t}\n\tinline long long query(int l, int r) {\n\t\treturn query(l, r, 1, 0, size_);\n\t}\n};\n\nLazySegmentTree seg;\nint n,q;\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n>>q;\n\tseg = LazySegmentTree(n);\n\twhile(q--)\n\t{\n\t\tll pos, v;\n\t\tcin>>pos>>v;\n\t\tpos--;\n\t\tll lo = 0; ll hi = pos;\n\t\tll ans = -1;\n\t\twhile(lo<=hi)\n\t\t{\n\t\t\tll mid = (lo+hi)>>1;\n\t\t\tll val = seg.query(mid,mid+1)*(pos-mid+1) - seg.query(mid,pos+1);\n\t\t\tif(val<=v)\n\t\t\t{\n\t\t\t\tans=mid;\n\t\t\t\thi=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlo=mid+1;\n\t\t\t}\n\t\t}\n\t\tll cur = seg.query(ans,ans+1);\n\t\tll val = cur*(pos-ans+1) - seg.query(ans,pos+1);\n\t\tv-=val;\n\t\tcur+=v/(pos-ans+1);\n\t\tv%=(pos-ans+1);\n\t\tseg.update(ans,ans+v,cur+1);\n\t\tseg.update(ans+v,pos+1,cur);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcout<<seg.query(i,i+1)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100002];\nbool flag[100002];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (long long int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start] * (a - start + 1)*(-1) < b) {\n\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\tflag[start] = false;\n\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\tif (flag[a + 1] == false && (b / (a - start + 1) != 0)) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\tnum[1 + b % a]--;\n\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\tif (flag[a + 1] == false && (b / a) != 0) {\n\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sum(x,y) que(1,1,n,x,y)\n#define change(x,y,z) chan(1,1,n,x,y,z)\n#define add(x,y,z) Plus(1,1,n,x,y,z)\n#define mid (l+r>>1)\nusing namespace std;\nlong long sum[400000],fg[400000],ad[400000];\nlong long n,m,a,b; \nvoid down(int now,int l,int r)\n{\n\tif(fg[now])\n\t{\n\t\tfg[now]+=ad[now];\n\t\tfg[now<<1]=fg[now];\n\t\tfg[now<<1|1]=fg[now];\n\t\tad[now]=ad[now<<1]=ad[now<<1|1]=fg[now]=0;\n\t\tsum[now<<1]=fg[now<<1]*(mid-l+1);\n\t\tsum[now<<1|1]=fg[now<<1|1]*(r-mid);\n\t}\n\tif(ad[now])\n\t{\n\t\tad[now<<1]+=ad[now];\n\t\tad[now<<1|1]+=ad[now];\n\t\tsum[now<<1]+=ad[now]*(mid-l+1);\n\t\tsum[now<<1|1]+=ad[now]*(r-mid);\n\t\tad[now]=0; \n\t}\n}\nvoid updata(int now)\n{\n\tsum[now]=sum[now<<1]+sum[now<<1|1];\n}\nvoid chan(int now,int l,int r,int x,int y,long long z)\n{\n\tif(l==x && r==y)\n\t{\n\t\tfg[now]=z;\n\t\tad[now]=0;\n\t\tsum[now]=z*(r-l+1);\n\t\treturn;\n\t}\n\tdown(now,l,r);\n\tif(x<=mid)\n\t\tchan(now<<1,l,mid,x,min(mid,y),z);\n\tif(y>mid)\n\t\tchan(now<<1|1,mid+1,r,max(mid+1,x),y,z);\n\tupdata(now);\n}\nvoid Plus(int now,int l,int r,int x,int y,long long z)\n{\n\tif(l==x && r==y)\n\t{\n\t\tad[now]+=z;\n\t\tsum[now]+=z*(r-l+1);\n\t\treturn;\n\t}\n\tdown(now,l,r);\n\tif(x<=mid)\n\t\tPlus(now<<1,l,mid,x,min(mid,y),z);\n\tif(y>mid)\n\t\tPlus(now<<1|1,mid+1,r,max(mid+1,x),y,z);\n\tupdata(now);\n}\nlong long que(int now,int l,int r,int x,int y)\n{\n\tif(l==x && r==y)\n\t\treturn sum[now];\n\tdown(now,l,r);\n\tlong long ret=0;\n\tif(x<=mid)\n\t\tret+=que(now<<1,l,mid,x,min(y,mid));\n\tif(y>mid)\n\t\tret+=que(now<<1|1,mid+1,r,max(x,mid+1),y);\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%lld\",&a,&b);\n\t\tint l=1,r=a;\n\t\tfor(;l<r;)\n\t\t\tif(sum(mid,mid)*(a-mid+1)-sum(mid,a)<=b)\n\t\t\t\tr=mid;\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\tb-=sum(l,l)*(a-l+1)-sum(l,a);\n\t\tchange(l,a,sum(l,l));\n\t\tadd(l,a,b/(a-l+1));\n\t\tif(b%(a-l+1))\n\t\tadd(l,l+b%(a-l+1)-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%lld\\n\",sum(i,i));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF=1e13;\nconst int maxn=100000+5;\n\nint N,Q;\n\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define mid ((l+r)>>1)\n\n#define val first\n#define pos second\ntypedef pair<ll,int> Min;//Min(val,pos)\n\nMin mn[maxn<<2];\nint add[maxn<<2];\n\nvoid put_up(int x) {\n\tmn[x]=min(mn[lc],mn[rc]);\n}\n\nvoid put_down(int x) {\n\tif(!add[x]) return ;\n\tadd[lc]+=add[x];\n\tmn[lc].val+=add[x];\n\tadd[rc]+=add[x];\n\tmn[rc].val+=add[x];\n\tadd[x]=0;\n}\n\nvoid build(int x,int l,int r) {\n\tmn[x]=Min(0,l);\n\tif(l==r) return ;\n\tbuild(lc,l,mid);\n\tbuild(rc,mid+1,r);\n\tput_up(x);\n}\n\nvoid update(int x,int l,int r,int ql,int qr,int v) {\n\tif(ql<=l&&r<=qr) {\n\t\tadd[x]+=v;\n\t\tmn[x].val+=v;\n\t\treturn ;\n\t}\n\tput_down(x);\n\tif(ql<=mid) update(lc,l,mid,ql,qr,v);\n\tif(qr>mid) update(rc,mid+1,r,ql,qr,v);\n\tput_up(x);\n}\n\nMin query(int x,int l,int r,int ql,int qr) {\n\tif(ql<=l&&r<=qr) return mn[x];\n\tput_down(x);\n\tMin L(INF,N+1),R(INF,N+1);\n\tif(ql<=mid) L=query(lc,l,mid,ql,qr);\n\tif(qr>mid) R=query(rc,mid+1,r,ql,qr);\n\treturn min(L,R);\n}\n\nint main() {\n\tint a,b;\n\tscanf(\"%d%d\",&N,&Q);\n\tbuild(1,1,N);\n\twhile(Q--) {\n\t\tscanf(\"%d%d\",&a,&b);\n\t\twhile(b) {\n\t\t\tMin x=query(1,1,N,1,a);\n\t\t\tif(x.pos==1) {\n\t\t\t\tint c=b/a;\n\t\t\t\tupdate(1,1,N,1,a,c);\n\t\t\t\tif((b-=c*a)>0)\n\t\t\t\t\tupdate(1,1,N,1,b,1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint v=query(1,1,N,x.pos-1,x.pos-1).val;\n\t\t\t\tif((v-x.val)*(a-x.pos+1)>b) {\n\t\t\t\t\tint c=b/(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,c);\n\t\t\t\t\tif((b-=c*(a-x.pos+1))>0) update(1,1,N,x.pos,x.pos+b-1,1);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tb-=(v-x.val)*(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,v-x.val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) printf(\"%lld\\n\",query(1,1,N,i,i).val);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200005;\nint n, Q, L, R;\nll _min[MAXN << 2], lazy[MAXN << 2];\n\nvoid pushdown(const int &o, const int &ls, const int &rs) {\n    _min[ls] += lazy[o], _min[rs] += lazy[o];\n    lazy[ls] += lazy[o], lazy[rs] += lazy[o];\n    lazy[o] = 0;\n}\n\npair<int, ll> find_min(int o, int l, int r, const int &p) {\n    if (l == r)\n        return make_pair(l, _min[o]);\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o])\n        pushdown(o, ls, rs);\n    if (r <= p)\n        return _min[ls] <= _min[rs] ? find_min(ls, l, mid, p) : find_min(rs, mid + 1, r, p);\n    if (p <= mid)\n        return find_min(ls, l, mid, p);\n    pair<int, ll> x, y;\n    x = find_min(ls, l, mid, p), y = find_min(rs, mid + 1, r, p);\n    return x.second == y.second ? x : y;\n}\n\nvoid update(const int &o, const int &ls, const int &rs) {\n    _min[o] = min(_min[ls], _min[rs]);\n}\n\nvoid modify(int o, int l, int r, ll v) {\n    if (L <= l && r <= R) {\n        _min[o] += v, lazy[o] += v;\n        return;\n    }\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o])\n        pushdown(o, ls, rs);\n    if (L <= mid)\n        modify(ls, l, mid, v);\n    if (R > mid)\n        modify(rs, mid + 1, r, v);\n    update(o, ls, rs);\n}\n\nvoid get_element(int o, int l, int r) {\n    if (l == r) {\n        printf(\"%lld\\n\", _min[o]);\n        return;\n    }\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o])\n        pushdown(o, ls, rs);\n    get_element(ls, l, mid), get_element(rs, mid + 1, r);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &Q);\n    int a; ll b;\n    pair<int, ll> x;\n    for (int t = 1; t <= Q; t++) {\n        scanf(\"%d %lld\", &a, &b);\n        while (b) {\n            x = find_min(1, 1, n, a);\n            if (x.first == 1) {\n                if (b / a) {\n                    L = 1, R = a;\n                    modify(1, 1, n, b / a);\n                    b %= a;\n                }\n                if ((L = 1) <= (R = b))\n                    modify(1, 1, n, 1ll);\n                break;\n            }\n            if (a - x.first + 1 >= b) {\n                L = x.first, R = x.first + b - 1;\n                modify(1, 1, n, 1ll);\n                break;\n            } else {\n                L = x.first, R = a;\n                modify(1, 1, n, 1ll);\n                b -= R - L + 1;\n            }\n        }\n    }\n    get_element(1, 1, n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nstatic const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n\ntypedef long long Int;\nInt all[2 * MAX_SIZE - 1], part[2 * MAX_SIZE - 1]; // segment tree\n\n//区間[a, b)に値xを加算する.\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (a <= l && r <= b){ //[l, r)が[a, b)に完全に内包されていれば\n        all[k] += x; //[l, r)の全ての区間が持つ値としてxを足す.\n    }\n    else if (l < b && a < r){ //[l, r)と[a, b)が交差していれば\n        part[k] += (min(b, r) - max(a, l)) * x;  //交差している分の値を, 部分的な和を持つノードに加算する.\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子でも同じ処理を行う.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃.\n    }\n}\n\nInt sum(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (b <= l || r <= a){ //[a, b)と[l, r)が全く交差しない場合\n        return (0);\n    }\n    else if (a <= l && r <= b){ //完全に内包されていれば\n        return (all[k] * (r - l) + part[k]);\n    }\n    else { //[l, r)と[a, b)が交差していれば\n        ll res;\n        res = (min(b, r) - max(a, l)) * all[k]; //そのノードの全ての要素が持つ値のうち, [a, b)に属すものの分だけを加算する.\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2); //子ノードで和を求める.\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r); //〃\n        return (res);\n    }\n}\n\n\nset<int> se;\n\nll myFill(int m, ll b){\n\t// cout<<\"m b \"<<m<<\" \"<<b<<endl;\n\twhile(se.size()>2){\n\t\tset<int>::iterator it = se.upper_bound(m);\n\t\tint r = m;\n\t\tit--;\n\t\tint l = *it;\n\t\tif(l == 0){\n\t\t\treturn b;\n\t\t}\n\t\tll h1 = sum(l-1,l);\n\t\tll h2 = sum(l,l+1);\n\t\t// dump(l);\n\t\tif((h1-h2)*(m-l+1)>=b){\n\t\t\t// se.erase(it);\n\t\t\tse.insert(l+b%(m-l*1));\n\t\t\tadd(l, r+1, b/(m-l+1));\n\t\t\tif(b/(m-l+1)>=1){\n\t\t\t\tse.insert(m+1);\n\t\t\t}\n\t\t\tadd(l, l+b%(m-l+1)+1, 1);\n\t\t\tse.insert(l+b%(m-l+1));\n\t\t\tif(l && sum(l,l+1)==sum(l-1,l)) se.erase(it);\n\t\t\treturn 0;\n\t\t}\n\t\tadd(l, m+1, h1-h2);\n\t\tse.insert(m+1);\n\t\tse.erase(it);\n\t\tb-=(h1-h2)*(m-l+1);\n\t}\n\treturn b;\n}\n\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tint Q;\n\tcin>>Q;\n\tse.insert(0);\n\tse.insert(n);\n\t/*\n9 3\n5 11\n8 4\n4 7\n\t*/\n\trep(i,Q){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tll c = myFill(a-1, b);\n\t\tif(c){\n\t\t\tadd(0, a, c/a);\n\t\t\tif(c/a>=1){\n\t\t\t\tse.insert(a);\n\t\t\t}\n\t\t\tc%=a;\n\t\t\tif(c){\n\t\t\t\tse.insert(c);\n\t\t\t\tadd(0, c, 1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\tcout << sum(i,i+1) << endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define inf (1ll<<30)\n#define free(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\nconst int maxn=100010;\nint n,Q;\nstruct node {int l,r;LL s,tag;}tr[maxn<<2];\n\nvoid pushdown(int k) {\n\tint l=k<<1,r=k<<1|1;LL w=tr[k].tag;tr[k].tag=0;\n\ttr[l].s=(tr[l].r-tr[l].l+1)*w;tr[l].tag=w;\n\ttr[r].s=(tr[r].r-tr[r].l+1)*w;tr[r].tag=w;\n}\nvoid modify(int k,int s,int t,LL val) {\n\tint l=tr[k].l,r=tr[k].r,mid=(l+r)>>1;\n\tif (l==s && r==t) {tr[k].s=val*(tr[k].r-tr[k].l+1);tr[k].tag=val;return;}\n\tif (tr[k].tag) pushdown(k);\n\tif (t<=mid) modify(k<<1,s,t,val);\n\telse if (s>mid) modify(k<<1|1,s,t,val);\n\telse modify(k<<1,s,mid,val),modify(k<<1|1,mid+1,t,val);\n\ttr[k].s=tr[k<<1].s+tr[k<<1|1].s;\n}\nvoid build(int k,int s,int t) {\n\ttr[k].l=s;tr[k].r=t;\n\tif (s==t) return;\n\tint mid=(s+t)>>1;\n\tbuild(k<<1,s,mid);\n\tbuild(k<<1|1,mid+1,t);\n}\nLL query(int k,int s,int t) {\n\tint l=tr[k].l,r=tr[k].r,mid=(l+r)>>1;\n\tif (l==s && r==t) return tr[k].s;\n\tif (tr[k].tag) pushdown(k);\n\tif (t<=mid) return query(k<<1,s,t);\n\telse if (s>mid) return query(k<<1|1,s,t);\n\telse return query(k<<1,s,mid)+query(k<<1|1,mid+1,t);\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&Q);\n\tbuild(1,1,n);\n\tfor (int x,y,i=1;i<=Q;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x==1) {modify(1,1,1,query(1,1,1)+y);continue;}\n\t\tif (query(1,x-1,x-1)-query(1,x,x)>=y) {modify(1,x,x,query(1,x,x)+y);continue;}\n\t\tint l=2,r=x,pos;\n\t\twhile (l<=r) {\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (query(1,mid-1,mid-1)*(x-mid+1)-query(1,mid,x)<=y) r=mid-1,pos=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tLL val=query(1,pos-1,pos-1),num=x-pos+1;\n\t\ty-=val*num-query(1,pos,x);\n\t\tmodify(1,pos,x,val);++num;\n\t\tif (y/num) modify(1,pos-1,x,val+y/num);\n\t\tif (y%num) modify(1,pos-1,pos-2+y%num,val+y/num+1);\n\t}\n\tfor (int i=1;i<=n;i++) printf(\"%lld\\n\",query(1,i,i));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200005;\nconst ll INF = 2e13;\nint n, Q, L, R;\nll sum[MAXN << 2], _min[MAXN << 2], lazy[MAXN << 2];\nll crs_sum[MAXN << 2];\n\nvoid build(int o, int l, int r) {\n    lazy[o] = -1;\n    if (l == r)\n        return;\n    int mid = (l + r) >> 1;\n    build(o << 1, l, mid), build(o << 1 | 1, mid + 1, r);\n}\n\nvoid pushdown(const int &o, const int &l, const int &r) {\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    _min[ls] = _min[rs] = lazy[o];\n    lazy[ls] = lazy[rs] = lazy[o];\n    sum[ls] = (mid - l + 1) * lazy[o], sum[rs] = (r - mid) * lazy[o];\n    lazy[o] = -1;\n}\n\nvoid update(const int &o, const int &ls, const int &rs) {\n    _min[o] = _min[rs], sum[o] = sum[ls] + sum[rs];\n}\n\nvoid get_crs_sum(int o, int l, int r, const int &p) {\n    if (l == r)\n        return;\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (p <= mid) {\n        get_crs_sum(ls, l, mid, p);\n        crs_sum[o] = crs_sum[ls];\n    } else {\n        get_crs_sum(rs, mid + 1, r, p);\n        crs_sum[o] = sum[ls] + crs_sum[rs];\n    }\n}\n\nint find(int o, int l, int r, int p, ll b, ll s) {\n    if (l == r)\n        return l;\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    if (p <= mid)\n        return find(ls, l, mid, p, b, 0);\n    else if (p < r) {\n        if ((p - mid) * _min[ls] - crs_sum[rs] >= b)\n            return find(rs, mid + 1, r, p, b, 0);\n        else\n            return find(ls, l, mid, p, b, crs_sum[rs]);\n    } else {\n        if ((p - mid) * _min[ls] - (s + sum[rs]) >= b)\n            return find(rs, mid + 1, r, p, b, s);\n        else\n            return find(ls, l, mid, p, b, s + sum[rs]);\n    }\n}\n\nll query_sum(int o, int l, int r) {\n    if (L <= l && r <= R)\n        return sum[o];\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    ll res = 0; int mid = (l + r) >> 1;\n    if (L <= mid)\n        res += query_sum(o << 1, l, mid);\n    if (R > mid)\n        res += query_sum(o << 1 | 1, mid + 1, r);\n    return res;\n}\n\nvoid modify(int o, int l, int r, ll v) {\n    if (L <= l && r <= R) {\n        sum[o] = (r - l + 1) * v, _min[o] = lazy[o] = v;\n        return;\n    }\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (L <= mid)\n        modify(ls, l, mid, v);\n    if (R > mid)\n        modify(rs, mid + 1, r, v);\n    update(o, ls, rs);\n}\n\nvoid get_element(int o, int l, int r) {\n    if (l == r) {\n        printf(\"%lld\\n\", _min[o]);\n        return;\n    }\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    get_element(ls, l, mid), get_element(rs, mid + 1, r);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &Q);\n    build(1, 1, n);\n    int a, p; ll b, s, l, r, mid;\n    for (int t = 1; t <= Q; t++) {\n        scanf(\"%d %lld\", &a, &b);\n        get_crs_sum(1, 1, n, a);\n        L = p = find(1, 1, n, a, b, 0), R = a;\n        s = query_sum(1, 1, n);\n        l = 0, r = INF;\n        while (l <= r)\n            (mid = (l + r) >> 1) * (R - L + 1) - s <= b ? l = mid + 1 : r = mid - 1;\n        modify(1, 1, n, r);\n        b = b - (R - L + 1) * r + s;\n        if (L <= (R = L + b - 1))\n            modify(1, 1, n, r + 1);\n    }\n    get_element(1, 1, n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#define mp  make_pair\nusing namespace std;\n\ntypedef long long  LL;\ntypedef pair <int,LL>  PIL;\ntypedef set <PIL>::iterator  Iter;\nint n,q;\nset <PIL> S;\n\nIter pre(Iter x){x--;  return x;}\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tS.insert(mp(0,1LL<<40)),S.insert(mp(1,0)),S.insert(mp(n+1,-1));\n\tfor (int i=1,a,l; i<=q; i++)\n\t\t{\n\t\t\tLL b;\n\t\t\tscanf(\"%d %lld\",&a,&b),a++;\n\t\t\tIter x=pre(S.upper_bound(mp(a,1LL<<60))),y;\n\t\t\tx=(S.insert(mp(a,(*x).second))).first;\n\t\t\twhile (b>0)\n\t\t\t\t{\n\t\t\t\t\ty=pre(x),l=a-(*y).first;\n\t\t\t\t\tif (((*pre(y)).second-(*y).second)*l>=b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (b%l)  S.insert(mp((*y).first+b%l,(*y).second+b/l));\n\t\t\t\t\t\t\tS.erase(y),y=S.insert(mp((*y).first,(*y).second+(b+l-1)/l)).first;\n\t\t\t\t\t\t\tif ((*pre(y)).second==(*y).second)  S.erase(y);\n\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t}else\n\t\t\t\t\t\tb-=((*pre(y)).second-(*y).second)*l,S.erase(y);\n\t\t\t\t}\n\t\t\tif ((*pre(x)).second==(*x).second)  S.erase(x);\n\t\t}\n\tfor (Iter x=S.begin(),y; x!=S.end(); y=x,x++)\n\t\tif ((*x).first>1)\n\t\t\tfor (int i=(*y).first; i<(*x).first; i++)\n\t\t\t\tprintf(\"%lld\\n\",(*y).second);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct P{\n\tint id;\t\t//id\n\tint num;\t//食べた寿司数\n\tbool operator<(const P& p) const{\n\t\tif (num < p.num){\n\t\t\treturn true;\n\t\t}\n\t\tif (num == p.num){\n\t\t\treturn id<p.id;\n\t\t}\n\t\treturn false;\n\t}\n\tP(int _id,int _num){\n\t\tid=_id;\n\t\tnum=_num;\n\t}\n};\nvoid SetMinP(vector<P> &p,int a,long long b)\n{\n\tP minP=p[0];\n\tint minI = 0;\n\twhile (b>0){\n\n\t\tfor (int i=0;i<a;i++){\n\t\t\tif (p[i]<minP){\n\t\t\t\tminP = p[i];\n\t\t\t\tminI=i;\n\t\t\t}\n\t\t}\n\t\tp[minI].num++;\n\t\tminP=p[minI];\n\t\tb--;\n\t}\n\n}\nint main(int argc, char* argv[])\n{\n\tint N,Q;\n\tcin>>N>>Q;\n\tvector<P> pVector;\n\tint i;\n\tfor (i=0;i<N;i++){\n\t\tP p(i+1,0);\n\t\tpVector.push_back(p);\n\t}\n\tint a;\n\tlong long b;\n\tfor (i=0;i<Q;i++){\n\t\tcin>>a>>b;\n\t\tSetMinP(pVector,a,b);\n\t}\n\tfor (i=0;i<pVector.size();i++){\n\t\tcout<<pVector[i].num<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\n/* LazyPropagationSegmentTree(Sum) */\n//0-index\n\nstruct LazySeg_sum{\n  typedef ll Type;\n  \n  struct Data{\n    Type val;\n    Type add;\n    Type sum;\n    bool valset;\n    \n    Type calc_sum(int l, int r){\n      if(valset){\n        return (val + add) * (r - l + 1);\n      }else{\n        return sum + add * (r - l + 1);\n      }\n    }\n\n    void set_data(Type x,Type y){\n      val = x;\n      add = y;\n      valset = true;\n    }\n\n    void add_data(Type x){\n      add += x;\n    }\n    \n    Data():val(0),add(0),sum(0),valset(false){}\n    \n  };\n\n  vector<Data> data;\n  int seg_size;\n  \n  LazySeg_sum(int n){\n    for(seg_size=1; seg_size < n; seg_size*=2);\n    data.assign(seg_size*2, Data());\n  }\n\n  Type set(int a, int b, Type x, int l=0, int r=-1,int k=0){\n    if(r == -1) r = seg_size-1;\n    \n    if(a <= l && r <= b){\n      data[k].set_data(x,0);\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n    \n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val,data[k].add);\n      data[k*2+2].set_data(data[k].val,data[k].add);\n    }else{\n      data[k*2+1].add_data(data[k].add);\n      data[k*2+2].add_data(data[k].add);\n    }\n      \n\n    data[k].add = 0;\n    \n    data[k].valset = false;\n    \n    data[k].sum = set(a,b,x,l,(l+r)/2,k*2+1) + set(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n\n  Type add(int a, int b, Type x, int l=0, int r=-1, int k=0){\n    if(r == -1) r = seg_size-1;\n\n    if(a <= l && r <= b){\n      data[k].add += x;\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n\n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val, data[k].add);\n      data[k*2+2].set_data(data[k].val, data[k].add);\n      data[k].add = 0;\n      data[k].valset = false;\n    }\n\n    data[k].sum = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n  \n  Type query(int a, int b, int l=0, int r=-1, int k = 0){\n    if(r == -1) r = seg_size-1;\n\n    if(r < a || b < l) return 0;\n\n    if((a <= l && r <= b) || data[k].valset){\n      return data[k].calc_sum(max(a,l),min(b,r));\n    }\n\n    return query(a,b,l,(l+r)/2,k*2+1) + query(a,b,(l+r)/2+1,r,k*2+2) +\n           data[k].add * (min(b,r) - max(a,l) + 1);\n  }\n  \n};\n\n\nLazySeg_sum seg(100000);\n\nint main(){\n  int n,q,a,b;\n\n  scanf(\"%d%d\",&n,&q);\n\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n\n    if(a == 0){\n      seg.add(0,0,b);\n      continue;\n    } \n    \n    int l=1,r=a,mid;\n    ll u,p;\n    \n    while(l < r){\n\n      mid = (l+r)/2;\n\n      u = seg.query(mid-1,mid-1);\n      \n      p = seg.query(mid,a);\n\n      if((u * (a-mid+1) - p) > b){\n        l = mid+1;\n      }else{\n        r = mid;\n      }\n    }\n    \n    p = seg.query(l,a);\n    u = seg.query(l-1,l-1);\n\n    while( b < u*(a-l+1) - p ) u--;\n    \n    b -= u*(a-l+1) - p;\n    seg.set(l,a,u);\n    \n    seg.add(l-1,a,b/(a-(l-1)+1));\n    b%=(a-(l-1)+1);\n    \n    if(b > 0)\n      seg.add(l-1,b-1+(l-1),1);\n  }\n  \n  for(int i=0;i<n;i++){\n    printf(\"%lld\\n\",seg.query(i,i));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass SegmentTree\n{\nprivate:\n    int n;\n    vector<long long> data;\n    vector<long long> mulDelay;\n    vector<long long> addDelay;\n    void updateTree(int a, int b, int k, int l, int r, long long mulNum, long long addNum){\n        if(a <= l && r <= b){\n            data[k] *= mulNum;\n            data[k] += addNum * (r - l + 1);\n            mulDelay[k] *= mulNum;\n            addDelay[k] *= mulNum;\n            addDelay[k] += addNum;\n        }\n        else if(a <= r && l <= b){\n            for(int i=0; i<2; ++i){\n                data[k*2+1+i] *= mulDelay[k];\n                data[k*2+1+i] += addDelay[k] * (r - l + 1) / 2;\n                mulDelay[k*2+1+i] *= mulDelay[k];\n                addDelay[k*2+1+i] *= mulDelay[k];\n                addDelay[k*2+1+i] += addDelay[k];\n            }\n            mulDelay[k] = 1;\n            addDelay[k] = 0;\n            updateTree(a, b, k*2+1, l, (l+r)/2, mulNum, addNum);\n            updateTree(a, b, k*2+2, (l+r+1)/2, r, mulNum, addNum);\n            data[k] = data[k*2+1] + data[k*2+2];\n        }\n    }\n    long long getValue(int a, int b, int k, int l, int r){\n        long long ret = 0;\n        if(a <= l && r <= b){\n            return data[k];\n        }else if(a <= r && l <= b){\n            for(int i=0; i<2; ++i){\n                data[k*2+1+i] *= mulDelay[k];\n                data[k*2+1+i] += addDelay[k] * (r - l + 1) / 2;\n                mulDelay[k*2+1+i] *= mulDelay[k];\n                addDelay[k*2+1+i] *= mulDelay[k];\n                addDelay[k*2+1+i] += addDelay[k];\n            }\n            mulDelay[k] = 1;\n            addDelay[k] = 0;\n            ret += getValue(a, b, k*2+1, l, (l+r)/2);\n            ret += getValue(a, b, k*2+2, (l+r+1)/2, r);\n        }\n        return ret;\n    }\npublic:\n    SegmentTree(int n0){\n        n = 1;\n        while(n < n0)\n            n *= 2;\n        data.assign(2*n-1, 0);\n        mulDelay.assign(2*n-1, 1);\n        addDelay.assign(2*n-1, 0);\n    }\n    void set(int a, int b, long long x){ // 区間[a,b]の要素をxにする\n        updateTree(a, b, 0, 0, n-1, 0, x);\n    }\n    void add(int a, int b, long long x){ // 区間[a,b]の要素にxを加算\n        updateTree(a, b, 0, 0, n-1, 1, x);\n    }\n    void mul(int a, int b, long long x){ // 区間[a,b]の要素にxを乗算\n        updateTree(a, b, 0, 0, n-1, x, 0);\n    }\n    long long get(int a, int b){         // 区間[a,b]の総和を返す\n        return getValue(a, b, 0, 0, n-1);\n    }\n};\n\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n\n    SegmentTree st(n);\n    while(--q >= 0){\n        int a;\n        long long b;\n        cin >> a >> b;\n        -- a;\n\n        int left = 0;\n        int right = a;\n        while(left < right){\n            int x = (left + right + 1) / 2;\n            int w = a - x + 1;\n            long long h = st.get(x-1, x-1);\n            long long add = h * w - st.get(x, a);\n            if(b <= add)\n                left = x;\n            else\n                right = x - 1;\n        }\n\n        int x = left;\n        int w = a - x + 1;\n        b += st.get(x, a);\n        st.set(x, a, b / w);\n        if(b % w != 0)\n            st.add(x, x + b % w - 1, 1);\n    }\n\n    for(int i=0; i<n; ++i)\n        cout << st.get(i, i) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n >> q;\n    //cout << n << \" \" << q << endl;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, TEN(15)));\n    s.insert(P(n-1, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;\n            if (a == pr.first) s.erase(pr);\n            if (pl.second-pr.second <= b/d) {\n                s.erase(pl);\n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {                \n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                if (pr.second + (b+d-1)/d == pl.second) {\n                    s.erase(pl);\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        assert(res[i] <= 2*TEN(13));\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD = 998244353;\n\nvector<ll> dy = {1, 0, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {0, 1, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.12lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n//コンビネーション\nconst int MAXcomb = 2000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\nll disit(ll s, ll base = 10){\n  ll res = 0;\n  while(s){\n    res++;\n    s /= base;\n  }\n  return res;\n}\n\n\nconst ll N_ = (1<<18);\nll seg[2*N_-1], pos[2*N_-1];\nvoid update(ll k, ll x){\n  k += N_-1;\n  seg[k] += x;\n  while(k > 0){\n    k = (k-1)/2;\n    if(seg[2*k+1] <= seg[2*k+2]){\n      seg[k] = seg[2*k+1];\n      pos[k] = pos[2*k+1];\n    }else{\n      seg[k] = seg[2*k+2];\n      pos[k] = pos[2*k+2];\n    }\n  }\n}\n\npair<ll, ll> getminimum(ll x, ll y, ll k = 0, ll left = 0, ll right = N_){\n  if(right <= x || y <= left) return {INFL, INFL};\n  if(x <= left && right <= y) return {seg[k], pos[k]};\n  ll mid = (left + right) / 2;\n  pair<ll, ll> l = getminimum(x, y, 2*k+1, left, mid);\n  pair<ll, ll> r = getminimum(x, y, 2*k+2, mid, right);\n  return min(l, r);\n}\n\nll N, Q;\nll a[100010], b[100010];\nll ans[100010];\nvoid one(){\n  rep(i, N){\n    pos[i+N_-1] = i;\n  }\n  rep(i, N_){\n    update(i, 0);\n  }\n  rep(i, Q){\n    pair<ll, ll> x = getminimum(0, a[i]);\n    update(x.s, 1);\n  }\n  rep(i, N){\n    cout << getminimum(i, i+1).f << endl;\n  }\n}\n\nvoid sub(){\n  rep(i, Q){\n    ll rest = b[i];\n    for(ll j = a[i]-2; j >= 0; j--){\n      if(rest == 0) break;\n      //j + 1 .. a[i]-1まで均等におく\n      if(rest >= (ans[j] - ans[j+1]) * (a[i]-1-j)){\n        rest -= (ans[j] - ans[j+1]) * (a[i]-1-j);\n        for(ll k = j + 1; k <= a[i]-1; k++){\n          ans[k] = ans[j];\n        }\n      }else{\n        ll num = a[i]-1-j;\n        ll sum = rest;\n        for(ll k = j + 1; k <= a[i]-1; k++){\n          ans[k] += sum / num;\n        }\n        rep(k, sum % num){\n          ans[j+1+k]++;\n        }\n        rest = 0;\n      }\n    }\n\n    ll num = a[i];\n    ll sum = rest;\n    for(ll k = 0; k <= a[i]-1; k++){\n      ans[k] += sum / num;\n    }\n    rep(k, sum % num){\n      ans[k]++;\n    }\n  }\n  rep(i, N){\n    cout << ans[i] << endl;\n  }\n\n}\n\nvoid solve(){\n  cin >> N >> Q;\n  rep(i, Q){\n    cin >> a[i] >> b[i];\n  }\n  bool allone = 1;\n  rep(i, Q){\n    if(b[i] != 1) allone = 0;\n  }\n  if(allone){\n    one();\n    return;\n  }\n  if(N < 200 && Q < 200){\n    sub();\n  }\n\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define NN 100400\nlong long oo;\nstruct node{\n\tlong long l,r;\n\tlong long max,min;\n\tlong long sum;\n\tlong long fg;\n}tree[NN*4];\nlong long n,q;\nvoid Init(long long l,long long r,long long idd){\n\ttree[idd].l=l;\n\ttree[idd].r=r;\n\ttree[idd].max=tree[idd].min=0;\n\ttree[idd].sum=0;\n\ttree[idd].fg=0;\n\tif(r-l<=1) return ;\n\tlong long mid=(l+r)/2;\n\tInit(l,mid,idd<<1);\n\tInit(mid,r,idd<<1|1);\n}\nvoid Up(long long idd){\n\ttree[idd].sum=tree[idd<<1].sum+tree[idd<<1|1].sum;\n\ttree[idd].max=max(tree[idd<<1].max,tree[idd<<1|1].max);\n\ttree[idd].min=min(tree[idd<<1].min,tree[idd<<1|1].min);\n}\nvoid Down(long long idd){\n\tif(tree[idd].fg){\t\t\n\t\ttree[idd<<1].fg=tree[idd<<1|1].fg=1;\n\t\ttree[idd<<1].min=tree[idd<<1|1].min=tree[idd].min;\n\t\ttree[idd<<1].max=tree[idd<<1|1].max=tree[idd].max;\n\t\ttree[idd<<1].sum=tree[idd].min*(tree[idd<<1].r-tree[idd<<1].l);\n\t\ttree[idd<<1|1].sum=tree[idd].min*(tree[idd<<1|1].r-tree[idd<<1|1].l);\n\t\ttree[idd].fg=0;\n\t}\n}\nlong long u;\nlong long bg;\nlong long ssum;\nlong long ftt;\nvoid Date(long long l,long long r,long long rr,long long num,long long pre,long long idd){\n\tlong long ssum=num+tree[idd].sum+ftt;\n\tlong long avg=ssum/(rr-l);\n\tif(ssum-avg*(rr-l)) avg++;\n\tif(avg>pre) return ;\n\tif(u==-1&&tree[idd].max<=avg) u=avg,bg=l;\n\telse if(u>=avg&&tree[idd].max<=avg)u=avg,bg=l;\n//\tprintf(\"~%d %d %d %lld %lld  %lld\\n\",l,r,bg,u,ssum,pre);\n\tif(r-l<=1) return  ;\n\tDown(idd);\n\tlong long mid=(l+r)/2;\n\tif(tree[idd<<1].min*(rr-tree[idd<<1|1].l)>=tree[idd<<1|1].sum+num) Date(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse {\n\t\tftt+=tree[idd<<1|1].sum;\n\t\tDate(l,mid,rr,num,pre,idd<<1);\n\t} \n\tUp(idd);\n}\nvoid Update(long long l,long long r,long long rr,long long num,long long pre,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tDate(l,r,rr,num,pre,idd);\n\t\tftt+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tUpdate(l,r,rr,num,pre,idd<<1);\n\telse if(mid<=l)\n\t\tUpdate(l,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse{\n\t\tUpdate(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\t\tUpdate(l,mid,rr,num,pre,idd<<1);\t\n\t}\n\tUp(idd);\n}\n\nvoid Query(long long l,long long r,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tssum+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tQuery(l,r,idd<<1);\n\telse if(mid<=l)\n\t\tQuery(l,r,idd<<1|1);\n\telse{\n\t\tQuery(l,mid,idd<<1);\n\t\tQuery(mid,r,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid fugai(long long l,long long r,long long shu,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\ttree[idd].max=tree[idd].min=shu;\n\t\ttree[idd].sum=(r-l)*shu;\n\t\ttree[idd].fg=1;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tfugai(l,r,shu,idd<<1);\n\telse if(mid<=l)\n\t\tfugai(l,r,shu,idd<<1|1);\n\telse{\n\t\tfugai(l,mid,shu,idd<<1);\n\t\tfugai(mid,r,shu,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid Print(long long l,long long r,long long idd){\n\tif(r-l<=1) {\n\t\tprintf(\"%lld\\n\",tree[idd].sum);\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(r+l)/2;\n\tPrint(l,mid,idd<<1);\n\tPrint(mid,r,idd<<1|1);\n\tUp(idd);\n}\nint main(){\n\too=1LL*2000000*10000000+10;\n\tscanf(\"%lld%lld\",&n,&q);\n\tInit(1,n+1,1);\n\tfor(long long i=1;i<=q;i++){\n\t\tlong long x;long long y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tu=-1;bg=-1;\n\t\tftt=0;\n\t\tUpdate(1,x+1,x+1,y,oo,1);\n\t\tssum=0;\n\t\tQuery(bg,x+1,1);\n\t\tlong long num=(x+1)-bg;\n\t\tlong long sum=ssum+y;\n\t\tlong long avg=sum/num;\n\t\tlong long a1=sum-avg*num;\n\t\tif(a1){\n\t\t\tfugai(bg,bg+a1,avg+1,1);\n\t\t}\n\t\tfugai(bg+a1,x+1,avg,1);\n\t//\tPrint(1,n+1,1);\n\t\n\t}\n\tPrint(1,n+1,1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 20;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else if (tree[root].stdl != tree[root].stdr) {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<set>\n#define LL long long\n#define PAIR pair<int,LL>\nusing namespace std;\nint n,q;\nset<PAIR> S;\nset<PAIR> :: iterator it,ot;\nint main()\n{\n\tint x,u; LL y,v,w,s,xyk;\n\tscanf(\"%d %d\",&n,&q);\n\tS.insert(PAIR(0,(LL)(1e18)));\n\tS.insert(PAIR(1,0));\n\tS.insert(PAIR(n+1,0));\n\twhile(q--){\n\t\tscanf(\"%d %lld\",&x,&y);\n\t\tit=S.upper_bound(PAIR(x+1,-1));\n\t\tit--,xyk=it->second;\n\t\twhile(1){\n\t\t\tit=S.upper_bound(PAIR(x+1,-1));\n\t\t\tit--,ot=it,ot--;\n\t\t\tw=ot->second-it->second;\n\t\t\ts=x-it->first+1;\n\t\t\tif(y/s<w){\n\t\t\t\tu=it->first,v=it->second;\n\t\t\t\tS.erase(it);\n\t\t\t\tif(y%s==0)\n\t\t\t\t\tS.insert(PAIR(u,v+y/s));\n\t\t\t\telse{\n\t\t\t\t\tS.insert(PAIR(u,v+y/s+1));\n\t\t\t\t\tS.insert(PAIR(u+y%s,v+y/s));\n\t\t\t\t\tit=S.find(PAIR(u,v+y/s+1));\n\t\t\t\t\tot=it,ot--;\n\t\t\t\t\tif(ot->second==v+y/s+1)\n\t\t\t\t\t\tS.erase(it);\n\t\t\t\t  }\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\ty-=w*s;\n\t\t\tS.erase(it);\n\t\t  }\n\t\tif(x<n){\n\t\t\tit=S.upper_bound(PAIR(x+1,-1));\n\t\t\tot=it,it--;\n\t\t\tif(it->second>xyk&&ot->first>x+1)\n\t\t\t\tS.insert(PAIR(x+1,xyk));\n\t\t  }\n\t  }\n\tit=S.begin(),it++,x=1;\n\tfor(;it!=S.end();it++){\n\t\tfor(u=x;u<it->first;u++)\n\t\t\tprintf(\"%lld\\n\",y);\n\t\tx=it->first,y=it->second;\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld%ld\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tif(Q<=10000&&N<=10000){\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tMin(a[i],9223372036854775806,0);\n\t\t}\n\t}\n\n\n\t\n\tfor(int i=0;i<N;i++){\n\tprintf(\"%ld\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\n/* LazyPropagationSegmentTree(Sum) */\n//0-index\n\nstruct LazySeg_sum{\n  typedef ll Type;\n  \n  struct Data{\n    Type val;\n    Type add;\n    Type sum;\n    bool valset;\n    \n    Type calc_sum(int l, int r){\n      if(valset){\n        return (val + add) * (r - l + 1);\n      }else{\n        return sum + add * (r - l + 1);\n      }\n    }\n\n    void set_data(Type x,Type y){\n      val = x;\n      add = y;\n      valset = true;\n    }\n\n    void add_data(Type x){\n      add += x;\n    }\n    \n    Data():val(0),add(0),sum(0),valset(false){}\n    \n  };\n\n  vector<Data> data;\n  int seg_size;\n  \n  LazySeg_sum(int n){\n    for(seg_size=1; seg_size < n; seg_size*=2);\n    data.assign(seg_size*2, Data());\n  }\n\n  Type set(int a, int b, Type x, int l=0, int r=-1,int k=0){\n    if(r == -1) r = seg_size-1;\n    \n    if(a <= l && r <= b){\n      data[k].set_data(x,0);\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n    \n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val,data[k].add);\n      data[k*2+2].set_data(data[k].val,data[k].add);\n    }else{\n      data[k*2+1].add_data(data[k].add);\n      data[k*2+2].add_data(data[k].add);\n    }\n      \n\n    data[k].add = 0;\n    \n    data[k].valset = false;\n    \n    data[k].sum = set(a,b,x,l,(l+r)/2,k*2+1) + set(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n\n  Type add(int a, int b, Type x, int l=0, int r=-1, int k=0){\n    if(r == -1) r = seg_size-1;\n\n    if(a <= l && r <= b){\n      data[k].add += x;\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n\n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val, data[k].add);\n      data[k*2+2].set_data(data[k].val, data[k].add);\n      data[k].add = 0;\n      data[k].valset = false;\n    }\n\n    data[k].sum = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n  \n  Type query(int a, int b, int l=0, int r=-1, int k = 0){\n    if(r == -1) r = seg_size-1;\n\n    if(r < a || b < l) return 0;\n\n    if((a <= l && r <= b) || data[k].valset){\n      return data[k].calc_sum(max(a,l),min(b,r));\n    }\n\n    return query(a,b,l,(l+r)/2,k*2+1) + query(a,b,(l+r)/2+1,r,k*2+2) +\n           data[k].add * (min(b,r) - max(a,l) + 1);\n  }\n  \n};\n\n\nLazySeg_sum seg(100000);\n\nint main(){\n  int n,q,a;\n  ll b;\n\n  scanf(\"%d%d\",&n,&q);\n\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d%lld\",&a,&b);\n    a--;\n\n    if(a == 0){\n      seg.add(0,0,b);\n      continue;\n    } \n    \n    int l=1,r=a,mid;\n    ll u,p;\n    \n    while(l < r){\n\n      mid = (l+r)/2;\n\n      u = seg.query(mid-1,mid-1);\n      \n      p = seg.query(mid,a);\n\n      if((u * (a-mid+1) - p) > b){\n        l = mid+1;\n      }else{\n        r = mid;\n      }\n    }\n    \n    p = seg.query(l,a);\n    u = seg.query(l-1,l-1);\n\n    while( b < u*(a-l+1) - p ) u--;\n    \n    b -= u*(a-l+1) - p;\n    seg.set(l,a,u);\n    \n    seg.add(l-1,a,b/(a-(l-1)+1));\n    b%=(a-(l-1)+1);\n    \n    if(b > 0)\n      seg.add(l-1,b-1+(l-1),1);\n  }\n  \n  for(int i=0;i<n;i++){\n    printf(\"%lld\\n\",seg.query(i,i));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 111111;\nconst ll INF = 1000000000000000000LL;\n\nclass SEG{\n  int n;\n  ll dat[2*(1<<18)-1];\n\npublic:\n  SEG(int _n = MAX){ \n    n = 1;\n    while(n < _n) n *= 2;\n    fill(dat,dat+2*n-1,0);\n  }\n\n  // get k-th\n  ll get(int k){\n    k += n - 1;\n    ll ret = dat[k];\n    while(k > 0){\n      k = (k - 1) / 2;\n      ret += dat[k];\n    }\n    return ret;\n  }\n\n  // add x to [a,b) \n  void query(int a, int b,ll x ){ return query(a, b, x, 0, 0, n);}\n  void query(int a, int b, ll x, int k, int l, int r){\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b) dat[k] += x;\n    else{\n      query(a, b, x, k*2+1, l, (l+r)/2);\n      query(a, b, x, k*2+2, (l+r)/2, r);\n    }\n  }\n};\n\nSEG seg;\nint N,Q;\n\n\nvoid calc(ll a,ll b){\n  //  cout << \"calc : \" << a << \" \" << b << endl;\n  ll x = seg.get( a );\n  int st = 0, ed = a;\n  int r = a;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( seg.get(h) == x ) {\n      r = h;\n      ed = h-1;\n    } else\n      st = h+1;    \n  }\n\n  ll inv = a-r+1;\n  if( r == 0 ){\n    seg.query( 0, a+1, b/(a+1) );\n    seg.query( 0, b%(a+1), 1 );\n  } else {\n    ll y = seg.get( r-1 );\n    if( b > (y-x) * inv ){\n      seg.query( r, a+1, (y-x) );\n      calc(a, b-(y-x)*inv);\n    } else {\n      seg.query( r, a+1, b / inv );\n      seg.query( r, r + b % inv, 1 );      \n    }\n  }\n}\n\nint main(){\n  cin >> N >> Q;\n  for(int i=0;i<Q;i++){\n    ll a,b; cin >> a >> b; --a;\n    calc( a, b );\n  }\n  for(int i=0;i<N;i++){\n    cout << seg.get(i) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nstatic const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n\ntypedef long long Int;\nInt all[2 * MAX_SIZE - 1], part[2 * MAX_SIZE - 1]; // segment tree\n\n//区間[a, b)に値xを加算する.\nvoid add(int a, int b, Int x, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (a <= l && r <= b){ //[l, r)が[a, b)に完全に内包されていれば\n        all[k] += x; //[l, r)の全ての区間が持つ値としてxを足す.\n    }\n    else if (l < b && a < r){ //[l, r)と[a, b)が交差していれば\n        part[k] += (min(b, r) - max(a, l)) * x;  //交差している分の値を, 部分的な和を持つノードに加算する.\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子でも同じ処理を行う.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃.\n    }\n}\n\nInt sum(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (b <= l || r <= a){ //[a, b)と[l, r)が全く交差しない場合\n        return (0);\n    }\n    else if (a <= l && r <= b){ //完全に内包されていれば\n        return (all[k] * (r - l) + part[k]);\n    }\n    else { //[l, r)と[a, b)が交差していれば\n        ll res;\n        res = (min(b, r) - max(a, l)) * all[k]; //そのノードの全ての要素が持つ値のうち, [a, b)に属すものの分だけを加算する.\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2); //子ノードで和を求める.\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r); //〃\n        return (res);\n    }\n}\n\n\nset<int> se;\n\nll myFill(int m, ll b){\n\t// cout<<\"m b \"<<m<<\" \"<<b<<endl;\n\twhile(se.size()>2){\n\t\tset<int>::iterator it = se.upper_bound(m);\n\t\tit--;\n\t\tint l = *it;\n\t\tif(l == 0){\n\t\t\treturn b;\n\t\t}\n\t\tll h1 = sum(l-1,l);\n\t\tll h2 = sum(l,l+1);\n\t\t// dump(l);\n\t\tif((h1-h2)*(m-l+1)>=b){\n\t\t\t// se.erase(it);\n\t\t\tadd(l, m+1, b/(m-l+1));\n\t\t\tif(b/(m-l+1)>=1){\n\t\t\t\tse.insert(m+1);\n\t\t\t}\n\t\t\tadd(l, l+b%(m-l+1), 1);\n\t\t\tse.insert(l+b%(m-l+1));\n\t\t\tif(sum(l,l+1)==sum(l-1,l)) se.erase(it);\n\t\t\treturn 0;\n\t\t}\n\t\tadd(l, m+1, h1-h2);\n\t\tse.insert(m+1);\n\t\tse.erase(it);\n\t\tb-=(h1-h2)*(m-l+1);\n\t}\n\treturn b;\n}\n\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tint Q;\n\tcin>>Q;\n\tse.insert(0);\n\tse.insert(n);\n\trep(i,Q){\n\t\t// dump(i);\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tll c = myFill(a-1, b);\n\t\tif(c){\n\t\t\t// cout << \"c a \"<<c << \" \" << a << endl;\n\t\t\tadd(0, a, c/a);\n\t\t\tif(c/a>=1){\n\t\t\t\tse.insert(a);\n\t\t\t}\n\t\t\tc%=a;\n\t\t\tif(c){\n\t\t\t\tse.insert(c);\n\t\t\t\tadd(0, c, 1);\n\t\t\t}\n\t\t}\n\t\t// cout << \"sum \"<<endl;\n\t\t// rep(j,n){\n\t\t// \tcout << sum(j,j+1) << endl;\n\t\t// }cout<<endl;\n\t\t// cout<<\"set\"<<endl;\n\t\t// for(int x:se){\n\t\t// \tcout<<x<<\" \";\n\t\t// }cout<<endl;\n\t}\n\trep(i,n){\n\t\tcout << sum(i,i+1) << endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld%ld\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tif(Q<=100000&&N<=100000){\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tMin(a[i],9223372036854775806,0);\n\t\t}\n\t}\n\n\n\t\n\tfor(int i=0;i<N;i++){\n\tprintf(\"%ld\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct RRange {\n\tint l, r;\n\tlong long int num;\n\tRRange(const int a, const int b, const long long int c) {\n\t\tl = a, r = b, num = c;\n\t\treturn;\n\t}\n\tbool operator<(const RRange& rr)const {\n\t\treturn r < rr.r;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tset<RRange>sr;\n\tsr.insert(RRange(1, N, 0));\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> L >> R;\n\t\tauto bag = sr.lower_bound(RRange(1, L, 0));\n\t\tif (bag->r != L) {\n\t\t\tint l = bag->l;\n\t\t\tint r = bag->r;\n\t\t\tlong long int num = bag->num;\n\t\t\tsr.erase(bag);\n\t\t\tsr.insert(RRange(l, L, num));\n\t\t\tsr.insert(RRange(L + 1, r, num));\n\t\t}\n\t\twhile (R) {\n\t\t\tauto box = sr.lower_bound(RRange(1, L, 0));\n\t\t\tif (box == sr.begin()) {\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tif (R%r) {\n\t\t\t\t\tsr.insert(RRange(l, l + (R%r) - 1, num + R / r + 1));\n\t\t\t\t\tsr.insert(RRange(l + (R%r), r, num + R / r));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum += R / r;\n\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t}\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << \"Hi\";\n\t\t\t\tauto bag = prev(box);\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tlong long int dif = (bag->num) - num;\n\t\t\t\tdif *= r - l + 1;\n\t\t\t\t//cout <<\"dif \"<< dif << endl;\n\t\t\t\tif (dif-(r-l+1) >= R) {\n\t\t\t\t\tif (R%r) {\n\t\t\t\t\t\tsr.insert(RRange(l, l + (R%(r-l+1)) - 1, num + R / (r-l+1) + 1));\n\t\t\t\t\t\tsr.insert(RRange(l + (R%(r-l+1)), r, num + R / (r-l+1)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum += R / (r-l+1);\n\t\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t\t}\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t\telse if (dif <= R) {\n\t\t\t\t\tassert(0);\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, r, nnum));\n\t\t\t\t\tR -= dif;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint m = R % (r - l + 1);\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tint rr = bag->r;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, rr + m, nnum));\n\t\t\t\t\tsr.insert(RRange(rr + m + 1, r, nnum - 1));\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"R \" << R << endl;\n\n\t\t}\n\t}\n\tfor (auto i : sr) {\n\t\tfor (int j = i.l; j <= i.r; j++) {\n\t\t\tcout << i.num << endl;\n\t\t}\n\t\t//cout << i.l << \" \" << i.r << \" \" << i.num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<class T> ostream &operator <<(ostream &os, const vector<T> &v) {\n    for (T x : v) os << x << \" \";\n    return os;\n}\n\nvector<ll> restore(multiset<pair<int, ll>> st) {\n    vector<ll> ans;\n    int pre = 0;\n    for (auto kv : st) {\n        for (int i = 0; i < kv.first - pre; i++) {\n            ans.push_back(kv.second);\n        }\n        pre = kv.first;\n    }\n    return ans;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    multiset<pair<int, ll>> st; // sum, val\n    const ll inf = ll(2e13) + 100;\n    st.emplace(0, inf);\n    st.emplace(n, 0);\n\n    for (int i = 0; i < q; i++) {\n        int a;\n        ll b;\n        scanf(\"%d %lld\", &a, &b);\n\n        while (b > 0) {\n            auto cur = st.lower_bound(make_pair(a, -1));\n            auto pre = prev(cur);\n\n            int pre_sum = pre->first;\n            int cnt = cur->first - pre->first;\n            int front = a - pre->first;\n            int back = cnt - front;\n            ll val = cur->second;\n            ll pre_val = pre->second;\n\n            st.erase(cur);\n            st.erase(pre);\n            \n            if (val + (b + front - 1) / front <= pre_val) {\n                ll val0 = val + (b + front - 1) / front;\n                ll val1 = val0 - 1;\n                int cnt0 = b % front == 0 ? front : b % front;\n                int cnt1 = front - cnt0;\n                if (val0 < pre_val) {\n                    st.emplace(pre_sum, pre_val);\n                    if (cnt0 > 0) {\n                        st.emplace(pre_sum + cnt0, val0);\n                    }\n                    if (cnt1 > 0) {\n                        st.emplace(pre_sum + cnt0 + cnt1, val1);\n                    }\n                } else {\n                    if (cnt0 > 0) st.emplace(pre_sum + cnt0, pre_val);\n                    if (cnt1 > 0) st.emplace(pre_sum + cnt0 + cnt1, val1);\n                }\n                if (back > 0) st.emplace(pre_sum + cnt0 + cnt1 + back, val);\n                b = 0;\n            } else {\n                b -= (pre_val - val) * front;\n                if (front > 0) st.emplace(pre_sum + front, pre_val);\n                if (back > 0) st.emplace(pre_sum + front + back, val);\n            }\n        }\n    }\n\n    auto ans = restore(st);\n    for (int i = 0; i < ans.size(); i++) {\n        printf(\"%lld\\n\", ans[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline ll in() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(int n) {\n    short res[10], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in(), q = in();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            st.erase(it2);\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                st.insert(p), h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                st.insert(p), h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                st.erase(it2);\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        st.insert(p), h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            st.insert(p), h[p] += x+1;\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                st.erase(it2);\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    st.insert(p), h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    st.insert(p), h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n        // sset(st);\n        // sar(h, n);\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a[100001];\nlong long int b[100001];\nlong long int num[100001];\nbool flag[100001];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\twhile (b[i] != 0) {\n\t\t\tif (CheckBefore(a[i])) {\n\t\t\t\tif ((a[i] - start + 1)*num[start]*(-1) <= b[i]) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[a[i] + 1] += num[start];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b[i] % (a[i] - start + 1) == 0) {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[i] % a[i] == 0) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline ll in() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz,h;\n    vector<T> node, lazy;\n    void eval(int k) {\n        if(lazy[k]){\n            node[k] += lazy[k];\n            if(k < n) {\n                lazy[k*2] += lazy[k], lazy[k*2+1] += lazy[k];\n            }\n            lazy[k] = 0;\n        }\n    }\n\npublic:\n    segtree(vector<T>& v) : sz((int)v.size()), h(0) {\n        n = 1;\n        while(n < sz) n *= 2, h++;\n        node.resize(2*n, numeric_limits<T>::min());\n        lazy.resize(2*n, 0);\n        for(int i = 0; i < sz; i++) node[i+n] = v[i];\n        for(int i = n-1; i >= 1; i--) node[i] = max(node[2*i], node[2*i+1]);\n    }\n    void add(int a, int b, T x, int k=1, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b){\n            lazy[k] += x;\n            eval(k);\n        }else{\n            add(a, b, x, 2*k, l, (l+r)/2);\n            add(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = max(node[2*k], node[2*k+1]);\n        }\n    }\n    T query(int a, int b) {\n        a += n, b += n - 1;\n        for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n        b++;\n        T res1 = numeric_limits<T>::min(), res2 = numeric_limits<T>::min();\n        while(a < b) {\n            if(a & 1) eval(a), res1 = max(res1, node[a++]);\n            if(b & 1) eval(--b), res2 = max(res2, node[b]);\n            a >>= 1, b >>= 1;\n        }\n        return max(res1, res2);\n    }\n    void print(){for(int i = 0; i < sz; i++) cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nint main(){\n    int n = in(), q = in();\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a = in();\n        ll b = in();\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        out(sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tfor(int i=0;i<Q;i++){\n\t\tMin(a[i],1000000,0);\n\t}\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%ld\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <map>\n#include <set>\n#include <array>\n#include <queue>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\ntypedef std::pair<int, int> P;\n\nLL N, Q, a[112345], b[112345];\nLL field[112345];\n\nint main()\n{\n\tin >> N >> Q;\n\trep(i, Q) { in >> a[i] >> b[i]; }\n\n\trep(i, Q)\n\t{\n\t\tLL min_pers, min_plate = INF;\n\t\tfor (int j = 0; j < a[i]; ++j)\n\t\t{\n\t\t\tif (field[j] < min_plate)\n\t\t\t{\n\t\t\t\tmin_plate = field[j];\n\t\t\t\tmin_pers = j;\n\t\t\t}\n\t\t}\n\t\t++field[min_pers];\n\t}\n\n\trep(i, N) { out << field[i] << std::endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF=1e14;\nconst int maxn=100000+5;\n\nint N,Q;\n\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define mid ((l+r)>>1)\n\n#define val first\n#define pos second\ntypedef pair<ll,int> Min;//Min(val,pos)\n\nMin mn[maxn<<2];\nll add[maxn<<2];\n\nvoid put_up(int x) {\n\tmn[x]=min(mn[lc],mn[rc]);\n}\n\nvoid put_down(int x) {\n\tif(!add[x]) return ;\n\tadd[lc]+=add[x];\n\tmn[lc].val+=add[x];\n\tadd[rc]+=add[x];\n\tmn[rc].val+=add[x];\n\tadd[x]=0;\n}\n\nvoid build(int x,int l,int r) {\n\tmn[x]=Min(0,l);\n\tif(l==r) return ;\n\tbuild(lc,l,mid);\n\tbuild(rc,mid+1,r);\n\tput_up(x);\n}\n\nvoid update(int x,int l,int r,int ql,int qr,ll v) {\n\tif(ql<=l&&r<=qr) {\n\t\tadd[x]+=v;\n\t\tmn[x].val+=v;\n\t\treturn ;\n\t}\n\tput_down(x);\n\tif(ql<=mid) update(lc,l,mid,ql,qr,v);\n\tif(qr>mid) update(rc,mid+1,r,ql,qr,v);\n\tput_up(x);\n}\n\nMin query(int x,int l,int r,int ql,int qr) {\n\tif(ql<=l&&r<=qr) return mn[x];\n\tput_down(x);\n\tMin L(INF,N+1),R(INF,N+1);\n\tif(ql<=mid) L=query(lc,l,mid,ql,qr);\n\tif(qr>mid) R=query(rc,mid+1,r,ql,qr);\n\treturn min(L,R);\n}\n\nint main() {\n\tint a;ll b;\n\tscanf(\"%d%d\",&N,&Q);\n\tbuild(1,1,N);\n\twhile(Q--) {\n\t\tscanf(\"%d%lld\",&a,&b);\n\t\twhile(b) {\n\t\t\tMin x=query(1,1,N,1,a);\n\t\t\tif(x.pos==1) {\n\t\t\t\tll c=b/a;\n\t\t\t\tupdate(1,1,N,1,a,c);\n\t\t\t\tif((b-=c*a)>0) update(1,1,N,1,b,1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tll v=query(1,1,N,x.pos-1,x.pos-1).val;\n\t\t\t\tif((v-x.val)*(a-x.pos+1)>b) {\n\t\t\t\t\tll c=b/(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,c);\n\t\t\t\t\tif((b-=c*(a-x.pos+1))>0) update(1,1,N,x.pos,x.pos+b-1,1);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tb-=(v-x.val)*(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,v-x.val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) printf(\"%lld\\n\",query(1,1,N,i,i).val);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tvector<int>cnt(n);\n\trep(i, q) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t(*--upper_bound(cnt.rbegin(), cnt.rend(), cnt[a - 1]))++;\n\t}\n\trep(i, n)printf(\"%d\\n\", cnt[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//start:\n//finish:\n#include<bits/stdc++.h>\n#define maxn 100005\nusing namespace std;\ntypedef long long ll;\nll a[maxn*4],flag[maxn*4]; \nint n,Q;\nvoid down(int x,int l,int r){\n\tint mid=(l+r)/2;\n\tif(!flag[x])return;\n\tflag[x*2]=flag[x];flag[x*2+1]=flag[x];\n\ta[x*2]=1ll*flag[x]*(mid-l+1);\n\ta[x*2+1]=1ll*flag[x]*(r-mid);\n\tflag[x]=0;\n}\nll query(int x,int l,int r,int tx,int ty){\n\tif(l>=tx && r<=ty)return a[x];\n\tdown(x,l,r);\n\tll ret=0,mid=(l+r)>>1;\n\tif(mid>=tx)ret+=query(x*2,l,mid,tx,ty);\n\tif(mid<ty)ret+=query(x*2+1,mid+1,r,tx,ty);\n\treturn ret;\n}\nvoid modify(int x,int l,int r,int tx,int ty,ll val){\n\tif(l>=tx && r<=ty){\n\t\tflag[x]=val;\n\t\ta[x]=1ll*(r-l+1)*val;return;\n\t}\n\tint mid=(l+r)/2;down(x,l,r);\n\tif(mid>=tx)modify(x*2,l,mid,tx,ty,val);\n\tif(mid<ty)modify(x*2+1,mid+1,r,tx,ty,val);\n\ta[x]=a[x*2]+a[x*2+1];\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&Q);\n\twhile(Q--){\n\t\tint x;ll y;\n\t\tscanf(\"%d%lld\",&x,&y);\n\t\tif(x==1){\n\t\t\tmodify(1,1,n,1,1,query(1,1,n,x,x)+y);\n\t\t\tcontinue;\n\t\t}\n\t\tif(query(1,1,n,x-1,x-1)-query(1,1,n,x,x)>=y){\n\t\t\tmodify(1,1,n,x,x,query(1,1,n,x,x)+y);continue;\n\t\t}\n\t\tint l=2,r=x,pos;\n\t\twhile(l<=r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(query(1,1,n,mid-1,mid-1)*(x-mid+1)-query(1,1,n,mid,x)<=y){\n\t\t\t\tpos=mid;r=mid-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl=mid+1;\n\t\t\t}\n\t\t}\n\t//\tcout<<\" \"<<pos<<\" \"<<query(1,1,n,1,1)<<endl;\n\t\tll val=query(1,1,n,pos-1,pos-1);\n\t\tll he=query(1,1,n,pos,x);\n\t\tmodify(1,1,n,pos,x,val);\n\t\ty-=val*(x-pos+1)-he;\n\t\tint num=x-pos+2;\n\t\tif(y/num){\n\t\t\tmodify(1,1,n,pos-1,x,val+y/num);\n\t\t}\n\t\tif(y%num){\n\t\t\tmodify(1,1,n,pos-1,pos-2+y%num,val+y/num+1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%lld\\n\",query(1,1,n,i,i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <array>\n#include <utility>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n\n\nnamespace XX\n{   \n    template<template<typename> class Compare, typename T>\n    inline T& UP(T& x, const T& y){if(Compare<T>()(y, x)) x = y; return x;}\n    template<typename Compare, typename T>\n    inline T& UP(T& x, const T& y, Compare comp){if(comp(y, x)) x = y; return x;}\n\n    template<typename T> inline T& GT(T& x, const T& y){return UP<std::greater>(x, y);}\n    template<typename T> inline T& LS(T& x, const T& y){return UP<std::less>(x, y);}\n\n    template<typename T>\n    struct Mapper\n    {\n        int operator[](const T& v) { int& ret = table[v]; if(!ret) rtable[ret = table.size()] = v; return ret - 1; }\n        template<typename... Args> int operator()(Args... args) { return (*this)[T(args...)]; }\n        T rev(int idx){return rtable[idx + 1];}\n        std::map<T, int> table;\n        std::map<int, T> rtable;\n    };\n\n    template<typename T, int S>\n    struct ReferenceArray\n    {\n        struct It {typename std::array<T*, S>::iterator it; T& operator*(){return **it;} void operator++(){it++;} bool operator!=(const It& other){return it != other.it;} };\n        int size()const{return _ptr.size();}\n        It begin()const{return {_ptr.begin()};}\n        It end()const{return {_ptr.end()};}\n        T& operator[](int idx)const{return *_ptr[idx];}\n        mutable std::array<T*, S> _ptr;\n    };\n    template<typename T, typename... Args> \n    ReferenceArray<T, sizeof...(Args) + 1> MAKEV(T& arg1, Args&... args) {return {&arg1, &args...};}\n\n    struct Range\n    {   \n        struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n        Range(int ee):b(0),e(ee){}\n        Range(int bb, int ee):b(bb), e(ee){}\n        It begin(){return {b, (b < e? 1: -1)};}\n        It end(){return {e, 0};}\n        int b, e;\n    };\n\n}\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\ntemplate<typename T> T& UMAX(T& x, T y){return XX::UP<std::greater>(x, y);}\ntemplate<typename T> T& UMIN(T& x, T y){return XX::UP<std::less>(x, y);}\nusing XX::UP; //(x,y) comp\nusing RG = XX::Range;\nusing XX::MAKEV;\nusing XX::Mapper;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n    int N, Q;\n    RD(N, Q);\n\n    map<int, pair<ll, ll>> q;\n    q[-1] = {0, 1000000000000000000ll};\n    q[0] = {N, 0};\n    while(Q--)\n    {\n        ll a, b;\n        RD(a, b);\n        a--;\n\n        while(b)\n        {\n            auto it = prev(q.upper_bound(a));\n            auto l = it->second.first;\n\n            if(it->first + l - 1 > a)\n            {\n                q[a +  1] = {it->first + l - 1 - a, it->second.second};\n                l = it->second.first = a - it->first + 1;\n            }\n\n\n            auto it2 = prev(it);\n\n            auto dif = it2->second.second - it->second.second;\n\n            if((b + l - 1) / l >= dif)\n            {\n                auto n = min(b - l * (dif - 1), l);\n                it2->second.first += n;\n                if(n < l)\n                    q[it->first + n] = {l - n, it->second.second};\n\n                q.erase(it);\n                b -= n * dif;\n            }\n            else\n            {\n                it->second.second += b / l;\n                b %= l;\n\n                if(b)\n                {\n                    q[it->first + b] = {l - b, it->second.second};\n                    it->second.first = b;\n                    it->second.second++;\n                }\n                b = 0;\n            }\n        }\n    }\n\n    for(auto it = q.find(0); it != q.end(); it++)\n        for(int j = it->second.first; j > 0; j--)\n            WTL(it->second.second);\n\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <limits>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 4; }\ntemplate <typename Base>\nclass LazySeg\n{\n    static std::size_t SZ(const std::size_t n)\n    {\n        std::size_t ans = 1;\n        for (; ans < n; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using BaseAlgebra = Base;\n    using ValMonoid = typename BaseAlgebra::ValMonoid;\n    using OpMonoid = typename BaseAlgebra::OpMonoid;\n    using T = typename BaseAlgebra::VT;\n    using F = typename BaseAlgebra::OT;\n    LazySeg(const std::size_t n) : size(n), half(SZ(n)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id()) {}\n    template <typename InIt>\n    LazySeg(const InIt first, const InIt last) : size(std::distance(first, last)), half(SZ(size)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id())\n    {\n        copy(first, last, value.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    T get(const std::size_t a) const { return accumulate(a, a + 1); }\n    void set(std::size_t a, const T& val)\n    {\n        modify(a, a + 1, OpMonoid::id()), value[a += half] = val;\n        while (a >>= 1) { up(a); }\n    }\n    T accumulate(const std::size_t L, const std::size_t R) const\n    {\n        auto arec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> T {\n            if (L <= left and right <= R) {\n                return value[index];\n            } else if (right <= L or R <= left) {\n                return ValMonoid::id();\n            } else {\n                return act(action[index], acc(self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right)));\n            }\n        };\n        return arec(arec, 1, 0, half);\n    }\n    void modify(const std::size_t L, const std::size_t R, const F& f)\n    {\n        auto mrec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> void {\n            if (L <= left and right <= R) {\n                this->update(index, f);\n            } else if (right <= L or R <= left) {\n            } else {\n                this->update(index << 1, action[index]), this->update(index << 1 | 1, action[index]);\n                self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right);\n                this->up(index), action[index] = OpMonoid::id();\n            }\n        };\n        mrec(mrec, 1, 0, half);\n    }\n    std::vector<T> data() const\n    {\n        std::vector<T> ans(size);\n        for (std::size_t i = 0; i < size; i++) { ans[i] = get(i); }\n        return ans;\n    }\n\nprivate:\n    void up(const std::size_t i) { value[i] = acc(value[i << 1], value[i << 1 | 1]); }\n    void update(const std::size_t i, const F& f) { value[i] = act(f, value[i]), action[i] = compose(f, action[i]); }\n    const std::size_t size, half;\n    std::vector<T> value;\n    std::vector<F> action;\n    const ValMonoid acc{};\n    const OpMonoid compose{};\n    const BaseAlgebra act{};\n};\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const LazySeg<T>& seg)\n{\n    os << \"[\";\n    for (const auto& e : seg.data()) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename VX = ll, typename OX = ll>\nstruct Max_Set\n{\n    using VT = VX;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return std::max(a, b); }\n        static constexpr VT id() { return -INF<VT>(); }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<VT>() ? f : x; }\n};\n\ntemplate <typename VX = ll, typename OX = ll>\nstruct Max_Plus\n{\n    using VT = VX;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return std::max(a, b); }\n        static constexpr VT id() { return -INF<VT>(); }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& a, const OT& b) const { return a + b; }\n        static constexpr OT id() { return 0; }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f + x; }\n};\ntemplate <typename VX = ll, typename OX = ll>\nstruct Sum_Plus\n{\n    using VT = std::pair<VX, VX>;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return {a.first + b.first, a.second + b.second}; }\n        static constexpr VT id() { return {0, 0}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 + f2; }\n        static constexpr OT id() { return 0; }\n    };\n    VT operator()(const OT& f, const VT& x) const { return {x.first + x.second * f, x.second}; }\n};\ntemplate <typename VX = ll, typename OX = ll>\nstruct Sum_Set\n{\n    using VT = std::pair<VX, VX>;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return {a.first + b.first, a.second + b.second}; }\n        static constexpr VT id() { return {0, 0}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<VX>() ? VT{x.second * f, x.second} : x; }\n};\nint main()\n{\n    int N, Q;\n    std::cin >> N >> Q;\n    LazySeg<Max_Set<ll>> seg(N);\n    LazySeg<Sum_Set<ll>> seg2(N);\n    for (int i = 0; i < N; i++) { seg.set(i, 0); }\n    for (int i = 0; i < N; i++) { seg2.set(i, {0, 1}); }\n    for (int q = 0; q < Q; q++) {\n        int A;\n        ll B;\n        std::cin >> A >> B;\n        int inf = -1, sup = A;\n        while (sup - inf > 1) {\n            const int mid = (inf + sup) / 2;\n            if (mid == 0) {\n                inf = mid;\n            } else {\n                const ll sub = seg2.accumulate(mid, A).first;\n                const ll H = seg.get(mid - 1);\n                const ll cap = H * (A - mid) - sub;\n                (cap < B ? sup : inf) = mid;\n            }\n        }\n        const ll rect = seg2.accumulate(inf, A).first + B;\n        const ll H = rect / (A - inf);\n        seg.modify(inf, A, H), seg2.modify(inf, A, H);\n        const ll res = rect % (A - inf);\n        if (res > 0) { seg.modify(inf, inf + res, H + 1), seg2.modify(inf, inf + res, H + 1); }\n    }\n    for (int i = 0; i < N; i++) { std::cout << seg.get(i) << std::endl; }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=1000*1007;\nconst ll inf=1e18;\n\nint n, q;\n\nset < pair <int,ll> > setel;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tsetel.insert({0, inf});\n\tsetel.insert({n+1, 0});\n\twhile(q--)\n\t{\n\t\tint a;\n\t\tll b;\n\t\tscanf(\"%d%lld\", &a, &b);\n\t\tauto it=setel.lower_bound({a, -1});\n\t\tsetel.insert({a, (*it).second});\n\t\twhile(b)\n\t\t{\n\t\t\tit=setel.lower_bound({a, -1});\n\t\t\tauto jt=it;\n\t\t\tjt--;\n\t\t\tif ((*it).second==(*jt).second)\n\t\t\t{\n\t\t\t\tsetel.erase(jt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint dlu=(*it).first-(*jt).first;\n\t\t\tif (b<dlu)\n\t\t\t{\n\t\t\t\tsetel.insert({(*jt).first+b, (*it).second+1});\n\t\t\t\tb=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll ile=min(b/dlu, (*jt).second-(*it).second);\n\t\t\tb-=dlu*ile;\n\t\t\tauto pam=(*it);\n\t\t\tsetel.erase(pam);\n\t\t\tpam.second+=ile;\n\t\t\tsetel.insert(pam);\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(\"%lld\\n\", (*setel.lower_bound({i, -1})).second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME],val[1<<ME];\n\tV total(int e) {V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tV add(int e,V v) { val[e++]+=v; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n\tV set(int e,V v) { add(e,v-val[e]);}\n\tint lower_bound(V val) {\n\t\tV tv=0; int i,ent=0;\n\t\tfor(i=ME-1;i>=0;i--) if(tv+bit[ent+(1<<i)-1]<val) tv+=bit[ent+(1<<i)-1],ent+=(1<<i);\n\t\treturn ent;\n\t}\n};\n\nint N,Q;\nll A,B;\nBIT<ll,20> bit;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tbit.add(N,2LL*10000000000000LL);\n\tFOR(i,Q) {\n\t\tcin>>A>>B;\n\t\tx=N-A;\n\t\twhile(B) {\n\t\t\tll xv=bit.total(x);\n\t\t\ty = bit.lower_bound(xv+1);\n\t\t\tll yv=bit.total(y);\n\t\t\t\n\t\t\t\n\t\t\tif(B>=(yv-xv)*(y-x)) {\n\t\t\t\tB -= (yv-xv)*(y-x);\n\t\t\t\tbit.add(x,yv-xv);\n\t\t\t\tbit.add(y,-(yv-xv));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbit.add(x,B/(y-x));\n\t\t\t\tbit.add(y,-B/(y-x));\n\t\t\t\tB %= (y-x);\n\t\t\t\tbit.add(y-B,1);\n\t\t\t\tbit.add(y,-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tFOR(i,N) cout<<bit.total(N-1-i)<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF=1e14;\nconst int maxn=100000+5;\n\nint N,Q;\n\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define mid ((l+r)>>1)\n\n#define val first\n#define pos second\ntypedef pair<ll,int> Min;//Min(val,pos)\n\nMin mn[maxn<<2];\nll add[maxn<<2];\n\nvoid put_up(int x) {\n\tmn[x]=min(mn[lc],mn[rc]);\n}\n\nvoid put_down(int x) {\n\tif(!add[x]) return ;\n\tadd[lc]+=add[x];\n\tmn[lc].val+=add[x];\n\tadd[rc]+=add[x];\n\tmn[rc].val+=add[x];\n\tadd[x]=0;\n}\n\nvoid build(int x,int l,int r) {\n\tmn[x]=Min(0,l);\n\tif(l==r) return ;\n\tbuild(lc,l,mid);\n\tbuild(rc,mid+1,r);\n\tput_up(x);\n}\n\nvoid update(int x,int l,int r,int ql,int qr,ll v) {\n\tif(ql<=l&&r<=qr) {\n\t\tadd[x]+=v;\n\t\tmn[x].val+=v;\n\t\treturn ;\n\t}\n\tput_down(x);\n\tif(ql<=mid) update(lc,l,mid,ql,qr,v);\n\tif(qr>mid) update(rc,mid+1,r,ql,qr,v);\n\tput_up(x);\n}\n\nMin query(int x,int l,int r,int ql,int qr) {\n\tif(ql<=l&&r<=qr) return mn[x];\n\tput_down(x);\n\tMin L(INF,N+1),R(INF,N+1);\n\tif(ql<=mid) L=query(lc,l,mid,ql,qr);\n\tif(qr>mid) R=query(rc,mid+1,r,ql,qr);\n\treturn min(L,R);\n}\n\nint main() {\n\tint a;ll b;\n\tscanf(\"%d%d\",&N,&Q);\n\tbuild(1,1,N);\n\twhile(Q--) {\n\t\tscanf(\"%d%lld\",&a,&b);\n\t\twhile(b) {\n\t\t\tMin x=query(1,1,N,1,a);\n\t\t\tif(x.pos==1) {\n\t\t\t\tll c=b/a;\n\t\t\t\tupdate(1,1,N,1,a,c);\n\t\t\t\tif((b-=c*a)>0)\n\t\t\t\t\tupdate(1,1,N,1,b,1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tll v=query(1,1,N,x.pos-1,x.pos-1).val;\n\t\t\t\tif((v-x.val)*(a-x.pos+1)>b) {\n\t\t\t\t\tint c=b/(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,c);\n\t\t\t\t\tif((b-=c*(a-x.pos+1))>0) update(1,1,N,x.pos,x.pos+b-1,1);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tb-=(v-x.val)*(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,v-x.val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) printf(\"%lld\\n\",query(1,1,N,i,i).val);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k, int l, int r) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(r - l > 1) {\n                    lazy_add[2*k+1] = lazy_add[2*k+2] = 0;\n                    lazy_update[2*k+1] = lazy_update[2*k+2] = lazy_update[k];\n                    lazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n                }\n                lazy_add[k] = 0;\n                lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(r - l > 1){\n                    lazy_add[2*k+1] += lazy_add[k]; lazy_add[2*k+2] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T> v) : sz((int)v.size()){\n            n = 1;\n            while(n < sz) n *= 2;\n            node.resize(2*n-1,numeric_limits<T>::min());\n            lazy_update.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n            lazy_add.resize(2*n-1, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n-1] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) node[i] = max(node[2*i+1],node[2*i+2]);\n        }\n        void update(int a, int b, T x, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true;\n                eval(k, l, r);\n            }else{\n                update(a, b, x, 2*k+1, l, (l+r)/2); update(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        void add(int a, int b, T x, int k=0, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k, l, r);\n            }else{\n                add(a, b, x, 2*k+1, l, (l+r)/2); add(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        T query(int a, int b, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return numeric_limits<T>::min();\n            if(a <= l && r <= b) return node[k];\n            return max(query(a, b, 2*k+1, l, (l+r)/2), query(a, b, 2*k+2, (l+r)/2, r));\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a;\n        ll b;\n        scanf(\"%d %lld\",&a,&b);\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        printf(\"%lld\\n\",sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a[100001];\nlong long int b[100001];\nlong long int num[100001];\nbool flag[100001];\nint section[101] ;\nint sum;\nint start;\n\nbool CheckBefore(int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (int j = i * 1000 + 999; j >= 0; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\twhile (b[i] != 0) {\n\t\t//\tcout << b[i] << \"\\n\";\n\t\t\tif (CheckBefore(a[i])) {\n\t\t\t\tif ((a[i] - start + 1)*num[start]*(-1) <= b[i]) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[a[i] + 1] += num[start];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b[i] % (a[i] - start + 1) == 0) {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[i] % a[i] == 0) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i] = 0;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\n#define LINF 1000000000000000000\n\nstruct SegTree {\n\tstruct Node {\n\t\tint64_t min = LINF;\n\t\tint64_t min2 = LINF;\n\t\tint mincnt = 0;\n\t\tint64_t added = 0;\n\t\tint64_t chmaxed = -LINF;\n\t\tNode operator * (const Node &r) const {\n\t\t\tconst Node &l = *this;\n\t\t\tNode res;\n\t\t\tif (l.min < r.min) res.min = l.min, res.mincnt = l.mincnt, res.min2 = std::min(l.min2, r.min);\n\t\t\telse if (r.min < l.min) res.min = r.min, res.mincnt = r.mincnt, res.min2 = std::min(r.min2, l.min);\n\t\t\telse res.min = l.min, res.mincnt = l.mincnt + r.mincnt, res.min2 = std::min(l.min2, r.min2);\n\t\t\treturn res;\n\t\t}\n\t};\n\tint n, n_;\n\tstd::vector<Node> nodes;\n\tSegTree (int n_) : n_(n_) {\n\t\tfor (n = 1; n < n_; n <<= 1);\n\t\tnodes.resize(n << 1);\n\t\tfor (int i = 0; i < n_; i++) nodes[i + n] = {0, LINF, 1, 0, -LINF};\n\t\tfor (int i = n; --i; ) fetch(i);\n\t}\n\tvoid fetch(int i) {\n\t\tnodes[i] = nodes[i << 1] * nodes[i << 1 | 1];\n\t}\n\tvoid flush(int i) {\n\t\tif (nodes[i].added) {\n\t\t\tnodes[i].min += nodes[i].added;\n\t\t\tnodes[i].min2 += nodes[i].added;\n\t\t\tif (i < n) {\n\t\t\t\tnodes[i << 1].added += nodes[i].added;\n\t\t\t\tif (nodes[i << 1].chmaxed != -LINF) nodes[i << 1].chmaxed += nodes[i].added;\n\t\t\t\tnodes[i << 1 | 1].added += nodes[i].added;\n\t\t\t\tif (nodes[i << 1 | 1].chmaxed != -LINF) nodes[i << 1 | 1].chmaxed += nodes[i].added;\n\t\t\t}\n\t\t\tnodes[i].added = 0;\n\t\t}\n\t\tif (nodes[i].chmaxed != -LINF) {\n\t\t\tif (i < n) {\n\t\t\t\tnodes[i << 1].chmaxed = std::max(nodes[i << 1].chmaxed, nodes[i].chmaxed);\n\t\t\t\tnodes[i << 1 | 1].chmaxed = std::max(nodes[i << 1 | 1].chmaxed, nodes[i].chmaxed);\n\t\t\t}\n\t\t\tif (nodes[i].chmaxed >= nodes[i].min2) {\n\t\t\t\tflush(i << 1);\n\t\t\t\tflush(i << 1 | 1);\n\t\t\t\tfetch(i);\n\t\t\t} else if (nodes[i].chmaxed > nodes[i].min) nodes[i].min = nodes[i].chmaxed;\n\t\t\tnodes[i].chmaxed = -LINF;\n\t\t}\n\t}\n\ttemplate<class T> void dive(int l, int r, int node, int size, const T &func) {\n\t\tflush(node);\n\t\tif (r <= 0 || l >= size) return;\n\t\tif (l <= 0 && r >= size) func(node);\n\t\telse {\n\t\t\tint half = size >> 1;\n\t\t\tdive(l, r, node << 1, half, func);\n\t\t\tdive(l - half, r - half, node << 1 | 1, half, func);\n\t\t\tfetch(node);\n\t\t}\n\t}\n\tvoid mininfo(int l, int r, int64_t &min, int &mincnt, int64_t &min2) {\n\t\tNode tmp;\n\t\tdive(l, r, 1, n, [&] (int node) { tmp = tmp * nodes[node]; });\n\t\tmin = tmp.min;\n\t\tmincnt = tmp.mincnt;\n\t\tmin2 = tmp.min2;\n\t}\n\tvoid chmax(int l, int r, int64_t val) {\n\t\tdive(l, r, 1, n, [&] (int node) { nodes[node].chmaxed = val; flush(node); });\n\t}\n\tint kth_min(int l, int r, int k, int64_t min) {\n\t\tint cur = 1;\n\t\tint index = 0;\n\t\tint size = n;\n\t\twhile (cur < n) {\n\t\t\tflush(cur);\n\t\t\tflush(cur << 1);\n\t\t\tint leftcnt = nodes[cur << 1].min < min ? 1000000000 :\n\t\t\t\t\t\t  nodes[cur << 1].min == min ? nodes[cur << 1].mincnt : 0;\n\t\t\tif (leftcnt > k) cur <<= 1;\n\t\t\telse k -= leftcnt, cur = cur << 1 | 1, index += size >> 1;\n\t\t\tsize >>= 1;\n\t\t}\n\t\tassert(index < r);\n\t\treturn index;\n\t}\n\tstd::vector<int64_t> dump() {\n\t\tfor (int i = 1; i < 2 * n; i++) flush(i);\n\t\tstd::vector<int64_t> res(n_);\n\t\tfor (int i = n; i < n + n_; i++) res[i - n] = nodes[i].min;\n\t\treturn res;\n\t}\n};\n\n// dummy\nstruct SegTreeDummy {\n\tstd::vector<int64_t> data;\n\tSegTreeDummy (int n) {\n\t\tdata.resize(n);\n\t}\n\tvoid mininfo(int l, int r, int64_t &min, int &mincnt, int64_t &min2) {\n\t\tmin = LINF;\n\t\tmincnt = 0;\n\t\tmin2 = LINF;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tif (min > data[i]) min2 = min, min = data[i], mincnt = 1;\n\t\t\telse if (min == data[i]) mincnt++;\n\t\t\telse min2 = std::min(min2, data[i]);\n\t\t}\n\t}\n\tvoid chmax(int l, int r, int64_t val) {\n\t\tfor (int i = l; i < r; i++) data[i] = std::max(data[i], val);\n\t}\n\tint kth_min(int l, int r, int k, int64_t) {\n\t\tstd::vector<int> mins;\n\t\tint64_t min = LINF;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tif (min > data[i]) min = data[i], mins = { i };\n\t\t\telse if (min == data[i]) mins.push_back(i);\n\t\t}\n\t\treturn mins[k];\n\t}\n\tstd::vector<int64_t> dump() {\n\t\treturn data;\n\t}\n};\n\nint main() {\n\tint n = ri();\n\tint q = ri();\n\tSegTree tree(n);\n\tfor (int i = 0; i < q; i++) {\n\t\tint r = ri();\n\t\tint64_t val;\n\t\tscanf(\"%\" SCNd64, &val);\n\t\twhile (val) {\n\t\t\tint64_t min, min2;\n\t\t\tint mincnt;\n\t\t\ttree.mininfo(0, r, min, mincnt, min2);\n\t\t\t// std::cerr << \"min \" << min << \" cnt:\" << mincnt << \" min2:\" << min2 << std::endl;\n\t\t\tint64_t consume = std::min(min2 - min, val / mincnt);\n\t\t\tif (!consume) {\n\t\t\t\tint index = tree.kth_min(0, r, val, min);\n\t\t\t\t// std::cerr << \"final \" << index << \"  \" << min + 1 << std::endl;\n\t\t\t\ttree.chmax(0, index, min + 1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// std::cerr << \"  normal consume \" << consume << std::endl;\n\t\t\t\tval -= consume * mincnt;\n\t\t\t\ttree.chmax(0, r, min + consume);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (auto i : tree.dump()) fprintf(stderr, \"%\" PRId64 \" \", i);\n\t\tfprintf(stderr, \"\\n\");*/\n\t}\n\tfor (auto i : tree.dump()) printf(\"%\" PRId64 \"\\n\", i);\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//It is made by ljh2000\n//有志者，事竟成，破釜沉舟，百二秦关终属楚；苦心人，天不负，卧薪尝胆，三千越甲可吞吴。\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#define lc root<<1\n#define rc root<<1|1\n#define reg(i,x) for(int i=first[x];i;i=nxt[i])\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200011;\nint n,Q;\nstruct node{ LL set,add,sum; }a[MAXN*3];\ninline void update(int root){ a[root].sum=a[lc].sum+a[rc].sum; }\ninline int getint(){\n    int w=0,q=0; char c=getchar(); while((c<'0'||c>'9') && c!='-') c=getchar();\n    if(c=='-') q=1,c=getchar(); while (c>='0'&&c<='9') w=w*10+c-'0',c=getchar(); return q?-w:w;\n}\n\ninline void pushdown(int root,int l,int r){\n\tif(a[root].set==0 && a[root].add==0) return  ; if(l==r) return ;\n\tint mid=(l+r)>>1;\n\tif(a[root].set>0) {\n\t\ta[lc].set=a[rc].set=a[root].set;\n\t\ta[lc].sum=1LL*a[root].set*(mid-l+1); a[rc].sum=1LL*a[root].set*(r-mid);\n\t\ta[lc].add=a[rc].add=a[root].set=0;\n\t}\n\n\tif(a[root].add>0) {\n\t\ta[lc].add+=a[root].add; a[rc].add+=a[root].add;\n\t\ta[lc].sum+=1LL*a[root].add*(mid-l+1); a[rc].sum+=1LL*a[root].add*(r-mid);\n\t\ta[root].add=0;\n\t}\n}\n\ninline void modify(int root,int l,int r,int ql,int qr,LL val){\n\tpushdown(root,l,r);\n\tif(ql<=l && r<=qr) {\n\t\ta[root].set=val; a[root].add=0;\n\t\ta[root].sum=1LL*(r-l+1)*val;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) modify(lc,l,mid,ql,qr,val);\n\tif(qr>mid) modify(rc,mid+1,r,ql,qr,val);\n\tupdate(root);\n}\n\ninline void add(int root,int l,int r,int ql,int qr,LL val){\n\tpushdown(root,l,r);\n\tif(ql<=l && r<=qr) {\n\t\ta[root].sum+=1LL*val*(r-l+1);\n\t\ta[root].add+=val;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) add(lc,l,mid,ql,qr,val);\n\tif(qr>mid) add(rc,mid+1,r,ql,qr,val);\n\tupdate(root);\n}\n\ninline LL query(int root,int l,int r,int ql,int qr){\n\tif(ql<=l && r<=qr) return a[root].sum;\n\tpushdown(root,l,r); int mid=(l+r)>>1;\n\tif(qr<=mid) return query(lc,l,mid,ql,qr);\n\telse if(ql>mid) return query(rc,mid+1,r,ql,qr);\n\treturn query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr);\n}\n\ninline void dfs(int root,int l,int r){\n\tif(l==r) { printf(\"%lld\\n\",a[root].sum); return ; }\n\tpushdown(root,l,r); int mid=(l+r)>>1;\n\tdfs(lc,l,mid); dfs(rc,mid+1,r);\n}\n\ninline void work(){\n\tn=getint(); Q=getint(); int x; LL y; int l,r,mid,pos;\n\twhile(Q--) {\n\t\tx=getint(); scanf(\"%lld\",&y);\n\t\tl=1; r=x; pos=0;\n\t\twhile(l<=r) {\n\t\t\tmid=(l+r)>>1;\n\t\t\tif(1LL*query(1,1,n,mid,mid)*(x-mid+1)-query(1,1,n,mid,x) <= y) r=mid-1;\n\t\t\telse l=mid+1,pos=mid;\n\t\t}\n\t\ty-=1LL*query(1,1,n,pos+1,pos+1)*(x-pos)-query(1,1,n,pos+1,x);\n\t\tmodify(1,1,n,pos+1,x, query(1,1,n,pos+1,pos+1) );\n\t\tif(y/(x-pos)) add(1,1,n,pos+1,x,y/(x-pos));\n\t\tif(y%(x-pos)) add(1,1,n,pos+1,pos+y%(x-pos),1);\n\t}\n\tdfs(1,1,n);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n    work();\n    return 0;\n}\n//有志者，事竟成，破釜沉舟，百二秦关终属楚；苦心人，天不负，卧薪尝胆，三千越甲可吞吴。\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint N,dat[300];\nvoid init(int n_){\n\tN=1;\n\twhile(N<n_)N*=2;\n\tfor(int i=0;i<2*N-1;i++)dat[i]=INT_MAX;\n}\nvoid update(int k,int a){\n\tk+=N-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r){\n\tif(r<=a||b<=l)return INT_MAX;\n\tif(a<=l&&r<=b)return dat[k];\n\tint v1=query(a,b,k*2+1,l,(l+r)/2);\n\tint v2=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(v1,v2);\n}\n\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tvector<int>cnt(n);\n\tinit(n);\n\trep(i,n)update(i,0);\n\trep(i,q){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tif(b>1)abort();\n\t\tint d=query(0,a,0,0,N);\n\t\tint k=upper_bound(cnt.rbegin(),cnt.rend(),d)-cnt.rbegin();\n\t\tk=n-k;\n\t\tupdate(k,d+1);\n\t\tcnt[k]=d+1;\n\t}\n\trep(i,n)printf(\"%d\\n\",cnt[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n >> q;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, TEN(15)));\n    s.insert(P(n-1, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;\n            if (a == pr.first) s.erase(pr);\n            if (d*(pl.second-pr.second) <= b) {\n                s.erase(pl); \n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {\n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                if (pr.second + (b+d-1)/d == pl.second) {\n                    s.erase(pl);\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz,h; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(k < n) {\n                    lazy_add[2*k] = lazy_add[2*k+1] = 0;\n                    lazy_update[2*k] = lazy_update[2*k+1] = lazy_update[k];\n                    lazyFlag[2*k] = lazyFlag[2*k+1] = true;\n                }\n                lazy_add[k] = 0, lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(k < n){\n                    lazy_add[2*k] += lazy_add[k]; lazy_add[2*k+1] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T> v) : n(1), sz((int)v.size()), h(0){\n            while(n < sz) n *= 2, h++;\n            node.resize(2*n,numeric_limits<T>::min());\n            lazy_update.resize(2*n, 0); lazyFlag.resize(2*n,false);\n            lazy_add.resize(2*n, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n] = v[i];\n            }\n            for(int i=n-1; i>=1; i--) node[i] = max(node[2*i],node[2*i+1]);\n        }\n        void update(int a, int b, T x, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true; eval(k);\n            }else{\n                update(a, b, x, 2*k, l, (l+r)/2); update(a, b, x, 2*k+1, (l+r)/2, r);\n                node[k] = max(node[2*k],node[2*k+1]);\n            }\n        }\n        void add(int a, int b, T x, int k=0, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k);\n            }else{\n                add(a, b, x, 2*k, l, (l+r)/2); add(a, b, x, 2*k+1, (l+r)/2, r);\n                node[k] = max(node[2*k],node[2*k+1]);\n            }\n        }\n        T query(int a, int b) {\n            a += n, b += n - 1;\n            for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n            b++;\n            T res1 = numeric_limits<T>::min(), res2 = numeric_limits<T>::min();\n            while(a < b) {\n                if(a & 1) eval(a), res1 = max(res1, node[a++]);\n                if(b & 1) eval(--b), res2 = max(res2, node[b]);\n                a >>= 1, b >>= 1;\n            }\n            return max(res1, res2);\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a;\n        ll b;\n        scanf(\"%d %lld\",&a,&b);\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        printf(\"%lld\\n\",sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <iostream>\nusing namespace std;\nset<pair<int,long long > >st;\nint n;\nvoid output(){\n\t    auto it=st.begin();\n\t\tint i=1;\n\t\twhile(i<=n){\n\t\t\tif(i<=it->first){\n\t\t\t\tcout<<it->second<<endl;\n\t\t\t\t++i;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n}\nint main(){\n\tint Q;\n\tscanf(\"%d%d\",&n,&Q);\n\tst.insert(make_pair(n,0));\n\twhile(Q--){\n\t\tint a;\n\t\tlong long b;\n\t\tcin>>a>>b;\n\t\twhile(b){\n\t\t\tauto it=st.lower_bound(make_pair(a,-1));\n\t\t\tif(it==st.begin()){\n\t\t\t\tint pos=it->first;\n\t\t\t\tlong long val=it->second+b/a;\n\t\t\t\tif(pos==a){\n\t\t\t\t\tst.erase(it);\n\t\t\t\t\tst.insert(make_pair(a,val));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tst.insert(make_pair(a,val));\n\t\t\t\t}\n\t\t\t\tb%=a;\n\t\t\t\tif(b){\n\t\t\t\t\tst.insert(make_pair(b,val+1));\n\t\t\t\t\tb=0;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tauto it0=it;\n\t\t\t\t--it0;\n\t\t\t\t//cout<<it->first<<\" \"<<it->second<<endl;\n\t\t\t\t//cout<<it0->first<<\" \"<<it0->second<<endl;\n\t\t\t\tint len=a-it0->first;\n\t\t\t\tlong long tot=(it0->second-it->second)*len;\n\t\t\t\tif(b>=tot){\n\t\t\t\t\tb-=tot;\n\t\t\t\t\tlong long cur=it->second+tot/len;\n\t\t\t\t\tif(a==it->first){\n\t\t\t\t\t\tst.erase(it);\n\t\t\t\t\t\tst.insert(make_pair(a,cur));\n\t\t\t\t\t\tst.erase(it0);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tst.erase(it0);\n\t\t\t\t\t\tst.insert(make_pair(a,cur));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlong long add=b/len+it->second;\n\t\t\t\t\tif(a==it->first){\n\t\t\t\t\t\tst.erase(it);\n\t\t\t\t\t\tst.insert(make_pair(a,add));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tst.insert(make_pair(a,add));\n\t\t\t\t\t}\n\t\t\t\t\tb%=len;\n\t\t\t\t\tif(b){\n\t\t\t\t\t\tst.insert(make_pair(it0->first+b,add+1));\n\t\t\t\t\t}\n\t\t\t\t\tb=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\toutput();\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100001];\nbool flag[100001];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (long long int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start]* (a - start + 1)*(-1) <= b) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b % (a - start + 1) == 0) {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1))!=0) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1)!=0)) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b % a == 0) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false&&b/a!=0) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  Int n;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(Int n_,F f,G g,H h,T ti,E ei,\n\t      P p=[](E a,size_t b){b++;return a;}):\n    f(f),g(g),h(h),ti(ti),ei(ei),p(p){\n    init(n_);\n  }\n  void init(Int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n    laz.assign(2*n-1,ei);\n  }\n  void build(Int n_, vector<T> v){\n    for(Int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(Int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(Int len,Int k){\n    if(laz[k]==ei) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=ei;\n  }\n  T update(Int a,Int b,E x,Int k,Int l,Int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(Int a,Int b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(Int a,Int b,Int k,Int l,Int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return ti;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(Int a,Int b){\n    return query(a,b,0,0,n);\n  }\n  void update(Int k,T x){\n    query(k,k+1);//evaluate\n    k+=n-1;\n    dat[k]=x;\n    while(k){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,q;\n  cin>>n>>q;\n\n  auto f=[](Int a,Int b){return a+b;};\n  auto g=[](Int a,Int b){a++;return b;};\n  auto p=[](Int a,size_t b){return a*b;};\n\n  SegmentTree<Int, Int> seg(n,f,g,g,0,0,p);\n\n  for(Int i=0;i<q;i++){\n    Int a,b;\n    cin>>a>>b;\n\n    Int l=-1,r=a;\n    while(l+1<r){\n      Int m=(l+r)>>1;\n      Int k=seg.query(m,m+1);\n      if(k*(a-m)<=seg.query(m,a)+b) r=m;\n      else l=m;\n    }\n    \n    Int k=seg.query(r,r+1);\n    b-=k*(a-r)-seg.query(r,a);\n    seg.update(r,a,k);\n    k+=b/(a-r);b%=(a-r);\n    seg.update(r,a,k);\n    seg.update(r,r+b,k+1);\n\n    continue;\n    cout<<r<<\":\"<<a<<\":\"<<b<<endl;\n    for(Int j=0;j<n;j++)\n      cout<<seg.query(j,j+1)<<\" \";\n    cout<<endl;\n  }\n  \n  for(Int i=0;i<n;i++)\n    cout<<seg.query(i,i+1)<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100001];\n\nLL count(int m, int a) {\n\tLL sum = 0;\n\tREP(i, a-m, 0) {\n\t\tsum += (res[a-i-1] - res[a-i]) * (i + 1);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\tmemset(res, 0, sizeof(res));\n\tres[0] = 20000000000000;\n\tcin >> N >> Q;\n//\tN = 10000, Q = 100000;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n//\t\tA = N, B = 1;\n\t\tif (B == 1) {\n\t\t\tREP(i, A+1, 0) {\n\t\t\t\tif (res[A-i] != res[A-i-1]) {\n\t\t\t\t\tres[A-i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint l = 0, r = A;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (r + l) / 2;\n//\t\t\tcout << m << \":\" << A << \":\" << count(m, A) << endl;\n\t\t\tif (count(m, A) > B) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tLL p = res[r];\n\t\tREP(i, A + 1, r + 1) {\n\t\t\tif (res[i] != p) {\n\t\t\t\tREP(j, A + 1, i) {\n\t\t\t\t\tB -= (p - res[j]);\n\t\t\t\t\tres[j] = p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp = res[i];\n\t\t\t}\n\t\t}\n//\t\tcout << r << endl;\n\t\tREP(i, A + 1, r) {\n\t\t\tres[i] += B/(A - r + 1);\n\t\t}\n\t\tREP(i, r + B%(A - r + 1), r) {\n\t\t\tres[i]++;\n\t\t}\n//\t\tREP(i, N + 1, 1) cout << res[i];\n//\t\tcout << endl;\n\t}\n\tREP(i, N + 1, 1) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100002];\nbool flag[100002];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nvoid CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (long long int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> Q;\n\tflag[1] = true;\n\tsection[0]++;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tCheckBefore(a);\n\t\t\tif (num[start] * (a - start + 1)*(-1) < b) {\n\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t}\n\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\tnum[start] = 0;\n\t\t\t\tflag[start] = false;\n\t\t\t\tsection[start / 1000]--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\tflag[start] = false;\n\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t}\n\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\tif (flag[a + 1] == false && (b / (a - start + 1) != 0)) {\n\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline int in() {\n    int n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline ll in_() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[19], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in_(), q = in_();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in_();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                    st.erase(it2);\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            h[p] += x+1;\n                        }else{\n                            st.erase(it2);\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100002];\nbool flag[100002];\nlong long int section[101];\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num / 1000] > 0) {\n\t\tfor (long long int i = num; i >= (num / 1000) * 1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i * 1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start] * (a - start + 1)*(-1) < b) {\n\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\tflag[start] = false;\n\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\tif (start + b % (a - start + i) != 1) {\n\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\tif (flag[a + 1] == false && (b / (a - start + 1) != 0)) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\tnum[1 + b % a]--;\n\t\t\t\tif (1 + b%a != 1) {\n\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t}\n\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\tif (flag[a + 1] == false && (b / a) != 0) {\n\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n, q, ans;\nLL num[100001];\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tif(n > 10000) { return 1; }\n\t\n\tnum[n] = 20000000000001LL;\n\tinc(t, q) {\n\t\tint a;\n\t\tLL b;\n\t\tscanf(\"%d%lld\", &a, &b);\n\t\tif(b > 100) { return 1; }\n\t\t\n\t\tinc(u, b) {\n\t\t\tint minp = n;\n\t\t\tinc(i, a) { if(num[i] < num[minp]) { minp = i; } }\n\t\t\tnum[minp]++;\n\t\t}\n\t}\n\t\n\tinc(i, n) { printf(\"%lld\\n\", num[i]); }\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//cout<<setprecision(20)\nconst llint mod=1000000007;\nconst llint big=2.19e13+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint LBI(vector<lldo>&ar,lldo in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint UBI(vector<lldo>&ar,lldo in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//寿司を解く\n\tint n,i,j,Q;cin>>n>>Q;\n\tset<pair<int,llint>>hen;\n\then.ins(mp(0,big));\n\then.ins(mp(n,0));\n\twhile(Q--){\n\t\tint a;llint b;cin>>a>>b;\n\t\tllint num=hen.lower_bound(mp(a,-big))->sec;\n\t\twhile(-1){\n\t\t\tauto p=prev(hen.lower_bound(mp(a,big)));\n\t\t\tint ter=p->fir;\n\t\t\tllint sa=p->sec - num;\n\t\t\tif(b>=sa*(a-ter)){\n\t\t\t\tb-=sa*(a-ter);\n\t\t\t\tnum=p->sec;\n\t\t\t\then.erase(p);\n\t\t\t}else{\n\t\t\t\tnum+=b/(a-ter);\n\t\t\t\tb%=a-ter;\n\t\t\t\then.ins(mp(a,num));\n\t\t\t\tif(sa>0){hen.ins(mp(ter+b,num+1));}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<llint>ans(n);\n\tfor(auto itr=hen.rbegin();itr!=hen.rend();itr++){\n\t\tif(itr->fir==0){break;}\n\t\tmaxeq(ans[itr->fir -1],itr->sec);\n\t}\n\tfor(i=n-1;i>0;i--){maxeq(ans[i-1],ans[i]);}\n\tfor(i=0;i<n;i++){cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nsigned main(){\n    set<tuple<int,int,int>>st;\n    st.insert(make_tuple(0,0,LLONG_MAX/10));\n\n    int N,Q;\n    cin>>N>>Q;\n    st.insert(make_tuple(N,0,0));\n\n    while(Q--){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n        while(b){\n            auto it=st.lower_bound(make_tuple(a,-1,-1));\n            int l,r,c;\n            tie(r,l,c)=*it;\n            st.erase(it);\n            if(r!=a){\n                st.insert(make_tuple(a,l,c));\n                st.insert(make_tuple(r,a,c));\n                continue;\n            }\n\n            int ll,rr,cc;\n            it=st.lower_bound(make_tuple(l,-1,-1));\n            tie(rr,ll,cc)=*it;\n\n            if(b>=(cc-c)*(r-l)){\n                b-=(cc-c)*(r-l);\n                st.erase(it);\n                st.insert(make_tuple(r,ll,cc));\n            }\n            else{\n                c+=b/(r-l);\n                if(b%(r-l))st.insert(make_tuple(b%(r-l)+l,l,c+1));\n                st.insert(make_tuple(r,b%(r-l)+l,c));\n                b=0;\n            }\n        }\n    }\n\n    for(auto &p:st){\n        for(int i=0;i<get<0>(p)-get<1>(p);i++)cout<<get<2>(p)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567L\n\nclass SegTree{\npublic:\n  int n;\n  vector<long> data, sum; // data: 区間内の値，sum:区間内の実際の和\n  inline void lazy_eval(int k, int l, int r){\n    if(data[k]>0){ // 最新の更新が下に伝搬していないとき\n      sum[k] = data[k]*(r-l);\n      if(k<n-1){\n        data[2*k+1]=data[k];\n        data[2*k+2]=data[k];\n      }\n      data[k]=0;\n    }\n  }\n  void _update(int a, int b, long v, int k, int l, int r){\n    lazy_eval(k,l,r);\n    if(r<=a || b<=l) return;\n    if(a<=l && r<=b){\n      data[k] = v;\n      lazy_eval(k,l,r);\n      return;\n    }\n    int m=(l+r)/2;\n    _update(a,b,v,k*2+1,l,m);\n    _update(a,b,v,k*2+2,m,r);\n    sum[k] = sum[k*2+1] + sum[k*2+2];\n    return;\n  }\n  // [a,b) をvに更新\n  void update(int a, int b, long v){ _update(a,b,v,0,0,n); }\n\n  long _sum(int a, int b, int k, int l, int r){\n    lazy_eval(k,l,r);\n    if(r<=a || b<=l) return 0;\n    if(a<=l && r<=b) return sum[k];\n    int m=(l+r)/2;\n    long vl = _sum(a,b,k*2+1,l,m);\n    long vr = _sum(a,b,k*2+2,m,r);\n    sum[k] = sum[k*2+1] + sum[k*2+2]; //??\n    return vl+vr;\n  }\n  // [a,b) の合計\n  long query(int a,int b){ return _sum(a,b,0,0,n); }\n\n  SegTree(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    data = vector<long>(2*n-1, 0);\n    sum = vector<long>(2*n-1, 0);\n  }\n};\n\nint main(){\n  int n,q;\n  cin>>n>>q;\n  vector<int> a(q);\n  vector<long> b(q);\n  rep(i,q) cin>>a[i]>>b[i];\n\n  SegTree st(n);\n\n  rep(i,q){\n    int li=-1,ri=a[i];\n    while(ri-li>1){\n      int mi=(li+ri)/2;\n      // [mi,a[i])を埋めなおす\n      long sumnew = st.query(mi,a[i]) + b[i];\n      long newh = sumnew/(a[i]-mi);\n      if(sumnew%(a[i]-mi)!=0) newh++;\n\n      if(st.query(mi,mi+1) >= newh) li = mi;\n      else ri = mi;\n    }\n    long sumnew = st.query(ri,a[i]) + b[i];\n    long newh = sumnew/(a[i]-ri);\n    long rem = sumnew%(a[i]-ri);\n    st.update(ri+rem, a[i], newh);\n    st.update(ri, ri+rem, newh+1);\n\n//    rep(j,n) cout << st.query(j,j+1) << endl; cout<<endl;\n  }\n\n  rep(i,n) cout << st.query(i,i+1) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct P{\n\tint id;\t\t//id\n\tlong long num;\t//食べた寿司数\n\tbool operator<(const P& p) const{\n\t\tif (num < p.num){\n\t\t\treturn true;\n\t\t}\n\t\tif (num == p.num){\n\t\t\treturn id<p.id;\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator==(const P& p) const{\n\t\tif (num == p.num){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tP(int _id,long long _num){\n\t\tid=_id;\n\t\tnum=_num;\n\t}\n};\nvoid SetMinP(vector<P*> p,int a,long long b)\n{\n\tP *minP;\n\twhile (b>0){\n\t\tminP=p[a-1];\n\t\tfor (int i=a-1;i>=0;i--){\n\t\t\tif (*minP==*p[i]){\n\t\t\t\tminP = p[i];\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tminP->num++;\n\t\tb--;\n\t}\n}\nint main(int argc, char* argv[])\n{\n\tint N,Q;\n\tcin>>N>>Q;\n\tvector<P*> pVector;\n\tint i;\n\tP *p;\n\tfor (i=0;i<N;i++){\n\t\tp = new P(i+1,0);\n\t\tpVector.push_back(p);\n\t}\n\tint a;\n\tlong long b;\n\tfor (i=0;i<Q;i++){\n\t\tcin>>a>>b;\n\t\tSetMinP(pVector,a,b);\n\t}\n\tfor (i=0;i<pVector.size();i++){\n\t\tcout<<pVector[i]->num<<endl;\n\t\tdelete pVector[i];\n\t}\n\tpVector.clear();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\nusing ll = long long;\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\ntemplate <typename Base>\nclass LazySeg\n{\n    static std::size_t SZ(const std::size_t n)\n    {\n        std::size_t ans = 1;\n        for (; ans < n; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using BaseAlgebra = Base;\n    using ValMonoid = typename BaseAlgebra::ValMonoid;\n    using OpMonoid = typename BaseAlgebra::OpMonoid;\n    using T = typename BaseAlgebra::VT;\n    using F = typename BaseAlgebra::OT;\n    LazySeg(const std::size_t n) : size(n), half(SZ(n)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id()) {}\n    template <typename InIt>\n    LazySeg(const InIt first, const InIt last) : size(std::distance(first, last)), half(SZ(size)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id())\n    {\n        copy(first, last, value.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    T get(const std::size_t a) const { return accumulate(a, a + 1); }\n    void set(std::size_t a, const T& val)\n    {\n        modify(a, a + 1, OpMonoid::id()), value[a += half] = val;\n        while (a >>= 1) { up(a); }\n    }\n    T accumulate(const std::size_t L, const std::size_t R) const\n    {\n        auto arec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> T {\n            if (L <= left and right <= R) {\n                return value[index];\n            } else if (right <= L or R <= left) {\n                return ValMonoid::id();\n            } else {\n                return act(action[index], acc(self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right)));\n            }\n        };\n        return arec(arec, 1, 0, half);\n    }\n    void modify(const std::size_t L, const std::size_t R, const F& f)\n    {\n        auto mrec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> void {\n            if (L <= left and right <= R) {\n                this->update(index, f);\n            } else if (right <= L or R <= left) {\n            } else {\n                this->update(index << 1, action[index]), this->update(index << 1 | 1, action[index]);\n                self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right);\n                this->up(index), action[index] = OpMonoid::id();\n            }\n        };\n        mrec(mrec, 1, 0, half);\n    }\n    template <typename Pred>\n    std::size_t partitionPoint(const std::size_t L, const std::size_t R, const Pred& pred) const\n    {\n        auto prec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right, const T& offset) -> std::pair<T, std::size_t> {\n            if (right <= L or R <= left or pred(acc(offset, act(action[index], value[index])))) { return {ValMonoid::id(), R}; }\n            if (index >= half) { return {act(action[index], value[index]), index - half}; }\n            const std::pair<T, std::size_t> lans = self(self, index << 1, left, (left + right) >> 1, offset);\n            if (lans.second != R) { return lans; }\n            return self(self, index << 1 | 1, (left + right) >> 1, right, acc(offset, lans.first));\n        };\n        return prec(prec, 1, 0, half, ValMonoid::id()).second;\n    }\n\n    std::vector<T> data() const\n    {\n        std::vector<T> ans(size);\n        for (std::size_t i = 0; i < size; i++) { ans[i] = get(i); }\n        return ans;\n    }\n\nprivate:\n    void up(const std::size_t i) { value[i] = acc(value[i << 1], value[i << 1 | 1]); }\n    void update(const std::size_t i, const F& f) { value[i] = act(f, value[i]), action[i] = compose(f, action[i]); }\n    const std::size_t size, half;\n    std::vector<T> value;\n    std::vector<F> action;\n    const ValMonoid acc{};\n    const OpMonoid compose{};\n    const BaseAlgebra act{};\n};\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const LazySeg<T>& seg)\n{\n    os << \"[\";\n    for (const auto& e : seg.data()) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 4; }\ntemplate <typename VX = ll, typename OX = ll>\nstruct MAct\n{\n    struct VT\n    {\n        VX max, sum;\n        std::size_t L, R;\n    };\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return VT{std::max(a.max, b.max), a.sum + b.sum, std::min(a.L, b.L), std::max(a.R, b.R)}; }\n        static constexpr VT id() { return {-INF<VX>(), (VX)0, INF<std::size_t>(), 0UL}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<OT>() ? VT{f, f * VX(x.R - x.L), x.L, x.R} : x; }\n};\nint main()\n{\n    std::size_t N, Q;\n    std::cin >> N >> Q;\n    LazySeg<MAct<ll, ll>> seg(N);\n    using VT = typename MAct<ll, ll>::VT;\n    for (std::size_t i = 0; i < N; i++) { seg.set(i, {0, 0, i, i + 1}); }\n    for (std::size_t q = 0; q < Q; q++) {\n        std::size_t A;\n        ll B;\n        std::cin >> A >> B;\n        auto pred = [&](const VT& v) {\n            const std::size_t l = v.L, r = v.R;\n            const ll H = v.max, res = H * (r - N + A) - v.sum;\n            return res < B;\n        };\n        const std::size_t p = seg.partitionPoint(N - A, N, pred);\n        const ll rect = seg.accumulate(N - A, p).sum + B, H = rect / (p - N + A), mod = rect % (p - N + A);\n        seg.modify(N - A, p, H);\n        if (mod != 0) { seg.modify(p - mod, p, H + 1); }\n    }\n    for (std::size_t i = 0; i < N; i++) { std::cout << seg.get(N - i - 1).max << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz,h; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(k < n) {\n                    lazy_add[2*k] = lazy_add[2*k+1] = 0;\n                    lazy_update[2*k] = lazy_update[2*k+1] = lazy_update[k];\n                    lazyFlag[2*k] = lazyFlag[2*k+1] = true;\n                }\n                lazy_add[k] = 0, lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(k < n){\n                    lazy_add[2*k] += lazy_add[k]; lazy_add[2*k+1] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T>& v) : n(1), sz((int)v.size()), h(0){\n            while(n < sz) n *= 2, h++;\n            node.resize(2*n, numeric_limits<T>::min());\n            lazy_update.resize(2*n, 0); lazyFlag.resize(2*n, false);\n            lazy_add.resize(2*n, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n] = v[i];\n            }\n            for(int i=n-1; i>=1; i--) node[i] = max(node[2*i], node[2*i+1]);\n        }\n        void update(int a, int b, T x, int k=1, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true; eval(k);\n            }else{\n                update(a, b, x, 2*k, l, (l+r)/2); update(a, b, x, 2*k+1, (l+r)/2, r);\n                node[k] = max(node[2*k], node[2*k+1]);\n            }\n        }\n        void add(int a, int b, T x, int k=1, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k);\n            }else{\n                add(a, b, x, 2*k, l, (l+r)/2); add(a, b, x, 2*k+1, (l+r)/2, r);\n                node[k] = max(node[2*k], node[2*k+1]);\n            }\n        }\n        T query(int a, int b) {\n            a += n, b += n - 1;\n            for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n            b++;\n            T res1 = numeric_limits<T>::min(), res2 = numeric_limits<T>::min();\n            while(a < b) {\n                if(a & 1) eval(a), res1 = max(res1, node[a++]);\n                if(b & 1) eval(--b), res2 = max(res2, node[b]);\n                a >>= 1, b >>= 1;\n            }\n            return max(res1, res2);\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a;\n        ll b;\n        scanf(\"%d %lld\",&a,&b);\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        printf(\"%lld\\n\",sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 10;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#define md double\n#define LL long long\nusing namespace std;\nconst int N=1<<20|1;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\ninline LL gL() {\n\tLL w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nLL e[N],sum[N],tag[N],now[N];\nint dep[N];\nint main()\n{\n\tint n=gi(),Q=gi(),i,k,t,ed,siz,L,R,l,r,H=1,mid;LL q,suf,to;\n\tfor (siz=1;siz<n+1;siz=siz<<1|1) H++;\n\tfor (dep[1]=H,i=2;i<=(siz<<1|1);i++) dep[i]=dep[i>>1]-1;\n\te[siz+1]=3e13;\n#define lc (k<<1)\n#define rc (lc|1)\n#define pushdown tag[lc]=tag[rc]=e[lc]=e[rc]=tag[k],sum[lc]=sum[rc]=tag[k]<<dep[lc],tag[k]=0\n#define update e[k]=e[rc],sum[k]=sum[lc]+sum[rc]\n#define modify(k,to) tag[k]=e[k]=(to),sum[k]=(to)<<dep[k]\n\twhile (Q--) {\n\t\tL=siz+1,R=siz+(ed=gi()+1)+1;q=gL();\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=L>>i]) pushdown;\n\t\t\tif ((R>>i)!=k&&tag[k=R>>i]) pushdown;\n\t\t}\n\t\tfor (l=L,now[r=R]=0;l^r^1;l>>=1,r>>=1) {\n\t\t\tif (~l&1) now[l^1]=sum[l^1],now[l>>1]=now[l]+now[l^1]; else now[l>>1]=now[l];\n\t\t\tif (r&1) now[r^1]=sum[r^1],now[r>>1]=now[r^1]+now[r]; else now[r>>1]=now[r];\n\t\t}\n\t\tnow[l>>1]=now[l]+now[r];\n\t\tfor (k=l;(k>>=1)>1;) now[k>>1]=now[k];\n\t\tsuf=0;\n\t\tfor (k=l>>1,l=1,r=1<<dep[k];k<=siz;) {\n\t\t\tif (tag[k]) pushdown;\n\t\t\tif (ed<=(mid=(l+r)>>1)) k<<=1,r=mid;\n\t\t\telse k=k<<1|(mid=(l+r)>>1,q<=e[lc]*(ed-mid)-(r<=ed?sum[rc]:now[rc])-suf?(l=mid+1,1):(suf+=r<=ed?sum[rc]:now[rc],r=mid,0));\n\t\t}\n\t\tsuf+=sum[k];\n\t\tto=(q-(e[i]*(ed-l+1)-suf))/(ed-l+1);\n\t\tq-=to*(ed-l+1)-suf;t=--k;\n\t\tl=k,r=t+q+1;\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=l>>i]) pushdown;\n\t\t\tif ((r>>i)!=k&&tag[k=r>>i]) pushdown;\n\t\t}\n\t\tfor (;l^r^1;) {\n\t\t\tif (~l&1) modify(l^1,to+1);\n\t\t\tif (r&1) modify(r^1,to+1);\n\t\t\tk=l>>=1;update;\n\t\t\tk=r>>=1;update;\n\t\t}\n\t\twhile (k=(l>>=1)) update;\n\t\tl=t+q,r=siz+ed+1;\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=l>>i]) pushdown;\n\t\t\tif ((r>>i)!=k&&tag[k=r>>i]) pushdown;\n\t\t}\n\t\tfor (;l^r^1;) {\n\t\t\tif (~l&1) modify(l^1,to);\n\t\t\tif (r&1) modify(r^1,to);\n\t\t\tk=l>>=1;update;\n\t\t\tk=r>>=1;update;\n\t\t}\n\t\twhile (k=(l>>=1)) update;\n\t}\n\tfor (k=1;k<=siz;k++) if (tag[k]) pushdown;\n\tfor (k=1;k<=n;k++) printf(\"%lld\\n\",e[k+siz+1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline int in() {\n    int n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline ll in_() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[18], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in(), q = in();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in();\n        ll b = in_();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                    st.erase(it2);\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            h[p] += x+1;\n                        }else{\n                            st.erase(it2);\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//It is made by ljh2000\n//有志者，事竟成，破釜沉舟，百二秦关终属楚；苦心人，天不负，卧薪尝胆，三千越甲可吞吴。\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#define lc root<<1\n#define rc root<<1|1\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200011;\nint n,Q;\nstruct node{ LL set,add,sum; }a[MAXN*3];\ninline void update(int root){ a[root].sum=a[lc].sum+a[rc].sum; }\ninline int getint(){\n    int w=0,q=0; char c=getchar(); while((c<'0'||c>'9') && c!='-') c=getchar();\n    if(c=='-') q=1,c=getchar(); while (c>='0'&&c<='9') w=w*10+c-'0',c=getchar(); return q?-w:w;\n}\n\ninline void pushdown(int root,int l,int r){\n\tif(a[root].set==0 && a[root].add==0) return  ; if(l==r) return ;\n\tint mid=(l+r)>>1;\n\tif(a[root].set>0) {\n\t\ta[lc].set=a[rc].set=a[root].set;\n\t\ta[lc].sum=1LL*a[root].set*(mid-l+1); a[rc].sum=1LL*a[root].set*(r-mid);\n\t\ta[lc].add=a[rc].add=a[root].set=0;\n\t}\n\n\tif(a[root].add>0) {\n\t\ta[lc].add+=a[root].add; a[rc].add+=a[root].add;\n\t\ta[lc].sum+=1LL*a[root].add*(mid-l+1); a[rc].sum+=1LL*a[root].add*(r-mid);\n\t\ta[root].add=0;\n\t}\n}\n\ninline void modify(int root,int l,int r,int ql,int qr,LL val){\n\tpushdown(root,l,r);\n\tif(ql<=l && r<=qr) {\n\t\ta[root].set=val; a[root].add=0;\n\t\ta[root].sum=1LL*(r-l+1)*val;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) modify(lc,l,mid,ql,qr,val);\n\tif(qr>mid) modify(rc,mid+1,r,ql,qr,val);\n\tupdate(root);\n}\n\ninline void add(int root,int l,int r,int ql,int qr,LL val){\n\tpushdown(root,l,r);\n\tif(ql<=l && r<=qr) {\n\t\ta[root].sum+=1LL*val*(r-l+1);\n\t\ta[root].add+=val;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(ql<=mid) add(lc,l,mid,ql,qr,val);\n\tif(qr>mid) add(rc,mid+1,r,ql,qr,val);\n\tupdate(root);\n}\n\ninline LL query(int root,int l,int r,int ql,int qr){\n\tif(ql<=l && r<=qr) return a[root].sum;\n\tpushdown(root,l,r); int mid=(l+r)>>1;\n\tif(qr<=mid) return query(lc,l,mid,ql,qr);\n\telse if(ql>mid) return query(rc,mid+1,r,ql,qr);\n\treturn query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr);\n}\n\ninline void dfs(int root,int l,int r){\n\tif(l==r) { printf(\"%lld\\n\",a[root].sum); return ; }\n\tpushdown(root,l,r); int mid=(l+r)>>1;\n\tdfs(lc,l,mid); dfs(rc,mid+1,r);\n}\n\ninline void work(){\n\tn=getint(); Q=getint(); int x; LL y; int l,r,mid,pos;\n\twhile(Q--) {\n\t\tx=getint(); scanf(\"%lld\",&y);\n\t\tif(x==1) { add(1,1,n,1,1,y); continue; }\n\t\tl=1; r=x; pos=0;\n\t\twhile(l<=r) {\n\t\t\tmid=(l+r)>>1;\n\t\t\tif(1LL*query(1,1,n,mid,mid)*(x-mid+1)-query(1,1,n,mid,x) <= y) r=mid-1;\n\t\t\telse l=mid+1,pos=mid;\n\t\t}\n\t\ty-=1LL*query(1,1,n,pos+1,pos+1)*(x-pos)-query(1,1,n,pos+1,x);\n\t\tmodify(1,1,n,pos+1,x, query(1,1,n,pos+1,pos+1) );\n\t\tif(y/(x-pos)) add(1,1,n,pos+1,x,y/(x-pos));\n\t\tif(y%(x-pos)) add(1,1,n,pos+1,pos+y%(x-pos),1);\n\t}\n\tdfs(1,1,n);\n}\n\nint main()\n{\n    work();\n    return 0;\n}\n//有志者，事竟成，破釜沉舟，百二秦关终属楚；苦心人，天不负，卧薪尝胆，三千越甲可吞吴。\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 1024;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (mid == a) for(;;);\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tif (a - r + 1 == 0) for(;;);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 100;\n\nvoid enter()\n{\n    freopen(\"solve.inp\",\"r\",stdin);\n    freopen(\"solve.out\",\"w\",stdout);\n}\nconst long long oo = 1e18;\nlong long IT[N * 4];\nlong long lazy[N * 4];\n\nvoid cn(int i, int L, int R) {\n    if (lazy[i] == 0) return;\n    IT[i] = 1LL * (R - L + 1) * lazy[i];\n    if (L != R) {\n        lazy[i << 1] = lazy[i];\n        lazy[i << 1 | 1] = lazy[i];\n    }\n    lazy[i] = 0;\n}\nvoid update(int i, int L, int R, int u, int v, long long val) { ///a[u -> v] = val\n    cn(i, L, R);\n    if (L > v || R < u) return;\n    if (L >= u && R <= v) {\n        lazy[i] = val;\n        cn(i, L, R);\n        return;\n    }\n    int mid = (L + R) >> 1;\n    update(i << 1, L, mid, u, v, val);\n    update(i << 1 | 1, mid + 1, R, u, v, val);\n    IT[i] = IT[i << 1] + IT[i << 1 | 1];\n}\nlong long Get(int i, int L, int R, int u, int v) {\n    cn(i, L, R);\n    if (L > v || R < u) return 0;\n    if (L >= u && R <= v) return IT[i];\n    int mid = (L + R) >> 1;\n    long long Left = Get(i << 1, L, mid, u, v);\n    long long Right = Get(i << 1 | 1, mid + 1, R, u, v);\n    return Left + Right;\n}\nvoid solve()\n{\n    int n, Q;\n    cin >> n >> Q;\n    while (Q--) {\n        int r;\n      \tlong long Pi;\n        cin >> r >> Pi;\n        int L = 1;\n        int R = r;\n        int H = r;\n        while (L <= R) {\n            int mid = (L + R) >> 1;\n            long long KC = Get(1, 1, n, mid, r);\n            long long Cao = Get(1, 1, n, mid, mid);\n            if ((Cao * (r - mid + 1) - KC) <= Pi) {\n                R = mid - 1;\n                H = mid;\n            }\n            else L = mid + 1;\n        }\n        long long Cao = Get(1, 1, n, H, H);\n        long long SL = Get(1, 1, n, H, r);\n        Pi -= Cao * (r - H + 1) - SL;\n        long long newH = Cao + (Pi / (r - H + 1));\n        long long Thua = Pi % (r - H + 1);\n        update(1, 1, n, H, r, newH);\n        update(1, 1, n, H, H + Thua - 1, newH + 1);\n        //cout << Get(1, 1, n, 2, 2).sum << '\\n';\n//        for (int i = 1; i <= n; i++) cout << Get(1, 1, n, i, i).sum << ' ';\n//        cout << '\\n';\n    }\n    for (int i = 1; i <= n; i++) cout << Get(1, 1, n, i, i) << ' ';\n}\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(nullptr); cout.tie(nullptr);\n    //enter();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <map>\n#include <set>\n#include <array>\n#include <queue>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\ntypedef std::pair<int, int> P;\n\nLL N, Q, a[112345], b[112345];\nLL field[112345];\n\nint main()\n{\n\tin >> N >> Q;\n\trep(i, Q) { in >> a[i] >> b[i]; }\n\n\trep(i, Q)\n\t{\n\t\tint min_pers, min_plate = INF;\n\t\tfor (int j = 0; j < b[i]; ++j)\n\t\t{\n\t\t\tif (field[j] < min_plate)\n\t\t\t{\n\t\t\t\tmin_plate = field[j];\n\t\t\t\tmin_pers = j;\n\t\t\t}\n\t\t}\n\t\t++field[min_pers];\n\t}\n\n\trep(i, N) { out << field[i] << std::endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100000];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tmemset(res, 0, sizeof(res));\n\tcin >> N >> Q;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n\t\tREP(i, B, 0) {\n\t\t\tint idx = 0;\n\t\t\tLL v = res[0];\n\t\t\tREP(j, A, 1) {\n\t\t\t\tif (res[j] < v) {\n\t\t\t\t\tidx = j;\n\t\t\t\t\tv = res[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[idx]++;\n\t\t}\n\t}\n\tREP(i, N, 0) {\n\t\tcout << res[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline ll in() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in(), q = in();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                    st.erase(it2);\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            h[p] += x+1;\n                        }else{\n                            st.erase(it2);\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k, int l, int r) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(r - l > 1) {\n                    lazy_add[2*k+1] = lazy_add[2*k+2] = 0;\n                    lazy_update[2*k+1] = lazy_update[2*k+2] = lazy_update[k];\n                    lazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n                }\n                lazy_add[k] = 0;\n                lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(r - l > 1){\n                    lazy_add[2*k+1] += lazy_add[k]; lazy_add[2*k+2] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T> v) : sz((int)v.size()){\n            n = 1;\n            while(n < sz) n *= 2;\n            node.resize(2*n-1,numeric_limits<T>::min());\n            lazy_update.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n            lazy_add.resize(2*n-1, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n-1] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) node[i] = max(node[2*i+1],node[2*i+2]);\n        }\n        void update(int a, int b, T x, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true;\n                eval(k, l, r);\n            }else{\n                update(a, b, x, 2*k+1, l, (l+r)/2); update(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        void add(int a, int b, T x, int k=0, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k, l, r);\n            }else{\n                add(a, b, x, 2*k+1, l, (l+r)/2); add(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        T query(int a, int b, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return numeric_limits<T>::min();\n            if(a <= l && r <= b) return node[k];\n            return max(query(a, b, 2*k+1, l, (l+r)/2), query(a, b, 2*k+2, (l+r)/2, r));\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a;\n        ll b;\n        scanf(\"%d %lld\",&a,&b);\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        printf(\"%lld\\n\",sg.query(i,i+1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 19) + 20;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (mid == a) for(;;);\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tif (a - r + 1 == 0) for(;;);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 20;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else if (tree[root].stdl != tree[root].stdr) {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\nclass SegmentTree {\n   public:\n    using value_type = int64_t;\n\n    SegmentTree(int64_t n)\n            : n(n), cap(pow(2, ceil(log2(n)))), values(2 * cap - 1, 0), delay(2 * cap - 1, -1L) {}\n  \n    void update(int64_t a, int64_t b, int64_t v, int64_t idx = 0, int64_t l = 0,\n                     int64_t r = -1) {\n        if (r < 0) {\n            r = cap;\n        }\n\n        if (a >= r || b <= l) {\n            return;\n        }\n\n        if (a <= l && r <= b) {\n            values[idx] = v * (r - l);\n            delay[idx] = v;\n            return;\n        }\n\n        auto left_idx = 2 * (idx + 1) - 1;\n        auto right_idx = 2 * (idx + 1);\n\n        if (delay[idx] >= 0) {\n            update(l, (l + r) / 2, delay[idx], left_idx, l, (l + r) / 2);\n            update((l + r) / 2, r, delay[idx], right_idx, (l + r) / 2, r);\n            delay[idx] = -1;\n        }\n\n        update(a, b, v, left_idx, l, (l + r) / 2);\n        update(a, b, v, right_idx, (l + r) / 2, r);\n      \n        values[idx] = values[left_idx] + values[right_idx];\n    }\n  \n    value_type get(int64_t pos) {\n        return query(pos, pos + 1);\n    }\n\n    value_type query(int64_t a, int64_t b, int64_t idx = 0, int64_t l = 0,\n                     int64_t r = -1) {\n        if (r < 0) {\n            r = cap;\n        }\n\n        if (a >= r || b <= l) {\n            return 0;\n        }\n\n        if (a <= l && r <= b) {\n            return values[idx];\n        }\n\n        auto left_idx = 2 * (idx + 1) - 1;\n        auto right_idx = 2 * (idx + 1);\n      \n        if (delay[idx] >= 0) {\n            update(l, (l + r) / 2, delay[idx], left_idx, l, (l + r) / 2);\n            update((l + r) / 2, r, delay[idx], right_idx, (l + r) / 2, r);\n            delay[idx] = -1;\n        }\n\n        auto left_v = query(a, b, left_idx, l, (l + r) / 2);\n        auto right_v = query(a, b, right_idx, (l + r) / 2, r);\n\n        return left_v + right_v;\n    }\n\n   private:\n    int64_t n;\n    int64_t cap;\n    vector<value_type> values;\n    vector<value_type> delay;\n};\n\nmain() {\n    int64_t n, q;\n    cin >> n >> q;\n\n    SegmentTree tree(n);\n  \n    for (auto i : irange(0L, q)) {\n        int64_t a, b;\n        cin >> a >> b;\n      \n        auto r = irange(0L, a);\n        auto c = *partition_point(r.begin(), r.end(), [&](int64_t pos) {\n            auto v = tree.get(pos);\n            auto v2 = tree.query(pos + 1, a);\n            return v2 + b < v * (a - pos - 1);\n        });\n        auto v = tree.get(c);\n        auto v2 = tree.query(c + 1, a);\n\n        b -= v * (a - c - 1) - v2;\n        auto l = a - c;\n        tree.update(c, c + b % l, v + b / l + 1);\n        tree.update(c + b % l, a, v + b / l);\n    }\n  \n    for (auto i : irange(0L, n)) {\n        cout << tree.get(i) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n// 寿司を食べたい！！\ntypedef long long int64;\n\nstruct SegmentTree\n{\n  vector< int64 > seg, lazy;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, 0);\n    lazy.assign(2 * sz - 1, -1);\n  }\n\n  void push(int k)\n  {\n    if(lazy[k] >= 0) {\n      if(k < sz - 1) {\n        lazy[2 * k + 1] = lazy[k] >> 1LL;\n        lazy[2 * k + 2] = lazy[k] >> 1LL;\n      }\n      seg[k] = lazy[k];\n      lazy[k] = -1;\n    }\n  }\n\n  int64 query(int a, int b, int k, int l, int r)\n  {\n    push(k);\n    if(a >= r || b <= l) {\n      return (0);\n    } else if(a <= l && r <= b) {\n      return (seg[k]);\n    } else {\n      return (query(a, b, 2 * k + 1, l, (l + r) >> 1) +\n              query(a, b, 2 * k + 2, (l + r) >> 1, r));\n    }\n  }\n\n  int64 query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n\n  void update(int a, int b, int64 x, int k, int l, int r)\n  {\n    push(k);\n    if(a >= r || b <= l) {\n      return;\n    } else if(a <= l && r <= b) {\n      lazy[k] = x * (r - l);\n      push(k);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n      update(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n      seg[k] = seg[2 * k + 1] + seg[2 * k + 2];\n    }\n  }\n\n  void update(int a, int b, int64 x)\n  {\n    update(a, b, x, 0, 0, sz);\n  }\n\n};\n\nsigned main()\n{\n  int N, Q;\n\n  cin >> N >> Q;\n  SegmentTree tree(N);\n  while(Q--) {\n    int64 A, B;\n    cin >> A >> B;\n    int low = 0, high = A;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(tree.query(mid, mid + 1) * (A - mid) - tree.query(mid, A) > B) low = mid;\n      else high = mid;\n    }\n    if(tree.query(low, low + 1) * (A - low) - tree.query(low, A) > B) ++low;\n    int64 v = tree.query(low, A) + B;\n    int64 width = A - low;\n    tree.update(low, A, v / width + 1);\n    tree.update(low + v % width, A, v / width);\n  }\n  for(int i = 0; i < N; i++) {\n    cout << tree.query(i, i + 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define NN 100400\nlong long oo;\nstruct node{\n\tlong long l,r;\n\tlong long max,min;\n\tlong long sum;\n\tlong long fg;\n}tree[NN*4];\nlong long n,q;\nvoid Init(long long l,long long r,long long idd){\n\ttree[idd].l=l;\n\ttree[idd].r=r;\n\ttree[idd].max=tree[idd].min=0;\n\ttree[idd].sum=0;\n\ttree[idd].fg=0;\n\tif(r-l<=1) return ;\n\tlong long mid=(l+r)/2;\n\tInit(l,mid,idd<<1);\n\tInit(mid,r,idd<<1|1);\n}\nvoid Up(long long idd){\n\ttree[idd].sum=tree[idd<<1].sum+tree[idd<<1|1].sum;\n\ttree[idd].max=max(tree[idd<<1].max,tree[idd<<1|1].max);\n\ttree[idd].min=min(tree[idd<<1].min,tree[idd<<1|1].min);\n}\nvoid Down(long long idd){\n\tif(tree[idd].fg){\t\t\n\t\ttree[idd<<1].fg=tree[idd<<1|1].fg=1;\n\t\ttree[idd<<1].min=tree[idd<<1|1].min=tree[idd].min;\n\t\ttree[idd<<1].max=tree[idd<<1|1].max=tree[idd].max;\n\t\ttree[idd<<1].sum=tree[idd].min*(tree[idd<<1].r-tree[idd<<1].l);\n\t\ttree[idd<<1|1].sum=tree[idd].min*(tree[idd<<1|1].r-tree[idd<<1|1].l);\n\t\ttree[idd].fg=0;\n\t}\n}\nlong long u;\nlong long bg;\nlong long ssum;\nlong long ftt;\nvoid Date(long long l,long long r,long long rr,long long num,long long pre,long long idd){\n\tlong long ssum=num+tree[idd].sum+ftt;\n\tlong long avg=ssum/(rr-l);\n\tif(ssum-avg*(rr-l)) avg++;\n\tif(avg>pre) return ;\n\tif(u==-1&&tree[idd].max<=avg) u=avg,bg=l;\n\telse if(u>=avg&&tree[idd].max<=avg)u=avg,bg=l;\n//\tprintf(\"~%d %d %d %lld %lld  %lld\\n\",l,r,bg,u,ssum,pre);\n\tif(r-l<=1) return  ;\n\tDown(idd);\n\tlong long mid=(l+r)/2;\n\tif(tree[idd<<1].min*(rr-tree[idd<<1|1].l)>=tree[idd<<1|1].sum+num) Date(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse {\n\t\tftt+=tree[idd<<1|1].sum;\n\t\tDate(l,mid,rr,num,pre,idd<<1);\n\t} \n\tUp(idd);\n}\nvoid Update(long long l,long long r,long long rr,long long num,long long pre,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tDate(l,r,rr,num,pre,idd);\n\t\tftt+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tUpdate(l,r,rr,num,pre,idd<<1);\n\telse if(mid<=l)\n\t\tUpdate(l,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse{\n\t\tUpdate(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\t\tUpdate(l,mid,rr,num,pre,idd<<1);\t\n\t}\n\tUp(idd);\n}\n\nvoid Query(long long l,long long r,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tssum+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tQuery(l,r,idd<<1);\n\telse if(mid<=l)\n\t\tQuery(l,r,idd<<1|1);\n\telse{\n\t\tQuery(l,mid,idd<<1);\n\t\tQuery(mid,r,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid fugai(long long l,long long r,long long shu,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\ttree[idd].max=tree[idd].min=shu;\n\t\ttree[idd].sum=(r-l)*shu;\n\t\ttree[idd].fg=1;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tfugai(l,r,shu,idd<<1);\n\telse if(mid<=l)\n\t\tfugai(l,r,shu,idd<<1|1);\n\telse{\n\t\tfugai(l,mid,shu,idd<<1);\n\t\tfugai(mid,r,shu,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid Print(long long l,long long r,long long idd){\n\tif(r-l<=1) {\n\t\tprintf(\"%lld\\n\",tree[idd].sum);\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(r+l)/2;\n\tPrint(l,mid,idd<<1);\n\tPrint(mid,r,idd<<1|1);\n\tUp(idd);\n}\nint main(){\n\too=1LL*2000000*10000000+10;\n\tscanf(\"%d%d\",&n,&q);\n\tInit(1,n+1,1);\n\tfor(long long i=1;i<=q;i++){\n\t\tlong long x;long long y;\n\t\tscanf(\"%d%lld\",&x,&y);\n\t\tu=-1;bg=-1;\n\t\tftt=0;\n\t\tUpdate(1,x+1,x+1,y,oo,1);\n\t\tssum=0;\n\t\tQuery(bg,x+1,1);\n\t\tlong long num=(x+1)-bg;\n\t\tlong long sum=ssum+y;\n\t\tlong long avg=sum/num;\n\t\tlong long a1=sum-avg*num;\n\t\tif(a1){\n\t\t\tfugai(bg,bg+a1,avg+1,1);\n\t\t}\n\t\tfugai(bg+a1,x+1,avg,1);\n\t//\tPrint(1,n+1,1);\n\t\n\t}\n\tPrint(1,n+1,1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\n/* LazyPropagationSegmentTree(Sum) */\n//0-index\n\nstruct LazySeg_sum{\n  typedef int Type;\n  \n  struct Data{\n    Type val;\n    Type add;\n    Type sum;\n    bool valset;\n    \n    Type calc_sum(int l, int r){\n      if(valset){\n        return (val + add) * (r - l + 1);\n      }else{\n        return sum + add * (r - l + 1);\n      }\n    }\n\n    void set_data(Type x,Type y){\n      val = x;\n      add = y;\n      valset = true;\n    }\n\n    void add_data(Type x){\n      add += x;\n    }\n    \n    Data():val(0),add(0),sum(0),valset(false){}\n    \n  };\n\n  vector<Data> data;\n  int seg_size;\n  \n  LazySeg_sum(int n){\n    for(seg_size=1; seg_size < n; seg_size*=2);\n    data.assign(seg_size*2, Data());\n  }\n\n  Type set(int a, int b, Type x, int l=0, int r=-1,int k=0){\n    if(r == -1) r = seg_size-1;\n    \n    if(a <= l && r <= b){\n      data[k].set_data(x,0);\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n    \n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val,data[k].add);\n      data[k*2+2].set_data(data[k].val,data[k].add);\n    }else{\n      data[k*2+1].add_data(data[k].add);\n      data[k*2+2].add_data(data[k].add);\n    }\n      \n\n    data[k].add = 0;\n    \n    data[k].valset = false;\n    \n    data[k].sum = set(a,b,x,l,(l+r)/2,k*2+1) + set(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n\n  Type add(int a, int b, Type x, int l=0, int r=-1, int k=0){\n    if(r == -1) r = seg_size-1;\n\n    if(a <= l && r <= b){\n      data[k].add += x;\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n\n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val, data[k].add);\n      data[k*2+2].set_data(data[k].val, data[k].add);\n      data[k].add = 0;\n      data[k].valset = false;\n    }\n\n    data[k].sum = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n  \n  Type query(int a, int b, int l=0, int r=-1, int k = 0){\n    if(r == -1) r = seg_size-1;\n\n    if(r < a || b < l) return 0;\n\n    if((a <= l && r <= b) || data[k].valset){\n      return data[k].calc_sum(max(a,l),min(b,r));\n    }\n\n    return query(a,b,l,(l+r)/2,k*2+1) + query(a,b,(l+r)/2+1,r,k*2+2) +\n           data[k].add * (min(b,r) - max(a,l) + 1);\n  }\n  \n};\n\n\nLazySeg_sum seg(100000);\n\nint main(){\n  int n,q,a,b;\n\n  scanf(\"%d%d\",&n,&q);\n\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n\n    if(a == 0){\n      seg.add(0,0,b);\n      continue;\n    } \n    \n    int l=1,r=a,mid;\n    ll u,p;\n    \n    while(l < r){\n\n      mid = (l+r)/2;\n\n      u = seg.query(mid-1,mid-1);\n      \n      p = seg.query(mid,a);\n\n      if((u * (a-mid+1) - p) > b){\n        l = mid+1;\n      }else{\n        r = mid;\n      }\n    }\n    \n    p = seg.query(l,a);\n    u = seg.query(l-1,l-1);\n\n    while( b < u*(a-l+1) - p ) u--;\n    \n    b -= u*(a-l+1) - p;\n    seg.set(l,a,u);\n    \n    seg.add(l-1,a,b/(a-(l-1)+1));\n    b%=(a-(l-1)+1);\n    \n    if(b > 0)\n      seg.add(l-1,b-1+(l-1),1);\n  }\n  \n  for(int i=0;i<n;i++){\n    printf(\"%lld\\n\",seg.query(i,i));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct RRange {\n\tint l, r;\n\tlong long int num;\n\tRRange(const int a, const int b, const long long int c) {\n\t\tl = a, r = b, num = c;\n\t\treturn;\n\t}\n\tbool operator<(const RRange& rr)const {\n\t\treturn r < rr.r;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tset<RRange>sr;\n\tsr.insert(RRange(1, N, 0));\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> L >> R;\n\t\tauto bag = sr.lower_bound(RRange(1, L, 0));\n\t\tif (bag->r != L) {\n\t\t\tint l = bag->l;\n\t\t\tint r = bag->r;\n\t\t\tlong long int num = bag->num;\n\t\t\tsr.erase(bag);\n\t\t\tsr.insert(RRange(l, L, num));\n\t\t\tsr.insert(RRange(L + 1, r, num));\n\t\t}\n\t\twhile (R) {\n\t\t\tauto box = sr.lower_bound(RRange(1, L, 0));\n\t\t\tif (box == sr.begin()) {\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tif (R%r) {\n\t\t\t\t\tsr.insert(RRange(l, l + (R%r) - 1, num + R / r + 1));\n\t\t\t\t\tsr.insert(RRange(l + (R%r), r, num + R / r));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum += R / r;\n\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t}\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << \"Hi\";\n\t\t\t\tauto bag = prev(box);\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tlong long int dif = (bag->num) - num;\n\t\t\t\tdif *= r - l + 1;\n\t\t\t\t//cout <<\"dif \"<< dif << endl;\n\t\t\t\tif (dif-(r-l+1) >= R) {\n\t\t\t\t\tif (R%r) {\n\t\t\t\t\t\tsr.insert(RRange(l, l + (R%(r-l+1)) - 1, num + R / (r-l+1) + 1));\n\t\t\t\t\t\tsr.insert(RRange(l + (R%(r-l+1)), r, num + R / (r-l+1)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum += R / (r-l+1);\n\t\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t\t}\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t\telse if (dif <= R) {\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, r, nnum));\n\t\t\t\t\tR -= dif;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint m = R % (r - l + 1);\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tint rr = bag->r;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, rr + m, nnum));\n\t\t\t\t\tsr.insert(RRange(rr + m + 1, r, nnum - 1));\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"R \" << R << endl;\n\n\t\t}\n\t}\n\tfor (auto i : sr) {\n\t\tfor (int j = i.l; j <= i.r; j++) {\n\t\t\tcout << i.num << endl;\n\t\t}\n\t\t//cout << i.l << \" \" << i.r << \" \" << i.num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx\")\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline ll in() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in(), q = in();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                    st.erase(it2);\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            h[p] += x+1;\n                        }else{\n                            st.erase(it2);\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tusing F=function<T(T,T)>;\n\tusing G=function<T(T,T,int,int)>;\n\tconst F calcfn,lazycalcfn;\n\tconst G updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tconst F calcfn_=[](T a,T b){return a+b;},\n\t\tconst F lazycalcfn_=[](T a,T b){return a+b;},\n\t\tconst G updatefn_=[](T a,T b,int l,int r){return a+b*(r-l);},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],l,r);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nint N,Q;\nmain()\n{\n\tcin>>N>>Q;\n\tlazysegtree<long>P(N,0,[](long a,long b){return a+b;},\n\t\t[](long a,long b){return b;},\n\t\t[](long a,long b,int l,int r){return b*(r-l);});\n\tfor(;Q--;)\n\t{\n\t\tlong a,b;cin>>a>>b;\n\t\tlong L=0,R=1e14;\n\t\twhile(R-L>1)\n\t\t{\n\t\t\tlong M=L+R>>1;\n\t\t\tint l=-1,r=a;\n\t\t\twhile(r-l>1)\n\t\t\t{\n\t\t\t\tint m=l+r>>1;\n\t\t\t\tif(P.query(m,m+1)>M)l=m;\n\t\t\t\telse r=m;\n\t\t\t}\n\t\t\tif(M*(a-r)-P.query(r,a)>b)R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tint l=-1,r=a;\n\t\twhile(r-l>1)\n\t\t{\n\t\t\tint m=l+r>>1;\n\t\t\tif(P.query(m,m+1)>L)l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tb-=L*(a-r)-P.query(r,a);\n\t\tP.update(r,a,L);\n\t\tP.update(r,r+b,L+1);\n\t}\n\tfor(int i=0;i<N;i++)cout<<P.query(i,i+1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// <sushi.cpp> - Sat Mar 25 08:49:56 2017\n// This file is created by XuYike's black technology automatically.\n// Copyright (C) 2015 ChangJun High School, Inc.\n// I don't know what this program is.\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef long long lol;\ntemplate<typename T>\ninline void gg(T &res){\n    res=0;T fh=1;char ch=getchar();\n    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();\n    if(ch=='-')fh=-1,ch=getchar();\n    while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();\n    res*=fh;\n}\ninline int gi(){int x;gg(x);return x;}\ninline lol gl(){lol x;gg(x);return x;}\nconst int MAXN=100010;\nconst int MAXK=MAXN<<2;\nconst lol INF=1e18;\nint n,pos[MAXN];\nlol val[MAXK],lazy[MAXK],mi[MAXK];\ninline void update(int x){\n    val[x]=val[x<<1]+val[x<<1|1];\n    mi[x]=min(mi[x<<1],mi[x<<1|1]);\n}\nvoid pushdown(int x,int l,int r){\n    if(!lazy[x])return;\n    int m=l+r>>1;\n    val[x<<1]=(m-l+1)*lazy[x];\n    val[x<<1|1]=(r-m)*lazy[x];\n    mi[x<<1]=mi[x<<1|1]=lazy[x<<1]=lazy[x<<1|1]=lazy[x];\n    lazy[x]=0;\n}\nlol getsum(int L,int R,int l=1,int r=n,int x=1){\n    if(l==L&&r==R)return val[x];\n    pushdown(x,l,r);\n    int m=l+r>>1;lol ans=0;\n    if(L<=m)ans+=getsum(L,min(R,m),l,m,x<<1);\n    if(R>m)ans+=getsum(max(L,m+1),R,m+1,r,x<<1|1);\n    return ans;\n}\nint find(int p,lol s,lol y,int l=1,int r=n,int x=1){\n    if(l==r)return l;\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    if(p<=m||s-val[x<<1]+y>mi[x<<1]*(p-m))return find(p,s,y,l,m,x<<1);\n    return find(p,s-val[x<<1],y,m+1,r,x<<1|1);\n}\nvoid set(int L,int R,lol v,int l=1,int r=n,int x=1){\n    if(L>R)return;\n    if(l==L&&r==R){\n        val[x]=(r-l+1)*v;\n        lazy[x]=mi[x]=v;\n        return;\n    }\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    if(L<=m)set(L,min(R,m),v,l,m,x<<1);\n    if(R>m)set(max(L,m+1),R,v,m+1,r,x<<1|1);\n    update(x);\n}\nvoid dfs(int l,int r,int x){\n    if(l==r){\n        if(l!=n)printf(\"%lld\\n\",val[x]);\n        return;\n    }\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    dfs(l,m,x<<1);\n    dfs(m+1,r,x<<1|1);\n}\nint main(){\n    n=gi();int m=gi();\n    while(m--){\n        int x=gi();\n        lol s=getsum(1,x),y=gl();\n        int p=find(x,s,y)-1;s=getsum(p+1,x);\n        set(p+1,x,(y+s)/(x-p));\n        set(p+1,p+(y+s)%(x-p),(y+s)/(x-p)+1);\n    }\n    dfs(0,n,1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 111111;\nconst ll INF = 1000000000000000000LL;\n\nclass SEG{\n  int n;\n  ll dat[2*(1<<18)-1];\n\npublic:\n  SEG(int _n = MAX){ \n    n = 1;\n    while(n < _n) n *= 2;\n    fill(dat,dat+2*n-1,0);\n  }\n\n  // get k-th\n  ll get(int k){\n    k += n - 1;\n    ll ret = dat[k];\n    while(k > 0){\n      k = (k - 1) / 2;\n      ret += dat[k];\n    }\n    return ret;\n  }\n\n  // add x to [a,b) \n  void query(int a, int b,ll x ){ return query(a, b, x, 0, 0, n);}\n  void query(int a, int b, ll x, int k, int l, int r){\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b) dat[k] += x;\n    else{\n      query(a, b, x, k*2+1, l, (l+r)/2);\n      query(a, b, x, k*2+2, (l+r)/2, r);\n    }\n  }\n};\n\nSEG seg;\nint N,Q;\n\n\nvoid calc(int a,int b){\n  //  cout << \"calc : \" << a << \" \" << b << endl;\n  ll x = seg.get( a );\n  int st = 0, ed = a;\n  int r = a;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( seg.get(h) == x ) {\n      r = h;\n      ed = h-1;\n    } else\n      st = h+1;    \n  }\n\n  ll inv = a-r+1;\n  if( r == 0 ){\n    seg.query( 0, a+1, b/(a+1) );\n    seg.query( 0, b%(a+1), 1 );\n  } else {\n    ll y = seg.get( r-1 );\n    if( b > (y-x) * inv ){\n      seg.query( r, a+1, (y-x) );\n      calc(a, b-(y-x)*inv);\n    } else {\n      seg.query( r, a+1, b / inv );\n      seg.query( r, r + b % inv, 1 );      \n    }\n  }\n}\n\nint main(){\n  cin >> N >> Q;\n  for(int i=0;i<Q;i++){\n    int a,b; cin >> a >> b; --a;\n    calc( a, b );\n  }\n  for(int i=0;i<N;i++){\n    cout << seg.get(i) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 16; }\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\ntemplate <typename Base>\nclass LazySeg\n{\n    static std::size_t SZ(const std::size_t n)\n    {\n        std::size_t ans = 1;\n        for (; ans < n; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using BaseAlgebra = Base;\n    using ValMonoid = typename BaseAlgebra::ValMonoid;\n    using OpMonoid = typename BaseAlgebra::OpMonoid;\n    using T = typename BaseAlgebra::VT;\n    using F = typename BaseAlgebra::OT;\n    LazySeg(const std::size_t n) : size(n), half(SZ(n)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id()) {}\n    template <typename InIt>\n    LazySeg(const InIt first, const InIt last) : size(std::distance(first, last)), half(SZ(size)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id())\n    {\n        copy(first, last, value.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    T get(const std::size_t a) const { return accumulate(a, a + 1); }\n    void set(std::size_t a, const T& val)\n    {\n        modify(a, a + 1, OpMonoid::id()), value[a += half] = val;\n        while (a >>= 1) { up(a); }\n    }\n    T accumulate(const std::size_t L, const std::size_t R) const\n    {\n        auto arec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> T {\n            if (L <= left and right <= R) {\n                return value[index];\n            } else if (right <= L or R <= left) {\n                return ValMonoid::id();\n            } else {\n                return act(action[index], acc(self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right)));\n            }\n        };\n        return arec(arec, 1, 0, half);\n    }\n    void modify(const std::size_t L, const std::size_t R, const F& f)\n    {\n        auto mrec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> void {\n            if (L <= left and right <= R) {\n                this->update(index, f);\n            } else if (right <= L or R <= left) {\n            } else {\n                this->update(index << 1, action[index]), this->update(index << 1 | 1, action[index]);\n                self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right);\n                this->up(index), action[index] = OpMonoid::id();\n            }\n        };\n        mrec(mrec, 1, 0, half);\n    }\n    template <typename Pred>\n    std::size_t partitionPoint(const std::size_t L, const std::size_t R, const Pred& pred) const\n    {\n        auto prec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right, const T& offset) -> std::pair<T, std::size_t> {\n            if (right <= L or R <= left or pred(acc(offset, act(action[index], value[index])))) { return {ValMonoid::id(), R}; }\n            if (index >= half) { return {act(action[index], value[index]), index - half}; }\n            const std::pair<T, std::size_t> lans = self(self, index << 1, left, (left + right) >> 1, offset);\n            if (lans.second != R) { return lans; }\n            return self(self, index << 1 | 1, (left + right) >> 1, right, acc(offset, lans.first));\n        };\n        return prec(prec, 1, 0, half, ValMonoid::id()).second;\n    }\n\n    std::vector<T> data() const\n    {\n        std::vector<T> ans(size);\n        for (std::size_t i = 0; i < size; i++) { ans[i] = get(i); }\n        return ans;\n    }\n\nprivate:\n    void up(const std::size_t i) { value[i] = acc(value[i << 1], value[i << 1 | 1]); }\n    void update(const std::size_t i, const F& f) { value[i] = act(f, value[i]), action[i] = compose(f, action[i]); }\n    const std::size_t size, half;\n    std::vector<T> value;\n    std::vector<F> action;\n    const ValMonoid acc{};\n    const OpMonoid compose{};\n    const BaseAlgebra act{};\n};\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const LazySeg<T>& seg)\n{\n    os << \"[\";\n    for (const auto& e : seg.data()) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename VX = ll, typename OX = ll>\nstruct MAct\n{\n    struct VT\n    {\n        VX max;\n        VX sum;\n        std::size_t L, R;\n    };\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return VT{std::max(a.max, b.max), a.sum + b.sum, std::min(a.L, b.L), std::max(a.R, b.R)}; }\n        static constexpr VT id() { return {-INF<VX>(), (VX)0, INF<std::size_t>(), 0UL}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<OT>() ? VT{f, f * VX(x.R - x.L), x.L, x.R} : x; }\n};\nint main()\n{\n    std::size_t N, Q;\n    std::cin >> N >> Q;\n    LazySeg<MAct<ll, ll>> seg(N);\n    using VT = typename MAct<ll, ll>::VT;\n    for (std::size_t i = 0; i < N; i++) { seg.set(i, {0, 0, i, i + 1}); }\n    for (std::size_t q = 0; q < Q; q++) {\n        std::size_t A;\n        ll B;\n        std::cin >> A >> B;\n        auto pred = [&](const VT& v) {\n            const std::size_t l = v.L, r = v.R;\n            const ll H = v.max, res = H * (r - N + A) - v.sum;\n            return res < B;\n        };\n        const std::size_t p = seg.partitionPoint(N - A, N, pred);\n        const ll rect = seg.accumulate(N - A, p).sum + B, H = rect / (p - N + A), mod = rect % (p - N + A);\n        seg.modify(N - A, p, H);\n        if (mod != 0) { seg.modify(p - mod, p, H + 1); }\n    }\n    for (std::size_t i = 0; i < N; i++) { std::cout << seg.get(N - i - 1).max << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint s[100000];\nint n,q,a,b;\nint BNS(int key,int right){\n\tint left=0,mid;\n\tint ret=right-1;\n\twhile(true){\n\t\tif(left>=right-1)break;\n\t\tmid=(left+right)/2;\n\t\tif(s[mid]<=key){\n\t\t\tret=min(ret,mid);\n\t\t\tright=mid;\n\t\t}\n\t\telse left=mid;\n\t}\n\tif(ret<0)if(s[ret-1]==key)ret--;\n\treturn ret;\n}\nint main(){\n\tcin>>n>>q;\n\tfor(int i=0;i<n;i++)s[i]=0;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>a>>b;\n\t\tif(b!=1)return 0;\n\t\ta--;\n\t\ts[BNS(s[a],a+1)]++;\n\t}\n\tfor(int i=0;i<n;i++)cout<<s[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <limits>\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 4; }\ntemplate <typename Base>\nclass LazySeg\n{\n    static std::size_t SZ(const std::size_t n)\n    {\n        std::size_t ans = 1;\n        for (; ans < n; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using BaseAlgebra = Base;\n    using ValMonoid = typename BaseAlgebra::ValMonoid;\n    using OpMonoid = typename BaseAlgebra::OpMonoid;\n    using T = typename BaseAlgebra::VT;\n    using F = typename BaseAlgebra::OT;\n    LazySeg(const std::size_t n) : size(n), half(SZ(n)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id()) {}\n    template <typename InIt>\n    LazySeg(const InIt first, const InIt last) : size(std::distance(first, last)), half(SZ(size)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id())\n    {\n        copy(first, last, value.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    T get(const std::size_t a) const { return accumulate(a, a + 1); }\n    void set(std::size_t a, const T& val)\n    {\n        modify(a, a + 1, OpMonoid::id()), value[a += half] = val;\n        while (a >>= 1) { up(a); }\n    }\n    T accumulate(const std::size_t L, const std::size_t R) const\n    {\n        auto arec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> T {\n            if (L <= left and right <= R) {\n                return value[index];\n            } else if (right <= L or R <= left) {\n                return ValMonoid::id();\n            } else {\n                return act(action[index], acc(self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right)));\n            }\n        };\n        return arec(arec, 1, 0, half);\n    }\n    void modify(const std::size_t L, const std::size_t R, const F& f)\n    {\n        auto mrec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> void {\n            if (L <= left and right <= R) {\n                this->update(index, f);\n            } else if (right <= L or R <= left) {\n            } else {\n                this->update(index << 1, action[index]), this->update(index << 1 | 1, action[index]);\n                self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right);\n                this->up(index), action[index] = OpMonoid::id();\n            }\n        };\n        mrec(mrec, 1, 0, half);\n    }\n    std::vector<T> data() const\n    {\n        std::vector<T> ans(size);\n        for (std::size_t i = 0; i < size; i++) { ans[i] = get(i); }\n        return ans;\n    }\n\nprivate:\n    void up(const std::size_t i) { value[i] = acc(value[i << 1], value[i << 1 | 1]); }\n    void update(const std::size_t i, const F& f) { value[i] = act(f, value[i]), action[i] = compose(f, action[i]); }\n    const std::size_t size, half;\n    std::vector<T> value;\n    std::vector<F> action;\n    const ValMonoid acc{};\n    const OpMonoid compose{};\n    const BaseAlgebra act{};\n};\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const LazySeg<T>& seg)\n{\n    os << \"[\";\n    for (const auto& e : seg.data()) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename VX = ll, typename OX = ll>\nstruct Max_Set\n{\n    using VT = VX;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return std::max(a, b); }\n        static constexpr VT id() { return -INF<VT>(); }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<VT>() ? f : x; }\n};\n\ntemplate <typename VX = ll, typename OX = ll>\nstruct Max_Plus\n{\n    using VT = VX;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return std::max(a, b); }\n        static constexpr VT id() { return -INF<VT>(); }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& a, const OT& b) const { return a + b; }\n        static constexpr OT id() { return 0; }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f + x; }\n};\ntemplate <typename VX = ll, typename OX = ll>\nstruct Sum_Plus\n{\n    using VT = std::pair<VX, VX>;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return {a.first + b.first, a.second + b.second}; }\n        static constexpr VT id() { return {0, 0}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 + f2; }\n        static constexpr OT id() { return 0; }\n    };\n    VT operator()(const OT& f, const VT& x) const { return {x.first + x.second * f, x.second}; }\n};\ntemplate <typename VX = ll, typename OX = ll>\nstruct Sum_Set\n{\n    using VT = std::pair<VX, VX>;\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return {a.first + b.first, a.second + b.second}; }\n        static constexpr VT id() { return {0, 0}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<VX>() ? VT{x.second * f, x.second} : x; }\n};\nint main()\n{\n    int N, Q;\n    std::cin >> N >> Q;\n    LazySeg<Max_Set<ll>> seg(N);\n    LazySeg<Sum_Set<ll>> seg2(N);\n    for (int i = 0; i < N; i++) { seg.set(i, 0); }\n    for (int i = 0; i < N; i++) { seg2.set(i, {0, 1}); }\n    for (int q = 0; q < Q; q++) {\n        int A;\n        ll B;\n        std::cin >> A >> B;\n        ll inf = 0, sup = 20000000000001LL;\n        while (sup - inf > 1) {\n            const ll mid = (inf + sup) / 2;\n            int iinf = -1, isup = A;\n            while (isup - iinf > 1) {\n                const std::size_t imid = (isup + iinf) / 2;\n                (seg.accumulate(imid, A) < mid ? isup : iinf) = imid;\n            }\n            const ll use = (A - isup) * mid - seg2.accumulate(isup, A).first;\n            (use <= B ? inf : sup) = mid;\n        }\n        int iinf = -1, isup = A;\n        while (isup - iinf > 1) {\n            const std::size_t imid = (isup + iinf) / 2;\n            (seg.accumulate(imid, A) < inf ? isup : iinf) = imid;\n        }\n        const ll use = (A - isup) * inf - seg2.accumulate(isup, A).first;\n        B -= use;\n        seg.modify(isup, A, inf), seg2.modify(isup, A, inf);\n        const ll newh = sup;\n        iinf = -1, isup = A;\n        while (isup - iinf > 1) {\n            const std::size_t imid = (isup + iinf) / 2;\n            (seg.accumulate(imid, A) < newh ? isup : iinf) = imid;\n        }\n        seg.modify(isup, isup + B, newh), seg2.modify(isup, isup + B, newh);\n    }\n    for (int i = 0; i < N; i++) { std::cout << seg.get(i) << std::endl; }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define int long long\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline ll in() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(int n) {\n    short res[10], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nsigned main()\n{\n    int n = in(), q = in();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            st.erase(it2);\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                st.insert(p), h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                st.insert(p), h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                st.erase(it2);\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        st.insert(p), h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            st.insert(p), h[p] += x+1;\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                st.erase(it2);\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    st.insert(p), h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    st.insert(p), h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int M=(int)1e5+5;\nconst long long INF=(long long)1e17+7;\ntemplate<class T>void Rd(T &res){\n\tres=0;static char p;\n\twhile(p=getchar(),p<'0');\n\tdo{\n\t\tres=(res*10)+(p^48);\n\t}while(p=getchar(),p>='0');\n}\ntemplate<class T>void Ps(T x){\n\tstatic int stk[65],sz;sz=0;\n\twhile(x)stk[sz++]=x%10,x/=10;\n\tif(sz==0)stk[sz++]=0;\n\twhile(sz--)putchar(stk[sz]^48);\n}\nint n,q;\nstruct W{\n\tint l,r;\n\tlong long v;\n\tbool operator <(const W &a)const{\n\t\tif(r!=a.r)return r<a.r;\n\t\tif(l!=a.l)return l<a.l;\n\t\treturn v<a.v;\n\t}\n}A,B;\nset<W>st;\nset<W>::iterator it,it1;\nint main(){\n\tRd(n),Rd(q);\n\tlong long x,y,ned;\n\tst.insert((W){0,0,INF});\n\tst.insert((W){1,n,0});\n\tfor(int i=1;i<=q;i++){\n\t\tRd(x),Rd(y);\n\t\twhile(y){\n\t\t\tit=st.lower_bound((W){0,(int)x,0ll});\n\t\t\tA=(*it);\n\t\t\tst.erase(it);\n\t\t\tif(A.r>x)st.insert((W){(int)x+1,A.r,A.v}),A.r=x;\n\t\t\tit1=st.lower_bound((W){-1,A.l-1,0ll});\n\t\t\tB=(*it1);\n\t\t\tned=(A.r-A.l+1)*(B.v-A.v);\n\t\t\tif(ned<=y){\n\t\t\t\tst.erase(it1);\n\t\t\t\tB.r=A.r;\n\t\t\t\tst.insert(B);\n\t\t\t\ty-=ned;\n\t\t\t}else {\n\t\t\t\tned=A.r-A.l+1;\n\t\t\t\tif(y%ned==0){\n\t\t\t\t\tA.v+=y/ned;\n\t\t\t\t\tst.insert(A);\n\t\t\t\t}else {\n\t\t\t\t\tB.l=A.l,B.r=B.l+y%ned-1,B.v=A.v+y/ned+1;\n\t\t\t\t\tst.insert(B);\n\t\t\t\t\tA.l=B.r+1,A.v=B.v-1;\n\t\t\t\t\tst.insert(A);\n\t\t\t\t}\n\t\t\t\ty=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(it=++st.begin(),it1=st.end();it!=it1;it++)\n\t\tfor(int j=(*it).l;j<=(*it).r;j++)\n\t\t\tPs((*it).v),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 100;\n\nvoid enter()\n{\n    freopen(\"solve.inp\",\"r\",stdin);\n    freopen(\"solve.out\",\"w\",stdout);\n}\nconst long long oo = 1e18;\nlong long IT[N * 4];\nlong long lazy[N * 4];\n\nvoid cn(int i, int L, int R) {\n    if (lazy[i] == 0) return;\n    IT[i] = 1LL * (R - L + 1) * lazy[i];\n    if (L != R) {\n        lazy[i << 1] = lazy[i];\n        lazy[i << 1 | 1] = lazy[i];\n    }\n    lazy[i] = 0;\n}\nvoid update(int i, int L, int R, int u, int v, long long val) { ///a[u -> v] = val\n    cn(i, L, R);\n    if (L > v || R < u) return;\n    if (L >= u && R <= v) {\n        lazy[i] = val;\n        cn(i, L, R);\n        return;\n    }\n    int mid = (L + R) >> 1;\n    update(i << 1, L, mid, u, v, val);\n    update(i << 1 | 1, mid + 1, R, u, v, val);\n    IT[i] = IT[i << 1] + IT[i << 1 | 1];\n}\nlong long Get(int i, int L, int R, int u, int v) {\n    cn(i, L, R);\n    if (L > v || R < u) return 0;\n    if (L >= u && R <= v) return IT[i];\n    int mid = (L + R) >> 1;\n    long long Left = Get(i << 1, L, mid, u, v);\n    long long Right = Get(i << 1 | 1, mid + 1, R, u, v);\n    return Left + Right;\n}\nvoid solve()\n{\n    int n, Q;\n    cin >> n >> Q;\n    while (Q--) {\n        int r;\n      \tlong long Pi;\n        cin >> r >> Pi;\n        int L = 1;\n        int R = r;\n        int H = r;\n        while (L <= R) {\n            int mid = (L + R) >> 1;\n            long long KC = Get(1, 1, n, mid, r);\n            long long Cao = Get(1, 1, n, mid, mid);\n            if ((Cao * (r - mid + 1) - KC) <= Pi) {\n                R = mid - 1;\n                H = mid;\n            }\n            else L = mid + 1;\n        }\n        long long Cao = Get(1, 1, n, H, H);\n        long long SL = Get(1, 1, n, H, r);\n        Pi -= Cao * (r - H + 1) - SL;\n        long long newH = Cao + (Pi / (r - H + 1));\n        long long Thua = Pi % (r - H + 1);\n        update(1, 1, n, H, r, newH);\n        update(1, 1, n, H, H + Thua - 1, newH + 1);\n        //cout << Get(1, 1, n, 2, 2).sum << '\\n';\n//        for (int i = 1; i <= n; i++) cout << Get(1, 1, n, i, i).sum << ' ';\n//        cout << '\\n';\n    }\n    for (int i = 1; i <= n; i++) cout << Get(1, 1, n, i, i) << '\\n';\n}\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(nullptr); cout.tie(nullptr);\n    //enter();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nclass RMQ{\npublic:\n  int n;\n  P dat[555555];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    rep(i,2*n) dat[i]=P(MAX,i);\n  }\n  void update(int k,int a){\n    k+=n-1;dat[k].F=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  P query(int a,int b){return query(a,b,0,0,n);}\n  P query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return P(MAX,MAX);\n    if(a<=l&&r<=b) return dat[k];\n    P vl=query(a,b,k*2+1,l,(l+r)/2);\n    P vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\nvoid Main() {\n  int n,m;\n  cin >> n >> m;\n  RMQ r;\n  r.init(n);\n  int k=r.n-1;\n  rep(i,n) r.update(i,0);\n  while(m--) {\n    int x,y;\n    cin >> x >> y;\n    P p=r.query(0,x);\n    r.update(p.S-k,p.F+1);\n  }\n  rep(i,n) pr(r.dat[i+k].F);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing int64 = long long;\n\nclass segment_tree\n{\nprivate:\n\tstd::vector<pair<int64,int>>treedat;\n\tint treesiz;\n\tpair<int64,int> inf;\n\tpair<int64,int> rawqry(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l && r <= b)return treedat[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(rawqry(a, b, k * 2 + 1, l, m), rawqry(a, b, k * 2 + 2, m, r));\n\t}\npublic:\n\tvoid update(int k, pair<int64,int> a)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tvoid update_inc(int k)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k].first++;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tint64 peek(int k)\n\t{\n\t\treturn treedat[k + treesiz - 1].first;\n\t}\n\tpair<int64, int> query(int a, int b) { return rawqry(a, b, 0, 0, treesiz); }\n\tsegment_tree(int n)\n\t{\n\t\tinf = make_pair((int64)LLONG_MAX - (int64)INT_MAX, n);\n\t\ttreesiz = 1;\n\t\twhile (treesiz < n)treesiz *= 2;\n\t\ttreedat.resize(2 * treesiz + 1);\n\t\tstd::fill(treedat.begin(), treedat.end(), inf);\n\t}\n};\n\nint n, q;\n\nsegment_tree *rmq;\n\nint main(void)\n{\n\tscanf(\"%lld %lld\", &n, &q);\n\trmq = new segment_tree(n);\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\trmq->update(j, make_pair((long long)0, j));\n\t}\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tif (b != 1)return -1;\n\t\tauto ret = rmq->query(0, a);\n\t\trmq->update_inc(ret.second);\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tint64 ans = rmq->peek(j);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst ll INF=3e13;\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,q;\n  cin>>n>>q;\n  vector<ll> as(q),bs(q);\n  rep(i,q) cin>>as[i]>>bs[i];\n  map<ll,ll> mp;\n  mp[0]=3e13;\n  mp[1]=0;\n  rep(i,q){\n    ll a=as[i],b=bs[i];\n    //cout<<pii(a,b)<<endl;\n    auto it=mp.upper_bound(a+1); --it;\n    ll orig=it->Y;\n    while(b){\n      //for(auto p:mp) cout<<p;cout<<endl;\n      auto it=mp.upper_bound(a);\n      --it;\n      // if(it->X == 1,0){\n      // \tll ad=b/a, x=b%a;\n      // \tif(x){\n      // \t  mp[0]+=ad+1;\n      // \t  mp[x]=mp[0]-1;\n      // \t}else{\n      // \t  mp[0]+=ad;\n      // \t}\n      // }else{\n      ll v=it->Y;\n      ll len=a-it->X+1;\n      auto ite=it;\n      ll lb=ite->X;\n      //cout<<pll(v,len)<<*ite<<endl;\n      --it;\n      if((it->Y-v)>b/len){\n\tll ad=b/len, x=b%len;\n\t//cout<<ad<<\",\"<<x<<endl;\n\tif(x){\n\t  if(v+b/len+1==it->Y) mp.erase(ite);\n\t  else mp[lb]+=ad+1;\n\t  mp[lb+x]=v+ad;\n\t}else{\n\t  mp[lb]+=ad;\n\t}\n\tbreak;\n      }else{\n\tb-=(it->Y-v)*len;\n\tmp.erase(ite);\n      }\n    }\n    it=mp.upper_bound(a+1);\n    --it;\n    if(it->Y!=orig) mp[a+1]=orig;\n    //for(auto p:mp) cout<<p;cout<<endl;\n  }\n  ll re=0;\n  reps(i,1,n+1){\n    if(mp.count(i)) re=mp[i];\n    cout<<re<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <map>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n, q, ans;\nLL num[100001];\nstd::map<LL, LL> m; // pos, num\n\nvoid ins(LL x, LL y) {\n\tauto result = m.insert(std::make_pair(x, y));\n\tif( ! result.second) {\n\t\tresult.first -> second = y;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\t\n\tm.insert(std::make_pair(-1, 20000000000001LL));\n\tm.insert(std::make_pair(n, 0));\n\tinc(t, q) {\n\t\tint a;\n\t\tLL b;\n\t\tscanf(\"%d%lld\", &a, &b);\n\t\t\n\t\tint ccc = 0;\n\t\twhile(b > 0) {\n\t\t\tauto it2 = m.lower_bound(a - 1); \n\t\t\tauto it = it2; it--;\n\t\t\tLL x = (it -> first);\n\t\t\tLL y = (it -> second);\n\t\t\tLL ny = (it2 -> second);\n\t\t\tLL d = a - 1 - x;\n\t\t\tLL s = d * (y - ny);\n\t\t\t\n\t\t\tif(b > s) {\n\t\t\t\tm.erase(x);\n\t\t\t\tins(a - 1, y);\n\t\t\t} else {\n\t\t\t\tif(b > s - d) { m.erase(x); } ins((b - 1) % d + 1 + x, (b - 1) / d + 1 + ny);\n\t\t\t\tif(b > d && b % d != 0) { ins(a - 1, (b - 1) / d + ny); }\n\t\t\t}\n\t\t\t\n\t\t\tb -= s;\n\t\t}\n\t}\n\t\n\tauto it = m.begin();\n\tinc(i, n) {\n\t\twhile(i > (it -> first)) { it++; }\n\t\tprintf(\"%lld\\n\", it -> second);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass SegmentTree\n{\nprivate:\n    int n;\n    vector<long long> data;\n    vector<long long> mulDelay;\n    vector<long long> addDelay;\n    void updateTree(int a, int b, int k, int l, int r, long long mulNum, long long addNum){\n        if(a <= l && r <= b){\n            data[k] *= mulNum;\n            data[k] += addNum * (r - l + 1);\n            mulDelay[k] *= mulNum;\n            addDelay[k] *= mulNum;\n            addDelay[k] += addNum;\n        }\n        else if(a <= r && l <= b){\n            for(int i=0; i<2; ++i){\n                data[k*2+1+i] *= mulDelay[k];\n                data[k*2+1+i] += addDelay[k] * (r - l + 1) / 2;\n                mulDelay[k*2+1+i] *= mulDelay[k];\n                addDelay[k*2+1+i] *= mulDelay[k];\n                addDelay[k*2+1+i] += addDelay[k];\n            }\n            mulDelay[k] = 1;\n            addDelay[k] = 0;\n            updateTree(a, b, k*2+1, l, (l+r)/2, mulNum, addNum);\n            updateTree(a, b, k*2+2, (l+r+1)/2, r, mulNum, addNum);\n            data[k] = data[k*2+1] + data[k*2+2];\n        }\n    }\n    long long getValue(int a, int b, int k, int l, int r){\n        long long ret = 0;\n        if(a <= l && r <= b){\n            return data[k];\n        }else if(a <= r && l <= b){\n            ret += getValue(a, b, k*2+1, l, (l+r)/2);\n            ret += getValue(a, b, k*2+2, (l+r+1)/2, r);\n        }\n        return ret;\n    }\npublic:\n    SegmentTree(int n0){\n        n = 1;\n        while(n < n0)\n            n *= 2;\n        data.assign(2*n-1, 0);\n        mulDelay.assign(2*n-1, 1);\n        addDelay.assign(2*n-1, 0);\n    }\n    void set(int a, int b, long long x){ // 区間[a,b]の要素をxにする\n        updateTree(a, b, 0, 0, n-1, 0, x);\n    }\n    void add(int a, int b, long long x){ // 区間[a,b]の要素にxを加算\n        updateTree(a, b, 0, 0, n-1, 1, x);\n    }\n    void mul(int a, int b, long long x){ // 区間[a,b]の要素にxを乗算\n        updateTree(a, b, 0, 0, n-1, x, 0);\n    }\n    long long get(int a, int b){         // 区間[a,b]の総和を返す\n        updateTree(a, b, 0, 0, n-1, 1, 0);\n        return getValue(a, b, 0, 0, n-1);\n    }\n};\n\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n\n    SegmentTree st(n);\n    while(--q >= 0){\n        int a;\n        long long b;\n        cin >> a >> b;\n        -- a;\n\n        int left = 0;\n        int right = a;\n        while(left < right){\n            int x = (left + right + 1) / 2;\n            int w = a - x + 1;\n            long long h = st.get(x-1, x-1);\n            long long add = h * w - st.get(x, a);\n            if(b <= add)\n                left = x;\n            else\n                right = x - 1;\n        }\n\n        int x = left;\n        int w = a - x + 1;\n        b += st.get(x, a);\n        st.set(x, a, b / w);\n        if(b % w != 0)\n            st.add(x, x + b % w - 1, 1);\n    }\n\n    for(int i=0; i<n; ++i)\n        cout << st.get(i, i) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sum(x,y) que(1,1,n,x,y)\n#define change(x,y,z) chan(1,1,n,x,y,z)\n#define add(x,y,z) Plus(1,1,n,x,y,z)\n#define mid (l+r>>1)\nusing namespace std;\nint sum[400000],fg[400000],ad[400000];\nint n,m,a,b; \nvoid down(int now,int l,int r)\n{\n\tif(fg[now])\n\t{\n\t\tfg[now]+=ad[now];\n\t\tfg[now<<1]=fg[now];\n\t\tfg[now<<1|1]=fg[now];\n\t\tad[now]=ad[now<<1]=ad[now<<1|1]=fg[now]=0;\n\t\tsum[now<<1]=fg[now<<1]*(mid-l+1);\n\t\tsum[now<<1|1]=fg[now<<1|1]*(r-mid);\n\t}\n\tif(ad[now])\n\t{\n\t\tad[now<<1]+=ad[now];\n\t\tad[now<<1|1]+=ad[now];\n\t\tsum[now<<1]+=ad[now]*(mid-l+1);\n\t\tsum[now<<1|1]+=ad[now]*(r-mid);\n\t\tad[now]=0; \n\t}\n}\nvoid updata(int now)\n{\n\tsum[now]=sum[now<<1]+sum[now<<1|1];\n}\nvoid chan(int now,int l,int r,int x,int y,int z)\n{\n\tif(l==x && r==y)\n\t{\n\t\tfg[now]=z;\n\t\tad[now]=0;\n\t\tsum[now]=z*(r-l+1);\n\t\treturn;\n\t}\n\tdown(now,l,r);\n\tif(x<=mid)\n\t\tchan(now<<1,l,mid,x,min(mid,y),z);\n\tif(y>mid)\n\t\tchan(now<<1|1,mid+1,r,max(mid+1,x),y,z);\n\tupdata(now);\n}\nvoid Plus(int now,int l,int r,int x,int y,int z)\n{\n\tif(l==x && r==y)\n\t{\n\t\tad[now]+=z;\n\t\tsum[now]+=z*(r-l+1);\n\t\treturn;\n\t}\n\tdown(now,l,r);\n\tif(x<=mid)\n\t\tPlus(now<<1,l,mid,x,min(mid,y),z);\n\tif(y>mid)\n\t\tPlus(now<<1|1,mid+1,r,max(mid+1,x),y,z);\n\tupdata(now);\n}\nint que(int now,int l,int r,int x,int y)\n{\n\tif(l==x && r==y)\n\t\treturn sum[now];\n\tdown(now,l,r);\n\tint ret=0;\n\tif(x<=mid)\n\t\tret+=que(now<<1,l,mid,x,min(y,mid));\n\tif(y>mid)\n\t\tret+=que(now<<1|1,mid+1,r,max(x,mid+1),y);\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tint l=1,r=a;\n\t\tfor(;l<r;)\n\t\t\tif(sum(mid,mid)*(a-mid+1)-sum(mid,a)<=b)\n\t\t\t\tr=mid;\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\tb-=sum(l,l)*(a-l+1)-sum(l,a);\n\t\tchange(l,a,sum(l,l));\n\t\tadd(l,a,b/(a-l+1));\n\t\tif(b%(a-l+1))\n\t\tadd(l,l+b%(a-l+1)-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d\\n\",sum(i,i));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\n/* LazyPropagationSegmentTree(Sum) */\n//0-index\n\nstruct LazySeg_sum{\n  typedef ll Type;\n  \n  struct Data{\n    Type val;\n    Type add;\n    Type sum;\n    bool valset;\n    \n    Type calc_sum(int l, int r){\n      if(valset){\n        return (val + add) * (r - l + 1);\n      }else{\n        return sum + add * (r - l + 1);\n      }\n    }\n\n    void set_data(Type x,Type y){\n      val = x;\n      add = y;\n      valset = true;\n    }\n\n    void add_data(int x){\n      add += x;\n    }\n    \n    Data():val(0),add(0),sum(0),valset(false){}\n    \n  };\n\n  vector<Data> data;\n  int seg_size;\n  \n  LazySeg_sum(int n){\n    for(seg_size=1; seg_size < n; seg_size*=2);\n    data.assign(seg_size*2, Data());\n  }\n\n  Type set(int a, int b, Type x, int l=0, int r=-1,int k=0){\n    if(r == -1) r = seg_size-1;\n    \n    if(a <= l && r <= b){\n      data[k].set_data(x,0);\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n    \n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val+data[k].add,0);\n      data[k*2+2].set_data(data[k].val+data[k].add,0);\n    }else{\n      data[k*2+1].add_data(data[k].add);\n      data[k*2+2].add_data(data[k].add);      \n    }\n\n    data[k].add = 0;\n    \n    data[k].valset = false;\n    \n    data[k].sum = set(a,b,x,l,(l+r)/2,k*2+1) + set(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n\n  Type add(int a, int b, Type x, int l=0, int r=-1, int k=0){\n    if(r == -1) r = seg_size-1;\n\n    if(a <= l && r <= b){\n      data[k].add += x;\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n\n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val, data[k].add);\n      data[k*2+2].set_data(data[k].val, data[k].add);\n      data[k].add = 0;\n      data[k].valset = false;\n    }\n\n    data[k].sum = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n  \n  Type query(int a, int b, int l=0, int r=-1, int k = 0){\n    if(r == -1) r = seg_size-1;\n\n    if(r < a || b < l) return 0;\n\n    if((a <= l && r <= b) || data[k].valset){\n      return data[k].calc_sum(max(a,l),min(b,r));\n    }\n\n    return query(a,b,l,(l+r)/2,k*2+1) + query(a,b,(l+r)/2+1,r,k*2+2) +\n           data[k].add * (min(b,r) - max(a,l) + 1);\n  }\n  \n};\n\n\nint main(){\n  int n,q,a,b;\n\n  scanf(\"%d%d\",&n,&q);\n\n  LazySeg_sum seg(n);\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n\n    if(a == 0){\n      seg.add(0,0,b);\n      continue;\n    } \n    \n    int l=1,r=a,mid;\n    ll u,p;\n    \n    while(l < r){\n\n      mid = (l+r)/2;\n\n      u = seg.query(mid-1,mid-1);\n      \n      p = seg.query(mid,a);\n\n      if((u * (a-mid+1) - p) > b){\n        l = mid+1;\n      }else{\n        r = mid;\n      }\n    }\n    \n    p = seg.query(l,a);\n    u = seg.query(l-1,l-1);\n\n    while( b < u*(a-l+1) - p ) u--;\n    \n    b -= u*(a-l+1) - p;\n    seg.set(l,a,u);\n    \n    seg.add(l-1,a,b/(a-(l-1)+1));\n    b%=(a-(l-1)+1);\n    \n    if(b > 0)\n      seg.add(l-1,b-1+(l-1),1);\n  }\n  \n  for(int i=0;i<n;i++){\n    printf(\"%lld\\n\",seg.query(i,i));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define NN 100400\nlong long oo;\nstruct node{\n\tlong long l,r;\n\tlong long max,min;\n\tlong long sum;\n\tlong long fg;\n}tree[NN*4];\nlong long n,q;\nvoid Init(long long l,long long r,long long idd){\n\ttree[idd].l=l;\n\ttree[idd].r=r;\n\ttree[idd].max=tree[idd].min=0;\n\ttree[idd].sum=0;\n\ttree[idd].fg=0;\n\tif(r-l<=1) return ;\n\tlong long mid=(l+r)/2;\n\tInit(l,mid,idd<<1);\n\tInit(mid,r,idd<<1|1);\n}\nvoid Up(long long idd){\n\ttree[idd].sum=tree[idd<<1].sum+tree[idd<<1|1].sum;\n\ttree[idd].max=max(tree[idd<<1].max,tree[idd<<1|1].max);\n\ttree[idd].min=min(tree[idd<<1].min,tree[idd<<1|1].min);\n}\nvoid Down(long long idd){\n\tif(tree[idd].fg){\t\t\n\t\ttree[idd<<1].fg=tree[idd<<1|1].fg=1;\n\t\ttree[idd<<1].min=tree[idd<<1|1].min=tree[idd].min;\n\t\ttree[idd<<1].max=tree[idd<<1|1].max=tree[idd].max;\n\t\ttree[idd<<1].sum=tree[idd].min*(tree[idd<<1].r-tree[idd<<1].l);\n\t\ttree[idd<<1|1].sum=tree[idd].min*(tree[idd<<1|1].r-tree[idd<<1|1].l);\n\t\ttree[idd].fg=0;\n\t}\n}\nlong long u;\nlong long bg;\nlong long ssum;\nlong long ftt;\nvoid Date(long long l,long long r,long long rr,long long num,long long pre,long long idd){\n\tlong long ssum=num+tree[idd].sum+ftt;\n\tlong long avg=ssum/(rr-l);\n\tif(ssum-avg*(rr-l)) avg++;\n\tif(avg>pre) return ;\n\tif(u==-1&&tree[idd].max<=avg) u=avg,bg=l;\n\telse if(u>=avg&&tree[idd].max<=avg)u=avg,bg=l;\n//\tprintf(\"~%d %d %d %lld %lld  %lld\\n\",l,r,bg,u,ssum,pre);\n\tif(r-l<=1) return  ;\n\tDown(idd);\n\tlong long mid=(l+r)/2;\n\tif(tree[idd<<1].min*(rr-tree[idd<<1|1].l)>=tree[idd<<1|1].sum+num) Date(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse {\n\t\tftt+=tree[idd<<1|1].sum;\n\t\tDate(l,mid,rr,num,pre,idd<<1);\n\t} \n\tUp(idd);\n}\nvoid Update(long long l,long long r,long long rr,long long num,long long pre,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tDate(l,r,rr,num,pre,idd);\n\t\tftt+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tUpdate(l,r,rr,num,pre,idd<<1);\n\telse if(mid<=l)\n\t\tUpdate(l,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse{\n\t\tUpdate(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\t\tUpdate(l,mid,rr,num,pre,idd<<1);\t\n\t}\n\tUp(idd);\n}\n\nvoid Query(long long l,long long r,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tssum+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tQuery(l,r,idd<<1);\n\telse if(mid<=l)\n\t\tQuery(l,r,idd<<1|1);\n\telse{\n\t\tQuery(l,mid,idd<<1);\n\t\tQuery(mid,r,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid fugai(long long l,long long r,long long shu,long long idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\ttree[idd].max=tree[idd].min=shu;\n\t\ttree[idd].sum=(r-l)*shu;\n\t\ttree[idd].fg=1;\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tfugai(l,r,shu,idd<<1);\n\telse if(mid<=l)\n\t\tfugai(l,r,shu,idd<<1|1);\n\telse{\n\t\tfugai(l,mid,shu,idd<<1);\n\t\tfugai(mid,r,shu,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid Print(long long l,long long r,long long idd){\n\tif(r-l<=1) {\n\t\tprintf(\"%lld\\n\",tree[idd].sum);\n\t\treturn;\n\t}\n\tDown(idd);\n\tlong long mid=(r+l)/2;\n\tPrint(l,mid,idd<<1);\n\tPrint(mid,r,idd<<1|1);\n\tUp(idd);\n}\nint main(){\n\too=1LL*2000000*10000000+10;\n\tscanf(\"%lld%lld\",&n,&q);\n\tInit(1,n+1,1);\n\tfor(long long i=1;i<=q;i++){\n\t\tlong long x;long long y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tu=-1;bg=-1;\n\t\tftt=0;\n\t\tUpdate(1,x+1,x+1,y,oo,1);\n\t\tssum=0;\n\t\tQuery(bg,x+1,1);\n\t\tlong long num=(x+1)-bg;\n\t\tlong long sum=ssum+y;\n\t\tlong long avg=sum/num;\n\t\tlong long a1=sum-avg*num;\n\t\tif(a1){\n\t\t\tfugai(bg,bg+a1,avg+1,1);\n\t\t}\n\t\tfugai(bg+a1,x+1,avg,1);\n\t//\tPrint(1,n+1,1);\n\t\n\t}\n\tPrint(1,n+1,1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<b[i];j++){\n\t\t\tMin(a[i],100000,0);\n\t\t}\n\t}\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%id\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n >> q;\n    //cout << n << \" \" << q << endl;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, 3*TEN(13)));\n    s.insert(P(n-1, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;\n            if (a == pr.first) s.erase(pr);\n            if (d*(pl.second-pr.second) <= b) {\n                s.erase(pl); \n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {                \n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                if (pr.second + (b+d-1)/d == pl.second) {\n                    s.erase(pl);\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100000], d[100000];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\tmemset(res, 0, sizeof(res));\n\tcin >> N >> Q;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n\t\tREP(i, A, 1) {\n\t\t\td[i] = res[i-1] - res[i];\n\t\t}\n\t\tREP(i, A, 1) {\n\t\t\tif (d[A-i] > 0) {\n\t\t\t\tif (d[A-i] * i <= B) {\n\t\t\t\t\tREP(j, i, 0) {\n\t\t\t\t\t\tres[A-j-1] += d[A-i];\n\t\t\t\t\t}\n\t\t\t\t\tB -= d[A-i] * i;\n\t\t\t\t} else {\n\t\t\t\t\tREP(j, i, 0) {\n\t\t\t\t\t\tres[A-j-1] += B/i;\n\t\t\t\t\t}\n\t\t\t\t\tB -= (LL)(B/i) * i;\n\t\t\t\t\tREP(j, B, 0) {\n\t\t\t\t\t\tres[A-i+j]++;\n\t\t\t\t\t\tB--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (B > 0) {\n\t\t\tREP(i, A, 0) {\n\t\t\t\tres[i] += B/A;\n\t\t\t}\n\t\t\tB -= (LL)(B/A) * A;\n\t\t\tREP(i, B, 0) {\n\t\t\t\tres[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, N, 0) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#include<vector>\ntemplate<typename T>\nstruct lazysegtree{\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,T lazydefvalue_=0\n\t):defvalue(defvalue_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=lazy[i]*(r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazy[i];\n\t\t\t\tlazy[2*i+2]=lazy[i];\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=x;\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=dat[2*k+1]+dat[2*k+2];\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return query(a,b,2*k+1,l,(l+r)/2)+query(a,b,2*k+2,(l+r)/2,r);\n\t}\n};\nint N,Q;\nmain()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tlazysegtree<long>P(N);\n\tfor(;Q--;)\n\t{\n\t\tint a;long b;\n\t\tscanf(\"%d%ld\",&a,&b);\n\t\tlong L=0,R=1e14;\n\t\twhile(R-L>1)\n\t\t{\n\t\t\tlong M=L+R>>1;\n\t\t\tint l=-1,r=a;\n\t\t\twhile(r-l>1)\n\t\t\t{\n\t\t\t\tint m=l+r>>1;\n\t\t\t\tif(P.query(m,m+1)>M)l=m;\n\t\t\t\telse r=m;\n\t\t\t}\n\t\t\tif(M*(a-r)-P.query(r,a)>b)R=M;\n\t\t\telse L=M;\n\t\t}\n\t\tint l=-1,r=a;\n\t\twhile(r-l>1)\n\t\t{\n\t\t\tint m=l+r>>1;\n\t\t\tif(P.query(m,m+1)>L)l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tb-=L*(a-r)-P.query(r,a);\n\t\tP.update(r,a,L);\n\t\tP.update(r,r+b,L+1);\n\t}\n\tfor(int i=0;i<N;i++)printf(\"%ld\\n\",P.query(i,i+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a[100001];\nlong long int b[100001];\nlong long int num[100001];\nbool flag[100001];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\twhile (b[i] != 0) {\n\t\t\tif (CheckBefore(a[i])) {\n\t\t\t\tif (num[start]* (a[i] - start + 1)*(-1) <= b[i]) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[a[i] + 1] += num[start];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb[i] += num[start] * (a[i] - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[i] += num[start] * (a[i] - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b[i] % (a[i] - start + 1) == 0) {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[i] % a[i] == 0) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 10;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV << 1];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (mid == a) for(;;);\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tif (a - r + 1 == 0) for(;;);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100006\nusing namespace std;\nlong long n,m,x,y,s[4*N],f[4*N];\ninline long long read()\n{\n\tlong long x=0,c=getchar();while(c<48)c=getchar();\n\twhile(c>47)x=x*10+c-48,c=getchar();return x;\n}\ninline void down(long long i,long long l,long long r)\n{\n\tif(f[i]){\n\t\tif(l!=r)f[i<<1]=f[i<<1|1]=f[i];\n\t\ts[i]=f[i]*(r-l+1);f[i]=0;\n\t}\n}\nvoid cover(long long i,long long l,long long r,long long x,long long y,long long p)\n{\n\tif(x>y)return;down(i,l,r);\n\tif(x<=l&&r<=y){f[i]=p;return;}\n\tlong long mid=(l+r)>>1;\n\tif(x<=mid)cover(i<<1,l,mid,x,y,p);\n\tif(y>mid)cover(i<<1|1,mid+1,r,x,y,p);\n\tdown(i<<1,l,mid);down(i<<1|1,mid+1,r);\n\ts[i]=s[i<<1]+s[i<<1|1];\n}\nlong long query(long long i,long long l,long long r,long long x,long long y)\n{\n\tdown(i,l,r);\n\tif(x<=l&&r<=y)return s[i];\n\tlong long mid=(l+r)>>1,tmp=0;\n\tif(x<=mid)tmp=query(i<<1,l,mid,x,y);\n\tif(y>mid)tmp+=query(i<<1|1,mid+1,r,x,y);\n\treturn tmp; \n}\ninline long long find()\n{\n\tlong long l=1,r=x,ans;\n\twhile(l<=r){\n\t\tlong long mid=(l+r)>>1;\n\t\tif(query(1,1,n,mid,mid)*(x-mid+1)-query(1,1,n,mid,x)<=y)r=mid-1,ans=mid;\n\t\telse l=mid+1;\n\t}\n\ty-=(query(1,1,n,ans,ans)*(x-ans+1)-query(1,1,n,ans,x));\n\treturn ans;\n}\nint main()\n{\n\tn=read();m=read();\n\twhile(m--){\n\t\tx=read();y=read();\n\t\tlong long lmax=find(),cs=y/(x-lmax+1),res=y%(x-lmax+1);\n\t\tlong long t=query(1,1,n,lmax,lmax);\n\t\tcover(1,1,n,lmax,lmax+res-1,t+cs+1);\n\t\tcover(1,1,n,lmax+res,x,t+cs);\n\t}\n\tfor(long long i=1;i<=n;i++)printf(\"%lld\\n\",query(1,1,n,i,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, q;\nint a[100], b[100];\nint num[100] = {0};\n\nint to_cost(int query_id, int val) {\n\tint ret = 0;\n\t\n\tfor (int i = 0; i < a[query_id]; i++) {\n\t\tret += max(0LL, val - num[i]);\n\t}\n\treturn ret;\n}\n\nsigned main() {\n\tint i, j, k;\n\t\n\tcin >> n >> q;\n\tfor (i = 0; i < q; i++) cin >> a[i] >> b[i];\n\t\n\tfor (i = 0; i < q; i++) {\n\t\tint st = 0, ed = 1e+15, mid;\t//oooxxx, [st, ed)\n\t\twhile (ed - st >= 2) {\n\t\t\tmid = (st + ed) / 2;\n\t\t\tif (to_cost(i, mid) <= b[i]) { st = mid; }\n\t\t\telse { ed = mid; }\n\t\t}\n\t\t\n\t\tint rem = b[i] - to_cost(i, st);\n\t\tfor (j = 0; j < a[i]; j++) num[j] = max(st, num[j]);\n\t\t\n\t\t//rem回シミュレーション\n\t\tfor (j = 0; j < rem; j++) {\n\t\t\tint id = 0;\n\t\t\tfor (k = 1; k < a[i]; k++) {\n\t\t\t\tif (num[k] < num[id]) {\n\t\t\t\t\tid = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum[id]++;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tcout << num[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define NN 100400\nlong long oo;\nstruct node{\n\tint l,r;\n\tlong long max,min;\n\tlong long sum;\n\tint fg;\n}tree[NN*4];\nint n,q;\nvoid Init(int l,int r,int idd){\n\ttree[idd].l=l;\n\ttree[idd].r=r;\n\ttree[idd].max=tree[idd].min=0;\n\ttree[idd].sum=0;\n\ttree[idd].fg=0;\n\tif(r-l<=1) return ;\n\tint mid=(l+r)/2;\n\tInit(l,mid,idd<<1);\n\tInit(mid,r,idd<<1|1);\n}\nvoid Up(int idd){\n\ttree[idd].sum=tree[idd<<1].sum+tree[idd<<1|1].sum;\n\ttree[idd].max=max(tree[idd<<1].max,tree[idd<<1|1].max);\n\ttree[idd].min=min(tree[idd<<1].min,tree[idd<<1|1].min);\n}\nvoid Down(int idd){\n\tif(tree[idd].fg){\t\t\n\t\ttree[idd<<1].fg=tree[idd<<1|1].fg=1;\n\t\ttree[idd<<1].min=tree[idd<<1|1].min=tree[idd].min;\n\t\ttree[idd<<1].max=tree[idd<<1|1].max=tree[idd].max;\n\t\ttree[idd<<1].sum=tree[idd].min*(tree[idd<<1].r-tree[idd<<1].l);\n\t\ttree[idd<<1|1].sum=tree[idd].min*(tree[idd<<1|1].r-tree[idd<<1|1].l);\n\t\ttree[idd].fg=0;\n\t}\n}\nlong long u;\nint bg;\nlong long ssum;\nlong long ftt;\nvoid Date(int l,int r,int rr,long long num,long long pre,int idd){\n\tlong long ssum=num+tree[idd].sum+ftt;\n\tlong long avg=ssum/(rr-l);\n\tif(ssum-avg*(rr-l)) avg++;\n\tif(avg>pre) return ;\n\tif(u==-1&&tree[idd].max<=avg) u=avg,bg=l;\n\telse if(u>=avg&&tree[idd].max<=avg)u=avg,bg=l;\n//\tprintf(\"~%d %d %d %lld %lld  %lld\\n\",l,r,bg,u,ssum,pre);\n\tif(r-l<=1) return  ;\n\tDown(idd);\n\tint mid=(l+r)/2;\n\tif(tree[idd<<1].min*(rr-tree[idd<<1|1].l)>=tree[idd<<1|1].sum+num) Date(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse {\n\t\tftt+=tree[idd<<1|1].sum;\n\t\tDate(l,mid,rr,num,pre,idd<<1);\n\t} \n\tUp(idd);\n}\nvoid Update(int l,int r,int rr,long long num,long long pre,int idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tDate(l,r,rr,num,pre,idd);\n\t\tftt+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tint mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tUpdate(l,r,rr,num,pre,idd<<1);\n\telse if(mid<=l)\n\t\tUpdate(l,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\telse{\n\t\tUpdate(mid,r,rr,num,tree[idd<<1].min,idd<<1|1);\n\t\tUpdate(l,mid,rr,num,pre,idd<<1);\t\n\t}\n\tUp(idd);\n}\n\nvoid Query(int l,int r,int idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\tssum+=tree[idd].sum;\n\t\treturn;\n\t}\n\tDown(idd);\n\tint mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tQuery(l,r,idd<<1);\n\telse if(mid<=l)\n\t\tQuery(l,r,idd<<1|1);\n\telse{\n\t\tQuery(l,mid,idd<<1);\n\t\tQuery(mid,r,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid fugai(int l,int r,long long shu,int idd){\n\tif(tree[idd].l==l&&tree[idd].r==r){\n\t\ttree[idd].max=tree[idd].min=shu;\n\t\ttree[idd].sum=(r-l)*shu;\n\t\ttree[idd].fg=1;\n\t\treturn;\n\t}\n\tDown(idd);\n\tint mid=(tree[idd].l+tree[idd].r)/2;\n\tif(mid>=r)\n\t\tfugai(l,r,shu,idd<<1);\n\telse if(mid<=l)\n\t\tfugai(l,r,shu,idd<<1|1);\n\telse{\n\t\tfugai(l,mid,shu,idd<<1);\n\t\tfugai(mid,r,shu,idd<<1|1);\n\t}\n\tUp(idd);\n}\nvoid Print(int l,int r,int idd){\n\tif(r-l<=1) {\n\t\tprintf(\"%lld\\n\",tree[idd].sum);\n\t\treturn;\n\t}\n\tDown(idd);\n\tint mid=(r+l)/2;\n\tPrint(l,mid,idd<<1);\n\tPrint(mid,r,idd<<1|1);\n\tUp(idd);\n}\nint main(){\n\too=1LL*2000000*10000000+10;\n\tscanf(\"%d%d\",&n,&q);\n\tInit(1,n+1,1);\n\tfor(int i=1;i<=q;i++){\n\t\tint x;long long y;\n\t\tscanf(\"%d%lld\",&x,&y);\n\t\tu=-1;bg=-1;\n\t\tftt=0;\n\t\tUpdate(1,x+1,x+1,y,oo,1);\n\t\tssum=0;\n\t\tQuery(bg,x+1,1);\n\t\tint num=(x+1)-bg;\n\t\tlong long sum=ssum+y;\n\t\tlong long avg=sum/num;\n\t\tint a1=sum-avg*num;\n\t\tif(a1){\n\t\t\tfugai(bg,bg+a1,avg+1,1);\n\t\t}\n\t\tfugai(bg+a1,x+1,avg,1);\n\t//\tPrint(1,n+1,1);\n\t\n\t}\n\tPrint(1,n+1,1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,q,a,b;\nlong long e[17][100000];\nint main(){\n\tcin>>n>>q;\n\tfor(int i=0;i<n;i++)for(int j=0;j<17;j++)e[j][i]=0;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>a>>b;\n\t\te[0][a-1]+=b;\n\t}\n\n\tint r=1;//範囲の長さ\n\tint t=1;\n\twhile(true){\n\t\tfor(int i=0;i+r<n;i+=r*2){\n\t\t\tif(e[t-1][i]<e[t-1][i+r])e[t][i]=e[t-1][i]+e[t-1][i+r];\n\t\t\telse e[t][i]=e[t-1][i];\n\t\t}\n\t\tr*=2;\n\t\tif(r>n)break;\n\t\tt++;\n\t}\n\tcout<<e[t][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nstruct Node\n{\n\tlong long lazy;\n\tNode(){}\n}Tree[400001];\n\nint n,q;\nint arr[100001];\n\ntemplate <typename T>\ninline void Read(T& x)\n{\n    bool Neg = false;\n    char c;\n    for (c = getchar(); c < '0' || c > '9'; c = getchar())\n        if (c == '-') Neg = !Neg;\n    x = c - '0';\n    for (c = getchar(); c >= '0' && c <= '9'; c = getchar())\n        x = x * 10 + c - '0';\n    if (Neg) x = -x;\n}\n\ntemplate <typename T>\ninline void Write(T x)\n{\n    if (x < 0)\n    {\n        putchar('-'); x = -x;\n    }\n    T p = 1;\n    for (T temp = x / 10; temp > 0; temp /= 10) p *= 10;\n    for (; p > 0; x %= p, p /= 10) putchar(x / p + '0');\n}\n\nvoid diffuse(int node,int l,int r)\n{\n\tif (l != r)\n\t{\n\t\tTree[node*2].lazy += Tree[node].lazy;\n\t\tTree[node*2 + 1].lazy += Tree[node].lazy;\n\t}\n\telse\n\t\tarr[l] += Tree[node].lazy;\n\tTree[node].lazy = 0;\t\t\t\n}\n\nvoid update(int node,int l,int r,int ll,int rr,int val)\n{\n\tif (r < ll || rr < l)\n\t\treturn;\n\tif (ll <= l && r <= rr)\n\t{\n\t\tTree[node].lazy += val;\n\t\treturn;\n\t}\t\n\tint mi = (l + r) / 2;\n\tupdate(node*2,l,mi,ll,rr,val);\n\tupdate(node*2+1,mi+1,r,ll,rr,val);\n\treturn;\n}\n\nint query(int node,int l,int r,int x)\n{\n\tdiffuse(node,l,r);\n\tif (l == r && l == x)\n\t\treturn arr[l];\t\n\tint mi = (l + r) / 2;\n\tif (x <= mi) return query(node*2,l,mi,x);\n\treturn query(node*2+1,mi+1,r,x);\n}\n\nint32_t main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tRead(n);\n\tRead(q);\n\t//cin >> n >> q;\n\twhile(q--)\n\t{\n\t\tint r;\n\t\tint p;\n\t\tRead(r);\n\t\tRead(p);\n\t\t//cin >> r >> p;\n\t\twhile(p)\n\t\t{\n\t\t\tint pos = r;\n\t\t\tint L = 1, R = r;\n    \t\twhile(L <= R)\n    \t\t{\n    \t\t\tint mi = (L + R) / 2;\n    \t\t\tif (query(1,1,n,mi) == query(1,1,n,r))\n    \t\t\t{\n    \t\t\t\tpos = mi;\n    \t\t\t\tR = mi - 1;\n    \t\t\t}\n    \t\t\telse\n    \t\t\t\tL = mi + 1;\n    \t\t}\n    \t\tif (pos != 1)\n    \t\t{\n    \t\t\tint val_r = query(1,1,n,r);\n    \t\t\tint b = query(1,1,n,pos-1);\n\t\t\t\tint z = (r - pos + 1) * (b - val_r);\n\t\t\t\tif (p <= z)\n\t\t\t\t{\n\t\t\t\t\tint z = (r - pos + 1);\n\t\t\t\t\tint zz = p / z;\n\t\t\t\t\tupdate(1,1,n,pos,r,zz);\n\t\t\t\t\tp -= (zz*z);\n\t\t\t\t\tif (p)\n\t\t\t\t\t\tupdate(1,1,n,pos,pos + p - 1,1);\n\t\t\t\t\tp = 0; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp -= z;\n\t\t\t\t\tupdate(1,1,n,pos,r,b - val_r);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint z = (r - pos + 1);\n\t\t\t\tint zz = p / z;\n\t\t\t\tupdate(1,1,n,1,r,zz);\n\t\t\t\tp -= (zz*z);\n\t\t\t\tif (p)\n\t\t\t\t\tupdate(1,1,n,1,p,1);\n\t\t\t\tp = 0;\n\t\t\t}\t\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tWrite(query(1,1,n,i));\n\t\tputchar('\\n');\n\t\t//cout << query(1,1,n,i) << ' ';\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cstdio>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ninline ll read() {\n    char ch = getchar(); ll x = 0;\n    while(ch < '0' || ch > '9') ch = getchar();\n    while(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n    return x;\n}\n\n\nconst ll INF = 2e13;\nconst int N = 1e5+5;\n\nstruct seg {\n    int l, r;\n    ll v;\n\n    seg() {}\n    seg(int a, int b, ll c): l(a), r(b), v(c) {}\n    bool operator <(const seg &b) const {\n        return l < b.l;\n    }\n};\n\nset <seg> s;\nset <seg>:: iterator it;\nseg del[N], ins[N];\n\nint t1, t2;\nvoid work() {\n    ll y = read(), x = read();\n    it = s.upper_bound(seg(y, 0, 0)), --it;\n    if(y+1 <= it->r) ins[++t1] = (seg(y+1, it->r, it->v));\n    del[++t2] = (*it);\n\n    int nl = it->l, nr = y, nv = it->v;\n    for(--it; 1LL*(nr-nl+1)*(it->v-nv) < x;) {\n        x -= 1LL*(nr-nl+1)*(it->v-nv);\n        del[++t2] = (*it);\n        nl = it->l, nv = it->v, --it;\n    }\n\n    nv += x / (nr-nl+1);\n    x  %= (nr-nl+1), nl = it->r+x+1;\n    if(nl <= nr) ins[++t1] = (seg(nl, nr, nv));\n    if(it->r < nl-1) ins[++t1] = (seg(it->r+1, nl-1, nv+1));\n\n    for(int i = 1; i <= t2; ++i) s.erase(del[i]);\n    for(int i = 1; i <= t1; ++i) s.insert(ins[i]);\n}\n\n\nint n, q;\nint main() {\n    n = read(), q = read();\n\n    s.insert(seg(0, 0, INF));\n    s.insert(seg(1, n, 0));\n\n    while(q--) work();\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n        for(int j = it->l; j <= it->r; ++j)\n            printf(\"%lld\\n\", it->v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing int64 = long long;\n\nclass segment_tree\n{\nprivate:\n\tstd::vector<pair<int64,int>>treedat;\n\tint treesiz;\n\tpair<int64,int> inf;\n\tpair<int64,int> rawqry(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l && r <= b)return treedat[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(rawqry(a, b, k * 2 + 1, l, m), rawqry(a, b, k * 2 + 2, m, r));\n\t}\npublic:\n\tvoid update(int k, pair<int64,int> a)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tvoid update_inc(int k)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k].first++;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tint64 peek(int k)\n\t{\n\t\treturn treedat[k + treesiz - 1].first;\n\t}\n\tpair<int64, int> query(int a, int b) { return rawqry(a, b, 0, 0, treesiz); }\n\tsegment_tree(int n)\n\t{\n\t\tinf = make_pair((int64)LLONG_MAX - (int64)INT_MAX, n);\n\t\ttreesiz = 1;\n\t\twhile (treesiz < n)treesiz *= 2;\n\t\ttreedat.resize(2 * treesiz + 1);\n\t\tstd::fill(treedat.begin(), treedat.end(), inf);\n\t}\n};\n\nint n, q;\n\nsegment_tree *rmq;\n\nint main(void)\n{\n\tscanf(\"%lld %lld\", &n, &q);\n\trmq = new segment_tree(n);\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\trmq->update(j, make_pair((long long)0, j));\n\t}\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\t//if (b != 1)return -1;\n\t\tauto ret = rmq->query(0, a);\n\t\trmq->update_inc(ret.second);\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tint64 ans = rmq->peek(j);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\n/* LazyPropagationSegmentTree(Sum) */\n//0-index\n\nstruct LazySeg_sum{\n  typedef ll Type;\n  \n  struct Data{\n    Type val;\n    Type add;\n    Type sum;\n    bool valset;\n    \n    Type calc_sum(int l, int r){\n      if(valset){\n        return (val + add) * (r - l + 1);\n      }else{\n        return sum + add * (r - l + 1);\n      }\n    }\n\n    void set_data(Type x,Type y){\n      val = x;\n      add = y;\n      valset = true;\n    }\n\n    void add_data(Type x){\n      add += x;\n    }\n    \n    Data():val(0),add(0),sum(0),valset(false){}\n    \n  };\n\n  vector<Data> data;\n  int seg_size;\n  \n  LazySeg_sum(int n){\n    for(seg_size=1; seg_size < n; seg_size*=2);\n    data.assign(seg_size*2, Data());\n  }\n\n  Type set(int a, int b, Type x, int l=0, int r=-1,int k=0){\n    if(r == -1) r = seg_size-1;\n    \n    if(a <= l && r <= b){\n      data[k].set_data(x,0);\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n    \n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val,data[k].add);\n      data[k*2+2].set_data(data[k].val,data[k].add);\n    }else{\n      data[k*2+1].add_data(data[k].add);\n      data[k*2+2].add_data(data[k].add);\n    }\n      \n\n    data[k].add = 0;\n    \n    data[k].valset = false;\n    \n    data[k].sum = set(a,b,x,l,(l+r)/2,k*2+1) + set(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n\n  Type add(int a, int b, Type x, int l=0, int r=-1, int k=0){\n    if(r == -1) r = seg_size-1;\n\n    if(a <= l && r <= b){\n      data[k].add += x;\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n\n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val, data[k].add);\n      data[k*2+2].set_data(data[k].val, data[k].add);\n      data[k].add = 0;\n      data[k].valset = false;\n    }\n\n    data[k].sum = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n  \n  Type query(int a, int b, int l=0, int r=-1, int k = 0){\n    if(r == -1) r = seg_size-1;\n\n    if(r < a || b < l) return 0;\n\n    if((a <= l && r <= b) || data[k].valset){\n      return data[k].calc_sum(max(a,l),min(b,r));\n    }\n\n    return query(a,b,l,(l+r)/2,k*2+1) + query(a,b,(l+r)/2+1,r,k*2+2) +\n           data[k].add * (min(b,r) - max(a,l) + 1);\n  }\n  \n};\n\n\nLazySeg_sum seg(100000);\n\nint main(){\n  int n,q,a;\n  ll b;\n\n  scanf(\"%d%d\",&n,&q);\n\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d%lld\",&a,&b);\n    a--;\n\n    if(a == 0){\n      seg.add(0,0,b);\n      continue;\n    } \n    \n    int l=1,r=a,mid;\n    ll u,p;\n    \n    while(l < r){\n\n      mid = (l+r)/2;\n\n      u = seg.query(mid-1,mid-1);\n      \n      p = seg.query(mid,a);\n\n      if((u * (a-mid+1) - p) > b){\n        l = mid+1;\n      }else{\n        r = mid;\n      }\n    }\n    \n    p = seg.query(l,a);\n    u = seg.query(l-1,l-1);\n\n    u = min((b + p)/(a-l+1),u);\n    \n    b -= u*(a-l+1) - p;\n    \n    seg.set(l,a,u);\n    \n    seg.add(l-1,a,b/(a-(l-1)+1));\n    b%=(a-(l-1)+1);\n    \n    if(b > 0)\n      seg.add(l-1,b-1+(l-1),1);\n  }\n  \n  for(int i=0;i<n;i++){\n    printf(\"%lld\\n\",seg.query(i,i));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//cout<<setprecision(20)\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint LBI(vector<lldo>&ar,lldo in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint UBI(vector<lldo>&ar,lldo in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//寿司を解く\n\tint n,i,j,Q;cin>>n>>Q;\n\tset<pair<int,llint>>hen;\n\then.ins(mp(0,big));\n\then.ins(mp(n,0));\n\twhile(Q--){\n\t\tint a;llint b;cin>>a>>b;\n\t\tllint num=hen.lower_bound(mp(a,-big))->sec;\n\t\twhile(-1){\n\t\t\tauto p=prev(hen.lower_bound(mp(a,big)));\n\t\t\tint ter=p->fir;\n\t\t\tllint sa=p->sec - num;\n\t\t\tif((a-ter)==0 || b/(a-ter)>=sa){\n\t\t\t\tb-=sa*(a-ter);\n\t\t\t\tnum=p->sec;\n\t\t\t\then.erase(p);\n\t\t\t}else{\n\t\t\t\tnum+=b/(a-ter);\n\t\t\t\tb%=a-ter;\n\t\t\t\then.ins(mp(a,num));\n\t\t\t\tif(b>0){hen.ins(mp(ter+b,num+1));}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<llint>ans(n);\n\tfor(auto itr=hen.rbegin();itr!=hen.rend();itr++){\n\t\tif(itr->fir==0){break;}\n\t\tmaxeq(ans[itr->fir -1],itr->sec);\n\t}\n\tfor(i=n-1;i>0;i--){maxeq(ans[i-1],ans[i]);}\n\tfor(i=0;i<n;i++){cout<<ans[i]<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100001];\n\nLL count(int m, int a) {\n\tLL sum = 0;\n\tREP(i, a-m, 0) {\n\t\tsum += (res[a-i-1] - res[a-i]) * (i + 1);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n\tifstream in(\"input.txt\");\n\tcin.rdbuf(in.rdbuf());\n\n\tmemset(res, 0, sizeof(res));\n//\tres[0] = 20000000000000;\n\tcin >> N >> Q;\n//\tN = 10000, Q = 100000;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n//\t\tA = N, B = 1;\n\t\tint l = 0, r = A;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (r + l) / 2;\n//\t\t\tcout << m << \":\" << A << \":\" << count(m, A) << endl;\n\t\t\tif (count(m, A) > B) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tLL p = res[r];\n\t\tREP(i, A + 1, r + 1) {\n\t\t\tif (res[i] != p) {\n\t\t\t\tREP(j, A + 1, i) {\n\t\t\t\t\tB -= (p - res[j]);\n\t\t\t\t\tres[j] = p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp = res[i];\n\t\t\t}\n\t\t}\n//\t\tcout << r << endl;\n\t\tREP(i, A + 1, r) {\n\t\t\tres[i] += B/(A - r + 1);\n\t\t}\n\t\tREP(i, r + B%(A - r + 1), r) {\n\t\t\tres[i]++;\n\t\t}\n//\t\tREP(i, N + 1, 1) cout << res[i];\n//\t\tcout << endl;\n\t}\n\tREP(i, N + 1, 1) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\nconst int M=(int)1e5+5;\nconst long long INF=(long long)1e17+7;\ntemplate<class T>void Rd(T &res){\n\tres=0;static char p;\n\twhile(p=getchar(),p<'0');\n\tdo{\n\t\tres=(res*10)+(p^48);\n\t}while(p=getchar(),p>='0');\n}\ntemplate<class T>void Ps(T x){\n\tstatic int stk[65],sz;sz=0;\n\twhile(x)stk[sz++]=x%10,x/=10;\n\tif(sz==0)stk[sz++]=0;\n\twhile(sz--)putchar(stk[sz]^48);\n}\nint n,q;\nstruct W{\n\tint l,r;\n\tlong long v;\n\tbool operator <(const W &a)const{\n\t\tif(r!=a.r)return r<a.r;\n\t\tif(l!=a.l)return l<a.l;\n\t\treturn v<a.v;\n\t}\n}A,B;\nset<W>st;\nset<W>::iterator it,it1;\nint main(){\n\tRd(n),Rd(q);\n\tlong long x,y,ned;\n\tst.insert((W){0,0,INF});\n\tst.insert((W){1,n,0});\n\tfor(int i=1;i<=q;i++){\n\t\tRd(x),Rd(y);\n\t\twhile(y){\n\t\t\tit=st.lower_bound((W){0,(int)x,0ll});\n\t\t\tA=(*it);\n\t\t\tst.erase(it);\n\t\t\tif(A.r>x)st.insert((W){(int)x+1,A.r,A.v}),A.r=x;\n\t\t\tit1=st.lower_bound((W){-1,A.l-1,0ll});\n\t\t\tB=(*it1);\n\t\t\tif(B.v!=INF)ned=(A.r-A.l+1)*(B.v-A.v);\n\t\t\telse ned=INF;\n\t\t\tif(ned<0)ned=INF;\n\t\t\tif(ned<=y){\n\t\t\t\tst.erase(it1);\n\t\t\t\tB.r=A.r;\n\t\t\t\tst.insert(B);\n\t\t\t\ty-=ned;\n\t\t\t}else {\n\t\t\t\tned=A.r-A.l+1;\n\t\t\t\tif(y%ned==0){\n\t\t\t\t\tA.v+=y/ned;\n\t\t\t\t\tst.insert(A);\n\t\t\t\t}else {\n\t\t\t\t\tB.l=A.l,B.r=B.l+y%ned-1,B.v=A.v+y/ned+1;\n\t\t\t\t\tst.insert(B);\n\t\t\t\t\tA.l=B.r+1,A.v=B.v-1;\n\t\t\t\t\tst.insert(A);\n\t\t\t\t}\n\t\t\t\ty=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(it=++st.begin(),it1=st.end();it!=it1;it++)\n\t\tfor(int j=(*it).l;j<=(*it).r;j++)\n\t\t\tPs((*it).v),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct P{\n\tint id;\t\t//id\n\tlong long num;\t//食べた寿司数\n\tbool operator<(const P& p) const{\n\t\tif (num < p.num){\n\t\t\treturn true;\n\t\t}\n\t\tif (num == p.num){\n\t\t\treturn id<p.id;\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator==(const P& p) const{\n\t\tif (num == p.num){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tP(int _id,long long _num){\n\t\tid=_id;\n\t\tnum=_num;\n\t}\n};\nint getMin(vector<P*> p,int a)\n{\n\tint i=0;\n\tP *minP=p[a-1];\n\tfor (i=0;i<a;i++){\n\t\tif (*p[i]==*minP){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\nvoid SetMinP(vector<P*> p,int a,long long b)\n{\n\tint minI=getMin(p,a);\n\tint i=minI;\n\twhile (i<a){\n\t\tp[i]->num++;\n\t\tb--;\n\t\tif (b==0){\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tif (i==a){\n\t\t\ti=getMin(p,a);\n\t\t}\n\t}\n}\nint main(int argc, char* argv[])\n{\n\tint N,Q;\n\tcin>>N>>Q;\n\tvector<P*> pVector;\n\tint i;\n\tP *p;\n\tfor (i=0;i<N;i++){\n\t\tp = new P(i+1,0);\n\t\tpVector.push_back(p);\n\t}\n\tint a;\n\tlong long b;\n\tfor (i=0;i<Q;i++){\n\t\tcin>>a>>b;\n\t\tSetMinP(pVector,a,b);\n\t}\n\tfor (i=0;i<pVector.size();i++){\n\t\tcout<<pVector[i]->num<<endl;\n\t\tdelete pVector[i];\n\t}\n\tpVector.clear();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100002];\nbool flag[100002];\nlong long int section[101];\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num / 1000] > 0) {\n\t\tfor (long long int i = num; i >= (num / 1000) * 1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i * 1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tflag[1] = true;\n\tsection[0]++;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start] * (a - start + 1)*(-1) < b) {\n\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\tflag[start] = false;\n\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\tif (flag[a + 1] == false && (b / (a - start + 1) != 0)) {\n\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\tnum[1 + b % a]--;\n\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\tif (flag[a + 1] == false && (b / a) != 0) {\n\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a[100001];\nlong long int b[100001];\nlong long int num[100001];\nbool flag[100001];\nint section[101] ;\nint sum;\nint start;\n\nbool CheckBefore(int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (int j = i * 1000 + 999; j >= 0; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\twhile (b[i] != 0) {\n\t\t//\tcout << b[i] << \"\\n\";\n\t\t\tif (CheckBefore(a[i])) {\n\t\t\t\tif ((a[i] - start + 1)*num[start]*(-1) <= b[i]) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[a[i] + 1] += num[start];\n\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b[i] % (a[i] - start + 1) == 0) {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[i] % a[i] == 0) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i] = 0;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 10;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l > r) for(;;);\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l > r) for(;;);\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t/*lint tree[MAXN];\n\tinline void buildtree(int root, int l, int r) {\n\t\t\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\trep (i, l, r) {\n\t\t\ttree[i] = c;\n\t\t}\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tlint ret = 0;\n\t\trep (i, l, r) {\n\t\t\tret += tree[i];\n\t\t}\n\t\treturn ret; \n\t}*/\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct RRange {\n\tint l, r;\n\tlong long int num;\n\tRRange(const int a, const int b, const long long int c) {\n\t\tl = a, r = b, num = c;\n\t\treturn;\n\t}\n\tbool operator<(const RRange& rr)const {\n\t\treturn r < rr.r;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tset<RRange>sr;\n\tsr.insert(RRange(1, N, 0));\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> L >> R;\n\t\tauto bag = sr.lower_bound(RRange(1, L, 0));\n\t\tif (bag->r != L) {\n\t\t\tint l = bag->l;\n\t\t\tint r = bag->r;\n\t\t\tlong long int num = bag->num;\n\t\t\tsr.erase(bag);\n\t\t\tsr.insert(RRange(l, L, num));\n\t\t\tsr.insert(RRange(L + 1, r, num));\n\t\t}\n\t\twhile (R) {\n\t\t\tauto box = sr.lower_bound(RRange(1, L, 0));\n\t\t\tif (box == sr.begin()) {\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tif (R%r) {\n\t\t\t\t\tsr.insert(RRange(l, l + (R%r) - 1, num + R / r + 1));\n\t\t\t\t\tsr.insert(RRange(l + (R%r), r, num + R / r));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum += R / r;\n\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t}\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << \"Hi\";\n\t\t\t\tauto bag = prev(box);\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tlong long int dif = (bag->num) - num;\n\t\t\t\tdif *= r - l + 1;\n\t\t\t\t//cout <<\"dif \"<< dif << endl;\n\t\t\t\tif (dif-(r-l+1) > R) {\n\t\t\t\t\tif (R%r) {\n\t\t\t\t\t\tsr.insert(RRange(l, l + (R%(r-l+1)) - 1, num + R / (r-l+1) + 1));\n\t\t\t\t\t\tsr.insert(RRange(l + (R%(r-l+1)), r, num + R / (r-l+1)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum += R / (r-l+1);\n\t\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t\t}\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t\telse if (dif <= R) {\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, r, nnum));\n\t\t\t\t\tR -= dif;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint m = R % (r - l + 1);\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tint rr = bag->r;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, rr + m, nnum));\n\t\t\t\t\tsr.insert(RRange(rr + m + 1, r, nnum - 1));\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"R \" << R << endl;\n\n\t\t}\n\t}\n\tfor (auto i : sr) {\n\t\tfor (int j = i.l; j <= i.r; j++) {\n\t\t\tcout << i.num << endl;\n\t\t}\n\t\t//cout << i.l << \" \" << i.r << \" \" << i.num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mx[400010],mn[400010],s[400010],t[400010];\nvoid pushup(int x){\n\tmx[x]=max(mx[x<<1],mx[x<<1|1]);\n\tmn[x]=min(mn[x<<1],mn[x<<1|1]);\n\ts[x]=s[x<<1]+s[x<<1|1];\n}\nvoid gao(int x,int len,ll v){\n\tmx[x]=mn[x]=v;\n\ts[x]=len*v;\n\tt[x]=v;\n}\nvoid pushdown(int x,int ln,int rn){\n\tif(t[x]){\n\t\tgao(x<<1,ln,t[x]);\n\t\tgao(x<<1|1,rn,t[x]);\n\t\tt[x]=0;\n\t}\n}\nvoid modify(int L,int R,ll v,int l,int r,int x){\n\tif(L<=l&&r<=R)return gao(x,r-l+1,v);\n\tint mid=(l+r)>>1;\n\tpushdown(x,mid-l+1,r-mid);\n\tif(L<=mid)modify(L,R,v,l,mid,x<<1);\n\tif(mid<R)modify(L,R,v,mid+1,r,x<<1|1);\n\tpushup(x);\n}\nll query(int L,int R,int l,int r,int x){\n\tif(L<=l&&r<=R)return s[x];\n\tint mid=(l+r)>>1;\n\tll s=0;\n\tpushdown(x,mid-l+1,r-mid);\n\tif(L<=mid)s+=query(L,R,l,mid,x<<1);\n\tif(mid<R)s+=query(L,R,mid+1,r,x<<1|1);\n\treturn s;\n}\nint query(ll v,int l,int r,int x){\n\tif(l==r)return l;\n\tint mid=(l+r)>>1;\n\tpushdown(x,mid-l+1,r-mid);\n\tif(mn[x<<1]<=v)return query(v,l,mid,x<<1);\n\treturn query(v,mid+1,r,x<<1|1);\n}\nvoid dfs(int l,int r,int x){\n\tif(l==r){\n\t\tprintf(\"%lld\\n\",s[x]);\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tpushdown(x,mid-l+1,r-mid);\n\tdfs(l,mid,x<<1);\n\tdfs(mid+1,r,x<<1|1);\n}\nint main(){\n\tint n,m,x,p;\n\tll y,l,r,mid,ans,t;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m--){\n\t\tscanf(\"%d%lld\",&x,&y);\n\t\tl=query(x,x,1,n,1);\n\t\tr=query(1,1,1,n,1)+y;\n\t\twhile(l<=r){\n\t\t\tmid=(l+r)>>1;\n\t\t\tp=query(mid,1,n,1);\n\t\t\tt=(x-p+1)*mid-query(p,x,1,n,1);\n\t\t\tif(t<=y){\n\t\t\t\tans=mid;\n\t\t\t\tl=mid+1;\n\t\t\t}else\n\t\t\t\tr=mid-1;\n\t\t}\n\t\tp=query(ans,1,n,1);\n\t\ty-=(x-p+1)*ans-query(p,x,1,n,1);\n\t\tmodify(p,x,ans,1,n,1);\n\t\tif(y)modify(p,p+y-1,ans+1,1,n,1);\n\t}\n\tdfs(1,n,1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Macro Tools /////////////////////////////////////////////////////////////////\n#define GET_MACRO_09(A0, A1, A2, A3, A4, A5, A6, A7, A8, NAME, ...) NAME\n\n#define EXPAND_01(MACRO, A0, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) \n#define EXPAND_02(MACRO, A0, A1, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) \n#define EXPAND_03(MACRO, A0, A1, A2, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__) \n#define EXPAND_04(MACRO, A0, A1, A2, A3, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) \n#define EXPAND_05(MACRO, A0, A1, A2, A3, A4, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) \n#define EXPAND_06(MACRO, A0, A1, A2, A3, A4, A5, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__) \n#define EXPAND_07(MACRO, A0, A1, A2, A3, A4, A5, A6, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) \n#define EXPAND_08(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) \n#define EXPAND_09(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, A8, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) MACRO(A8, ##__VA_ARGS__) \n\n#define GET_EXPAND(...) GET_MACRO_09(__VA_ARGS__, EXPAND_09, EXPAND_08, \\\n\tEXPAND_07, EXPAND_06, EXPAND_05, EXPAND_04, EXPAND_03, EXPAND_02, EXPAND_01)\n#define EXPAND_ARG_0(MACRO, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__)\n#define EXPAND_ARG_1(MACRO, A0, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__, A0)\n\n#define EXPAND(MACRO, ...) EXPAND_ARG_0(MACRO, __VA_ARGS__)\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define SCANF_INT(a) scanf(\"%d\", &(a));\n#define ID(...) int __VA_ARGS__;\n#define IR(...) {EXPAND(SCANF_INT, __VA_ARGS__)}\n#define I(...) ID(__VA_ARGS__) IR(__VA_ARGS__)\n\n// #define DEFINE_INT_ARRAY(a, n) int a[n];\n// #define INT_ITH_ARRAY(a, i) a[i]\n// #define IAD(N, ...) EXPAND_ARG_1(DEFINE_INT_ARRAY, N, __VA_ARGS__)\n// #define IAR(N, ...) REP(array_reader_i, N){ \n\n#define SCANF_LL(a) scanf(\"%lld\", &(a));\n#define LD(...) ll __VA_ARGS__;\n#define LR(...) {EXPAND(SCANF_LL, __VA_ARGS__)}\n#define L(...) LD(__VA_ARGS__) LR(__VA_ARGS__)\n\n#define SCANF_LD(a) scanf(\"%Lf\", &(a));\n#define DD(...) lD __VA_ARGS__;\n#define DR(...) {EXPAND(SCANF_LD, __VA_ARGS__)}\n#define D(...) DD(__VA_ARGS__) DR(__VA_ARGS__)\n\n#define DEFINE_STR(a, n) char a[n];\n#define SCANF_STR(a) scanf(\"%s\", a);\n#define SD(N, ...) EXPAND_ARG_1(DEFINE_STR, N, __VA_ARGS__)\n#define SR(...) EXPAND(SCANF_STR, __VA_ARGS__)\n#define S(N, ...) SD(N, __VA_ARGS__) SR(__VA_ARGS__)\n\n// Output //////////////////////////////////////////////////////////////////////\n#define LN printf(\"\\n\");\n\n#define IP(a, ...) printf(\"%d\", a); \n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FORT(t, i, a, b) \\\n\tfor(t i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define FORL(i, a, b) FORT(ll, i, a, b)\n#define FOR(i, a, b) FORT(int, i, a, b)\n#define REPT(t, i, n) FORT(t, i, 0, n)\n#define REPL(i, n) FORL(i, 0, n)\n#define REP(i, n) FOR(i, 0, n)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define SORTA(a, n) sort(a, a+n)\n\n#define PB push_back\n#define MP make_pair\n#define itr iterator\n\n// Range ///////////////////////////////////////////////////////////////////////\n#define IN(x, a, b) (a<=x && x<b)\n#define INC(x, a, b) (a<=x && x<=b)\nint dx[8] = { 1, 0, 0,-1, 1, 1,-1,-1};\nint dy[8] = { 0,-1, 1, 0,-1, 1,-1, 1};\n\n#define LAR(a, b) ((a)=max((a), (b)))\n#define SML(a, b) ((a)=min((a), (b)))\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define println(...) {printf(__VA_ARGS__); printf(\"\\n\");}\n#ifdef LOCAL\n#define debug(...) printf(__VA_ARGS__)\n#define debugln(...) println(__VA_ARGS__)\n#else\n#define debug(...) {}\n#define debugln(...) {}\n#endif\n\n// Numbers /////////////////////////////////////////////////////////////////////\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\n\n#define PRIME_MAX 1000000\nbool isprime[PRIME_MAX+5];\nvoid init_prime(){\n\tfill(isprime, isprime+PRIME_MAX+5, true);\n\tisprime[0]=isprime[1]=false;\n\tREP(i, PRIME_MAX+5){\n\t\tif(isprime[i]){\n\t\t\tfor(int j=i*2; j<PRIME_MAX; j+=i){\n\t\t\t\tisprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll factors(ll n){\n\tvll v;\n\tREPL(i, PRIME_MAX){\n\t\tif(!isprime[i]) continue;\n\t\twhile(n%i==0){\n\t\t\tv.PB(i);\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif(n>1){\n\t\tv.PB(n);\n\t}\n\treturn v;\n}\n\n// BIT /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int\n>\nclass bit{\npublic:\n\tT *bit_arr;\n\tint size;\n\n\tbit(int n){\n\t\tsize = n;\n\t\tbit_arr = new T[n];\n\t\tfill(bit_arr, bit_arr+n, 0);\n\t}\n\n\t~bit(){\n\t\tdelete bit_arr;\n\t}\n\n\tT sum(int a){\n\t\tT ret = 0;\n\t\twhile(a){\n\t\t\tret+=bit_arr[a];\n\t\t\ta-=a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tT sum(int a, int b){\n\t\treturn sum(b)-sum(a);\n\t}\n\n\tT get(int a){\n\t\treturn sum(a, a+1);\n\t}\n\n\tvoid add(int a, T x){\n\t\ta++;\n\t\twhile(a<size){\n\t\t\tbit_arr[a]+=x;\n\t\t\ta+=a&-a;\n\t\t}\n\t}\n\n\tvoid set(int a, T x){\n\t\tadd(a, x-get(a));\n\t}\n};\ntypedef bit<ll> bll;\n\n// RMQ /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int,\n\tclass Compare=less<T>\n>\nclass rmq{\npublic:\n\tint size;\n\tCompare comp;\n\tT *dat;\n\tT init;\n\t\n\trmq(int n, T init_=INT_MAX){\n\t\tinit=init_;\n\t\tsize = 1;\n\t\twhile(size<n) size*=2;\n\t\tdat = new T[2*size-1];\n\t\tfill(dat, dat+(2*size-1), init);\n\t}\n\n\t~rmq(){\n\t\tdelete dat;\n\t}\n\n\tvoid set(int k, T a){\n\t\tk+=size-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1], dat[k*2+2], comp);\n\t\t}\n\t}\n\n\tT get(int a, int b, int k, int l, int r){\n\t\tif(r<=a || b<=l) return init;\n\t\tif(a<=l && r<=b) return dat[k];\n\t\telse{\n\t\t\tT vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\t\tT vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn min(vl, vr, comp);\n\t\t}\n\t}\n\n\tT get(int a, int b){\n\t\treturn get(a, b, 0, 0, size);\n\t}\n\n\tT get(int a){\n\t\treturn get(a, a+1);\n\t}\n};\n\n// Others //////////////////////////////////////////////////////////////////////\n#define MOD 1000000007\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n\n////////////////////////////////////////////////////////////////////////////////\n\nrmq<pii, less<pii>> q(100005, MP(INT_MAX, INT_MAX));\n\nint main(){\n\tI(n, m);\n\tREP(i, n) q.set(i, MP(0, i));\n\tREP(i, m){\n\t\tI(a, b);\n\t\tREP(j, b){\n\t\t\tpii mi = q.get(0, a);\n\t\t\tq.set(mi.second, MP(mi.first+1, mi.second));\n\t\t}\n\t}\n\tREP(i, n){\n\t\tprintf(\"%d\\n\", q.get(i).first);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\nLL read() {\n    char ch = getchar();\n    LL x = 0, flag = 1;\n    for (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n    for (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x * flag;\n}\nvoid write(int x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x >= 10) write(x / 10);\n    putchar(x % 10 + 48);\n}\n\nconst int Maxn = 100009;\nint n, q;\n\ntemplate <int N> struct SGMTtree {\n\tpair<LL, int> t[N << 2]; LL add[N << 2];\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ls rt << 1, l, mid\n#define rs rt << 1 | 1, mid + 1, r\n\tvoid pushup(int u) {\n\t\tt[u] = min(t[lc(u)], t[rc(u)]);\n\t}\n\tvoid pushdown(int u) {\n\t\tif (add[u]) {\n\t\t\tadd[lc(u)] += add[u]; add[rc(u)] += add[u];\n\t\t\tt[lc(u)].first += add[u]; t[rc(u)].first += add[u];\n\t\t\tadd[u] = 0;\n\t\t}\n\t}\n\n\tvoid build(int rt, int l, int r) {\n\t\tif (l == r) {\n\t\t\tt[rt] = make_pair(0, l);\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1;\n\t\tbuild(ls), build(rs);\n\t\tpushup(rt);\n\t}\n\tvoid modify(int rt, int l, int r, int P, int Q, LL v) {\n\t\tif (P <= l && r <= Q) {\n\t\t\tadd[rt] += v; t[rt].first += v;\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) modify(ls, P, Q, v);\n\t\telse if (P >= mid + 1) modify(rs, P, Q, v);\n\t\telse modify(ls, P, Q, v), modify(rs, P, Q, v);\n\t\tpushup(rt);\n\t}\n\n\tpair<LL, int> query(int rt, int l, int r, int P, int Q) {\n\t\tif (P > Q) return {-1, INT_MIN};\n\t\tif (P <= l && r <= Q) return t[rt];\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) return query(ls, P, Q);\n\t\telse if (P >= mid + 1) return query(rs, P, Q);\n\t\telse return min(query(ls, P, Q), query(rs, P, Q));\n\t}\n#undef lc\n#undef rc\n#undef ls\n#undef rs\n}; SGMTtree <Maxn> st;\n\nvoid init() {\n\tn = read(); q = read();\n\tst.build(1, 1, n);\n}\n\nint Find(LL v, int l, int r) {\n\tint ans = -1;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (st.query(1, 1, n, mid, mid).first <= v) l = mid + 1;\n\t\telse r = mid - 1, ans = mid;\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\trep (i, 1, q) {\n\t\tint r = read(); LL v = read();\n\t\tif (r == 1) {\n\t\t\tst.modify(1, 1, n, 1, 1, v);\n\t\t\tv = 0;\n\t\t}\n\t\twhile (v) {\n\t\t\tpair<LL, int> k = st.query(1, 1, n, 1, r);\n\t\t\tint pos = Find(k.first, k.second, r);\n\t\t\tif (pos == -1) pos = r; else --pos;\n\t\t\tLL z = st.query(1, 1, n, 1, k.second - 1).first;\n\n\t\t\tif (z == -1) {\n\t\t\t\tLL rest = v % r, partly = v / r;\n\t\t\t\tst.modify(1, 1, n, 1, r, partly);\n\t\t\t\tif (rest) st.modify(1, 1, n, 1, rest, 1);\n\t\t\t\tv = 0;\n\t\t\t} else {\n\t\t\t\tif ((z - k.first) * (pos - k.second + 1) <= v) {\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, z - k.first);\n\t\t\t\t\tv -= (z - k.first) * (pos - k.second + 1);\n\t\t\t\t} else {\n\t\t\t\t\tLL rest = v % (pos - k.second + 1), partly = v / (pos - k.second + 1);\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, partly);\n\t\t\t\t\tif (rest) st.modify(1, 1, n, k.second, k.second - rest + 1, 1);\n\t\t\t\t\tv = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\n\trep (i, 1, n) \n\t\tprintf(\"%lld\\n\", st.query(1, 1, n, i, i).first);\n}\n\nint main() {\n//\tfreopen(\"ATCs8pc_3_f.in\", \"r\", stdin);\n//\tfreopen(\"ATCs8pc_3_f.out\", \"w\", stdout);\n\n\tinit();\n\tsolve();\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct RRange {\n\tint l, r;\n\tlong long int num;\n\tRRange(const int a, const int b, const long long int c) {\n\t\tl = a, r = b, num = c;\n\t\treturn;\n\t}\n\tbool operator<(const RRange& rr)const {\n\t\treturn r < rr.r;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tset<RRange>sr;\n\tsr.insert(RRange(1, N, 0));\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> L >> R;\n\t\tauto bag = sr.lower_bound(RRange(1, L, 0));\n\t\tif (bag->r != L) {\n\t\t\tint l = bag->l;\n\t\t\tint r = bag->r;\n\t\t\tlong long int num = bag->num;\n\t\t\tsr.erase(bag);\n\t\t\tsr.insert(RRange(l, L, num));\n\t\t\tsr.insert(RRange(L + 1, r, num));\n\t\t}\n\t\twhile (R) {\n\t\t\tauto box = sr.lower_bound(RRange(1, L, 0));\n\t\t\tif (box == sr.begin()) {\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tif (R%r) {\n\t\t\t\t\tsr.insert(RRange(l, l + (R%r) - 1, num + R / r + 1));\n\t\t\t\t\tsr.insert(RRange(l + (R%r), r, num + R / r));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum += R / r;\n\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t}\n\t\t\t\tR = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << \"Hi\";\n\t\t\t\tauto bag = prev(box);\n\t\t\t\tint l = box->l;\n\t\t\t\tint r = box->r;\n\t\t\t\tlong long int num = box->num;\n\t\t\t\tsr.erase(box);\n\t\t\t\tlong long int dif = (bag->num) - num;\n\t\t\t\tdif *= r - l + 1;\n\t\t\t\t//cout <<\"dif \"<< dif << endl;\n\t\t\t\tif (dif-(r-l+1) >= R) {\n\t\t\t\t\tif (R%(r-l+1)) {\n\t\t\t\t\t\tsr.insert(RRange(l, l + (R%(r-l+1)) - 1, num + R / (r-l+1) + 1));\n\t\t\t\t\t\tsr.insert(RRange(l + (R%(r-l+1)), r, num + R / (r-l+1)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum += R / (r-l+1);\n\t\t\t\t\t\tsr.insert(RRange(l, r, num));\n\t\t\t\t\t}\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t\telse if (dif <= R) {\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, r, nnum));\n\t\t\t\t\tR -= dif;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint m = R % (r - l + 1);\n\t\t\t\t\tint ll = bag->l;\n\t\t\t\t\tint rr = bag->r;\n\t\t\t\t\tlong long int nnum = bag->num;\n\t\t\t\t\tsr.erase(bag);\n\t\t\t\t\tsr.insert(RRange(ll, rr + m, nnum));\n\t\t\t\t\tsr.insert(RRange(rr + m + 1, r, nnum - 1));\n\t\t\t\t\tR = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"R \" << R << endl;\n\n\t\t}\n\t}\n\tfor (auto i : sr) {\n\t\tfor (int j = i.l; j <= i.r; j++) {\n\t\t\tcout << i.num << endl;\n\t\t}\n\t\t//cout << i.l << \" \" << i.r << \" \" << i.num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld%ld\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tif(Q<=100&&N<=100){\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tMin(a[i],9223372036854775806,0);\n\t\t}\n\t}\n\n\n\t\n\tfor(int i=0;i<N;i++){\n\tprintf(\"%ld\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ll long long\nll T[1<<18],val[1<<18];\nbool tag[1<<18];\nvoid setval(int node,int left,int right,ll x){\n\ttag[node]=1;\n\tT[node]=x*(right-left+1);\n\tval[node]=x;\n}\nvoid pushdown(int node,int left,int right){\n\tif(tag[node]){\n\t\tint mid=left+right>>1;\n\t\tsetval(node<<1,left,mid,val[node]);\n\t\tsetval(node<<1|1,mid+1,right,val[node]);\n\t\ttag[node]=0;\n\t}\n}\nvoid modify(int node,int left,int right,int l,int r,ll x){\n\tif(l==left&&r==right)setval(node,l,r,x);\n\telse{\n\t\tpushdown(node,left,right);\n\t\tint mid=left+right>>1;\n\t\tif(r<=mid)modify(node<<1,left,mid,l,r,x);\n\t\telse if(l>mid)modify(node<<1|1,mid+1,right,l,r,x);\n\t\telse{\n\t\t\tmodify(node<<1,left,mid,l,mid,x);\n\t\t\tmodify(node<<1|1,mid+1,right,mid+1,r,x);\n\t\t}\n\t\tT[node]=T[node<<1]+T[node<<1|1];\n\t}\n}\nll getsum(int node,int left,int right,int l,int r){\n\tif(l==left&&r==right)return T[node];\n\tpushdown(node,left,right);\n\tint mid=left+right>>1;\n\tif(r<=mid)return getsum(node<<1,left,mid,l,r);\n\tif(l>mid)return getsum(node<<1|1,mid+1,right,l,r);\n\treturn getsum(node<<1,left,mid,l,mid)+getsum(node<<1|1,mid+1,right,mid+1,r);\n}\nint main(){\n\tint N,Q,a;\n\tll b;\n\tscanf(\"%d%d\",&N,&Q);\n\twhile(Q--){\n\t\tscanf(\"%d%lld\",&a,&b);\n\t\tint left=0,right=a,mid;\n\t\twhile(right-left>1){\n\t\t\tmid=left+right>>1;\n\t\t\tif(getsum(1,1,N,mid,mid)*(a-mid+1)-getsum(1,1,N,mid,a)<=b)right=mid;\n\t\t\telse left=mid;\n\t\t}\n\t\tll tmp=getsum(1,1,N,right,right),tmp1,tmp2;\n\t\tb-=tmp*(a-right+1)-getsum(1,1,N,right,a);\n\t\ttmp1=b/(a-right+1);\n\t\ttmp2=b%(a-right+1);\n\t\tmodify(1,1,N,right,a,tmp+tmp1);\n\t\tif(tmp2)modify(1,1,N,right,right+tmp2-1,tmp+tmp1+1);\n\t}\n\tfor(int i=1;i<=N;i++)printf(\"%lld\\n\",getsum(1,1,N,i,i));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100001];\n\nLL count(int m, int a) {\n\tLL sum = 0;\n\tREP(i, a-m, 0) {\n\t\tsum += (res[a-i-1] - res[a-i]) * (i + 1);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\tmemset(res, 0, sizeof(res));\n//\tres[0] = 20000000000000;\n\tcin >> N >> Q;\n//\tN = 10000, Q = 100000;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n//\t\tA = N, B = 1;\n\t\tint l = 0, r = A;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (r + l) / 2;\n//\t\t\tcout << m << \":\" << A << \":\" << count(m, A) << endl;\n\t\t\tif (count(m, A) > B) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tLL p = res[r];\n\t\tREP(i, A + 1, r + 1) {\n\t\t\tif (res[i] != p) {\n\t\t\t\tREP(j, A + 1, i) {\n\t\t\t\t\tB -= (p - res[j]);\n\t\t\t\t\tres[j] = p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp = res[i];\n\t\t\t}\n\t\t}\n//\t\tcout << r << endl;\n\t\tREP(i, A + 1, r) {\n\t\t\tres[i] += B/(A - r + 1);\n\t\t}\n\t\tREP(i, r + B%(A - r + 1), r) {\n\t\t\tres[i]++;\n\t\t}\n//\t\tREP(i, N + 1, 1) cout << res[i];\n//\t\tcout << endl;\n\t}\n\tREP(i, N + 1, 1) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a[100001];\nlong long int b[100001];\nlong long int num[100001];\nbool flag[100001];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (int j = i * 1000 + 999; j >= 0; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\twhile (b[i] != 0) {\n\t\t\tif (CheckBefore(a[i])) {\n\t\t\t\tif ((a[i] - start + 1)*num[start]*(-1) <= b[i]) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[a[i] + 1] += num[start];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb[i] += (a[i] - start + 1)*num[start];\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b[i] % (a[i] - start + 1) == 0) {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / (a[i] - start + 1);\n\t\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b[i] / (a[i] - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b[i] % (a[i] - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b[i] % (a[i] - start + 1)] = true;\n\t\t\t\t\t\t\tsection[start + b[i] % (a[i] - start + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b[i] % a[i] == 0) {\n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a[i] != N) {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t\tnum[a[i] + 1] -= b[i] / a[i];\n\t\t\t\t\t\tif (flag[a[i] + 1] == false) {\n\t\t\t\t\t\t\tflag[a[i] + 1] = true;\n\t\t\t\t\t\t\tsection[(a[i] + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b[i] / a[i] + 1;\n\t\t\t\t\t\tnum[1 + b[i] % a[i]]--;\n\t\t\t\t\t\tflag[1 + b[i] % a[i]] = true;\n\t\t\t\t\t\tsection[(1 + b[i] % a[i]) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, TEN(15)));\n    s.insert(P(n, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;\n            if (a == pr.first) s.erase(pr);\n            if (d*(pl.second-pr.second) <= b) {\n                s.erase(pl); \n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {\n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint N,dat[300000];\nvoid init(int n_){\n\tN=1;\n\twhile(N<n_)N*=2;\n\tfor(int i=0;i<2*N-1;i++)dat[i]=INT_MAX;\n}\nvoid update(int k,int a){\n\tk+=N-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r){\n\tif(r<=a||b<=l)return INT_MAX;\n\tif(a<=l&&r<=b)return dat[k];\n\tint v1=query(a,b,k*2+1,l,(l+r)/2);\n\tint v2=query(a,b,k*2+2,(l+r)/2,r);\n\treturn min(v1,v2);\n}\n\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tvector<int>cnt(n);\n\tinit(n);\n\trep(i,n)update(i,0);\n\trep(i,q){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tint d=query(0,a,0,0,N);\n\t\tint k=upper_bound(cnt.rbegin(),cnt.rend(),d)-cnt.rbegin();\n\t\tk=n-k;\n\t\tupdate(k,d+1);\n\t\tcnt[k]=d+1;\n\t}\n\trep(i,n)printf(\"%d\\n\",cnt[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz,h; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(k < n) {\n                    lazy_add[2*k] = lazy_add[2*k+1] = 0;\n                    lazy_update[2*k] = lazy_update[2*k+1] = lazy_update[k];\n                    lazyFlag[2*k] = lazyFlag[2*k+1] = true;\n                }\n                lazy_add[k] = 0, lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(k < n){\n                    lazy_add[2*k] += lazy_add[k]; lazy_add[2*k+1] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T> v) : n(1), sz((int)v.size()), h(0){\n            while(n < sz) n *= 2, h++;\n            node.resize(2*n, numeric_limits<T>::min());\n            lazy_update.resize(2*n, 0); lazyFlag.resize(2*n, false);\n            lazy_add.resize(2*n, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n] = v[i];\n            }\n            for(int i=n-1; i>=1; i--) node[i] = max(node[2*i],node[2*i+1]);\n        }\n        void update(int a, int b, T x, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true; eval(k);\n            }else{\n                update(a, b, x, 2*k, l, (l+r)/2); update(a, b, x, 2*k+1, (l+r)/2, r);\n                node[k] = max(node[2*k], node[2*k+1]);\n            }\n        }\n        void add(int a, int b, T x, int k=0, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k);\n            }else{\n                add(a, b, x, 2*k, l, (l+r)/2); add(a, b, x, 2*k+1, (l+r)/2, r);\n                node[k] = max(node[2*k], node[2*k+1]);\n            }\n        }\n        T query(int a, int b) {\n            a += n, b += n - 1;\n            for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n            b++;\n            T res1 = numeric_limits<T>::min(), res2 = numeric_limits<T>::min();\n            while(a < b) {\n                if(a & 1) eval(a), res1 = max(res1, node[a++]);\n                if(b & 1) eval(--b), res2 = max(res2, node[b]);\n                a >>= 1, b >>= 1;\n            }\n            return max(res1, res2);\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a;\n        ll b;\n        scanf(\"%d %lld\",&a,&b);\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        printf(\"%lld\\n\",sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#define mp  make_pair\nusing namespace std;\n\ntypedef long long  LL;\ntypedef pair <int,LL>  PIL;\ntypedef set <PIL>::iterator  Iter;\nint n,q;\nset <PIL> S;\n\nIter pre(Iter x){x--;  return x;}\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tS.insert(mp(0,1LL<<40)),S.insert(mp(1,0)),S.insert(mp(n+1,-1));\n\tfor (int i=1,a,l; i<=q; i++)\n\t\t{\n\t\t\tLL b;\n\t\t\tscanf(\"%d %lld\",&a,&b),a++;\n\t\t\tIter x=pre(S.upper_bound(mp(a,1LL<<60))),y;\n\t\t\tif ((*x).first!=a)\n\t\t\t\t{\n\t\t\t\t\tif (a-(*x).first>=b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((*pre(x)).second==(*x).second+1)\n\t\t\t\t\t\t\t\tS.erase(x),S.insert(mp((*x).first+b,(*x).second));\n\t\t\t\t\t\t\telse  S.insert(mp((*x).first+b,(*x).second)),S.erase(x),S.insert(mp((*x).first,(*x).second+1));\n\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t}else  x=(S.insert(mp(a,(*x).second))).first;\n\t\t\t\t}\n\t\t\twhile (b>0)\n\t\t\t\t{\n\t\t\t\t\ty=pre(x),l=a-(*y).first;\n\t\t\t\t\tif (((*pre(y)).second-(*y).second)*l>=b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (b%l)  S.insert(mp((*y).first+b%l,(*y).second+b/l));\n\t\t\t\t\t\t\tS.erase(y),S.insert(mp((*y).first,(*y).second+(b+l-1)/l));\n\t\t\t\t\t\t\tif ((*pre(y)).second==(*y).second)  S.erase(y);\n\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t}else\n\t\t\t\t\t\tb-=((*pre(y)).second-(*y).second)*l,S.erase(y);\n\t\t\t\t}\n\t\t}\n\tfor (Iter x=S.begin(),y; x!=S.end(); y=x,x++)\n\t\tif ((*x).first>1)\n\t\t\tfor (int i=(*y).first; i<(*x).first; i++)\n\t\t\t\tprintf(\"%lld\\n\",(*y).second);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define int long long\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nll a[MAX_N], b[MAX_N];\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    rep(i,q){\n        cin >> a[i] >> b[i];\n    }\n    set<P> st = {P(0,0)};\n    rep(i,q){\n        auto it = st.lower_bound(P(a[i], -INF));\n        bool flag = (it == st.end() || it->fi != a[i]);\n        auto it2 = --it;\n        ll flag2 = it2->se;\n        // each(p,st){\n        //     spair(p);\n        // }\n        // cout << \"===================\\n\";\n        if(it2 == st.begin()){\n            P p = *it2;\n            st.erase(it2);\n            ll x = b[i] / a[i], y = b[i] % a[i];\n            if(y == 0){\n                st.insert(P(p.fi,p.se+x));\n            }else{\n                st.insert(P(p.fi,p.se+x+1));\n                st.insert(P(p.fi+y,p.se+x));\n            }\n        }else{\n            do {\n                P p = *it2, q = *(--it2);\n                ++it2;\n                // spair((*it2));\n                st.erase(it2);\n                ll cri = (a[i]-p.fi)*(q.se-p.se);\n                if(b[i] >= cri){\n                    b[i] -= cri;\n                }else{\n                    ll x = b[i] / (a[i]-p.fi), y = b[i] % (a[i]-p.fi);\n                    // cout << x << \" \" << y << endl;\n                    if(y == 0){\n                        st.insert(P(p.fi,p.se+x));\n                    }else{\n                        if(q.se != p.se+x+1){\n                            st.insert(P(p.fi,p.se+x+1));\n                        }\n                        st.insert(P(p.fi+y,p.se+x));\n                        // spair(P(p.fi,p.se+x+1)), spair(P(p.fi+y,p.se+x));\n                    }\n                    b[i] = 0;\n                }\n                // each(p,st){\n                //     spair(p);\n                // }\n                // cout << \"-------------------\\n\";\n                it = st.lower_bound(P(a[i], -INF));\n                it2 = --it;\n                // show(b[i]);\n            }while(it2 != st.begin() && b[i] > 0);\n            if(b[i] > 0){\n                P p = *it2;\n                st.erase(it2);\n                ll x = b[i] / a[i], y = b[i] % a[i];\n                if(y == 0){\n                    st.insert(P(p.fi,p.se+x));\n                }else{\n                    st.insert(P(p.fi,p.se+x+1));\n                    st.insert(P(p.fi+y,p.se+x));\n                }\n            }\n        }\n        if(flag){\n            st.insert(P(a[i],flag2));\n        }\n    }\n    // each(p,st){\n    //     spair(p);\n    // }\n    // cout << \"-------------------\\n\";\n    int s = 0, prv = -1;\n    each(p,st){\n        if(p.fi > 0){\n            srep(i,s,p.fi){\n                cout << prv << \"\\n\";\n            }\n        }\n        s = p.fi, prv = p.se;\n    }\n    srep(i,s,n){\n        cout << prv << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nstatic const int MAX_SIZE = 1 << 17; //segment tree のサイズ。 2^17 ≒ 1.3 * 10^5\n\ntypedef long long Int;\nInt all[2 * MAX_SIZE - 1], part[2 * MAX_SIZE - 1]; // segment tree\n\n//区間[a, b)に値xを加算する.\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (a <= l && r <= b){ //[l, r)が[a, b)に完全に内包されていれば\n        all[k] += x; //[l, r)の全ての区間が持つ値としてxを足す.\n    }\n    else if (l < b && a < r){ //[l, r)と[a, b)が交差していれば\n        part[k] += (min(b, r) - max(a, l)) * x;  //交差している分の値を, 部分的な和を持つノードに加算する.\n        add(a, b, x, k * 2 + 1, l, (l + r) / 2); //子でも同じ処理を行う.\n        add(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃.\n    }\n}\n\nInt sum(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n    if (b <= l || r <= a){ //[a, b)と[l, r)が全く交差しない場合\n        return (0);\n    }\n    else if (a <= l && r <= b){ //完全に内包されていれば\n        return (all[k] * (r - l) + part[k]);\n    }\n    else { //[l, r)と[a, b)が交差していれば\n        ll res;\n        res = (min(b, r) - max(a, l)) * all[k]; //そのノードの全ての要素が持つ値のうち, [a, b)に属すものの分だけを加算する.\n        res += sum(a, b, k * 2 + 1, l, (l + r) / 2); //子ノードで和を求める.\n        res += sum(a, b, k * 2 + 2, (l + r) / 2, r); //〃\n        return (res);\n    }\n}\n\n\nset<int> se;\n\nll myFill(int m, ll b){\n\t// cout<<\"m b \"<<m<<\" \"<<b<<endl;\n\twhile(se.size()>2){\n\t\tset<int>::iterator it = se.upper_bound(m);\n\t\tint r = m;\n\t\tit--;\n\t\tint l = *it;\n\t\tif(l == 0){\n\t\t\treturn b;\n\t\t}\n\t\tll h1 = sum(l-1,l);\n\t\tll h2 = sum(l,l+1);\n\t\t// dump(l);\n\t\tif((h1-h2)*(m-l+1)>=b){\n\t\t\t// se.erase(it);\n\t\t\tse.insert(l+b%(m-l+1));\n\t\t\tadd(l, r+1, b/(m-l+1));\n\t\t\tif(b/(m-l+1)>=1){\n\t\t\t\tse.insert(m+1);\n\t\t\t}\n\t\t\tadd(l, l+b%(m-l+1), 1);\n\t\t\tse.insert(l+b%(m-l+1));\n\t\t\tif(sum(l,l+1)==sum(l-1,l)) se.erase(it);\n\t\t\treturn 0;\n\t\t}\n\t\tadd(l, m+1, h1-h2);\n\t\tse.insert(m+1);\n\t\tse.erase(it);\n\t\tb-=(h1-h2)*(m-l+1);\n\t}\n\treturn b;\n}\n\n\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\tint Q;\n\tcin>>Q;\n\tse.insert(0);\n\tse.insert(n);\n\t/*\n9 3\n5 11\n8 4\n4 7\n\t*/\n\trep(i,Q){\n\t\t// dump(i);\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tll c = myFill(a-1, b);\n\t\tif(c){\n\t\t\t// cout << \"c a \"<<c << \" \" << a << endl;\n\t\t\tadd(0, a, c/a);\n\t\t\tif(c/a>=1){\n\t\t\t\tse.insert(a);\n\t\t\t}\n\t\t\tc%=a;\n\t\t\tif(c){\n\t\t\t\tse.insert(c);\n\t\t\t\tadd(0, c, 1);\n\t\t\t}\n\t\t}\n\t\t// cout << \"sum \"<<endl;\n\t\t// rep(j,n){\n\t\t// \tcout << sum(j,j+1) << endl;\n\t\t// }cout<<endl;\n\t\t// cout<<\"set\"<<endl;\n\t\t// for(int x:se){\n\t\t// \tcout<<x<<\" \";\n\t\t// }cout<<endl;\n\t}\n\trep(i,n){\n\t\tcout << sum(i,i+1) << endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#define file(s) freopen(s\".in\", \"r\", stdin), freopen(s\".out\", \"w\", stdout);\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200005;\nconst ll INF = 2e13;\nint n, Q, L, R;\nll sum[MAXN << 2], _min[MAXN << 2], lazy[MAXN << 2];\nll crs_sum[MAXN << 2];\n\nvoid build(int o, int l, int r) {\n    lazy[o] = -1;\n    if (l == r)\n        return;\n    int mid = (l + r) >> 1;\n    build(o << 1, l, mid), build(o << 1 | 1, mid + 1, r);\n}\n\nvoid pushdown(const int &o, const int &l, const int &r) {\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    _min[ls] = _min[rs] = lazy[o];\n    lazy[ls] = lazy[rs] = lazy[o];\n    sum[ls] = (mid - l + 1) * lazy[o], sum[rs] = (r - mid) * lazy[o];\n    lazy[o] = -1;\n}\n\nvoid update(const int &o, const int &ls, const int &rs) {\n    _min[o] = _min[rs], sum[o] = sum[ls] + sum[rs];\n}\n\nvoid get_crs_sum(int o, int l, int r, const int &p) {\n    if (l == r) {\n        crs_sum[o] = sum[o];\n        return;\n    }\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (p <= mid) {\n        get_crs_sum(ls, l, mid, p);\n        crs_sum[o] = crs_sum[ls];\n    } else {\n        get_crs_sum(rs, mid + 1, r, p);\n        crs_sum[o] = sum[ls] + crs_sum[rs];\n    }\n}\n\nint find(int o, int l, int r, int p, ll b, ll s) {\n    if (l == r)\n        return l;\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    if (p <= mid)\n        return find(ls, l, mid, p, b, 0);\n    else if (p < r) {\n        if ((p - mid) * _min[ls] - crs_sum[rs] >= b)\n            return find(rs, mid + 1, r, p, b, 0);\n        else\n            return find(ls, l, mid, p, b, crs_sum[rs]);\n    } else {\n        if ((p - mid) * _min[ls] - (s + sum[rs]) >= b)\n            return find(rs, mid + 1, r, p, b, s);\n        else\n            return find(ls, l, mid, p, b, s + sum[rs]);\n    }\n}\n\nll query_sum(int o, int l, int r) {\n    if (L <= l && r <= R)\n        return sum[o];\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    ll res = 0; int mid = (l + r) >> 1;\n    if (L <= mid)\n        res += query_sum(o << 1, l, mid);\n    if (R > mid)\n        res += query_sum(o << 1 | 1, mid + 1, r);\n    return res;\n}\n\nvoid modify(int o, int l, int r, ll v) {\n    if (L <= l && r <= R) {\n        sum[o] = (r - l + 1) * v, _min[o] = lazy[o] = v;\n        return;\n    }\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (L <= mid)\n        modify(ls, l, mid, v);\n    if (R > mid)\n        modify(rs, mid + 1, r, v);\n    update(o, ls, rs);\n}\n\nvoid get_element(int o, int l, int r) {\n    if (l == r) {\n        printf(\"%lld\\n\", _min[o]);\n        return;\n    }\n    int ls = o << 1, rs = ls | 1, mid = (l + r) >> 1;\n    if (lazy[o] != -1)\n        pushdown(o, l, r);\n    get_element(ls, l, mid), get_element(rs, mid + 1, r);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &Q);\n    build(1, 1, n);\n    int a, p; ll b, s, l, r, mid;\n    for (int t = 1; t <= Q; t++) {\n        scanf(\"%d %lld\", &a, &b);\n        get_crs_sum(1, 1, n, a);\n        L = p = find(1, 1, n, a, b, 0), R = a;\n        s = query_sum(1, 1, n);\n        l = 0, r = INF;\n        while (l <= r)\n            (mid = (l + r) >> 1) * (R - L + 1) - s <= b ? l = mid + 1 : r = mid - 1;\n        modify(1, 1, n, r);\n        b = b - (R - L + 1) * r + s;\n        if (L <= (R = L + b - 1))\n            modify(1, 1, n, r + 1);\n    }\n    get_element(1, 1, n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll INF = (1LL<<60);\nP dat[(1<<18)];\n\nvoid update(int i,P p){\n  i+=(1<<17)-1;\n  dat[i]=p;\n  while(i){\n    i=(i-1)/2;\n    dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n}\n\nP getMin(int a,int b,int k=0,int l=0,int r=(1<<17)){\n  if(b<=l || r<=a)return P(INF,INF);\n  if(a<=l && r<=b)return dat[k];\n  int m=(l+r)/2;\n  return min( getMin(a,b,k*2+1,l,m),getMin(a,b,k*2+2,m,r));\n}\n\nint N,Q;\n\nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  for(int i=0;i<N;i++)update(i, P(0,i));\n  for(int i=0;i<Q;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    while(b--){\n      P target=getMin(0,a);\n      update( target.second , P( target.first+1, target.second ) );\n    }\n  }\n  for(int i=0;i<N;i++){\n    P ans=getMin(i,i+1);\n    printf(\"%lld\\n\",ans.first);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\n/* LazyPropagationSegmentTree(Sum) */\n//0-index\n\nstruct LazySeg_sum{\n  typedef ll Type;\n  \n  struct Data{\n    Type val;\n    Type add;\n    Type sum;\n    bool valset;\n    \n    Type calc_sum(int l, int r){\n      if(valset){\n        return (val + add) * (r - l + 1);\n      }else{\n        return sum + add * (r - l + 1);\n      }\n    }\n\n    void set_data(Type x,Type y){\n      val = x;\n      add = y;\n      valset = true;\n    }\n\n    void add_data(Type x){\n      add += x;\n    }\n    \n    Data():val(0),add(0),sum(0),valset(false){}\n    \n  };\n\n  vector<Data> data;\n  int seg_size;\n  \n  LazySeg_sum(int n){\n    for(seg_size=1; seg_size < n; seg_size*=2);\n    data.assign(seg_size*2, Data());\n  }\n\n  Type set(int a, int b, Type x, int l=0, int r=-1,int k=0){\n    if(r == -1) r = seg_size-1;\n    \n    if(a <= l && r <= b){\n      data[k].set_data(x,0);\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n    \n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val,data[k].add);\n      data[k*2+2].set_data(data[k].val,data[k].add);\n    }else{\n      data[k*2+1].add_data(data[k].add);\n      data[k*2+2].add_data(data[k].add);\n    }\n      \n\n    data[k].add = 0;\n    \n    data[k].valset = false;\n    \n    data[k].sum = set(a,b,x,l,(l+r)/2,k*2+1) + set(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n\n  Type add(int a, int b, Type x, int l=0, int r=-1, int k=0){\n    if(r == -1) r = seg_size-1;\n\n    if(a <= l && r <= b){\n      data[k].add += x;\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n\n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val, data[k].add);\n      data[k*2+2].set_data(data[k].val, data[k].add);\n      data[k].add = 0;\n      data[k].valset = false;\n    }\n\n    data[k].sum = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n  \n  Type query(int a, int b, int l=0, int r=-1, int k = 0){\n    if(r == -1) r = seg_size-1;\n\n    if(r < a || b < l) return 0;\n\n    if((a <= l && r <= b) || data[k].valset){\n      return data[k].calc_sum(max(a,l),min(b,r));\n    }\n\n    return query(a,b,l,(l+r)/2,k*2+1) + query(a,b,(l+r)/2+1,r,k*2+2) +\n           data[k].add * (min(b,r) - max(a,l) + 1);\n  }\n  \n};\n\n\nLazySeg_sum seg(100000);\n\nint main(){\n  int n,q,a;\n  ll b;\n\n  scanf(\"%d%d\",&n,&q);\n\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d%lld\",&a,&b);\n    a--;\n\n    if(a == 0){\n      seg.add(0,0,b);\n      continue;\n    } \n    \n    int l=1,r=a,mid;\n    ll u,p;\n    \n    while(l < r){\n\n      mid = (l+r)/2;\n\n      u = seg.query(mid-1,mid-1);\n      \n      p = seg.query(mid,a);\n\n      if((u * (a-mid+1) - p) > b){\n        l = mid+1;\n      }else{\n        r = mid;\n      }\n    }\n    \n    p = seg.query(l,a);\n    u = seg.query(l-1,l-1);\n\n    while( b < u*(a-l+1) - p ) u--;\n    \n    b -= u*(a-l+1) - p;\n    \n    seg.set(l,a,u);\n    \n    seg.add(l-1,a,b/(a-(l-1)+1));\n    b%=(a-(l-1)+1);\n    \n    if(b > 0)\n      seg.add(l-1,b-1+(l-1),1);\n  }\n  \n  for(int i=0;i<n;i++){\n    //printf(\"%lld\\n\",seg.query(i,i));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz,h;\n    vector<T> node, lazy;\n    void eval(int k) {\n        if(lazy[k]){\n            node[k] += lazy[k];\n            if(k < n) {\n                lazy[k*2] += lazy[k], lazy[k*2+1] += lazy[k];\n            }\n            lazy[k] = 0;\n        }\n    }\n\npublic:\n    segtree(vector<T>& v) : sz((int)v.size()), h(0) {\n        n = 1;\n        while(n < sz) n *= 2, h++;\n        node.resize(2*n, numeric_limits<T>::min());\n        lazy.resize(2*n, 0);\n        for(int i = 0; i < sz; i++) node[i+n] = v[i];\n        for(int i = n-1; i >= 1; i--) node[i] = max(node[2*i], node[2*i+1]);\n    }\n    void add(int a, int b, T x, int k=1, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b){\n            lazy[k] += x;\n            eval(k);\n        }else{\n            add(a, b, x, 2*k, l, (l+r)/2);\n            add(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = max(node[2*k], node[2*k+1]);\n        }\n    }\n    T query(int a, int b) {\n        a += n, b += n - 1;\n        for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n        b++;\n        T res1 = numeric_limits<T>::min(), res2 = numeric_limits<T>::min();\n        while(a < b) {\n            if(a & 1) eval(a), res1 = max(res1, node[a++]);\n            if(b & 1) eval(--b), res2 = max(res2, node[b]);\n            a >>= 1, b >>= 1;\n        }\n        return max(res1, res2);\n    }\n    void print(){for(int i = 0; i < sz; i++) cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a;\n        ll b;\n        scanf(\"%d %lld\",&a,&b);\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        printf(\"%lld\\n\",sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\n#define MOD 1000000007\n#define EPS (1e-10)\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\n\nstruct st {\n\tint id, cnt;\n};\nbool operator<(st a, st b) {\n\tif (a.cnt == b.cnt)return a.id < b.id;\n\treturn a.cnt < b.cnt;\n}\nint cnt[1000000];\n\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tif (n > 100)abort();\n\tset<st>se;\n\tfor (int i = 1; i <= n; i++) se.insert({ i,0 });\n\trep(i, q) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\twhile (se.size()&&cnt[(*se.begin()).id] != (*se.begin()).cnt)se.erase(se.begin());\n\t\tauto it = se.begin();\n\t\tfor (; (*it).id > a; it++);\n\t\tcnt[(*it).id]++;\n\t\tse.insert({ (*it).id,cnt[(*it).id] });\n\t\tse.erase(it);\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d\\n\", cnt[i]);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing int64 = long long;\n\nclass segment_tree\n{\nprivate:\n\tstd::vector<pair<int64,int>>treedat;\n\tint treesiz;\n\tpair<int64,int> inf;\n\tpair<int64,int> rawqry(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l && r <= b)return treedat[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(rawqry(a, b, k * 2 + 1, l, m), rawqry(a, b, k * 2 + 2, m, r));\n\t}\npublic:\n\tvoid update(int k, pair<int64,int> a)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tvoid update_inc(int k)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k].first++;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tint64 peek(int k)\n\t{\n\t\treturn treedat[k + treesiz - 1].first;\n\t}\n\tpair<int64, int> query(int a, int b) { return rawqry(a, b, 0, 0, treesiz); }\n\tsegment_tree(int n)\n\t{\n\t\tinf = make_pair((int64)LLONG_MAX - (int64)INT_MAX, n);\n\t\ttreesiz = 1;\n\t\twhile (treesiz < n)treesiz *= 2;\n\t\ttreedat.resize(2 * treesiz + 1);\n\t\tstd::fill(treedat.begin(), treedat.end(), inf);\n\t}\n};\n\nint n, q;\n\nint main(void)\n{\n\tscanf(\"%lld %lld\", &n, &q);\n\tsegment_tree rmq(n);\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\trmq.update(j, make_pair((long long)0, j));\n\t}\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tif (b != 1)return -1;\n\t\tauto ret = rmq.query(0, a);\n\t\trmq.update_inc(ret.second);\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tint64 ans = rmq.peek(j);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid M. Note that constructing this tree requires the identity\n * element of M and the operation of M.\n * Header requirement: vector, algorithm\n * Verified by AtCoder ABC017-D (http://abc017.contest.atcoder.jp/submissions/660402)\n */\ntemplate<class I, class BiOp = I (*) (I, I)>\nclass SegTree {\n  int n;\n  std::vector<I> dat;\n  BiOp op;\n  I e;\npublic:\n  SegTree(int n_, BiOp op, I e) : op(op), e(e) {\n    n = 1;\n    while (n < n_) { n *= 2; } // n is a power of 2\n    dat.resize(2 * n);\n    for (int i = 0; i < 2 * n - 1; i++) {\n      dat[i] = e;\n    }\n  }\n  /* ary[k] <- v */\n  void update(int k, I v) {\n    k += n - 1;\n    dat[k] = v;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = op(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  void update_array(int k, int len, const I *vals) {\n    for (int i = 0; i < len; ++i) {\n      update(k + i, vals[i]);\n    }\n  }\n  /*\n    Updates all elements. O(n)\n   */\n  void update_all(const I *vals, int len) {\n    for (int k = 0; k < std::min(n, len); ++k) {\n      dat[k + n - 1] = vals[k];\n    }\n    for (int k = std::min(n, len); k < n; ++k) {\n      dat[k + n - 1] = e;\n    }\n    for (int b = n / 2; b >= 1; b /= 2) {\n      for (int k = 0; k < b; ++k) {\n\tdat[k + b - 1] = op(dat[k * 2 + b * 2 - 1], dat[k * 2 + b * 2]);\n      }\n    }\n  }\n  /* l,r are for simplicity */\n  I querySub(int a, int b, int k, int l, int r) const {\n    // [a,b) and  [l,r) intersects?\n    if (r <= a || b <= l) return e;\n    if (a <= l && r <= b) return dat[k];\n    I vl = querySub(a, b, 2 * k + 1, l, (l + r) / 2);\n    I vr = querySub(a, b, 2 * k + 2, (l + r) / 2, r);\n    return op(vl, vr);\n  }\n  /* [a, b] (note: inclusive) */\n  I query(int a, int b) const {\n    return querySub(a, b + 1, 0, 0, n);\n  }\n};\n\n\nstruct min_fun {\n  int operator() (int a, int b) const {\n    return min(a, b);\n  }\n};\n\nint main(void){\n  int n, q;\n  cin >> n >> q;\n  SegTree<int, min_fun> st(n, min_fun(), 1e9);\n  REP(i, 0, n) {\n    st.update(i, 0);\n  }\n  VI dp(n, 0);\n  REP(i, 0, q) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    assert (b == 1);\n    int mi = st.query(0, a);\n    int lo = -1, hi = a;\n    while (hi - lo > 1) {\n      int mid = (hi + lo) / 2;\n      if (st.query(0, mid) == mi) {\n\thi = mid;\n      } else {\n\tlo = mid;\n      }\n    }\n    dp[hi]++;\n    st.update(hi, dp[hi]);\n  }\n  REP(i, 0, n) {\n    cout << dp[i] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define IL inline\n#define lt p<<1\n#define rt p<<1|1\n#define N 100003\n#define REP(a,b,c) for(a=b;a<=c;a++)\nusing namespace std;\ntypedef long long lol;\nconst lol inf=(~0ULL)>>1;\nint n,q;\nint t[N<<2];\nlol tag[N<<2],h[N<<2];\nIL int rd(){\n\tint res=0;char c;while((c=getchar())<'0'||c>'9');\n\twhile(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();return res;\n}\nIL lol rl(){\n\tlol res=0;char c;while((c=getchar())<'0'||c>'9');\n\twhile(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();return res;\n}\nIL void build(int p,int l,int r){\n\tt[p]=l;if(l==r)return;int mid=(l+r)>>1;\n\tbuild(lt,l,mid),build(rt,mid+1,r);\n}\nIL void pushdown(int p){\n\tif(tag[p])h[lt]+=tag[p],h[rt]+=tag[p],tag[lt]+=tag[p],tag[rt]+=tag[p],tag[p]=0;\n}\nIL void output(int p,int l,int r){\n\tif(l==r){printf(\"%lld\\n\",h[p]);return;}\n\tint mid=(l+r)>>1;pushdown(p);output(lt,l,mid),output(rt,mid+1,r);\n}\nint mix;lol mih;\nIL void query(int p,int l,int r,int x){\n\tint mid;mix=0,mih=inf;\n\tif(!x)return;\n\twhile(l!=r){\n\t\tif(t[p]<=x){if(h[p]<mih)mix=t[p],mih=h[p];return;}\n\t\tpushdown(p);mid=(l+r)>>1;\n\t\t(x<=mid)?(r=mid,p=lt):(h[lt]<mih?(mix=t[lt],mih=h[lt]):0,l=mid+1,p=rt);\n\t}\n\tif(h[p]<mih)mix=l,mih=h[p];\n}\nIL void add(int p,int l,int r,int L,int R,lol v){\n\tif(L<=l && R>=r){h[p]+=v,tag[p]+=v;return;}\n\tpushdown(p);int mid=(l+r)>>1;\n\tif(L<=mid)add(lt,l,mid,L,R,v);if(R>mid)add(rt,mid+1,r,L,R,v);\n\th[lt]<=h[rt]?(t[p]=t[lt],h[p]=h[lt]):(t[p]=t[rt],h[p]=h[rt]);\n}\nint main(){\n  n=rd(),q=rd();int i,x,xx;lol y,hh,dt;\n\tbuild(1,1,n);\n  REP(i,1,q){\n\t\tx=rd(),y=rl();\n\t\tquery(1,1,n,x);\n\t\txx=mix,hh=mih;\n\t\twhile(y){\n\t\t\tdt=y/(x-xx+1);\n\t\t\tquery(1,1,n,xx-1);\n\t\t\tif(dt>=mih-hh){\n\t\t\t\tdt=mih-hh;add(1,1,n,xx,x,dt);y-=dt*(x-xx+1);\n\t\t\t\txx=mix,hh=mih;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tadd(1,1,n,xx,x,dt);y-=dt*(x-xx+1);\n\t\t\t\tif(y)add(1,1,n,xx,xx+y-1,1),y=0;\n\t\t\t}\n\t\t}\n\t}\n\toutput(1,1,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nmap<int,int> data;\n\nint counter(int idx){\n\tauto nx = data.upper_bound(idx);\n\tauto it = --nx;\n\treturn it->second;\n}\n\nvoid debug(){\n\tfor( auto i : data ) cout << i.first << \" \" << i.second << endl;\n\tcout << \"_____\" << endl;\n}\nint query(int idx,int b){\n\t//cout << idx << \" \" << b << endl;\n\t//cout << \"++++\" << endl;\n\t//debug();\n\t\n\tauto nx = data.upper_bound(idx);\n\tauto it = nx;--it;\n\t//cout << it->first << endl;\n\t//cout << b+1 << \" \" << nx->first << endl;\n\tif( idx+1 < nx->first ){\n\t\tdata[idx+1] = it->second;\n\t}\n\tauto nx2 = data.upper_bound(idx);\n\tint len = nx2->first - it->first;\n\tauto pr = it;\n\tpr--;\n\tint diff = pr->second - it->second;\n\t//cout << diff << \"<<\" << endl;\n\tif( pr->first >= 0 and diff * len <= b ){\n\t\tdata.erase(it);\n\t\treturn b - diff * len;\n\t}else{\n\t\tint all = b / len;\n\t\tint part = b % len;\n\t\t//cout << all << \" \" << part << endl;\n\t\tif( all + 1 == pr->second ){\n\t\t\tif( part ){\n\t\t\t\tdata[it->first+part] = it->second + all;\n\t\t\t\tdata.erase(it);\n\t\t\t}else{\n\t\t\t\tit->second = it->second + all;\n\t\t\t}\n\t\t}else{\n\t\t\tif(part){\n\t\t\t\tdata[it->first+part] = it->second + all;\n\t\t\t\tit->second = it->second + all + 1;\n\t\t\t}else{\n\t\t\t\tit->second = it->second + all;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint N,Q;\n\tcin >> N >> Q;\n\tdata[-1] = 1e18;\n\tdata[0] = 0;\n\tdata[N] = -1;\n\t\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a;\n\t\twhile(b = query(a,b));\n\n\t}\n\t\n\tfor(int i = 0 ; i < N ; i++){\n\t\tcout << counter(i) << endl;\n\t} \n}"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tif(Q<100&&N<100){\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tMin(a[i],1000000000000,0);\n\t\t}\n\t}\n\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%ld\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\nusing ll = long long;\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\ntemplate <typename Base>\nclass LazySeg\n{\n    static std::size_t SZ(const std::size_t n)\n    {\n        std::size_t ans = 1;\n        for (; ans < n; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using BaseAlgebra = Base;\n    using ValMonoid = typename BaseAlgebra::ValMonoid;\n    using OpMonoid = typename BaseAlgebra::OpMonoid;\n    using T = typename BaseAlgebra::VT;\n    using F = typename BaseAlgebra::OT;\n    LazySeg(const std::size_t n) : size(n), half(SZ(n)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id()) {}\n    template <typename InIt>\n    LazySeg(const InIt first, const InIt last) : size(std::distance(first, last)), half(SZ(size)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id())\n    {\n        copy(first, last, value.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    T get(const std::size_t a) const { return accumulate(a, a + 1); }\n    void set(std::size_t a, const T& val)\n    {\n        modify(a, a + 1, OpMonoid::id()), value[a += half] = val;\n        while (a >>= 1) { up(a); }\n    }\n    T accumulate(const std::size_t L, const std::size_t R) const\n    {\n        auto arec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> T {\n            if (L <= left and right <= R) {\n                return value[index];\n            } else if (right <= L or R <= left) {\n                return ValMonoid::id();\n            } else {\n                return act(action[index], acc(self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right)));\n            }\n        };\n        return arec(arec, 1, 0, half);\n    }\n    void modify(const std::size_t L, const std::size_t R, const F& f)\n    {\n        auto mrec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> void {\n            if (L <= left and right <= R) {\n                this->update(index, f);\n            } else if (right <= L or R <= left) {\n            } else {\n                this->update(index << 1, action[index]), this->update(index << 1 | 1, action[index]);\n                self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right);\n                this->up(index), action[index] = OpMonoid::id();\n            }\n        };\n        mrec(mrec, 1, 0, half);\n    }\n    template <typename Pred>\n    std::size_t partitionPoint(const std::size_t L, const std::size_t R, const Pred& pred) const\n    {\n        this->accumulate(L, R);\n        auto prec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right, const T& offset) -> std::pair<T, std::size_t> {\n            if (right <= L or R <= left or pred(acc(offset, act(action[index], value[index])))) { return {ValMonoid::id(), R}; }\n            if (index >= half) { return {act(action[index], value[index]), index - half}; }\n            const std::pair<T, std::size_t> lans = self(self, index << 1, left, (left + right) >> 1, act(action[index], offset));\n            if (lans.second != R) { return lans; }\n            return self(self, index << 1 | 1, (left + right) >> 1, right, act(action[index], acc(offset, lans.first)));\n        };\n        return prec(prec, 1, 0, half, ValMonoid::id()).second;\n    }\n\n    std::vector<T> data() const\n    {\n        std::vector<T> ans(size);\n        for (std::size_t i = 0; i < size; i++) { ans[i] = get(i); }\n        return ans;\n    }\n\nprivate:\n    void up(const std::size_t i) { value[i] = acc(value[i << 1], value[i << 1 | 1]); }\n    void update(const std::size_t i, const F& f) { value[i] = act(f, value[i]), action[i] = compose(f, action[i]); }\n    const std::size_t size, half;\n    std::vector<T> value;\n    std::vector<F> action;\n    const ValMonoid acc{};\n    const OpMonoid compose{};\n    const BaseAlgebra act{};\n};\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const LazySeg<T>& seg)\n{\n    os << \"[\";\n    for (const auto& e : seg.data()) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 4; }\ntemplate <typename VX = ll, typename OX = ll>\nstruct MAct\n{\n    struct VT\n    {\n        VX max, sum;\n        std::size_t L, R;\n    };\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return VT{std::max(a.max, b.max), a.sum + b.sum, std::min(a.L, b.L), std::max(a.R, b.R)}; }\n        static constexpr VT id() { return {-INF<VX>(), (VX)0, INF<std::size_t>(), 0UL}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<OT>() ? VT{f, f * VX(x.R - x.L), x.L, x.R} : x; }\n};\nint main()\n{\n    std::size_t N, Q;\n    std::cin >> N >> Q;\n    LazySeg<MAct<ll, ll>> seg(N);\n    using VT = typename MAct<ll, ll>::VT;\n    for (std::size_t i = 0; i < N; i++) { seg.set(i, {0, 0, i, i + 1}); }\n    for (std::size_t q = 0; q < Q; q++) {\n        std::size_t A;\n        ll B;\n        std::cin >> A >> B;\n        auto pred = [&](const VT& v) {\n            const std::size_t l = v.L, r = v.R;\n            const ll H = v.max, res = H * (r - N + A) - v.sum;\n            return res < B;\n        };\n        const std::size_t p = seg.partitionPoint(N - A, N, pred);\n        const ll rect = seg.accumulate(N - A, p).sum + B, H = rect / (p - N + A), mod = rect % (p - N + A);\n        seg.modify(N - A, p, H);\n        if (mod != 0) { seg.modify(p - mod, p, H + 1); }\n    }\n    for (std::size_t i = 0; i < N; i++) { std::cout << seg.get(N - i - 1).max << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nint n, q;\nll a[100001];\nvector<ii> range;\nconst ll INF = ll(3e18);\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>n>>q;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint x; ll y;\n\t\tcin>>x>>y;\n\t\tx--;\n\t\tll sum = 0;\n\t\tfor(int j = x; j >= 0; j--)\n\t\t{\n\t\t\tll l = INF;\n\t\t\tif(j > 0)\n\t\t\t{\n\t\t\t\tl = a[j-1];\n\t\t\t}\n\t\t\tsum += a[j];\n\t\t\tif(l >= INF || y <= ll(x-j+1)*l - sum)\n\t\t\t{\n\t\t\t\tfor(int k = x; k >= j; k--)\n\t\t\t\t{\n\t\t\t\t\ty -= (a[j] - a[k]);\n\t\t\t\t\ta[k] = a[j];\n\t\t\t\t}\n\t\t\t\tll add = y/(x-j+1);\n\t\t\t\tll rem = y%(x-j+1);\n\t\t\t\tfor(int k = j; k <= x; k++)\n\t\t\t\t{\n\t\t\t\t\tif(k - j < rem)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[k]+=add+1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ta[k]+=add;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcout<<a[i]<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// <sushi.cpp> - Sat Mar 25 08:49:56 2017\n// This file is created by XuYike's black technology automatically.\n// Copyright (C) 2015 ChangJun High School, Inc.\n// I don't know what this program is.\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef long long lol;\ntemplate<typename T>\ninline void gg(T &res){\n    res=0;T fh=1;char ch=getchar();\n    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();\n    if(ch=='-')fh=-1,ch=getchar();\n    while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();\n    res*=fh;\n}\ninline int gi(){int x;gg(x);return x;}\ninline lol gl(){lol x;gg(x);return x;}\nconst int MAXN=100010;\nconst int MAXK=MAXN<<2;\nconst lol INF=1e18;\nint n,pos[MAXN];\nlol val[MAXK],lazy[MAXK],mi[MAXK];\ninline void update(int x){\n    val[x]=val[x<<1]+val[x<<1|1];\n    mi[x]=min(mi[x<<1],mi[x<<1|1]);\n}\nvoid pushdown(int x,int l,int r){\n    if(!lazy[x])return;\n    int m=l+r>>1;\n    val[x<<1]=(m-l+1)*lazy[x];\n    val[x<<1|1]=(r-m)*lazy[x];\n    mi[x<<1]=mi[x<<1|1]=lazy[x<<1]=lazy[x<<1|1]=lazy[x];\n    lazy[x]=0;\n}\nlol getsum(int L,int R,int l=1,int r=n,int x=1){\n    if(l==L&&r==R)return val[x];\n    pushdown(x,l,r);\n    int m=l+r>>1;lol ans=0;\n    if(L<=m)ans+=getsum(L,min(R,m),l,m,x<<1);\n    if(R>m)ans+=getsum(max(L,m+1),R,m+1,r,x<<1|1);\n    return ans;\n}\nint find(int p,lol s,lol y,int l=1,int r=n,int x=1){\n    if(l==r)return l;\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    if(p<=m||s-val[x<<1]+y>mi[x<<1]*(p-m))return find(p,s,y,l,m,x<<1);\n    return find(p,s-val[x<<1],y,m+1,r,x<<1|1);\n}\nvoid set(int L,int R,lol v,int l=1,int r=n,int x=1){\n    if(L>R)return;\n    if(l==L&&r==R){\n        val[x]=(r-l+1)*v;\n        lazy[x]=mi[x]=v;\n        return;\n    }\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    if(L<=m)set(L,min(R,m),v,l,m,x<<1);\n    if(R>m)set(max(L,m+1),R,v,m+1,r,x<<1|1);\n    update(x);\n}\nvoid dfs(int l,int r,int x){\n    if(l==r){printf(\"%lld\\n\",val[x]);return;}\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    dfs(l,m,x<<1);\n    dfs(m+1,r,x<<1|1);\n}\nint main(){\n    n=gi();int m=gi();\n    while(m--){\n        int x=gi();\n        lol s=getsum(1,x),y=gl();\n        int p=find(x,s,y);s=getsum(p,x);\n        set(p,x,(y+s)/(x-p+1));\n        set(p,p+(y+s)%(x-p+1)-1,(y+s)/(x-p+1)+1);\n    }\n    dfs(1,n,1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    ll sum, val;\n};\n\nstruct IT {\nprivate:\n    vector<Node> t;\n    int n;\n\n    void propagate(int id, int l, int r) {\n        ll &x = t[id].val;\n        if (x != -1) {\n            int m = (l+r)/2;\n            t[2*id].val = t[2*id+1].val = x;\n            t[2*id].sum = (m-l+1)*x;\n            t[2*id+1].sum = (r-m)*x;\n            x = -1;\n        }\n    }\n\n    void update(int id, int l, int r, int i, int j, ll x) {\n        if (l > j || r < i) return;\n        if (i <= l && r <= j) {\n            t[id].val = x;\n            t[id].sum = (r-l+1)*x;\n            return;\n        }\n        propagate(id, l, r);\n        int m = (l+r)/2;\n        update(2*id, l, m, i, j, x); update(2*id+1, m+1, r, i, j, x);\n        t[id].sum = t[2*id].sum + t[2*id+1].sum;\n    }\n\n    long long query(int id, int l, int r, int i, int j) {\n        if (l > j || r < i) return 0;\n        if (i <= l && r <= j) return t[id].sum;\n        propagate(id, l, r);\n        int m = (l+r)/2;\n        return query(2*id, l, m, i, j) + query(2*id+1, m+1, r, i, j);\n    }\n\npublic:\n    IT(int n): n(n) {t.assign(4*n+1, {0, -1});}\n\n    void update(int i, int j, ll x) {update(1, 1, n, i, j, x);}\n\n    long long query(int i, int j) {return query(1, 1, n, i, j);}\n};\n\nint main () {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    IT t(n);\n\n    for(int i = 0; i < q; ++i) {\n        int r; ll p;\n        scanf(\"%d%lld\", &r, &p);\n\n        int lo = 1, hi = r-1, l = r;\n        while (lo <= hi) {\n            int mid = (lo + hi)/2;\n            ll aMid = t.query(mid, mid);\n            ll x = (r-mid+1)*aMid - t.query(mid, r);\n\n            if (x <= p) {\n                l = mid;\n                hi = mid-1;\n            } else\n                lo = mid+1;\n        }\n\n        ll aL = t.query(l, l);\n        p -= (r-l+1) * aL - t.query(l, r);\n\n        ll aNew = aL + p/(r-l+1);\n        int m = l + p%(r-l+1) - 1;\n        t.update(l, m, aNew + 1);\n        t.update(m + 1, r, aNew);\n    }\n\n    for(int i = 1; i <= n; ++i)\n        printf(\"%lld\\n\", t.query(i, i));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n >> q;\n    //cout << n << \" \" << q << endl;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, TEN(15)));\n    s.insert(P(n-1, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;\n            if (a == pr.first) s.erase(pr);\n            if (pl.second-pr.second <= b/d) {\n                s.erase(pl);\n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {                \n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                if (pr.second + (b+d-1)/d == pl.second) {\n                    s.erase(pl);\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct T{\n    int l,r,x;\n    T(int a,int b,int c):l(a),r(b),x(c){}\n    bool operator<(const T &t)const{\n        if(t.l!=l)return l<t.l;\n        if(t.r!=r)return r<t.r;\n        return x<t.x;\n    }\n};\n\nsigned main(){\n    int N,Q;\n    scanf(\"%lld%lld\",&N,&Q);\n    set<T>s;\n    s.insert(T(0,N,0));\n    s.insert(T(N,1001001001,1001001001));\n    while(Q--){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n        auto it=s.lower_bound(T(a,-1,-1));\n        if(it->l!=a){\n            it--;\n            int l=it->l,r=it->r,x=it->x;\n            s.erase(it);\n            s.insert(T(l,a,x));\n            s.insert(T(a,r,x));\n        }\n\n        while(b){\n            it=s.lower_bound(T(a,-1,-1));\n            it--;\n            bool isend=false;\n            if(it==s.begin())isend=true;\n            else{\n                auto jt=it;\n                jt--;\n                if((jt->x-it->x)*(it->r-it->l)>b)isend=true;\n            }\n            int l=it->l,r=it->r,x=it->x;\n            if(isend){\n                s.erase(it);\n                x+=b/(it->r-it->l);\n                b%=(it->r-it->l);\n                if(b){\n                    s.insert(T(l,l+b,x+1));\n                    s.insert(T(l+b,r,x));\n                }\n                else{\n                    s.insert(T(l,r,x));\n                }\n                b=0;\n            }\n            else{\n                auto jt=it;\n                jt--;\n                b-=(jt->x-it->x)*(it->r-it->l);\n                l=jt->l;\n                x=jt->x;\n                s.erase(it);s.erase(jt);\n                s.insert(T(l,r,x));\n            }\n        }\n    }\n\n    each(it,s){\n        if(it->l==N)break;\n        rep(i,it->r-it->l)printf(\"%lld\\n\",it->x);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n    char ch = getchar(); int x = 0;\n    while(ch < '0' || ch > '9') ch = getchar();\n    while(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n    return x;\n}\n\n\nconst ll INF = 1e17;\n\nstruct seg {\n    int l, r;\n    ll v;\n\n    seg() {}\n    seg(int a, int b, ll c): l(a), r(b), v(c) {}\n    bool operator <(const seg &b) const {\n        return l < b.l;\n    }\n};\n\nset <seg> s;\nset <seg>:: iterator it;\nvector <seg> del, ins;\n\nvoid print() {\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n            printf(\"(%d %d %lld) \", it->l, it->r, it->v);\n    printf(\"\\n\");\n}\n\nvoid work() {\n    ll y = read(), x = read();\n    it = s.upper_bound(seg(y, 0, 0)), --it;\n    if(y+1 <= it->r) ins.push_back(seg(y+1, it->r, it->v));\n    del.push_back(*it);\n\n    int nl = it->l, nr = y, nv = it->v;\n    for(--it; 1LL*(nr-nl+1)*(it->v-nv) < x;) {\n        x -= 1LL*(nr-nl+1)*(it->v-nv);\n        del.push_back(*it);\n        nl = it->l, nv = it->v, --it;\n    }\n\n    nv += x / (nr-nl+1);\n    x  %= (nr-nl+1), nl = it->r+x+1;\n    if(nl <= nr) ins.push_back(seg(nl, nr, nv));\n    if(it->r < nl-1) ins.push_back(seg(it->r+1, nl-1, nv+1));\n\n    for(int i = 0; i < del.size(); ++i) s.erase(del[i]);\n    for(int i = 0; i < ins.size(); ++i) s.insert(ins[i]);\n    del.clear();\n    ins.clear();\n    //print();\n}\n\n\nint n, q;\nint main() {\n    n = read(), q = read();\n\n    s.insert(seg(0, 0, INF));\n    s.insert(seg(1, n, 0));\n\n    while(q--) work();\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n        for(int j = it->l; j <= it->r; ++j)\n            printf(\"%lld\\n\", it->v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cstdio>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ninline ll read() {\n    char ch = getchar(); ll x = 0;\n    while(ch < '0' || ch > '9') ch = getchar();\n    while(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n    return x;\n}\n\n\nconst ll INF = 2e13 + 5;\nconst int N = 1e5+5;\n\nstruct seg {\n    int l, r;\n    ll v;\n\n    seg() {}\n    seg(int a, int b, ll c): l(a), r(b), v(c) {}\n    bool operator <(const seg &b) const {\n        return l < b.l;\n    }\n};\n\nset <seg> s;\nset <seg>:: iterator it;\nseg del[N], ins[N];\n\nint t1, t2;\nvoid work() {\n    ll y = read(), x = read();\n    it = s.upper_bound(seg(y, 0, 0)), --it;\n    if(y+1 <= it->r) ins[++t1] = (seg(y+1, it->r, it->v));\n    del[++t2] = (*it);\n\n    int nl = it->l, nr = y; ll nv = it->v;\n    for(--it; 1LL*(nr-nl+1)*(it->v-nv) < x && it != s.begin();) {\n        x -= 1LL*(nr-nl+1)*(it->v-nv);\n        del[++t2] = (*it);\n        nl = it->l, nv = it->v, --it;\n    }\n\n    nv += x / (nr-nl+1);\n    x  %= (nr-nl+1), nl = it->r+x+1;\n    if(nl <= nr) ins[++t1] = (seg(nl, nr, nv));\n    if(it->r < nl-1) ins[++t1] = (seg(it->r+1, nl-1, nv+1));\n\n    for(int i = 1; i <= t2; ++i) s.erase(del[i]);\n    for(int i = 1; i <= t1; ++i) s.insert(ins[i]);\n    t1 = t2 = 0;\n}\n\n\nint n, q;\nint main() {\n    n = read(), q = read();\n\n    s.insert(seg(0, 0, INF));\n    s.insert(seg(1, n, 0));\n\n    while(q--) work();\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n        for(int j = it->l; j <= it->r; ++j)\n            printf(\"%lld\\n\", it->v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    ll sum, val;\n};\n\nstruct IT {\nprivate:\n    vector<Node> t;\n    int n;\n\n    void propagate(int id, int l, int r) {\n        ll &x = t[id].val;\n        if (x != -1) {\n            int m = (l+r)/2;\n            t[2*id].val = t[2*id+1].val = x;\n            t[2*id].sum = (m-l+1)*x;\n            t[2*id+1].sum = (r-m)*x;\n            x = -1;\n        }\n    }\n\n    void update(int id, int l, int r, int i, int j, ll x) {\n        if (l > j || r < i) return;\n        if (i <= l && r <= j) {\n            t[id].val = x;\n            t[id].sum = (r-l+1)*x;\n            return;\n        }\n        propagate(id, l, r);\n        int m = (l+r)/2;\n        update(2*id, l, m, i, j, x); update(2*id+1, m+1, r, i, j, x);\n        t[id].sum = t[2*id].sum + t[2*id+1].sum;\n    }\n\n    long long query(int id, int l, int r, int i, int j) {\n        if (l > j || r < i) return 0;\n        if (i <= l && r <= j) return t[id].sum;\n        propagate(id, l, r);\n        int m = (l+r)/2;\n        return query(2*id, l, m, i, j) + query(2*id+1, m+1, r, i, j);\n    }\n\npublic:\n    IT(int n): n(n) {t.assign(4*n+1, {0, -1});}\n\n    void update(int i, int j, ll x) {update(1, 1, n, i, j, x);}\n\n    long long query(int i, int j) {return query(1, 1, n, i, j);}\n};\n\nint main () {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n\n    IT t(n);\n\n    for(int i = 0; i < q; ++i) {\n        int a; ll b;\n        scanf(\"%d%lld\", &a, &b);\n\n        int lo = 1, hi = a-1, res = a;\n        while (lo <= hi) {\n            int mid = (lo + hi)/2;\n            ll tMid = t.query(mid, mid);\n            ll x = (a-mid+1)*tMid - t.query(mid, a);\n\n            if (x <= b) {\n                res = mid;\n                hi = mid-1;\n            } else\n                lo = mid+1;\n        }\n\n        ll tRes = t.query(res, res);\n        b -= (a-res+1) * tRes - t.query(res, a);\n\n        ll tA = tRes + b/(a-res+1);\n        int extra = b%(a-res+1);\n        int lastExtra = res + extra - 1;\n        t.update(res, lastExtra, tA + 1);\n        t.update(lastExtra + 1, a, tA);\n    }\n\n    for(int i = 1; i <= n; ++i)\n        printf(\"%lld\\n\", t.query(i, i));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 10;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\t/*struct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}*/ \n\tlint tree[MAXN];\n\tinline void buildtree(int root, int l, int r) {\n\t\t\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\trep (i, l, r) {\n\t\t\ttree[i] = c;\n\t\t}\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tlint ret = 0;\n\t\trep (i, l, r) {\n\t\t\tret += tree[i];\n\t\t}\n\t\treturn ret; \n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace std;\n\nconst int maxn = 1E5 + 10;\nconst int T = 4;\ntypedef long long LL;\n\nint n,Q;\nLL x,y,Sum[maxn*T],Cov[maxn*T];\n\nLL getLL()\n{\n\tchar ch = getchar(); LL ret = 0;\n\twhile (ch < '0' || '9' < ch) ch = getchar();\n\twhile ('0' <= ch && ch <= '9')\n\t\tret = ret * 10LL + 1LL * (ch - '0'),ch = getchar();\n\treturn ret;\n}\n\nchar s[20];\nvoid Print(LL k)\n{\n\tif (!k) {puts(\"0\"); return;} int len = 0;\n\twhile (k) s[++len] = k % 10LL,k /= 10LL;\n\tfor (int i = len; i; i--) putchar(s[i] + '0'); puts(\"\");\n}\n\nvoid pushdown(int o,int l,int r)\n{\n\tif (!Cov[o]) return;\n\tSum[o] = 1LL * (r - l + 1) * Cov[o];\n\tif (l == r) {Cov[o] = 0; return;}\n\tCov[o<<1] = Cov[o<<1|1] = Cov[o]; Cov[o] = 0;\n}\n\nvoid Search(int o,int l,int r,int pos)\n{\n\tpushdown(o,l,r);\n\tif (l == r) {x = Sum[o]; return;}\n\tint mid = l + r >> 1;\n\tif (pos <= mid) Search(o<<1,l,mid,pos);\n\telse Search(o<<1|1,mid+1,r,pos);\n}\n\nvoid Query(int o,int l,int r,int ql,int qr)\n{\n\tpushdown(o,l,r);\n\tif (ql <= l && r <= qr)\n\t{\n\t\tif (l == ql) Search(o,l,r,ql);\n\t\ty += Sum[o]; return;\n\t}\n\tint mid = l + r >> 1;\n\tif (ql <= mid) Query(o<<1,l,mid,ql,qr);\n\tif (qr > mid) Query(o<<1|1,mid+1,r,ql,qr);\n}\n\nvoid Cover(int o,int l,int r,int ql,int qr,LL k)\n{\n\tif (ql <= l && r <= qr)\n\t{\n\t\tCov[o] = k; pushdown(o,l,r); return;\n\t}\n\tint mid = l + r >> 1; pushdown(o,l,r);\n\tif (ql <= mid) Cover(o<<1,l,mid,ql,qr,k); else pushdown(o<<1,l,mid);\n\tif (qr > mid) Cover(o<<1|1,mid+1,r,ql,qr,k); else pushdown(o<<1|1,mid+1,r);\n\tSum[o] = Sum[o<<1] + Sum[o<<1|1];\n}\n\nvoid Print_All(int o,int l,int r)\n{\n\tpushdown(o,l,r);\n\tif (l == r) {Print(Sum[o]); return;}\n\tint mid = l + r >> 1;\n\tPrint_All(o<<1,l,mid); Print_All(o<<1|1,mid+1,r);\n}\n\nbool Judge(int now,int pos,LL tot)\n{\n\ty = 0; Query(1,1,n,now,pos);\n\tLL sum = 1LL * (pos - now + 1) * x;\n\treturn sum - y <= tot;\n}\n\nvoid Work(int now,int pos,LL &tot)\n{\n\ty = 0; Query(1,1,n,now,pos);\n\tLL sum = 1LL * (pos - now + 1) * x;\n\ttot -= (sum - y); Cover(1,1,n,now,pos,x);\n}\n\nint main()\n{\n\t#ifdef DMC\n\t\tfreopen(\"DMC.txt\",\"r\",stdin);\n\t#endif\n\t\n\tn = getLL(); Q = getLL();\n\twhile (Q--)\n\t{\n\t\tint pos = getLL();\n\t\tLL tot = getLL(); int l = 1,r = pos;\n\t\twhile (r - l > 1)\n\t\t{\n\t\t\tint mid = l + r >> 1;\n\t\t\tif (Judge(mid,pos,tot)) r = mid;\n\t\t\telse l = mid;\n\t\t}\n\t\tint now = Judge(l,pos,tot) ? l : r;\n\t\tWork(now,pos,tot); if (!tot) continue;\n\t\tLL len = pos - now + 1; Search(1,1,n,now);\n\t\tif (tot >= len) Cover(1,1,n,now,pos,x + tot / len);\n\t\tif (tot % len != 0)\n\t\t{\n\t\t\tSearch(1,1,n,now);\n\t\t\tCover(1,1,n,now,now + (tot % len) - 1,x + 1LL);\n\t\t}\n\t}\n\tPrint_All(1,1,n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\n/* LazyPropagationSegmentTree(Sum) */\n//0-index\n\nstruct LazySeg_sum{\n  typedef ll Type;\n  \n  struct Data{\n    Type val;\n    Type add;\n    Type sum;\n    bool valset;\n    \n    Type calc_sum(int l, int r){\n      if(valset){\n        return (val + add) * (r - l + 1);\n      }else{\n        return sum + add * (r - l + 1);\n      }\n    }\n\n    void set_data(Type x,Type y){\n      val = x;\n      add = y;\n      valset = true;\n    }\n\n    void add_data(int x){\n      add += x;\n    }\n    \n    Data():val(0),add(0),sum(0),valset(false){}\n    \n  };\n\n  vector<Data> data;\n  int seg_size;\n  \n  LazySeg_sum(int n){\n    for(seg_size=1; seg_size < n; seg_size*=2);\n    data.assign(seg_size*2, Data());\n  }\n\n  Type set(int a, int b, Type x, int l=0, int r=-1,int k=0){\n    if(r == -1) r = seg_size-1;\n    \n    if(a <= l && r <= b){\n      data[k].set_data(x,0);\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n    \n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val+data[k].add,0);\n      data[k*2+2].set_data(data[k].val+data[k].add,0);\n    }else{\n      data[k*2+1].add_data(data[k].add);\n      data[k*2+2].add_data(data[k].add);      \n    }\n\n    data[k].add = 0;\n    \n    data[k].valset = false;\n    \n    data[k].sum = set(a,b,x,l,(l+r)/2,k*2+1) + set(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n\n  Type add(int a, int b, Type x, int l=0, int r=-1, int k=0){\n    if(r == -1) r = seg_size-1;\n\n    if(a <= l && r <= b){\n      data[k].add += x;\n      return data[k].calc_sum(l,r);\n    }\n\n    if(r < a || b < l) return data[k].calc_sum(l,r);\n\n    if(data[k].valset){\n      data[k*2+1].set_data(data[k].val, data[k].add);\n      data[k*2+2].set_data(data[k].val, data[k].add);\n      data[k].add = 0;\n      data[k].valset = false;\n    }\n\n    data[k].sum = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n\n    return data[k].calc_sum(l,r);\n  }\n  \n  Type query(int a, int b, int l=0, int r=-1, int k = 0){\n    if(r == -1) r = seg_size-1;\n\n    if(r < a || b < l) return 0;\n\n    if((a <= l && r <= b) || data[k].valset){\n      return data[k].calc_sum(max(a,l),min(b,r));\n    }\n\n    return query(a,b,l,(l+r)/2,k*2+1) + query(a,b,(l+r)/2+1,r,k*2+2) +\n           data[k].add * (min(b,r) - max(a,l) + 1);\n  }\n  \n};\n\nLazySeg_sum seg(100000);\n\nint main(){\n  int n,q,a,b;\n\n  scanf(\"%d%d\",&n,&q);\n\n  \n  for(int i=0;i<q;i++){\n    scanf(\"%d%d\",&a,&b);\n    a--;\n\n    if(a == 0){\n      seg.add(0,0,b);\n      continue;\n    } \n    \n    int l=1,r=a,mid;\n    ll u,p;\n    \n    while(l < r){\n\n      mid = (l+r)/2;\n\n      u = seg.query(mid-1,mid-1);\n      \n      p = seg.query(mid,a);\n\n      if((u * (a-mid+1) - p) > b){\n        l = mid+1;\n      }else{\n        r = mid;\n      }\n    }\n    \n    p = seg.query(l,a);\n    u = seg.query(l-1,l-1);\n\n    while( b < u*(a-l+1) - p ) u--;\n    \n    b -= u*(a-l+1) - p;\n    seg.set(l,a,u);\n    \n    seg.add(l-1,a,b/(a-(l-1)+1));\n    b%=(a-(l-1)+1);\n    \n    if(b > 0)\n      seg.add(l-1,b-1+(l-1),1);\n  }\n  \n  for(int i=0;i<n;i++){\n    printf(\"%lld\\n\",seg.query(i,i));\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <cassert>\n#define SIZE 100005\n#define LINF 1000000000000000005LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\ntypedef pair <P,ll> PP;\n\nint main()\n{\n\tint n,q;\n\tscanf(\"%d %d\",&n,&q);\n\tset <PP> st;\n\tset <PP>::iterator it;\n\tst.insert(PP(P(0,n-1),0));\n\tPP dm=PP(P(-1,-1),-1);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint a;\n\t\tll b;\n\t\tscanf(\"%d %lld\",&a,&b);a--;\n\t\twhile(1)\n\t\t{\n\t\t\tit=st.lower_bound(PP(P(a+1,-1),-1));\n\t\t\tit--;\n\t\t\tPP p=*it;\n\t\t\tPP q=dm;\n\t\t\tif(it!=st.begin())\n\t\t\t{\n\t\t\t\tit--;\n\t\t\t\tq=*it;\n\t\t\t\tit++;\n\t\t\t}st.erase(it);\n\t\t\tif(p.first.second>a) st.insert(PP(P(a+1,p.first.second),p.second));\n\t\t\tp.first.second=a;\n\t\t\tif(q!=dm&&(q.second-p.second)*(ll) (p.first.second-p.first.first+1)<=b)\n\t\t\t{\n\t\t\t\tb-=(q.second-p.second)*(ll) (p.first.second-p.first.first+1);\n\t\t\t\tst.erase(q);\n\t\t\t\tst.insert(PP(P(q.first.first,p.first.second),q.second));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp.second+=b/(ll) (p.first.second-p.first.first+1);\n\t\t\t\tb%=(ll) (p.first.second-p.first.first+1);\n\t\t\t\tif(b>0)\n\t\t\t\t{\n\t\t\t\t\tst.insert(PP(P(p.first.first,p.first.first+(int) b-1),p.second+1));\n\t\t\t\t\tp.first.first+=(int) b;\n\t\t\t\t}st.insert(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(it=st.begin();it!=st.end();it++)\n\t{\n\t\tPP p=*it;\n\t\tP s=p.first;\n\t\tfor(int i=s.first;i<=s.second;i++) printf(\"%lld\\n\",p.second);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 18) + 10;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l > r) for(;;);\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l > r) for(;;);\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t/*lint tree[MAXN];\n\tinline void buildtree(int root, int l, int r) {\n\t\t\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\trep (i, l, r) {\n\t\t\ttree[i] = c;\n\t\t}\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tlint ret = 0;\n\t\trep (i, l, r) {\n\t\t\tret += tree[i];\n\t\t}\n\t\treturn ret; \n\t}*/\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\nusing ll = long long;\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\ntemplate <typename Base>\nclass LazySeg\n{\n    static std::size_t SZ(const std::size_t n)\n    {\n        std::size_t ans = 1;\n        for (; ans < n; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using BaseAlgebra = Base;\n    using ValMonoid = typename BaseAlgebra::ValMonoid;\n    using OpMonoid = typename BaseAlgebra::OpMonoid;\n    using T = typename BaseAlgebra::VT;\n    using F = typename BaseAlgebra::OT;\n    LazySeg(const std::size_t n) : size(n), half(SZ(n)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id()) {}\n    template <typename InIt>\n    LazySeg(const InIt first, const InIt last) : size(std::distance(first, last)), half(SZ(size)), value(half << 1, ValMonoid::id()), action(half << 1, OpMonoid::id())\n    {\n        copy(first, last, value.begin() + half);\n        for (std::size_t i = half - 1; i >= 1; i--) { up(i); }\n    }\n    T get(const std::size_t a) const { return accumulate(a, a + 1); }\n    void set(std::size_t a, const T& val)\n    {\n        modify(a, a + 1, OpMonoid::id()), value[a += half] = val;\n        while (a >>= 1) { up(a); }\n    }\n    T accumulate(const std::size_t L, const std::size_t R) const\n    {\n        auto arec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> T {\n            if (L <= left and right <= R) {\n                return value[index];\n            } else if (right <= L or R <= left) {\n                return ValMonoid::id();\n            } else {\n                return act(action[index], acc(self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right)));\n            }\n        };\n        return arec(arec, 1, 0, half);\n    }\n    void modify(const std::size_t L, const std::size_t R, const F& f)\n    {\n        auto mrec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right) -> void {\n            if (L <= left and right <= R) {\n                this->update(index, f);\n            } else if (right <= L or R <= left) {\n            } else {\n                this->update(index << 1, action[index]), this->update(index << 1 | 1, action[index]);\n                self(self, index << 1, left, (left + right) >> 1), self(self, index << 1 | 1, (left + right) >> 1, right);\n                this->up(index), action[index] = OpMonoid::id();\n            }\n        };\n        mrec(mrec, 1, 0, half);\n    }\n    std::vector<T> data() const\n    {\n        std::vector<T> ans(size);\n        for (std::size_t i = 0; i < size; i++) { ans[i] = get(i); }\n        return ans;\n    }\n    template <typename Pred>\n    std::size_t partitionPoint(const std::size_t L, const std::size_t R, const Pred& pred)\n    {\n        this->modify(L, R, OpMonoid::id());\n        auto prec = [&](auto&& self, const std::size_t index, const std::size_t left, const std::size_t right, const T& offset) -> std::pair<T, std::size_t> {\n            if (right <= L or R <= left or pred(acc(offset, act(action[index], value[index])))) { return {ValMonoid::id(), R}; }\n            if (index >= half) { return {act(action[index], value[index]), index - half}; }\n            const std::pair<T, std::size_t> lans = self(self, index << 1, left, (left + right) >> 1, offset);\n            if (lans.second != R) { return lans; }\n            return self(self, index << 1 | 1, (left + right) >> 1, right, acc(offset, lans.first));\n        };\n        return prec(prec, 1, 0, half, ValMonoid::id()).second;\n    }\n\n    void debug() const\n    {\n        for (std::size_t i = 1; i <= half; i *= 2) {\n            for (std::size_t j = i; j < 2 * i; j++) { std::cout << \"(\" << value[j] << \",\" << action[j] << \"),\"; }\n            std::cout << std::endl;\n        }\n    }\n\nprivate:\n    void up(const std::size_t i) { value[i] = acc(value[i << 1], value[i << 1 | 1]); }\n    void update(const std::size_t i, const F& f) { value[i] = act(f, value[i]), action[i] = compose(f, action[i]); }\n    const std::size_t size, half;\n    std::vector<T> value;\n    std::vector<F> action;\n    const ValMonoid acc{};\n    const OpMonoid compose{};\n    const BaseAlgebra act{};\n};\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const LazySeg<T>& seg)\n{\n    os << \"[\";\n    for (const auto& e : seg.data()) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T>\nconstexpr T INF() { return std::numeric_limits<T>::max() / 4; }\ntemplate <typename VX = ll, typename OX = ll>\nstruct MAct\n{\n    struct VT\n    {\n        VX max, sum;\n        std::size_t L, R;\n    };\n    struct ValMonoid\n    {\n        VT operator()(const VT& a, const VT& b) const { return VT{std::max(a.max, b.max), a.sum + b.sum, std::min(a.L, b.L), std::max(a.R, b.R)}; }\n        static constexpr VT id() { return {-INF<VX>(), (VX)0, INF<std::size_t>(), 0UL}; }\n    };\n    using OT = OX;\n    struct OpMonoid\n    {\n        OT operator()(const OT& f1, const OT& f2) const { return f1 != INF<OT>() ? f1 : f2; }\n        static constexpr OT id() { return INF<OT>(); }\n    };\n    VT operator()(const OT& f, const VT& x) const { return f != INF<OT>() ? VT{f, f * VX(x.R - x.L), x.L, x.R} : x; }\n};\nint main()\n{\n    std::size_t N, Q;\n    std::cin >> N >> Q;\n    LazySeg<MAct<ll, ll>> seg(N);\n    using VT = typename MAct<ll, ll>::VT;\n    for (std::size_t i = 0; i < N; i++) { seg.set(i, {0, 0, i, i + 1}); }\n    for (std::size_t q = 0; q < Q; q++) {\n        std::size_t A;\n        ll B;\n        std::cin >> A >> B;\n        auto pred = [&](const VT& v) {\n            const std::size_t l = v.L, r = v.R;\n            const ll H = v.max, res = H * (r - N + A) - v.sum;\n            return res < B;\n        };\n        const std::size_t p = seg.partitionPoint(N - A, N, pred);\n        const ll rect = seg.accumulate(N - A, p).sum + B, H = rect / (p - N + A), mod = rect % (p - N + A);\n        seg.modify(N - A, p, H);\n        if (mod != 0) { seg.modify(p - mod, p, H + 1); }\n    }\n    for (std::size_t i = 0; i < N; i++) { std::cout << seg.get(N - i - 1).max << std::endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tif(Q<=100&&N<=100){\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tMin(a[i],9223372036854775806,0);\n\t\t}\n\t}\n\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%ld\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME],val[1<<ME];\n\tV total(int e) {V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tV add(int e,V v) { val[e++]+=v; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n\tV set(int e,V v) { add(e,v-val[e]);}\n\tint lower_bound(V val) {\n\t\tV tv=0; int i,ent=0;\n\t\tfor(i=ME-1;i>=0;i--) if(tv+bit[ent+(1<<i)-1]<val) tv+=bit[ent+(1<<i)-1],ent+=(1<<i);\n\t\treturn ent;\n\t}\n};\n\nint N,Q;\nll A,B;\nBIT<ll,18> bit;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tbit.add(N,2LL*10000000000001LL);\n\tFOR(i,Q) {\n\t\tcin>>A>>B;\n\t\tx=N-A;\n\t\twhile(B) {\n\t\t\tll xv=bit.total(x);\n\t\t\ty = bit.lower_bound(xv+1);\n\t\t\tll yv=bit.total(y);\n\t\t\t\n\t\t\t\n\t\t\tif(B>=(yv-xv)*(y-x)) {\n\t\t\t\tB -= (yv-xv)*(y-x);\n\t\t\t\tbit.add(x,yv-xv);\n\t\t\t\tbit.add(y,-(yv-xv));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbit.add(x,B/(y-x));\n\t\t\t\tbit.add(y,-B/(y-x));\n\t\t\t\tB %= (y-x);\n\t\t\t\tbit.add(y-B,1);\n\t\t\t\tbit.add(y,-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tFOR(i,N) cout<<bit.total(N-1-i)<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\n\nint N, Q;\nlong long int a;\nlong long int b;\nlong long int num[100001];\nbool flag[100001];\nlong long int section[101] ;\nlong long int sum;\nlong long int start;\n\nbool CheckBefore(long long int num) {\n\tif (section[num/1000] > 0) {\n\t\tfor (long long int i = num; i >= (num /1000)*1000; i--) {\n\t\t\tif (flag[i]) {\n\t\t\t\tstart = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (long long int i = num / 1000 - 1; i >= 0; i--) {\n\t\t\tif (section[i] > 0) {\n\t\t\t\tfor (long long int j = i * 1000 + 999; j >= i*1000; j--) {\n\t\t\t\t\tif (flag[j]) {\n\t\t\t\t\t\tstart = j;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> a >> b;\n\t\twhile (b != 0) {\n\t\t\tif (CheckBefore(a)) {\n\t\t\t\tif (num[start] * (a - start + 1)*(-1) < b) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[a + 1] += num[start];\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb += num[start] * (a - start + 1);\n\t\t\t\t\t\tnum[start] = 0;\n\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b % (a - start + 1) == 0) {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1))!=0) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1);\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t\t\tnum[a + 1] -= b / (a - start + 1);\n\t\t\t\t\t\t\tif (flag[a + 1] == false&&(b/(a-start+1)!=0)) {\n\t\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnum[start] += b / (a - start + 1) + 1;\n\t\t\t\t\t\t\tif (num[start] == 0) {\n\t\t\t\t\t\t\t\tflag[start] = false;\n\t\t\t\t\t\t\t\tsection[start / 1000]--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[start + b % (a - start + 1)]--;\n\t\t\t\t\t\t\tflag[start + b % (a - start + 1)] = true;\n\t\t\t\t\t\t\tsection[(start + b % (a - start + 1)) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b % a == 0) {\n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tif (a != N) {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t\tnum[a + 1] -= b / a;\n\t\t\t\t\t\tif (flag[a + 1] == false&&b/a!=0) {\n\t\t\t\t\t\t\tflag[a + 1] = true;\n\t\t\t\t\t\t\tsection[(a + 1) / 1000]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnum[1] += b / a + 1;\n\t\t\t\t\t\tnum[1 + b % a]--;\n\t\t\t\t\t\tflag[1 + b % a] = true;\n\t\t\t\t\t\tsection[(1 + b % a) / 1000]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsum += num[i];\n\t\tcout << sum << \"\\n\";\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#define mp  make_pair\nusing namespace std;\n\ntypedef long long  LL;\ntypedef pair <int,LL>  PIL;\ntypedef set <PIL>::iterator  Iter;\nint n,q;\nset <PIL> S;\n\nIter pre(Iter x){x--;  return x;}\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tS.insert(mp(0,1LL<<40)),S.insert(mp(1,0)),S.insert(mp(n+1,-1));\n\tfor (int i=1,a,l; i<=q; i++)\n\t\t{\n\t\t\tLL b;\n\t\t\tscanf(\"%d %lld\",&a,&b),a++;\n\t\t\tIter x=pre(S.upper_bound(mp(a,1LL<<60))),y;\n\t\t\tif ((*x).first!=a)\n\t\t\t\t{\n\t\t\t\t\tif (a-(*x).first>=b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((*pre(x)).second==(*x).second+1)\n\t\t\t\t\t\t\t\tS.erase(x),S.insert(mp((*x).first+b,(*x).second));\n\t\t\t\t\t\t\telse  S.insert(mp((*x).first+b,(*x).second)),S.insert(mp((*x).first,(*x).second+1)),S.erase(x);\n\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t}else  x=(S.insert(mp(a,(*x).second))).first;\n\t\t\t\t}\n\t\t\twhile (b>0)\n\t\t\t\t{\n\t\t\t\t\ty=pre(x),l=a-(*y).first;\n\t\t\t\t\tif (((*pre(y)).second-(*y).second)*l>=b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (b%l)  S.insert(mp((*y).first+b%l,(*y).second+b/l));\n\t\t\t\t\t\t\tS.insert(mp((*y).first,(*y).second+(b+l-1)/l)),S.erase(y);\n\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t}else\n\t\t\t\t\t\tb-=((*pre(y)).second-(*y).second)*l,S.erase(y);\n\t\t\t\t}\n\t\t}\n\tfor (Iter x=S.begin(),y; x!=S.end(); y=x,x++)\n\t\tif ((*x).first>1)\n\t\t\tfor (int i=(*y).first; i<(*x).first; i++)\n\t\t\t\tprintf(\"%lld\\n\",(*y).second);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nsigned main(){\n    int N,Q;\n    cin>>N>>Q;\n\n    set<pint>st;\n    st.insert({0ll,20000000000000ll+1});\n    st.insert({N,0});\n\n    while(Q--){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n\n        while(b){\n\n            auto it=st.lower_bound({a,-1});\n            int r,c;\n            tie(r,c)=*it;\n\n            if(r!=a){\n                st.erase(it);\n                st.insert({a,c});\n                st.insert({r,c});\n                continue;\n            }\n\n            it--;\n            int rr,cc;\n            tie(rr,cc)=*it;\n\n            if(b>=(cc-c)*(r-rr)){\n                b-=(cc-c)*(r-rr);\n                st.erase({r,c});\n                st.erase({rr,cc});\n                st.insert({r,cc});\n            }\n            else{\n                st.erase({r,c});\n                if(b%(r-rr))st.insert({rr+b%(r-rr),c+b/(r-rr)+1});\n                st.insert({r,c+b/(r-rr)});\n                b=0;\n            }\n        }\n    }\n\n\n    int pre=0;\n    for(auto &p:st){\n        for(;pre<p.fi;pre++)cout<<p.se<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <map>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n, q, ans;\nLL num[100001];\nstd::map<LL, LL> m; // pos, num\n\nvoid ins(LL x, LL y) {\n\tauto result = m.insert(std::make_pair(x, y));\n\tif( ! result.second) {\n\t\tresult.first -> second = y;\n\t}\n}\n\nvoid test() {\n\tfor(auto it = m.begin(); it != m.end(); it++) {\n\t\tprintf(\"<%lld, %lld> \", it->first, it->second);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\t\n\tm.insert(std::make_pair(-1, 20000000000001LL));\n\tm.insert(std::make_pair(n, 0));\n\tinc(t, q) {\n\t\tint a;\n\t\tLL b;\n\t\tscanf(\"%d%lld\", &a, &b);\n\t\t\n\t\tint ccc = 0;\n\t\twhile(b > 0) {\n\t\t\tauto it2 = m.lower_bound(a - 1); \n\t\t\tauto it = it2; it--;\n\t\t\tLL x = (it -> first);\n\t\t\tLL y = (it -> second);\n\t\t\tLL ny = (it2 -> second);\n\t\t\tLL d = a - 1 - x;\n\t\t\tLL s = d * (y - ny);\n\t\t\t\n\t\t\t\n\t\t\t//ccc++; if(ccc > 20) { return 1; }\n\t\t\t//test();\n\t\t\t//printf(\"lb: <%lld, %lld>\\n\", it->first, it->second);\n\t\t\t//printf(\"t: %d, ccc: %d, xy: <%lld, %lld>, ny: %lld, d: %lld, s: %lld\\n\", t, ccc, x, y, ny, d, s);\n\t\t\t\n\t\t\t\n\t\t\tif(b > s) {\n\t\t\t\tm.erase(x);\n\t\t\t\tins(a - 1, y);\n\t\t\t} else {\n\t\t\t\tif(b > s - d) { m.erase(x); } ins((b - 1) % d + 1 + x, (b - 1) / d + 1 + ny);\n\t\t\t\tif(b > d && b % d != 0) { ins(a - 1, (b - 1) / d + ny); }\n\t\t\t}\n\t\t\t\n\t\t\tb -= s;\n\t\t}\n\t}\n\t\n\tauto it = m.begin();\n\tinc(i, n) {\n\t\twhile(i > (it -> first)) { it++; }\n\t\tprintf(\"%lld\\n\", it -> second);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <array>\n#include <limits>\n#define _USE_MATH_DEFINES\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define FORCLS(i,a,b) for(int i = (a); i <= (b); i++)\n#define REPCLS(i,n) FORCLS(i,1,n)\n// For debug\n#ifdef _DEBUG\n#define DD(x) cerr << #x << \":\" << x << endl;\n#define DDA(ary) \\\ncerr << #ary << \":\" << endl;\\\nfor (auto v : ary) { cerr << v << \",\"; }\\\ncerr << endl;\n#else\n#define DD(x)\n#define DDA(ary)\n#endif\n\nusing IntType = long long;\nusing CntAndNo = pair<IntType, IntType>;\nconst int MAX = 100005;\nIntType cnts[MAX];\nint ps[MAX];\nint n, q;\nint main() {\n\tcin >> n >> q;\n\tREP(i, n) {\n\t\tps[i] = 0;\n\t}\n\tcnts[0] = numeric_limits<IntType>::max();\n\tREP(qi, q) {\n\t\t//REPCLS(i, n) {\n\t\t//\tcout << i << \":\" << cnts[i] << \",\" << ps[i] << endl;\n\t\t//}\n\t\t//cout << \"---\" << endl;\n\t\tIntType a, b;\n\t\tcin >> a >> b;\n\t\twhile (0 < b) {\n\t\t\tint r = a + 1; // [l,r)\n\t\t\tint l = ps[a] + 1;\n\t\t\tint len = r - l;\n\t\t\tIntType v1 = b / len;\n\t\t\tIntType v2 = cnts[ps[a]] - cnts[l];\n\t\t\tif (v1 < v2) {\n\t\t\t\tif (v1 == 0) {\n\t\t\t\t\tint q = b % len;\n\t\t\t\t\tint newp = (v2 == 1) ? ps[ps[a]] : ps[a];\n\t\t\t\t\tFOR(i, l, l + q) {\n\t\t\t\t\t\tcnts[i] += 1;\n\t\t\t\t\t\tps[i] = newp;\n\t\t\t\t\t}\n\t\t\t\t\tFOR(i, l + q, r) {\n\t\t\t\t\t\tps[i] = l + q - 1;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = r; cnts[i] == cnts[r - 1] && i <= n; i++) {\n\t\t\t\t\t\tps[i] = l + q - 1;\n\t\t\t\t\t}\n\t\t\t\t\tb -= q;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tFOR(i, l, r) {\n\t\t\t\t\t\tcnts[i] += v1;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = r; cnts[i] == cnts[r] && i <= n; i++) {\n\t\t\t\t\t\tps[i] = r - 1;\n\t\t\t\t\t}\n\t\t\t\t\tb -= v1 * len;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint newp = ps[ps[a]];\n\t\t\t\tFOR(i, l, r) {\n\t\t\t\t\tcnts[i] += v2;\n\t\t\t\t\tps[i] = newp;\n\t\t\t\t}\n\t\t\t\tfor (int i = r; cnts[i] == cnts[r] && i <= n; i++) {\n\t\t\t\t\tps[i] = r - 1;\n\t\t\t\t}\n\t\t\t\tb -= v2 * len;\n\t\t\t}\n\t\t}\n\t}\n\tREPCLS(i, n) {\n\t\tcout << cnts[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 F / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int h, n;\n\tvector<T1> data;\n\tvector<T2> lazy;\n\tvoid push(int node) {\n\t\tif (lazy[node] == M::id2()) return;\n\t\tif (node < n) {\n\t\t\tlazy[node * 2] = M::op3(lazy[node * 2], lazy[node]);\n\t\t\tlazy[node * 2 + 1] = M::op3(lazy[node * 2 + 1], lazy[node]);\n\t\t}\n\t\tdata[node] = M::op2(data[node], lazy[node]);\n\t\tlazy[node] = M::id2();\n\t}\n\tvoid update(int node) {\n\t\tdata[node] = M::op1(M::op2(data[node * 2], lazy[node * 2]), M::op2(data[node * 2 + 1], lazy[node * 2 + 1]));\n\t}\npublic:\n\tlazy_segment_tree(int n_)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n * 2, M::id1()), lazy(n * 2, M::id2()) {}\n\tlazy_segment_tree(int n_, T1 v1)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n * 2, v1), lazy(n * 2, M::id2()) {}\n\tlazy_segment_tree(const vector<T1>& data_)\n\t\t: h(ceil(log2(data_.size()))), n(1 << h), data(n * 2, M::id1()), lazy(n * 2, M::id2()) {\n\t\tinit(data_);\n\t}\n\tvoid init() {\n\t\tfor (int i = n - 1; i >= 1; i--) data[i] = M::op1(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid init(const vector<T1>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++) data[i + n] = data_[i];\n\t\tinit();\n\t}\n\tvoid update(int l, int r, T2 val) {\n\t\tr--;\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tint tl = l, tr = r;\n\t\tr++;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) lazy[l] = M::op3(lazy[l], val), l++;\n\t\t\tif (r & 1) r--, lazy[r] = M::op3(lazy[r], val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\twhile (tl >>= 1, tr >>= 1, tl) {\n\t\t\tif (lazy[tl] == M::id2()) update(tl);\n\t\t\tif (lazy[tr] == M::id2()) update(tr);\n\t\t}\n\t}\n\tT1 query(int l, int r) {\n\t\tr--;\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tr++;\n\t\tT1 res1 = M::id1(), res2 = M::id1();\n\t\twhile (l < r) {\n\t\t\tif (l & 1) res1 = M::op1(res1, M::op2(data[l], lazy[l])), l++;\n\t\t\tif (r & 1) r--, res2 = M::op1(M::op2(data[r], lazy[r]), res2);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn M::op1(res1, res2);\n\t}\n};\n\nstruct M {\n\tusing ll = long long;\n\tstruct t1 {\n\t\tll val, size;\n\t\tt1(ll v, ll s = 1) : val(v), size(s) {}\n\t};\n\tusing t2 = ll;\n\tstatic t1 id1() { return t1(0, 0); }\n\tstatic t2 id2() { return -LINF; }\n\tstatic t1 op1(const t1& l, const t1& r) { return t1(l.val + r.val, l.size + r.size); }\n\tstatic t1 op2(const t1& l, const t2& r) {\n\t\tif (r == id2()) {\n\t\t\treturn l;\n\t\t}\n\t\treturn t1(l.size * r, l.size);\n\t}\n\tstatic t2 op3(const t2& l, const t2& r) { return r != id2() ? r : l; }\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tLL N, Q; cin >> N >> Q;\n\tvector<M::t1>init_data(N, M::t1(0, 1));\n\tlazy_segment_tree<M> seg(init_data);\n\n\tauto print = [&]() {\n\t\treturn;\n\t\tDD(\n\t\t\tFOR(i, 0, N) {\n\t\t\tcout << seg.query(i, i + 1).val << \" \\n\"[i + 1 == N];\n\t\t}\n\t\t)\n\t};\n\tprint();\n\tFOR(_, 0, Q) {\n\t\tLL a, b; cin >> a >> b;\n\t\tLL L = -1, R = a;\n\t\twhile (R - L > 1) {\n\t\t\tLL mid = (R + L) / 2;\n\t\t\tLL v = seg.query(mid, mid + 1).val;\n\t\t\tif (v*(a - mid) - seg.query(mid, a).val <= b) {\n\t\t\t\tR = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL = mid;\n\t\t\t}\n\t\t}\n\t\tLL v = seg.query(R, R + 1).val;\n\t\tb -= v * (a - R) - seg.query(R, a).val;\n\t\tv += b / (a - R); // delta\n\t\tb %= (a - R); // mod\n\t\tseg.update(R, R + b, v + 1);\n\t\tseg.update(R + b, a, v);\n\n\t\tprint();\n\n\t}\n\n\n\n\tFOR(i, 0, N) {\n\t\tcout << seg.query(i, i + 1).val << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstring>\n#define lch (x<<1)\n#define rch ((x<<1)|1)\ntypedef long long ll;\nconst int N=100005;\nint n,m;\nll mn[N<<2],tag[N<<2];\nusing namespace std;\n\nvoid modify(int x,ll v){tag[x]+=v,mn[x]+=v;}\nvoid updtag(int x){if (tag[x]) modify(lch,tag[x]),modify(rch,tag[x]),tag[x]=0;}\nint find(int x,int L,int R,int l,int r,ll v)\n{\n\tif (L<R) updtag(x);\n\tif (L==R) return L;\n\tint mid=L+R>>1;\n\tif (mid>=r) return find(lch,L,mid,l,r,v);\n\tif (mn[lch]<=v) return find(lch,L,mid,l,r,v);\n\treturn find(rch,mid+1,R,l,r,v);\n}\nll query(int x,int l,int r,int p)\n{\n\tif (l<r) updtag(x);\n\tif (l==r) return mn[x];\n\tint mid=l+r>>1;\n\tif (mid>=p) return query(lch,l,mid,p);\n\treturn query(rch,mid+1,r,p);\n}\nvoid update(int x,int L,int R,int l,int r,ll v)\n{\n\tif (L<R) updtag(x);\n\tif (L>=l && R<=r){modify(x,v);return;}\n\tif (L>r || R<l) return;\n\tint mid=L+R>>1;\n\tupdate(lch,L,mid,l,r,v);\n\tupdate(rch,mid+1,R,l,r,v);\n\tmn[x]=mn[rch];\n}\nvoid calc(int x,int l,int r)\n{\n\tif (l<r) updtag(x);\n\tif (l==r){printf (\"%lld\\n\",mn[x]);return;}\n\tint mid=l+r>>1;\n\tcalc(lch,l,mid),calc(rch,mid+1,r);\n}\nint main()\n{\n\t#ifdef Kay\n\t\tfreopen (\"s8pc_3_f.in\",\"r\",stdin);\n\t\tfreopen (\"s8pc_3_f.out\",\"w\",stdout);\n\t#endif\n\tscanf (\"%d %d\",&n,&m);\n\tint pos;ll tot;\n\twhile (m--)\n\t{\n\t\tscanf (\"%d %lld\",&pos,&tot);\n\t\twhile (tot)\n\t\t{\n\t\t\tll val=query(1,1,n,pos);\n\t\t\tint las=find(1,1,n,1,pos,val);\n\t\t\tif (las==1)\n\t\t\t{\n\t\t\t\tupdate(1,1,n,1,pos,tot/pos),tot%=pos;\n\t\t\t\tif (tot) update(1,1,n,1,tot,1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tll lv=query(1,1,n,las-1);\n\t\t\tll add=min(lv-val,tot/(pos-las+1));\n\t\t\tupdate(1,1,n,las,pos,add),tot-=add*(pos-las+1);\n\t\t\tval+=add;\n\t\t\tif (val<lv && tot){update(1,1,n,las,las+tot-1,1);break;}\n\t\t}\n\t}\n\tcalc(1,1,n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint s[100000];\nint n,q,a,b;\nint BNS(int key,int right){\n\tint i=0;\n\twhile(true){\n\t\tif(s[i]==key)return i;\n\t\ti++;\n\t}\n}\nint main(){\n\tcin>>n>>q;\n\tfor(int i=0;i<n;i++)s[i]=0;\n\tfor(int i=0;i<q;i++){\n\t\tcin>>a>>b;\n\t\tif(b!=1)return 0;\n\t\ta--;\n\t\ts[BNS(s[a],a+1)]++;\n\t}\n\tfor(int i=0;i<n;i++)cout<<s[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\nmain() {\n    int64_t n, q;\n    cin >> n >> q;\n\n    map<int64_t, int64_t> m;\n    m[0] = 0;\n    m[n] = -1;\n  \n    for (auto i : irange(0L, q)) {\n        int64_t a, b;\n        cin >> a >> b;\n\n        auto it = m.lower_bound(a);\n        if (it == m.end() || a < it->first) {\n            --it;\n            auto v = it->second;\n            it = m.emplace(a, v).first;\n        }\n        --it;\n        while (it != m.begin()) {\n            auto previt = it;\n            --previt;\n            int64_t d = (previt->second - it->second) * (a - it->first);\n            if (d <= b) {\n                b -= d;\n                m.erase(it--);\n            } else {\n                break;\n            }\n        }\n        it->second += b / (a - it->first);\n        b %= a - it->first;\n        if (b > 0) {\n            m.emplace(it->first + b, it->second);\n            it->second += 1;\n        }\n    }\n  \n    for (auto i : irange(0L, n)) {\n        cout << (--m.upper_bound(i))->second << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nll a[MAX_N], b[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    rep(i,q){\n        cin >> a[i] >> b[i];\n    }\n    set<P> st = {P(0,0)};\n    rep(i,q){\n        auto it = st.lower_bound(P(a[i], -INF));\n        bool flag = (it == st.end() || it->fi != a[i]);\n        auto it2 = --it;\n        ll flag2 = it2->se;\n        // each(p,st){\n        //     spair(p);\n        // }\n        // cout << \"===================\\n\";\n        if(it2 == st.begin()){\n            P p = *it2;\n            st.erase(it2);\n            ll x = b[i] / a[i], y = b[i] % a[i];\n            if(y == 0){\n                st.insert(P(p.fi,p.se+x));\n            }else{\n                st.insert(P(p.fi,p.se+x+1));\n                st.insert(P(p.fi+y,p.se+x));\n            }\n        }else{\n            do {\n                P p = *it2, q = *(--it2);\n                ++it2;\n                // spair((*it2));\n                st.erase(it2);\n                ll cri = (a[i]-p.fi)*(q.se-p.se);\n                if(b[i] >= cri){\n                    b[i] -= cri;\n                }else{\n                    ll x = b[i] / (a[i]-p.fi), y = b[i] % (a[i]-p.fi);\n                    // cout << x << \" \" << y << endl;\n                    if(y == 0){\n                        st.insert(P(p.fi,p.se+x));\n                    }else{\n                        if(q.se != p.se+x+1){\n                            st.insert(P(p.fi,p.se+x+1));\n                        }\n                        st.insert(P(p.fi+y,p.se+x));\n                        // spair(P(p.fi,p.se+x+1)), spair(P(p.fi+y,p.se+x));\n                    }\n                    b[i] = 0;\n                }\n                // each(p,st){\n                //     spair(p);\n                // }\n                // cout << \"-------------------\\n\";\n                it = st.lower_bound(P(a[i], -INF));\n                it2 = --it;\n                // show(b[i]);\n            }while(it2 != st.begin() && b[i] > 0);\n            if(b[i] > 0){\n                P p = *it2;\n                st.erase(it2);\n                ll x = b[i] / a[i], y = b[i] % a[i];\n                if(y == 0){\n                    st.insert(P(p.fi,p.se+x));\n                }else{\n                    st.insert(P(p.fi,p.se+x+1));\n                    st.insert(P(p.fi+y,p.se+x));\n                }\n            }\n        }\n        if(flag){\n            st.insert(P(a[i],flag2));\n        }\n    }\n    // each(p,st){\n    //     spair(p);\n    // }\n    // cout << \"-------------------\\n\";\n    int s = 0, prv = -1;\n    each(p,st){\n        if(p.fi > 0){\n            srep(i,s,p.fi){\n                cout << prv << \"\\n\";\n            }\n        }\n        s = p.fi, prv = p.se;\n    }\n    srep(i,s,n){\n        cout << prv << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tfor(int i=0;i<Q;i++){\n\t\tMin(a[i],1000000,0);\n\t}\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%id\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sum(x,y) que(1,1,n,x,y)\n#define change(x,y,z) chan(1,1,n,x,y,z)\n#define add(x,y,z) Plus(1,1,n,x,y,z)\n#define mid (l+r>>1)\nusing namespace std;\nlong long sum[400000],fg[400000],ad[400000];\nlong long n,m,a,b; \nvoid down(int now,int l,int r)\n{\n    if(fg[now])\n    {\n        fg[now]+=ad[now];\n        fg[now<<1]=fg[now];\n        fg[now<<1|1]=fg[now];\n        ad[now]=ad[now<<1]=ad[now<<1|1]=fg[now]=0;\n        sum[now<<1]=fg[now<<1]*(mid-l+1);\n        sum[now<<1|1]=fg[now<<1|1]*(r-mid);\n    }\n    if(ad[now])\n    {\n        ad[now<<1]+=ad[now];\n        ad[now<<1|1]+=ad[now];\n        sum[now<<1]+=ad[now]*(mid-l+1);\n        sum[now<<1|1]+=ad[now]*(r-mid);\n        ad[now]=0; \n    }\n}\nvoid updata(int now)\n{\n    sum[now]=sum[now<<1]+sum[now<<1|1];\n}\nvoid chan(int now,int l,int r,int x,int y,long long z)\n{\n    if(l==x && r==y)\n    {\n        fg[now]=z;\n        ad[now]=0;\n        sum[now]=z*(r-l+1);\n        return;\n    }\n    down(now,l,r);\n    if(x<=mid)\n        chan(now<<1,l,mid,x,min(mid,y),z);\n    if(y>mid)\n        chan(now<<1|1,mid+1,r,max(mid+1,x),y,z);\n    updata(now);\n}\nvoid Plus(int now,int l,int r,int x,int y,long long z)\n{\n    if(l==x && r==y)\n    {\n        ad[now]+=z;\n        sum[now]+=z*(r-l+1);\n        return;\n    }\n    down(now,l,r);\n    if(x<=mid)\n        Plus(now<<1,l,mid,x,min(mid,y),z);\n    if(y>mid)\n        Plus(now<<1|1,mid+1,r,max(mid+1,x),y,z);\n    updata(now);\n}\nlong long que(int now,int l,int r,int x,int y)\n{\n    if(l==x && r==y)\n        return sum[now];\n    down(now,l,r);\n    long long ret=0;\n    if(x<=mid)\n        ret+=que(now<<1,l,mid,x,min(y,mid));\n    if(y>mid)\n        ret+=que(now<<1|1,mid+1,r,max(x,mid+1),y);\n    return ret;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%lld\",&a,&b);\n        int l=1,r=a;\n        for(;l<r;)\n            if(sum(mid,mid)*(a-mid+1)-sum(mid,a)<=b)\n                r=mid;\n            else\n                l=mid+1;\n        b-=sum(l,l)*(a-l+1)-sum(l,a);\n        change(l,a,sum(l,l));\n        add(l,a,b/(a-l+1));\n        if(b%(a-l+1))\n        add(l,l+b%(a-l+1)-1,1);\n    }\n    for(int i=1;i<=n;i++)\n        printf(\"%lld\\n\",sum(i,i));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong n,q,idx;\nlong long val,lazy[1000005],st_max[1000005],st_sum[1000005];\nvoid update(long id,long l,long r,long i,long j,long long x){\n\tif(lazy[id]!=0){\n\t\tst_max[id]=lazy[id];\n\t\tst_sum[id]=(r-l+1)*lazy[id];\n\t\tif(l<r){\n\t\t    lazy[2*id]=lazy[id];\n\t\t    lazy[2*id+1]=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n\tif(l>j||r<i||i>j){\n\t\treturn;\n\t}\n\tif(l>=i&&r<=j){\n\t\tst_max[id]=x;\n\t\tst_sum[id]=(r-l+1)*x;\n\t\tif(l<r){\n\t\t    lazy[2*id]=x;\n\t\t    lazy[2*id+1]=x;\n\t\t}    \n\t\treturn;\n\t}\n\tlong mid=(l+r)/2;\n\tupdate(2*id,l,mid,i,j,x);\n\tupdate(2*id+1,mid+1,r,i,j,x);\n\tst_max[id]=max(st_max[2*id],st_max[2*id+1]);\n\tst_sum[id]=st_sum[2*id]+st_sum[2*id+1];\n}\nlong long get_max(long id,long l,long r,long i,long j){\n\tif(lazy[id]!=0){\n\t\tst_max[id]=lazy[id];\n\t\tst_sum[id]=(r-l+1)*lazy[id];\n\t\tif(l<r){\n\t\t    lazy[2*id]=lazy[id];\n\t\t    lazy[2*id+1]=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n\tif(l>j||r<i||i>j){\n\t\treturn -1e18;\n\t}\n\tif(l>=i&&r<=j){\n\t\treturn st_max[id];\n\t}\n\tlong mid=(l+r)/2;\n\treturn max(get_max(2*id,l,mid,i,j),get_max(2*id+1,mid+1,r,i,j));\n}\nlong long get_sum(long id,long l,long r,long i,long j){\n\tif(lazy[id]!=0){\n\t\tst_max[id]=lazy[id];\n\t\tst_sum[id]=(r-l+1)*lazy[id];\n\t\tif(l<r){\n\t\t    lazy[2*id]=lazy[id];\n\t\t    lazy[2*id+1]=lazy[id];\n\t\t}\n\t\tlazy[id]=0;\n\t}\n\tif(l>j||r<i||i>j){\n\t\treturn 0;\n\t}\n\tif(l>=i&&r<=j){\n\t\treturn st_sum[id];\n\t}\n\tlong mid=(l+r)/2;\n\treturn get_sum(2*id,l,mid,i,j)+get_sum(2*id+1,mid+1,r,i,j);\n}\nlong search(long l,long r,long i,long long val){\n\twhile(l<r){\n\t\tlong mid=(l+r)/2;\n\t\tif((get_max(1,1,n,mid,i)*(i-mid+1)-get_sum(1,1,n,mid,i))<=val){\n\t\t\tr=mid;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\treturn l;\n}\nint main(){\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin>>n>>q;\n\tfor(int vl=1;vl<=q;vl++){\n\t\tcin>>idx>>val;\n\t\tlong pos=search(1,idx,idx,val);\n\t\tlong long dm=get_max(1,1,n,pos,idx);\n\t\tlong long dm3=idx-pos+1;\n\t\tval-=dm*dm3-get_sum(1,1,n,pos,idx);\n\t\tupdate(1,1,n,pos,idx,dm);\n\t\tlong long dm1=val/dm3;\n\t\tlong long dm2=val%dm3;\n\t\tupdate(1,1,n,pos,idx,dm+dm1);\n\t\tupdate(1,1,n,pos,pos+dm2-1,dm+dm1+1);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcout<<get_max(1,1,n,i,i)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n \n \nstruct st {\n\tint id, cnt;\n};\nbool operator<(st a, st b) {\n\tif (a.cnt == b.cnt)return a.id > b.id;\n\treturn a.cnt > b.cnt;\n}\nint cnt[1000000];\n \nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tpriority_queue<st>que;\n\tfor (int i = 1; i <= n; i++) que.push({ i,0 });\n\trep(i, q) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tif(b!=1)abort();\n\t\twhile (!que.empty()&&cnt[que.top().id] != que.top().cnt)que.pop();\n\t\tdeque<st>Q;\n\t\twhile(que.top().id>a){\n\t\t\tQ.push_back(que.top());que.pop();\n\t\t}\n\t\tst s=que.top();que.pop();\n\t\tcnt[s.id]++;\n\t\tque.push({ s.id,cnt[s.id] });\n\t\tfor(st i:Q)que.push(i);\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d\\n\", cnt[i]);\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, long long> P2;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, Q;\nlong long A[100000];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> Q;\n  set<P2> S;\n  S.insert(P2(P(0, N-1), 0));\n  rep(i, Q) {\n    int a;\n    long long b;\n    cin >> a >> b;\n    a--;\n    auto it = --S.upper_bound(P2(P(a+1, -1), -1));\n    P2 p = *it;\n    if (p._1._2 > a) {\n      S.erase(it);\n      S.insert(P2(P(a+1, p._1._2), p._2));\n      it = S.insert(P2(P(p._1._1, a), p._2))._1;\n    }\n    while (true) {\n      P2 cur = *it;\n      long long w = cur._1._2-cur._1._1+1;\n      long long lim = INF;\n      if (it != S.begin()) {\n        lim = (--it)->_2 - cur._2;\n        it++;\n      }\n      long long up = min(lim, b/w);\n      cur._2 += up;\n      b -= 1LL*up*w;\n      if (it != S.begin() && up == lim) {\n        it = S.erase(it);\n        int left = (--it)->_1._1;\n        S.erase(it);\n        it = S.insert(P2(P(left, a), cur._2))._1;\n      }\n      else {\n        S.erase(it);\n        it = S.insert(cur)._1;\n        break;\n      }\n    }\n    if (b > 0) {\n      P2 cur = *it;\n      int left = it->_1._1, border = left+b;\n      S.erase(it);\n      S.insert(P2(P(left, border-1), cur._2+1));\n      S.insert(P2(P(border, a), cur._2));\n    }\n  }\n  for (P2 p : S) {\n    int l = p._1._1, r = p._1._2;\n    long long val = p._2;\n    for (int i=l; i<=r; i++) A[i] = val;\n  }\n  rep(i, N) cout << A[i] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma once\n\n#include <iostream>\n\nlong N,Q;\nlong sara[100000]={};\nlong a[100000]={};\nlong b[100000]={};\n\n\nvoid Min(long ab,long min,long hito){\n\tfor(int i=0;i<ab;i++){\n\t\tif(sara[i]<min){\n\t\t\tmin =sara[i];\n\t\t\thito =i;\n\t\t}\n\t}\n\tsara[hito] ++;\n}\n\n\nint main(){\n\tscanf(\"%ld\\n%ld\\n\",&N,&Q);\n\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%ld\\n%ld\\n\",&a[i],&b[i]);\n\t}\n\n\tif(Q<=100&&N<=100){\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tMin(a[i],1000000000000,0);\n\t\t}\n\t}\n\n\n\t\n\tfor(int i=0;i<Q;i++){\n\tprintf(\"%ld\\n\",sara[i]);\n\t}\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nll readLL(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nstruct Range{\n\tmutable int b,e;\n\tmutable ll eat;\n\tbool operator<(const Range& rhs)const{\n\t\treturn b<rhs.b;\n\t}\n};\n\nint main(){\n\tint n=read(),q=read();\n\tset<Range> s;\n\ts.insert(Range{0,n,0});\n\tREP(_,q){\n\t\tint a=read();\n\t\tll b=readLL();\n\t\tauto itr=s.lower_bound(Range{a});\n\t\t--itr;\n\t\tif(a<itr->e){\n\t\t\tRange tmp=*itr;\n\t\t\ttmp.b=a;\n\t\t\titr=s.insert(tmp).first;\n\t\t\titr--;\n\t\t\titr->e=a;\n\t\t}\n\t\twhile(itr!=s.begin()){\n\t\t\tauto p=itr;p--;\n\t\t\tll dif=p->eat-itr->eat;\n\t\t\tif(dif*(itr->e-itr->b)<=b){\n\t\t\t\tb-=dif*(itr->e-itr->b);\n\t\t\t\titr=s.erase(itr);\n\t\t\t\titr--;\n\t\t\t\titr->e=a;\n\t\t\t}else\n\t\t\t\tbreak;\n\t\t}\n\t\titr->eat+=b/(itr->e-itr->b);\n\t\tRange x=*itr;\n\t\tx.e=x.b+b%(itr->e-itr->b);\n\t\tif(x.b<x.e){\n\t\t\titr->b=x.e;\n\t\t\tx.eat++;\n\t\t\ts.insert(x);\n\t\t}\n\t}\n\tfor(auto g:s)\n\t\tFOR(i,g.b,g.e)\n\t\t\tprintf(\"%lld\\n\",g.eat);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\nconst int maxN = 100 * 1000 + 9;\n\nll segTree[4 * maxN], lazy[4 * maxN];\nbool f[4 * maxN];\n\nvoid propagate(int id, int l, int r){\n\tif(f[id])\n\t\tsegTree[id] = lazy[id] * (r - l + 1);\n\telse \n\t\tsegTree[id] += lazy[id] * (r - l + 1);\n\n\tif(l != r){\n\t\tif(f[id]){\n\t\t\tf[id * 2] = f[id * 2 + 1] = true;\n\t\t\tlazy[id * 2] = lazy[id];\n\t\t\tlazy[id * 2 + 1] = lazy[id];\n\t\t} else {\n\t\t\tlazy[id * 2] += lazy[id];\n\t\t\tlazy[id * 2 + 1] += lazy[id];\n\t\t}\n\t}\n\n\tlazy[id] = 0;\n\tf[id] = 0;\n}\n\nvoid upd(int id, int l, int r, int L, int R, ll val, bool changeTo){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\tlazy[id] = val;\n\t\tf[id] = changeTo;\n\t\tpropagate(id, l, r);\n\t\t//cerr << l << ' ' << r << ' ' << segTree[id] << '\\n';\n\t\treturn;\n\t}\n\t\n\tif(r < L || l > R){\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(id * 2, l, mid, L, R, val, changeTo);\n\tupd(id * 2 + 1, mid + 1, r, L, R, val, changeTo);\n\n\tsegTree[id] = segTree[id * 2] + segTree[id * 2 + 1];\n}\n\nll getSum(int id, int l, int r, int L, int R){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\treturn segTree[id];\n\t}\n\n\tif(r < L || l > R){\n\t\treturn 0;\n\t}\n\t\n\tint mid = (l + r) / 2;\n\treturn getSum(id * 2, l, mid, L, R) + getSum(id * 2 + 1, mid + 1, r, L, R);\n}\n\nint n, q;\n\nvoid read(){\n\tcin >> n >> q;\n}\n\nll aa[maxN];\n\nvoid brute(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tll tot = 0;\n\t\tll foo = -1;\n\t\tfor(int i = r; i > 0; i--){\n\t\t\tint len = r - i + 1;\n\t\t\ttot += aa[i];\n\t\t\tif(p - (aa[i] * len - tot) >= 0){\n\t\t\t\tfoo = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = r; i > foo; i--){\n\t\t\tp -= (aa[foo] - aa[i]);\n\t\t\taa[i] = aa[foo];\n\t\t}\n\n\t\tint P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tfor(int i = foo; i <= r; i++){\n\t\t\taa[i] += P;\n\t\t}\n\t\t\n\t\t//cerr << foo << ' ' << P << ' ' << Q << '\\n';\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\n\t\tfor(int i = foo; i <= foo + Q - 1; i++){\n\t\t\taa[i]++;\n\t\t}\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << aa[i] << ' ';\n\t}\n\tcout << '\\n';\n}\n\nvoid better(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tint lo = 1, hi = r, foo = r;\n\t\twhile(lo <= hi){\n\t\t\tint mid = (lo + hi) / 2;\n\t\t\tif(p - ((r - mid + 1) * getSum(1, 1, n, mid, mid) - getSum(1, 1, n, mid, r)) >= 0){\n\t\t\t\tfoo = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tll x = getSum(1, 1, n, foo, foo);\n\t\tp -= ((r - foo + 1) * x - getSum(1, 1, n, foo, r));\n\n\t\tupd(1, 1, n, foo, r, x, true);\n\t\t//cerr << foo << \", \" << r << \" = \" << x << '\\n';\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t\n\t\tint P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tupd(1, 1, n, foo, r, P, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\n\t\tupd(1, 1, n, foo, foo + Q - 1, 1, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t//cout << \"\\n\\n\\n\";\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << getSum(1, 1, n, i, i) << '\\n';\n\t}\n}\n\nvoid solv(){\n\t//if(n <= 2000){\n\t//\tbrute();\n\t//} else {\n\t//\tbetter();\n\t//}\n\n\tbetter();\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n#ifdef h4h4\n\tfreopen((FILENAME + \".inp\").c_str(), \"r\", stdin);\n\tfreopen((FILENAME + \".out\").c_str(), \"w\", stdout);\n#endif\n\t\n\tread();\n\tsolv();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline int in() {\n    int n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\ntemplate<typename T> class segtree {\n    private:\n        int n,sz; vector<T> node, lazy_update, lazy_add; vector<bool> lazyFlag;\n        void eval(int k, int l, int r) {\n            if(lazyFlag[k]){\n                lazy_update[k] += lazy_add[k];\n                node[k] = lazy_update[k];\n                if(r - l > 1) {\n                    lazy_add[2*k+1] = lazy_add[2*k+2] = 0;\n                    lazy_update[2*k+1] = lazy_update[2*k+2] = lazy_update[k];\n                    lazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n                }\n                lazy_add[k] = 0;\n                lazyFlag[k] = false;\n            }else if(lazy_add[k] != 0){\n                node[k] += lazy_add[k];\n                if(r - l > 1){\n                    lazy_add[2*k+1] += lazy_add[k]; lazy_add[2*k+2] += lazy_add[k];\n                }\n                lazy_add[k] = 0;\n            }\n        }\n     \n    public:\n        segtree(vector<T> v) : sz((int)v.size()){\n            n = 1;\n            while(n < sz) n *= 2;\n            node.resize(2*n-1,numeric_limits<T>::min());\n            lazy_update.resize(2*n-1, 0); lazyFlag.resize(2*n-1,false);\n            lazy_add.resize(2*n-1, 0);\n            for(int i = 0; i < sz; i++){\n                node[i+n-1] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) node[i] = max(node[2*i+1],node[2*i+2]);\n        }\n        void update(int a, int b, T x, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] = 0; lazy_update[k] = x; lazyFlag[k] = true;\n                eval(k, l, r);\n            }else{\n                update(a, b, x, 2*k+1, l, (l+r)/2); update(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        void add(int a, int b, T x, int k=0, int l=0, int r=-1){\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                lazy_add[k] += x; eval(k, l, r);\n            }else{\n                add(a, b, x, 2*k+1, l, (l+r)/2); add(a, b, x, 2*k+2, (l+r)/2, r);\n                node[k] = max(node[2*k+1],node[2*k+2]);\n            }\n        }\n        T query(int a, int b, int k=0, int l=0, int r=-1) {\n            if(r < 0) r = n;\n            eval(k, l, r);\n            if(b <= l || r <= a) return numeric_limits<T>::min();\n            if(a <= l && r <= b) return node[k];\n            return max(query(a, b, 2*k+1, l, (l+r)/2), query(a, b, 2*k+2, (l+r)/2, r));\n        }\n        void print(){\n            for(int i = 0; i < sz; i++){\n                cout<<query(i,i+1)<< \" \";\n            }\n            cout<<endl;\n        }\n    };\n\n\nint main(){\n    int n = in(), q = in();\n    vector<ll> v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a = in();\n        ll b = in();\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        out(sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll dat[400000], lazy[400000];\nint n = 1;\ninline void push(int k, int s) {\n\tif (lazy[k] == 0)return;\n\tdat[k] = lazy[k] * s;\n\tif (k < n - 1) {\n\t\tlazy[k * 2 + 1] = lazy[k];\n\t\tlazy[k * 2 + 2] = lazy[k];\n\t}\n\tlazy[k] = 0;\n}\ninline void upnode(int k) {\n\tdat[k] = dat[k * 2 + 1] + dat[k * 2 + 2];\n}\ninline void update(int a, int b, ll x, int k = 0, int l = 0, int r = n) {\n\tpush(k, r - l);\n\tif (b <= l || r <= a)return;\n\tif (a <= l&&r <= b) {\n\t\tlazy[k] = x; push(k, r - l); return;\n\t}\n\tupdate(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\tupnode(k);\n}\ninline ll query(int a, int b, int k = 0, int l = 0, int r = n) {\n\tpush(k, r - l);\n\tif (b <= l || r <= a)return 0;\n\tif (a <= l&&r <= b)return dat[k];\n\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\tupnode(k);\n\treturn vl + vr;\n}\nint main() {\n\tint N, q; scanf(\"%d%d\", &N, &q);\n\twhile (n < N)n <<= 1;\n\trep(i, q) {\n\t\tint a; ll b; scanf(\"%d%lld\", &a, &b); a--;\n\t\tint l = 0, r = a;\n\t\twhile (l != r) {\n\t\t\tint t = (l + r) / 2;\n\t\t\tif (query(t, t + 1)*(a - t) - query(t + 1, a + 1) <= b)r = t;\n\t\t\telse l = t + 1;\n\t\t}\n\t\tb -= query(l, l + 1)*(a - l) - query(l + 1, a + 1);\n\t\tupdate(l, a + 1, query(l, l + 1) + b / (a - l + 1));\n\t\tupdate(l, l + b % (a - l + 1), query(l, l + 1) + 1);\n\t}\n\trep(i, N)printf(\"%lld\\n\", query(i, i + 1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n#include <bits/stdc++.h>\n#include <boost/range/irange.hpp>\n\nusing namespace std;\nusing namespace boost;\n\nclass SegmentTree {\n   public:\n    using value_type = int64_t;\n\n    SegmentTree(int64_t n)\n            : n(n), cap(pow(2, ceil(log2(n)))), values(2 * cap - 1, 0), delay(2 * cap - 1, -1L) {}\n  \n    void update(int64_t a, int64_t b, int64_t v, int64_t idx = 0, int64_t l = 0,\n                     int64_t r = -1) {\n        if (r < 0) {\n            r = cap;\n        }\n\n        if (a >= r || b <= l) {\n            return;\n        }\n\n        if (a <= l && r <= b) {\n            values[idx] = v * (r - l);\n            delay[idx] = v;\n            return;\n        }\n\n        auto left_idx = 2 * (idx + 1) - 1;\n        auto right_idx = 2 * (idx + 1);\n\n        if (delay[idx] >= 0) {\n            update(l, (l + r) / 2, delay[idx], left_idx, l, (l + r) / 2);\n            update((l + r) / 2, r, delay[idx], right_idx, (l + r) / 2, r);\n            delay[idx] = -1;\n        }\n\n        update(a, b, v, left_idx, l, (l + r) / 2);\n        update(a, b, v, right_idx, (l + r) / 2, r);\n      \n        values[idx] = values[left_idx] + values[right_idx];\n    }\n  \n    value_type get(int64_t pos) {\n        return query(pos, pos + 1);\n    }\n\n    value_type query(int64_t a, int64_t b, int64_t idx = 0, int64_t l = 0,\n                     int64_t r = -1) {\n        if (r < 0) {\n            r = cap;\n        }\n\n        if (a >= r || b <= l) {\n            return 0;\n        }\n\n        if (a <= l && r <= b) {\n            return values[idx];\n        }\n\n        auto left_idx = 2 * (idx + 1) - 1;\n        auto right_idx = 2 * (idx + 1);\n      \n        if (delay[idx] >= 0) {\n            update(l, (l + r) / 2, delay[idx], left_idx, l, (l + r) / 2);\n            update((l + r) / 2, r, delay[idx], right_idx, (l + r) / 2, r);\n            delay[idx] = -1;\n        }\n\n        auto left_v = query(a, b, left_idx, l, (l + r) / 2);\n        auto right_v = query(a, b, right_idx, (l + r) / 2, r);\n\n        return left_v + right_v;\n    }\n\n   private:\n    int64_t n;\n    int64_t cap;\n    vector<value_type> values;\n    vector<value_type> delay;\n};\n\nmain() {\n    int64_t n, q;\n    cin >> n >> q;\n\n    SegmentTree tree(n);\n  \n    for (auto i : irange(0L, q)) {\n        int64_t a, b;\n        cin >> a >> b;\n      \n        auto r = irange(0L, a);\n        auto c = *partition_point(r.begin(), r.end(), [&](int64_t pos) {\n            auto v = tree.get(pos);\n            auto v2 = tree.query(pos + 1, a);\n            return v2 + b < v * (a - pos - 1);\n        });\n        auto v = tree.get(c);\n        auto v2 = tree.query(c + 1, a);\n\n        b -= v * (a - c - 1) - v2;\n        auto l = a - c;\n        tree.update(c, c + b % l, v + b / l + 1);\n        tree.update(c + b % l, a, v + b / l);\n    }\n  \n    for (auto i : irange(0L, n)) {\n        cout << tree.get(i) << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing int64 = long long;\n\nclass segment_tree\n{\nprivate:\n\tstd::vector<pair<int64,int>>treedat;\n\tint treesiz;\n\tpair<int64,int> inf;\n\tpair<int64,int> rawqry(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)return inf;\n\t\tif (a <= l && r <= b)return treedat[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(rawqry(a, b, k * 2 + 1, l, m), rawqry(a, b, k * 2 + 2, m, r));\n\t}\npublic:\n\tvoid update(int k, pair<int64,int> a)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k] = a;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tvoid update_inc(int k)\n\t{\n\t\tk += (treesiz - 1);\n\t\ttreedat[k].first++;\n\t\twhile (k > 0)\n\t\t{\n\t\t\tk = (k - 1) / 2;\n\t\t\ttreedat[k] = std::min(treedat[k * 2 + 1], treedat[k * 2 + 2]);\n\t\t}\n\t}\n\tint64 peek(int k)\n\t{\n\t\treturn treedat[k + treesiz - 1].first;\n\t}\n\tpair<int64, int> query(int a, int b) { return rawqry(a, b, 0, 0, treesiz); }\n\tsegment_tree(int n)\n\t{\n\t\tinf = make_pair((int64)LLONG_MAX / 128, n);\n\t\ttreesiz = 1;\n\t\twhile (treesiz < n)treesiz *= 2;\n\t\ttreedat.resize(2 * treesiz + 1);\n\t\tstd::fill(treedat.begin(), treedat.end(), inf);\n\t}\n};\n\nint n, q;\n\nsegment_tree *rmq;\n\nint main(void)\n{\n\tscanf(\"%lld %lld\", &n, &q);\n\trmq = new segment_tree(n);\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\trmq->update(j, make_pair((long long)0, j));\n\t}\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tif (b != 1)return -1;\n\t\tauto ret = rmq->query(0, a);\n\t\trmq->update_inc(ret.second);\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t{\n\t\tint64 ans = rmq->peek(j);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int N, Q;\n    const ll INF = LLONG_MAX / 3;\n    while(cin >> N >> Q) {\n        map<int, ll> m;\n        m[0] = INF;\n        m[N] = 0;\n\n        while(Q--) {\n            int a;\n            ll b;\n            cin >> a >> b;\n            while(b) {\n                auto rit = m.lower_bound(a);\n                auto lit = prev(rit);\n                int d = a - lit->first;\n                ll c = min(b / d, lit->second - rit->second);\n                if(c) {\n                    m[a] = rit->second + c;\n                    b -= (ll)c*d;\n                    if(b && c < lit->second - rit->second) {\n                        m[lit->first + b] = m[a] + 1;\n                        b = 0;\n                    }\n                } else {\n                    m[lit->first + b] = rit->second + 1;\n                    b = 0;\n                }\n                if(lit->second == next(lit)->second) {\n                    m.erase(lit);\n                }\n            }\n        }\n\n        vll ans(N);\n        for(auto i = m.begin(); next(i) != m.end(); ++i) {\n            auto j = next(i);\n            FOR(k, i->first, j->first) {\n                ans[k] = j->second;\n            }\n        }\n\n        rep(i, N)cout << ans[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n// 寿司を食べたい！！\ntypedef long long int64;\n\nstruct SegmentTree\n{\n  vector< int64 > seg, lazy;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, 0);\n    lazy.assign(2 * sz - 1, -1);\n  }\n\n  void push(int k)\n  {\n    if(lazy[k] >= 0) {\n      if(k < sz - 1) {\n        lazy[2 * k + 1] = lazy[k] >> 1LL;\n        lazy[2 * k + 2] = lazy[k] >> 1LL;\n      }\n      seg[k] = lazy[k];\n      lazy[k] = -1;\n    }\n  }\n\n  int64 query(int a, int b, int k, int l, int r)\n  {\n    push(k);\n    if(a >= r || b <= l) {\n      return (0);\n    } else if(a <= l && r <= b) {\n      return (seg[k]);\n    } else {\n      return (query(a, b, 2 * k + 1, l, (l + r) >> 1) +\n              query(a, b, 2 * k + 2, (l + r) >> 1, r));\n    }\n  }\n\n  int64 query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n\n  void update(int a, int b, int64 x, int k, int l, int r)\n  {\n    push(k);\n    if(a >= r || b <= l) {\n      return;\n    } else if(a <= l && r <= b) {\n      lazy[k] = x * (r - l);\n      push(k);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n      update(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n      seg[k] = seg[2 * k + 1] + seg[2 * k + 2];\n    }\n  }\n\n  void update(int a, int b, int64 x)\n  {\n    update(a, b, x, 0, 0, sz);\n  }\n\n};\n\nint main()\n{\n  int N, Q;\n\n  cin >> N >> Q;\n  SegmentTree tree(N);\n  while(Q--) {\n    int A, B;\n    cin >> A >> B;\n    int low = 0, high = A;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(tree.query(mid, mid + 1) * (A - mid) - tree.query(mid, A) > B) low = mid;\n      else high = mid;\n    }\n    if(tree.query(low, low + 1) * (A - low) - tree.query(low, A) > B) ++low;\n    int64 v = tree.query(low, A) + B;\n    int64 width = A - low;\n    tree.update(low, A, v / width + 1);\n    tree.update(low + v % width, A, v / width);\n  }\n  for(int i = 0; i < N; i++) {\n    cout << tree.query(i, i + 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stdlib.h>\n#include<string.h>\n#include<queue>\n#define LL long long\nusing namespace std;\ninline LL read( )\n{\n  LL sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int N=100005;\nint n,Q;LL t[N*4],cov[N*4],add[N*4];\ninline void _cov(int p,LL v,int len)\n{\n  t[p]=v*len;\n  add[p]=0;cov[p]=v;\n}\ninline void _add(int p,LL v,int len)\n{\n  t[p]+=v*len;\n  if(cov[p]==-1) add[p]+=v;\n  else cov[p]+=v;\n}\ninline void push(int p,int l,int r)\n{\n  LL u;int L=p<<1,R=L|1,mid=(l+r)>>1;\n  if((u=add[p])) _add(L,u,mid-l+1),_add(R,u,r-mid),add[p]=0;\n  if((u=cov[p])!=-1) _cov(L,u,mid-l+1),_cov(R,u,r-mid),cov[p]=-1;\n}\nLL v;\ninline void build(int p,int l,int r)\n{\n  cov[p]=-1;if(l==r) return;\n  int mid=(l+r)>>1;build(p<<1,l,mid);build(p<<1|1,mid+1,r);\n}\ninline void ch(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) {_cov(p,v,r-l+1);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) ch(p<<1,l,mid,L,R);\n  else if(L>mid) ch(p<<1|1,mid+1,r,L,R);\n  else ch(p<<1,l,mid,L,mid),ch(p<<1|1,mid+1,r,mid+1,R);\n  t[p]=t[p<<1]+t[p<<1|1];\n}\ninline void up(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) {_add(p,v,r-l+1);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) up(p<<1,l,mid,L,R);\n  else if(L>mid) up(p<<1|1,mid+1,r,L,R);\n  else up(p<<1,l,mid,L,mid),up(p<<1|1,mid+1,r,mid+1,R);\n  t[p]=t[p<<1]+t[p<<1|1];\n}\ninline LL ask(int p,int l,int r,int L,int R)\n{\n  if(l==L&&r==R) return t[p];\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  if(R<=mid) return ask(p<<1,l,mid,L,R);\n  else if(L>mid) return ask(p<<1|1,mid+1,r,L,R);\n  else return ask(p<<1,l,mid,L,mid)+ask(p<<1|1,mid+1,r,mid+1,R);\n}\ninline void DFS(int p,int l,int r)\n{\n  if(l==r) {printf(\"%lld \",t[p]);return;}\n  push(p,l,r);\n  int mid=(l+r)>>1;\n  DFS(p<<1,l,mid);\n  DFS(p<<1|1,mid+1,r);\n}\nint main( )\n{\n  int a,l,r,mid,L,len;LL b,t;\n  n=read( );Q=read( );\n  build(1,1,n);\n  while(Q--)\n    {\n      a=read( );b=read( );\n      if(a==1) {v=b;up(1,1,n,1,1);continue;} //q[0]=inf\n      if(ask(1,1,n,a-1,a-1)-ask(1,1,n,a,a)>=b) {v=b;up(1,1,n,a,a);continue;}\n      l=2;r=a;\n      while(l<=r)\n\t{\n\t  mid=(l+r)>>1;\n\t  if(ask(1,1,n,mid-1,mid-1)*(a-mid+1)-ask(1,1,n,mid,a)<=b) r=mid-1;\n\t  else l=mid+1;\n\t}\n      L=l-1;t=ask(1,1,n,L,L);\n      //printf(\"%d\\n\",L);\n      b-=t*(a-r+1)-ask(1,1,n,r,a);\n      //cout<<b<<endl;\n      v=t;ch(1,1,n,L+1,a);\n      //DFS(1,1,n);puts(\"\");\n      len=a-L+1;\n      v=b/len;\n      if(v) up(1,1,n,L,a);//,printf(\"%d %d %lld\\n\",L,a,v);\n      b%=len;\n      if(b) v=1,up(1,1,n,L,L+b-1);//,printf(\"%d %lld\\n\",L,L+b-1);\n      //DFS(1,1,n);puts(\"\");\n    }\n  DFS(1,1,n);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 1e18;\nconst int maxN = 100 * 1000 + 9;\n\nll segTree[4 * maxN], lazy[4 * maxN];\nbool f[4 * maxN];\n\nvoid propagate(int id, int l, int r){\n\tif(f[id])\n\t\tsegTree[id] = lazy[id] * (r - l + 1);\n\telse \n\t\tsegTree[id] += lazy[id] * (r - l + 1);\n\n\tif(l != r){\n\t\tif(f[id]){\n\t\t\tf[id * 2] = f[id * 2 + 1] = true;\n\t\t\tlazy[id * 2] = lazy[id];\n\t\t\tlazy[id * 2 + 1] = lazy[id];\n\t\t} else {\n\t\t\tlazy[id * 2] += lazy[id];\n\t\t\tlazy[id * 2 + 1] += lazy[id];\n\t\t}\n\t}\n\n\tlazy[id] = 0;\n\tf[id] = 0;\n}\n\nvoid upd(int id, int l, int r, int L, int R, ll val, bool changeTo){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\tlazy[id] = val;\n\t\tf[id] = changeTo;\n\t\tpropagate(id, l, r);\n\t\t//cerr << l << ' ' << r << ' ' << segTree[id] << '\\n';\n\t\treturn;\n\t}\n\t\n\tif(r < L || l > R){\n\t\treturn;\n\t}\n\n\tint mid = (l + r) / 2;\n\tupd(id * 2, l, mid, L, R, val, changeTo);\n\tupd(id * 2 + 1, mid + 1, r, L, R, val, changeTo);\n\n\tsegTree[id] = segTree[id * 2] + segTree[id * 2 + 1];\n}\n\nll getSum(int id, int l, int r, int L, int R){\n\tpropagate(id, l, r);\n\tif(L <= l && r <= R){\n\t\treturn segTree[id];\n\t}\n\n\tif(r < L || l > R){\n\t\treturn 0;\n\t}\n\t\n\tint mid = (l + r) / 2;\n\treturn getSum(id * 2, l, mid, L, R) + getSum(id * 2 + 1, mid + 1, r, L, R);\n}\n\nint n, q;\n\nvoid read(){\n\tcin >> n >> q;\n}\n\nll aa[maxN];\n\nvoid brute(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tll tot = 0;\n\t\tll foo = -1;\n\t\tfor(int i = r; i > 0; i--){\n\t\t\tint len = r - i + 1;\n\t\t\ttot += aa[i];\n\t\t\tif(p - (aa[i] * len - tot) >= 0){\n\t\t\t\tfoo = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = r; i > foo; i--){\n\t\t\tp -= (aa[foo] - aa[i]);\n\t\t\taa[i] = aa[foo];\n\t\t}\n\n\t\tint P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tfor(int i = foo; i <= r; i++){\n\t\t\taa[i] += P;\n\t\t}\n\t\t\n\t\t//cerr << foo << ' ' << P << ' ' << Q << '\\n';\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\n\t\tfor(int i = foo; i <= foo + Q - 1; i++){\n\t\t\taa[i]++;\n\t\t}\n\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcerr << aa[i] << ' ';\n\t\t//}\n\t\t//cerr << '\\n';\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << aa[i] << ' ';\n\t}\n\tcout << '\\n';\n}\n\nvoid better(){\n\twhile(q--){\n\t\tint r; ll p;  cin >> r >> p;\n\t\tint lo = 1, hi = r, foo = r;\n\t\twhile(lo <= hi){\n\t\t\tint mid = (lo + hi) / 2;\n\t\t\tif(p - ((r - mid + 1) * getSum(1, 1, n, mid, mid) - getSum(1, 1, n, mid, r)) >= 0){\n\t\t\t\tfoo = mid;\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tll x = getSum(1, 1, n, foo, foo);\n\t\tp -= ((r - foo + 1) * x - getSum(1, 1, n, foo, r));\n\n\t\tupd(1, 1, n, foo, r, x, true);\n\t\t//cerr << foo << \", \" << r << \" = \" << x << '\\n';\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t\n\t\tll P = p / (r - foo + 1);\n\t\tint Q = p % (r - foo + 1);\n\t\tupd(1, 1, n, foo, r, P, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\n\t\tupd(1, 1, n, foo, foo + Q - 1, 1, false);\n\t\t//for(int i = 1; i <= n; i++){\n\t\t//\tcout << getSum(1, 1, n, i, i) << ' ';\n\t\t//}\n\t\t//cout << '\\n';\n\t\t//cout << \"\\n\\n\\n\";\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tcout << getSum(1, 1, n, i, i) << '\\n';\n\t}\n}\n\nvoid solv(){\n\t//if(n <= 2000){\n\t//\tbrute();\n\t//} else {\n\t//\tbetter();\n\t//}\n\n\tbetter();\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n#ifdef h4h4\n\tfreopen((FILENAME + \".inp\").c_str(), \"r\", stdin);\n\tfreopen((FILENAME + \".out\").c_str(), \"w\", stdout);\n#endif\n\t\n\tread();\n\tsolv();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\nlong long sum1[maxn<<2];//sum of val\nlong long sum2[maxn<<2];//sum of tot val\nlong long lazy[maxn<<2];\nlong long totnum=-20000000000010LL;\nint n;\nlong long Start;\nvoid Push_down(int id)\n{\n    lazy[id]=0;\n    lazy[id<<1]=lazy[id<<1|1]=1;\n    sum1[id<<1]=sum1[id<<1|1]=0;\n    sum2[id<<1]=sum2[id<<1|1]=0;\n}\nvoid Push_up(int id)\n{\n    sum1[id]=sum1[id<<1]+sum1[id<<1|1];\n    sum2[id]=sum2[id<<1]+sum2[id<<1|1];\n}\nvoid updata(int id,int l,int r,int w,long long val)\n{\n    if(l==r){\n        sum1[id]+=val;\n        sum2[id]+=val*(n+1-l);\n        lazy[id]=0;\n        return;\n    }\n    if(lazy[id]){\n        Push_down(id);\n    }\n    int mid=(l+r)>>1;\n    if(w<=mid) updata(id<<1,l,mid,w,val);\n    else updata(id<<1|1,mid+1,r,w,val);\n    Push_up(id);\n}\nvoid updatalazy(int id,int l,int r,int tl,int tr)\n{\n    if(l==tl&&r==tr){\n        lazy[id]=1;\n        sum1[id]=sum2[id]=0;\n        return ;\n    }\n    if(lazy[id]) return;\n    int mid=(l+r)>>1;\n    if(tr<=mid)  updatalazy(id<<1,l,mid,tl,tr);\n    else if(tl>mid) updatalazy(id<<1|1,mid+1,r,tl,tr);\n    else{\n        updatalazy(id<<1,l,mid,tl,mid);\n        updatalazy(id<<1|1,mid+1,r,mid+1,tr);\n    }\n    Push_up(id);\n}\nint Q(int id,int l,int r,int x,long long &val)\n{\n    //printf(\"%d %d %d %d %lld %d\\n\",id,l,r,x,val,lazy[id]);\n    if(lazy[id]) return -1;\n    if(r<=x){\n        long long tmp=sum2[id]-sum1[id]*(n-x);\n        //printf(\"%lld %lld %lld %lld ssss\\n\",tmp,val,sum2[id],sum1[id]);\n        if(tmp+val>=0){\n            val=tmp+val;\n            return -1;\n        }\n        else{\n            if(l==r) return l;\n            int mid=(l+r)>>1;\n            int tt=Q(id<<1|1,mid+1,r,x,val);\n            if(tt!=-1) return tt;\n            tt=Q(id<<1,l,mid,x,val);\n            return tt;\n        }\n    }\n    int mid=(l+r)>>1;\n    if(x<=mid) return Q(id<<1,l,mid,x,val);\n    else{\n        int tt=Q(id<<1|1,mid+1,r,x,val);\n        if(tt!=-1) return tt;\n        return Q(id<<1,l,mid,x,val);\n    }\n}\nlong long Qsum(int id,int l,int r,int tl,int tr)\n{\n    if(l==tl&&r==tr){\n        return sum1[id];\n    }\n    if(lazy[id]) return 0;\n    int mid=(l+r)>>1;\n    if(tr<=mid) return Qsum(id<<1,l,mid,tl,tr);\n    else if(tl>mid) return Qsum(id<<1|1,mid+1,r,tl,tr);\n    else return Qsum(id<<1,l,mid,tl,mid)+Qsum(id<<1|1,mid+1,r,mid+1,tr);\n}\nlong long ans[maxn];\nvoid get(int id,int l,int r)\n{\n    if(l==r){\n        ans[l]=sum1[id];\n        return ;\n    }\n    if(lazy[id]){\n        return ;\n    }\n    int mid=(l+r)>>1;\n    get(id<<1,l,mid);\n    get(id<<1|1,mid+1,r);\n}\nvoid Output()\n{\n    memset(ans,0,sizeof(ans));\n    ans[0]=-totnum;\n    get(1,1,n);\n//    for(int i=1;i<=n;i++)\n//        printf(\"%lld \",ans[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=n;i++)\n        ans[i]+=ans[i-1];\n//    for(int i=1;i<=n;i++)\n//        printf(\"%lld \",ans[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=n;i++)\n        printf(\"%lld\\n\",ans[i]);\n}\nint main()\n{\n    int q;\n    scanf(\"%d%d\",&n,&q);\n    Start=0;\n    memset(lazy,0,sizeof(lazy));\n    memset(sum1,0,sizeof(sum1));\n    memset(sum2,0,sizeof(sum2));\n    updata(1,1,n,1,totnum);\n    while(q--)\n    {\n        int x;\n        long long val;\n        scanf(\"%d%lld\",&x,&val);\n        int t=Q(1,1,n,x,val);\n       // printf(\"%d %lld\\n\",t,val);\n        if(t<x){\n            long long sum=Qsum(1,1,n,t+1,x);\n            if(x+1<=n) updata(1,1,n,x+1,sum);\n            updatalazy(1,1,n,t+1,x);\n        }\n        long long tmp=val/(x-t+1);\n        val=val%(x-t+1);\n        updata(1,1,n,t,tmp);\n        if(x+1<=n)\n            updata(1,1,n,x+1,-tmp);\n        if(val){\n            updata(1,1,n,t,1);\n            updata(1,1,n,t+val,-1);\n        }\n        //Output();\n    }\n    Output();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,ll> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline ll in() {\n    ll n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\nll h[MAX_N];\n\nint main()\n{\n    int n = in(), q = in();\n    set<int> st = {0};\n    rep(i,q){\n        int a = in();\n        ll b = in();\n        auto it = st.lower_bound(a);\n        bool flag = (it == st.end() || *it != a);\n        auto it2 = --it;\n        ll flag2 = h[*it2];\n        if(it2 == st.begin()){\n            int p = *it2;\n            ll x = b / a, y = b % a;\n            if(y == 0){\n                h[p] += x;\n            }else{\n                st.insert(p+y), h[p+y] = h[p]+x;\n                h[p] += x+1;\n            }\n        }else{\n            do {\n                int p = *it2, q = *(--it2);\n                ++it2;\n                ll cri = (a-p)*(h[q]-h[p]);\n                if(b >= cri){\n                    b -= cri;\n                }else{\n                    ll x = b / (a-p), y = b % (a-p);\n                    if(y == 0){\n                        h[p] += x;\n                    }else{\n                        st.insert(p+y), h[p+y] = h[p] + x;\n                        if(h[q] != h[p]+x+1){\n                            h[p] += x+1;\n                        }else{\n                            st.erase(it2);\n                        }\n                    }\n                    b = 0;\n                }\n                it = st.lower_bound(a);\n                it2 = --it;\n            }while(it2 != st.begin() && b > 0);\n            if(b > 0){\n                int p = *it2;\n                ll x = b / a, y = b % a;\n                if(y == 0){\n                    h[p] += x;\n                }else{\n                    st.insert(p+y), h[p+y] = h[p]+x;\n                    h[p] += x+1;\n                }\n            }\n        }\n        if(flag) st.insert(a), h[a] = flag2;\n    }\n    int s = 0;\n    ll prv = -1;\n    each(p,st){\n        if(p > 0){\n            srep(i,s,p) out(prv);\n        }\n        s = p, prv = h[p];\n    }\n    srep(i,s,n) out(prv);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline int in() {\n    int n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(ll n) {\n    short res[20], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n    putchar('\\n');\n}\n\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz,h;\n    vector<T> node, lazy;\n    void eval(int k) {\n        if(lazy[k]){\n            node[k] += lazy[k];\n            if(k < n) {\n                lazy[k*2] += lazy[k], lazy[k*2+1] += lazy[k];\n            }\n            lazy[k] = 0;\n        }\n    }\n\npublic:\n    segtree(vector<T>& v) : sz((int)v.size()), h(0) {\n        n = 1;\n        while(n < sz) n *= 2, h++;\n        node.resize(2*n, numeric_limits<T>::min());\n        lazy.resize(2*n, 0);\n        for(int i = 0; i < sz; i++) node[i+n] = v[i];\n        for(int i = n-1; i >= 1; i--) node[i] = max(node[2*i], node[2*i+1]);\n    }\n    void add(int a, int b, T x, int k=1, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b){\n            lazy[k] += x;\n            eval(k);\n        }else{\n            add(a, b, x, 2*k, l, (l+r)/2);\n            add(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = max(node[2*k], node[2*k+1]);\n        }\n    }\n    T query(int a, int b) {\n        a += n, b += n - 1;\n        for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n        b++;\n        T res1 = numeric_limits<T>::min(), res2 = numeric_limits<T>::min();\n        while(a < b) {\n            if(a & 1) eval(a), res1 = max(res1, node[a++]);\n            if(b & 1) eval(--b), res2 = max(res2, node[b]);\n            a >>= 1, b >>= 1;\n        }\n        return max(res1, res2);\n    }\n    void print(){for(int i = 0; i < sz; i++) cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nint main(){\n    int n = in(), q = in();\n    vector<ll>v(n+1);\n    segtree<ll> sg(v);\n    rep(zz,q){\n        int a = in();\n        ll b = in();\n        while(b!=0){\n            ll pp = sg.query(a-1,a);\n    \n            int ok = a-1;\n            int ng = -1;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(sg.query(mid,a)==pp){\n                    ok = mid;\n                }else{\n                    ng = mid;\n                }\n            }\n            if(ok==0){\n                sg.add(0,a,b/a);\n                b-=(b/a)*a;\n                if(b!=0){\n                    sg.add(0,b,1);\n                }\n                b = 0;\n            }else{\n                ll qq = sg.query(ok-1,ok);\n                if( (a-ok)*(qq-pp) <= b ){\n                    sg.add(ok,a,qq-pp);\n                    b -= (a-ok)*(qq-pp);\n                }else{\n                    ll dis = a-ok;\n                    sg.add(ok,a,(b/dis));\n                    b -= dis*(b/dis);\n                    if(b!=0){\n                        sg.add(ok,ok+b,1);\n                    }\n                    b = 0;\n                }\n            }\n        }\n    }\n    rep(i,n){\n        out(sg.query(i,i+1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <vector>\n#include <cstdio>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ninline ll read() {\n    char ch = getchar(); ll x = 0;\n    while(ch < '0' || ch > '9') ch = getchar();\n    while(ch >= '0' && ch <= '9') x = x*10+ch-'0', ch = getchar();\n    return x;\n}\n\n\nconst ll INF = 2e13;\nconst int N = 1e5+5;\n\nstruct seg {\n    int l, r;\n    ll v;\n\n    seg() {}\n    seg(int a, int b, ll c): l(a), r(b), v(c) {}\n    bool operator <(const seg &b) const {\n        return l < b.l;\n    }\n};\n\nset <seg> s;\nset <seg>:: iterator it;\nseg del[N], ins[N];\n\nint t1, t2;\nvoid work() {\n    ll y = read(), x = read();\n    it = s.upper_bound(seg(y, 0, 0)), --it;\n    if(y+1 <= it->r) ins[++t1] = (seg(y+1, it->r, it->v));\n    del[++t2] = (*it);\n\n    int nl = it->l, nr = y, nv = it->v;\n    for(--it; 1LL*(nr-nl+1)*(it->v-nv) < x;) {\n        x -= 1LL*(nr-nl+1)*(it->v-nv);\n        del[++t2] = (*it);\n        nl = it->l, nv = it->v, --it;\n    }\n\n    nv += x / (nr-nl+1);\n    x  %= (nr-nl+1), nl = it->r+x+1;\n    if(nl <= nr) ins[++t1] = (seg(nl, nr, nv));\n    if(it->r < nl-1) ins[++t1] = (seg(it->r+1, nl-1, nv+1));\n\n    for(int i = 1; i <= t2; ++i) s.erase(del[i]);\n    for(int i = 1; i <= t1; ++i) s.insert(ins[i]);\n    t1 = t2 = 0;\n}\n\n\nint n, q;\nint main() {\n    n = read(), q = read();\n\n    s.insert(seg(0, 0, INF));\n    s.insert(seg(1, n, 0));\n\n    while(q--) work();\n    for(it = s.begin(), ++it; it != s.end(); ++it)\n        for(int j = it->l; j <= it->r; ++j)\n            printf(\"%lld\\n\", it->v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n \n \nstruct st {\n\tint id, cnt;\n};\nbool operator<(st a, st b) {\n\tif (a.cnt == b.cnt)return a.id < b.id;\n\treturn a.cnt < b.cnt;\n}\nint cnt[1000000];\n \nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\tset<st>se;\n\tfor (int i = 1; i <= n; i++) se.insert({ i,0 });\n\trep(i, q) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tif(b!=1)abort();\n\t\twhile (se.size()&&cnt[(*se.begin()).id] != (*se.begin()).cnt)se.erase(se.begin());\n\t\tauto it = se.begin();\n\t\tfor (; (*it).id > a; it++);\n\t\tcnt[(*it).id]++;\n\t\tse.insert({ (*it).id,cnt[(*it).id] });\n\t\tse.erase(it);\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d\\n\", cnt[i]);\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define inf (1ll<<30)\n#define free(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\nconst int maxn=100010;\nint n,Q;\nstruct node {int l,r;LL s,tag;}tr[maxn<<2];\n\nvoid pushdown(int k) {\n\tint l=k<<1,r=k<<1|1;LL w=tr[k].tag;tr[k].tag=0;\n\ttr[l].s=(tr[l].r-tr[l].l+1)*w;tr[l].tag=w;\n\ttr[r].s=(tr[r].r-tr[r].l+1)*w;tr[r].tag=w;\n}\nvoid modify(int k,int s,int t,LL val) {\n\tint l=tr[k].l,r=tr[k].r,mid=(l+r)>>1;\n\tif (l==s && r==t) {tr[k].s=val*(tr[k].r-tr[k].l+1);tr[k].tag=val;return;}\n\tif (tr[k].tag) pushdown(k);\n\tif (t<=mid) modify(k<<1,s,t,val);\n\telse if (s>mid) modify(k<<1|1,s,t,val);\n\telse modify(k<<1,s,mid,val),modify(k<<1|1,mid+1,t,val);\n\ttr[k].s=tr[k<<1].s+tr[k<<1|1].s;\n}\nvoid build(int k,int s,int t) {\n\ttr[k].l=s;tr[k].r=t;\n\tif (s==t) return;\n\tint mid=(s+t)>>1;\n\tbuild(k<<1,s,mid);\n\tbuild(k<<1|1,mid+1,t);\n}\nLL query(int k,int s,int t) {\n\tint l=tr[k].l,r=tr[k].r,mid=(l+r)>>1;\n\tif (l==s && r==t) return tr[k].s;\n\tif (tr[k].tag) pushdown(k);\n\tif (t<=mid) return query(k<<1,s,t);\n\telse if (s>mid) return query(k<<1|1,s,t);\n\telse return query(k<<1,s,mid)+query(k<<1|1,mid+1,t);\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&Q);\n\tbuild(1,1,n);\n\tfor (int x,i=1;i<=Q;i++) {\n\t\tLL y;\n\t\tscanf(\"%d%lld\",&x,&y);\n\t\tif (x==1) {modify(1,1,1,query(1,1,1)+y);continue;}\n\t\tif (query(1,x-1,x-1)-query(1,x,x)>=y) {modify(1,x,x,query(1,x,x)+y);continue;}\n\t\tint l=2,r=x,pos;\n\t\twhile (l<=r) {\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (query(1,mid-1,mid-1)*(x-mid+1)-query(1,mid,x)<=y) r=mid-1,pos=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tLL val=query(1,pos-1,pos-1),num=x-pos+1;\n\t\ty-=val*num-query(1,pos,x);\n\t\tmodify(1,pos,x,val);++num;\n\t\tif (y/num) modify(1,pos-1,x,val+y/num);\n\t\tif (y%num) modify(1,pos-1,pos-2+y%num,val+y/num+1);\n\t}\n\tfor (int i=1;i<=n;i++) printf(\"%lld\\n\",query(1,i,i));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tbool sign = false;\n\tchar ch = getchar();\n\twhile (ch < '0' || '9' < ch) {\n\t\tsign |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile ('0' <= ch && ch <='9') {\n\t\tx = (x << 3) + (x << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}\n\tx = sign ? -x : x;\n}\ntemplate <typename T>\ninline void print(T x) {\n\tstatic char outp[128];\n\tint tot = 0;\n\tif (!x) {\n\t\tputchar('0');\n\t\treturn;\n\t} else if (x < 0) {\n\t\tx = -x;\n\t\tputchar('-');\n\t}\n\twhile (x) { outp[tot++] = x % 10, x /= 10; }\n\twhile (tot) { putchar(outp[--tot] + 48); }\n}\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\nconst lint INF = 2e13 + 10;\nconst int MAXV = (1 << 19) + 20;\nstruct Segment_tree {\n\t#define lson (root << 1)\n\t#define rson (root << 1 | 1)\n\t#define mid ((tree[root].stdl + tree[root].stdr) >> 1)\n\tstruct Node {\n\t\tint stdl, stdr;\n\t\tlint cover, tot;\n\t\tNode() : stdl(0), stdr(0), cover(-1), tot(0) {}\n\t}\ttree[MAXV];\n\tinline void buildtree(int root, int l, int r) {\n\t\ttree[root].stdl = l;\n\t\ttree[root].stdr = r;\n\t\tif (l == r) return;\n\t\tbuildtree(lson, l, mid);\n\t\tbuildtree(rson, mid + 1, r);\n\t}\n\tinline void update(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[root].tot = (tree[root].stdr - tree[root].stdl + 1) * tree[root].cover;\n\t\t} else {\n\t\t\ttree[root].tot = tree[lson].tot + tree[rson].tot;\n\t\t}\n\t}\n\tinline void pushdown(int root) {\n\t\tif (~tree[root].cover) {\n\t\t\ttree[lson].cover = tree[rson].cover = tree[root].cover;\n\t\t\ttree[root].cover = -1;\n\t\t\tupdate(lson), update(rson);\n\t\t}\n\t}\n\tinline void cover(int root, int l, int r, lint c) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\ttree[root].cover = c;\n\t\t\tupdate(root);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\tif (l <= mid) cover(lson, l, r, c);\n\t\tif (r > mid) cover(rson, l, r, c);\n\t\tupdate(root);\n\t}\n\tinline lint query(int root, int l, int r) {\n\t\tif (l <= tree[root].stdl && tree[root].stdr <= r) {\n\t\t\tupdate(root);\n\t\t\treturn tree[root].tot;\n\t\t}\n\t\tlint ret = 0;\n\t\tpushdown(root);\n\t\tif (l <= mid) ret += query(lson, l, r);\n\t\tif (r > mid) ret += query(rson, l, r);\n\t\treturn ret;\n\t}\n\t#undef lson\n\t#undef rson\n\t#undef mid\n}\tTree;\nint main() {\n\tint n, q;\n\tread(n);\n\tread(q);\n\tif (n >= MAXN) for(;;);\n\tTree.buildtree(1, 0, n);\n\tTree.cover(1, 0, 0, INF);\n\tlint a, b;\n\twhile (q--) {\n\t\tread(a);\n\t\tread(b);\n\t\tint l = 0, r = a;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (mid == a) for(;;);\n\t\t\tlint L = Tree.query(1, mid, mid) * (a - mid);\n\t\t\tlint R = Tree.query(1, mid + 1, a) + b;\n\t\t\tif (L <= R) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif (r == a) {\n\t\t\tTree.cover(1, a, a, Tree.query(1, a, a) + b);\n\t\t} else {\n\t\t\tlint M = Tree.query(1, r, r);\n\t\t\tlint L = M * (a - r);\n\t\t\tlint R = Tree.query(1, r + 1, a);\n\t\t\tb -= L - R;\n\t\t\tTree.cover(1, r + 1, a, M);\n\t\t\tif (a - r + 1 == 0) for(;;);\n\t\t\tTree.cover(1, r, a, M + b / (a - r + 1));\n\t\t\tlint c = b - b / (a - r + 1) * (a - r + 1);\n\t\t\tif (c) Tree.cover(1, r, r + c - 1, M + b / (a - r + 1) + 1);\n\t\t}\n\t}\n\trep (i, 1, n) {\n\t\tprint(Tree.query(1, i, i));\n\t\tnewline;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\ntypedef long long LL;\n\n#define lson o<<1\n#define rson o<<1|1\n#define gmid l[o] + r[o] >> 1\n\nint n, Q;\n\nLL S[N<<2], lazy[N<<2];\nint l[N<<2], r[N<<2];\n\nvoid build(int o, int ll, int rr){\n    l[o] = ll;\n    r[o] = rr;\n    S[o] = lazy[o] = 0;\n    if(ll < rr){\n        int mid = gmid;\n        build(lson, ll, mid);\n        build(rson, mid+1, rr);\n    }\n}\n\nvoid update(int o, int ll, int rr, LL v);\n\nint pushdown(int o){\n    int mid = gmid;\n    if(lazy[o]){\n        update(lson, l[o], mid, lazy[o]);\n        update(rson, mid+1, r[o], lazy[o]);\n        lazy[o] = 0;\n    }\n    return mid;\n}\n\nvoid update(int o, int ll, int rr, LL v){\n    if(l[o]==ll && r[o]==rr){\n        S[o] = v * (rr - ll + 1);\n        lazy[o] = v;\n        return;\n    }\n    int mid = pushdown(o);\n    if(rr <= mid)   update(lson, ll, rr, v);\n    else if(ll > mid)   update(rson, ll, rr, v);\n    else{\n        update(lson, ll, mid, v);\n        update(rson, mid+1, rr, v);\n    }\n    S[o] = S[lson] + S[rson];\n}\n\nLL query(int o, int ll, int rr){\n    if(l[o]==ll && r[o]==rr){\n        return S[o];\n    }\n    int mid = pushdown(o);\n    if(rr <= mid)   return query(lson, ll, rr);\n    if(ll > mid)    return query(rson, ll, rr);\n    return query(lson, ll, mid) + query(rson, mid+1, rr);\n}\n\nvoid solve(int a, LL b){\n    int low = 1, top = a, mid, key = top;\n    LL tmp, v;\n    while(low <= top){\n        mid = low + top >> 1;\n        tmp = query(1, mid, a);\n        v = query(1, mid, mid);\n        if(v * (a - mid + 1) - tmp <= b){\n            key = min(key, mid);\n            top = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    tmp = query(1, key, a);\n    v = query(1, key, key);\n    int len = a - key + 1;\n    LL d = v * len - tmp;\n    b = b - d;\n    LL g = b / len + v;\n    LL h = b % len;\n    if(h > 0){\n        int p = key + (int)h - 1;\n        update(1, key, p, g + 1);\n        update(1, p+1, a, g);\n    } else {\n        update(1, key, a, g);\n    }\n}\n\nint main(){\n    while(~scanf(\"%d %d\", &n, &Q)){\n        build(1, 1, n);\n        int a;\n        LL b;\n        for(int i=1; i<=Q; i++){\n            scanf(\"%d %lld\", &a, &b);\n            solve(a, b);\n        }\n        for(int i=1; i<=n; i++){\n            printf(\"%lld\\n\", query(1, i, i));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    int n, q;\n    cin >> n >> q;\n    //cout << n << \" \" << q << endl;\n    using P = pair<int, ll>;\n    set<P> s;\n    s.insert(P(-1, TEN(13)));\n    s.insert(P(n-1, 0));\n\n    for (int i = 0; i < q; i++) {\n        int a; ll b;\n        cin >> a >> b; a--;\n        while (b) {\n            auto it = s.lower_bound(P(a, -1));\n            auto pr = *it; it--;\n            auto pl = *it;\n            int d = a-pl.first;            \n            if (d == 0) return 0;\n            if (a == pr.first) s.erase(pr);\n            if (d*(pl.second-pr.second) <= b) {\n                s.erase(pl); \n                s.insert(P(a, pl.second));\n                b -= d*(pl.second-pr.second);\n            } else {                \n                s.insert(P(a, pr.second + b/d));\n                if (b%d) {\n                    s.insert(P(pl.first + b%d, pr.second + b/d + 1));\n                }\n                if (pr.second + (b+d-1)/d == pl.second) {\n                    s.erase(pl);\n                }\n                b = 0;\n            }\n        }\n    }\n\n    ll res[n];\n    int b = -1;\n    for (auto p: s) {\n        for (int i = b+1; i <= p.first; i++) {\n            res[i] = p.second;\n        }\n        b = p.first;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for(int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntypedef long long LL;\ntypedef long double LD;\nint read() {\n    char ch = getchar();\n    int x = 0, flag = 1;\n    for (;!isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n    for (;isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x * flag;\n}\nvoid write(int x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x >= 10) write(x / 10);\n    putchar(x % 10 + 48);\n}\n\nconst int Maxn = 100009;\nint n, q;\n\ntemplate <int N> struct SGMTtree {\n\tpair<LL, int> t[N << 2]; LL add[N << 2];\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ls rt << 1, l, mid\n#define rs rt << 1 | 1, mid + 1, r\n\tvoid pushup(int u) {\n\t\tt[u] = min(t[lc(u)], t[rc(u)]);\n\t}\n\tvoid pushdown(int u) {\n\t\tif (add[u]) {\n\t\t\tadd[lc(u)] += add[u]; add[rc(u)] += add[u];\n\t\t\tt[lc(u)].first += add[u]; t[rc(u)].first += add[u];\n\t\t\tadd[u] = 0;\n\t\t}\n\t}\n\n\tvoid build(int rt, int l, int r) {\n\t\tif (l == r) {\n\t\t\tt[rt] = make_pair(0, l);\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1;\n\t\tbuild(ls), build(rs);\n\t\tpushup(rt);\n\t}\n\tvoid modify(int rt, int l, int r, int P, int Q, LL v) {\n\t\tif (P <= l && r <= Q) {\n\t\t\tadd[rt] += v; t[rt].first += v;\n\t\t\treturn ;\n\t\t}\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) modify(ls, P, Q, v);\n\t\telse if (P >= mid + 1) modify(rs, P, Q, v);\n\t\telse modify(ls, P, Q, v), modify(rs, P, Q, v);\n\t\tpushup(rt);\n\t}\n\n\tpair<LL, int> query(int rt, int l, int r, int P, int Q) {\n\t\tif (P > Q) return {-1, INT_MIN};\n\t\tif (P <= l && r <= Q) return t[rt];\n\n\t\tint mid = (l + r) >> 1; pushdown(rt);\n\t\tif (Q <= mid) return query(ls, P, Q);\n\t\telse if (P >= mid + 1) return query(rs, P, Q);\n\t\telse return min(query(ls, P, Q), query(rs, P, Q));\n\t}\n#undef lc\n#undef rc\n#undef ls\n#undef rs\n}; SGMTtree <Maxn> st;\n\nvoid init() {\n\tn = read(); q = read();\n\tst.build(1, 1, n);\n}\n\nint Find(LL v, int l, int r) {\n\tint ans = -1;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (st.query(1, 1, n, mid, mid).first <= v) l = mid + 1;\n\t\telse r = mid - 1, ans = mid;\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\trep (i, 1, q) {\n\t\tint r = read(); LL v = read();\n\t\twhile (v) {\n\t\t\tpair<LL, int> k = st.query(1, 1, n, 1, r);\n\t\t\tint pos = Find(k.first, k.second, r);\n\t\t\tif (pos == -1) pos = r; else --pos;\n\t\t\tLL z = st.query(1, 1, n, 1, k.second - 1).first;\n\t\t\t/*debug*/\n\t\t\tif (i == -1) {\n\t\t\t\tprintf(\"%d %d %d %d: %d\\n\", k.first, k.second, pos, v, z);\n\t\t\t}\n\t\t\t/*debug*/\n\t\t\tif (z == -1) {\n\t\t\t\tLL rest = v % r, partly = v / r;\n\t\t\t\tst.modify(1, 1, n, 1, r, partly);\n\t\t\t\tif (rest) st.modify(1, 1, n, 1, rest, 1);\n\t\t\t\tv = 0;\n\t\t\t} else {\n\t\t\t\tif ((z - k.first) * (pos - k.second + 1) <= v) {\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, z - k.first);\n\t\t\t\t\tv -= (z - k.first) * (pos - k.second + 1);\n\t\t\t\t} else {\n\t\t\t\t\tLL rest = v % (pos - k.second + 1), partly = v / (pos - k.second + 1);\n\t\t\t\t\tst.modify(1, 1, n, k.second, pos, partly);\n\t\t\t\t\tif (rest) st.modify(1, 1, n, k.second, k.second - rest + 1, 1);\n\t\t\t\t\tv = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\n\trep (i, 1, n) \n\t\tprintf(\"%lld\\n\", st.query(1, 1, n, i, i).first);\n}\n\nint main() {\n//\tfreopen(\"ATCs8pc_3_f.in\", \"r\", stdin);\n//\tfreopen(\"ATCs8pc_3_f.out\", \"w\", stdout);\n\n\tinit();\n\tsolve();\n\n#ifdef Qrsikno\n    debug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (int i = (s); i < (n); i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N, Q, A;\nLL B, res[100001];\n\nLL count(int m, int a) {\n\tLL sum = 0;\n\tREP(i, a-m, 0) {\n\t\tsum += (res[a-i-1] - res[a-i]) * (i + 1);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\tmemset(res, 0, sizeof(res));\n\tres[0] = 20000000000000;\n\tcin >> N >> Q;\n//\tN = 100000, Q = 100000;\n\twhile (Q--) {\n\t\tcin >> A >> B;\n//\t\tA = N, B = 1;\n\t\tif (B == 1) {\n\t\t\tint l = 0, r = A;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (r + l) / 2;\n\t\t\t\tif (res[m] != res[A]) l = m;\n\t\t\t\telse r = m;\n\t\t\t}\n\t\t\tres[r]++;\n\t\t\tcontinue;\n\t\t}\n\t\tint l = 0, r = A;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (r + l) / 2;\n//\t\t\tcout << m << \":\" << A << \":\" << count(m, A) << endl;\n\t\t\tif (count(m, A) > B) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tLL p = res[r];\n\t\tREP(i, A + 1, r + 1) {\n\t\t\tif (res[i] != p) {\n\t\t\t\tREP(j, A + 1, i) {\n\t\t\t\t\tB -= (p - res[j]);\n\t\t\t\t\tres[j] = p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tp = res[i];\n\t\t\t}\n\t\t}\n//\t\tcout << r << endl;\n\t\tREP(i, A + 1, r) {\n\t\t\tres[i] += B/(A - r + 1);\n\t\t}\n\t\tREP(i, r + B%(A - r + 1), r) {\n\t\t\tres[i]++;\n\t\t}\n//\t\tREP(i, N + 1, 1) cout << res[i];\n//\t\tcout << endl;\n\t}\n\tREP(i, N + 1, 1) cout << res[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint main(){\n  int n,q;\n  scanf(\"%d%d\",&n,&q);\n  map<pii,ll> M;\n  M[pii(0,n-1)] = 0;\n  while(q--){\n    int a;\n    ll b;\n    scanf(\"%d%lld\",&a,&b);\n    --a;\n    auto it = M.upper_bound(pii(a,n+252521));\n    it--;\n    if(it->first.second != a){\n      // split\n      ll val = it->second;\n      int beg = it->first.first;\n      int end = it->first.second;\n      M.erase(it);\n      M[pii(beg,a)] = val;\n      M[pii(a+1,end)] = val;\n      it = M.find(pii(beg,a));\n    }\n    while(b>0){\n      bool lastflag = false;\n      auto bef = it;\n      if(it == M.begin()){\n        lastflag = true;\n      }else{\n        bef--;\n        ll sub = bef->second - it->second;\n        ll rest = sub * (it->first.second - it->first.first + 1);\n        if(b>=rest){\n          b -= rest;\n          // join\n          ll val = bef->second;\n          int beg = bef->first.first;\n          int end = it->first.second;\n          M.erase(bef);\n          M.erase(it);\n          M[pii(beg,end)] = val;\n          it = M.find(pii(beg,end));\n        }else{\n          lastflag = true;\n        }\n      }\n      if(lastflag){\n        // split\n        ll aval = it->second;\n        ll bval = aval;\n        int beg = it->first.first;\n        int end = it->first.second;\n        int cnt = end-beg+1;\n        ll add = b/cnt;\n        aval += add;\n        bval += add;\n        b -= add*cnt;\n        if(b==0){\n          it->second = aval;\n        }else{\n          M.erase(it);\n          aval += 1;\n          int sp = beg+b-1;\n          b = 0;\n          M[pii(beg,sp)] = aval;\n          M[pii(sp+1,end)] = bval;\n          it = M.find(pii(beg,sp));\n        }\n        // join\n        if(it != M.begin()){\n          auto bef = it; bef--;\n          if(bef->second == it->second){\n            ll val = it->second;\n            int beg = bef->first.first;\n            int end = it->first.second;\n            M.erase(bef);\n            M.erase(it);\n            M[pii(beg,end)] = val;\n          }\n        }\n      }\n    }\n    // debug\n    // it = M.begin();\n    // REP(i,n){\n    //   printf(\"%lld \",it->second);\n    //   if(i == it->first.second){\n    //     it++;\n    //   }\n    // }\n    // putchar('\\n');\n  }\n  auto it = M.begin();\n  REP(i,n){\n    printf(\"%lld\\n\",it->second);\n    if(i == it->first.second){\n      it++;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#define md double\n#define LL long long\nusing namespace std;\nconst int N=1<<20;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\ninline LL gL() {\n\tLL w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nLL e[N],sum[N],tag[N],now[N];\nint dep[N];\nint main()\n{\n\tint n=gi(),Q=gi(),i,k,t,ed,siz,L,R,l,r,H=1,mid;LL q,suf,to;\n\tfor (siz=1;siz<n+2;siz=siz<<1|1) H++;\n\tfor (dep[1]=H,i=2;i<=(siz<<1|1);i++) dep[i]=dep[i>>1]-1;\n\te[siz+1]=3e13;\n#define lc (k<<1)\n#define rc (lc|1)\n#define pushdown tag[lc]=tag[rc]=e[lc]=e[rc]=tag[k],sum[lc]=sum[rc]=tag[k]<<dep[lc],tag[k]=0\n#define update e[k]=e[rc],sum[k]=sum[lc]+sum[rc]\n#define modify(k,to) tag[k]=e[k]=(to),sum[k]=(to)<<dep[k]\n\twhile (Q--) {\n\t\tL=siz+1,R=siz+(ed=gi()+1)+1;q=gL();\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=L>>i]) pushdown;\n\t\t\tif ((R>>i)!=k&&tag[k=R>>i]) pushdown;\n\t\t}\n\t\tfor (l=L,now[r=R]=0;l^r^1;l>>=1,r>>=1) {\n\t\t\tif (~l&1) now[l^1]=sum[l^1],now[l>>1]=now[l]+now[l^1]; else now[l>>1]=now[l];\n\t\t\tif (r&1) now[r^1]=sum[r^1],now[r>>1]=now[r^1]+now[r]; else now[r>>1]=now[r];\n\t\t}\n\t\tnow[l>>1]=now[l]+now[r];\n\t\tfor (k=l;(k>>=1)>1;) now[k>>1]=now[k];\n\t\tsuf=0;\n\t\tfor (k=l>>1,l=1,r=1<<dep[k];k<=siz;) {\n\t\t\tif (tag[k]) pushdown;\n\t\t\tif (ed<=(mid=(l+r)>>1)) k<<=1,r=mid;\n\t\t\telse k=k<<1|(mid=(l+r)>>1,q<=e[lc]*(ed-mid)-(r<=ed?sum[rc]:now[rc])-suf?(l=mid+1,1):(suf+=r<=ed?sum[rc]:now[rc],r=mid,0));\n\t\t}\n\t\tsuf+=sum[k];\n\t\tto=(q-(e[i]*(ed-l+1)-suf))/(ed-l+1);\n\t\tq-=to*(ed-l+1)-suf;t=--k;\n\t\tl=k,r=t+q+1;\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=l>>i]) pushdown;\n\t\t\tif ((r>>i)!=k&&tag[k=r>>i]) pushdown;\n\t\t}\n\t\tfor (;l^r^1;) {\n\t\t\tif (~l&1) modify(l^1,to+1);\n\t\t\tif (r&1) modify(r^1,to+1);\n\t\t\tk=l>>=1;update;\n\t\t\tk=r>>=1;update;\n\t\t}\n\t\twhile (k=(l>>=1)) update;\n\t\tl=t+q,r=siz+ed+1;\n\t\tfor (i=H;i;i--) {\n\t\t\tif (tag[k=l>>i]) pushdown;\n\t\t\tif ((r>>i)!=k&&tag[k=r>>i]) pushdown;\n\t\t}\n\t\tfor (;l^r^1;) {\n\t\t\tif (~l&1) modify(l^1,to);\n\t\t\tif (r&1) modify(r^1,to);\n\t\t\tk=l>>=1;update;\n\t\t\tk=r>>=1;update;\n\t\t}\n\t\twhile (k=(l>>=1)) update;\n\t}\n\tfor (k=1;k<=siz;k++) if (tag[k]) pushdown;\n\tfor (k=1;k<=n;k++) printf(\"%lld\\n\",e[k+siz+1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF=1e14;\nconst int maxn=100000+5;\n\nint N,Q;\n\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define mid ((l+r)>>1)\n\n#define val first\n#define pos second\ntypedef pair<ll,int> Min;//Min(val,pos)\n\nMin mn[maxn<<2];\nll add[maxn<<2];\n\nvoid put_up(int x) {\n\tmn[x]=min(mn[lc],mn[rc]);\n}\n\nvoid put_down(int x) {\n\tif(!add[x]) return ;\n\tadd[lc]+=add[x];\n\tmn[lc].val+=add[x];\n\tadd[rc]+=add[x];\n\tmn[rc].val+=add[x];\n\tadd[x]=0;\n}\n\nvoid build(int x,int l,int r) {\n\tmn[x]=Min(0,l);\n\tif(l==r) return ;\n\tbuild(lc,l,mid);\n\tbuild(rc,mid+1,r);\n\tput_up(x);\n}\n\nvoid update(int x,int l,int r,int ql,int qr,int v) {\n\tif(ql<=l&&r<=qr) {\n\t\tadd[x]+=v;\n\t\tmn[x].val+=v;\n\t\treturn ;\n\t}\n\tput_down(x);\n\tif(ql<=mid) update(lc,l,mid,ql,qr,v);\n\tif(qr>mid) update(rc,mid+1,r,ql,qr,v);\n\tput_up(x);\n}\n\nMin query(int x,int l,int r,int ql,int qr) {\n\tif(ql<=l&&r<=qr) return mn[x];\n\tput_down(x);\n\tMin L(INF,N+1),R(INF,N+1);\n\tif(ql<=mid) L=query(lc,l,mid,ql,qr);\n\tif(qr>mid) R=query(rc,mid+1,r,ql,qr);\n\treturn min(L,R);\n}\n\nint main() {\n\tint a;ll b;\n\tscanf(\"%d%d\",&N,&Q);\n\tbuild(1,1,N);\n\twhile(Q--) {\n\t\tscanf(\"%d%lld\",&a,&b);\n\t\twhile(b) {\n\t\t\tMin x=query(1,1,N,1,a);\n\t\t\tif(x.pos==1) {\n\t\t\t\tll c=b/a;\n\t\t\t\tupdate(1,1,N,1,a,c);\n\t\t\t\tif((b-=c*a)>0)\n\t\t\t\t\tupdate(1,1,N,1,b,1);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tll v=query(1,1,N,x.pos-1,x.pos-1).val;\n\t\t\t\tif((v-x.val)*(a-x.pos+1)>b) {\n\t\t\t\t\tint c=b/(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,c);\n\t\t\t\t\tif((b-=c*(a-x.pos+1))>0) update(1,1,N,x.pos,x.pos+b-1,1);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tb-=(v-x.val)*(a-x.pos+1);\n\t\t\t\t\tupdate(1,1,N,x.pos,a,v-x.val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) printf(\"%lld\\n\",query(1,1,N,i,i).val);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// <sushi.cpp> - Sat Mar 25 08:49:56 2017\n// This file is created by XuYike's black technology automatically.\n// Copyright (C) 2015 ChangJun High School, Inc.\n// I don't know what this program is.\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef long long lol;\ntemplate<typename T>\ninline void gg(T &res){\n    res=0;T fh=1;char ch=getchar();\n    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();\n    if(ch=='-')fh=-1,ch=getchar();\n    while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();\n    res*=fh;\n}\ninline int gi(){int x;gg(x);return x;}\ninline lol gl(){lol x;gg(x);return x;}\nconst int MAXN=100010;\nconst int MAXK=MAXN<<2;\nconst lol INF=1e18;\nint n,pos[MAXN];\nlol val[MAXK],lazy[MAXK],mi[MAXK];\ninline void update(int x){\n    val[x]=val[x<<1]+val[x<<1|1];\n    mi[x]=min(mi[x<<1],mi[x<<1|1]);\n}\nvoid pushdown(int x,int l,int r){\n    if(!lazy[x])return;\n    int m=l+r>>1;\n    val[x<<1]=(m-l+1)*lazy[x];\n    val[x<<1|1]=(r-m)*lazy[x];\n    mi[x<<1]=mi[x<<1|1]=lazy[x<<1]=lazy[x<<1|1]=lazy[x];\n    lazy[x]=0;\n}\nlol getsum(int L,int R,int l=0,int r=n,int x=1){\n    if(l==L&&r==R)return val[x];\n    pushdown(x,l,r);\n    int m=l+r>>1;lol ans=0;\n    if(L<=m)ans+=getsum(L,min(R,m),l,m,x<<1);\n    if(R>m)ans+=getsum(max(L,m+1),R,m+1,r,x<<1|1);\n    return ans;\n}\nint find(int p,lol s,lol y,int l=0,int r=n,int x=1){\n    if(l==r)return l;\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    if(p<=m||s-val[x<<1]+y>mi[x<<1]*(p-m))return find(p,s,y,l,m,x<<1);\n    return find(p,s-val[x<<1],y,m+1,r,x<<1|1);\n}\nvoid set(int L,int R,lol v,int l=0,int r=n,int x=1){\n    if(L>R)return;\n    if(l==L&&r==R){\n        val[x]=(r-l+1)*v;\n        lazy[x]=mi[x]=v;\n        return;\n    }\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    if(L<=m)set(L,min(R,m),v,l,m,x<<1);\n    if(R>m)set(max(L,m+1),R,v,m+1,r,x<<1|1);\n    update(x);\n}\nvoid dfs(int l,int r,int x){\n    if(l==r){\n        if(l!=n)printf(\"%lld\\n\",val[x]);\n        return;\n    }\n    pushdown(x,l,r);\n    int m=l+r>>1;\n    dfs(l,m,x<<1);\n    dfs(m+1,r,x<<1|1);\n}\nint main(){\n    n=gi();int m=gi();\n    while(m--){\n        int x=gi()-1;\n        lol s=getsum(0,x),y=gl();\n        int p=find(x,s,y);s=getsum(p,x);\n        set(p,x,(y+s)/(x-p+1));\n        set(p,p+(y+s)%(x-p+1)-1,(y+s)/(x-p+1)+1);\n    }\n    dfs(0,n,1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct P{\n\tint id;\t\t//id\n\tint num;\t//食べた寿司数\n\tbool operator<(const P& p) const{\n\t\tif (num < p.num){\n\t\t\treturn true;\n\t\t}\n\t\tif (num == p.num){\n\t\t\treturn id<p.id;\n\t\t}\n\t\treturn false;\n\t}\n\tP(int _id,int _num){\n\t\tid=_id;\n\t\tnum=_num;\n\t}\n};\nvoid SetMinP(vector<P*> p,int a,long long b)\n{\n\tP *minP=p[0];\n\twhile (b>0){\n\t\tfor (int i=0;i<a;i++){\n\t\t\tif (*p[i]<*minP){\n\t\t\t\tminP = p[i];\n\t\t\t}\n\t\t}\n\t\tminP->num++;\n\t\tb--;\n\t}\n}\nint main(int argc, char* argv[])\n{\n\tint N,Q;\n\tcin>>N>>Q;\n\tvector<P*> pVector;\n\tint i;\n\tP *p;\n\tfor (i=0;i<N;i++){\n\t\tp = new P(i+1,0);\n\t\tpVector.push_back(p);\n\t}\n\tint a;\n\tlong long b;\n\tfor (i=0;i<Q;i++){\n\t\tcin>>a>>b;\n\t\tSetMinP(pVector,a,b);\n\t}\n\tfor (i=0;i<pVector.size();i++){\n\t\tcout<<pVector[i]->num<<endl;\n\t\tdelete pVector[i];\n\t}\n\tpVector.clear();\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    int Q = sc.nextInt();\n    int[] A = new int[Q];\n    int[] B = new int[Q];\n    for (int i = 0; i < Q; i++) {\n      A[i] = Integer.parseInt(sc.next());\n      B[i] = Integer.parseInt(sc.next());\n    }\n    TreeSet<Range> ranges = new TreeSet<>();\n    ranges.add(new Range(0, 0));\n    ranges.add(new Range(N, -1));\n    for (int i = 0; i < Q; i++) {\n      Range cur = ranges.lower(new Range(A[i], 0));\n      Range next = ranges.higher(cur);\n      if (A[i] != next.start) {\n        next = new Range(A[i], cur.count);\n        ranges.add(next);\n      }\n      while (true) {\n        Range prev = ranges.lower(cur);\n        int len = next.start - cur.start;\n        if (prev == null || (prev.count - cur.count - 1) * len >= B[i]) {\n          cur.count += B[i] / len;\n          if (B[i] % len != 0) {\n            ranges.add(new Range(cur.start + B[i] % len, cur.count));\n            cur.count++;\n          }\n          break;\n        } else if ((prev.count - cur.count) * len >= B[i]) {\n          if (B[i] % len != 0) {\n            cur.start += B[i] % len;\n            cur.count += B[i] / len;\n          } else {\n            ranges.remove(cur);\n          }\n          break;\n        } else {\n          B[i] -= (prev.count - cur.count) * len;\n          ranges.remove(cur);\n          cur = prev;\n        }\n      }\n    }\n    StringBuilder sb = new StringBuilder();\n    ArrayList<Range> rangeList = new ArrayList<>(ranges);\n    for (int i = 0; i < rangeList.size() - 1; i++) {\n      for (int j = 0; j < rangeList.get(i + 1).start - rangeList.get(i).start; j++) {\n        sb.append(rangeList.get(i).count + \"\\n\");\n      }\n    }\n    System.out.print(sb);\n  }\n\n  static class Range implements Comparable<Range> {\n    int start;\n    long count;\n\n    public Range(int start, long count) {\n      this.start = start;\n      this.count = count;\n    }\n\n    @Override\n    public int compareTo(Range o) {\n      return Integer.compare(this.start, o.start);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      Range range = (Range) o;\n      return start == range.start;\n    }\n\n    @Override\n    public int hashCode() {\n      return start;\n    }\n\n    @Override\n    public String toString() {\n      return \"Range{\" +\n          \"start=\" + start +\n          \", count=\" + count +\n          '}';\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass UpdateRangeGetRangeSegmentTree<T, S> {\n  public interface Operator<T, S> {\n    T multiplyLazyValue(T lazy, int count);\n    T getUnitLazy();\n    T mergeLazyValue(T lazy1, T lazy2);\n    S apply(S value, T lazy);\n    S mergeValue(S smallValue, S largeValue);\n    S getUnitValue();\n  }\n  \n  private final Operator<T, S> operator;\n  private final int n;\n  private final List<T> lazies;\n  private final List<S> values;\n  \n  public UpdateRangeGetRangeSegmentTree(Operator<T, S> operator, S[] initialValues) {\n    this.operator = operator;\n    \n    int tempN = 1;\n    while (tempN < initialValues.length) {\n      tempN *= 2;\n    }\n    n = tempN;\n    lazies = new ArrayList<>();\n    values = new ArrayList<>();\n    for (int i = 0; i < 2 * n - 1; i++) {\n      lazies.add(this.operator.getUnitLazy());\n      values.add(null);\n    }\n    for (int i = 0; i < initialValues.length; i++) {\n      values.set(i + n - 1, initialValues[i]);\n    }\n    for (int i = initialValues.length; i < n; i++) {\n      values.set(i + n - 1, this.operator.getUnitValue());\n    }\n    for (int i = n - 2; i >= 0; i--) {\n      values.set(i, this.operator.mergeValue(values.get(2 * i + 1), values.get(2 * i + 2)));\n    }\n  }\n  \n  private void eval(int k, int l, int r) {\n    if (lazies.get(k).equals(operator.getUnitLazy())) {\n      return;\n    }\n    values.set(k, operator.apply(values.get(k), operator.multiplyLazyValue(lazies.get(k), r - l)));\n    if (r - l > 1) {\n      lazies.set(2 * k + 1, operator.mergeLazyValue(lazies.get(2 * k + 1), lazies.get(k)));\n      lazies.set(2 * k + 2, operator.mergeLazyValue(lazies.get(2 * k + 2), lazies.get(k)));\n    }\n    lazies.set(k, operator.getUnitLazy());\n  }\n  \n  private void update(int a, int b, T lazy, int k, int l, int r) {\n    eval(k, l, r);\n    if (b <= l || r <= a) {\n      return;\n    }\n    if (a <= l && r <= b) {\n      lazies.set(k, operator.mergeLazyValue(lazies.get(k), lazy));\n      eval(k, l, r);\n    } else {\n      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, lazy, 2 * k + 2, (l + r) / 2, r);\n      values.set(k, operator.mergeValue(values.get(2 * k + 1), values.get(2 * k + 2)));\n    }\n  }\n  \n  public void update(int a, int b, T lazy) {\n    update(a, b, lazy, 0, 0, n);\n  }\n  \n  private S getRange(int a, int b, int k, int l, int r) {\n    if (b <= l || r <= a) {\n      return operator.getUnitValue();\n    }\n    eval(k, l, r);\n    if (a <= l && r <= b) {\n      return values.get(k);\n    }\n    S vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);\n    S vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);\n    return operator.mergeValue(vl, vr);\n  }\n  \n  public S getRange(int a, int b) {\n    return getRange(a, b, 0, 0, n);\n  }\n  \n  public S get(int a) {\n    return getRange(a, a + 1);\n  }\n  \n  public void dump() {\n    for (int i = 0; i < 2 * n - 1; i++) {\n      System.err.print(values.get(i));\n      System.err.print(\" \");\n    }\n    System.err.println();\n    for (int i = 0; i < 2 * n - 1; i++) {\n      System.err.print(lazies.get(i));\n      System.err.print(\" \");\n    }\n    System.err.println();\n  }\n}\n\nclass Solver {\n  private static final UpdateRangeGetRangeSegmentTree.Operator<Long, Long> operator = new UpdateRangeGetRangeSegmentTree.Operator<Long, Long>() {\n    private Long zero = Long.valueOf(0);\n    private Long inf = Long.valueOf(Long.MAX_VALUE);\n    \n    public Long mergeValue(Long v1, Long v2) {\n      return Math.max(v1, v2);\n    }\n    \n    public Long apply(Long value, Long lazy) {\n      return lazy;\n    }\n    \n    public Long getUnitValue() {\n      return zero;\n    }\n    \n    public Long mergeLazyValue(Long lazy1, Long lazy2) {\n      return lazy2;\n    }\n    \n    public Long multiplyLazyValue(Long lazy, int count) {\n      return lazy;\n    }\n    \n    public Long getUnitLazy() {\n      return zero;\n    }\n  };\n  \n  final int n, q;\n  final long[][] abs;\n  UpdateRangeGetRangeSegmentTree<Long, Long> segmentTree;\n    \n    \n  Solver(int n, int q, long[][] abs) {\n    this.n = n;\n    this.q = q;\n    this.abs = abs;\n  }\n  \n  private int findMinIndex(int a) {\n    int max = a;\n    int min = 0;\n    long aValue = segmentTree.get(a);\n    while (max - min > 1) {\n      int mid = (max + min) / 2;\n      long midValue = segmentTree.get(mid);\n      if (midValue > aValue) {\n        min = mid;\n      } else {\n        max = mid;\n      }\n    }\n    return max;\n  }\n  \n  private void serve(int aIndex, long b) {\n    if (b <= 0) {\n      return;\n    }\n    \n    long aValue = segmentTree.get(aIndex);\n    int minIndex = findMinIndex(aIndex);\n    long nextValue = segmentTree.get(minIndex - 1);\n    long capacity = (nextValue - aValue) * (aIndex - minIndex + 1);\n    if (b >= capacity) {\n      segmentTree.update(minIndex, aIndex + 1, nextValue);\n      serve(aIndex, b - capacity);\n    } else {\n      int mod = (int)(b % (aIndex - minIndex + 1));\n      if (mod > 0) {\n        segmentTree.update(minIndex, minIndex + mod, b / (aIndex - minIndex + 1) + 1 + aValue);\n      }\n      segmentTree.update(minIndex + mod, aIndex + 1, b / (aIndex - minIndex + 1) + aValue);\n    }\n  }\n  \n  public List<Long> solve() {\n    Long zero = Long.valueOf(0);\n    Long[] initialValues = new Long[n + 1];\n    Arrays.fill(initialValues, zero);\n    initialValues[0] = 30_000_000_000_000L;\n    segmentTree = new UpdateRangeGetRangeSegmentTree<>(operator, initialValues);\n    \n    for (long[] ab : abs) {\n      serve((int)ab[0], ab[1]);\n    }\n    List<Long> answers = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n      answers.add(segmentTree.get(i));\n    }\n    return answers;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int q = reader.nextInt();\n    long[][] abs = reader.nextLong(q, 2);\n    for (long answer : new Solver(n, q, abs).solve()) {\n      out.println(answer);\n    }\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n/*\nclass RangeValueManager {\n  TreeMap<Long, Long> \n}\n*/\n\nclass UpdateRangeGetRangeSegmentTree<T, S> {\n  public interface Operator<T, S> {\n    T multiplyLazyValue(T lazy, int count);\n    T getUnitLazy();\n    T mergeLazyValue(T lazy1, T lazy2);\n    S apply(S value, T lazy);\n    S mergeValue(S smallValue, S largeValue);\n    S getUnitValue();\n  }\n  \n  private final Operator<T, S> operator;\n  private final int n;\n  private final List<T> lazies;\n  private final List<S> values;\n  \n  public UpdateRangeGetRangeSegmentTree(Operator<T, S> operator, S[] initialValues) {\n    this.operator = operator;\n    \n    int tempN = 1;\n    while (tempN < initialValues.length) {\n      tempN *= 2;\n    }\n    n = tempN;\n    lazies = new ArrayList<>();\n    values = new ArrayList<>();\n    for (int i = 0; i < 2 * n - 1; i++) {\n      lazies.add(this.operator.getUnitLazy());\n      values.add(null);\n    }\n    for (int i = 0; i < initialValues.length; i++) {\n      values.set(i + n - 1, initialValues[i]);\n    }\n    for (int i = initialValues.length; i < n; i++) {\n      values.set(i + n - 1, this.operator.getUnitValue());\n    }\n    for (int i = n - 2; i >= 0; i--) {\n      values.set(i, this.operator.mergeValue(values.get(2 * i + 1), values.get(2 * i + 2)));\n    }\n  }\n  \n  private void eval(int k, int l, int r) {\n    if (lazies.get(k).equals(operator.getUnitLazy())) {\n      return;\n    }\n    values.set(k, operator.apply(values.get(k), operator.multiplyLazyValue(lazies.get(k), r - l)));\n    if (r - l > 1) {\n      lazies.set(2 * k + 1, operator.mergeLazyValue(lazies.get(2 * k + 1), lazies.get(k)));\n      lazies.set(2 * k + 2, operator.mergeLazyValue(lazies.get(2 * k + 2), lazies.get(k)));\n    }\n    lazies.set(k, operator.getUnitLazy());\n  }\n  \n  private void update(int a, int b, T lazy, int k, int l, int r) {\n    eval(k, l, r);\n    if (b <= l || r <= a) {\n      return;\n    }\n    if (a <= l && r <= b) {\n      lazies.set(k, operator.mergeLazyValue(lazies.get(k), lazy));\n      eval(k, l, r);\n    } else {\n      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, lazy, 2 * k + 2, (l + r) / 2, r);\n      values.set(k, operator.mergeValue(values.get(2 * k + 1), values.get(2 * k + 2)));\n    }\n  }\n  \n  public void update(int a, int b, T lazy) {\n    update(a, b, lazy, 0, 0, n);\n  }\n  \n  private S getRange(int a, int b, int k, int l, int r) {\n    if (b <= l || r <= a) {\n      return operator.getUnitValue();\n    }\n    eval(k, l, r);\n    if (a <= l && r <= b) {\n      return values.get(k);\n    }\n    S vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);\n    S vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);\n    return operator.mergeValue(vl, vr);\n  }\n  \n  public S getRange(int a, int b) {\n    return getRange(a, b, 0, 0, n);\n  }\n  \n  public S get(int a) {\n    return getRange(a, a + 1);\n  }\n  \n  public void dump() {\n    for (int i = 0; i < 2 * n - 1; i++) {\n      System.err.print(values.get(i));\n      System.err.print(\" \");\n    }\n    System.err.println();\n    for (int i = 0; i < 2 * n - 1; i++) {\n      System.err.print(lazies.get(i));\n      System.err.print(\" \");\n    }\n    System.err.println();\n  }\n}\n\nclass Solver {\n  private static final UpdateRangeGetRangeSegmentTree.Operator<Long, Long> operator = new UpdateRangeGetRangeSegmentTree.Operator<Long, Long>() {\n    private Long zero = Long.valueOf(0);\n    private Long inf = Long.valueOf(Long.MAX_VALUE);\n    \n    public Long mergeValue(Long v1, Long v2) {\n      return Math.max(v1, v2);\n    }\n    \n    public Long apply(Long value, Long lazy) {\n      return lazy;\n    }\n    \n    public Long getUnitValue() {\n      return zero;\n    }\n    \n    public Long mergeLazyValue(Long lazy1, Long lazy2) {\n      return lazy2;\n    }\n    \n    public Long multiplyLazyValue(Long lazy, int count) {\n      return lazy;\n    }\n    \n    public Long getUnitLazy() {\n      return zero;\n    }\n  };\n  \n  final int n, q;\n  final long[][] abs;\n//  UpdateRangeGetRangeSegmentTree<Long, Long> segmentTree;\n  TreeMap<Integer, Long> map;\n  \n  \n  Solver(int n, int q, long[][] abs) {\n    this.n = n;\n    this.q = q;\n    this.abs = abs;\n  }\n  \n  private void serve(int aIndex, long b) {\n    if (b <= 0) {\n      return;\n    }\n    \n    Map.Entry<Integer, Long> floorEntry = map.floorEntry(aIndex);\n    long aValue = floorEntry.getValue();\n    int minIndex = floorEntry.getKey();\n    long nextValue = map.lowerEntry(minIndex).getValue();\n    long capacity = (nextValue - aValue) * (aIndex - minIndex + 1);\n    if (b >= capacity) {\n      map.remove(minIndex);\n      if (map.get(aIndex + 1) == null) {\n        map.put(aIndex + 1, aValue);\n      }\n      serve(aIndex, b - capacity);\n    } else {\n      int mod = (int)(b % (aIndex - minIndex + 1));\n      if (mod > 0) {\n        map.put(minIndex, b / (aIndex - minIndex + 1) + 1 + aValue);\n      }\n      map.put(minIndex + mod, b / (aIndex - minIndex + 1) + aValue);\n      if (map.get(aIndex + 1) == null && b / (aIndex - minIndex + 1) > 0) {\n        map.put(aIndex + 1, aValue);\n      }\n    }\n  }\n  \n  public List<Long> solve() {\n    map = new TreeMap<>();\n    map.put(0, 30_000_000_000_000L);\n    map.put(1, 0L);\n    map.put(n + 1, -1L);\n    \n    for (long[] ab : abs) {\n      serve((int)ab[0], ab[1]);\n    }\n    List<Long> answers = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n      answers.add(map.floorEntry(i).getValue());\n    }\n    return answers;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int q = reader.nextInt();\n    long[][] abs = reader.nextLong(q, 2);\n    for (long answer : new Solver(n, q, abs).solve()) {\n      out.println(answer);\n    }\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solver {\n  final int n, q;\n  final long[][] abs;\n  TreeMap<Integer, Long> map;\n  \n  Solver(int n, int q, long[][] abs) {\n    this.n = n;\n    this.q = q;\n    this.abs = abs;\n  }\n  \n  private void serve(int aIndex, long b) {\n    if (b <= 0) {\n      return;\n    }\n    \n    Map.Entry<Integer, Long> floorEntry = map.floorEntry(aIndex);\n    long aValue = floorEntry.getValue();\n    int minIndex = floorEntry.getKey();\n    long nextValue = map.lowerEntry(minIndex).getValue();\n    long capacity = (nextValue - aValue) * (aIndex - minIndex + 1);\n    if (b >= capacity) {\n      map.remove(minIndex);\n      if (map.get(aIndex + 1) == null) {\n        map.put(aIndex + 1, aValue);\n      }\n      serve(aIndex, b - capacity);\n    } else {\n      int mod = (int)(b % (aIndex - minIndex + 1));\n      if (mod > 0) {\n        map.put(minIndex, b / (aIndex - minIndex + 1) + 1 + aValue);\n      }\n      map.put(minIndex + mod, b / (aIndex - minIndex + 1) + aValue);\n      if (map.get(aIndex + 1) == null && b / (aIndex - minIndex + 1) > 0) {\n        map.put(aIndex + 1, aValue);\n      }\n    }\n  }\n  \n  public List<Long> solve() {\n    map = new TreeMap<>();\n    map.put(0, 30_000_000_000_000L);\n    map.put(1, 0L);\n    map.put(n + 1, -1L);\n    \n    for (long[] ab : abs) {\n      serve((int)ab[0], ab[1]);\n    }\n    List<Long> answers = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n      answers.add(map.floorEntry(i).getValue());\n    }\n    return answers;\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, PrintWriter out) {\n    int n = reader.nextInt();\n    int q = reader.nextInt();\n    long[][] abs = reader.nextLong(q, 2);\n    for (long answer : new Solver(n, q, abs).solve()) {\n      out.println(answer);\n    }\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    int Q = sc.nextInt();\n    int[] A = new int[Q];\n    long[] B = new long[Q];\n    for (int i = 0; i < Q; i++) {\n      A[i] = Integer.parseInt(sc.next());\n      B[i] = Long.parseLong(sc.next());\n    }\n    TreeSet<Range> ranges = new TreeSet<>();\n    ranges.add(new Range(0, 0));\n    ranges.add(new Range(N, -1));\n    for (int i = 0; i < Q; i++) {\n      Range cur = ranges.lower(new Range(A[i], 0));\n      Range next = ranges.higher(cur);\n      if (A[i] != next.start) {\n        next = new Range(A[i], cur.count);\n        ranges.add(next);\n      }\n      while (true) {\n        Range prev = ranges.lower(cur);\n        int len = next.start - cur.start;\n        if (prev == null || (prev.count - cur.count - 1) * len >= B[i]) {\n          cur.count += B[i] / len;\n          if (B[i] % len != 0) {\n            ranges.add(new Range(cur.start + (int)(B[i] % len), cur.count));\n            cur.count++;\n          }\n          break;\n        } else if ((prev.count - cur.count) * len >= B[i]) {\n          if (B[i] % len != 0) {\n            cur.start += B[i] % len;\n            cur.count += B[i] / len;\n          } else {\n            ranges.remove(cur);\n          }\n          break;\n        } else {\n          B[i] -= (prev.count - cur.count) * len;\n          ranges.remove(cur);\n          cur = prev;\n        }\n      }\n    }\n    StringBuilder sb = new StringBuilder();\n    ArrayList<Range> rangeList = new ArrayList<>(ranges);\n    for (int i = 0; i < rangeList.size() - 1; i++) {\n      for (int j = 0; j < rangeList.get(i + 1).start - rangeList.get(i).start; j++) {\n        sb.append(rangeList.get(i).count + \"\\n\");\n      }\n    }\n    System.out.print(sb);\n  }\n\n  static class Range implements Comparable<Range> {\n    int start;\n    long count;\n\n    public Range(int start, long count) {\n      this.start = start;\n      this.count = count;\n    }\n\n    @Override\n    public int compareTo(Range o) {\n      return Integer.compare(this.start, o.start);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      Range range = (Range) o;\n      return start == range.start;\n    }\n\n    @Override\n    public int hashCode() {\n      return start;\n    }\n\n    @Override\n    public String toString() {\n      return \"Range{\" +\n          \"start=\" + start +\n          \", count=\" + count +\n          '}';\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Main {\n\tfinal int _intMax = Integer.MAX_VALUE; //=2147483647>10^9\n\tfinal long _longMax = Long.MAX_VALUE; //=9223372036854775807L>10^18\n\tstatic boolean bElapsed = false;\n\tStringBuilder sb = new StringBuilder();\n\tList<String> list = new ArrayList<>();\n\tSet<String> set = new HashSet<>();\n\tMap<String,String> map = new HashMap<>();\n\tQueue<String> queue = new ArrayDeque<>();\n\tDeque<String> stack = new ArrayDeque<>();\n\n\tvoid solve() {\n\t\tint[] ia = readNums();\n\t\tint n = ia[0];\n\t\tint q = ia[1];\n\t\tlong cnt[] = new long[n+1];\n\t\tfor (int i=0; i<q; i++) {\n\t\t\tia = readNums();\n\t\t\tint a = ia[0];\n\t\t\tint b = ia[1];\n\t\t\tfor (int j=0; j<b; j++) {\n\t\t\t\tint min = 1;\n\t\t\t\tfor (int k=1; k<=a; k++) {\n\t\t\t\t\tif (cnt[k] < cnt[min]) min=k;\n\t\t\t\t}\n\t\t\t\tcnt[min]++;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1; i<=n; i++) {\n\t\t\tpln(cnt[i]);\n\t\t}\n\t}\n\n\tclass Point {\n\t\tint x;\n\t\tint y;\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic Point(Point pt) {\n\t\t\tthis.x = pt.x;\n\t\t\tthis.y = pt.y;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Point) {\n\t\t\t\tPoint that = (Point)o;\n\t\t\t\treturn (x == that.x) && (y == that.y);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn x + (y << 16);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \", \" + y + \")\";\n\t\t}\n\t}\n\tclass Info implements Comparable<Info> {\n\t\tint idx;\n\t\tint val;\n\t\tpublic Info(int idx, int val) {\n\t\t\tthis.idx = idx;\n\t\t\tthis.val = val;\n\t\t}\n\t\tpublic int compareTo(Info o) {\n\t\t\treturn idx - o.idx;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Info) {\n\t\t\t\tInfo that = (Info)o;\n\t\t\t\treturn 0 == compareTo(that);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn idx + (val << 16);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + idx + \", \" + val + \")\";\n\t\t}\n\t}\n\tclass InfoComp implements Comparator<Info> {\n\t\tpublic int compare(Info o1, Info o2) {\n\t\t\treturn o1.val - o2.val;\n\t\t}\n\t}\n\tint pint(String s) {\n\t\treturn Integer.parseInt(s);\n\t}\n\tString readLine() {\n\t\ttry {\n\t\t\t_line = _in.readLine();\n\t\t\treturn _line;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\tint readNum() {\n\t\treadLine();\n\t\treturn pint(_line);\n\t}\n\tString[] readFields() {\n\t\treadLine();\n\t\t_flds = _line.split(\" \");\n\t\treturn _flds;\n\t}\n\tint[] readNums() {\n\t\treadFields();\n\t\t_nums = new int[_flds.length];\n\t\tfor (int i=0; i<_flds.length; i++) {\n\t\t\t_nums[i] = pint(_flds[i]);\n\t\t}\n\t\treturn _nums;\n\t}\n\tvoid p(char c) {\n\t\t_out.print(c);\n\t}\n\tvoid pln(char c) {\n\t\t_out.println(c);\n\t}\n\tvoid p(double d) {\n\t\t_out.print(d);\n\t}\n\tvoid pln(double d) {\n\t\t_out.println(d);\n\t}\n\tvoid p(long l) {\n\t\t_out.print(l);\n\t}\n\tvoid pln(long l) {\n\t\t_out.println(l);\n\t}\n\tvoid p(String s) {\n\t\t_out.print(s);\n\t}\n\tvoid pln(String s) {\n\t\t_out.println(s);\n\t}\n\tString _line;\n\tString[] _flds;\n\tint[] _nums;\n\tstatic BufferedReader _in;\n\tstatic PrintWriter _out;\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\t\t_in = new BufferedReader(new InputStreamReader(System.in));\n\t\t_out = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\t_out.flush();\n\t\tlong end = System.currentTimeMillis();\n\t\tif (bElapsed) {\n\t\t\tSystem.err.println((end-start) + \"ms\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), Q = ni();\n\t\t\n\t\tLST lst = new LST(n+3);\n\t\tlst.set(0);\n\t\tlong[] ft = new long[n+3];\n\t\tfor(int z = 0;z < Q;z++){\n\t\t\tint a = ni()-1;\n\t\t\tlong b = nl();\n\t\t\tlst.set(a+1);\n\t\t\twhile(true){\n\t\t\t\tint p = lst.prev(a);\n\t\t\t\tif(p > 0){\n\t\t\t\t\tlong need = -sumFenwick(ft, p) + sumFenwick(ft, p-1);\n\t\t\t\t\tif(need == 0){\n\t\t\t\t\t\tlst.unset(p);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tlong up = Math.min(need, b/(a-p+1));\n\t\t\t\t\tif(up == 0){\n\t\t\t\t\t\taddFenwick(ft, p, 1);\n\t\t\t\t\t\taddFenwick(ft, (int)(p+b), -1);\n\t\t\t\t\t\tlst.set((int)(p+b));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\taddFenwick(ft, p, up);\n\t\t\t\t\taddFenwick(ft, a+1, -up);\n\t\t\t\t\tlst.set(a+1);\n\t\t\t\t\tb -= up * (a-p+1);\n\t\t\t\t\tif(need == up){\n\t\t\t\t\t\tlst.unset(p);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlong up = b/(a-p+1);\n\t\t\t\t\tif(up == 0){\n\t\t\t\t\t\taddFenwick(ft, p, 1);\n\t\t\t\t\t\taddFenwick(ft, (int)(p+b), -1);\n\t\t\t\t\t\tlst.set((int)(p+b));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\taddFenwick(ft, p, up);\n\t\t\t\t\taddFenwick(ft, a+1, -up);\n\t\t\t\t\tlst.set(a+1);\n\t\t\t\t\tb -= up * (a-p+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tout.println(sumFenwick(ft, i));\n\t\t}\n\t}\n\t\n\n\t\n\tpublic static long sumFenwick(long[] ft, int i)\n\t{\n\t\tlong sum = 0;\n\t\tfor(i++;i > 0;i -= i&-i)sum += ft[i];\n\t\treturn sum;\n\t}\n\t\n\tpublic static void addFenwick(long[] ft, int i, long v)\n\t{\n\t\tif(v == 0)return;\n\t\tint n = ft.length;\n\t\tfor(i++;i < n;i += i&-i)ft[i] += v;\n\t}\n\tpublic static class LST {\n\t\tpublic long[][] set;\n\t\tpublic int n;\n//\t\tpublic int size;\n\t\t\n\t\tpublic LST(int n) {\n\t\t\tthis.n = n;\n\t\t\tint d = 1;\n\t\t\tfor(int m = n;m > 1;m>>>=6, d++);\n\t\t\t\n\t\t\tset = new long[d][];\n\t\t\tfor(int i = 0, m = n>>>6;i < d;i++, m>>>=6){\n\t\t\t\tset[i] = new long[m+1];\n\t\t\t}\n//\t\t\tsize = 0;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST setRange(int r)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\tfor(int j = 0;j < r>>>6;j++){\n\t\t\t\t\tset[i][j] = -1L;\n\t\t\t\t}\n\t\t\t\tif((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST unsetRange(int r)\n\t\t{\n\t\t\tif(r >= 0){\n\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\tfor(int j = 0;j < r+63>>>6;j++){\n\t\t\t\t\t\tset[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST set(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(!get(pos))size++;\n\t\t\t\tfor(int i = 0;i < set.length;i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] |= 1L<<pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST unset(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(get(pos))size--;\n\t\t\t\tfor(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] &= ~(1L<<pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic boolean get(int pos)\n\t\t{\n\t\t\treturn pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;\n\t\t}\n\t\t\n\t\tpublic int prev(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){\n\t\t\t\tint pre = prev(set[i][pos>>>6], pos&63);\n\t\t\t\tif(pre != -1){\n\t\t\t\t\tpos = pos>>>6<<6|pre;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic int next(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){\n\t\t\t\tint nex = next(set[i][pos>>>6], pos&63);\n\t\t\t\tif(nex != -1){\n\t\t\t\t\tpos = pos>>>6<<6|nex;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tprivate static int prev(long set, int n)\n\t\t{\n\t\t\tlong h = Long.highestOneBit(set<<~n);\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)-(63-n);\n\t\t}\n\t\t\n\t\tprivate static int next(long set, int n)\n\t\t{\n\t\t\tlong h = Long.lowestOneBit(set>>>n);\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)+n;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int pos = next(0);pos != -1;pos = next(pos+1)){\n\t\t\t\tlist.add(pos);\n\t\t\t}\n\t\t\treturn list.toString();\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    MyScanner sc    = new MyScanner();\n    Scanner   sc2   = new Scanner(System.in);\n    long      start = System.currentTimeMillis();\n    long      fin   = System.currentTimeMillis();\n    final int MOD   = 1000000007;\n    int[]     dx    = { 1, 0, 0, -1 };\n    int[]     dy    = { 0, 1, -1, 0 };\n\n    int       n, q;\n    Pair      dat[];\n\n    void init() {\n        dat = new Pair[n * 2 - 1];\n        for (int i = 0; i < n * 2 - 1; i++) {\n            dat[i] = new Pair(0, 100);\n        }\n    }\n\n    Pair query(int a, int b, int k, int l, int r) {\n        if (a <= l && r <= b) return dat[k];\n        if (r <= a || b <= l) return new Pair(100000000, 100000000);\n        Pair vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        Pair vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n        return compare(vl, vr);\n    }\n\n    void update(int i, int x, int id) {\n        i += n - 1;\n        dat[i].cnt += x;\n        dat[i].id = id;\n        while (i > 0) {\n            i = (i - 1) / 2;\n            dat[i] = compare(dat[i * 2 + 1], dat[i * 2 + 2]);\n        }\n    }\n\n    Pair compare(Pair a, Pair b) {\n        if (a.cnt < b.cnt) return a;\n        else if (b.cnt < a.cnt) return b;\n        else if (a.id < b.id) return a;\n        else return b;\n    }\n\n    void display() {\n        StringBuilder sb = new StringBuilder();\n        System.out.println(\"-------dump-------\");\n        int h = 0;\n        int index = 0;\n        while (index < dat.length) {\n            for (int i = 0; i < Math.pow(2, h); i++)\n                sb.append(dat[index].cnt + \".\"+dat[index++].id+\" \");\n            sb.append(\"\\n\");\n            h++;\n        }\n        System.out.print(sb);\n    }\n\n    void run() {\n        // nn : 要素数\n        // q : クエリ\n        // n : 用意するノードの数\n        int nn = sc.nextInt();\n        q = sc.nextInt();\n        n = 1;\n        while (n < nn)\n            n *= 2;\n\n        init();\n        for(int i=0;i<nn;i++) update(i, 0, i);\n        //display();\n        while (q-- > 0) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if (b != 1) return;\n            \n            Pair min = query(0, a, 0, 0, n);\n            update(min.id, 1, min.id);\n        }\n        for(int i=0;i<nn;i++) {\n            System.out.println(dat[i+n-1].cnt);\n        }\n    }\n\n    class Pair implements Comparable<Pair> {\n\n        int cnt;\n        int id;\n\n        public Pair() {\n            super();\n            this.cnt = 0;\n            this.id = 0;\n        }\n\n        public Pair(int cnt, int id) {\n            super();\n            this.cnt = cnt;\n            this.id = id;\n        }\n\n        @Override\n        public int compareTo(Pair arg0) {\n            if (this.cnt == arg0.cnt) {\n                return this.id - arg0.id;\n            }\n            return this.cnt - arg0.cnt;\n        }\n\n        void show() {\n            System.out.println(\"cnt = \" + this.cnt + \" id = \" + this.id);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    void debug2(int[][] array) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                System.out.print(array[i][j]);\n            }\n            System.out.println();\n        }\n    }\n\n    boolean inner(int h, int w, int limH, int limW) {\n        return 0 <= h && h < limH && 0 <= w && w < limW;\n    }\n\n    void swap(int[] x, int a, int b) {\n        int tmp = x[a];\n        x[a] = x[b];\n        x[b] = tmp;\n    }\n\n    // find minimum i (k <= a[i])\n    int lower_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k <= a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    // find minimum i (k < a[i])\n    int upper_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k < a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    long gcd(long a, long b) {\n        return a % b == 0 ? b : gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    boolean palindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    class MyScanner {\n        int nextInt() {\n            try {\n                int c = System.in.read();\n                while (c != '-' && (c < '0' || '9' < c))\n                    c = System.in.read();\n                if (c == '-')\n                    return -nextInt();\n                int res = 0;\n                do {\n                    res *= 10;\n                    res += c - '0';\n                    c = System.in.read();\n                } while ('0' <= c && c <= '9');\n                return res;\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String next() {\n            try {\n                StringBuilder res = new StringBuilder(\"\");\n                int c = System.in.read();\n                while (Character.isWhitespace(c))\n                    c = System.in.read();\n                do {\n                    res.append((char) c);\n                } while (!Character.isWhitespace(c = System.in.read()));\n                return res.toString();\n            } catch (Exception e) {\n                return null;\n            }\n        }\n\n        int[] nextIntArray(int n) {\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextInt();\n            }\n            return in;\n        }\n\n        int[][] nextInt2dArray(int n, int m) {\n            int[][] in = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextIntArray(m);\n            }\n            return in;\n        }\n\n        double[] nextDoubleArray(int n) {\n            double[] in = new double[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextDouble();\n            }\n            return in;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] in = new long[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextLong();\n            }\n            return in;\n        }\n\n        char[][] nextCharField(int n, int m) {\n            char[][] in = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                String s = sc.next();\n                for (int j = 0; j < m; j++) {\n                    in[i][j] = s.charAt(j);\n                }\n            }\n            return in;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws Exception{\t\n\t\tFastScanner sc = new FastScanner();\n\t\tint i, j, k;\n\t\t\t//code\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\t\n\t\tint index = 0;\n\t\t\n\t\tint[] N = new int[n];\n\t\tlong[] a = new long[q];\n\t\tlong[] b = new long[q];\n\t\t\n\t\t\n\t\tfor(i=0; i<q; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tfor(i=0; i<q; i++){\n\t\t\tfor(j=0; j<b[i]; j++){\n\t\t\t\tint min = 9999999;\n\t\t\t\tfor(k=(int) (a[i]-1); k>=0; k--){\n\t\t\t\t\tif(min >= N[k]){\n\t\t\t\t\tmin = N[k];\n\t\t\t\t\tindex = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tN[index]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=0; i<n; i++){\n\t\t\tpl(N[i]);\n\t\t}\n\t\t\n\t\t\n\t\n\t\t\n\t\n\t}\n\t\n\t\n\t\n\tstatic void func(){\n\n\t}\n\t\n\tstatic void p(String s){ System.out.print(s); }\n\tstatic void pl(String s){ System.out.println(s); }\n\tstatic void p(int s){ System.out.print(s); }\n\tstatic void pl(int s){ System.out.println(s); }\n\tstatic void p(long s){ System.out.print(s); }\n\tstatic void pl(long s){ System.out.println(s); }\n\tstatic void p(double s){ System.out.print(s); }\n\tstatic void pl(double s){ System.out.println(s); }\n\tstatic void p(boolean s){ System.out.print(s); }\n\tstatic void pl(boolean s){ System.out.println(s); }\n\t\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    \n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    MyScanner sc    = new MyScanner();\n    Scanner   sc2   = new Scanner(System.in);\n    long      start = System.currentTimeMillis();\n    long      fin   = System.currentTimeMillis();\n    final int MOD   = 1000000007;\n    int[]     dx    = { 1, 0, 0, -1 };\n    int[]     dy    = { 0, 1, -1, 0 };\n\n    void run() {\n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        int[] c = new int[n];\n\n        while (q-- > 0) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n\n            int index = 0;\n            int cnt = Integer.MAX_VALUE;\n            for (int i = 0; i < a; i++) {\n                if (c[i] < cnt) {\n                    cnt = c[i];\n                    index = i;\n                }\n            }\n            c[index]++;\n        }\n        for (int i = 0; i < n; i++) {\n            System.out.println(c[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    void debug2(int[][] array) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                System.out.print(array[i][j]);\n            }\n            System.out.println();\n        }\n    }\n\n    boolean inner(int h, int w, int limH, int limW) {\n        return 0 <= h && h < limH && 0 <= w && w < limW;\n    }\n\n    void swap(int[] x, int a, int b) {\n        int tmp = x[a];\n        x[a] = x[b];\n        x[b] = tmp;\n    }\n\n    // find minimum i (k <= a[i])\n    int lower_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k <= a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    // find minimum i (k < a[i])\n    int upper_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k < a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    long gcd(long a, long b) {\n        return a % b == 0 ? b : gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    boolean palindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    class MyScanner {\n        int nextInt() {\n            try {\n                int c = System.in.read();\n                while (c != '-' && (c < '0' || '9' < c))\n                    c = System.in.read();\n                if (c == '-')\n                    return -nextInt();\n                int res = 0;\n                do {\n                    res *= 10;\n                    res += c - '0';\n                    c = System.in.read();\n                } while ('0' <= c && c <= '9');\n                return res;\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String next() {\n            try {\n                StringBuilder res = new StringBuilder(\"\");\n                int c = System.in.read();\n                while (Character.isWhitespace(c))\n                    c = System.in.read();\n                do {\n                    res.append((char) c);\n                } while (!Character.isWhitespace(c = System.in.read()));\n                return res.toString();\n            } catch (Exception e) {\n                return null;\n            }\n        }\n\n        int[] nextIntArray(int n) {\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextInt();\n            }\n            return in;\n        }\n\n        int[][] nextInt2dArray(int n, int m) {\n            int[][] in = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextIntArray(m);\n            }\n            return in;\n        }\n\n        double[] nextDoubleArray(int n) {\n            double[] in = new double[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextDouble();\n            }\n            return in;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] in = new long[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextLong();\n            }\n            return in;\n        }\n\n        char[][] nextCharField(int n, int m) {\n            char[][] in = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                String s = sc.next();\n                for (int j = 0; j < m; j++) {\n                    in[i][j] = s.charAt(j);\n                }\n            }\n            return in;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int N = sc.nextInt();\n    int Q = sc.nextInt();\n    int[] A = new int[N];\n    int[] B = new int[N];\n    for (int i = 0; i < Q; i++) {\n      A[i] = Integer.parseInt(sc.next());\n      B[i] = Integer.parseInt(sc.next());\n    }\n    TreeSet<Range> ranges = new TreeSet<>();\n    ranges.add(new Range(0, 0));\n    ranges.add(new Range(N, -1));\n    for (int i = 0; i < Q; i++) {\n      Range cur = ranges.lower(new Range(A[i], 0));\n      Range next = ranges.higher(cur);\n      if (A[i] != next.start) {\n        next = new Range(A[i], cur.count);\n        ranges.add(next);\n      }\n      while (true) {\n        Range prev = ranges.lower(cur);\n        int len = next.start - cur.start;\n        if (prev == null || (prev.count - cur.count - 1) * len >= B[i]) {\n          cur.count += B[i] / len;\n          if (B[i] % len != 0) {\n            ranges.add(new Range(cur.start + B[i] % len, cur.count));\n            cur.count++;\n          }\n          break;\n        } else if ((prev.count - cur.count) * len >= B[i]) {\n          if (B[i] % len != 0) {\n            cur.start += B[i] % len;\n            cur.count += B[i] / len;\n          } else {\n            ranges.remove(cur);\n          }\n          break;\n        } else {\n          B[i] -= (prev.count - cur.count) * len;\n          ranges.remove(cur);\n          cur = prev;\n        }\n      }\n    }\n    StringBuilder sb = new StringBuilder();\n    ArrayList<Range> rangeList = new ArrayList<>(ranges);\n    for (int i = 0; i < rangeList.size() - 1; i++) {\n      for (int j = 0; j < rangeList.get(i + 1).start - rangeList.get(i).start; j++) {\n        sb.append(rangeList.get(i).count + \"\\n\");\n      }\n    }\n    System.out.print(sb);\n  }\n\n  static class Range implements Comparable<Range> {\n    int start;\n    long count;\n\n    public Range(int start, long count) {\n      this.start = start;\n      this.count = count;\n    }\n\n    @Override\n    public int compareTo(Range o) {\n      return Integer.compare(this.start, o.start);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      Range range = (Range) o;\n      return start == range.start;\n    }\n\n    @Override\n    public int hashCode() {\n      return start;\n    }\n\n    @Override\n    public String toString() {\n      return \"Range{\" +\n          \"start=\" + start +\n          \", count=\" + count +\n          '}';\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws Exception{\t\n\t\tFastScanner sc = new FastScanner();\n\t\tint i, j, k;\n\t\t\t//code\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\t\n\t\tint index = 0;\n\t\t\n\t\tint[] N = new int[n];\n\t\tint[] a = new int[q];\n\t\tlong[] b = new long[q];\n\t\t\n\t\t\n\t\tfor(i=0; i<q; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tfor(i=0; i<q; i++){\n\t\t\tfor(j=0; j<b[i]; j++){\n\t\t\t\tint min = 9999999;\n\t\t\t\tfor(k=a[i]-1; k>=0; k--){\n\t\t\t\t\tif(min >= N[k]){\n\t\t\t\t\tmin = N[k];\n\t\t\t\t\tindex = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tN[index]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=0; i<n; i++){\n\t\t\tpl(N[i]);\n\t\t}\n\t\t\n\t\t\n\t\n\t\t\n\t\n\t}\n\t\n\t\n\t\n\tstatic void func(){\n\n\t}\n\t\n\tstatic void p(String s){ System.out.print(s); }\n\tstatic void pl(String s){ System.out.println(s); }\n\tstatic void p(int s){ System.out.print(s); }\n\tstatic void pl(int s){ System.out.println(s); }\n\tstatic void p(long s){ System.out.print(s); }\n\tstatic void pl(long s){ System.out.println(s); }\n\tstatic void p(double s){ System.out.print(s); }\n\tstatic void pl(double s){ System.out.println(s); }\n\tstatic void p(boolean s){ System.out.print(s); }\n\tstatic void pl(boolean s){ System.out.println(s); }\n\t\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    \n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var q = sc.Integer();\n            var seg = new LazyEvaluateSetSumTree(n);\n            for (int i = 0; i < q; i++)\n            {\n                var k = sc.Integer();\n                var v = sc.Long();\n                var l = -1; var r = k - 1;\n                while (l + 1 < r)\n                {\n                    var m = (l + r) / 2;\n                    var val = seg.Query(m, m + 1);\n                    var len = k - m;\n                    var sum = seg.Query(m, k);\n                    if (len * val - sum <= v) r = m;\n                    else l = m;\n                }\n                {\n                    var val = seg.Query(r, r + 1);\n                    var len = k - r;\n                    var sum = seg.Query(r, k);\n                    seg.Set(r, k, val);\n                    v -= len * val - sum;\n                }\n                {\n                    var len = k - r;\n                    var val = seg.Query(r, r + 1);\n                    val += v / len;\n                    seg.Set(r, k, val);\n                    v %= len;\n                    int nr = (int)(r + v);\n                    if (v > 0)\n                        seg.Set(r, nr, val + 1);\n                }\n                /*\n                var hoge = new List<long>();\n                for (int j = 0; j < n; j++) hoge.Add(seg.Query(j, j + 1));\n                Debug.WriteLine(hoge.AsJoinedString());\n                */\n            }\n            for (int i = 0; i < n; i++)\n                IO.Printer.Out.WriteLine(seg.Query(i, i + 1));\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region LazyEvalSetSum\npublic class LazyEvaluateSetSumTree\n{\n    int n;\n    long[] data;\n    long[] lazy;\n    public LazyEvaluateSetSumTree(int size)\n    {\n        n = 1;\n        while (n < size)\n            n <<= 1;\n        data = new long[n << 1];\n        lazy = new long[n << 1];\n        for (int i = 0; i < lazy.Length; i++)\n            lazy[i] = -1;\n    }\n    private void lazyEval(int k, int a, int b)\n    {\n        if (lazy[k] == -1)\n            return;\n        Update(a, (a + b) >> 1, lazy[k], k << 1, a, (a + b) >> 1);\n        Update((a + b) >> 1, b, lazy[k], (k << 1) + 1, (a + b) >> 1, b);\n        lazy[k] = -1;\n    }\n    private void eval(int k)\n    {\n        int l = k << 1, r = (k << 1) + 1;\n        data[k] = data[l] + data[r];\n    }\n    public void Set(int a, int b, long v)\n    {\n        Update(a, b, v, 1, 0, n);\n    }\n    private void Update(int a, int b, long v, int k, int l, int r)\n    {\n        if (r <= a || b <= l)\n            return;\n        else if (a <= l && r <= b)\n        {\n            lazy[k] = v;\n            data[k] = v * (r - l);\n        }\n        else\n        {\n            lazyEval(k, l, r);\n            Update(a, b, v, k << 1, l, (l + r) >> 1);\n            Update(a, b, v, (k << 1) + 1, (l + r) >> 1, r);\n            eval(k);\n        }\n    }\n    public long Query(int a, int b) { return Query(a, b, 1, 0, n); }\n    private long Query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l)\n            return 0;\n        if (a <= l && r <= b)\n            return data[k];\n        else\n        {\n            lazyEval(k, l, r);\n            var vl = Query(a, b, k << 1, l, (l + r) >> 1);\n            var vr = Query(a, b, (k << 1) + 1, (l + r) >> 1, r);\n            eval(k);\n            return vl + vr;\n        }\n    }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        int Q = int.Parse(str[1]);\n        SegTree Seg = new SegTree(N);\n        for(int i=2*N-2;i>=0;i--){\n            if(i >= Seg.segf){\n                Seg.cn[i] = 1; \n            }\n            else{\n                int sl = i*2+1;\n                int sr = i*2+2;\n                Seg.cn[i] = Seg.cn[sl]+Seg.cn[sr];\n            }\n        }\n        for(int i=0;i<Q;i++){\n            str = Console.ReadLine().Split(' ');\n            int a = int.Parse(str[0])-1;\n            long b = long.Parse(str[1]);\n            int bf = 0;\n            int bl = a;\n            while(bf != bl){\n                int bc = (bf+bl)/2;\n                if(Seg.Sum(bc,a) + b >= Seg.GetValue(bc) * (a - bc + 1)){\n                    bl = bc;\n                }\n                else{\n                    bf = bc+1;\n                }\n            }\n            long nb = Seg.Sum(bf,a) + b;\n            if(nb % (a - bf + 1) == 0){\n                Seg.SetC(bf,a,nb/(a-bf+1)); \n            }\n            else{\n                Seg.SetC(bf,bf+(int)(nb%(a-bf+1))-1,nb/(a-bf+1)+1);\n                Seg.SetC(bf+(int)(nb%(a-bf+1)),a,nb/(a-bf+1)); \n            }\n        }\n        for(int i=0;i<N;i++){\n            sb.Append(Seg.GetValue(i)+\"\\n\");\n        }\n    }\n}\nstruct SegTree{\n    public long[] Mi;\n    public bool[] uncom;\n    public int[] cn;\n    public long[] co;\n    //葉の最初の場所\n    public int segf;\n    //segfのbit\n    public int segfb;\n    //葉の深さの内浅い方\n    public int depth;\n    //浅い葉の内座標が最大のもの\n    public int borderP;\n    //はみ出すものの数\n    public int border;\n    public SegTree(int N){\n        Mi = new long[2*N-1];\n        uncom = new bool[2*N-1];\n        cn = new int[2*N-1];\n        co = new long[2*N-1];\n        for(depth = 1;(1 << depth) <= N;depth++){\n            ;\n        }\n        segf = N-1;\n        borderP = (1 << depth) - 2;\n        border = 2*N - borderP - 2;\n        segfb = border/2;\n    }\n    public int ToBit(int p){\n        if(p >= border){\n            return segfb + p - border;\n        }\n        else{\n            return p;\n        }\n    }\n    //葉のある場所\n    public int ToLeaf(int p){\n        if(p >= border){\n            return segf + p - border;\n        }\n        else{\n            return borderP + p + 1;\n        }\n    }\n    //葉の示す頂点\n    public int ToPoint(int leaf){\n        if(leaf > borderP){\n            return leaf - borderP - 1;\n        }\n        else{\n            return leaf - segf + border;\n        }\n    }\n    long Single(int b,int v,int depth){\n        if(depth == -1){\n            return Mi[v];\n        }\n        else{\n            if((b & (1 << depth)) == 0){\n                return Math.Max(Mi[v],Single(b,v*2+1,depth-1));\n            }\n            else{\n                return Math.Max(Mi[v],Single(b,v*2+2,depth-1));\n            }\n        }\n    }\n    public long GetValue(int p){\n        int b = ToBit(p);\n        int d = p >= border ? depth - 2 : depth - 1;\n        return Single(b,0,d);\n    }\n    //vの子の内bより大きいものに(bは子孫,bはToBitしたもの)\n    void More(int b,int v,int depth,long C){\n        if(v < segf){\n            if(uncom[v]){\n                Mi[v*2+1] = Mi[v];\n                co[v*2+1] = cn[v*2+1] * Mi[v];\n                uncom[v*2+1] = true;\n                Mi[v*2+2] = Mi[v];\n                co[v*2+2] = cn[v*2+2] * Mi[v];\n                uncom[v*2+2] = true;\n                uncom[v] = false;\n            }\n        }\n        if((b & (1 << depth)) == 0){\n            //右の子は全てbより大きい\n            co[v*2+2] = cn[v*2+2] * C;\n            Mi[v*2+2] = C;\n            uncom[v*2+2] = true;\n            if(((b+1) % (1 << depth)) != 0){\n                More(b,v*2+1,depth-1,C);\n            }\n        }\n        else{\n            //左の子は全てb未満\n            More(b,v*2+2,depth-1,C);\n        }\n        if(v < segf){\n            co[v] = co[v*2+1] + co[v*2+2];\n        }\n    }\n    //vの子の内bより小さなものに(bは子孫,bはToBitしたもの)\n    void Less(int b,int v,int depth,long C){\n        if(v < segf){\n            if(uncom[v]){\n                Mi[v*2+1] = Mi[v];\n                co[v*2+1] = cn[v*2+1] * Mi[v];\n                uncom[v*2+1] = true;\n                Mi[v*2+2] = Mi[v];\n                co[v*2+2] = cn[v*2+2] * Mi[v];\n                uncom[v*2+2] = true;\n                uncom[v] = false;\n            }\n        }\n        if((b & (1 << depth)) == 0){\n            //右の子は全てbより大きい\n            Less(b,v*2+1,depth-1,C);\n        }\n        else{\n            //左の子は全てb未満\n            Mi[v*2+1] = C;\n            co[v*2+1] = cn[v*2+1] * C;\n            uncom[v*2+1] = true;\n            if(b % (1 << depth) != 0){\n                Less(b,v*2+2,depth-1,C);\n            }\n        }\n        if(v < segf){\n            co[v] = co[v*2+1] + co[v*2+2];\n        }\n    }\n    void Section(int bl,int br,int v,int dl,int dr,long C){\n        if(v >= segf){\n            //葉\n            Mi[v] = C;\n            co[v] = C;\n        }\n        else{\n            if(uncom[v]){\n                Mi[v*2+1] = Mi[v];\n                co[v*2+1] = cn[v*2+1] * Mi[v];\n                uncom[v*2+1] = true;\n                Mi[v*2+2] = Mi[v];\n                co[v*2+2] = cn[v*2+2] * Mi[v];\n                uncom[v*2+2] = true;\n                uncom[v] = false;\n            }\n            if((bl & (1 << dl)) == 0 && (br & (1 << dr)) == 0){\n                //両方左\n                Section(bl,br,v*2+1,dl-1,dr-1,C);\n            }\n            else if((bl & (1 << dl)) != 0 && (br & (1 << dr)) != 0){\n                //両方右\n                Section(bl,br,v*2+2,dl-1,dr-1,C);\n            }\n            else{\n                //左と右に分かれた\n                if(bl % (1 << dl) == 0){\n                    //左の子は全て区間に\n                    Mi[v*2+1] = C;\n                    co[v*2+1] = cn[v*2+1] * C;\n                    uncom[v*2+1] = true;\n                }\n                else{\n                    More(bl-1,v*2+1,dl-1,C);\n                }\n                if((br + 1) % (1 << dl) == 0){\n                    //右の子は全て区間に\n                    Mi[v*2+2] = C;\n                    co[v*2+2] = cn[v*2+2] * C;\n                    uncom[v*2+2] = true;\n                }\n                else{\n                    Less(br+1,v*2+2,dr-1,C);\n                }\n            }\n            co[v] = co[v*2+1] + co[v*2+2];\n        }\n    }\n    public void SetC(int l0,int r0,long C){\n        int bl = ToBit(l0);\n        int br = ToBit(r0);\n        int dl = l0 >= border ? depth - 2 : depth - 1;\n        int dr = r0 >= border ? depth - 2 : depth - 1;\n        Section(bl,br,0,dl,dr,C);\n    }\n    //vの子の内bより大きいものに(bは子孫,bはToBitしたもの)\n    long More(int b,int v,int depth){\n        if(v < segf){\n            if(uncom[v]){\n                Mi[v*2+1] = Mi[v];\n                co[v*2+1] = cn[v*2+1] * Mi[v];\n                uncom[v*2+1] = true;\n                Mi[v*2+2] = Mi[v];\n                co[v*2+2] = cn[v*2+2] * Mi[v];\n                uncom[v*2+2] = true;\n                uncom[v] = false;\n            }\n        }\n        if((b & (1 << depth)) == 0){\n            //右の子は全てbより大きい\n            if(((b+1) % (1 << depth)) != 0){\n                return co[v*2+2] + More(b,v*2+1,depth-1);\n            }\n            else{\n                return co[v*2+2];\n            }\n        }\n        else{\n            //左の子は全てb未満\n            return More(b,v*2+2,depth-1);\n        }\n    }\n    //vの子の内bより小さなものに(bは子孫,bはToBitしたもの)\n    long Less(int b,int v,int depth){\n        if(v < segf){\n            if(uncom[v]){\n                Mi[v*2+1] = Mi[v];\n                co[v*2+1] = cn[v*2+1] * Mi[v];\n                uncom[v*2+1] = true;\n                Mi[v*2+2] = Mi[v];\n                co[v*2+2] = cn[v*2+2] * Mi[v];\n                uncom[v*2+2] = true;\n                uncom[v] = false;\n            }\n        }\n        if((b & (1 << depth)) == 0){\n            //右の子は全てbより大きい\n            return Less(b,v*2+1,depth-1);\n        }\n        else{\n            //左の子は全てb未満\n            if(b % (1 << depth) != 0){\n                return co[v*2+1] + Less(b,v*2+2,depth-1);\n            }\n            else{\n                return co[v*2+1];\n            }\n        }\n    }\n    long Section(int bl,int br,int v,int dl,int dr){\n        if(v >= segf){\n            //葉\n            return co[v];\n        }\n        else{\n            if(uncom[v]){\n                Mi[v*2+1] = Mi[v];\n                co[v*2+1] = cn[v*2+1] * Mi[v];\n                uncom[v*2+1] = true;\n                Mi[v*2+2] = Mi[v];\n                co[v*2+2] = cn[v*2+2] * Mi[v];\n                uncom[v*2+2] = true;\n                uncom[v] = false;\n            }\n            if((bl & (1 << dl)) == 0 && (br & (1 << dr)) == 0){\n                //両方左\n                return Section(bl,br,v*2+1,dl-1,dr-1);\n            }\n            else if((bl & (1 << dl)) != 0 && (br & (1 << dr)) != 0){\n                //両方右\n                return Section(bl,br,v*2+2,dl-1,dr-1);\n            }\n            else{\n                long ans = 0;\n                //左と右に分かれた\n                if(bl % (1 << dl) != 0){\n                    ans += More(bl-1,v*2+1,dl-1);\n                }\n                else{\n                    ans += co[v*2+1];\n                }\n                if((br + 1) % (1 << dl) != 0){\n                    ans += Less(br+1,v*2+2,dr-1);\n                }\n                else{\n                    ans += co[v*2+2];\n                }\n                return ans;\n            }\n        }\n    }\n    public long Sum(int l0,int r0){\n        int bl = ToBit(l0);\n        int br = ToBit(r0);\n        int dl = l0 >= border ? depth - 2 : depth - 1;\n        int dr = r0 >= border ? depth - 2 : depth - 1;\n        return Section(bl,br,0,dl,dr);\n    }\n}"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Implicit treap\n;;; (treap with implicit key)\n;;;\n\n;; Note:\n;; - An empty treap is NIL.\n\n(declaim (inline op))\n(defun op (a b)\n  \"Is a binary operator comprising a monoid.\"\n  (declare ((unsigned-byte 62) a b))\n  (min a b))\n\n(defconstant +op-identity+ most-positive-fixnum\n  \"identity element w.r.t. OP\")\n\n(declaim (inline updater-op))\n(defun updater-op (a b)\n  \"Is the operator to compute and update LAZY value. A is the current LAZY value\nand B is operand.\"\n  (declare ((unsigned-byte 62) a b))\n  (+ a b))\n\n(defconstant +updater-identity+ 0\n  \"identity element w.r.t. UPDATER-OP\")\n\n(declaim (inline modifier-op))\n(defun modifier-op (acc x size)\n  \"Is the operator to update ACCUMULATOR (and VALUE) based on LAZY value. ACC is\nthe current ACCUMULATOR value and X is the LAZY value. SIZE is the length of the\nspecified interval.\"\n  (declare ((unsigned-byte 62) acc x)\n           (ignorable size))\n  (+ acc x))\n\n(defstruct (itreap (:constructor %make-itreap (value priority &key left right (count 1) (accumulator value) (lazy +updater-identity+)))\n                  (:copier nil)\n                  (:conc-name %itreap-))\n  (value +op-identity+ :type fixnum)\n  (accumulator +op-identity+ :type fixnum)\n  (lazy +updater-identity+ :type fixnum)\n  (priority 0 :type (integer 0 #.most-positive-fixnum))\n  (count 1 :type (integer 0 #.most-positive-fixnum)) ; size of (sub)treap\n  (left nil :type (or null itreap))\n  (right nil :type (or null itreap)))\n\n(declaim (inline itreap-count))\n(defun itreap-count (itreap)\n  \"Returns the number of the elements.\"\n  (declare ((or null itreap) itreap))\n  (if itreap\n      (%itreap-count itreap)\n      0))\n\n(declaim (inline itreap-accumulator))\n(defun itreap-accumulator (itreap)\n  \"Returns the sum (w.r.t. OP) of the whole ITREAP:\nITREAP[0]+ITREAP[1]+...+ITREAP[SIZE-1].\"\n  (declare ((or null itreap) itreap))\n  (if itreap\n      (%itreap-accumulator itreap)\n      +op-identity+))\n\n(declaim (inline update-count))\n(defun update-count (itreap)\n  (declare (itreap itreap))\n  (setf (%itreap-count itreap)\n        (+ 1\n           (itreap-count (%itreap-left itreap))\n           (itreap-count (%itreap-right itreap)))))\n\n(declaim (inline update-accumulator))\n(defun update-accumulator (itreap)\n  (declare (itreap itreap))\n  (setf (%itreap-accumulator itreap)\n        (if (%itreap-left itreap)\n            (if (%itreap-right itreap)\n                (let ((mid (op (%itreap-accumulator (%itreap-left itreap))\n                               (%itreap-value itreap))))\n                  (op mid (%itreap-accumulator (%itreap-right itreap))))\n                (op (%itreap-accumulator (%itreap-left itreap))\n                    (%itreap-value itreap)))\n            (if (%itreap-right itreap)\n                (op (%itreap-value itreap)\n                    (%itreap-accumulator (%itreap-right itreap)))\n                (%itreap-value itreap)))))\n\n(declaim (inline force-up))\n(defun force-up (itreap)\n  \"Propagates up the information from children.\"\n  (declare (itreap itreap))\n  (update-accumulator itreap))\n\n(declaim (inline force-down))\n(defun force-down (itreap)\n  \"Propagates down the information to children.\"\n  (declare (itreap itreap))\n  (unless (eql +updater-identity+ (%itreap-lazy itreap))\n    (when (%itreap-left itreap)\n      (setf (%itreap-lazy (%itreap-left itreap))\n            (updater-op (%itreap-lazy (%itreap-left itreap))\n                        (%itreap-lazy itreap)))\n      (setf (%itreap-accumulator (%itreap-left itreap))\n            (modifier-op (%itreap-accumulator (%itreap-left itreap))\n                         (%itreap-lazy itreap)\n                         (%itreap-count (%itreap-left itreap)))))\n    (when (%itreap-right itreap)\n      (setf (%itreap-lazy (%itreap-right itreap))\n            (updater-op (%itreap-lazy (%itreap-right itreap))\n                        (%itreap-lazy itreap)))\n      (setf (%itreap-accumulator (%itreap-right itreap))\n            (modifier-op (%itreap-accumulator (%itreap-right itreap))\n                         (%itreap-lazy itreap)\n                         (%itreap-count (%itreap-right itreap)))))\n    (setf (%itreap-value itreap)\n          (modifier-op (%itreap-value itreap)\n                       (%itreap-lazy itreap)\n                       1))\n    (setf (%itreap-lazy itreap) +updater-identity+)))\n\n(defun %heapify (top)\n  \"Properly swaps the priorities of the node and its two children.\"\n  (declare (optimize (speed 3) (safety 0)))\n  (when top\n    (let ((high-priority-node top))\n      (when (and (%itreap-left top)\n                 (> (%itreap-priority (%itreap-left top))\n                    (%itreap-priority high-priority-node)))\n        (setq high-priority-node (%itreap-left top)))\n      (when (and (%itreap-right top)\n                 (> (%itreap-priority (%itreap-right top))\n                    (%itreap-priority high-priority-node)))\n        (setq high-priority-node (%itreap-right top)))\n      (unless (eql high-priority-node top)\n        (rotatef (%itreap-priority high-priority-node)\n                 (%itreap-priority top))\n        (%heapify high-priority-node)))))\n\n(defun make-itreap (size &key initial-element)\n  (declare #.OPT)\n  (labels ((build (l r)\n             (declare ((integer 0 #.most-positive-fixnum) l r))\n             (if (= l r)\n                 nil\n                 (let* ((mid (ash (+ l r) -1))\n                        (node (%make-itreap (or initial-element +op-identity+)\n                                            (random most-positive-fixnum))))\n                   (setf (%itreap-left node) (build l mid))\n                   (setf (%itreap-right node) (build (+ mid 1) r))\n                   (%heapify node)\n                   (update-count node)\n                   (update-accumulator node)\n                   node))))\n    (build 0 size)))\n\n(defun itreap-split (itreap index)\n  \"Destructively splits the ITREAP into two nodes [0, INDEX) and [INDEX, N),\nwhere N is the number of the elements in ITREAP.\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) index))\n  (labels ((recur (itreap ikey)\n             (unless itreap\n               (return-from itreap-split (values nil nil)))\n             (force-down itreap)\n             (let ((left-count (itreap-count (%itreap-left itreap))))\n               (if (<= ikey left-count)\n                   (multiple-value-bind (left right)\n                       (itreap-split (%itreap-left itreap) ikey)\n                     (setf (%itreap-left itreap) right)\n                     (force-up itreap)\n                     (values left itreap))\n                   (multiple-value-bind (left right)\n                       (itreap-split (%itreap-right itreap) (- ikey left-count 1))\n                     (setf (%itreap-right itreap) left)\n                     (force-up itreap)\n                     (values itreap right))))))\n    (recur itreap index)))\n\n(defun itreap-merge (left right)\n  \"Destructively concatenates two ITREAPs.\"\n  (declare #.OPT\n           ((or null itreap) left right))\n  (cond ((null left) (when right (force-down right) (force-up right)) right)\n        ((null right) (when left (force-down left) (force-up left)) left)\n        (t (force-down left)\n           (force-down right)\n           (if (> (%itreap-priority left) (%itreap-priority right))\n               (progn\n                 (setf (%itreap-right left)\n                       (itreap-merge (%itreap-right left) right))\n                 (force-up left)\n                 left)\n               (progn\n                 (setf (%itreap-left right)\n                       (itreap-merge left (%itreap-left right)))\n                 (force-up right)\n                 right)))))\n\n(declaim (inline itreap-map))\n(defun itreap-map (function itreap)\n  \"Successively applies FUNCTION to ITREAP[0], ..., ITREAP[SIZE-1].\"\n  (declare (function function))\n  (labels ((recur (node)\n             (when node\n               (force-down node)\n               (recur (%itreap-left node))\n               (funcall function (%itreap-value node))\n               (recur (%itreap-right node))\n               (force-up node))))\n    (recur itreap)))\n\n(defmethod print-object ((object itreap) stream)\n  (print-unreadable-object (object stream :type t)\n    (let ((init t))\n      (itreap-map (lambda (x)\n                    (if init\n                        (setq init nil)\n                        (write-char #\\  stream))\n                   (write x :stream stream))\n                 object))))\n\n(defun itreap-ref (itreap index)\n  \"Returns the element ITREAP[INDEX].\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) index))\n  (labels ((%ref (itreap index)\n             (declare ((integer 0 #.most-positive-fixnum) index))\n             (force-down itreap)\n             (prog1\n                 (let ((left-count (itreap-count (%itreap-left itreap))))\n                   (cond ((< index left-count)\n                          (%ref (%itreap-left itreap) index))\n                         ((> index left-count)\n                          (%ref (%itreap-right itreap) (- index left-count 1)))\n                         (t (%itreap-value itreap))))\n               (force-up itreap))))\n    (%ref itreap index)))\n\n(defun itreap-query (itreap l r)\n  \"Queries the `sum' (w.r.t. OP) of the range ITREAP[L, R).\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) l r))\n  (labels\n      ((recur (itreap l r)\n         (declare ((integer 0 #.most-positive-fixnum) l r))\n         (unless itreap\n           (return-from recur +op-identity+))\n         (force-down itreap)\n         (prog1\n             (if (and (zerop l) (= r (%itreap-count itreap)))\n                 (itreap-accumulator itreap)\n                 (let ((left-count (itreap-count (%itreap-left itreap))))\n                   (if (<= l left-count)\n                       (if (< left-count r)\n                           ;; LEFT-COUNT is in [L, R)\n                           (op (op (recur (%itreap-left itreap) l (min r left-count))\n                                   (%itreap-value itreap))\n                               (recur (%itreap-right itreap) 0 (- r left-count 1)))\n                           ;; LEFT-COUNT is in [R, END)\n                           (recur (%itreap-left itreap) l (min r left-count)))\n                       ;; LEFT-COUNT is in [0, L)\n                       (recur (%itreap-right itreap) (- l left-count 1) (- r left-count 1)))))\n           (force-up itreap))))\n    (recur itreap l r)))\n\n;; FIXME: might be problematic when two priorities collide and START is not\n;; zero. (It will be negligible from the viewpoint of probability, however.)\n(declaim (inline itreap-range-bisect-left))\n(defun itreap-range-bisect-left (itreap value order &optional (start 0))\n  \"Returns the smallest index that satisfies ITREAP[START]+ ITREAP[START+1] +\n... + ITREAP[index] >= VALUE (if ORDER is #'<).\n\nNote:\n- This function handles a **closed** interval.\n- This function returns the length of ITREAP instead if ITREAP[START]+\n... +ITREAP[length-1] < VALUE.\n- The prefix sums of ITREAP, (ITREAP[START], ITREAP[START]+ITREAP[START+1], ...)\n  must be monotone w.r.t. ORDER.\n- ORDER must be a strict order\"\n  (declare ((integer 0 #.most-positive-fixnum) start))\n  (multiple-value-bind (itreap-prefix itreap)\n      (if (zerop start)\n          (values nil itreap)\n          (itreap-split itreap start))\n    (labels\n        ((recur (itreap offset prev-sum)\n           (declare ((integer 0 #.most-positive-fixnum) offset)\n                    #+sbcl (values (integer 0 #.most-positive-fixnum)))\n           (unless itreap\n             (return-from recur offset))\n           (force-down itreap)\n           (let ((sum prev-sum))\n             (prog1\n                 (cond ((not (funcall order\n                                      (setq sum (op sum (itreap-accumulator (%itreap-left itreap))))\n                                      value))\n                        (recur (%itreap-left itreap) offset prev-sum))\n                       ((not (funcall order\n                                      (setq sum (op sum (%itreap-value itreap)))\n                                      value))\n                        (+ offset (itreap-count (%itreap-left itreap))))\n                       (t\n                        (recur (%itreap-right itreap)\n                               (+ offset (itreap-count (%itreap-left itreap)) 1)\n                               sum)))\n               (force-up itreap)))))\n      (prog1 (+ start (recur itreap 0 +op-identity+))\n        (itreap-merge itreap-prefix itreap)))))\n\n(defun itreap-update (itreap operand l r)\n  \"Updates ITREAP[i] := (OP ITREAP[i] OPERAND) for all i in [l, r)\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) l r))\n  (labels\n      ((recur (itreap l r)\n         (declare ((integer 0 #.most-positive-fixnum) l r))\n         (when itreap\n           (if (and (zerop l) (= r (%itreap-count itreap)))\n               (progn\n                 (setf (%itreap-lazy itreap)\n                       (updater-op (%itreap-lazy itreap) operand))\n                 (force-down itreap))\n               (let ((left-count (itreap-count (%itreap-left itreap))))\n                 (force-down itreap)\n                 (if (<= l left-count)\n                     (if (< left-count r)\n                         ;; LEFT-COUNT is in [L, R)\n                         (progn\n                           (recur (%itreap-left itreap) l (min r left-count))\n                           (setf (%itreap-value itreap)\n                                 (modifier-op (%itreap-value itreap) operand 1))\n                           (recur (%itreap-right itreap) 0 (- r left-count 1)))\n                         ;; LEFT-COUNT is in [R, END)\n                         (recur (%itreap-left itreap) l (min r left-count)))\n                     ;; LEFT-COUNT is in [0, L)\n                     (recur (%itreap-right itreap) (- l left-count 1) (- r left-count 1)))))\n           (force-up itreap))))\n    (recur itreap l r)\n    itreap))\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (declare #.OPT)\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setf minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((n (read))\n         (q (read))\n         (dp (make-itreap n :initial-element 0)))\n    (declare (uint31 n q))\n    (dotimes (_ q)\n      (let ((a (read-fixnum))\n            (b (read-fixnum)))\n        (declare (uint31 a) (uint62 b))\n        (loop until (zerop b)\n              for min of-type uint62 = (itreap-query dp 0 a)\n              for argmin of-type uint31 = (itreap-range-bisect-left dp min #'>)\n              when (zerop argmin)\n              do (multiple-value-bind (quot rem) (floor b a)\n                   (itreap-update dp quot 0 a)\n                   (itreap-update dp 1 0 rem)\n                   (setq b 0))\n              else\n              do (let ((min2 (itreap-ref dp (- argmin 1))))\n                   (declare (uint62 min2))\n                   (multiple-value-bind (quot rem) (floor b (- a argmin))\n                     (declare (uint62 quot rem))\n                     (cond ((or (< (+ min quot) min2)\n                                (and (= (+ min quot) min2) (zerop rem)))\n                            (itreap-update dp quot argmin a)\n                            (itreap-update dp 1 argmin (+ argmin rem))\n                            (setq b 0))\n                           ((= (+ min quot) min2)\n                            (itreap-update dp quot argmin a)\n                            (setq b rem))\n                           (t\n                            (assert (> (+ min quot) min2))\n                            (itreap-update dp (- min2 min) argmin a)\n                            (decf b (* (- min2 min) (- a argmin))))))))))\n    (itreap-map #'println dp)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 3\n5 11\n8 4\n4 7\n\"\n    \"4\n4\n4\n4\n2\n2\n1\n1\n0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n3 5\n6 11\n1 6\n4 7\n5 2\n2 5\n\"\n    \"10\n10\n5\n5\n4\n2\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"5 6\n1 1\n2 1\n3 1\n1 1\n5 1\n3 1\n\"\n    \"2\n2\n1\n1\n0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"10 10\n10 10\n9 20\n8 30\n7 40\n6 50\n5 60\n4 70\n3 80\n2 90\n1 100\n\"\n    \"223\n123\n77\n50\n33\n21\n12\n7\n3\n1\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Implicit treap\n;;; (treap with implicit key)\n;;;\n\n;; Note:\n;; - An empty treap is NIL.\n\n(declaim (inline op))\n(defun op (a b)\n  \"Is a binary operator comprising a monoid.\"\n  (declare ((unsigned-byte 62) a b))\n  (min a b))\n\n(defconstant +op-identity+ most-positive-fixnum\n  \"identity element w.r.t. OP\")\n\n(declaim (inline updater-op))\n(defun updater-op (a b)\n  \"Is the operator to compute and update LAZY value. A is the current LAZY value\nand B is operand.\"\n  (declare ((unsigned-byte 62) a b))\n  (+ a b))\n\n(defconstant +updater-identity+ 0\n  \"identity element w.r.t. UPDATER-OP\")\n\n(declaim (inline modifier-op))\n(defun modifier-op (acc x size)\n  \"Is the operator to update ACCUMULATOR (and VALUE) based on LAZY value. ACC is\nthe current ACCUMULATOR value and X is the LAZY value. SIZE is the length of the\nspecified interval.\"\n  (declare ((unsigned-byte 62) acc x)\n           (ignorable size))\n  (+ acc x))\n\n(defstruct (itreap (:constructor %make-itreap (value priority &key left right (count 1) (accumulator value) (lazy +updater-identity+)))\n                  (:copier nil)\n                  (:conc-name %itreap-))\n  (value +op-identity+ :type fixnum)\n  (accumulator +op-identity+ :type fixnum)\n  (lazy +updater-identity+ :type fixnum)\n  (priority 0 :type (integer 0 #.most-positive-fixnum))\n  (count 1 :type (integer 0 #.most-positive-fixnum)) ; size of (sub)treap\n  (left nil :type (or null itreap))\n  (right nil :type (or null itreap)))\n\n(declaim (inline itreap-count))\n(defun itreap-count (itreap)\n  \"Returns the number of the elements.\"\n  (declare ((or null itreap) itreap))\n  (if itreap\n      (%itreap-count itreap)\n      0))\n\n(declaim (inline itreap-accumulator))\n(defun itreap-accumulator (itreap)\n  \"Returns the sum (w.r.t. OP) of the whole ITREAP:\nITREAP[0]+ITREAP[1]+...+ITREAP[SIZE-1].\"\n  (declare ((or null itreap) itreap))\n  (if itreap\n      (%itreap-accumulator itreap)\n      +op-identity+))\n\n(declaim (inline update-count))\n(defun update-count (itreap)\n  (declare (itreap itreap))\n  (setf (%itreap-count itreap)\n        (+ 1\n           (itreap-count (%itreap-left itreap))\n           (itreap-count (%itreap-right itreap)))))\n\n(declaim (inline update-accumulator))\n(defun update-accumulator (itreap)\n  (declare (itreap itreap))\n  (setf (%itreap-accumulator itreap)\n        (if (%itreap-left itreap)\n            (if (%itreap-right itreap)\n                (let ((mid (op (%itreap-accumulator (%itreap-left itreap))\n                               (%itreap-value itreap))))\n                  (op mid (%itreap-accumulator (%itreap-right itreap))))\n                (op (%itreap-accumulator (%itreap-left itreap))\n                    (%itreap-value itreap)))\n            (if (%itreap-right itreap)\n                (op (%itreap-value itreap)\n                    (%itreap-accumulator (%itreap-right itreap)))\n                (%itreap-value itreap)))))\n\n(declaim (inline force-up))\n(defun force-up (itreap)\n  \"Propagates up the information from children.\"\n  (declare (itreap itreap))\n  (update-accumulator itreap))\n\n(declaim (inline force-down))\n(defun force-down (itreap)\n  \"Propagates down the information to children.\"\n  (declare (itreap itreap))\n  (unless (eql +updater-identity+ (%itreap-lazy itreap))\n    (when (%itreap-left itreap)\n      (setf (%itreap-lazy (%itreap-left itreap))\n            (updater-op (%itreap-lazy (%itreap-left itreap))\n                        (%itreap-lazy itreap)))\n      (setf (%itreap-accumulator (%itreap-left itreap))\n            (modifier-op (%itreap-accumulator (%itreap-left itreap))\n                         (%itreap-lazy itreap)\n                         (%itreap-count (%itreap-left itreap)))))\n    (when (%itreap-right itreap)\n      (setf (%itreap-lazy (%itreap-right itreap))\n            (updater-op (%itreap-lazy (%itreap-right itreap))\n                        (%itreap-lazy itreap)))\n      (setf (%itreap-accumulator (%itreap-right itreap))\n            (modifier-op (%itreap-accumulator (%itreap-right itreap))\n                         (%itreap-lazy itreap)\n                         (%itreap-count (%itreap-right itreap)))))\n    (setf (%itreap-value itreap)\n          (modifier-op (%itreap-value itreap)\n                       (%itreap-lazy itreap)\n                       1))\n    (setf (%itreap-lazy itreap) +updater-identity+)))\n\n(defun %heapify (top)\n  \"Properly swaps the priorities of the node and its two children.\"\n  (declare (optimize (speed 3) (safety 0)))\n  (when top\n    (let ((high-priority-node top))\n      (when (and (%itreap-left top)\n                 (> (%itreap-priority (%itreap-left top))\n                    (%itreap-priority high-priority-node)))\n        (setq high-priority-node (%itreap-left top)))\n      (when (and (%itreap-right top)\n                 (> (%itreap-priority (%itreap-right top))\n                    (%itreap-priority high-priority-node)))\n        (setq high-priority-node (%itreap-right top)))\n      (unless (eql high-priority-node top)\n        (rotatef (%itreap-priority high-priority-node)\n                 (%itreap-priority top))\n        (%heapify high-priority-node)))))\n\n(defun make-itreap (size &key initial-element)\n  (declare #.OPT)\n  (labels ((build (l r)\n             (declare ((integer 0 #.most-positive-fixnum) l r))\n             (if (= l r)\n                 nil\n                 (let* ((mid (ash (+ l r) -1))\n                        (node (%make-itreap (or initial-element +op-identity+)\n                                           (random most-positive-fixnum))))\n                   (setf (%itreap-left node) (build l mid))\n                   (setf (%itreap-right node) (build (+ mid 1) r))\n                   (%heapify node)\n                   (update-count node)\n                   (update-accumulator node)\n                   node))))\n    (build 0 size)))\n\n(defun itreap-split (itreap index)\n  \"Destructively splits the ITREAP into two nodes [0, INDEX) and [INDEX, N),\nwhere N is the number of the elements in ITREAP.\"\n  (declare (optimize (speed 3))\n           ((integer 0 #.most-positive-fixnum) index))\n  (labels ((recur (itreap ikey)\n             (unless itreap\n               (return-from itreap-split (values nil nil)))\n             (force-down itreap)\n             (let ((left-count (itreap-count (%itreap-left itreap))))\n               (if (<= ikey left-count)\n                   (multiple-value-bind (left right)\n                       (itreap-split (%itreap-left itreap) ikey)\n                     (setf (%itreap-left itreap) right)\n                     (force-up itreap)\n                     (values left itreap))\n                   (multiple-value-bind (left right)\n                       (itreap-split (%itreap-right itreap) (- ikey left-count 1))\n                     (setf (%itreap-right itreap) left)\n                     (force-up itreap)\n                     (values itreap right))))))\n    (recur itreap index)))\n\n(defun itreap-merge (left right)\n  \"Destructively concatenates two ITREAPs.\"\n  (declare (optimize (speed 3))\n           ((or null itreap) left right))\n  (cond ((null left) (when right (force-down right) (force-up right)) right)\n        ((null right) (when left (force-down left) (force-up left)) left)\n        (t (force-down left)\n           (force-down right)\n           (if (> (%itreap-priority left) (%itreap-priority right))\n               (progn\n                 (setf (%itreap-right left)\n                       (itreap-merge (%itreap-right left) right))\n                 (force-up left)\n                 left)\n               (progn\n                 (setf (%itreap-left right)\n                       (itreap-merge left (%itreap-left right)))\n                 (force-up right)\n                 right)))))\n\n(declaim (inline itreap-map))\n(defun itreap-map (function itreap)\n  \"Successively applies FUNCTION to ITREAP[0], ..., ITREAP[SIZE-1].\"\n  (declare (function function))\n  (labels ((recur (node)\n             (when node\n               (force-down node)\n               (recur (%itreap-left node))\n               (funcall function (%itreap-value node))\n               (recur (%itreap-right node))\n               (force-up node))))\n    (recur itreap)))\n\n(defmethod print-object ((object itreap) stream)\n  (print-unreadable-object (object stream :type t)\n    (let ((init t))\n      (itreap-map (lambda (x)\n                    (if init\n                        (setq init nil)\n                        (write-char #\\  stream))\n                   (write x :stream stream))\n                 object))))\n\n(defmacro do-itreap ((var itreap &optional result) &body body)\n  \"Successively binds ITREAP[0], ..., ITREAP[SIZE-1] to VAR and executes BODY\neach time.\"\n  `(block nil\n     (itreap-map (lambda (,var) ,@body) ,itreap)\n     ,result))\n\n(declaim (inline itreap-ref))\n(defun itreap-ref (itreap index)\n  \"Returns the element ITREAP[INDEX].\"\n  (declare ((integer 0 #.most-positive-fixnum) index))\n  (labels ((%ref (itreap index)\n             (declare ((integer 0 #.most-positive-fixnum) index))\n             (force-down itreap)\n             (prog1\n                 (let ((left-count (itreap-count (%itreap-left itreap))))\n                   (cond ((< index left-count)\n                          (%ref (%itreap-left itreap) index))\n                         ((> index left-count)\n                          (%ref (%itreap-right itreap) (- index left-count 1)))\n                         (t (%itreap-value itreap))))\n               (force-up itreap))))\n    (%ref itreap index)))\n\n(defun itreap-query (itreap l r)\n  \"Queries the `sum' (w.r.t. OP) of the range ITREAP[L, R).\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) l r))\n  (labels\n      ((recur (itreap l r)\n         (declare ((integer 0 #.most-positive-fixnum) l r))\n         (unless itreap\n           (return-from recur +op-identity+))\n         (force-down itreap)\n         (prog1\n             (if (and (zerop l) (= r (%itreap-count itreap)))\n                 (itreap-accumulator itreap)\n                 (let ((left-count (itreap-count (%itreap-left itreap))))\n                   (if (<= l left-count)\n                       (if (< left-count r)\n                           ;; LEFT-COUNT is in [L, R)\n                           (op (op (recur (%itreap-left itreap) l (min r left-count))\n                                   (%itreap-value itreap))\n                               (recur (%itreap-right itreap) 0 (- r left-count 1)))\n                           ;; LEFT-COUNT is in [R, END)\n                           (recur (%itreap-left itreap) l (min r left-count)))\n                       ;; LEFT-COUNT is in [0, L)\n                       (recur (%itreap-right itreap) (- l left-count 1) (- r left-count 1)))))\n           (force-up itreap))))\n    (recur itreap l r)))\n\n;; FIXME: might be problematic when two priorities collide and START is not\n;; zero. (It will be negligible from the viewpoint of probability, however.)\n(declaim (inline itreap-range-bisect-left))\n(defun itreap-range-bisect-left (itreap value order &optional (start 0))\n  \"Returns the smallest index that satisfies ITREAP[START]+ ITREAP[START+1] +\n... + ITREAP[index] >= VALUE (if ORDER is #'<).\n\nNote:\n- This function handles a **closed** interval.\n- This function returns the length of ITREAP instead if ITREAP[START]+\n... +ITREAP[length-1] < VALUE.\n- The prefix sums of ITREAP, (ITREAP[START], ITREAP[START]+ITREAP[START+1], ...)\n  must be monotone w.r.t. ORDER.\n- ORDER must be a strict order\"\n  (declare ((integer 0 #.most-positive-fixnum) start))\n  (multiple-value-bind (itreap-prefix itreap)\n      (if (zerop start)\n          (values nil itreap)\n          (itreap-split itreap start))\n    (labels\n        ((recur (itreap offset prev-sum)\n           (declare ((integer 0 #.most-positive-fixnum) offset)\n                    #+sbcl (values (integer 0 #.most-positive-fixnum)))\n           (unless itreap\n             (return-from recur offset))\n           (force-down itreap)\n           (let ((sum prev-sum))\n             (prog1\n                 (cond ((not (funcall order\n                                      (setq sum (op sum (itreap-accumulator (%itreap-left itreap))))\n                                      value))\n                        (recur (%itreap-left itreap) offset prev-sum))\n                       ((not (funcall order\n                                      (setq sum (op sum (%itreap-value itreap)))\n                                      value))\n                        (+ offset (itreap-count (%itreap-left itreap))))\n                       (t\n                        (recur (%itreap-right itreap)\n                               (+ offset (itreap-count (%itreap-left itreap)) 1)\n                               sum)))\n               (force-up itreap)))))\n      (prog1 (+ start (recur itreap 0 +op-identity+))\n        (itreap-merge itreap-prefix itreap)))))\n\n(defun itreap-update (itreap operand l r)\n  \"Updates ITREAP[i] := (OP ITREAP[i] OPERAND) for all i in [l, r)\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) l r))\n  (labels\n      ((recur (itreap l r)\n         (declare ((integer 0 #.most-positive-fixnum) l r))\n         (when itreap\n           (if (and (zerop l) (= r (%itreap-count itreap)))\n               (progn\n                 (setf (%itreap-lazy itreap)\n                       (updater-op (%itreap-lazy itreap) operand))\n                 (force-down itreap))\n               (let ((left-count (itreap-count (%itreap-left itreap))))\n                 (force-down itreap)\n                 (if (<= l left-count)\n                     (if (< left-count r)\n                         ;; LEFT-COUNT is in [L, R)\n                         (progn\n                           (recur (%itreap-left itreap) l (min r left-count))\n                           (setf (%itreap-value itreap)\n                                 (modifier-op (%itreap-value itreap) operand 1))\n                           (recur (%itreap-right itreap) 0 (- r left-count 1)))\n                         ;; LEFT-COUNT is in [R, END)\n                         (recur (%itreap-left itreap) l (min r left-count)))\n                     ;; LEFT-COUNT is in [0, L)\n                     (recur (%itreap-right itreap) (- l left-count 1) (- r left-count 1)))))\n           (force-up itreap))))\n    (recur itreap l r)\n    itreap))\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (declare #.OPT)\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setf minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((n (read))\n         (q (read))\n         (dp (make-itreap n :initial-element 0)))\n    (dotimes (_ q)\n      (let ((a (read-fixnum))\n            (b (read-fixnum)))\n        (declare (uint62 a b))\n        (loop until (zerop b)\n              for min of-type uint62 = (itreap-query dp 0 a)\n              for argmin of-type uint62 = (itreap-range-bisect-left dp min #'>)\n              when (zerop argmin)\n              do (multiple-value-bind (quot rem) (floor b a)\n                   (itreap-update dp quot 0 a)\n                   (itreap-update dp 1 0 rem)\n                   (setq b 0))\n              else\n              do (let ((min2 (itreap-ref dp (- argmin 1))))\n                   (declare (uint62 min2))\n                   (multiple-value-bind (quot rem) (floor b (- a argmin))\n                     (declare (uint62 quot rem))\n                     (cond ((or (< (+ min quot) min2)\n                                (and (= (+ min quot) min2) (zerop rem)))\n                            (itreap-update dp quot argmin a)\n                            (itreap-update dp 1 argmin (+ argmin rem))\n                            (setq b 0))\n                           ((= (+ min quot) min2)\n                            (itreap-update dp quot argmin a)\n                            (setq b rem))\n                           (t\n                            (assert (> (+ min quot) min2))\n                            (itreap-update dp (- min2 min) argmin a)\n                            (decf b (* (- min2 min) (- a argmin))))))))))\n    (itreap-map #'println dp)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 3\n5 11\n8 4\n4 7\n\"\n    \"4\n4\n4\n4\n2\n2\n1\n1\n0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n3 5\n6 11\n1 6\n4 7\n5 2\n2 5\n\"\n    \"10\n10\n5\n5\n4\n2\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"5 6\n1 1\n2 1\n3 1\n1 1\n5 1\n3 1\n\"\n    \"2\n2\n1\n1\n0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"10 10\n10 10\n9 20\n8 30\n7 40\n6 50\n5 60\n4 70\n3 80\n2 90\n1 100\n\"\n    \"223\n123\n77\n50\n33\n21\n12\n7\n3\n1\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Implicit treap\n;;; (treap with implicit key)\n;;;\n\n;; Note:\n;; - An empty treap is NIL.\n\n(declaim (inline op))\n(defun op (a b)\n  \"Is a binary operator comprising a monoid.\"\n  (declare ((unsigned-byte 62) a b))\n  (min a b))\n\n(defconstant +op-identity+ most-positive-fixnum\n  \"identity element w.r.t. OP\")\n\n(declaim (inline updater-op))\n(defun updater-op (a b)\n  \"Is the operator to compute and update LAZY value. A is the current LAZY value\nand B is operand.\"\n  (declare ((unsigned-byte 62) a b))\n  (+ a b))\n\n(defconstant +updater-identity+ 0\n  \"identity element w.r.t. UPDATER-OP\")\n\n(declaim (inline modifier-op))\n(defun modifier-op (acc x size)\n  \"Is the operator to update ACCUMULATOR (and VALUE) based on LAZY value. ACC is\nthe current ACCUMULATOR value and X is the LAZY value. SIZE is the length of the\nspecified interval.\"\n  (declare ((unsigned-byte 62) acc x)\n           (ignorable size))\n  (+ acc x))\n\n(defstruct (itreap (:constructor %make-itreap (value priority &key left right (count 1) (accumulator value) (lazy +updater-identity+)))\n                  (:copier nil)\n                  (:conc-name %itreap-))\n  (value +op-identity+ :type fixnum)\n  (accumulator +op-identity+ :type fixnum)\n  (lazy +updater-identity+ :type fixnum)\n  (priority 0 :type (integer 0 #.most-positive-fixnum))\n  (count 1 :type (integer 0 #.most-positive-fixnum)) ; size of (sub)treap\n  (left nil :type (or null itreap))\n  (right nil :type (or null itreap)))\n\n(declaim (inline itreap-count))\n(defun itreap-count (itreap)\n  \"Returns the number of the elements.\"\n  (declare ((or null itreap) itreap))\n  (if itreap\n      (%itreap-count itreap)\n      0))\n\n(declaim (inline itreap-accumulator))\n(defun itreap-accumulator (itreap)\n  \"Returns the sum (w.r.t. OP) of the whole ITREAP:\nITREAP[0]+ITREAP[1]+...+ITREAP[SIZE-1].\"\n  (declare ((or null itreap) itreap))\n  (if itreap\n      (%itreap-accumulator itreap)\n      +op-identity+))\n\n(declaim (inline update-count))\n(defun update-count (itreap)\n  (declare (itreap itreap))\n  (setf (%itreap-count itreap)\n        (+ 1\n           (itreap-count (%itreap-left itreap))\n           (itreap-count (%itreap-right itreap)))))\n\n(declaim (inline update-accumulator))\n(defun update-accumulator (itreap)\n  (declare (itreap itreap))\n  (setf (%itreap-accumulator itreap)\n        (if (%itreap-left itreap)\n            (if (%itreap-right itreap)\n                (let ((mid (op (%itreap-accumulator (%itreap-left itreap))\n                               (%itreap-value itreap))))\n                  (op mid (%itreap-accumulator (%itreap-right itreap))))\n                (op (%itreap-accumulator (%itreap-left itreap))\n                    (%itreap-value itreap)))\n            (if (%itreap-right itreap)\n                (op (%itreap-value itreap)\n                    (%itreap-accumulator (%itreap-right itreap)))\n                (%itreap-value itreap)))))\n\n(declaim (inline force-up))\n(defun force-up (itreap)\n  \"Propagates up the information from children.\"\n  (declare (itreap itreap))\n  (update-count itreap)\n  (update-accumulator itreap))\n\n(declaim (inline force-down))\n(defun force-down (itreap)\n  \"Propagates down the information to children.\"\n  (declare (itreap itreap))\n  (unless (eql +updater-identity+ (%itreap-lazy itreap))\n    (when (%itreap-left itreap)\n      (setf (%itreap-lazy (%itreap-left itreap))\n            (updater-op (%itreap-lazy (%itreap-left itreap))\n                        (%itreap-lazy itreap)))\n      (setf (%itreap-accumulator (%itreap-left itreap))\n            (modifier-op (%itreap-accumulator (%itreap-left itreap))\n                         (%itreap-lazy itreap)\n                         (%itreap-count (%itreap-left itreap)))))\n    (when (%itreap-right itreap)\n      (setf (%itreap-lazy (%itreap-right itreap))\n            (updater-op (%itreap-lazy (%itreap-right itreap))\n                        (%itreap-lazy itreap)))\n      (setf (%itreap-accumulator (%itreap-right itreap))\n            (modifier-op (%itreap-accumulator (%itreap-right itreap))\n                         (%itreap-lazy itreap)\n                         (%itreap-count (%itreap-right itreap)))))\n    (setf (%itreap-value itreap)\n          (modifier-op (%itreap-value itreap)\n                       (%itreap-lazy itreap)\n                       1))\n    (setf (%itreap-lazy itreap) +updater-identity+)))\n\n(defun %heapify (top)\n  \"Properly swaps the priorities of the node and its two children.\"\n  (declare (optimize (speed 3) (safety 0)))\n  (when top\n    (let ((high-priority-node top))\n      (when (and (%itreap-left top)\n                 (> (%itreap-priority (%itreap-left top))\n                    (%itreap-priority high-priority-node)))\n        (setq high-priority-node (%itreap-left top)))\n      (when (and (%itreap-right top)\n                 (> (%itreap-priority (%itreap-right top))\n                    (%itreap-priority high-priority-node)))\n        (setq high-priority-node (%itreap-right top)))\n      (unless (eql high-priority-node top)\n        (rotatef (%itreap-priority high-priority-node)\n                 (%itreap-priority top))\n        (%heapify high-priority-node)))))\n\n(declaim (inline make-itreap))\n(defun make-itreap (size &key initial-element)\n  (labels ((build (l r)\n             (declare ((integer 0 #.most-positive-fixnum) l r))\n             (if (= l r)\n                 nil\n                 (let* ((mid (ash (+ l r) -1))\n                        (node (%make-itreap (or initial-element +op-identity+)\n                                           (random most-positive-fixnum))))\n                   (setf (%itreap-left node) (build l mid))\n                   (setf (%itreap-right node) (build (+ mid 1) r))\n                   (%heapify node)\n                   (force-up node)\n                   node))))\n    (build 0 size)))\n\n(define-condition invalid-itreap-index-error (type-error)\n  ((itreap :initarg :itreap :reader invalid-itreap-index-error-itreap)\n   (index :initarg :index :reader invalid-itreap-index-error-index))\n  (:report\n   (lambda (condition stream)\n     (let ((index (invalid-itreap-index-error-index condition)))\n       (if (consp index)\n           (format stream \"Invalid range [~W, ~W) for itreap ~W.\"\n                   (car index)\n                   (cdr index)\n                   (invalid-itreap-index-error-itreap condition))\n           (format stream \"Invalid index ~W for itreap ~W.\"\n                   index\n                   (invalid-itreap-index-error-itreap condition)))))))\n\n(defun itreap-split (itreap index)\n  \"Destructively splits the ITREAP into two nodes [0, INDEX) and [INDEX, N),\nwhere N is the number of the elements in ITREAP.\"\n  (declare (optimize (speed 3))\n           ((integer 0 #.most-positive-fixnum) index))\n  (unless (<= index (itreap-count itreap))\n    (error 'invalid-itreap-index-error :index index :itreap itreap))\n  (labels ((recur (itreap ikey)\n             (unless itreap\n               (return-from itreap-split (values nil nil)))\n             (force-down itreap)\n             (let ((left-count (itreap-count (%itreap-left itreap))))\n               (if (<= ikey left-count)\n                   (multiple-value-bind (left right)\n                       (itreap-split (%itreap-left itreap) ikey)\n                     (setf (%itreap-left itreap) right)\n                     (force-up itreap)\n                     (values left itreap))\n                   (multiple-value-bind (left right)\n                       (itreap-split (%itreap-right itreap) (- ikey left-count 1))\n                     (setf (%itreap-right itreap) left)\n                     (force-up itreap)\n                     (values itreap right))))))\n    (recur itreap index)))\n\n(defun itreap-merge (left right)\n  \"Destructively concatenates two ITREAPs.\"\n  (declare (optimize (speed 3))\n           ((or null itreap) left right))\n  (cond ((null left) (when right (force-down right) (force-up right)) right)\n        ((null right) (when left (force-down left) (force-up left)) left)\n        (t (force-down left)\n           (force-down right)\n           (if (> (%itreap-priority left) (%itreap-priority right))\n               (progn\n                 (setf (%itreap-right left)\n                       (itreap-merge (%itreap-right left) right))\n                 (force-up left)\n                 left)\n               (progn\n                 (setf (%itreap-left right)\n                       (itreap-merge left (%itreap-left right)))\n                 (force-up right)\n                 right)))))\n\n(declaim (inline itreap-map))\n(defun itreap-map (function itreap)\n  \"Successively applies FUNCTION to ITREAP[0], ..., ITREAP[SIZE-1].\"\n  (declare (function function))\n  (labels ((recur (node)\n             (when node\n               (force-down node)\n               (recur (%itreap-left node))\n               (funcall function (%itreap-value node))\n               (recur (%itreap-right node))\n               (force-up node))))\n    (recur itreap)))\n\n(defmethod print-object ((object itreap) stream)\n  (print-unreadable-object (object stream :type t)\n    (let ((init t))\n      (itreap-map (lambda (x)\n                    (if init\n                        (setq init nil)\n                        (write-char #\\  stream))\n                   (write x :stream stream))\n                 object))))\n\n(defmacro do-itreap ((var itreap &optional result) &body body)\n  \"Successively binds ITREAP[0], ..., ITREAP[SIZE-1] to VAR and executes BODY\neach time.\"\n  `(block nil\n     (itreap-map (lambda (,var) ,@body) ,itreap)\n     ,result))\n\n(declaim (inline itreap-ref))\n(defun itreap-ref (itreap index)\n  \"Returns the element ITREAP[INDEX].\"\n  (declare ((integer 0 #.most-positive-fixnum) index))\n  (unless (< index (itreap-count itreap))\n    (error 'invalid-itreap-index-error :itreap itreap :index index))\n  (labels ((%ref (itreap index)\n             (declare ((integer 0 #.most-positive-fixnum) index))\n             (force-down itreap)\n             (prog1\n                 (let ((left-count (itreap-count (%itreap-left itreap))))\n                   (cond ((< index left-count)\n                          (%ref (%itreap-left itreap) index))\n                         ((> index left-count)\n                          (%ref (%itreap-right itreap) (- index left-count 1)))\n                         (t (%itreap-value itreap))))\n               (force-up itreap))))\n    (%ref itreap index)))\n\n(declaim (inline (setf itreap-ref)))\n(defun (setf itreap-ref) (new-value itreap index)\n  \"Sets ITREAP[INDEX] to the given value.\"\n  (declare ((integer 0 #.most-positive-fixnum) index))\n  (unless (< index (itreap-count itreap))\n    (error 'invalid-itreap-index-error :itreap itreap :index index))\n  (labels ((%set (itreap index)\n             (declare ((integer 0 #.most-positive-fixnum) index))\n             (force-down itreap)\n             (prog1\n                 (let ((left-count (itreap-count (%itreap-left itreap))))\n                   (cond ((< index left-count)\n                          (%set (%itreap-left itreap) index))\n                         ((> index left-count)\n                          (%set (%itreap-right itreap) (- index left-count 1)))\n                         (t (setf (%itreap-value itreap) new-value))))\n               (force-up itreap))))\n    (%set itreap index)\n    new-value))\n\n(declaim (inline itreap-query))\n(defun itreap-query (itreap l r)\n  \"Queries the `sum' (w.r.t. OP) of the range ITREAP[L, R).\"\n  (declare ((integer 0 #.most-positive-fixnum) l r))\n  (unless (<= l r (itreap-count itreap))\n    (error 'invalid-itreap-index-error :itreap itreap :index (cons l r)))\n  (labels\n      ((recur (itreap l r)\n         (declare ((integer 0 #.most-positive-fixnum) l r))\n         (unless itreap\n           (return-from recur +op-identity+))\n         (force-down itreap)\n         (prog1\n             (if (and (zerop l) (= r (%itreap-count itreap)))\n                 (itreap-accumulator itreap)\n                 (let ((left-count (itreap-count (%itreap-left itreap))))\n                   (if (<= l left-count)\n                       (if (< left-count r)\n                           ;; LEFT-COUNT is in [L, R)\n                           (op (op (recur (%itreap-left itreap) l (min r left-count))\n                                   (%itreap-value itreap))\n                               (recur (%itreap-right itreap) 0 (- r left-count 1)))\n                           ;; LEFT-COUNT is in [R, END)\n                           (recur (%itreap-left itreap) l (min r left-count)))\n                       ;; LEFT-COUNT is in [0, L)\n                       (recur (%itreap-right itreap) (- l left-count 1) (- r left-count 1)))))\n           (force-up itreap))))\n    (recur itreap l r)))\n\n;; FIXME: might be problematic when two priorities collide and START is not\n;; zero. (It will be negligible from the viewpoint of probability, however.)\n(declaim (inline itreap-range-bisect-left))\n(defun itreap-range-bisect-left (itreap value order &optional (start 0))\n  \"Returns the smallest index that satisfies ITREAP[START]+ ITREAP[START+1] +\n... + ITREAP[index] >= VALUE (if ORDER is #'<).\n\nNote:\n- This function handles a **closed** interval.\n- This function returns the length of ITREAP instead if ITREAP[START]+\n... +ITREAP[length-1] < VALUE.\n- The prefix sums of ITREAP, (ITREAP[START], ITREAP[START]+ITREAP[START+1], ...)\n  must be monotone w.r.t. ORDER.\n- ORDER must be a strict order\"\n  (declare ((integer 0 #.most-positive-fixnum) start))\n  (multiple-value-bind (itreap-prefix itreap)\n      (if (zerop start)\n          (values nil itreap)\n          (itreap-split itreap start))\n    (labels\n        ((recur (itreap offset prev-sum)\n           (declare ((integer 0 #.most-positive-fixnum) offset)\n                    #+sbcl (values (integer 0 #.most-positive-fixnum)))\n           (unless itreap\n             (return-from recur offset))\n           (force-down itreap)\n           (let ((sum prev-sum))\n             (prog1\n                 (cond ((not (funcall order\n                                      (setq sum (op sum (itreap-accumulator (%itreap-left itreap))))\n                                      value))\n                        (recur (%itreap-left itreap) offset prev-sum))\n                       ((not (funcall order\n                                      (setq sum (op sum (%itreap-value itreap)))\n                                      value))\n                        (+ offset (itreap-count (%itreap-left itreap))))\n                       (t\n                        (recur (%itreap-right itreap)\n                               (+ offset (itreap-count (%itreap-left itreap)) 1)\n                               sum)))\n               (force-up itreap)))))\n      (prog1 (+ start (recur itreap 0 +op-identity+))\n        (itreap-merge itreap-prefix itreap)))))\n\n;; merge/split version of itreap-query (a bit slower but simpler)\n;; FIXME: might be problematic when two priorities collide.\n#|\n(declaim (inline itreap-query))\n(defun itreap-query (itreap l r)\n  \"Queries the `sum' (w.r.t. OP) of the interval [L, R).\"\n  (declare ((integer 0 #.most-positive-fixnum) l r))\n  (unless (<= l r (itreap-count itreap))\n    (error 'invalid-itreap-index-error :itreap itreap :index (cons l r)))\n  (if (= l r)\n      +op-identity+\n      (multiple-value-bind (itreap-0-l itreap-l-n)\n          (itreap-split itreap l)\n        (multiple-value-bind (itreap-l-r itreap-r-n)\n            (itreap-split itreap-l-n (- r l))\n          (prog1 (%itreap-accumulator itreap-l-r)\n            (itreap-merge itreap-0-l (itreap-merge itreap-l-r itreap-r-n)))))))\n;|#\n\n(defun itreap-update (itreap operand l r)\n  \"Updates ITREAP[i] := (OP ITREAP[i] OPERAND) for all i in [l, r)\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) l r))\n  (unless (<= l r (itreap-count itreap))\n    (error 'invalid-itreap-index-error :itreap itreap :index (cons l r)))\n  (labels\n      ((recur (itreap l r)\n         (declare ((integer 0 #.most-positive-fixnum) l r))\n         (when itreap\n           (if (and (zerop l) (= r (%itreap-count itreap)))\n               (progn\n                 (setf (%itreap-lazy itreap)\n                       (updater-op (%itreap-lazy itreap) operand))\n                 (force-down itreap))\n               (let ((left-count (itreap-count (%itreap-left itreap))))\n                 (force-down itreap)\n                 (if (<= l left-count)\n                     (if (< left-count r)\n                         ;; LEFT-COUNT is in [L, R)\n                         (progn\n                           (recur (%itreap-left itreap) l (min r left-count))\n                           (setf (%itreap-value itreap)\n                                 (modifier-op (%itreap-value itreap) operand 1))\n                           (recur (%itreap-right itreap) 0 (- r left-count 1)))\n                         ;; LEFT-COUNT is in [R, END)\n                         (recur (%itreap-left itreap) l (min r left-count)))\n                     ;; LEFT-COUNT is in [0, L)\n                     (recur (%itreap-right itreap) (- l left-count 1) (- r left-count 1)))))\n           (force-up itreap))))\n    (recur itreap l r)\n    itreap))\n\n;; merge/split version of itreap-update (a bit slower but simpler)\n#|\n(declaim (inline itreap-update))\n(defun itreap-update (itreap operand l r)\n  \"Updates ITREAP[i] := (OP ITREAP[i] OPERAND) for all i in [l, r)\"\n  (declare ((integer 0 #.most-positive-fixnum) l r))\n  (unless (<= l r (itreap-count itreap))\n    (error 'invalid-itreap-index-error :itreap itreap :index (cons l r)))\n  (multiple-value-bind (itreap-0-l itreap-l-n)\n      (itreap-split itreap l)\n    (multiple-value-bind (itreap-l-r itreap-r-n)\n        (itreap-split itreap-l-n (- r l))\n      (when itreap-l-r\n        (setf (%itreap-lazy itreap-l-r)\n              (updater-op (%itreap-lazy itreap-l-r) operand)))\n      (itreap-merge itreap-0-l (itreap-merge itreap-l-r itreap-r-n)))))\n;|#\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setf minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((n (read))\n         (q (read))\n         (dp (make-itreap n :initial-element 0)))\n    (dotimes (_ q)\n      (let ((a (read-fixnum))\n            (b (read-fixnum)))\n        (declare (uint62 a b))\n        (loop until (zerop b)\n              for min of-type uint62 = (itreap-query dp 0 a)\n              for argmin of-type uint62 = (itreap-range-bisect-left dp min #'>)\n              when (zerop argmin)\n              do (multiple-value-bind (quot rem) (floor b a)\n                   (itreap-update dp quot 0 a)\n                   (itreap-update dp 1 0 rem)\n                   (setq b 0))\n              else\n              do (let ((min2 (itreap-ref dp (- argmin 1))))\n                   (declare (uint62 min2))\n                   (multiple-value-bind (quot rem) (floor b (- a argmin))\n                     (declare (uint62 quot rem))\n                     (cond ((or (< (+ min quot) min2)\n                                (and (= (+ min quot) min2) (zerop rem)))\n                            (itreap-update dp quot argmin a)\n                            (itreap-update dp 1 argmin (+ argmin rem))\n                            (setq b 0))\n                           ((= (+ min quot) min2)\n                            (itreap-update dp quot argmin a)\n                            (setq b rem))\n                           (t\n                            (assert (> (+ min quot) min2))\n                            (itreap-update dp (- min2 min) argmin a)\n                            (decf b (* (- min2 min) (- a argmin))))))))))\n    (itreap-map #'println dp)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"9 3\n5 11\n8 4\n4 7\n\"\n    \"4\n4\n4\n4\n2\n2\n1\n1\n0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n3 5\n6 11\n1 6\n4 7\n5 2\n2 5\n\"\n    \"10\n10\n5\n5\n4\n2\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"5 6\n1 1\n2 1\n3 1\n1 1\n5 1\n3 1\n\"\n    \"2\n2\n1\n1\n0\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"10 10\n10 10\n9 20\n8 30\n7 40\n6 50\n5 60\n4 70\n3 80\n2 90\n1 100\n\"\n    \"223\n123\n77\n50\n33\n21\n12\n7\n3\n1\n\")))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit\ni8 = numba.int64\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n@njit((i8[:], ), cache=True)\ndef build(raw_data):\n    bit = raw_data.copy()\n    for i in range(len(bit)):\n        j = i + (i & (-i))\n        if j < len(bit):\n            bit[j] += bit[i]\n    return bit\n\n\n@njit((i8[:], i8), cache=True)\ndef get_sum(bit, i):\n    s = 0\n    while i:\n        s += bit[i]\n        i -= i & -i\n    return s\n\n\n@njit((i8[:], i8, i8), cache=True)\ndef add(bit, i, x):\n    while i < len(bit):\n        bit[i] += x\n        i += i & -i\n\n\n@njit((i8[:], i8), cache=True)\ndef find_kth_element(bit, k):\n    N = len(bit)\n    x, sx = 0, 0\n    dx = 1\n    while 2 * dx < N:\n        dx *= 2\n    while dx:\n        y = x + dx\n        if y < N:\n            sy = sx + bit[y]\n            if sy < k:\n                x, sx = y, sy\n        dx //= 2\n    return x + 1\n\n@njit((i8, i8[:]), cache=True)\ndef main(N, AB):\n    A, B = AB[::2], AB[1::2]\n    Q = len(A)\n\n    bit = np.zeros(N + 1, np.int64)  # 長方形の右上になる x 座標集合を管理\n    bit_raw = np.zeros(N + 1, np.int64)\n    H = np.zeros(N + 1, np.int64)  # 長方形の高さを管理\n    H[0] = 10**13 + 10\n    bit_raw[N] = 1\n    add(bit, N, 1)\n\n    for i in range(Q):\n        a, b = A[i], B[i]\n        n = get_sum(bit, a - 1)\n        h = H[find_kth_element(bit, 1 + n)]\n        if not bit_raw[a]:\n            bit_raw[a] = 1\n            add(bit, a, 1)\n            H[a] = h\n        r = a\n\n        while b:\n            l = 0 if n == 0 else find_kth_element(bit, n)\n            n -= 1\n            area = (H[l] - H[r]) * (r - l)\n            if area <= b:\n                b -= area\n                if l:\n                    bit_raw[l] = 0\n                    add(bit, l, -1)\n                H[l], H[r] = 0, H[l]\n                continue\n            k = b // (r - l)\n            b -= k * (r - l)\n            H[r] += k\n            if b:\n                m = l + b\n                bit_raw[m] = 1\n                add(bit, m, 1)\n                H[m] = H[r] + 1\n                b = 0\n    for n in range(N, 0, -1):\n        H[n - 1] = max(H[n - 1], H[n])\n    return H[1:N + 1]\n\nN, Q = map(int, readline().split())\nAB = np.array(read().split(), np.int64)\n\nans = main(N, AB)\nprint('\\n'.join(map(str, ans.tolist())))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit\ni8 = numba.int64\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n@njit((i8[:], ), cache=True)\ndef build(raw_data):\n    bit = raw_data.copy()\n    for i in range(len(bit)):\n        j = i + (i & (-i))\n        if j < len(bit):\n            bit[j] += bit[i]\n    return bit\n\n\n@njit((i8[:], i8), cache=True)\ndef get_sum(bit, i):\n    s = 0\n    while i:\n        s += bit[i]\n        i -= i & -i\n    return s\n\n\n@njit((i8[:], i8, i8), cache=True)\ndef add(bit, i, x):\n    while i < len(bit):\n        bit[i] += x\n        i += i & -i\n\n\n@njit((i8[:], i8), cache=True)\ndef find_kth_element(bit, k):\n    N = len(bit)\n    x, sx = 0, 0\n    dx = 1\n    while 2 * dx < N:\n        dx *= 2\n    while dx:\n        y = x + dx\n        if y < N:\n            sy = sx + bit[y]\n            if sy < k:\n                x, sx = y, sy\n        dx //= 2\n    return x + 1\n\n@njit((i8, i8[:]), cache=True)\ndef main(N, AB):\n    A, B = AB[::2], AB[1::2]\n    Q = len(A)\n\n    bit = np.zeros(N + 1, np.int64)  # 長方形の右上になる x 座標集合を管理\n    bit_raw = np.zeros(N + 1, np.int64)\n    H = np.zeros(N + 1, np.int64)  # 長方形の高さを管理\n    H[0] = 2 * 10**13 + 10\n    bit_raw[N] = 1\n    add(bit, N, 1)\n\n    for i in range(Q):\n        a, b = A[i], B[i]\n        n = get_sum(bit, a - 1)\n        h = H[find_kth_element(bit, 1 + n)]\n        if not bit_raw[a]:\n            bit_raw[a] = 1\n            add(bit, a, 1)\n            H[a] = h\n        r = a\n\n        while b:\n            l = 0 if n == 0 else find_kth_element(bit, n)\n            n -= 1\n            area = (H[l] - H[r]) * (r - l)\n            if area <= b:\n                b -= area\n                if l:\n                    bit_raw[l] = 0\n                    add(bit, l, -1)\n                H[l], H[r] = 0, H[l]\n                continue\n            k = b // (r - l)\n            b -= k * (r - l)\n            H[r] += k\n            if b:\n                m = l + b\n                bit_raw[m] = 1\n                add(bit, m, 1)\n                H[m] = H[r] + 1\n                b = 0\n    for n in range(N, 0, -1):\n        H[n - 1] = max(H[n - 1], H[n])\n    return H[1:N + 1]\n\nN, Q = map(int, readline().split())\nAB = np.array(read().split(), np.int64)\n\nans = main(N, AB)\nprint('\\n'.join(map(str, ans.tolist())))"
  }
]