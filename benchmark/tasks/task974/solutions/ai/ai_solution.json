[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100001\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    \n    int dishes[MAX_N] = {0};\n    \n    for (int q = 0; q < Q; q++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        \n        for (int j = 0; j < b; j++) {\n            int min_dishes = INT_MAX;\n            int selected_customer = -1;\n            \n            for (int i = 1; i <= a; i++) {\n                if (dishes[i] < min_dishes) {\n                    min_dishes = dishes[i];\n                    selected_customer = i;\n                }\n            }\n            \n            dishes[selected_customer]++;\n        }\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        printf(\"%d\\n\", dishes[i]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int index;\n    int value;\n} Customer;\n\nvoid build_segment_tree(Customer *tree, int *arr, int node, int start, int end) {\n    if (start == end) {\n        tree[node].index = start;\n        tree[node].value = arr[start];\n    } else {\n        int mid = (start + end) / 2;\n        build_segment_tree(tree, arr, 2 * node, start, mid);\n        build_segment_tree(tree, arr, 2 * node + 1, mid + 1, end);\n        if (tree[2 * node].value < tree[2 * node + 1].value) {\n            tree[node] = tree[2 * node];\n        } else if (tree[2 * node].value > tree[2 * node + 1].value) {\n            tree[node] = tree[2 * node + 1];\n        } else {\n            if (tree[2 * node].index < tree[2 * node + 1].index) {\n                tree[node] = tree[2 * node];\n            } else {\n                tree[node] = tree[2 * node + 1];\n            }\n        }\n    }\n}\n\nCustomer query_segment_tree(Customer *tree, int node, int start, int end, int l, int r) {\n    if (r < start || end < l) {\n        Customer invalid;\n        invalid.index = -1;\n        invalid.value = -1;\n        return invalid;\n    }\n    if (l <= start && end <= r) {\n        return tree[node];\n    }\n    int mid = (start + end) / 2;\n    Customer left = query_segment_tree(tree, 2 * node, start, mid, l, r);\n    Customer right = query_segment_tree(tree, 2 * node + 1, mid + 1, end, l, r);\n    if (left.index == -1) return right;\n    if (right.index == -1) return left;\n    if (left.value < right.value) {\n        return left;\n    } else if (left.value > right.value) {\n        return right;\n    } else {\n        if (left.index < right.index) {\n            return left;\n        } else {\n            return right;\n        }\n    }\n}\n\nvoid update_segment_tree(Customer *tree, int node, int start, int end, int idx, int value) {\n    if (start == end) {\n        tree[node].value = value;\n    } else {\n        int mid = (start + end) / 2;\n        if (start <= idx && idx <= mid) {\n            update_segment_tree(tree, 2 * node, start, mid, idx, value);\n        } else {\n            update_segment_tree(tree, 2 * node + 1, mid + 1, end, idx, value);\n        }\n        if (tree[2 * node].value < tree[2 * node + 1].value) {\n            tree[node] = tree[2 * node];\n        } else if (tree[2 * node].value > tree[2 * node + 1].value) {\n            tree[node] = tree[2 * node + 1];\n        } else {\n            if (tree[2 * node].index < tree[2 * node + 1].index) {\n                tree[node] = tree[2 * node];\n            } else {\n                tree[node] = tree[2 * node + 1];\n            }\n        }\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    int *dishes = (int *)calloc(N + 1, sizeof(int));\n    Customer *tree = (Customer *)malloc(4 * (N + 1) * sizeof(Customer));\n    build_segment_tree(tree, dishes, 1, 1, N);\n    \n    while (Q--) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        while (b--) {\n            Customer selected = query_segment_tree(tree, 1, 1, N, 1, a);\n            dishes[selected.index]++;\n            update_segment_tree(tree, 1, 1, N, selected.index, dishes[selected.index]);\n        }\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        printf(\"%d \", dishes[i]);\n    }\n    printf(\"\\n\");\n    \n    free(dishes);\n    free(tree);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> dishes(N + 1, 0); // 1-based indexing\n\n    while (Q--) {\n        int a, b;\n        cin >> a >> b;\n        for (int k = 0; k < b; ++k) {\n            int min_val = INT_MAX;\n            int min_pos = 1;\n            for (int i = 1; i <= a; ++i) {\n                if (dishes[i] < min_val) {\n                    min_val = dishes[i];\n                    min_pos = i;\n                } else if (dishes[i] == min_val && i < min_pos) {\n                    min_pos = i;\n                }\n            }\n            dishes[min_pos]++;\n        }\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        cout << dishes[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:33:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class SegmentTree {\n        int size;\n        int[] min;\n        int[] count;\n        int[] idx;\n\n        SegmentTree(int n) {\n            size = 1;\n            while (size < n) size <<= 1;\n            min = new int[2 * size];\n            count = new int[2 * size];\n            idx = new int[2 * size];\n            Arrays.fill(min, Integer.MAX_VALUE);\n            for (int i = 0; i < n; i++) {\n                idx[size + i] = i + 1;\n            }\n            for (int i = size - 1; i > 0; i--) {\n                idx[i] = idx[2 * i];\n            }\n        }\n\n        void update(int pos) {\n            pos += size;\n            min[pos]++;\n            for (int i = pos >> 1; i > 0; i >>= 1) {\n                int left = 2 * i;\n                int right = 2 * i + 1;\n                if (min[left] < min[right]) {\n                    min[i] = min[left];\n                    count[i] = count[left];\n                    idx[i] = idx[left];\n                } else if (min[left] > min[right]) {\n                    min[i] = min[right];\n                    count[i] = count[right];\n                    idx[i] = idx[right];\n                } else {\n                    min[i] = min[left];\n                    count[i] = count[left] + count[right];\n                    if (idx[left] < idx[right]) {\n                        idx[i] = idx[left];\n                    } else {\n                        idx[i] = idx[right];\n                    }\n                }\n            }\n        }\n\n        int[] query(int l, int r) {\n            l += size;\n            r += size;\n            int resMin = Integer.MAX_VALUE;\n            int resCount = 0;\n            int resIdx = Integer.MAX_VALUE;\n            while (l < r) {\n                if ((l & 1) == 1) {\n                    if (min[l] < resMin) {\n                        resMin = min[l];\n                        resCount = count[l];\n                        resIdx = idx[l];\n                    } else if (min[l] == resMin) {\n                        resCount += count[l];\n                        if (idx[l] < resIdx) {\n                            resIdx = idx[l];\n                        }\n                    }\n                    l++;\n                }\n                if ((r & 1) == 1) {\n                    r--;\n                    if (min[r] < resMin) {\n                        resMin = min[r];\n                        resCount = count[r];\n                        resIdx = idx[r];\n                    } else if (min[r] == resMin) {\n                        resCount += count[r];\n                        if (idx[r] < resIdx) {\n                            resIdx = idx[r];\n                        }\n                    }\n                }\n                l >>= 1;\n                r >>= 1;\n            }\n            return new int[]{resMin, resIdx};\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int N = Integer.parseInt(line[0]);\n        int Q = Integer.parseInt(line[1]);\n\n        SegmentTree st = new SegmentTree(N);\n        int[] dishes = new int[N + 1];\n\n        for (int q = 0; q < Q; q++) {\n            line = br.readLine().split(\" \");\n            int a = Integer.parseInt(line[0]);\n            int b = Integer.parseInt(line[1]);\n\n            for (int i = 0; i < b; i++) {\n                int[] res = st.query(0, a);\n                int customer = res[1];\n                dishes[customer]++;\n                st.update(customer - 1);\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= N; i++) {\n            sb.append(dishes[i]).append(\" \");\n        }\n        System.out.println(sb.toString().trim());\n    }\n}",
    "timestamp": "2025-08-05 23:34:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class SushiDishes {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int Q = Integer.parseInt(st.nextToken());\n        \n        int[] dishes = new int[N + 1];\n        \n        for (int i = 0; i < Q; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            \n            for (int j = 0; j < b; j++) {\n                int minDishes = Integer.MAX_VALUE;\n                int minCustomer = 1;\n                \n                for (int k = 1; k <= a; k++) {\n                    if (dishes[k] < minDishes) {\n                        minDishes = dishes[k];\n                        minCustomer = k;\n                    }\n                }\n                \n                dishes[minCustomer]++;\n            }\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            System.out.println(dishes[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:34:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    vector<int> dishes(N + 1, 0);\n    \n    for (int i = 0; i < Q; i++) {\n        int a, b;\n        cin >> a >> b;\n        \n        for (int j = 0; j < b; j++) {\n            int min_dishes = INT_MAX;\n            int min_customer = 1;\n            \n            for (int k = 1; k <= a; k++) {\n                if (dishes[k] < min_dishes) {\n                    min_dishes = dishes[k];\n                    min_customer = k;\n                }\n            }\n            \n            dishes[min_customer]++;\n        }\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        cout << dishes[i] << \" \";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def sushi_eaten(N, Q, operations):\n    dishes_eaten = [0] * N\n\n    for a_i, b_i in operations:\n        for _ in range(b_i):\n            min_dishes = float('inf')\n            selected_customer = -1\n            for i in range(a_i):\n                if dishes_eaten[i] < min_dishes:\n                    min_dishes = dishes_eaten[i]\n                    selected_customer = i\n            dishes_eaten[selected_customer] += 1\n\n    return dishes_eaten\n\n# Example usage:\nN = 5\nQ = 3\noperations = [(3, 2), (5, 1), (2, 3)]\nresult = sushi_eaten(N, Q, operations)\nprint(result)  # Output: [3, 3, 2, 0, 0]",
    "timestamp": "2025-08-13 15:49:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SushiRestaurant {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int Q = scanner.nextInt();\n\n        int[] sushiEaten = new int[N + 1]; // using 1-based indexing\n\n        for (int i = 0; i < Q; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n\n            for (int count = 0; count < b; count++) {\n                int minIndex = 1;\n                for (int j = 2; j <= a; j++) {\n                    if (sushiEaten[j] < sushiEaten[minIndex]) {\n                        minIndex = j;\n                    }\n                }\n                sushiEaten[minIndex]++;\n            }\n        }\n\n        // Print the number of sushi dishes each customer has eaten\n        for (int i = 1; i <= N; i++) {\n            System.out.print(sushiEaten[i] + \" \");\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 15:49:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    \n    int *dishes = (int *)calloc(N, sizeof(int));\n    \n    for (int i = 0; i < Q; ++i) {\n        int a_i, b_i;\n        scanf(\"%d %d\", &a_i, &b_i);\n        \n        for (int j = 0; j < b_i; ++j) {\n            int min_dishes = dishes[0];\n            int min_index = 0;\n            \n            for (int k = 1; k < a_i; ++k) {\n                if (dishes[k] < min_dishes) {\n                    min_dishes = dishes[k];\n                    min_index = k;\n                }\n            }\n            \n            dishes[min_index]++;\n        }\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        printf(\"%d \", dishes[i]);\n    }\n    \n    free(dishes);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:49:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    vector<int> sushi_count(N + 1, 0);\n    \n    for (int i = 0; i < Q; ++i) {\n        int a_i, b_i;\n        cin >> a_i >> b_i;\n        \n        while (b_i--) {\n            int min_index = 1, min_value = INT_MAX;\n            \n            for (int j = 1; j <= a_i; ++j) {\n                if (sushi_count[j] < min_value) {\n                    min_value = sushi_count[j];\n                    min_index = j;\n                }\n            }\n            \n            sushi_count[min_index]++;\n        }\n    }\n    \n    for (int i = 1; i <= N; ++i) {\n        cout << sushi_count[i] << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:49:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_sushi_distribution(N, Q, operations):\n    dishes_eaten = [0] * (N + 1)\n    \n    for a, b in operations:\n        for _ in range(b):\n            # Find the customer with minimum dishes among first a customers\n            min_dishes = float('inf')\n            min_customer = float('inf')\n            \n            for customer in range(1, a + 1):\n                if dishes_eaten[customer] < min_dishes:\n                    min_dishes = dishes_eaten[customer]\n                    min_customer = customer\n                elif dishes_eaten[customer] == min_dishes:\n                    min_customer = min(min_customer, customer)\n            \n            # Give dish to selected customer\n            dishes_eaten[min_customer] += 1\n    \n    # Remove first index which is not used\n    return dishes_eaten[1:]\n\n# Read input\nN, Q = map(int, input().split())\noperations = []\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    operations.append((a, b))\n\n# Solve and print result\nresult = solve_sushi_distribution(N, Q, operations)\nprint(*result)",
    "timestamp": "2025-08-13 15:49:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    \n    # We'll use a list to keep track of the counts, initialized to 0\n    counts = [0] * (N + 1)  # 1-based indexing\n    \n    # For each of the first a_i customers, we need to keep track of their counts and indices\n    # We'll use a segment tree or a heap to find the minimum efficiently\n    \n    # Since we need to handle ranges [1..a_i], a segment tree is more appropriate\n    # The segment tree will store the minimum value in a range and the smallest index with that value\n    \n    size = 1\n    while size < N:\n        size <<= 1\n    seg = [ (0, i) for i in range(2*size) ]  # (value, index)\n    \n    # Initialize leaves\n    for i in range(1, N+1):\n        seg[size + i - 1] = (0, i)\n    # Build the segment tree\n    for i in range(size-1, 0, -1):\n        left = seg[2*i]\n        right = seg[2*i+1]\n        if left[0] < right[0]:\n            seg[i] = left\n        elif left[0] > right[0]:\n            seg[i] = right\n        else:\n            seg[i] = (left[0], min(left[1], right[1]))\n    \n    def update(pos):\n        pos += size - 1\n        seg[pos] = (counts[seg[pos][1]], seg[pos][1])\n        pos >>= 1\n        while pos >= 1:\n            left = seg[2*pos]\n            right = seg[2*pos+1]\n            if left[0] < right[0]:\n                seg[pos] = left\n            elif left[0] > right[0]:\n                seg[pos] = right\n            else:\n                seg[pos] = (left[0], min(left[1], right[1]))\n            pos >>= 1\n    \n    def query(l, r):\n        res = (float('inf'), -1)\n        l += size - 1\n        r += size - 1\n        while l <= r:\n            if l % 2 == 1:\n                cand = seg[l]\n                if cand[0] < res[0]:\n                    res = cand\n                elif cand[0] == res[0] and cand[1] < res[1]:\n                    res = cand\n                l += 1\n            if r % 2 == 0:\n                cand = seg[r]\n                if cand[0] < res[0]:\n                    res = cand\n                elif cand[0] == res[0] and cand[1] < res[1]:\n                    res = cand\n                r -= 1\n            l >>= 1\n            r >>= 1\n        return res[1]\n    \n    for _ in range(Q):\n        a_i = int(input[ptr])\n        b_i = int(input[ptr+1])\n        ptr += 2\n        for _ in range(b_i):\n            selected = query(1, a_i)\n            counts[selected] += 1\n            update(selected)\n    \n    print('\\n'.join(map(str, counts[1:N+1])))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 15:50:09"
  }
]