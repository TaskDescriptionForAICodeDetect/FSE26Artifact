[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint solve(int arr[], int n) {\n    int minReplacements = INT_MAX;\n    \n    for (int first = 0; first <= 1; first++) {\n        for (int second = 0; second <= 1; second++) {\n            if (first == second) continue;\n            \n            int replacements = 0;\n            int values[2] = {first, second};\n            \n            for (int i = 0; i < n; i++) {\n                if (arr[i] != values[i % 2]) {\n                    replacements++;\n                }\n            }\n            \n            minReplacements = (replacements < minReplacements) ? replacements : minReplacements;\n        }\n    }\n    \n    return minReplacements;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    printf(\"%d\\n\", solve(arr, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int value;\n    int count;\n} Freq;\n\nint compare(const void *a, const void *b) {\n    return ((Freq *)b)->count - ((Freq *)a)->count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int v[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &v[i]);\n    }\n\n    Freq even_freq[MAX_N] = {0};\n    Freq odd_freq[MAX_N] = {0};\n    int even_size = 0, odd_size = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            int found = 0;\n            for (int j = 0; j < even_size; j++) {\n                if (even_freq[j].value == v[i]) {\n                    even_freq[j].count++;\n                    found = 1;\n                    break;\n                }\n            }\n            if (!found) {\n                even_freq[even_size].value = v[i];\n                even_freq[even_size].count = 1;\n                even_size++;\n            }\n        } else {\n            int found = 0;\n            for (int j = 0; j < odd_size; j++) {\n                if (odd_freq[j].value == v[i]) {\n                    odd_freq[j].count++;\n                    found = 1;\n                    break;\n                }\n            }\n            if (!found) {\n                odd_freq[odd_size].value = v[i];\n                odd_freq[odd_size].count = 1;\n                odd_size++;\n            }\n        }\n    }\n\n    qsort(even_freq, even_size, sizeof(Freq), compare);\n    qsort(odd_freq, odd_size, sizeof(Freq), compare);\n\n    int min_changes = INT_MAX;\n    for (int i = 0; i < 2 && i < even_size; i++) {\n        for (int j = 0; j < 2 && j < odd_size; j++) {\n            if (even_freq[i].value != odd_freq[j].value) {\n                int changes = (n / 2 - even_freq[i].count) + (n / 2 - odd_freq[j].count);\n                if (changes < min_changes) {\n                    min_changes = changes;\n                }\n            }\n        }\n    }\n\n    if (min_changes == INT_MAX) {\n        min_changes = n / 2;\n    }\n\n    printf(\"%d\\n\", min_changes);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n\n    map<int, int> freq1, freq2;\n    for (int i = 0; i < n; i += 2) {\n        freq1[v[i]]++;\n    }\n    for (int i = 1; i < n; i += 2) {\n        freq2[v[i]]++;\n    }\n\n    vector<pair<int, int>> vec1(freq1.begin(), freq1.end());\n    vector<pair<int, int>> vec2(freq2.begin(), freq2.end());\n\n    auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second > b.second;\n    };\n    sort(vec1.begin(), vec1.end(), cmp);\n    sort(vec2.begin(), vec2.end(), cmp);\n\n    int max1 = (vec1.empty()) ? 0 : vec1[0].second;\n    int max2 = (vec2.empty()) ? 0 : vec2[0].second;\n\n    if (vec1.empty() || vec2.empty()) {\n        cout << n / 2 << endl;\n        return 0;\n    }\n\n    if (vec1[0].first != vec2[0].first) {\n        cout << n - max1 - max2 << endl;\n    } else {\n        int option1 = (vec1.size() > 1) ? vec1[1].second : 0;\n        int option2 = (vec2.size() > 1) ? vec2[1].second : 0;\n        int best = max(max1 + option2, max2 + option1);\n        cout << n - best << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] v = new int[n];\n        for (int i = 0; i < n; i++) {\n            v[i] = scanner.nextInt();\n        }\n\n        Map<Integer, Integer> evenFreq = new HashMap<>();\n        Map<Integer, Integer> oddFreq = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                evenFreq.put(v[i], evenFreq.getOrDefault(v[i], 0) + 1);\n            } else {\n                oddFreq.put(v[i], oddFreq.getOrDefault(v[i], 0) + 1);\n            }\n        }\n\n        int evenMax1 = 0, evenMax2 = 0, evenKey1 = 0, evenKey2 = 0;\n        for (Map.Entry<Integer, Integer> entry : evenFreq.entrySet()) {\n            if (entry.getValue() > evenMax1) {\n                evenMax2 = evenMax1;\n                evenKey2 = evenKey1;\n                evenMax1 = entry.getValue();\n                evenKey1 = entry.getKey();\n            } else if (entry.getValue() > evenMax2) {\n                evenMax2 = entry.getValue();\n                evenKey2 = entry.getKey();\n            }\n        }\n\n        int oddMax1 = 0, oddMax2 = 0, oddKey1 = 0, oddKey2 = 0;\n        for (Map.Entry<Integer, Integer> entry : oddFreq.entrySet()) {\n            if (entry.getValue() > oddMax1) {\n                oddMax2 = oddMax1;\n                oddKey2 = oddKey1;\n                oddMax1 = entry.getValue();\n                oddKey1 = entry.getKey();\n            } else if (entry.getValue() > oddMax2) {\n                oddMax2 = entry.getValue();\n                oddKey2 = entry.getKey();\n            }\n        }\n\n        int minChanges;\n        if (evenKey1 != oddKey1) {\n            minChanges = n - evenMax1 - oddMax1;\n        } else {\n            int option1 = n - evenMax1 - (oddMax2 != 0 ? oddMax2 : 0);\n            int option2 = n - (evenMax2 != 0 ? evenMax2 : 0) - oddMax1;\n            minChanges = Math.min(option1, option2);\n        }\n\n        System.out.println(minChanges);\n    }\n}",
    "timestamp": "2025-08-05 23:02:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AlternatingSequence {\n    public static int minReplacements(int[] arr) {\n        int n = arr.length;\n        int[] unique = new HashSet<>(Arrays.stream(arr).boxed().collect(Collectors.toList()))\n                .stream().mapToInt(Integer::intValue).toArray();\n        \n        if (unique.length > 2) return -1;\n        \n        int replacements1 = countReplacements(arr, unique[0], unique[1]);\n        int replacements2 = countReplacements(arr, unique[1], unique[0]);\n        \n        return Math.min(replacements1, replacements2);\n    }\n    \n    private static int countReplacements(int[] arr, int first, int second) {\n        int replacements = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (i % 2 == 0 && arr[i] != first) replacements++;\n            if (i % 2 == 1 && arr[i] != second) replacements++;\n        }\n        return replacements;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int[] sequence = {1, 2, 1, 2, 1, 2};\n        System.out.println(minReplacements(sequence));\n    }\n}",
    "timestamp": "2025-08-05 23:02:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumReplacements(vector<int>& nums) {\n        int n = nums.size();\n        int replacements = 0;\n        \n        // Try using the first two unique elements\n        int first = nums[0], second = -1;\n        for (int num : nums) {\n            if (num != first) {\n                second = num;\n                break;\n            }\n        }\n        \n        // If only one unique element exists\n        if (second == -1) return n / 2;\n        \n        // Try two possible patterns\n        int changes1 = tryAlternatingPattern(nums, first, second);\n        int changes2 = tryAlternatingPattern(nums, second, first);\n        \n        return min(changes1, changes2);\n    }\n    \nprivate:\n    int tryAlternatingPattern(vector<int>& nums, int first, int second) {\n        int replacements = 0;\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0 && nums[i] != first) replacements++;\n            if (i % 2 == 1 && nums[i] != second) replacements++;\n        }\n        \n        return replacements;\n    }\n};",
    "timestamp": "2025-08-05 23:02:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import Counter\n\ndef min_changes_to_alternating(v):\n    n = len(v)\n    \n    # Split sequence into two subsequences\n    v1 = v[0::2]\n    v2 = v[1::2]\n    \n    # Get the most common elements and their counts in each subsequence\n    c1 = Counter(v1).most_common(2)\n    c2 = Counter(v2).most_common(2)\n    \n    # Ensure that we have at least two entries\n    if len(c1) < 2:\n        c1.append((None, 0))\n    if len(c2) < 2:\n        c2.append((None, 0))\n    \n    # Calculate the replacement needed in different scenarios\n    if c1[0][0] != c2[0][0]:\n        # No conflict between the two major elements\n        changes = (len(v1) - c1[0][1]) + (len(v2) - c2[0][1])\n    else:\n        # Conflict between the two major elements\n        changes = min(\n            (len(v1) - c1[0][1]) + (len(v2) - c2[1][1]),  # Use second most common in v2\n            (len(v1) - c1[1][1]) + (len(v2) - c2[0][1])   # Use second most common in v1\n        )\n    \n    return changes\n\n# Example usage\nv = [2, 3, 2, 3, 2, 3, 2, 4]\nresult = min_changes_to_alternating(v)\nprint(result)",
    "timestamp": "2025-08-13 13:22:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class AlternatingSequence {\n    public static int minReplacements(int[] v) {\n        int n = v.length;\n        Map<Integer, Integer> map1 = new HashMap<>();\n        Map<Integer, Integer> map2 = new HashMap<>();\n        \n        for (int i = 0; i < n; i += 2) {\n            map1.put(v[i], map1.getOrDefault(v[i], 0) + 1);\n        }\n        for (int i = 1; i < n; i += 2) {\n            map2.put(v[i], map2.getOrDefault(v[i], 0) + 1);\n        }\n        \n        List<Map.Entry<Integer, Integer>> freq1 = new ArrayList<>(map1.entrySet());\n        List<Map.Entry<Integer, Integer>> freq2 = new ArrayList<>(map2.entrySet());\n        \n        freq1.sort((o1, o2) -> o2.getValue() - o1.getValue());\n        freq2.sort((o1, o2) -> o2.getValue() - o1.getValue());\n        \n        int len1 = freq1.size();\n        int len2 = freq2.size();\n        \n        int maxFreq1 = freq1.get(0).getValue();\n        int maxElem1 = freq1.get(0).getKey();\n\n        int maxFreq2 = freq2.get(0).getValue();\n        int maxElem2 = freq2.get(0).getKey();\n\n        if (maxElem1 != maxElem2) {\n            return n - maxFreq1 - maxFreq2;\n        } else {\n            int option1 = n - maxFreq1 - (len2 > 1 ? freq2.get(1).getValue() : 0);\n            int option2 = n - maxFreq2 - (len1 > 1 ? freq1.get(1).getValue() : 0);\n            return Math.min(option1, option2);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] v = {1, 2, 1, 2, 1, 2};\n        System.out.println(minReplacements(v)); // Output: 0\n    }\n}",
    "timestamp": "2025-08-13 13:22:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint minReplacementsToAlternateSequence(int* v, int n) {\n    int freq1[100001] = {0}, freq2[100001] = {0};\n    int max_val1 = 0, max_val2 = 0;\n    int max_count1 = 0, max_count2 = 0;\n    \n    for (int i = 0; i < n; i += 2) {\n        freq1[v[i]]++;\n        if (freq1[v[i]] > max_count1) {\n            max_count1 = freq1[v[i]];\n            max_val1 = v[i];\n        }\n    }\n    \n    for (int i = 1; i < n; i += 2) {\n        freq2[v[i]]++;\n        if (freq2[v[i]] > max_count2) {\n            max_count2 = freq2[v[i]];\n            max_val2 = v[i];\n        }\n    }\n\n    int second_max_val1 = 0, second_max_count1 = 0;\n    int second_max_val2 = 0, second_max_count2 = 0;\n\n    for (int i = 0; i < 100001; ++i) {\n        if (i != max_val1 && freq1[i] > second_max_count1) {\n            second_max_count1 = freq1[i];\n            second_max_val1 = i;\n        }\n        if (i != max_val2 && freq2[i] > second_max_count2) {\n            second_max_count2 = freq2[i];\n            second_max_val2 = i;\n        }\n    }\n\n    int replacements;\n    if (max_val1 != max_val2) {\n        replacements = (n / 2 - max_count1) + (n / 2 - max_count2);\n    } else {\n        int case1 = (n / 2 - max_count1) + (n / 2 - second_max_count2);\n        int case2 = (n / 2 - second_max_count1) + (n / 2 - max_count2);\n        replacements = case1 < case2 ? case1 : case2;\n    }\n    \n    return replacements;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int v[n];\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &v[i]);\n    }\n\n    int result = minReplacementsToAlternateSequence(v, n);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:22:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minReplacementsToAlternating(arr) {\n    const n = arr.length;\n    const freqMap1 = {};\n    const freqMap2 = {};\n    \n    // Count frequencies for odd and even indexed positions\n    for (let i = 0; i < n; i += 2) {\n        freqMap1[arr[i]] = (freqMap1[arr[i]] || 0) + 1;\n        freqMap2[arr[i + 1]] = (freqMap2[arr[i + 1]] || 0) + 1;\n    }\n    \n    // Convert frequency maps to arrays [[key, freq], ...] and sort them by frequency\n    const sortedFreq1 = Object.entries(freqMap1).sort((a, b) => b[1] - a[1]);\n    const sortedFreq2 = Object.entries(freqMap2).sort((a, b) => b[1] - a[1]);\n    \n    const maxFreq1 = sortedFreq1[0][1];\n    const maxFreq2 = sortedFreq2[0][1];\n    \n    // Determine if the top most frequent elements are different\n    if (sortedFreq1[0][0] !== sortedFreq2[0][0]) {\n        return n - maxFreq1 - maxFreq2;\n    }\n\n    // If they are the same, calculate second most frequent replacements\n    const secondMaxFreq1 = sortedFreq1.length > 1 ? sortedFreq1[1][1] : 0;\n    const secondMaxFreq2 = sortedFreq2.length > 1 ? sortedFreq2[1][1] : 0;\n\n    const option1 = n - (maxFreq1 + secondMaxFreq2);\n    const option2 = n - (secondMaxFreq1 + maxFreq2);\n    \n    // Return the minimum number of replacements between the two options\n    return Math.min(option1, option2);\n}",
    "timestamp": "2025-08-13 13:23:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_replacements_to_alternating(v):\n    n = len(v)\n    if n % 2 != 0:\n        return -1  # Odd length sequence is impossible\n    \n    # Try both possible alternating arrangements\n    arrangement1 = [v[0], v[1]] * (n // 2)\n    arrangement2 = [v[1], v[0]] * (n // 2)\n    \n    # Count replacements for first arrangement\n    replacements1 = sum(v[i] != arrangement1[i] for i in range(n))\n    \n    # Count replacements for second arrangement\n    replacements2 = sum(v[i] != arrangement2[i] for i in range(n))\n    \n    return min(replacements1, replacements2)",
    "timestamp": "2025-08-13 13:23:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumReplacements(v) {\n    const n = v.length;\n    if (n % 2 !== 0) return -1;\n    \n    let replacements = Infinity;\n    \n    for (let firstNum of new Set(v)) {\n        for (let secondNum of new Set(v)) {\n            if (firstNum === secondNum) continue;\n            \n            let currentReplacements = 0;\n            let alternating = true;\n            \n            for (let i = 0; i < n; i++) {\n                if (i % 2 === 0 && v[i] !== firstNum) {\n                    currentReplacements++;\n                }\n                if (i % 2 === 1 && v[i] !== secondNum) {\n                    currentReplacements++;\n                }\n            }\n            \n            replacements = Math.min(replacements, currentReplacements);\n        }\n    }\n    \n    return replacements;\n}",
    "timestamp": "2025-08-13 13:23:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "n = int(input())\nv = list(map(int, input().split()))\nfrom collections import defaultdict\n\neven_counts = defaultdict(int)\nodd_counts = defaultdict(int)\n\nfor i in range(n):\n    if i % 2 == 0:\n        even_counts[v[i]] += 1\n    else:\n        odd_counts[v[i]] += 1\n\n# Get top two for even and odd positions\neven_top = sorted(even_counts.items(), key=lambda x: -x[1])\nodd_top = sorted(odd_counts.items(), key=lambda x: -x[1])\n\nmax_even1, cnt_even1 = even_top[0] if even_top else (0, 0)\nmax_even2, cnt_even2 = even_top[1] if len(even_top) > 1 else (0, 0)\nmax_odd1, cnt_odd1 = odd_top[0] if odd_top else (0, 0)\nmax_odd2, cnt_odd2 = odd_top[1] if len(odd_top) > 1 else (0, 0)\n\nif max_even1 != max_odd1:\n    changes = (n // 2 - cnt_even1) + (n // 2 - cnt_odd1)\nelse:\n    option1 = (n // 2 - cnt_even1) + (n // 2 - cnt_odd2)\n    option2 = (n // 2 - cnt_even2) + (n // 2 - cnt_odd1)\n    changes = min(option1, option2)\n\nprint(changes)",
    "timestamp": "2025-08-13 13:23:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minReplacementsToAlternating(sequence) {\n    if (sequence.length === 0) return 0;\n    \n    // Count frequencies for even and odd positions\n    const evenFreq = new Map();\n    const oddFreq = new Map();\n    \n    for (let i = 0; i < sequence.length; i++) {\n        const num = sequence[i];\n        if (i % 2 === 0) {\n            evenFreq.set(num, (evenFreq.get(num) || 0) + 1);\n        } else {\n            oddFreq.set(num, (oddFreq.get(num) || 0) + 1);\n        }\n    }\n    \n    // Find top two frequencies for even positions\n    const evenTop = getTopTwoFrequencies(evenFreq);\n    // Find top two frequencies for odd positions\n    const oddTop = getTopTwoFrequencies(oddFreq);\n    \n    let minReplacements = Infinity;\n    \n    // Try all combinations of top two from even and odd\n    for (const [evenNum, evenCount] of evenTop) {\n        for (const [oddNum, oddCount] of oddTop) {\n            if (evenNum !== oddNum) {\n                const replacements = (sequence.length / 2 - evenCount) + (sequence.length / 2 - oddCount);\n                if (replacements < minReplacements) {\n                    minReplacements = replacements;\n                }\n            }\n        }\n    }\n    \n    // If all elements are same, need to replace half\n    if (minReplacements === Infinity) {\n        minReplacements = sequence.length / 2;\n    }\n    \n    return minReplacements;\n}\n\nfunction getTopTwoFrequencies(freqMap) {\n    const entries = Array.from(freqMap.entries());\n    entries.sort((a, b) => b[1] - a[1]);\n    return entries.slice(0, 2).length > 0 ? entries.slice(0, 2) : [[null, 0]];\n}",
    "timestamp": "2025-08-13 13:23:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minReplacementsToAlternating(const vector<int>& v) {\n    int n = v.size();\n    unordered_map<int, int> freq1, freq2;\n\n    for (int i = 0; i < n; i += 2) {\n        freq1[v[i]]++;\n    }\n\n    for (int i = 1; i < n; i += 2) {\n        freq2[v[i]]++;\n    }\n\n    int maxFreq1 = 0, secMaxFreq1 = 0, num1 = 0, secNum1 = 0;\n    for (auto& p : freq1) {\n        if (p.second > maxFreq1) {\n            secMaxFreq1 = maxFreq1;\n            secNum1 = num1;\n            maxFreq1 = p.second;\n            num1 = p.first;\n        } else if (p.second > secMaxFreq1) {\n            secMaxFreq1 = p.second;\n            secNum1 = p.first;\n        }\n    }\n\n    int maxFreq2 = 0, secMaxFreq2 = 0, num2 = 0, secNum2 = 0;\n    for (auto& p : freq2) {\n        if (p.second > maxFreq2) {\n            secMaxFreq2 = maxFreq2;\n            secNum2 = num2;\n            maxFreq2 = p.second;\n            num2 = p.first;\n        } else if (p.second > secMaxFreq2) {\n            secMaxFreq2 = p.second;\n            secNum2 = p.first;\n        }\n    }\n\n    int replaceCase1 = n - maxFreq1 - (num1 == num2 ? secMaxFreq2 : maxFreq2);\n    int replaceCase2 = n - maxFreq2 - (num2 == num1 ? secMaxFreq1 : maxFreq1);\n\n    return min(replaceCase1, replaceCase2);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n    cout << minReplacementsToAlternating(v) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:39:27"
  }
]