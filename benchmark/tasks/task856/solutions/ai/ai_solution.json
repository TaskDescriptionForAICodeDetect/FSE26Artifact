[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <vector>\n\nconst int MAXN = 10005;\n\nstd::vector<int> graph[MAXN];\nstd::vector<int> rev_graph[MAXN];\nint dfn[MAXN], low[MAXN], scc[MAXN], st[MAXN];\nbool instack[MAXN];\nint dfs_clock, scc_cnt, top;\n\nvoid tarjan(int u) {\n    dfn[u] = low[u] = ++dfs_clock;\n    st[++top] = u;\n    instack[u] = true;\n\n    for (int v : graph[u]) {\n        if (!dfn[v]) {\n            tarjan(v);\n            low[u] = std::min(low[u], low[v]);\n        } else if (instack[v]) {\n            low[u] = std::min(low[u], dfn[v]);\n        }\n    }\n\n    if (dfn[u] == low[u]) {\n        scc_cnt++;\n        int v;\n        do {\n            v = st[top--];\n            instack[v] = false;\n            scc[v] = scc_cnt;\n        } while (v != u);\n    }\n}\n\nint find_scc(int n) {\n    dfs_clock = 0;\n    scc_cnt = 0;\n    top = 0;\n    memset(dfn, 0, sizeof(dfn));\n    memset(low, 0, sizeof(low));\n    memset(scc, 0, sizeof(scc));\n    memset(instack, 0, sizeof(instack));\n\n    for (int i = 1; i <= n; i++) {\n        if (!dfn[i]) {\n            tarjan(i);\n        }\n    }\n    return scc_cnt;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 1; i <= m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        graph[a].push_back(b);\n    }\n\n    int original_scc = find_scc(n);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            graph[j].clear();\n        }\n\n        for (int j = 1; j <= m; j++) {\n            int a, b;\n            scanf(\"%d %d\", &a, &b);\n            if (j == i) {\n                graph[b].push_back(a);\n            } else {\n                graph[a].push_back(b);\n            }\n        }\n\n        int reversed_scc = find_scc(n);\n\n        if (reversed_scc != original_scc) {\n            printf(\"diff\\n\");\n        } else {\n            printf(\"same\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:08:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 2000\n#define MAX_M 200000\n\ntypedef struct {\n    int a, b;\n} Edge;\n\nEdge edges[MAX_M];\nint adj[MAX_N + 1][MAX_N + 1];\nint radj[MAX_N + 1][MAX_N + 1];\nint visited[MAX_N + 1];\nint order[MAX_N + 1];\nint component[MAX_N + 1];\nint N, M, order_idx, component_count;\n\nvoid dfs1(int u) {\n    visited[u] = 1;\n    for (int v = 1; v <= N; v++) {\n        if (adj[u][v] && !visited[v]) {\n            dfs1(v);\n        }\n    }\n    order[order_idx++] = u;\n}\n\nvoid dfs2(int u, int c) {\n    component[u] = c;\n    for (int v = 1; v <= N; v++) {\n        if (radj[u][v] && component[v] == -1) {\n            dfs2(v, c);\n        }\n    }\n}\n\nvoid kosaraju() {\n    order_idx = 0;\n    memset(visited, 0, sizeof(visited));\n    for (int u = 1; u <= N; u++) {\n        if (!visited[u]) {\n            dfs1(u);\n        }\n    }\n\n    component_count = 0;\n    memset(component, -1, sizeof(component));\n    for (int i = N - 1; i >= 0; i--) {\n        int u = order[i];\n        if (component[u] == -1) {\n            dfs2(u, component_count++);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    memset(adj, 0, sizeof(adj));\n    memset(radj, 0, sizeof(radj));\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &edges[i].a, &edges[i].b);\n        adj[edges[i].a][edges[i].b] = 1;\n        radj[edges[i].b][edges[i].a] = 1;\n    }\n\n    kosaraju();\n    int original_components = component_count;\n\n    for (int i = 0; i < M; i++) {\n        int a = edges[i].a, b = edges[i].b;\n        if (component[a] == component[b]) {\n            printf(\"same\\n\");\n            continue;\n        }\n\n        adj[a][b] = 0;\n        radj[b][a] = 0;\n        adj[b][a] = 1;\n        radj[a][b] = 1;\n\n        kosaraju();\n        if (component_count == original_components) {\n            printf(\"same\\n\");\n        } else {\n            printf(\"diff\\n\");\n        }\n\n        adj[b][a] = 0;\n        radj[a][b] = 0;\n        adj[a][b] = 1;\n        radj[b][a] = 1;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int a, b;\n};\n\nvector<vector<int>> adj, radj;\nvector<bool> visited;\nvector<int> order, component;\n\nvoid dfs1(int v) {\n    visited[v] = true;\n    for (int u : adj[v]) {\n        if (!visited[u]) {\n            dfs1(u);\n        }\n    }\n    order.push_back(v);\n}\n\nvoid dfs2(int v) {\n    visited[v] = true;\n    component.push_back(v);\n    for (int u : radj[v]) {\n        if (!visited[u]) {\n            dfs2(u);\n        }\n    }\n}\n\nint count_scc(int N) {\n    visited.assign(N + 1, false);\n    order.clear();\n    for (int i = 1; i <= N; ++i) {\n        if (!visited[i]) {\n            dfs1(i);\n        }\n    }\n    visited.assign(N + 1, false);\n    reverse(order.begin(), order.end());\n    int scc_count = 0;\n    for (int v : order) {\n        if (!visited[v]) {\n            component.clear();\n            dfs2(v);\n            scc_count++;\n        }\n    }\n    return scc_count;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N, M;\n    cin >> N >> M;\n    adj.resize(N + 1);\n    radj.resize(N + 1);\n    vector<Edge> edges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].a >> edges[i].b;\n        adj[edges[i].a].push_back(edges[i].b);\n        radj[edges[i].b].push_back(edges[i].a);\n    }\n    int original_scc = count_scc(N);\n    for (int i = 0; i < M; ++i) {\n        int a = edges[i].a, b = edges[i].b;\n        // Remove edge a->b\n        adj[a].erase(find(adj[a].begin(), adj[a].end(), b));\n        radj[b].erase(find(radj[b].begin(), radj[b].end(), a));\n        // Add edge b->a\n        adj[b].push_back(a);\n        radj[a].push_back(b);\n        int new_scc = count_scc(N);\n        if (new_scc != original_scc) {\n            cout << \"diff\\n\";\n        } else {\n            cout << \"same\\n\";\n        }\n        // Revert changes\n        adj[b].pop_back();\n        radj[a].pop_back();\n        adj[a].push_back(b);\n        radj[b].push_back(a);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static int N, M;\n    static List<List<Integer>> graph, reversedGraph;\n    static List<int[]> edges;\n    static int[] order, component;\n    static boolean[] visited;\n    static int currentOrder, currentComponent;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().split(\" \");\n        N = Integer.parseInt(parts[0]);\n        M = Integer.parseInt(parts[1]);\n        edges = new ArrayList<>();\n        graph = new ArrayList<>();\n        reversedGraph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n            reversedGraph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            parts = br.readLine().split(\" \");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            edges.add(new int[]{a, b});\n            graph.get(a).add(b);\n            reversedGraph.get(b).add(a);\n        }\n\n        order = new int[N + 1];\n        visited = new boolean[N + 1];\n        currentOrder = 0;\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                dfs1(i);\n            }\n        }\n\n        component = new int[N + 1];\n        visited = new boolean[N + 1];\n        currentComponent = 0;\n        for (int i = N; i >= 1; i--) {\n            int v = order[i];\n            if (!visited[v]) {\n                dfs2(v);\n                currentComponent++;\n            }\n        }\n\n        for (int[] edge : edges) {\n            int a = edge[0];\n            int b = edge[1];\n            if (component[a] == component[b]) {\n                System.out.println(\"same\");\n            } else {\n                System.out.println(\"diff\");\n            }\n        }\n    }\n\n    static void dfs1(int v) {\n        visited[v] = true;\n        for (int u : graph.get(v)) {\n            if (!visited[u]) {\n                dfs1(u);\n            }\n        }\n        order[++currentOrder] = v;\n    }\n\n    static void dfs2(int v) {\n        visited[v] = true;\n        component[v] = currentComponent;\n        for (int u : reversedGraph.get(v)) {\n            if (!visited[u]) {\n                dfs2(u);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:09:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class StronglyConnectedComponents {\n    private static List<List<Integer>> graph;\n    private static List<List<Integer>> reversedGraph;\n    private static boolean[] visited;\n    private static Stack<Integer> stack;\n    private static int originalSCC, newSCC;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        graph = new ArrayList<>(N + 1);\n        reversedGraph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n            reversedGraph.add(new ArrayList<>());\n        }\n\n        int[] from = new int[M];\n        int[] to = new int[M];\n        for (int i = 0; i < M; i++) {\n            from[i] = scanner.nextInt();\n            to[i] = scanner.nextInt();\n            graph.get(from[i]).add(to[i]);\n            reversedGraph.get(to[i]).add(from[i]);\n        }\n\n        originalSCC = countSCC();\n\n        for (int i = 0; i < M; i++) {\n            graph.get(from[i]).remove((Integer) to[i]);\n            graph.get(to[i]).add(from[i]);\n            reversedGraph.get(from[i]).add(to[i]);\n            reversedGraph.get(to[i]).remove((Integer) from[i]);\n\n            newSCC = countSCC();\n\n            System.out.println(originalSCC == newSCC ? \"same\" : \"diff\");\n\n            graph.get(to[i]).remove((Integer) from[i]);\n            graph.get(from[i]).add(to[i]);\n            reversedGraph.get(to[i]).add(from[i]);\n            reversedGraph.get(from[i]).remove((Integer) to[i]);\n        }\n    }\n\n    private static int countSCC() {\n        visited = new boolean[graph.size()];\n        stack = new Stack<>();\n        for (int i = 1; i < graph.size(); i++) {\n            if (!visited[i]) {\n                dfs(i);\n            }\n        }\n\n        Arrays.fill(visited, false);\n        int scc = 0;\n        while (!stack.isEmpty()) {\n            int node = stack.pop();\n            if (!visited[node]) {\n                reverseDfs(node);\n                scc++;\n            }\n        }\n\n        return scc;\n    }\n\n    private static void dfs(int node) {\n        visited[node] = true;\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n        stack.push(node);\n    }\n\n    private static void reverseDfs(int node) {\n        visited[node] = true;\n        for (int neighbor : reversedGraph.get(node)) {\n            if (!visited[neighbor]) {\n                reverseDfs(neighbor);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:10:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<vector<int>> graph, rev_graph;\n    vector<bool> visited;\n    stack<int> order;\n    \n    void dfs1(int v) {\n        visited[v] = true;\n        for (int u : graph[v]) {\n            if (!visited[u]) {\n                dfs1(u);\n            }\n        }\n        order.push(v);\n    }\n    \n    void dfs2(int v) {\n        visited[v] = true;\n        for (int u : rev_graph[v]) {\n            if (!visited[u]) {\n                dfs2(u);\n            }\n        }\n    }\n    \n    int countSCC(int N) {\n        visited.assign(N + 1, false);\n        \n        // First DFS to get order\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                dfs1(i);\n            }\n        }\n        \n        // Second DFS to count SCCs\n        visited.assign(N + 1, false);\n        int scc_count = 0;\n        \n        while (!order.empty()) {\n            int v = order.top();\n            order.pop();\n            \n            if (!visited[v]) {\n                dfs2(v);\n                scc_count++;\n            }\n        }\n        \n        return scc_count;\n    }\n    \npublic:\n    void solve() {\n        int N, M;\n        cin >> N >> M;\n        \n        graph.resize(N + 1);\n        rev_graph.resize(N + 1);\n        \n        vector<pair<int, int>> edges(M);\n        \n        for (int i = 0; i < M; i++) {\n            int a, b;\n            cin >> a >> b;\n            graph[a].push_back(b);\n            rev_graph[b].push_back(a);\n            edges[i] = {a, b};\n        }\n        \n        int original_scc = countSCC(N);\n        \n        for (auto& [a, b] : edges) {\n            // Remove original edge\n            graph[a].erase(find(graph[a].begin(), graph[a].end(), b));\n            rev_graph[b].erase(find(rev_graph[b].begin(), rev_graph[b].end(), a));\n            \n            // Add reversed edge\n            graph[b].push_back(a);\n            rev_graph[a].push_back(b);\n            \n            // Check SCC count\n            int new_scc = countSCC(N);\n            \n            // If SCC count changes, print 'diff'\n            if (new_scc != original_scc) {\n                cout << \"diff\" << endl;\n            } else {\n                cout << \"same\" << endl;\n            }\n            \n            // Restore original graph\n            graph[b].pop_back();\n            rev_graph[a].pop_back();\n            graph[a].push_back(b);\n            rev_graph[b].push_back(a);\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    solution.solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef find_scc(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n\n    index = [0] * (n + 1)\n    lowlink = [0] * (n + 1)\n    on_stack = [False] * (n + 1)\n    stack = []\n    scc_count = 0\n    idx = [0]  # Use list to allow modification within function\n\n    def strongconnect(v):\n        nonlocal scc_count\n        index[v] = idx[0]\n        lowlink[v] = idx[0]\n        idx[0] += 1\n        stack.append(v)\n        on_stack[v] = True\n\n        for w in graph[v]:\n            if not index[w]:\n                strongconnect(w)\n                lowlink[v] = min(lowlink[v], lowlink[w])\n            elif on_stack[w]:\n                lowlink[v] = min(lowlink[v], index[w])\n\n        if lowlink[v] == index[v]:\n            scc_count += 1\n            while True:\n                w = stack.pop()\n                on_stack[w] = False\n                if w == v:\n                    break\n\n    for v in range(1, n + 1):\n        if not index[v]:\n            strongconnect(v)\n\n    return scc_count\n\ndef change_scc(n, edges):\n    initial_scc = find_scc(n, edges)\n\n    for i, (u, v) in enumerate(edges):\n        new_edges = edges[:i] + edges[i+1:] + [(v, u)]\n        new_scc = find_scc(n, new_edges)\n\n        if new_scc != initial_scc:\n            print(\"diff\")\n        else:\n            print(\"same\")\n\n# Example usage\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nchange_scc(n, edges)",
    "timestamp": "2025-08-13 13:49:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class StronglyConnectedComponents {\n\n    static List<List<Integer>> graph;\n    static List<List<Integer>> reverseGraph;\n    static boolean[] visited;\n    static Stack<Integer> finishStack;\n    static int[] sccId;\n    static int sccCount;\n\n    public static String[] determineEdgeReversionEffect(int N, int M, int[] a, int[] b) {\n        graph = new ArrayList<>();\n        reverseGraph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n            reverseGraph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            graph.get(a[i]).add(b[i]);\n            reverseGraph.get(b[i]).add(a[i]);\n        }\n\n        // Find SCC in the original graph\n        int originalSCCCount = findSCCs(N);\n\n        String[] result = new String[M];\n        for (int i = 0; i < M; i++) {\n            graph.get(a[i]).remove(Integer.valueOf(b[i]));\n            graph.get(b[i]).add(a[i]);\n\n            int newSCCCount = findSCCs(N);\n\n            graph.get(b[i]).remove(Integer.valueOf(a[i]));\n            graph.get(a[i]).add(b[i]);\n\n            result[i] = (newSCCCount != originalSCCCount) ? \"diff\" : \"same\";\n        }\n\n        return result;\n    }\n\n    private static int findSCCs(int N) {\n        visited = new boolean[N + 1];\n        finishStack = new Stack<>();\n        sccId = new int[N + 1];\n        Arrays.fill(sccId, -1);\n        sccCount = 0;\n\n        // First phase of Kosaraju's algorithm\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                dfs1(i);\n            }\n        }\n\n        visited = new boolean[N + 1];\n\n        // Second phase of Kosaraju's algorithm\n        while (!finishStack.isEmpty()) {\n            int v = finishStack.pop();\n            if (!visited[v]) {\n                dfs2(v);\n                sccCount++;\n            }\n        }\n\n        return sccCount;\n    }\n\n    private static void dfs1(int vertex) {\n        visited[vertex] = true;\n        for (int neighbor : graph.get(vertex)) {\n            if (!visited[neighbor]) {\n                dfs1(neighbor);\n            }\n        }\n        finishStack.push(vertex);\n    }\n\n    private static void dfs2(int vertex) {\n        visited[vertex] = true;\n        sccId[vertex] = sccCount;\n        for (int neighbor : reverseGraph.get(vertex)) {\n            if (!visited[neighbor]) {\n                dfs2(neighbor);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int N = 4;\n        int M = 5;\n        int[] a = {1, 2, 3, 3, 4};\n        int[] b = {2, 3, 1, 4, 3};\n\n        String[] result = determineEdgeReversionEffect(N, M, a, b);\n        for (String res : result) {\n            System.out.println(res);\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:49:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 10005\n#define MAXM 100005\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nint N, M;\nint head[MAXN], head_rev[MAXN], head_temp[MAXN];\nEdge edges[MAXM], edges_rev[MAXM];\nint order[MAXN], component[MAXN], visited[MAXN];\nint order_idx, num_scc;\n\nvoid addEdge(int *head, Edge *edges, int u, int v, int *edge_count) {\n    edges[*edge_count] = (Edge){v, head[u]};\n    head[u] = (*edge_count)++;\n}\n\nvoid dfs1(int u) {\n    visited[u] = 1;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (!visited[v]) dfs1(v);\n    }\n    order[order_idx++] = u;\n}\n\nvoid dfs2(int u) {\n    visited[u] = 1;\n    component[u] = num_scc;\n    for (int i = head_rev[u]; i != -1; i = edges_rev[i].next) {\n        int v = edges_rev[i].to;\n        if (!visited[v]) dfs2(v);\n    }\n}\n\nvoid find_scc(int *head_src, Edge *edges_src) {\n    memset(visited, 0, sizeof(visited));\n    order_idx = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (!visited[i]) dfs1(i);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    num_scc = 0;\n    for (int i = order_idx - 1; i >= 0; --i) {\n        int u = order[i];\n        if (!visited[u]) {\n            dfs2(u);\n            num_scc++;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    memset(head, -1, sizeof(head));\n    memset(head_rev, -1, sizeof(head_rev));\n\n    int edge_count = 0;\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(head, edges, u, v, &edge_count);\n        addEdge(head_rev, edges_rev, v, u, &edge_count);\n    }\n    \n    find_scc(head, edges);\n    int original_scc = num_scc;\n    \n    for (int i = 0; i < M; ++i) {\n        int u = edges[i].to, v = edges[i ^ 1].to;\n        int new_edge = i ^ 1;\n        \n        int temp_edge_count = edge_count;\n        memcpy(head_temp, head, sizeof(head));\n        memcpy(edges + temp_edge_count, edges, sizeof(Edge) * edge_count);\n        \n        for (int j = head[v]; j != -1; j = edges[j].next) {\n            if (edges[j].to == u) {\n                temp_edge_count--;\n                head_temp[v] = edges[j].next;\n                break;\n            }\n            if ((j ^ 1) == new_edge) {\n                temp_edge_count--;\n                head_temp[v] = edges[j].next;\n                break;\n            }\n        }\n        \n        addEdge(head_temp, edges + temp_edge_count, u, v, &temp_edge_count);\n        \n        memcpy(head_rev, head_temp, sizeof(head_temp));\n        for (int j = 0; j < temp_edge_count; ++j) {\n            edges_rev[j] = (Edge){edges[j].to, head_rev[edges[j ^ 1].to]};\n            head_rev[edges[j ^ 1].to] = j;\n        }\n        \n        find_scc(head_temp, edges);\n        \n        if (num_scc != original_scc) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:49:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const findSCCs = (n, edges) => {\n    const adj = Array.from({ length: n }, () => []);\n    const radj = Array.from({ length: n }, () => []);\n    \n    edges.forEach(([u, v]) => {\n        adj[u - 1].push(v - 1);\n        radj[v - 1].push(u - 1);\n    });\n\n    const order = [];\n    const visited = Array(n).fill(false);\n\n    const dfs1 = (v) => {\n        visited[v] = true;\n        adj[v].forEach((u) => {\n            if (!visited[u]) dfs1(u);\n        });\n        order.push(v);\n    };\n\n    const dfs2 = (v, component) => {\n        visited[v] = true;\n        component.push(v);\n        radj[v].forEach((u) => {\n            if (!visited[u]) dfs2(u, component);\n        });\n    };\n\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) dfs1(i);\n    }\n\n    visited.fill(false);\n    const sccs = [];\n    for (let i = order.length - 1; i >= 0; i--) {\n        if (!visited[order[i]]) {\n            const component = [];\n            dfs2(order[i], component);\n            sccs.push(component);\n        }\n    }\n\n    return sccs;\n};\n\nconst reverseEdgeChangesSCCCount = (n, originalEdges) => {\n    const originalSCCs = findSCCs(n, originalEdges).length;\n    const results = [];\n\n    originalEdges.forEach(([a, b]) => {\n        const edgesWithoutCurrent = originalEdges.filter(edge => !(edge[0] === a && edge[1] === b));\n        edgesWithoutCurrent.push([b, a]);\n\n        const newSCCs = findSCCs(n, edgesWithoutCurrent).length;\n        if (newSCCs !== originalSCCs) {\n            results.push('diff');\n        } else {\n            results.push('same');\n        }\n    });\n\n    return results;\n};\n\n// Sample usage\nconst N = 5, M = 5;\nconst edges = [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n    [4, 5],\n    [5, 1]\n];\nconsole.log(reverseEdgeChangesSCCCount(N, edges)); // Output: ['same', 'same', 'same', 'same', 'same']",
    "timestamp": "2025-08-13 13:50:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef dfs(graph, node, visited, stack):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(graph, neighbor, visited, stack)\n    stack.append(node)\n\ndef transpose_graph(graph, n):\n    transposed = defaultdict(list)\n    for node in range(1, n+1):\n        for neighbor in graph[node]:\n            transposed[neighbor].append(node)\n    return transposed\n\ndef count_scc(graph, n):\n    visited = [False] * (n+1)\n    stack = []\n    \n    for node in range(1, n+1):\n        if not visited[node]:\n            dfs(graph, node, visited, stack)\n    \n    transposed = transpose_graph(graph, n)\n    visited = [False] * (n+1)\n    scc_count = 0\n    \n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            dfs_scc = []\n            dfs(transposed, node, visited, dfs_scc)\n            scc_count += 1\n    \n    return scc_count\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    edges = []\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        edges.append((a, b))\n    \n    original_scc = count_scc(graph, n)\n    \n    for a, b in edges:\n        graph[a].remove(b)\n        graph[b].append(a)\n        \n        new_scc = count_scc(graph, n)\n        \n        if new_scc != original_scc:\n            print(\"diff\")\n        else:\n            print(\"same\")\n        \n        graph[b].remove(a)\n        graph[a].append(b)\n\nsolve()",
    "timestamp": "2025-08-13 13:50:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findSCCs(graph) {\n    const n = graph.length;\n    const disc = new Array(n).fill(-1);\n    const low = new Array(n).fill(-1);\n    const stackMember = new Array(n).fill(false);\n    const st = [];\n    let time = 0;\n    let sccCount = 0;\n\n    function tarjan(u) {\n        disc[u] = low[u] = time++;\n        stackMember[u] = true;\n        st.push(u);\n\n        for (const v of graph[u]) {\n            if (disc[v] === -1) {\n                tarjan(v);\n                low[u] = Math.min(low[u], low[v]);\n            } else if (stackMember[v]) {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n\n        if (low[u] === disc[u]) {\n            sccCount++;\n            while (true) {\n                const v = st.pop();\n                stackMember[v] = false;\n                if (v === u) break;\n            }\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (disc[i] === -1) {\n            tarjan(i);\n        }\n    }\n\n    return sccCount;\n}\n\nfunction solve(N, edges) {\n    const graph = Array.from({ length: N }, () => []);\n    const reverseGraph = Array.from({ length: N }, () => []);\n\n    for (const [a, b] of edges) {\n        graph[a - 1].push(b - 1);\n        reverseGraph[b - 1].push(a - 1);\n    }\n\n    const originalSCCs = findSCCs(graph);\n    const result = [];\n\n    for (let i = 0; i < edges.length; i++) {\n        const [a, b] = edges[i];\n        graph[a - 1] = graph[a - 1].filter(v => v !== b - 1);\n        graph[b - 1].push(a - 1);\n\n        const newSCCs = findSCCs(graph);\n        result.push(newSCCs !== originalSCCs ? 'diff' : 'same');\n\n        graph[a - 1].push(b - 1);\n        graph[b - 1] = graph[b - 1].filter(v => v !== a - 1);\n    }\n\n    return result;\n}\n\nfunction main(input) {\n    const lines = input.trim().split('\\n');\n    const [N, M] = lines[0].split(' ').map(Number);\n    const edges = lines.slice(1).map(line => line.split(' ').map(Number));\n\n    const output = solve(N, edges);\n    console.log(output.join('\\n'));\n}",
    "timestamp": "2025-08-13 13:50:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1 << 25)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(N+1)]\n    edges = []\n    for _ in range(M):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        adj[a].append(b)\n        edges.append((a, b))\n    \n    # Kosaraju's algorithm to find SCCs and build the component DAG\n    order = []\n    visited = [False]*(N+1)\n    \n    for u in range(1, N+1):\n        if not visited[u]:\n            stack = [(u, False)]\n            while stack:\n                node, processed = stack.pop()\n                if processed:\n                    order.append(node)\n                    continue\n                if visited[node]:\n                    continue\n                visited[node] = True\n                stack.append((node, True))\n                for v in adj[node]:\n                    if not visited[v]:\n                        stack.append((v, False))\n    \n    # Reverse the graph\n    adj_rev = [[] for _ in range(N+1)]\n    for a, b in edges:\n        adj_rev[b].append(a)\n    \n    component = [0]*(N+1)\n    current_component = 0\n    visited = [False]*(N+1)\n    \n    for u in reversed(order):\n        if not visited[u]:\n            stack = [u]\n            visited[u] = True\n            current_component += 1\n            while stack:\n                node = stack.pop()\n                component[node] = current_component\n                for v in adj_rev[node]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n    \n    total_scc = current_component\n    \n    # Build the component DAG\n    component_edges = set()\n    component_adj = [[] for _ in range(current_component + 1)]\n    component_indeg = [0]*(current_component + 1)\n    component_outdeg = [0]*(current_component + 1)\n    \n    for a, b in edges:\n        ca = component[a]\n        cb = component[b]\n        if ca != cb:\n            if (ca, cb) not in component_edges:\n                component_edges.add((ca, cb))\n                component_adj[ca].append(cb)\n                component_indeg[cb] += 1\n                component_outdeg[ca] += 1\n    \n    # For each edge, check if reversing it changes the number of SCCs\n    res = []\n    for a, b in edges:\n        ca = component[a]\n        cb = component[b]\n        if ca == cb:\n            res.append('same')\n        else:\n            # Check if (cb, ca) already exists in component_edges\n            if (cb, ca) in component_edges:\n                res.append('same')\n            else:\n                # Check if ca and cb are in a cycle after reversal\n                # We need to see if there's a path from cb to ca in the original component DAG\n                # Perform a BFS from cb to see if ca is reachable\n                found = False\n                q = [cb]\n                visited_bfs = [False]*(current_component + 1)\n                visited_bfs[cb] = True\n                while q and not found:\n                    u = q.pop(0)\n                    for v in component_adj[u]:\n                        if v == ca:\n                            found = True\n                            break\n                        if not visited_bfs[v]:\n                            visited_bfs[v] = True\n                            q.append(v)\n                    if found:\n                        break\n                if found:\n                    res.append('same')\n                else:\n                    res.append('diff')\n    \n    print('\\n'.join(res))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 13:50:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n\nclass Kosaraju {\n    constructor(n) {\n        this.n = n;\n        this.graph = Array.from({ length: n + 1 }, () => []);\n        this.revGraph = Array.from({ length: n + 1 }, () => []);\n        this.visited = new Array(n + 1).fill(false);\n        this.order = [];\n        this.component = new Array(n + 1).fill(0);\n        this.sccCount = 0;\n    }\n\n    addEdge(u, v) {\n        this.graph[u].push(v);\n        this.revGraph[v].push(u);\n    }\n\n    dfs1(u) {\n        this.visited[u] = true;\n        for (const v of this.graph[u]) {\n            if (!this.visited[v]) {\n                this.dfs1(v);\n            }\n        }\n        this.order.push(u);\n    }\n\n    dfs2(u, id) {\n        this.visited[u] = true;\n        this.component[u] = id;\n        for (const v of this.revGraph[u]) {\n            if (!this.visited[v]) {\n                this.dfs2(v, id);\n            }\n        }\n    }\n\n    computeSCC() {\n        this.visited.fill(false);\n        this.order = [];\n        for (let u = 1; u <= this.n; u++) {\n            if (!this.visited[u]) {\n                this.dfs1(u);\n            }\n        }\n        this.visited.fill(false);\n        this.sccCount = 0;\n        for (let i = this.order.length - 1; i >= 0; i--) {\n            const u = this.order[i];\n            if (!this.visited[u]) {\n                this.dfs2(u, ++this.sccCount);\n            }\n        }\n        return this.sccCount;\n    }\n}\n\nfunction main() {\n    const [n, m] = input[0].split(' ').map(Number);\n    const edges = [];\n    const kosaraju = new Kosaraju(n);\n\n    for (let i = 1; i <= m; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        edges.push([a, b]);\n        kosaraju.addEdge(a, b);\n    }\n\n    const originalSCC = kosaraju.computeSCC();\n    const component = [...kosaraju.component];\n    const sccCount = originalSCC;\n    const result = [];\n\n    for (const [a, b] of edges) {\n        if (component[a] !== component[b]) {\n            result.push('same');\n        } else {\n            const tempKosaraju = new Kosaraju(n);\n            for (const [u, v] of edges) {\n                if (u === a && v === b) {\n                    tempKosaraju.addEdge(v, u);\n                } else {\n                    tempKosaraju.addEdge(u, v);\n                }\n            }\n            const newSCC = tempKosaraju.computeSCC();\n            if (newSCC === originalSCC) {\n                result.push('same');\n            } else {\n                result.push('diff');\n            }\n        }\n    }\n\n    console.log(result.join('\\n'));\n}\n\nmain();",
    "timestamp": "2025-08-13 13:51:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvoid tarjanSCC(int u, const vector<vector<int>>& adj, vector<int>& ids, vector<int>& low,\n               vector<bool>& onStack, stack<int>& stk, int& id, vector<int>& scc) {\n    ids[u] = low[u] = id++;\n    stk.push(u);\n    onStack[u] = true;\n\n    for (int v : adj[u]) {\n        if (ids[v] == -1) {\n            tarjanSCC(v, adj, ids, low, onStack, stk, id, scc);\n            low[u] = min(low[u], low[v]);\n        } else if (onStack[v]) {\n            low[u] = min(low[u], ids[v]);\n        }\n    }\n\n    if (low[u] == ids[u]) {\n        while (!stk.empty()) {\n            int v = stk.top();\n            stk.pop();\n            onStack[v] = false;\n            scc[v] = u;\n            if (v == u) break;\n        }\n    }\n}\n\nint countSCCs(int n, const vector<vector<int>>& adj, vector<int>& scc) {\n    vector<int> ids(n, -1), low(n, 0);\n    vector<bool> onStack(n, false);\n    stack<int> stk;\n    int id = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (ids[i] == -1) {\n            tarjanSCC(i, adj, ids, low, onStack, stk, id, scc);\n        }\n    }\n\n    int sccCount = 0;\n    for (int i = 0; i < n; ++i) {\n        if (scc[i] == i) {\n            ++sccCount;\n        }\n    }\n    return sccCount;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> edges(m);\n    vector<vector<int>> adj(n);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        edges[i] = {a, b};\n        adj[a].push_back(b);\n    }\n\n    vector<int> initialSCC(n);\n    int initialSccCount = countSCCs(n, adj, initialSCC);\n\n    for (auto& edge : edges) {\n        int a = edge.first, b = edge.second;\n        adj[a].erase(find(adj[a].begin(), adj[a].end(), b));\n        adj[b].push_back(a);\n\n        vector<int> newSCC(n);\n        int newSccCount = countSCCs(n, adj, newSCC);\n\n        if (newSccCount != initialSccCount) {\n            cout << \"diff\" << endl;\n        } else {\n            cout << \"same\" << endl;\n        }\n\n        adj[b].pop_back();\n        adj[a].push_back(b);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:41:04"
  }
]