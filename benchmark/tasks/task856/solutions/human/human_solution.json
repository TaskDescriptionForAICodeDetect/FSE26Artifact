[
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\n#define fi first\n#define se second\n#define pb push_back\n#define MP std::make_pair\n#define PII std::pair<int, int>\n#define all(x) (x).begin(), (x).end()\n#define CL(a, b) memset(a, b, sizeof a)\n#define rep(i, l, r) for (int i = (l); i <= (r); ++ i)\n#define per(i, r, l) for (int i = (r); i >= (l); -- i)\n#define PE(x, a) for (int x = head[a]; x;x = edge[x].next)\n\ntypedef long long ll;\n\nconst int MAXN = 1e3 + 7;\nconst int MAXM = 2e5 + 7;\n\nint n, m;\nstd::vector<PII> E[MAXN];\nint fr[MAXM], to[MAXM], col[MAXN][MAXN][2], vis[MAXN], ts;\n\nvoid dfs(int u, int root, int c, int type) {\n\tvis[u] = ts, col[root][u][type] = c;\n\tfor (auto v: E[u]) if (vis[v.fi] != ts) dfs(v.fi, root, c, type);\n}\n\nvoid solve(int u) {\n\tvis[u] = ++ts;\n\tfor (auto v: E[u]) if (vis[v.fi] != ts) dfs(v.fi, u, v.se, 0);\n\tstd::reverse(all(E[u]));\n\tvis[u] = ++ts;\n\tfor (auto v: E[u]) if (vis[v.fi] != ts) dfs(v.fi, u, v.se, 1);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\trep(i, 1, m) scanf(\"%d %d\", fr + i, to + i), E[fr[i]].pb(MP(to[i], i));\n\trep(i, 1, n) solve(i);\n\trep(i, 1, m) {\n\t\tif ((col[to[i]][fr[i]][0] != 0) == (col[fr[i]][to[i]][0] != i || col[fr[i]][to[i]][1] != i)) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define OK puts(\"OK\");\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int inf = (int)1e9 + 7;\nconst int N = (int)2e5 + 7;\n\nint n,m;\nint x,y;\nint u[N],comp[N];\nint sz;\n\nvector <int> g[N],rg[N];\nvector <pair<int,int> > e;\nvector <int> t;\nmap<pair<int,int>,int> ans;\n\nvoid SCC (int v) {\n    u[v] = 1;\n\n    for (auto to : g[v])\n        if (!u[to])\n            SCC(to);\n    t.pb(v);\n}\nvoid RSCC (int v) {\n    comp[v] = sz;\n    u[v] = 1;\n    for (auto to : rg[v])\n        if (!u[to])\n            RSCC(to);\n}\nvoid dfs (int v) {\n    u[v] = 1;\n    for (auto to : g[v])\n        if (!u[to])\n            dfs(to);\n}\n\nmain () {\n    cin >> n >> m;\n\n    for (int i = 1; i <= m; i ++) {\n        cin >> x >> y;\n        e.pb({x,y});\n        g[x].pb(y);\n        rg[y].pb(x);\n    }\n    for (int i = 1; i <= n; i ++)\n        if (!u[i])\n            SCC(i);\n\n    reverse (t.begin(),t.end());\n    memset(u,0,sizeof(u));\n\n    for (auto to : t)\n        if (!u[to]) {\n            sz ++;\n            RSCC(to);\n        }\n\n    for (int v = 1; v <= n; v ++) {\n        for (int i = 1; i <= n; i ++)\n            u[i] = 0;\n        u[v] = 1;\n        for (auto to : g[v]) {\n            if (u[to])\n                ans[{v,to}] = 1;\n            dfs(to);\n        }\n\n        for (int i = 1; i <= n; i ++)\n            u[i] = 0;\n\n        reverse(g[v].begin(),g[v].end());\n\n        u[v] = 1;\n\n        for (auto to : g[v]) {\n            if (u[to])\n                ans[{v,to}] = 1;\n            dfs(to);\n        }\n    }\n    for (auto c : e) {\n        if (comp[c.fr] != comp[c.sc]) ans[{c.fr,c.sc}] ^= 1;\n        if (ans[{c.fr,c.sc}])\n            puts(\"same\");\n        else\n            puts(\"diff\");\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tll f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1000+10,maxm=2000000+10;\nvector<int> G[maxn];\nstruct point{\n\tint x,y;\n}a[maxm];\nint d[maxn][maxn],vis[maxn];\nvoid dfs(int s,int x,int u){\n\tif(s==x || d[s][x]>=2 || vis[x]==u) return;\n\td[s][x]++;\n\tif(d[s][x]==1) vis[x]=u;\n\tREP(i,0,G[x].size()-1) dfs(s,G[x][i],u);\n}\nint main(){\n\tint n=read(),m=read();\n\tREP(i,1,m){\n\t\ta[i].x=read(),a[i].y=read();\n\t\tG[a[i].x].push_back(a[i].y);\n\t}\n\tREP(i,1,n){\n\t\tmemset(vis,-1,sizeof(vis));\n\t\tREP(j,0,G[i].size()-1) dfs(i,G[i][j],G[i][j]);\n\t}\n\tREP(i,1,m)\n\t\tif((d[a[i].x][a[i].y]>=2)^(d[a[i].y][a[i].x]>=1)) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*==============================\n * Authot : ylsoi\n * Time : 2018.3.20\n * Problem : ARC92F\n * File : ARC92F.cpp\n * Algorithm : Strange Algorithm\n * ===========================*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid File(){\n\tfreopen(\"ARC92F.in\",\"r\",stdin);\n\tfreopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define MREP(i,x) for(register int i=beg[x];i;i=E[i].last)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nint n,m,beg[maxn],len;\nbool can[maxn][maxn],can1[maxn][maxn],vis[maxn];\nstruct edge{\n\tint from;\n\tint to;\n\tint last;\n}E[maxm];\nvoid add(int u,int v){\n\t++len;\n\tE[len].from=u;\n\tE[len].to=v;\n\tE[len].last=beg[u];\n\tbeg[u]=len;\n}\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tMREP(i,u){\n\t\tint v=E[i].to;\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nbool flag;\nvoid dfs1(int u,int e,int rt){\n\tvis[u]=1;\n\tMREP(i,u){\n\t\tif(flag)return;\n\t\tint v=E[i].to;\n\t\tif(i==e)continue;\n\t\tif(v==E[e].to){\n\t\t\tcan1[rt][v]=1;\n\t\t\tflag=1;\n\t\t}\n\t\tif(vis[v])continue;\n\t\tdfs1(v,e,rt);\n\t}\n}\nint main(){\n\t//File();\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t}\n\tREP(i,1,n)dfs(i,i),mem(vis);\n\tREP(i,1,m){\n\t\tdfs1(E[i].from,i,E[i].from);\n\t\tmem(vis);\n\t\tflag=0;\n\t}\n\tREP(i,1,m){\n\t\tint u=E[i].from,v=E[i].to;\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tcout<<\"same\"<<endl;\n\t\telse cout<<\"diff\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <vector>\n#include <queue>\n#define PB push_back\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1010,M=1003;\nvector<int> G[N];\nint n,m;\nint vis[N][2],cur,tg;\nvoid dfs(int u) {\n\tif(vis[u][cur]) return;\n\tvis[u][cur]=tg;\n\tfor(int i=0;i<G[u].size();++i) dfs(G[u][i]);\n}\nint p1[N][N],p2[N][N],mp[N][N];\nvoid sol(int s) {\n\tfor(int i=1;i<=n;++i) vis[i][0]=vis[i][1]=i==s;\n\tcur=0; for(int i=1;i<=n;++i) if(mp[s][i]) tg=i,dfs(i);\n\tcur=1; for(int i=n;i>=1;--i) if(mp[s][i]) tg=i,dfs(i);\n\tfor(int i=1;i<=n;++i) if(s!=i) {\n\t\tp1[s][i]=vis[i][0]||vis[i][1];\n\t\tp2[s][i]=p1[s][i]&&(vis[i][0]!=i||vis[i][1]!=i);\n\t}\n}\nvector<PII> E;\nint main() {\n\trd(n),rd(m);\n\tfor(int i=1,x,y;i<=m;++i) rd(x),rd(y),G[x].PB(y),mp[x][y]=1,E.PB(MP(x,y));\n\tfor(int i=1;i<=n;++i) sol(i);\n\tfor(int i=0;i<E.size();++i) { \n\t\tint x=E[i].fir,y=E[i].sec,flg;\n\t\tif(p1[y][x]) flg=(p2[x][y]==1);\n\t\telse flg=(p2[x][y]==0);\n\t\tif(flg) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\n#define fir first\n#define sec second\n#define rep(i,a,b) for (int i = (a) ; i <= (b) ; ++ i)\n#define rrp(i,a,b) for (int i = (a) ; i >= (b) ; -- i)\n#define gc() getchar()\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc() ; !isdigit(tmp) ; tmp = gc())\n    key = (tmp == '-');\n  for ( ; isdigit(tmp) ; tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 1010, M = 200010;\nint n, m;\npii edg[M];\nstruct edge {\n  int la,b;\n} con[M];\nint tot, fir[N];\nvoid add_edge(int from,int to) {\n  con[++tot] = (edge) {fir[from], to};\n  fir[from] = tot;\n}\nint sta[N], dfn[N], low[N], top, bcnt, col[N];\nvoid dfs(int pos) {\n  sta[dfn[pos] = low[pos] = ++ top] = pos;\n  for (int i = fir[pos]; i; i = con[i].la) {\n    if (col[con[i].b]) continue;\n    if (!dfn[con[i].b]) dfs(con[i].b);\n    low[pos] = min(low[pos], low[con[i].b]);\n  }\n  if (low[pos] >= dfn[pos]) {\n    ++ bcnt;\n    while (top >= dfn[pos])\n      col[sta[top --]] = bcnt;\n  }\n}\nint ava[M], rec[N], rt;\nvoid fsd(int pos) {\n  for (int i = fir[pos]; i; i = con[i].la) {\n    if (con[i].b == rt || rec[con[i].b] > 0)\n      continue;\n    rec[con[i].b] = 1;\n    fsd(con[i].b);\n  }\n}\nvoid doit(int cur) {\n  rt = cur;\n  memset(rec, 0, sizeof rec);\n  vector<int> tmp;\n  for (int i = fir[cur]; i; i = con[i].la) {\n    if (rec[con[i].b] == 0) {\n      rec[con[i].b] = 1;\n      fsd(con[i].b);\n    } else ava[i] = 1;\n    tmp.push_back(i);\n  }\n  memset(rec, 0, sizeof rec);\n  reverse(tmp.begin(), tmp.end());\n  for (int j = 0; j < (int)tmp.size(); ++ j) {\n    int i = tmp[j];\n    if (rec[con[i].b] == 0) {\n      rec[con[i].b] = 1;\n      fsd(con[i].b);\n    } else ava[i] = 1;\n  }\n}\nbool check(int a,int b) {\n  return ((a ^ b) == 0) ? 0 : 1;\n}\nint main() {\n  int x,y;\n  read(n), read(m);\n  rep (i, 1, m) {\n    read(x), read(y);\n    edg[i] = pii(x, y);\n    add_edge(x, y);\n  }\n  rep (i, 1, n) if (!dfn[i]) dfs(i);\n  rep (i, 1, n) doit(i);\n  rep (i, 1, m)\n    printf(\"%s\\n\",\n\t   check(ava[i], col[edg[i].fir] == col[edg[i].sec])\n\t   ? \"diff\" : \"same\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200200;\ninline int read(int x=0,bool f=0,char ch=getchar()){\n\tfor(;!isdigit(ch);ch=getchar()) f=ch=='-';\n\tfor(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\nint n,m,tot,fi[N],to[N],u[N],ne[N];\nbool vis[1010][1010];\nint pre[1010][1010],suf[1010][1010];\nvoid bfs(int x){\n\tqueue<int> s; s.push(x); vis[x][x]=true;\n\twhile(!s.empty()){\n\t\tint y=s.front(); s.pop();\n\t\tfor(int i=fi[y];i;i=ne[i]) if(!vis[x][to[i]]) vis[x][to[i]]=true,s.push(to[i]);\n\t}\n}\nvoid dfs1(int x,int id,int k){\n\tpre[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!pre[id][to[i]]) dfs1(to[i],id,k);\n}\nvoid dfs2(int x,int id,int k){\n\tsuf[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!suf[id][to[i]]) dfs2(to[i],id,k);\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;++i) x=read(),y=read(),ne[++tot]=fi[x],u[tot]=x,to[fi[x]=tot]=y;\n\tfor(int i=1;i<=n;++i) bfs(i);\n\tfor(int i=1;i<=n;++i){\n\t\tvector<int> s; int sz=0; pre[i][i]=suf[i][i]=1;\n\t\tfor(int j=fi[i];j;j=ne[j]) s.push_back(to[j]);\n\t\tfor(int j:s){\n\t\t\t++sz;\n\t\t\tif(!pre[i][j]) dfs1(j,i,sz);\n\t\t}\n\t\treverse(s.begin(),s.end());\n\t\tfor(int j:s){\n\t\t\tif(!suf[i][j]) dfs2(j,i,sz);\n\t\t\t--sz;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint x=u[i],y=to[i];\n\t\tif(vis[y][x]^(pre[x][y]!=suf[x][y])) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[2][N],vi[N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(vis[0][rt][v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tmemset(vi,0,sizeof(vi));\n\t\tdfs_vis(i,i);\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid,LL rt){\n\tp[pid][u] = col;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(p[pid][v]) continue;\n\t\tdfs_sol(v,col,pid,rt);\n\t}\n}\n\nvoid solve(LL u){\n\tmemset(p,0,sizeof(p)); p[0][u] = 1; p[1][u] = 1;\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!vi[G[u][i]]) dfs_sol(G[u][i],i + 1,0,u);\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!vi[G[u][i]]) dfs_sol(G[u][i],i + 1,1,u);\n\tfor(LL i = 1;i <= n;i ++) if(vi[i] && p[0][i] != p[1][i]) vis[1][u][i] = 1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(ev[i]);\n\t}\n\tget_vis();\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 1005\n#define M 200005\nusing namespace std;\nstruct Edge{\n\tint to,next,last;\n}edge[M];\nint head[N],tot,first[N];\nvoid addedge(int from,int to){\n\tedge[++tot].to=to;\n\tif(head[from]){\n\t\tedge[head[from]].last=tot;\n\t}else{\n\t\tfirst[from]=tot;\n\t}\n\tedge[tot].next=head[from];\n\thead[from]=tot;\n}\nint p1[N][N];\nvoid dfs1(int now,int p){\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=now;\n\t\tdfs1(v,p);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p){\n\tfor(int i=first[now];i;i=edge[i].last){\n\t\tint v=edge[i].to;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=now;\n\t\tdfs2(v,p);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;++i){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\taddedge(u[i],v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tp1[i][i]=i;\n\t\tdfs1(i,i);\n\t\tp2[i][i]=i;\n\t\tdfs2(i,i);\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1005;\nint n,m,i,x,y,ans[200005],dfn[N],low[N],xb,st[N],w,bel[N],scnt;\nvector<pair<int,int>>e[N],tmp,tmp2;\nbool b[N];\nvoid dfs(int x){\n\tdfn[x]=low[x]=++xb;st[++w]=x;\n\tfor(auto u:e[x])if(!dfn[u.first]){\n\t\tdfs(u.first);low[x]=min(low[x],low[u.first]);\n\t}else if(!bel[u.first])low[x]=min(low[x],low[u.first]);\n\tif(dfn[x]==low[x])for(++scnt;;){\n\t\tbel[st[w]]=scnt;\n\t\tfor(auto u:e[st[w]])if(bel[u.first] && bel[u.first]!=scnt)ans[u.second]=1;\n\t\tif(st[w--]==x)break;\n\t}\n}\nvoid dfs2(int x){b[x]=1;for(auto u:e[x])if(!b[u.first])dfs2(u.first);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=m;++i)cin>>x>>y,e[x].push_back(make_pair(y,i));\n\tfor(i=1;i<=n;++i)if(!dfn[i])dfs(i);\n\tfor(i=1;i<=n;++i){\n\t\tmemset(b+1,0,n);b[i]=1;tmp.clear();tmp2.clear();\n\t\tfor(auto u:e[i])if(!b[u.first])tmp.push_back(u),dfs2(u.first);\n\t\t\telse tmp2.push_back(u);\n\t\tmemset(b+1,0,n);b[i]=1;reverse(tmp.begin(),tmp.end());\n\t\tfor(auto u:tmp2)dfs2(u.first);\n\t\tfor(auto u:tmp)if(!b[u.first])ans[u.second]^=1,dfs2(u.first);\n\t}\n\tfor(i=1;i<=m;++i)cout<<(ans[i]?\"diff\\n\":\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nconst int N = 1e3+3;\n\n\nint cnt[N][N];\npair< int, int > edge[N*200];\nint n, m;\nvector<int> g[N];\n\n#define u first\n#define v second\n\nbool kappa[N][N];\n\nvoid dothething(int root) {\n\tvector< pair<int, int> > lel;\n\tqueue< pair<int, int> > q;\n\tint k = 0;\n\tfor (auto c : g[root]) {\n\t\tk++;\n\t\tq.push({c, k});\n\t\tlel.push_back({c, k});\n\t\tkappa[c][k] = 1;\n\t\tcnt[root][c] = 1;\n\t} \n\twhile (q.empty() == false) {\n\t\tint u = q.front().u;\n\t\tint e = q.front().v; q.pop();\n\t\tfor (auto v : g[u]) {\n\t\t\tif (v == root) continue;\n\t\t\tif (cnt[root][v] == 2) continue;\n\t\t\tif (!kappa[v][e]) {\n\t\t\t\tlel.push_back({v, e});\n\t\t\t\tkappa[v][e] = 1;\n\t\t\t\tcnt[root][v]++;\n\t\t\t\tq.push({v, e});\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : lel) {\n\t\tkappa[i.u][i.v] = 0;\n\t}\n}\n\nsigned main() {\n\tmemset(cnt, 0, sizeof(cnt));\n\tmemset(kappa, 0, sizeof(kappa));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &edge[i].u, &edge[i].v);\n\t\tg[edge[i].u].push_back(edge[i].v);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tdothething(i);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (cnt[edge[i].u][edge[i].v] == 1) {\n\t\t\tif (cnt[edge[i].v][edge[i].u] >= 1) {\n\t\t\t\tcout << \"diff\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"same\\n\";\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\tif (cnt[edge[i].v][edge[i].u] >= 1) {\n\t\t\t\tcout << \"same\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"diff\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//毒瘤!\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\ninline int qread(){\n\tint x=0,sign=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') sign=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*sign;\n}\nint n,m; \nint s[maxm],e[maxm];\nvector<int>E[maxn];\nvoid add_edge(int u,int v){\n\tE[u].push_back(v);\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tint y;\n\tused[x]=1;\n\troute[s][x]++;\n\tint cnt=E[x].size();\n\tfor(int i=0;i<cnt;i++){\n\t\ty=E[x][i];\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nchar a[]=\"same\",b[]=\"diff\";\nvoid qprint(char *s,int len){\n\tfor(int i=0;i<len;i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('\\n');\n}\nint main(){\n//\tscanf(\"%d %d\",&n,&m);\n\tn=qread();\n\tm=qread(); \n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n//\t\tscanf(\"%d %d\",&u,&v);\n\t\ts[i]=qread();\n\t\te[i]=qread();\n\t\tadd_edge(s[i],e[i]);\n\t}\n\tint y;\n\tfor(int i=1;i<=n;i++){\n\t\tint cnt=E[i].size();\n\t\tfor(int j=0;j<cnt;j++){\n\t\t\ty=E[i][j];\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(s[i],e[i]) )qprint(b,4);\n\t\telse qprint(a,4);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n   int x=0,f=1;char ch=getchar();\n   while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n   while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n   return x*f;\n}\nconst int N=1005;\nconst int M=200005; \nvector<int> vec[N];\nint now,x[M],y[M],n,m,vis1[N][N],vis2[N][N];\nvoid dfs1(int x,int fa)\n{\n\tfor (int i=0;i<vec[x].size();i++)\n\t  if (vec[x][i]!=fa)\n\t  \t if (!vis1[now][vec[x][i]]) vis1[now][vec[x][i]]=x,dfs1(vec[x][i],x);\n}\nvoid dfs2(int x,int fa)\n{\n\tfor (int i=vec[x].size()-1;i>=0;i--)\n\t  if (vec[x][i]!=fa)\n\t  \t if (!vis2[now][vec[x][i]]) vis2[now][vec[x][i]]=x,dfs2(vec[x][i],x);\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (int i=1;i<=m;i++) x[i]=read(),y[i]=read(),vec[x[i]].push_back(y[i]);\n\tfor (int i=1;i<=n;i++) \n\t{ \n\t  now=i;vis1[now][now]=vis2[now][now]=1;//注意把起点的vis标记！ \n\t  dfs1(i,-1);\n\t  dfs2(i,-1);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tputs(((vis1[y[i]][x[i]]!=0)^(vis1[x[i]][y[i]]!=x[i]||vis2[x[i]][y[i]]!=x[i]))?\"diff\":\"same\");\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint dfn[1010], low[1010], up[1010], dft, bel[1010], blt, st[1010], tp;\nmap<int,int>mp[1010]; int ans[202000];\nvector<int>G[1010]; \n\nvoid tar(int x){\n  dfn[x]=low[x]=++dft;\n  st[++tp]=x;\n  \n  for (auto &y:G[x])\n    if (dfn[y]){\n      if (!bel[y]) low[x]=min(low[x],dfn[y]);\n    }else{\n      tar(y); low[x]=min(low[x],low[y]);\n    }\n  \n  if (dfn[x]==low[x]){\n    ++blt;\n    for (;;){\n      bel[st[tp]]=blt;\n      if (st[tp--]==x) break;\n    }\n  }\n}\n\nvoid dfs(int x,int *vis,int tp){\n  if (vis[x]) return; vis[x]=tp;\n  for (auto &y:G[x]) dfs(y,vis,tp);\n}\n\nvoid doit(int x){\n  memset(up,0,sizeof up); memset(low,0,sizeof low);\n  up[x]=low[x]=x;\n  sort(G[x].begin(),G[x].end());\n  for (auto &y:G[x]) dfs(y,low,y);\n  reverse(G[x].begin(),G[x].end());\n  for (auto &y:G[x]) dfs(y,up,y);\n  for (auto &y:G[x])\n    ans[mp[x][y]]= (bel[x]!=bel[y]) ^ (up[y]==low[y]);\n}\n\nint main(){\n  cin>>n>>m; int x, y;\n  for (int i=1;i<=m;++i){\n    scanf(\"%d%d\",&x,&y);\n    mp[x][y]=i; G[x].push_back(y);\n  }\n  for (int i=1;i<=n;++i) if (!dfn[i]) tar(i);\n  \n  for (int i=1;i<=n;++i) doit(i);\n  for (int i=1;i<=m;++i) puts(ans[i]? \"diff\": \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn;\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(++pn;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(int*h,int x,int z)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])d1(h,e[i].t,z),uu[i>>1]|=z;\n}\nvoid d2(int*h,int x,int d,int xs,int ys)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=d&&!u[e[i].t])d2(h,e[i].t,d,xs,ys);\n\tif(x==xs&&!u[ys])d2(h,ys,d,xs,ys);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tfor(i=1;i<=n;++i)if(!u[i])d1(h,i,1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=n;++i)if(!u[i])d1(r,i,2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(k=c[q[j]];k;k=e[k].nx)if(!g[i][e[k].t]++)q[++qn]=e[k].t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i]&1)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,x[i],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i]&2)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,x[i],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define edge(u) for(re int i=head[u];i;i=e[i].nxt)\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nconst int N=1e3+5;\nconst int M=2e5+5;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nbool vis[N],vis1[N][N],vis2[N][N];\nint n,m,head[N],cnt,a[M],b[M],mark[N];\nstruct edge{\n\tint to,nxt;\n}e[M];\nvoid add(int a,int b){\n\te[++cnt].to=b;\n\te[cnt].nxt=head[a];\n\thead[a]=cnt;\n}\nvoid dfs1(int u,int s){\n\tvis1[s][u]=1;\n\tedge(u){\n\t\tint v=e[i].to;\n\t\tif(!vis1[s][v]) dfs1(v,s);\n\t}\n}\nvoid dfs2(int u,int s,int tp,int c){\n\tif(!tp) mark[u]=c;\n\telse vis2[s][u]=c!=mark[u];\n\tvis[u]=1;\n\tedge(u){\n\t\tint v=e[i].to;\n\t\tif(vis[v]) continue;\n\t\tdfs2(v,s,tp,c);\n\t}\n}\nvector<pair<int,int> > ve;\nint main(){\n\tn=read(),m=read();\n\tinc(i,1,m){\n\t\ta[i]=read(),b[i]=read();\n\t\tadd(a[i],b[i]);\n\t}\n\tinc(i,1,n) dfs1(i,i);\n\tinc(u,1,n){\n\t\tmemset(vis,0,sizeof(vis));vis[u]=1;\n\t\tedge(u){\n\t\t\tint v=e[i].to;\n\t\t\tve.push_back(mp(v,i));\n\t\t\tif(vis[v]) continue;\n\t\t\tdfs2(v,u,0,i);\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));vis[u]=1;\n\t\tfor(re int i=ve.size()-1;i>=0;i--){\n\t\t\tint v=ve[i].fi,c=ve[i].se;\n\t\t\tif(vis[v]) continue;\n\t\t\tdfs2(v,u,1,c);\n\t\t}\n\t\tve.clear();\n\t}\n\tinc(i,1,m) puts(vis1[b[i]][a[i]]^vis2[a[i]][b[i]]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1005,M=200005;\nint n,m,num,X[M],Y[M],cnt[N][N],flag1[N],flag2[N];\nbool vis[N],ok[N][N],ok2[N][N];\nvector<int> e[N];\nvoid dfs(int u,int fa){\n\tvis[u]=1;\n\tok[fa][u]=1;\n\tfor(int i=0;i<e[u].size();i++){\n\t\tint v=e[u][i];\n\t\tif(vis[v])continue;\n\t\tdfs(v,fa);\n\t}\n}\nvoid dfs2(int u){\n\tvis[u]=1;\n\tfor(int i=0;i<e[u].size();i++){\n\t\tint v=e[u][i];\n\t\tif(vis[v])continue;\n\t\tflag1[v]=cnt[u][v];\n\t\tdfs2(v);\n\t} \n}\nvoid dfs3(int u){\n\tvis[u]=1;\n\tfor(int i=e[u].size()-1;i>=0;i--){\n\t\tint v=e[u][i];\n\t\tif(vis[v])continue;\n\t\tflag2[v]=cnt[u][v];\n\t\tdfs3(v);\n\t} \n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].push_back(v);\n\t\tcnt[u][v]=++num;\n\t\tX[num]=u;\n\t\tY[num]=v;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdfs(i,i);\n\t\tmemset(vis,0,sizeof(vis));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdfs2(i);\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs3(i);\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tint v=e[i][j];\n\t\t\tif(flag1[v]!=cnt[i][v]||flag2[v]!=cnt[i][v])ok2[i][v]=1;\n\t\t}\n\t\tmemset(flag1,0,sizeof(flag1));\n\t\tmemset(flag2,0,sizeof(flag2));\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif((ok[Y[i]][X[i]]^ok2[X[i]][Y[i]])==0)puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000 + 5;\nconst int M = 200000 + 5;\n\nint n, m;\nint vis[N], flag;\nvector<pair<int, int>> adj[N];\nint ans[M];\nint minv[N];\n\nvoid dfs(int u, int mark = 1, int forbid = -1)\n{\n    if (u == forbid) return;\n    if (vis[u]) return;\n    vis[u] = mark;\n    for (auto e : adj[u]) {\n        int v = e.first;\n        dfs(v, mark, forbid);\n    }\n}\n\nvoid solve()\n{\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u, --v;\n        adj[u].push_back(make_pair(v, i));\n    }\n\n    for (int i = 0; i < n; i++) {\n        memset(vis, 0, sizeof vis);\n        dfs(i);\n        for (int u = 0; u < n; u++) {\n            if (! vis[u]) continue;\n            for (auto e : adj[u]) {\n                if (e.first != i) continue;\n                ans[e.second] ++;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        memset(vis, 0, sizeof vis);\n        for (auto e : adj[i]) {\n            dfs(e.first, e.second + 1, i);\n        }\n        for (int j = 0; j < n; j++) {\n            minv[j] = vis[j];\n        }\n        memset(vis, 0, sizeof vis);\n        for (auto e = adj[i].rbegin(); e != adj[i].rend(); e++) {\n            dfs(e->first, e->second + 1, i);\n        }\n        for (auto e : adj[i]) {\n            int v = e.first;\n            if (e.second + 1 != minv[v] || e.second + 1 != vis[v]) {\n                ans[e.second] += 2;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        puts(ans[i] == 3 || ans[i] == 0 ? \"same\" : \"diff\");\n        //cout << ans[i] % 2 << ' ' << ans[i] / 2 << endl;\n    }\n\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\nvector<int> gr[1100];\nvector<int> igr[1100];\nvector<int> ban;\n\nint V,e;\nint visit[1100]={0},gro[1100]={0};\n\nvoid dfs(int i){\n\tif(visit[i]==0){\n\t\tvisit[i]=1;\n\t\tfor(int k=0;k<gr[i].size();k++) dfs(gr[i][k]);\n\t\tban.push_back(i);\n\t}\n}\n\nvoid idfs(int i,int h){\n\tif(visit[i]==0){\n\t\tvisit[i]=1;\n\t\tgro[i]=h;\n\t\tfor(int k=0;k<igr[i].size();k++) idfs(igr[i][k],h);\n\t}\n}\n\nvoid kyouren(){\n\tfor(int i=0;i<V;i++){\n\t\tdfs(i);\n\t}\n\tfor(int i=0;i<V;i++) visit[i]=0;\n\tfor(int i=V-1;i>=0;i--){\n\t\tidfs(ban[i],ban[i]);\n\t}\n\n\n}\n\nvector<pa> eda;\nmap<pa,int> ma;\n\n\nvector<pa> naibu[1100];\nint GG[1100][1100]={};\nvector<pa> G[1100];\nvector<pa> H[1100];\nvector<int> G2[1100];\nint owari[1100]={};\nint ans[200020]={};\n// sonomama ->1\n// kawaru ->2\n\n\nint tmp[1100];\nint sumi[1100];\n\nint dfs1(int r,int p){\n\tif(sumi[r])return tmp[r];\n\tsumi[r]=1;\n\tif(r==p){\n\t\ttmp[r]=0;\n\t}\n\telse{\n\t\tint ima=-100;\n\t\tfor(auto v:G2[r])ima=max(ima,dfs1(v,p));\n\t\t\n\t\tima++;\n\t\tif(ima<0) tmp[r]=-100;\n\t\telse tmp[r]=ima;\n\t}\n\treturn tmp[r];\n}\n\nvoid dagdag(int r,int n){\n\tfor(int i=0;i<n;i++)sumi[i]=0;\n\tfor(auto v:G[r]){\n\t\tif(v.second==-1) continue;\n\t//\tcout<<\" \"<<v.first<<\" \"<<r<<\" \"<<dfs1(v.first,r)<<endl;\n\t\tif(dfs1(v.first,r)>1) ans[v.second]=2;\n\t\telse ans[v.second]=1;\n\t}\n}\nvector<int> cho[1010];\n\nvector<int> T[1010];\nvector<int> T2[1010];\n\nint dfs2(int r,int p,int mae){\n\tif(sumi[r])return tmp[r];\n\tsumi[r]=1;\n\tif(r==p){\n\t\ttmp[r]=0;\n\t}\n\telse{\n\t\tint ima=-100;\n\t\tfor(auto v:T2[r])if(v!=mae)ima=max(ima,dfs2(v,p,r));\n\t\t\n\t\tima++;\n\t\tif(ima<0) tmp[r]=-100;\n\t\telse tmp[r]=ima;\n\t}\n\treturn tmp[r];\n}\nint vis[1100];\nvoid ddff(int r){\n\tif(vis[r]) return;\n\tvis[r]=1;\n\tfor(auto v:T[r])if(!vis[v])ddff(v);\n}\n\nvoid uti(int r,int n){\n\tfor(auto v:cho[r]){\n\t\t\n\t\t\n\t\tif(T[v].size()==1){\n\t\t\tans[ma[{v,T[v][0]}]]=2;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tint f=T[v].size();\n\t\t\tvector<int> ve(f,0);\n\t\t\tfor(int i=0;i<n;i++)vis[i]=0;\n\t\t\tvis[v]=1;\n\t\t\tfor(int i=0;i<f;i++){\n\t\t\t\t\n\t\t\t\tif(vis[T[v][i]])ve[i]=1;\n\t\t\t\tddff(T[v][i]);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++)vis[i]=0;\n\t\t\tvis[v]=1;\n\t\t\tfor(int i=f-1;i>=0;i--){\n\t\t\t\tif(vis[T[v][i]])ve[i]=1;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tddff(T[v][i]);\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<f;i++){\n\t\t\t\tif(ve[i]) ans[ma[{v,T[v][i]}]]=1;\n\t\t\t\telse ans[ma[{v,T[v][i]}]]=2;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\nsigned main(){\n\n\t\t\t  cin.tie(0);\n\t\t\tios::sync_with_stdio(false);\nint n,m;\ncin>>n>>m;\n\tV=n;\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\ty--;\n\t\tyy--;\n\t\tma[{y,yy}]=i;\n\t\t\teda.pb({y,yy});\n\t\tgr[y].pb(yy);\n\t\tigr[yy].pb(y);\n\t}\n\tkyouren();\n\tfor(int i=0;i<n;i++)cho[gro[i]].pb(i);\n\tfor(int i=0;i<m;i++){\n\t\tpa v=eda[i];\n\t\tif(gro[v.first]==gro[v.second]){\n\t\t\tnaibu[gro[v.first]].pb(v);\n\t\t\tT[v.first].pb(v.second);\n\t\t\tT2[v.second].pb(v.first);\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tGG[gro[v.first]][gro[v.second]]++;\n\t\t\t\tH[gro[v.first]].pb({gro[v.second],i});\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(auto v:H[i]){\n\t\t\tif(GG[i][v.first]==1){\n\t\t\t\tG[i].pb(v);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans[v.second]=1;\n\t\t\t}\n\t\t}\n\t\tfor(auto v:H[i]){\n\t\t\tif(GG[i][v.first]>1){\n\t\t\t\tG[i].pb(v);\n\t\t\t\tG[i].back().second=-1;\n\t\t\t\tGG[i][v.first]=0;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<n;i++){\n\t\tif((int)G[i].size()>1){\n\t\tfor(auto v:G[i]){\n\t\t\tans[v.second]=1;\n\t\t}\n\t\towari[i]=1;\n\t\twhile(G[i].size()>1)G[i].pop_back();\n\t\t}\n\t\telse if(G[i].size()==0) owari[i]=1;\n\t}\n\t*/\n\t\n\tfor(int i=0;i<n;i++)for(auto v:G[i]){\n\t//\tcout<<i<<\" \"<<v.first<<\" \"<<v.second<<endl;\n\t\tG2[v.first].pb(i);\n\t}\n\tfor(int i=0;i<n;i++)if(!owari[i]){\n\t\tdagdag(i,n);\n\t}\n\t//\tfor(int i=0;i<m;i++)cout<<ans[i]<<endl;\n\n\tfor(int i=0;i<n;i++)if(naibu[i].size()) uti(i,n);\n\t\n\tfor(int i=0;i<m;i++)cout<<(ans[i]==1?\"same\":\"diff\")<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define M 200000\n#define N 1001\nusing namespace std;\nint a[N],b[M],c[M],d[M],e[N][N],f[N][N],m,n;bool x[M];\ninline bool cmp(int u,int v){return b[u]==b[v]?c[u]<c[v]:b[u]<b[v];}\nvoid dfs(int u,int*w){for(int i=a[u-1];i<a[u];i++)if(!w[b[i]])w[b[i]]=w[u],dfs(b[i],w);}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++)scanf(\"%d%d\",b+i,c+i),a[b[d[i]=i]]++;\n\tsort(d,d+m,cmp);\n\tfor(int i=1;i<=n;i++)a[i]+=a[i-1],e[i][i]=f[i][i]=-1;\n\tfor(int i=0;i<m;i++)b[i]=c[d[i]];\n\tfor(int i=0;i<m;i++)c[i]=d[i];\n\tfor(int i=1;i<=n;i++)for(int j=a[i-1];j<a[i];j++)if(!e[i][b[j]])dfs(e[i][b[j]]=b[j],e[i]);\n\tfor(int i=1;i<=n;i++)for(int j=a[i];a[i-1]<j--;)if(!f[i][b[j]])dfs(f[i][b[j]]=b[j],f[i]);\n\tfor(int i=1;i<=n;i++)for(int j=a[i-1];j<a[i];j++)x[c[j]]=(bool)e[b[j]][i]^e[i][b[j]]==f[i][b[j]];\n\tfor(int i=0;i<m;i++)puts(x[i]?\"same\":\"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nstruct edge{\n\tint to, id;\n\tedge *nxt;\n}edges[MAXM + 5], *adj[MAXN + 5], *ecnt = edges;\nvoid addedge(int u, int v, int i) {\n\tedge *p = (++ecnt);\n\tp->to = v, p->id = i, p->nxt = adj[u], adj[u] = p;\n}\n\nint tag[MAXN + 5], que[2*MAXN + 5];\nbool ans1[MAXM + 5], ans2[MAXM + 5];\n\nint n, m;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\taddedge(a, b, i);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) tag[j] = 0;\n\t\tint s = 1, t = 0;\n\t\tfor(edge *p=adj[i];p;p=p->nxt)\n\t\t\ttag[que[++t] = p->to] = p->id;\n\t\twhile( s <= t ) {\n\t\t\tint x = que[s++], y = tag[x];\n\t\t\tfor(edge *p=adj[x];p;p=p->nxt) {\n\t\t\t\tif( p->to == i )\n\t\t\t\t\tans1[p->id] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif( tag[p->to] != -1 ) {\n\t\t\t\t\t\tif( tag[p->to] == 0 )\n\t\t\t\t\t\t\ttag[que[++t] = p->to] = y;\n\t\t\t\t\t\telse if( tag[p->to] != y )\n\t\t\t\t\t\t\ttag[que[++t] = p->to] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(edge *p=adj[i];p;p=p->nxt)\n\t\t\tif( tag[p->to] == -1 ) ans2[p->id] = 1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tputs(ans1[i] ^ ans2[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nbool bz[N],bz1[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1])){\n                bz1[x]|=bz1[y];\n                continue;\n            }\n            if (!F[y][0]){\n                F[y][0]=v;\n                dfs(y,s,v);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y])dfs(y,s,v);\n            }\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\n#define N 600006\nvector<int>v[2002];\nint n,m,a[N][2],id[2002][2002],id1[2002],id2[2002];\nbool vis[2002],to[2002][2002],ao[2002][2002];\nvoid df5(int anc,int te)\n{\n    for(int i=0;i<v[te].size();i++)\n    {\n        int j=v[te][i];to[anc][j]=1;\n        if(!vis[j])\n        {\n            vis[j]=1;df5(anc,j);\n        }\n    }\n}\nvoid dfs(int anc,int te,int wh)\n{\n    for(int i=0;i<v[te].size();i++)\n    {\n        int j=v[te][i];if(te==anc)wh=i+1;\n        if(!vis[j])\n        {\n        if(id1[j]&&id1[j]!=wh)ao[anc][j]=1;id1[j]=wh;\n            vis[j]=1;dfs(anc,j,wh);\n        }\n    }\n}\nvoid dfss(int anc,int te,int wh)\n{\n    for(int i=((int)v[te].size())-1;~i;i--)\n    {\n        int j=v[te][i];if(te==anc)wh=i+1;\n        if(!vis[j])\n        {\n        if(id1[j]&&id1[j]!=wh)ao[anc][j]=1;id1[j]=wh;\n            vis[j]=1;dfss(anc,j,wh);\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        int x,y;scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);a[i][0]=x,a[i][1]=y,id[x][y]=i;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)vis[j]=0;vis[i]=1;\n        df5(i,i);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)vis[j]=id1[j]=id2[j]=0;\n        vis[i]=1;dfs(i,i,0);\n        for(int j=1;j<=n;j++)vis[j]=0;\n        vis[i]=1;dfss(i,i,0);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(to[a[i][1]][a[i][0]]^ao[a[i][0]][a[i][1]])puts(\"diff\");\n        else puts(\"same\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=200005,N=1005;\nint nxt[M],ed[M],ans[M];\nvector<int> v[N];\nint son[N],vis[N],ne,alb[M],lt[N][N];\nvoid ae(int a,int b){\n\tnxt[++ne]=son[a]; son[a]=ne; ed[ne]=b;\n}\nvoid dfs(int p){\n\tvis[p]=1;\n\tfor(auto i:v[p])if(!vis[i])dfs(i);\n}\nint main(){\n\tint n=read(),m=read();\n\tFor(i,1,m){\n\t\tint s=read(),t=read(); \n\t\tae(s,t); v[s].pb(t);\n\t}\n\tFor(i,1,n){\n\t\tmemset(vis,0,sizeof(vis)); \n\t\tvector<int> v; vis[i]=1;\n\t\tfor(int j=son[i];j;j=nxt[j]){\t\t\t\n\t\t\tif(vis[ed[j]]){\n\t\t\t\talb[j]=1; \n\t\t\t}else{\n\t\t\t\tdfs(ed[j]);\n\t\t\t}\n\t\t\tv.pb(j);\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));  vis[i]=1;\n\t\tRep(o,v.size()-1,0){\n\t\t\tint j=v[o];\n\t\t\tif(vis[ed[j]]){\n\t\t\t\talb[j]=1; \n\t\t\t}else{\n\t\t\t\tdfs(ed[j]);\n\t\t\t}\n\t\t}\n\t\tFor(j,1,n)lt[i][j]=vis[j];\n\t}\n\tFor(i,1,n)for(int j=son[i];j;j=nxt[j])ans[j]=alb[j]==lt[ed[j]][i];\n\t//for(int i=son[3];i;i=nxt[i])if(ed[i]==4)cout<<alb[i]<<endl;\n\tFor(i,1,m)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1003,M=200005;\nusing namespace std;\nint n,m,to[M],hd[M],lk[M],\nu,nl[N],nr[N],st[N],t;\nbool mp[N][N],ans[M];\nvoid dfs(int x){\n\tif(mp[u][x])return;\n\tmp[u][x]=1;\n\tfor(int i=lk[x];i;i=hd[i])\n\tdfs(to[i]);\n}\nvoid dfs(int x,int*a){\n\t//cerr<<x<<'('<<u<<'/'<<t<<endl;\n\tif(a[x]||x==u)return;\n\ta[x]=t;\n\tfor(int i=lk[x];i;i=hd[i])\n\tdfs(to[i],a);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,to+i);\n\t\thd[i]=lk[u],lk[u]=i;\n\t}\n\tfor(int i=1;i<=n;i++)dfs(u=i);\n\tfor(int i=1;i<=n;i++){\n\t\tt=0,u=i;\n\t\tfor(int j=1;j<=n;j++)\n\t\tnl[j]=nr[j]=0;\n\t\tfor(int j=lk[i];j;j=hd[j])\n\t\tdfs(to[st[++t]=j],nl);\n\t\tfor(int s;t;t--)\n\t\tdfs(s=to[st[t]],nr),\n\t\t//cerr<<st[t]<<\":\"<<i<<\"->\"<<s<<' '<<mp[s][i]<<','<<nl[s]<<','<<nr[s]<<endl,\n\t\tans[st[t]]=mp[s][i]^(nl[s]<t||nr[s]>t);\n\t}\n\tfor(int i=1;i<=m;i++)\n\tputs(ans[i]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\nusing namespace std;\nconst int N=1e3+5;\nconst int M=2e5+5;\nbitset<N> vis;\nbool vis1[N][N],vis2[N][N];\nint n,m,a[M],b[M],mark[N];\nvector<int> to[N];\ninline void dfs1(int u,int s){\n\tif(vis1[s][u]) return;\n\tvis1[s][u]=1;\n\tfor(re int i=0;i<to[u].size();i++) dfs1(to[u][i],s);\n}\ninline void dfs2(int u,int s,int tp,int c){\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tif(!tp) mark[u]=c;\n\telse vis2[s][u]=(c!=mark[u]);\n\tfor(re int i=0;i<to[u].size();i++) dfs2(to[u][i],s,tp,c);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tinc(i,1,m){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tto[a[i]].push_back(b[i]);\n\t}\n\tinc(i,1,n) dfs1(i,i);\n\tinc(u,1,n){\n\t\tvis.reset(),vis[u]=1;\n\t\tfor(re int i=0;i<to[u].size();i++) dfs2(to[u][i],u,0,i);\n\t\tvis.reset(),vis[u]=1;\n\t\tfor(re int i=to[u].size()-1;~i;i--) dfs2(to[u][i],u,1,i);\n\t}\n\tinc(i,1,m) puts(vis1[b[i]][a[i]]^vis2[a[i]][b[i]]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ld inf = 2e18;\nconst int N = 1020;\nconst int maxn = 200020;\nconst ll mod = 998244353;\n\nstruct node{\n\tint next,to;\n}e[maxn * 2];\nint head[maxn],cnt;\nint reach[N][N],vis[N],tag[N];\nint n,m;\nvector <pr> edge;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nvoid dfs(int x,int from){\n\tif ( !vis[x] ) vis[x] = 1 , tag[x] = from;\n\telse{\n\t\tif ( from != tag[x] ) vis[x]++;\n\t\telse return;\n\t\tif ( vis[x] > 2 ) return;\n\t}\n\tfore(i,x){\n\t\tdfs(e[i].to,from);\n\t}\n}\nvoid solve(int id){\n\trep(i,1,n) vis[i] = 0;\n\tvis[id] = 1;\n\tfore(i,id){\n\t\tdfs(e[i].to,e[i].to);\n\t}\n\trep(i,1,n){\n\t\treach[id][i] = vis[i];\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,m){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y);\n\t\tedge.pb(mp(x,y));\n\t}\n\trep(i,1,n) solve(i);\n//\trep(i,1,n) rep(j,i + 1,n){\n//\t\tcout<<i<<\" \"<<j<<\" \"<<reach[i][j]<<endl;\n//\t\tcout<<j<<\" \"<<i<<\" \"<<reach[j][i]<<endl;\n//\t}\n\trep(i,0,m - 1){\n\t\tint x = edge[i].fi , y = edge[i].se;\n\t\tif ( reach[x][y] > 1 && reach[y][x] ) puts(\"same\");\n\t\telse if ( reach[x][y] == 1 && !reach[y][x] ) puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1020, M = 203000, inf = 0x3f3f3f3f;\nint n,m,head[N],nxt[M],to[M],edgenum,a[M],b[M],d[N],mx[N],res[M];Vi e[N];\nvoid add(int u, int v){\n\tto[++edgenum]=v;nxt[edgenum]=head[u];head[u]=edgenum;\n}\ninline void dfs(int u, int *d){\n\tL(i,u)if(d[to[i]]==inf)d[to[i]]=d[u],dfs(to[i],d);\n}\nint main() {\n\tread(n);read(m);rep(i,1,m)read(a[i]),read(b[i]),add(a[i],b[i]),e[b[i]].pb(i);\n\trep(u,1,n){\n\t//\tint f=1,r=1;\n\t\tmemset(d,inf,sizeof(d));memset(mx,inf,sizeof(mx));\n\t//\tL(i,u)q[r++]=to[i];\n\t\td[u]=mx[u]=0;\n\t\t/*while(f!=r){\n\t\t\tint u=q[f++];\n\t\t\tL(i,u)if(d[to[i]]>d[u]||mx[to[i]]<mx[u])\n\t\t\t\tmx[to[i]]=mx[u],d[to[i]]=d[u],q[r++]=to[i];\n\t\t}*/\n\t\tstatic int s[N];int len=0;L(i,u)s[++len]=to[i];\n\t\trep(i,1,len)if(d[s[i]]==inf)d[s[i]]=s[i],dfs(s[i],d);\n\t\tper(i,len,1)if(mx[s[i]]==inf)mx[s[i]]=s[i],dfs(s[i],mx);\n\t\tL(i,u)res[i]^=d[to[i]]!=to[i]||mx[to[i]]!=to[i];\n\t\tper(i,SZ(e[u])-1,0)res[e[u][i]]^=d[a[e[u][i]]]<inf;\n\t}\n\trep(i,1,m)printf(\"%s\\n\",res[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1e3+5,M=2e5+5;\nint rt,g[M],a[M],b[M],sta[2][N];\nbool f[N][N],vis[N];\nvector<pair<int,int> > v[N];\n#define fi first\n#define se second\ninline void dfs0(ri x){\n\tif(f[rt][x]) return;\n\tf[rt][x]=1;\n\tfor(auto o:v[x])\n\t\tdfs0(o.fi);\n}\nint cur;\ninline void dfs(ri x){\n\tif(vis[x]==cur)\n\t\treturn;\n\tvis[x]=cur;\n\tsta[cur][x]=rt;\n\tfor(auto o:v[x])\n\t\tdfs(o.fi);\n}\nint main(){\n\tri n,m,i,x;\n\tgi(n);gi(m);\n\tfor(i=1;i<=m;++i)\n\t\tgi(a[i]),gi(b[i]),\n\t\tv[a[i]].push_back(make_pair(b[i],i));\n\tfor(i=1;i<=n;++i)\n\t\trt=i,\n\t\tdfs0(i);\n\tfor(x=1;x<=n;++x){\n\t\tcur^=1;\n\t\tvis[x]=cur;\n\t\tfor(auto o:v[x])\n\t\t\trt=o.se,\n\t\t\tdfs(o.fi);\n\t\treverse(v[x].begin(),v[x].end());\n\t\tcur^=1;\n\t\tvis[x]=cur;\n\t\tfor(auto o:v[x])\n\t\t\trt=o.se,\n\t\t\tdfs(o.fi);\n\t\tfor(auto o:v[x])\n\t\t\tg[o.se]=sta[0][o.fi]!=sta[1][o.fi];\n\t}\n\tfor(i=1;i<=m;++i)\n\t\tputs(f[b[i]][a[i]]^g[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  int x=0,f=1;char c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return f?x:-x;\n  }\ntemplate <typename mitsuha>\ninline bool read(mitsuha &x){\n  x=0;int f=1;char c=gc();\n  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';\n  if (!~c) return 0;\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return x=f?x:-x,1;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x){\n  if (!x) return 0&pc(48);\n  if (x<0) x=-x,pc('-');\n  int bit[20],i,p=0;\n  for (;x;x/=10) bit[++p]=x%10;\n  for (i=p;i;--i) pc(bit[i]+48);\n  return 0;\n  }\ninline char fuhao(){\n  char c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=2e5;\ntypedef int fuko[yuzu|10];\nfuko u,v;int vis[2][yuzu>>6][yuzu>>6];\nvector<int> lj[yuzu|10];\n\nvoid dfs(int id,int p,int u,int col){\nif (vis[id][p][u]) return;\nvis[id][p][u]=col;\nfor (int i:lj[u]) dfs(id,p,i,col);\n}\n\nint main(){\nint i,n=read(),m=read();\nfor (i=1;i<=m;++i){\n  u[i]=read(),v[i]=read();\n  lj[u[i]].push_back(v[i]);\n  } \nfor (i=1;i<=n;++i){\n  vis[0][i][i]=vis[1][i][i]=1;\n  int now=0;for (int j:lj[i]) dfs(0,i,j,++now);\n  if (lj[i].size()) for (int j=lj[i].size()-1;~j;--j) dfs(1,i,lj[i][j],j+1);\n  }\nfor (i=1;i<=m;++i){\n  puts((vis[0][u[i]][v[i]]!=vis[1][u[i]][v[i]])^(vis[0][v[i]][u[i]]>0)?\"diff\":\"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 1010\n#define MAXM 200010\nusing namespace std;\nint n,m,u,v;\nint id[MAXN][MAXN],ans1[MAXN][MAXN],ans2[MAXN][MAXN],q[MAXN][2];\nint ans[MAXM];\nvector<int> a[MAXN];\nvoid dfs(int x,int fa){\n    ans1[fa][x]=1;\n    for(int i=0;i<a[x].size();i++)\n        if(ans1[fa][a[x][i]]==0)\n            dfs(a[x][i],fa);\n}\nvoid dfs1(int x,int tag,int flag){\n    q[x][flag]=tag;\n    for(int i=0;i<a[x].size();i++)\n        if(!q[a[x][i]][flag])\n            dfs1(a[x][i],tag,flag);\n}\nint main(){\n    SF(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++){\n        SF(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        id[u][v]=i+1;\n        a[u].push_back(v);\n    }\n    for(int i=0;i<n;i++)\n        dfs(i,i);\n    for(int i=0;i<n;i++){\n        memset(q,0,sizeof q);\n        q[i][0]=q[i][1]=-1;\n        for(int j=0;j<a[i].size();j++)\n            if(!q[a[i][j]][0])\n                dfs1(a[i][j],j+1,0);\n        for(int j=a[i].size()-1;j>=0;j--)\n            if(!q[a[i][j]][1])\n                dfs1(a[i][j],j+1,1);\n        for(int j=0;j<a[i].size();j++)\n            if(q[a[i][j]][0]!=j+1||q[a[i][j]][1]!=j+1)\n                ans2[i][a[i][j]]=1;\n    }\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            if(ans1[j][i]==ans2[i][j]&&id[i][j])\n                ans[id[i][j]]=1;\n    for(int i=1;i<=m;i++){\n        if(ans[i]==1)\n            PF(\"same\\n\");\n        else\n            PF(\"diff\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\nconst int M = 200005;\nconst int INF = 1e9;\n\nint n, m;\nint fr[M], to[M];\nvector<int> g[N];\nint low[N], num[N], step, scc;\nstack <int> st;\nint pos[N];\nbool vis[N];\nvector<int> buf;\n\nvoid dfs(int u) {\n\tlow[u] = num[u] = ++step;\n\tst.push(u);\n\n\tfor (int &v : g[u]) {\n\t\tif (num[v]) low[u] = min(low[u], num[v]);\n\t\telse {\n\t\t\tdfs(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t}\n\t}\n\n\tif (low[u] == num[u]) {\n\t\tint v = 0;\n\t\t++scc;\n\t\tdo {\n\t\t\tv = st.top(); st.pop();\n\t\t\tlow[v] = num[v] = INF;\n\t\t\tpos[v] = scc;\n\t\t} while(v != u);\n\t}\n}\n\nbool check(int id) { // id: ID of the edge\n\tint s = fr[id], t = to[id]; // s -> t\n\tqueue <int> q;\n\tfor (int i = 1; i <= n; ++i) vis[i] = false;\n\tq.push(s);\n\tvis[s] = true;\n\n\tvector<int> buf;\n\twhile(!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tbuf.push_back(u);\n\n\t\tif (u == t) return true;\n\n\t\tfor (int &v : g[u]) {\n\t\t\tif (u == s && v == t) continue;\n\t\t\tif (!vis[v]) {\n\t\t\t\tvis[v] = true; q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tfr[i] = u;\n\t\tto[i] = v;\n\t}\n\n\tfor (int i = 1; i <= n; ++i) if (!num[i]) dfs(i);\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u = fr[i], v = to[i];\n\t\tbool cur = (pos[u] != pos[v]);\n\t\tcur ^= check(i);\n\t\t\n\t\t// cut the i-th edge and find if there exists a directed path from u to v\n\t\tif (cur) {\n\t\t\tprintf(\"same\\n\");\n\t\t} else {\n\t\t\tprintf(\"diff\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int>> edges[1000], rev[1000];\nbitset<200000> cond1, cond2;\n\nbitset<1000> visited;\nvoid dfs(int i){\n    if(visited[i]) return;\n    visited[i] = 1;\n    for(auto& p : edges[i]) if(!visited[p.second]) dfs(p.second);\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    for(int i=0; i<M; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back({i, b-1});\n        rev[b-1].push_back({i, a-1});\n    }\n    for(int i=0; i<N; i++){\n        visited.reset();\n        dfs(i);\n        for(auto& p : rev[i]) if(visited[p.second]) cond1[p.first] = 1;\n    }\n\n    for(int i=0; i<N; i++){\n        for(int t=0; t<2; t++){\n            visited.reset();\n            visited[i] = 1;\n            for(auto& p : edges[i]){\n                if(visited[p.second]) cond2[p.first] = 1;\n                dfs(p.second);\n            }\n            reverse(edges[i].begin(), edges[i].end());\n        }\n    }\n\n    for(int i=0; i<M; i++){\n        cout << (cond1[i] == cond2[i] ? \"same\" : \"diff\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=200005;\nint n,m,U[M],V[M],id,f[N],dfn[N],low[N];\nvector<int>e[N],d[N];\nstack<int>s;\nint tim,vis[N];\nint mp[N][N][2];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs(int now,int fa,int b,int f)\n{\n\tvis[now]=tim; mp[fa][now][f]=b;\n\tint len=e[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[e[now][i]]!=tim)\n\t\t\tdfs(e[now][i],fa,b,f);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n        d[U[i]].push_back(i);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        tim++;vis[i]=tim;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,d[i][j],0);\n        tim++;vis[i]=tim;\n        for(int j=up-1;j>=0;j--)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,d[i][j],1);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]][0]!=mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]][0]==mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nconst int MN = 1005, MM = 200005;\n\nint N, M, eu[MM], ev[MM], Ans[MM];\nstd::vector<int> G[MN];\nbool vis[MN], rch[MN][MN]; int col[MN];\nvoid DFS(int u, int c) {\n\tvis[u] = 1, col[u] ^= c;\n\tfor (auto i : G[u]) if (!vis[ev[i]]) DFS(ev[i], c);\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= M; ++i) {\n\t\tscanf(\"%d%d\", &eu[i], &ev[i]);\n\t\tG[eu[i]].push_back(i);\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 1; j <= N; ++j) vis[j] = 0;\n\t\tDFS(i, 0);\n\t\tfor (int j = 1; j <= N; ++j) if (vis[j]) rch[i][j] = 1;\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 1; j <= N; ++j) col[j] = vis[j] = 0; vis[i] = 1;\n\t\tfor (auto j : G[i]) if (!vis[ev[j]]) DFS(ev[j], ev[j]);\n\t\tstd::reverse(G[i].begin(), G[i].end());\n\t\tfor (int j = 1; j <= N; ++j) vis[j] = 0; vis[i] = 1;\n\t\tfor (auto j : G[i]) if (!vis[ev[j]]) DFS(ev[j], ev[j]);\n\t\tfor (auto j : G[i]) Ans[j] = rch[ev[j]][i] ^ !!col[ev[j]];\n\t}\n\tfor (int i = 1; i <= M; ++i) puts(Ans[i] ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n\n2 2\n1 2\n2 1\n\n3 3\n1 2\n1 3\n2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define N 1005\n#define bit(x,y) ((x>>y)&1LL)\n#define loop(i,l,r) for(int i=(signed)(l); i<=(signed)(r); i++)\n\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &a) {\n    return os << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    for (unsigned int i = 0; i < a.size(); i++)\n        os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n    os << ']';\n    return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &a) {\n    os << '{';\n    for (typename set<T>::iterator it = a.begin(); it != a.end(); it++) {\n        typename set<T>::iterator jt = it;\n        os << *it << (++jt != a.end() ? \", \" : \"\");\n    }\n    os << '}';\n    return os;\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, map<T1, T2> &a) {\n    os << \"{\\n\";\n    for (typename map<T1, T2>::iterator it = a.begin(); it != a.end(); it++) {\n        typename map<T1, T2>::iterator jt = it;\n        os << \"  \" << it->first << \": \" << it->second << (++jt != a.end() ? \",\\n\" : \"\\n\");\n    }\n    os << '}';\n    return os;\n}\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint cnt[N][N];\nint mark[N][N];\nbool ansOrder[200005];\n\nvoid dfs(int u, int p, const int root, const int source) {\n    if (u == root) return;\n    if (cnt[root][u] >= 2) return;\n    if (cnt[root][u] == 1 && mark[root][u] == source) return;\n    cnt[root][u]++; mark[root][u] = source;\n    for (auto it : a[u]) {\n        int v = it.fi;\n        if (v == p) continue;\n        dfs(v, u, root, source);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    loop(i, 1, m) {\n        int u, v; cin >> u >> v;\n        a[u].push_back(mp(v, i));\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            dfs(v, u, u, v);\n        }\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            bool diff = false;\n            if (cnt[u][v] >= 2) {\n                if (cnt[v][u] == 0) diff = true;\n            }\n            else if (cnt[u][v] == 1) {\n                if (cnt[v][u] >= 1) diff = true;\n            }\n            ansOrder[it.se] = diff;\n        }\n    }\n    loop(i, 1, m) {\n        if (ansOrder[i] == false) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <queue>\n#include <sstream>\nusing namespace std;\n#define x first\n#define y second\n#define mp make_pair\n#define elif else if\n#define prev prev2\n#define Edge pair <int, int>\n#define next next2\n#define u first\n#define v second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1000, N = 1000, MAXM = 2e5;\nvector<int> g[MAXM], gt[MAXM];\nint a[MAXM], b[MAXM], c1[MAXM], c2[MAXM];\nvector<int> topsort;\nint vis[MAXM];\nEdge ed[MAXM];\nbool used[MAXM];\nvoid dfs(int u) {\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (!used[v]) dfs(v);\n    }   \n}   \nvoid solve(int u) {\n\t//cout << \"u: \" << u << endl;\n    memset(used, 0, sizeof used);\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        //cout << v << \" \" << used[v] << endl;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n    memset(used, 0, sizeof used);\n    reverse(g[u].begin(), g[u].end());\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n}   \nvoid dfst1(int v) {\n\tvis[v] = 1;\n\tfor (int e : g[v]) {\n\t\tint u = b[e];\n\t\tif (!vis[u])\n\t\t\tdfst1(u);\n\t}\n\ttopsort.push_back(v);\n}\nint clr = 0;\nvoid dfst2(int v) {\n\tvis[v] = clr;\n\tfor (int e : gt[v]) {\n\t\tint u = a[e];\n\t\tif (!vis[u])\n\t\t\tdfst2(u);\n\t}\n}\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\t--a[i];\n\t\t--b[i];\n\t\tg[a[i]].push_back(i);\n\t\tgt[b[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!vis[i])\n\t\t\tdfst1(i);\n\tfill(vis, vis + n, 0);\n\treverse(topsort.begin(), topsort.end());\n\tfor (int v : topsort)\n\t\tif (!vis[v]) {\n\t\t\t++clr;\n\t\t\tdfst2(v);\n\t\t}\n\n\tfor (int i = 0; i < m; ++i) \n\t\tc1[i] = (vis[a[i]] == vis[b[i]]);\n\tfor (int i = 0; i < m; ++i) {\n        ed[i] = {a[i], b[i]};\n    }   \n    for (int i = 0; i < n; ++i) {\n        solve(i);\n    }\n\n\tfor (int i = 0; i < m; ++i) {\n\t\t//cout << c1[i] << c2[i];\n        if (c1[i] ^ c2[i]) {\n            cout << \"diff\\n\";\n        }   \n        else {\n            cout << \"same\\n\";\n        }\n    }   \n\treturn;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[N][N],ans[2][N],p[2][N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[rt][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vis[rt][v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++) vis[i][j] = 0;\n\t\tdfs_vis(i,i);\n\t}\n\tfor(LL i = 1;i <= m;i ++){\n\t\tif(vis[ev[i]][eu[i]]) ans[0][i] = 1;\n\t\telse ans[0][i] = 0;\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid){\n\tp[pid][u] = col;\n//\tcout << pid << ' ' << u << '-' << col << endl;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n//\t\tcout << u << ' ' << v << ' ' << col << ' ' << p[pid][v] << endl;\n\t\tif(p[pid][v]) continue;\n\t\tdfs_sol(v,col,pid);\n\t}\n}\n\nvoid solve(LL u){\n\tfor(LL i = 1;i <= n;i ++) p[0][i] = p[1][i] = 0;\n\tp[0][u] = p[1][u] = u;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!p[0][ev[G[u][i]]]) dfs_sol(ev[G[u][i]],G[u][i],0);\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!p[1][ev[G[u][i]]]) dfs_sol(ev[G[u][i]],G[u][i],1);\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n//\t\tcout << u << ',' << v << ' ' << p[0][v] << ' ' << p[1][v] << endl;\n\t\tif(p[0][v] != p[1][v]) ans[1][G[u][i]] = 1;\n\t\telse ans[1][G[u][i]] = 0;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(i);\n\t}\n\tget_vis();\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n//\tfor(LL i = 1;i <= m;i ++) cout << ans[0][i] << ' ' << ans[1][i] << endl;\n\tfor(LL i = 1;i <= m;i ++) cout << ((ans[0][i] ^ ans[1][i]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005;\nconst int M = 200005;\nconst int INF = 1000000000;\ntypedef long long i64;\n\nvector<int> E[N];\nint edge[M][2];\nint ma[N][N], mi[N][N];\nbool vis[N];\n\nvoid dfs(int s, int now, int k, bool mark) {\n    if (vis[now] || now == s) return ;\n    vis[now] = true;\n    if (mark) mi[s][now] = k;\n    else ma[s][now] = k;\n    for (auto i = E[now].begin(); i != E[now].end(); ++i) {\n        dfs(s, *i, k, mark);\n    }\n}\nint main ()\n{\n    int n, m, v;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= m; ++i) {\n        scanf(\"%d %d\", &edge[i][0], &edge[i][1]);\n        E[edge[i][0]].push_back(edge[i][1]);\n    }\n    for (int i = 1; i <= n; ++i) {\n        memset(vis, false, sizeof(vis));\n        int num = 0;\n        for (auto j = E[i].begin(); j != E[i].end(); ++j) {\n            dfs(i, *j, ++num, true);\n        }\n        memset(vis,false, sizeof(vis));\n        reverse(E[i].begin(), E[i].end());\n        num = E[i].size();\n        for (auto j = E[i].begin(); j != E[i].end(); ++j) {\n            dfs(i, *j, num--, false);\n        }\n    }\n    for (int i = 1; i <= m; ++i) {\n        if ((mi[edge[i][1]][edge[i][0]] > 0) == (ma[edge[i][0]][edge[i][1]] != mi[edge[i][0]][edge[i][1]])) {\n            puts(\"same\");\n        }\n        else {\n            puts(\"diff\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define maxn 200100\nusing namespace std;\nint n,m,tot,head[1010],th[1010][1010];\nbool vis[1010];\nstruct point{\n\tint to,nxt;\n}a[maxn];\nvoid add(int x,int y)\n{\n\ta[++tot].to=y;\n\ta[tot].nxt=head[x];\n\thead[x]=tot;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tvis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tdfs(a[i].to,s,cur);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=head[i];j;j=a[j].nxt) dfs(a[j].to,i,j);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].fr,y=a[i].to;\n\t\tif((th[y][x]&&th[x][y]!=-1)||(!th[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int N = 1005;\nconst int M = 2e5 + 5;\nvector<int> v[N];\nint n, m, vis[N], g1[N][N], g2[N][N], pre[N];\nstruct node{int x, y;}e[M];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid dfs(int x, int now)\n{\n\tg1[now][x] = 1; vis[x] = 1;\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, now);\n\t}\n}\nvoid dfs(int x, int id, int k, int now)\n{\n\tvis[x] = 1;\n\tif(!k) pre[x] = id; else g2[now][x] = (pre[x] != id);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, id, k, now);\n\t}\n}\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read();\n\tfor(int i = 1, x, y; i <= m; i ++)\n\t{\n\t\tx = read(); y = read();\n\t\tv[x].push_back(y); e[i] = node{x, y};\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++) vis[j] = 0;\n\t\tdfs(i, i);\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++) pre[j] = vis[j] = 0; vis[i] = 1;\n\t\tint d = v[i].size();\n\t\tfor(int j = 0; j < d; j ++) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 0, i);\n\t\tfor(int j = 1; j <= n; j ++) vis[j] = 0; vis[i] = 1;\n\t\tfor(int j = d - 1; j >= 0; j --) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 1, i);//d - 1\n\t}\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tif(g1[e[i].x][e[i].y] ^ g2[e[i].x][e[i].y]) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n\tstatic const int S=1e7;\n\tchar rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n\tfastio() {rpos=len=wpos=0;}\n\tinline char Getchar()\n\t{\n\t\tif (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n\t\tif (!len) return EOF;\n\t\treturn rbuf[rpos++];\n\t}\n\ttemplate <class T> inline void Get(T &x)\n\t{\n\t\tchar ch;bool f;T res;\n\t\twhile (!isdigit(ch=Getchar()) && ch!='-') {}\n\t\tif (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n\t\twhile (isdigit(ch=Getchar())) res=res*10+ch-'0';\n\t\tx=(f?res:-res);\n\t}\n\tinline void getstring(char *s)\n\t{\n\t\tchar ch;\n\t\twhile ((ch=Getchar())<=32) {}\n\t\tfor (;ch>32;ch=Getchar()) *s++=ch;\n\t\t*s='\\0';\n\t}\n\tinline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n\tinline void Writechar(char ch)\n\t{\n\t\tif (wpos==S) flush();\n\t\twbuf[wpos++]=ch;\n\t}\n\ttemplate <class T> inline void Print(T x,char ch)\n\t{\n\t\tchar s[20];int pt=0;\n\t\tif (x==0) s[++pt]='0';\n\t\telse\n\t\t{\n\t\t\tif (x<0) Writechar('-'),x=-x;\n\t\t\twhile (x) s[++pt]='0'+x%10,x/=10;\n\t\t}\n\t\twhile (pt) Writechar(s[pt--]);\n\t\tWritechar(ch);\n\t}\n\tinline void printstring(char *s)\n\t{\n\t\tint pt=1;\n\t\twhile (s[pt]!='\\0') Writechar(s[pt++]);\n\t}\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ntemplate<typename T> inline int quick_pow(int x,T y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ntemplate<typename T> inline int quick_pow(int x,T y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=1000;\nconst int MAXM=2e5;\n\nint n,m;\nvector<Pair> v[MAXN+48];\nvector<int> vv[MAXN+48];\nbool visited1[MAXN+48],visited2[MAXN+48],visited3[MAXN+48],ok[MAXN+48];\nint ans[MAXM+48];\n\ninline void dfs1(int cur)\n{\n\tvisited1[cur]=true;\n\tfor (register int i=0;i<int(vv[cur].size());i++)\n\t{\n\t\tregister int y=vv[cur][i];\n\t\tif (!visited1[y]) dfs1(y);\n\t}\n}\n\ninline void dfs2(int cur)\n{\n\tvisited2[cur]=true;\n\tfor (register int i=0;i<int(v[cur].size());i++)\n\t{\n\t\tregister int y=v[cur][i].x;\n\t\tif (!visited2[y]) dfs2(y);\n\t}\n}\n\nint main ()\n{\n#ifdef LOCAL\n\tdouble TIME=clock();\n\tfreopen (\"a.in\",\"r\",stdin);\n\tfreopen (\"a.out\",\"w\",stdout);\n\tcerr<<\"Running...\"<<endl;\n#endif\n\tio.Get(n);io.Get(m);int x,y;\n\tfor (register int i=1;i<=m;i++)\n\t{\n\t\tio.Get(x);io.Get(y);\n\t\tv[x].pb(mp(y,i));vv[y].pb(x);\n\t}\n\tfor (register int i=1;i<=n;i++)\n\t{\n\t\tmemset(visited1,false,sizeof(visited1));\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tmemset(ok,false,sizeof(ok));\n\t\tdfs1(i);visited2[i]=true;\n\t\tfor (register int j=0;j<int(v[i].size())-1;j++)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j+1;k<int(v[i].size());k++)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tvisited[2]=true;\n\t\tfor (register int j=int(v[i].size())-1;j>=1;j--)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j-1;k>=0;k--)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tfor (register int j=0;j<int(v[i].size());j++) ans[v[i][j].y]=(visited1[v[i][j].x]^ok[v[i][j].x]);\n\t}\n\tfor (register int i=1;i<=m;i++) printf(ans[i]?\"diff\\n\":\"same\\n\");\n\tio.flush();\n#ifdef LOCAL\n\tcerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=200005,N=1005;\nint nxt[M],ed[M],ans[M];\nvector<int> v[N];\nint son[N],vis[N],ne,alb[M],lt[N][N];\nvoid ae(int a,int b){\n\tnxt[++ne]=son[a]; son[a]=ne; ed[ne]=b;\n}\nvoid dfs(int p){\n\tvis[p]=1;\n\tfor(auto i:v[p])if(!vis[i])dfs(i);\n}\nint main(){\n\tint n=read(),m=read();\n\tFor(i,1,m){\n\t\tint s=read(),t=read(); \n\t\tae(s,t); v[s].pb(t);\n\t}\n\tFor(i,1,n){\n\t\tmemset(vis,0,sizeof(vis)); \n\t\tvector<int> v; vis[i]=1;\n\t\tfor(int j=son[i];j;j=nxt[j]){\t\t\t\n\t\t\tif(vis[ed[j]]){\n\t\t\t\talb[j]=1; \n\t\t\t}else{\n\t\t\t\tdfs(ed[j]);\n\t\t\t}\n\t\t\tv.pb(j);\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));  vis[i]=1;\n\t\tRep(o,v.size()-1,0){\n\t\t\tint j=v[o];\n\t\t\tif(vis[ed[j]]){\n\t\t\t\talb[j]=1; \n\t\t\t}else{\n\t\t\t\tdfs(ed[j]);\n\t\t\t}\n\t\t}\n\t\tFor(j,1,n)lt[i][j]=vis[j];\n\t}\n\tFor(i,1,n)for(int j=son[i];j;j=nxt[j])ans[j]=alb[j]==lt[ed[j]][i];\n\t//for(int i=son[3];i;i=nxt[i])if(ed[i]==4)cout<<alb[i]<<endl;\n\tFor(i,1,m)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n        printf(\"i = %d\\n\", i);\n        for (int j=1; j<=n; ++j) {\n            printf(\"%d %d\\n\", starred[j], res[i][j]);\n        }\n    }\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else puts(\"diff\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <list>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <utility>\n#include <complex>\n#include <assert.h>\n#include <limits.h>\n//#include <bits/stdc++.h>\nusing namespace std;\n#define rank rankk\n#define mp make_pair\n#define pb push_back\n#define xo(a,b) ((b)&1?(a):0)\n#define tm tmp\n\n//#define LL ll\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll>pil;\ntypedef pair<ll,ll> pll;\n//const double INF=1e20;\nconst int INF=0x3f3f3f3f;\n//const int INF= 0x7fffffff;\n//const ll INF=0x3f3f3f3f3f3f3f3fll;\n//const ll INFF=0x3f3f3f3f3f3f3fll;\n//const ll INFF=1e14+5;\nconst int MAX=2e5+5;\n//const ll MAXN=2e8;\n//const int MAX_N=MAX;\n//const ll MOD=1e9+7;\nconst int MOD=1e9+7;\n//const long double pi=acos(-1.0);\n//const double eps=0.00000001;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\ninline ll powMM(ll a,ll b,ll M){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\n//const long double eps=-1.0;\n//clock_t t1 = clock();\n//fprintf(stderr, \"%ld ms\\n\", clock() - t1);\nvoid open()\n{\n    freopen(\"in2.txt\",\"r\",stdin);\n    freopen(\"out2.txt\",\"w\",stdout);\n}\nconst int maxn=1e3+5;\nvector<int> G[maxn];//存原图 初始化仅需初始此\nint n,m;\nint a[MAX],b[MAX];\nint da[1005][1005],xiao[1005][1005];\nbool vi[1005];\nvoid dfs(int now,int id,int st,int x[1005][1005] )\n{\n//    printf(\"now=%d id=%d st=%d\\n\",now,id,st);\n    vi[now]=true;\n    if(x[st][now]==-1)x[st][now]=id;\n    for(int u:G[now])\n        if(!vi[u]&&u!=st)dfs(u,id,st,x);\n}\nvoid solve(int st)\n{\n    for(int i=0;i<G[st].size();i++)\n    {\n        int to=G[st][i];\n        memset(vi,false,sizeof(vi));\n        vi[st]=1;\n        dfs(to,i,st,xiao);\n    }\n    memset(vi,false,sizeof(vi));\n    for(int i=G[st].size()-1;i>=0;i--)\n    {\n        int to=G[st][i];\n        memset(vi,false,sizeof(vi));\n        vi[st]=1;\n        dfs(to,i,st,da);\n    }\n}\nint main()\n{\n    read(n);read(m);\n    memset(da,-1,sizeof(da));\n    memset(xiao,-1,sizeof(xiao));\n    for(int i=1;i<=m;i++){read(a[i]);read(b[i]);G[a[i]].pb(b[i]);}\n//    find_scc(n);\n    for(int i=1;i<=n;i++)\n        solve(i);\n    for(int i=1;i<=m;i++)\n    {\n//        printf(\"%d %d %d\\n\",da[a[i]][b[i]],xiao[a[i]][b[i]],da[b[i]][a[i]]);\n        if((da[a[i]][b[i]]!=xiao[a[i]][b[i]])==(da[b[i]][a[i]]!=-1))printf(\"same\\n\");\n        else printf(\"diff\\n\");\n    }\n\n}\n/*\n4\n1 2 3 2\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e3+5;\nconst int M=2e5+5;\n\nint n,m,A[M],B[M],vis[N],tag[N],flag[2][N][N];\nvector <int> G[N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nvoid dfs(int u,int rt) {\n\tif(vis[u]) return;\n\tflag[0][rt][u]=vis[u]=true;\n\tfor(auto v:G[u]) dfs(v,rt);\n}\nvoid dfs(int u,int rt,int id,int now) {\n\tif(vis[u]) return;\n\tvis[u]=true;\n\tif(!now) tag[u]=id;\n\telse flag[1][rt][u]=(bool)(tag[u]!=id);\n\tfor(auto v:G[u]) dfs(v,rt,id,now);\n}\n\nint main() {\n\tIN(n),IN(m);\n\tfor(int i=1;i<=m;++i)\n\t\tIN(A[i]),IN(B[i]),G[A[i]].push_back(B[i]);\n\tfor(int u=1;u<=n;++u) memset(vis,0,sizeof(vis)),dfs(u,u);\n\tfor(int u=1;u<=n;++u) {\n\t\tmemset(tag,0,sizeof(tag));\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=0;i<=(int)G[u].size()-1;++i) dfs(G[u][i],u,i,0);\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=(int)G[u].size()-1;i>=0;--i) dfs(G[u][i],u,i,1);\n\t}\n\tfor(int i=1;i<=m;++i)\n\t\tputs(flag[0][B[i]][A[i]]^flag[1][A[i]][B[i]]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e3 + 3;\n\nvector < pp > V[N],U[N];\nvector < int > Y[N]; \nint D[N],low[N],zaman,H[N],Scc[N],scc,T[N],ans[N],n,m,x,y,i,X;\nstack < int > S;\n\nvoid f(int x){\n    D[x] = low[x] = ++zaman;\n    S.push(x); H[x] = 1;\n    for(auto t : V[x]){\n        int y = t.st;\n        if(y == X) continue;\n        if(!D[y]){ f(y); low[x] = min(low[x] , low[y]); }\n        else if(H[y]) low[x] = min(low[x] , D[y]); \n    }\n    \n    if(low[x] == D[x]){\n        scc++;\n        for(int y = 0; y != x;){\n            y = S.top();\n            S.pop();\n            H[y] = 0;\n            Scc[y] = scc;\n            Y[scc].pb(y);\n        }        \n    }\n}\n\nvoid g(int x){\n    X = x;\n    int i;\n    memset(D , zaman=0 , sizeof D);\n    memset(Scc , scc=0 , sizeof Scc);\n    for(i=1;i<=n;i++) { Y[i].clear(); U[i].clear(); }\n    for(i=1;i<=n;i++) if(i != X && !D[i]) f(i);\n    if(x == 0){\n        for(i=1;i<=n;i++) T[i] = Scc[i];\n        return;\n    }\n\n    memset(D , 0 , sizeof D);\n    for(auto t : V[X]){\n        U[ Scc[t.st] ].pb(t);\n    }\n    for(i=scc; i ;i--){\n        if(!D[i] && U[i].size() == 0) continue;\n        if(D[i] || U[i].size() > 1){\n            for(auto t : U[i]){\n                ans[t.nd] = T[X] == T[t.st];\n            }\n        }\n        else { for(auto t : U[i]) ans[t.nd] = T[X] != T[t.st]; }\n        \n        for(auto x : Y[i]){\n            for(auto y : V[x])\n                D[ Scc[y.st] ] = 1;    \n        }\n    }\n}\n\nsigned main(){\n    cin >> n >> m;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d\",&x,&y);\n        V[x].pb(mp(y,i));\n    }\n    \n    for(i=0;i<=n;i++) g(i);\n    for(i=1;i<=m;i++) puts(ans[i] ? \"same\" : \"diff\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\n#define N 600006\nvector<int>v[2002];\nint n,m,a[N][2],id[2002][2002],id1[2002],id2[2002];\nbool vis[2002],to[2002][2002],ao[2002][2002];\nvoid df5(int anc,int te)\n{\n    for(int i=0;i<v[te].size();i++)\n    {\n        int j=v[te][i];to[anc][j]=1;\n        if(!vis[j])\n        {\n            vis[j]=1;df5(anc,j);\n        }\n    }\n}\nvoid dfs(int anc,int te,int wh)\n{\n    for(int i=0;i<v[te].size();i++)\n    {\n        int j=v[te][i];if(te==anc)wh=i+1;\n        if(!vis[j])\n        {\n        if(id1[j]&&id1[j]!=wh)ao[anc][j]=1;id1[j]=wh;\n            vis[j]=1;dfs(anc,j,wh);\n        }\n    }\n}\nvoid dfss(int anc,int te,int wh)\n{\n    for(int i=((int)v[te].size())-1;~i;i--)\n    {\n        int j=v[te][i];if(te==anc)wh=i+1;\n        if(!vis[j])\n        {\n        if(id1[j]&&id1[j]!=wh)ao[anc][j]=1;id1[j]=wh;\n            vis[j]=1;dfss(anc,j,wh);\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        int x,y;scanf(\"%d%d\",&x,&y);\n        v[x].push_back(y);a[i][0]=x,a[i][1]=y,id[x][y]=i;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)vis[j]=0;vis[i]=1;\n        df5(i,i);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)vis[j]=id1[j]=id2[j]=0;\n        vis[i]=1;dfs(i,i,0);\n        for(int j=1;j<=n;j++)vis[j]=0;\n        vis[i]=1;dfss(i,i,0);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(to[a[i][1]][a[i][0]]^ao[a[i][0]][a[i][1]])puts(\"diff\");\n        else puts(\"same\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2],gg[N],ff[N][N][2];\nvoid ins(int x,int y,int*g){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s){ \n    for (int i=g[x];i;i=a[i][1])\n        if (a[i][0]!=s){\n            if (!f[s][a[i][0]][0])f[s][a[i][0]][0]=x;\n            else\n                if (!f[s][a[i][0]][1])f[s][a[i][0]][1]=x;\n            if (f[s][a[i][0]][0]==x)dfs(a[i][0],s);\n        }\n}\nvoid dfs1(int x,int s){ \n    for (int i=gg[x];i;i=a[i][1])\n        if (a[i][0]!=s){\n            if (!ff[s][a[i][0]][0])ff[s][a[i][0]][0]=x;\n            else\n                if (!ff[s][a[i][0]][1])ff[s][a[i][0]][1]=x;\n            if (ff[s][a[i][0]][0]==x)dfs1(a[i][0],s);\n        }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for (int i=1;i<=m;i++){\n        cin>>e[i][0]>>e[i][1];\n        ins(e[i][1],e[i][0],g);\n        ins(e[i][0],e[i][1],gg);\n    }\n    for (int i=1;i<=n;i++)\n        dfs(i,i),dfs1(i,i);\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][0]][e[i][1]][0];\n        bool sig1=((f[e[i][1]][e[i][0]][0]&&f[e[i][1]][e[i][0]][0]!=e[i][1])||(f[e[i][1]][e[i][0]][1]&&f[e[i][1]][e[i][0]][1]!=e[i][1]));\n        swap(e[i][0],e[i][1]);\n        bool sig2=ff[e[i][0]][e[i][1]][0];\n        bool sig3=((ff[e[i][1]][e[i][0]][0]&&ff[e[i][1]][e[i][0]][0]!=e[i][1])||(ff[e[i][1]][e[i][0]][1]&&ff[e[i][1]][e[i][0]][1]!=e[i][1]));\n        sig==sig1&&sig2==sig3?cout<<\"same\"<<endl:cout<<\"diff\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n\ntypedef pair<int, int> P;\n\n#define fir first\n#define sec second\n\nvector<P> G[N];\n\nbool vis[N]; int ct[N][N], wkr[N];\n\nint rt, n, col; \n\nvoid dfs(int u, int type) {\n    if (!type) wkr[u] = col;\n    else if (wkr[u] != col) ct[rt][u] |= 1;\n    vis[u] = 1;\n    for (auto v : G[u]) if (!vis[v.sec]) dfs(v.sec, type);\n}\n\ninline void clr() {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\ninline void solve(int u) {\n    rt = u, clr(), vis[u] = 1;\n    for (auto v : G[u]) if (!vis[v.sec]) dfs(col = v.sec, 0);\n    clr(), vis[u] = 1;\n    for (int i = (int)G[u].size() - 1; i >= 0; i--) if (!vis[G[u][i].sec]) dfs(col = G[u][i].sec, 1);\n    for (int i = 1; i <= n; i++) if (vis[i]) ct[i][u] |= 2;\n}\n\nint ans[N * 20];\n\nint main() {\n    int m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(P(i, b));\n    for (int i = 1; i <= n; i++) solve(i);\n    for (int i = 1; i <= n; i++) for (auto v : G[i]) \n        if (ct[i][v.sec] != 0 && ct[i][v.sec] != 3) ans[v.fir] = 1;\n    for (int i = 1; i <= m; i++) puts(ans[i] ? \"diff\" : \"same\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\n\nvector <int> graph[1001];\n\nvoid addedge(int u,int v)\n{\n\tgraph[u].push_back(v);\n}\n\nint vis[1001][1001];\nstruct\n{\n\tint first,second;\n}edge[200001];\nint mark[1001];\nint times=1;\nint tmp;\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=times;\n\tfor(auto to:graph[now])\n\t{\n\t\tif(to==from)continue;\n\t\tif(vis[from][to]<2&&mark[to]!=times)\n\t\t{\n\t\t\tdfs(from,to);\n\t\t}\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i].first=from;\n\t\tedge[i].second=to;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto to:graph[i])\n\t\t{\n\t\t\tif(vis[i][to]<2)\n\t\t\t{\n\t\t\t\ttimes++;\n\t\t\t\tdfs(i,to);\n\t\t\t}\n\t\t}\n\t}\n\t//return 0;\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n\tstatic const int S=1e7;\n\tchar rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n\tfastio() {rpos=len=wpos=0;}\n\tinline char Getchar()\n\t{\n\t\tif (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n\t\tif (!len) return EOF;\n\t\treturn rbuf[rpos++];\n\t}\n\ttemplate <class T> inline void Get(T &x)\n\t{\n\t\tchar ch;bool f;T res;\n\t\twhile (!isdigit(ch=Getchar()) && ch!='-') {}\n\t\tif (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n\t\twhile (isdigit(ch=Getchar())) res=res*10+ch-'0';\n\t\tx=(f?res:-res);\n\t}\n\tinline void getstring(char *s)\n\t{\n\t\tchar ch;\n\t\twhile ((ch=Getchar())<=32) {}\n\t\tfor (;ch>32;ch=Getchar()) *s++=ch;\n\t\t*s='\\0';\n\t}\n\tinline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n\tinline void Writechar(char ch)\n\t{\n\t\tif (wpos==S) flush();\n\t\twbuf[wpos++]=ch;\n\t}\n\ttemplate <class T> inline void Print(T x,char ch)\n\t{\n\t\tchar s[20];int pt=0;\n\t\tif (x==0) s[++pt]='0';\n\t\telse\n\t\t{\n\t\t\tif (x<0) Writechar('-'),x=-x;\n\t\t\twhile (x) s[++pt]='0'+x%10,x/=10;\n\t\t}\n\t\twhile (pt) Writechar(s[pt--]);\n\t\tWritechar(ch);\n\t}\n\tinline void printstring(char *s)\n\t{\n\t\tint pt=1;\n\t\twhile (s[pt]!='\\0') Writechar(s[pt++]);\n\t}\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ntemplate<typename T> inline int quick_pow(int x,T y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ntemplate<typename T> inline int quick_pow(int x,T y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=1000;\nconst int MAXM=2e5;\n\nint n,m;\nvector<Pair> v[MAXN+48];\nvector<int> vv[MAXN+48];\nbool visited1[MAXN+48],visited2[MAXN+48],visited3[MAXN+48],ok[MAXN+48];\nint ans[MAXM+48];\n\ninline void dfs1(int cur)\n{\n\tvisited1[cur]=true;\n\tfor (register int i=0;i<int(vv[cur].size());i++)\n\t{\n\t\tregister int y=vv[cur][i];\n\t\tif (!visited1[y]) dfs1(y);\n\t}\n}\n\ninline void dfs2(int cur)\n{\n\tvisited2[cur]=true;\n\tfor (register int i=0;i<int(v[cur].size());i++)\n\t{\n\t\tregister int y=v[cur][i].x;\n\t\tif (!visited2[y]) dfs2(y);\n\t}\n}\n\nint main ()\n{\n#ifdef LOCAL\n\tdouble TIME=clock();\n\tfreopen (\"a.in\",\"r\",stdin);\n\tfreopen (\"a.out\",\"w\",stdout);\n\tcerr<<\"Running...\"<<endl;\n#endif\n\tio.Get(n);io.Get(m);int x,y;\n\tfor (register int i=1;i<=m;i++)\n\t{\n\t\tio.Get(x);io.Get(y);\n\t\tv[x].pb(mp(y,i));vv[y].pb(x);\n\t}\n\tfor (register int i=1;i<=n;i++)\n\t{\n\t\tmemset(visited1,false,sizeof(visited1));\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tmemset(ok,false,sizeof(ok));\n\t\tdfs1(i);visited2[i]=true;\n\t\tfor (register int j=0;j<int(v[i].size())-1;j++)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j+1;k<int(v[i].size());k++)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tvisited2[i]=true;\n\t\tfor (register int j=int(v[i].size())-1;j>=1;j--)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j-1;k>=0;k--)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tfor (register int j=0;j<int(v[i].size());j++) ans[v[i][j].y]=(visited1[v[i][j].x]^ok[v[i][j].x]);\n\t}\n\tfor (register int i=1;i<=m;i++) printf(ans[i]?\"diff\\n\":\"same\\n\");\n\tio.flush();\n#ifdef LOCAL\n\tcerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nvector<int> g[maxn];\nint a[maxm], b[maxm];\nint v[maxn][maxn], w[maxn][maxn], vis2[maxn];\nint rt;\n\ninline void add(int a,int b){g[a].push_back(b);}\n\ninline int read()\n{\n\tint ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\ninline void dfs2(int u) {\n\tv[rt][u] = vis2[u] = 1;\n\tfor (auto y: g[u]) {\n\t\tif (!vis2[y]) dfs2(y);\n\t}\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 1; i <= m; ++i) {\n\t\ta[i] = read(), b[i] = read();\n\t\tadd(a[i], b[i]);\n\t}\n\tfor (rt = 1; rt <= n; ++rt) {\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis2[rt] = 1;\n\t\tfor (auto x: g[rt]) {\n\t\t\tif (!vis2[x]) dfs2(x);\n\t\t\telse w[rt][x] = 1;\n\t\t}\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\treverse(g[rt].begin(), g[rt].end());\n\t\tfor (auto x: g[rt]) {\n\t\t\tif (!vis2[x]) dfs2(x);\n\t\t\telse w[rt][x] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tputs(v[b[i]][a[i]]^w[a[i]][b[i]]?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  UnWeightedGraph gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n    for (int i = 0; i < g.size(); i++)\n    {\n        sort(gg[i].begin(),gg[i].end());\n        sort(rg[i].begin(),rg[i].end());\n    }\n  }\n\n  void revEdge(int a, int b){\n      auto itrgg_erase = lower_bound(gg[a].begin(),gg[a].end(),b);\n      gg[a].erase(itrgg_erase);\n      auto itrrg_erase = lower_bound(rg[b].begin(),rg[b].end(),a);\n      rg[b].erase(itrrg_erase);\n      auto itrgg_insert = lower_bound(gg[b].begin(),gg[b].end(),a);\n      gg[b].insert(itrgg_insert,a);\n      auto itrrg_insert = lower_bound(rg[a].begin(),rg[a].end(),b);\n      rg[a].insert(itrrg_insert,b);\n  }\n\n  int operator[](int k) {\n    return comp[k];\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(UnWeightedGraph &t) {\n    order.clear();\n    fill(comp.begin(),comp.end(),-1);\n    fill(used.begin(),used.end(), 0);\n    \n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      for(auto &to : g[i]) {\n        int x = comp[i], y = comp[to];\n        if(x == y) continue;\n        t[x].push_back(y);\n      }\n    }\n  }\n};\n\n\nint N;\nll M;\nvector<ll> A,B;\nUnWeightedGraph g, revG;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N >> M;\n    g.resize(N);\n    revG.resize(N);\n    for (int i = 0; i < M; i++)\n    {\n        int a,b;\n        cin >> a >> b;\n        a--;\n        b--;\n        A.push_back(a);\n        B.push_back(b);\n        g[a].emplace_back(b);\n    }\n    \n}\n\nint TLEsolve(){\n    StronglyConnectedComponents< UnWeightedGraph > scc(g);\n    UnWeightedGraph buff;\n    scc.build(buff);\n    int cntG=0;\n    vector<bool> seen(N);\n    for (int i = 0; i < N; i++)\n    {\n        if(!seen[scc[i]]) cntG++;\n        seen[scc[i]] = true;\n    }\n    DBG(cntG)\n    for (int i = 0; i < M; i++)\n    {\n        // StronglyConnectedComponents< UnWeightedGraph > sccrev(g);\n        // strcpy(sccrev,scc);\n        scc.revEdge(A[i],B[i]);\n        scc.build(buff);\n        int cntrevG=0;\n        vector<bool> seen_revG(N);\n        for (int i = 0; i < N; i++)\n        {\n            if(!seen_revG[scc[i]]) cntrevG++;\n            seen_revG[scc[i]] = true;\n        }\n        if(cntG==cntrevG) cout << \"same\" << \"\\n\";\n        else cout << \"diff\" << \"\\n\";\n        scc.revEdge(B[i],A[i]);\n    }\n    \n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nint N, M;\nvector <int> E[1010], F[1010];\nint X[1010][2], save[1010][2];\nint idx[1010][1010];\nint dif[200020];\nvector <int> v;\nint svis[1010], scc[1010], sid;\n\nvoid dfs1(int x) {\n\tsvis[x] = 1;\n\tfor(int e : E[x]) if(svis[e] == 0) {\n\t\tdfs1(e);\n\t}\n\tv.pb(x);\n}\n\nvoid dfs2(int x) {\n\tscc[x] = sid;\n\tsvis[x] = 2;\n\tfor(int e : F[x]) if(svis[e] == 1) {\n\t\tdfs2(e);\n\t}\n}\n\npii edge[200020];\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i=1;i<=M;i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(y); F[y].pb(x);\n\t\tidx[x][y] = i;\n\t\tedge[i] = pii(x, y);\n\t}\n\tfor(int i=1;i<=N;i++) {\n\t\tmemset(X, 0, sizeof X);\n\t\tmemset(save, 0, sizeof save);\n\t\tvector <pii> q;\n\t\tfor(int e : E[i]) {\n\t\t\tsave[e][0] = e;\n\t\t\tq.pb(pii(e, 0));\n\t\t}\n\t\trep(j, szz(q)) {\n\t\t\tpii t = q[j];\n\t\t\tif(t.Fi == i) continue;\n\t\t\tint p = save[t.Fi][t.Se];\n\t\t\tfor(int e : E[t.Fi]) {\n\t\t\t\tif(save[e][0] == 0) {\n\t\t\t\t\tsave[e][0] = p;\n\t\t\t\t\tq.pb(pii(e, 0));\n\t\t\t\t}\n\t\t\t\telse if(save[e][1] == 0 && save[e][0] != p) {\n\t\t\t\t\tsave[e][1] = p;\n\t\t\t\t\tq.pb(pii(e, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int e : E[i]) {\n\t\t\tif(save[e][1]) {\n\t\t\t\tdif[idx[i][e]] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) if(svis[i] == 0) dfs1(i);\n\treverse(all(v));\n\tfor(int e : v) if(svis[e] == 1) {\n\t\t++sid; dfs2(e);\n\t}\n\t\n\tfor(int i=1;i<=M;i++) {\n\t\tint x = edge[i].Fi, y = edge[i].Se;\n\t\tif((scc[x] == scc[y]) ^ dif[i]) puts(\"diff\");\n\t\telse puts(\"same\");\n\t//\tprintf(\"%d\\n\", dif[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint ans[200010];\nvector<int> adj[1010], radj[1010], sadj[1010], U, V;\nint tin[1010], bck[1010], id[1010], timer, scnt;\nstack<int> stk;\n\nvoid dfs(int u) {\n    tin[u] = timer++;\n    bck[u] = tin[u];\n    stk.push(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int e = adj[u][i];\n        int v = V[e];\n        if(tin[v] == -1) {\n            dfs(v);\n            bck[u] = min(bck[u], bck[v]);\n        }\n        else if(id[v] == -1) {\n            bck[u] = min(bck[u], tin[v]);\n        }\n    }\n    if(bck[u] == tin[u]) {\n        while(1) {\n            int t = stk.top(); stk.pop();\n            id[t] = scnt;\n            if(t == u) break;\n        }\n        scnt++;\n    }\n}\n\nint cc[1010][1010];\nint dp(int u, int d) {\n    int &ret = cc[u][d];\n    if(ret != -1) return ret;\n    if(u == d) return ret = 0;\n\n    ret = 0;\n    for(int i = 0; i < sadj[u].size(); i++) {\n        int e = sadj[u][i];\n        int v = id[ V[e] ];\n        ret = max(ret, 1 + dp(v, d));\n    }\n    return ret;\n}\n\nint Cnt[1010][1010];\n\nvoid scc() {\n    memset(tin, -1, sizeof(tin));\n    memset(id, -1, sizeof(id));\n    for(int i = 0; i < N; i++) if(tin[i] == -1) {\n        dfs(i);\n    }\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            sadj[ id[u] ].push_back(e);\n            Cnt[ id[u] ][ id[v] ]++;\n        }\n    }\n    memset(cc, -1, sizeof(cc));\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            if(Cnt[ id[u] ][ id[v] ] > 1 || dp(id[u], id[v]) > 1) ans[e] = 1;\n            else ans[e] = 0;\n        }\n    }\n}\n\nqueue<int> q1, q2;\nint dist1[1010], dist2[1010], par1[1010], par2[1010];\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < M; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(i);\n        radj[v].push_back(i);\n        U.push_back(u);\n        V.push_back(v);\n    }\n\n    scc();\n\n    for(int u = 0; u < N; u++) {\n        memset(dist1, -1, sizeof(dist1));\n        memset(dist2, -1, sizeof(dist2));\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                q1.push(v);\n                dist1[v] = 0;\n                par1[v] = v;\n            }\n        }\n        while(!q1.empty()) {\n            int t = q1.front(); q1.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist1[v] == -1) {\n                        dist1[v] = dist1[t] + 1;\n                        par1[v] = par1[t];\n                        q1.push(v);\n                    }\n                    else if(dist2[v] == -1 && par1[v] != par1[t]) {\n                        dist2[v] = dist1[t] + 1;\n                        par2[v] = par1[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n        while(!q2.empty()) {\n            int t = q2.front(); q2.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist2[v] == -1 && par1[v] != par2[t]) {\n                        dist2[v] = dist2[t] + 1;\n                        par2[v] = par2[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                if(dist2[v] != -1) ans[e] = 0;\n                else ans[e] = 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++) {\n        if(ans[i]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,m;\nvvi cost,out;\nvvp G;\nvi used,t;\nvoid dfs(int a,int no){\n\tused[a]=true;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i].first;\n\t\tif(!used[to]&&a-no)dfs(to,no);\n\t}\n}\nvoid f(int a){\n\tused=vi(n);\n\trep(i,t.size()){\n\t\tif(used[G[a][t[i]].first])out[G[a][t[i]].second][0]=1;\n\t\telse dfs(G[a][t[i]].first,a);\n\t}\n}\nsigned main(){\n\tcin>>n>>m;\n\tG=vvp(n);\n\tcost=vvi(n,vi(n));\n\trep(i,n)cost[i][i]=1;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tcost[a][b]=1;\n\t\tG[a].pb({b,i});\n\t}\n\tout=vvi(m,vi(2));\n\trep(k,n)rep(i,n)rep(j,n)\n\t\tcost[i][j]|=cost[i][k]&cost[k][j];\n\trep(i,n)rep(j,G[i].size())out[G[i][j].second][1]=cost[G[i][j].first][i];\n\trep(i,n){\n\t\tt=vi(G[i].size());\n\t\trep(j,t.size())t[j]=j;\n\t\tf(i);\n\t\treverse(all(t));\n\t\tf(i);\n\t}\n\trep(i,m)if(out[i][0]^out[i][1])cout<<\"diff\"<<endl;\n\telse cout<<\"same\"<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 1005;\nconst int Maxm = 200005;\n\nint n, m;\nint a[Maxm], b[Maxm];\nvector <ii> neigh[Maxn];\nint cur, tim[Maxn], low[Maxn];\nint imp[Maxm];\nint my[Maxn];\nvector <int> S;\nbool onStack[Maxn];\nint curcol, col[Maxn];\nint res[Maxm];\nint dp[Maxn];\nvector <int> gneigh[Maxn];\nbool vis[Maxn];\nmap <ii, int> M;\n\nint Connect(int v)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tmy[v] = -1;\n\tS.push_back(v); onStack[v] = true;\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (!tim[u.first]) {\n\t\t\timp[u.second] |= 2;\n\t\t\tres += Connect(u.first); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v]) {\n\t\t\tif (my[v] != -1) imp[my[v]] ^= 1;\n\t\t\tlow[v] = tim[u.first];\n\t\t\timp[u.second] ^= 1; \n\t\t\tmy[v] = u.second;\n\t\t}\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tcurcol++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tcol[w] = curcol;\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int v, int forb)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tS.push_back(v); onStack[v] = true;\n\tif (v == b[forb]) {\n\t\tint u = a[forb];\n\t\tif (!tim[u]) {\n\t\t\tres += Count(u, forb); low[v] = min(low[v], low[u]); \n\t\t} else if (onStack[u] && tim[u] < low[u])\n\t\t\tlow[u] = tim[u];\n\t}\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (u.second == forb) continue;\n\t\tif (!tim[u.first]) {\n\t\t\tres += Count(u.first, forb); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v])\n\t\t\tlow[v] = tim[u.first];\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int forb)\n{\n\tint ans = 0;\n\tfill(tim, tim + Maxn, 0); fill(low, low + Maxn, 0);\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tans += Count(i, forb);\n\treturn ans; \n}\n\nint Visit(int v)\n{\n\tif (vis[v]) return dp[v];\n\tint res = 0;\n\tfor (int i = 0; i < gneigh[v].size(); i++)\n\t\tres = max(res, Visit(gneigh[v][i]) + 1);\n\tdp[v] = res; vis[v] = true;\n\treturn dp[v];\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\", &a[i], &b[i]);\n\t\tneigh[a[i]].push_back(ii(b[i], i));\n\t}\n\tint comp = 0;\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tcomp += Connect(i);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (col[a[i]] != col[b[i]]) {\n\t\t\tgneigh[col[a[i]]].push_back(col[b[i]]);\n\t\t\tM[ii(col[a[i]], col[b[i]])]++;\n\t\t\tif (imp[i]) res[i] = Count(i) != comp;\n\t\t} else if (imp[i]) res[i] = Count(i) != comp;\n\tfor (int i = 1; i <= curcol; i++)\n\t\tVisit(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!imp[i] && col[a[i]] != col[b[i]]) {\n\t\t\tres[i] = abs(dp[col[a[i]]] - dp[col[b[i]]]) > 1;\n\t\t\tif (M[ii(col[a[i]], col[b[i]])] > 1) res[i] = 1;\n\t\t}\n\t\tprintf(\"%s\\n\", res[i]? \"diff\": \"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[N],vi[N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vis[0][rt][v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++) dfs_vis(i,i);\n}\n\nvoid dfs_sol(LL u,LL col,LL pid,LL rt){\n\tif(pid) vis[1][rt][u] = (p[u] != col);\n\telse p[u] = col;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vi[v]) continue;\n\t\tdfs_sol(v,col,pid,rt);\n\t}\n}\n\nvoid solve(LL u){\n\tmemset(p,0,sizeof(p));\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!vi[ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,0,u);\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!vi[ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,1,u);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(i);\n\t}\n\tget_vis(); memset(vis,0,sizeof(vis));\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n//\tfor(LL i = 1;i <= m;i ++) cout << ans[0][i] << ' ' << ans[1][i] << endl;\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n\n2 2\n1 2\n2 1\n\n3 3\n1 2\n1 3\n2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define N 1005\n#define bit(x,y) ((x>>y)&1LL)\n#define loop(i,l,r) for(int i=(signed)(l); i<=(signed)(r); i++)\n\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &a) {\n    return os << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    for (unsigned int i = 0; i < a.size(); i++)\n        os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n    os << ']';\n    return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &a) {\n    os << '{';\n    for (typename set<T>::iterator it = a.begin(); it != a.end(); it++) {\n        typename set<T>::iterator jt = it;\n        os << *it << (++jt != a.end() ? \", \" : \"\");\n    }\n    os << '}';\n    return os;\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, map<T1, T2> &a) {\n    os << \"{\\n\";\n    for (typename map<T1, T2>::iterator it = a.begin(); it != a.end(); it++) {\n        typename map<T1, T2>::iterator jt = it;\n        os << \"  \" << it->first << \": \" << it->second << (++jt != a.end() ? \",\\n\" : \"\\n\");\n    }\n    os << '}';\n    return os;\n}\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint cnt[N][N];\nint mark[N][N];\nbool ansOrder[200005];\n\nvoid dfs(int u, int p, const int root, const int source) {\n    if (u == root) return;\n    if (cnt[root][u] >= 2) return;\n    if (cnt[root][u] == 1 && mark[root][u] == source) return;\n    cnt[root][u]++; mark[root][u] = source;\n    for (auto it : a[u]) {\n        int v = it.fi;\n        if (v == p) continue;\n        dfs(v, u, root, source);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    loop(i, 1, m) {\n        int u, v; cin >> u >> v;\n        a[u].push_back(mp(v, i));\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            dfs(v, u, u, v);\n        }\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            bool diff = false;\n            if (cnt[u][v] >= 2) {\n                if (cnt[v][u] == 0) diff = true;\n            }\n            else if (cnt[u][v] == 1) {\n                if (cnt[v][u] >= 1) diff = true;\n            }\n            ansOrder[it.se] = diff;\n        }\n    }\n    loop(i, 1, m) {\n        if (ansOrder[i] == false) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1005\n#define M 200005\nusing namespace std;\n\nint n,m;\nbool irp[N][N],lnk[N][N];\nint rt,cnt,fir[N];\nbool col[N];\nvector<int>to[N];\nstruct edge{int u,v;}e[M];\n\ninline int read()\n{\n\tint ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\ninline void add(int a,int b){to[a].push_back(b);e[++cnt]=(edge){a,b};}\n\ninline void dfs(int x)\n{\n\tcol[x]=lnk[rt][x]=1;\n\tfor(auto it:to[x]) if(!col[it]) dfs(it);\n}\n\ninline void insert(int x)\n{\n\trt=x;\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n\treverse(to[x].begin(),to[x].end());\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n}\n\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint a=read(),b=read();\n\t\tadd(a,b);\n\t}return 0;\n\tfor(int i=1;i<=n;++i)insert(i);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x=e[i].u,y=e[i].v;\n\t\tputs(irp[x][y]^lnk[y][x]?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\ninline int qread(){\n\tint x=0,sign=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') sign=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*sign;\n}\nint n,m; \nstruct edge{\n\tint from;\n\tint to;\n\tint next;\n}E[maxm];\nint sz=0; \nint head[maxn];\nvoid add_edge(int u,int v){\n\tsz++;\n\tE[sz].from=u;\n\tE[sz].to=v;\n\tE[sz].next=head[u];\n\thead[u]=sz;\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tint y;\n\tused[x]=1;\n\troute[s][x]++;\n\tfor(int i=head[x];i;i=E[i].next){\n\t\ty=E[i].to;\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nchar a[]=\"same\",b[]=\"diff\";\nvoid qprint(char *s,int len){\n\tfor(int i=0;i<len;i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('\\n');\n}\nint main(){\n//\tscanf(\"%d %d\",&n,&m);\n\tn=qread();\n\tm=qread(); \n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n//\t\tscanf(\"%d %d\",&u,&v);\n\t\tu=qread();\n\t\tv=qread();\n\t\tadd_edge(u,v);\n\t}\n\tint y;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=head[i];j;j=E[j].next){\n\t\t\ty=E[j].to;\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(E[i].from,E[i].to)) qprint(b,4);\n\t\telse qprint(a,4);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1003,M=200005;\nusing namespace std;\nint n,m,eu[M],ev[M],u,st[N],t;\nbool mp[N][N],rc[N][N],vis[N];\nvector<int>ed[N];\nvoid dfs(int x){\n\tif(!mp[u][x]){\n\t\tmp[u][x]=1;\n\t\tfor(int i:ed[x])dfs(i);\n\t}\n}\nvoid dfss(int x){\n\tif(x^u&&!vis[x]){\n\t\tvis[x]=1;\n\t\tfor(int i:ed[x])dfss(i);\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++)\n\tscanf(\"%d%d\",eu+i,ev+i),\n\ted[eu[i]].push_back(ev[i]);\n\tfor(int i=1;i<=n;i++)dfs(u=i);\n\tfor(int i=1;i<=n;i++){\n\t\tu=i,t=0;\n\t\tfor(int j:ed[i]){\n\t\t\trc[i][j]=vis[j];\n\t\t\tdfss(st[++t]=j);\n\t\t}\n\t\tfor(int j=1;j<=n;j++)vis[j]=0;\n\t\tfor(int j=t;j;j--)\n\t\trc[i][st[j]]|=vis[st[j]],dfss(st[j]);\n\t\tfor(int j=1;j<=n;j++)vis[j]=0;\n\t}\n\tfor(int i=0;i<m;i++)\n\tputs(mp[ev[i]][eu[i]]^rc[eu[i]][ev[i]]\n\t?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <tuple>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n#define to_pair(x, y) ((x) << 10 | (y))\n\nusing namespace std;\nusing ll = long long;\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\nvector< vector<int> > e, re;\n\nUnionFind cc(1024);\nUnionFind scc(1024);\nint post[1024];\nint rev[1024];\nbool visited[1024];\nbool visited2[1024];\n\nint t = 1;\n\nvoid dfs0(int u, int r) {\n    cc.unite(u, r);\n    post[u] = 1;  // dummy\n    for (int w : e[u]) {\n        if (!post[w]) {\n            dfs0(w, r);\n        }\n    }\n    post[u] = t;\n    rev[t] = u;\n    ++t;\n}\n\nvoid dfs1(int u, int r, int cr, bool visited[]) {\n    scc.unite(u, r);\n    visited[u] = true;\n    for (int w : re[u]) {\n        if (cc.find(w) != cr) {\n            continue;\n        }\n        if (!visited[w]) {\n            dfs1(w, r, cr, visited);\n        }\n    }\n}\n\nvoid dfs2(int u, int r, int first, unordered_set<int>& rs, bool visited[]) {\n    visited[u] = true;\n    for (int w : e[u]) {\n        if (!visited[w]) {\n            dfs2(w, r, first, rs, visited);\n        } else if (w != r && w != first) {\n            rs.insert(to_pair(r, w));\n        }\n    }\n}\n\nvoid traverse(int n, int s, unordered_set<int>& rs) {\n    fill(visited2, visited2 + n + 1, false);\n    visited2[s] = true;\n    for (int w : e[s]) {\n        visited2[w] = true;\n    }\n    for (int w : e[s]) {\n        dfs2(w, s, w, rs, visited2);\n    }\n}\n\nvoid solve(int n, int m, vector< pair<int, int> >& edges) {\n    int cur;\n    int r1, cr;\n\n    fill(post, post + n + 1, 0);\n    fill(rev, rev + n + 1, 0);\n\n    fill(visited, visited + n + 1, false);\n    rep(r, 1, n + 1) {\n        if (!post[r]) {\n            cur = t;\n            dfs0(r, r);\n            cr = cc.find(r);\n            for (int v = t - 1; v >= cur; --v) {\n                r1 = rev[v];\n                if (!visited[r1]) {\n                    dfs1(r1, r1, cr, visited);\n                }\n            }\n        }\n    }\n\n    unordered_set<int> path_exists;\n    int a, b;\n    int scc_a, scc_b;\n    bool exist;\n    \n    fill(visited, visited + n + 1, false);\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        if (!visited[a]) {\n            visited[a] = true;\n            traverse(n, a, path_exists);\n        }\n    }\n\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        scc_a = scc.find(a);\n        scc_b = scc.find(b);\n        exist = (path_exists.find(to_pair(a, b)) != path_exists.end());\n        cout << ((scc_a == scc_b) ^ exist ? \"diff\" : \"same\") << endl;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n\n    int n, m;\n    int a, b;\n    vector< pair<int, int> > edges;\n    \n    cin >> n >> m;\n    e.resize(n + 1);\n    re.resize(n + 1);\n    rep(i, 0, m) {\n        cin >> a >> b;\n        edges.push_back(make_pair(a, b));\n        e[a].push_back(b);\n        re[b].push_back(a);\n    }\n\n    solve(n, m, edges);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m;\nvector<int>e[1005]; vector<P>E;\ndouble cur ;\nbool used[1005];\nbool dfs(int v,int x,int y){\n\tif(v == y) return true;\n\tif(used[v]) return false; used[v] = 1;\n\tif(clock()-cur >= 4.9*CLOCKS_PER_SEC / m){\n\t\treturn false;\n\t}\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(v==x&&e[v][i]==y) continue;\n\t\tif(dfs(e[v][i],x,y)) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\te[a].push_back(b); E.pb(mp(a,b));\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; a = E[i].fi, b = E[i].sc;\n\t\tcur = clock(); memset(used,0,sizeof(used));\n\t\tbool flag = dfs(a,a,b);\n\t\tputs(flag?\"same\":\"diff\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=200010, inf=2e9;\n\nint n, m;\nbool ans[MX];\npii E[MX];\n\nvector<pii> G[1010];\nint D[1010][1010][2];\n\nvoid dfs3(int v, int st, int idx){\n    if(D[st][v][0]==0) D[st][v][0]=idx;\n    else D[st][v][1]=idx;\n    for(pii &e:G[v]){\n        int x=e.first;\n        if(D[st][x][0]!=0 && D[st][x][1]!=0) continue;\n        if(D[st][x][0]==idx || D[st][x][1]==idx) continue;\n        dfs3(x,st,idx);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>m;\n    for(int i=1; i<=m; i++){\n        int u,v; cin>>u>>v;\n        E[i]={u,v};\n        G[u].push_back({v,i});\n    }\n\n    for(int v=1; v<=n; v++){\n        D[v][v][0]=D[v][v][1]=-1;\n        for(pii &p:G[v]){\n            int x,idx; tie(x,idx)=p;\n            if(D[v][x][0]!=0 && D[v][x][1]!=0) continue;\n            dfs3(x,v,idx);\n        }\n    }\n\n    for(int i=1; i<=m; i++){\n        int u,v; tie(u,v)=E[i];\n        ans[i] = !(D[u][v][0]==i && D[u][v][1]==0) ^ (D[v][u][0]==0);\n    }\n    for(int i=1; i<=m; i++) cout<<(ans[i] ? \"same\" : \"diff\")<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[200001];\nint n,m,op[1001][1001],a[200001],b[200001];\ninline void read(int &x){\n\tint a;scanf(\"%d\",&a);x=a;\n}\nbool visit[1001]={false};\nvoid dfs(int u,int c){//cout<<u<<\" \";\n\tvisit[u]=true;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(!visit[v]){\n\t\t\top[c][v]++;\n\t\t\tdfs(v,c);\n\t\t}\n\t}\n\tvisit[u]=false;\n}\nint main(){\n\tread(n);read(m);\n\tfor(int i=1;i<=m;i++){\n\t\tread(a[i]);read(b[i]);\n\t\tg[a[i]].push_back(b[i]);\n\t}\n\tfor(int i=1;i<=n;i++)dfs(i,i);\n\tfor(int i=1;i<=m;i++){\n\t\tif(op[a[i]][b[i]]&&op[b[i]][a[i]]){//qlt\n\t\t\tif(op[a[i]][b[i]]==1)printf(\"diff\\n\");\n\t\t\telse printf(\"same\\n\");\n\t\t}\n\t\telse{//bqlt\n\t\t\tif(op[a[i]][b[i]]==1)printf(\"same\\n\");\n\t\t\telse printf(\"diff\\n\");\n\t\t}\n\t}\n} //"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\ts[++top]=e[p].k;\n\t\t\tif(vis[i][e[p].k]) continue;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=0;\n\t\t}\n\t\tint mn=1;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\ttemp[p]=vis[i][p];\n\t\t\tif(!temp[p]) mn=p;\n\t\t}\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>mn;p--){\n\t\t\tif(vis[i][s[p]]) continue;\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\nint n,m; \nstruct edge{\n\tint from;\n\tint to;\n\tint next;\n}E[maxm];\nint sz=0; \nint head[maxn];\nvoid add_edge(int u,int v){\n\tsz++;\n\tE[sz].from=u;\n\tE[sz].to=v;\n\tE[sz].next=head[u];\n\thead[u]=sz;\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tused[x]=1;\n\troute[s][x]++;\n\tfor(int i=head[x];i;i=E[i].next){\n\t\tint y=E[i].to;\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tadd_edge(u,v);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=head[i];j;j=E[j].next){\n\t\t\tint y=E[j].to;\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(E[i].from,E[i].to)) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e3+20;\n\nvector<int>ed[maxn];\n\nint n,m;\nint f[maxn][maxn];\nint rt,D;\nint g[maxn][maxn];\nint vis[maxn];\nint A[maxn],B[maxn];\nint graph[maxn][maxn];\n\nvoid bfs(int S)\n{\n\tf[rt][S]=1;\n\tqueue<int>q;\n\tq.push(S);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();q.pop();\n\t\tfor(int v:ed[u])\n\t\t{\n\t\t\tif(!f[rt][v])\n\t\t\t{\n\t\t\t\tf[rt][v]=1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstruct Edge {\n\tint u,v;\n};\nEdge E[200020];\n\nvoid dfs1(int u)\n{\n\tvis[u]=D;\n\tfor(int v:ed[u])\n\t{\n\t\tif(vis[v])continue;\n\t\tdfs1(v);\n\t}\n}\n\ninline void init()\n{\n\tn=read(); m=read();\n\tREP(i,1,m)\n\t{\n\t\tint u=read(),v=read();\n\t\tE[i]=(Edge){u,v};\n\t\ted[u].push_back(v);\n\t\tgraph[u][v]=1;\n\t}\n\tREP(u,1,n)\n\t{\n\t\trt=u;\n\t\tbfs(u);\n\t}\n\tcerr<<(double)clock()/CLOCKS_PER_SEC<<endl;\n\tREP(u,1,n)\n\t{\n\t\tstatic int st[maxn],top; top=0;\n\t\tfor(int v:ed[u])st[++top]=v;\n\t\tmemset(vis,0,sizeof(int)*(n+1));\n\t\tvis[u]=top+1;\n\t\tREP(j,1,top)\n\t\t{\n\t\t\tD=j;\n\t\t\tif(!vis[st[j]])dfs1(st[j]);\n\t\t}\n\t\tmemcpy(A,vis,sizeof(int)*(n+1));\n\t\tmemset(vis,0,sizeof(int)*(n+1));\n\t\tvis[u]=top+1;\n\t\tDREP(j,top,1)\n\t\t{\n\t\t\tD=j;\n\t\t\tif(!vis[st[j]])dfs1(st[j]);\n\t\t}\n\t\tmemcpy(B,vis,sizeof(int)*(n+1));\n\t\tREP(j,1,top)if(A[st[j]]!=B[st[j]])g[u][st[j]]=1;\n\t\t\n\t}\n}\n\ninline void doing()\n{\n\tREP(i,1,m)\n\t{\n\t\tint u=E[i].u,v=E[i].v;\n\t\tif(f[v][u]^(g[u][v]))puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n大毒瘤！\nvector比邻接表快十倍！\nvector比邻接表快十倍！\nvector比邻接表快十倍！\nvector比邻接表快十倍！\nvector比邻接表快十倍！\n*/\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\n\nvector <int> graph[1001];\n\nvoid addedge(int u,int v)\n{\n\tgraph[u].push_back(v);\n}\n\nint vis[1001][1001];\nstruct\n{\n\tint first,second;\n}edge[200001];\nint mark[1001];\nint times=1;\nint tmp;\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=times;\n\tfor(auto to:graph[now])\n\t{\n\t\tif(to==from)continue;\n\t\tif(vis[from][to]<2&&mark[to]!=times)\n\t\t{\n\t\t\tdfs(from,to);\n\t\t}\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i].first=from;\n\t\tedge[i].second=to;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto to:graph[i])\n\t\t{\n\t\t\tif(vis[i][to]<2)\n\t\t\t{\n\t\t\t\ttimes++;\n\t\t\t\tdfs(i,to);\n\t\t\t}\n\t\t}\n\t}\n\t//return 0;\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxm 200010\n#define maxn 1010\nusing namespace std;\ntypedef long long LL;\nstruct Edge {\n    int from, to, ne;\n}edge[maxm];\nint head[maxn], ne[maxm], pre[maxm], T, tot;\nbool flag[maxn][maxn];\nint f1[maxn][maxn], f2[maxn][maxn], vis[maxn<<1];\nvoid add(int u, int v) {\n    if (~ne[u]) pre[ne[u]] = tot;\n    else head[u] = tot;\n    edge[tot] = {u, v, ne[u]};\n    ne[u] = tot++;\n}\nvoid dfs1(int src, int u) {\n    flag[src][u] = true; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v] != T) dfs1(src, v);\n    }\n}\nvoid dfs2(int src, int exc, int u, int f[maxn][maxn]) {\n    if (~f[exc][u]) return;\n    f[exc][u] = src; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v]!=T && v!=exc) dfs2(src, exc, v, f);\n    }\n}\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    int n, m;\n    memset(ne, -1, sizeof ne);\n    memset(head, -1, sizeof head);\n    memset(f1, -1, sizeof f1);\n    memset(f2, -1, sizeof f2);\n    scanf(\"%d%d\", &n, &m);\n    F(i, 0, m) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u, v);\n    }\n//    F2(i, 1, n) printf(\"%d\\n\", head[i]);\n//    F(i, 0, m) printf(\"%d\\n\", pre[i]);\n//    F2(i, 1, n) {\n//        ++T; dfs1(i, i);\n//    }\n    F2(i, 1, n) {\n        ++T;\n        for (int j = ne[i]; ~j; j = edge[j].ne) {\n            int v = edge[j].to;\n            dfs2(j, i, edge[j].to, f1);\n        }\n        if (head[i]==-1) continue;\n        ++T;\n        for (int j = head[i]; ; j = pre[j]) {\n//            printf(\"dfs2 : %d %d\\n\", i, j);\n            int v = edge[j].to;\n            dfs2(j, i, edge[j].to, f2);\n            if (j==ne[i]) break;\n        }\n    }\n\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", flag[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f1[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f2[i][j]); puts(\"\");\n//    }\n    F(i, 0, m) {\n        int u=edge[i].from, v=edge[i].to;\n        if (f1[v][u]!=-1 ^ (f1[u][v]!=i||f2[u][v]!=i)) puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{edge*nx;int t;}e[MM*3+5],*h[MN+5],*r[MN+5],*c[MN+5];\nint en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(edge**h,int x,int y){e[++en]=(edge){h[x],y};h[x]=e+en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)\n\t\tif(!d[i->t])dfs(i->t),l[x]=min(l[x],l[i->t]);\n\t\telse if(inz[i->t])l[x]=min(l[x],d[i->t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(edge**h,int x,int z)\n{\n\tu[x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)if(!u[i->t])d1(h,i->t,z),uu[i-e>>1]|=z;\n}\nvoid d2(edge**h,int x,int d,int xs,int ys)\n{\n\tint i;\n\tfor(u[q[i=qn=0]=x]=1;i<=qn;++i)\n\t{\n\t\tfor(edge*j=h[q[i]];j;j=j->nx)if((j-e>>1)!=d&&!u[j->t])u[q[++qn]=j->t]=1;\n\t\tif(q[i]==xs&&!u[ys])u[q[++qn]=ys]=1;\n\t}\n}\nint main()\n{\n\tint n=read(),m=read(),i,j;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tmemset(h,0,sizeof(h));memset(r,0,sizeof(r));en=1;\n\tfor(i=1;i<=m;++i)if(p[x[i]]==p[y[i]])ins(h,x[i],y[i]),ins(r,y[i],x[i]);else en+=2;\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(edge*k=c[q[j]];k;k=k->nx)if(!g[i][k->t]++)q[++qn]=k->t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i]&1)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,ph[p[x[i]]],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i]&2)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,ph[p[x[i]]],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],z[M],vis[N],p[N][N],q[N][N];\nvector<int> e[N];\nvoid dfs(int st,int u){\n\tvis[u]=1; a[st][u]=1;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs(st,v);\n\t}\n}\nvoid dfs1(int st,int u,int id){\n\tvis[u]=1; p[st][u]=id;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs1(st,v,id);\n\t}\n}\nvoid dfs2(int st,int u,int id){\n\tvis[u]=1; q[st][u]=id;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs2(st,v,id);\n\t}\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read(); z[i]=(int)e[x[i]].size();\n\t\te[x[i]].push_back(y[i]);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(i,i);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\trep (j,0,(int)e[i].size()-1) if (!vis[e[i][j]]) dfs1(i,e[i][j],j);\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\tper (j,(int)e[i].size()-1,0) if (!vis[e[i][j]]){\n\t\t\tdfs2(i,e[i][j],j);\n\t\t}\n\t}\n\t//printf(\"%d\\n\",a[3][1]);\n\t//printf(\"%d %d\\n\",p[1][3],q[1][3]);\n\t//printf(\"%d\\n\",a[4][3]);\n\t//printf(\"%d %d\\n\",p[3][4],q[3][4]);\n\trep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]];\n\t\tbool f2=p[x[i]][y[i]]!=z[i] || q[x[i]][y[i]]!=z[i];\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define N 800002\ntypedef long long ll;\nvector<int>v[N];\nint n,m,a[N][2],rt,id[1002][1002],ie[1002][1002];\nbool re[1002][1002],ve[1002][1002],nx[1002][1002];\nvoid dfs(int te)\n{\n\tfor(int i=0;i<v[te].size();i++)\n\t{\n\t\tint j=v[te][i];\n\t\tif(!re[rt][j])re[rt][j]=1,dfs(j);\n\t}\n}\nvoid df55(int te,int ti)\n{//printf(\"%d \",te);\n\tfor(int i=0;i<v[te].size();i++)\n\t{\n\t\tint j=v[te][i];if(te==rt)ti=i+1;\n\t\tif(!id[rt][j])id[rt][j]=ti,df55(j,ti);\n\t\telse id[rt][j]=min(id[rt][j],ti);\n\t}\n}\nvoid df5(int te,int ti)\n{//printf(\"%d \",te);\n\tfor(int i=((int)v[te].size())-1;~i;i--)\n\t{\n\t\tint j=v[te][i];if(te==rt)ti=i+1;\n\t\tif(!ie[rt][j])ie[rt][j]=ti,df5(j,ti);\n\t\telse ie[rt][j]=max(ie[rt][j],ti);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);v[x].push_back(y);\n\t\ta[i][0]=x,a[i][1]=y;ve[x][y]=1;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\trt=i,re[rt][rt]=1,dfs(i);df55(i,0);\n\t\tdf5(i,0);\n\t\tfor(int j=1;j<=n;j++)nx[i][j]=(id[i][j]!=ie[i][j]);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(re[a[i][1]][a[i][0]]^nx[a[i][0]][a[i][1]])puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\nstruct bian{int nxt,to;}bi[200020];\nint n,m,head[1010],num,b[200020][2];\ninline void add(int from,int to){bi[++num]=bian{head[from],to};head[from]=num;}\nbool vis[1010],f[200020][2];\nint q[1010],h,t,l[1010],r[1010];\nint st[1010],tp;\nvoid work(int v)\n{\n\ttp=0;\n\tfor(int i=head[v];i;i=bi[i].nxt)st[++tp]=bi[i].to;\n\tint x,y;\n\tmemset(vis+1,0,n);vis[v]=1;\n\tfor(int i=1;i<=tp;++i)\n\t\tif(!vis[x=st[i]])\n\t\t{\n\t\t\th=0,t=1,q[t]=x,vis[x]=1,l[x]=i;\n\t\t\twhile(h<t)\n\t\t\t{\n\t\t\t\tx=q[++h];\n\t\t\t\tfor(int j=head[x];j;j=bi[j].nxt)\n\t\t\t\t{\n\t\t\t\t\ty=bi[j].to;\n\t\t\t\t\tif(!vis[y])vis[y]=1,q[++t]=y,l[y]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tmemset(vis+1,0,n);vis[v]=1;\n\tfor(int i=tp;i;--i)\n\t\tif(!vis[x=st[i]])\n\t\t{\n\t\t\th=0,t=1,q[t]=x,vis[x]=1,r[x]=i;\n\t\t\twhile(h<t)\n\t\t\t{\n\t\t\t\tx=q[++h];\n\t\t\t\tfor(int j=head[x];j;j=bi[j].nxt)\n\t\t\t\t{\n\t\t\t\t\ty=bi[j].to;\n\t\t\t\t\tif(!vis[y])vis[y]=1,q[++t]=y,r[y]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(int i=head[v];i;i=bi[i].nxt)f[i][0]=l[bi[i].to]!=r[bi[i].to];\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tint x,y;\n\tfor(int i=1;i<=m;++i)scanf(\"%d %d\",&x,&y),add(x,y),b[i][0]=x,b[i][1]=y;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tmemset(vis+1,0,n);h=0,t=1;q[t]=i;vis[i]=1;\n\t\twhile(h<t)\n\t\t{\n\t\t\tx=q[++h];\n\t\t\tfor(int j=head[x];j;j=bi[j].nxt)\n\t\t\t{\n\t\t\t\ty=bi[j].to;\n\t\t\t\tif(!vis[y])vis[y]=1,q[++t]=y;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=m;++j)if(b[j][1]==i)f[j][1]=vis[b[j][0]];\n\t}\n\tfor(int i=1;i<=n;++i)work(i);\n\tfor(int i=1;i<=m;++i)\n\t\tif(f[i][0]!=f[i][1])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#include<unordered_map>\n#include<vector>\ntypedef long long ll;\nusing namespace std;\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define N 1010\n#define M 200010\nstruct Edge{\n\tint e,n;\n}e[M];\nint hd[N],cnt;\nvoid add(int a,int b){\n\te[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;\n}\nint a[M],b[M],id[M],ban[M],vis[N];\nint connected(int a,int b){\n\tint i;\n\tvis[a]=1;\n\tif(a==b)return 1;\n\tfor(i=hd[a];i;i=e[i].n){\n\t\tint q=e[i].e;\n\t\tif(!ban[i]&&!vis[q]&&connected(q,b))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,j,n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tadd(a[i],b[i]);id[i]=cnt;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=1;j<=n;j++)vis[j]=0;\n\t\tint x=connected(b[i],a[i]);\n\t\tban[id[i]]=1;\n\t\tfor(j=1;j<=n;j++)vis[j]=0;\n\t\tint y=connected(a[i],b[i]);\n\t\tban[id[i]]=0;\n\t\tif(x^y)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N = 1005, M = 200005;\n\nint n, m, sc, cc, non, wh[N], col[N];\nbool vis[N], ans[M], shu[N], can[N];\npii e[M];\n\nvector<int> adj[N], rev[N], out[N], st;\n\nvoid tdfs (int I) {\n\tif(vis[I]) return;\n\tvis[I] = true;\n\tfor(auto &T : adj[I]) if(T != non) tdfs(T);\n\tst.push_back(I);\n}\n\nvoid rdfs (int I) {\n\tif(vis[I]) return;\n\twh[I] = sc;\n\tvis[I] = true;\n\tfor(auto &T : rev[I]) if(T != non) rdfs(T);\n}\n\nvoid toposort (int I) {\n\tnon = I; sc = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vis[i]) tdfs(i);\n\t}\n\tfill(vis+1, vis+1+n, 0);\n\twhile(!st.empty()) {\n\t\tint T; T = st.back(); st.pop_back();\n\t\tif(!vis[T]) {rdfs(T); sc++;}\n\t}\n\tfill(vis+1, vis+1+n, 0);\n}\n\nvoid cdfs (int I) {\n\tcol[I] = cc;\n\tvis[I] = true;\n\tif(shu[I] && I != st[cc]) {\n\t\tcan[I] = true;\n\t\tif(wh[I] == wh[st[cc]]) can[st[cc]] = true;\n\t}\n\tfor(auto &T : adj[I]) {\n\t\tif(T == non)  continue;\n\t\tif(vis[T]) {\n\t\t\tif(col[I] == col[T]) continue;\n\t\t\tif(wh[T] == wh[st[col[T]]]) can[st[col[T]]] = true;\n\t\t}\n\t\telse cdfs(T);\n\t}\n}\n\nvoid solve (int I) {\n\ttoposort(I);\n\tfor(auto &T : adj[I]) shu[T] = true;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T]) continue;\n\t\tst.push_back(T);\n\t\tcdfs(T); cc++;\n\t}\n\tfor(auto &T : out[I]) {\n\t\tans[T] = can[e[T].Y];\n\t}\n\tcc = 0;\n\tfill(vis+1, vis+1+n, 0);\n\tst.clear();\n\tfor(auto &T : adj[I]) {\n\t\tshu[T] = false;\n\t\tcan[T] = false;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\te[i] = {A, B};\n\t\tout[A].push_back(i);\n\t\tadj[A].push_back(B);\n\t\trev[B].push_back(A);\n\t}\n\tfor(int i=1;i<=n;i++) solve(i);\n\ttoposort(0);\n\tfor(int i=1;i<=m;i++) {\n\t\tputs(ans[i] ^ wh[e[i].X] == wh[e[i].Y] ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << \"\\n\";\n}\n\nint n;\nvector<int> oriG[1000];\nbool e[1000][1000];\nint id[1000][1000];\nbool ans[200000];\n\nstruct graph {\nprivate:\n\tint n;\n\tvector<vector<int>> G, rG;\n\tvector<bool> used;\n\tvector<int> vs;\n\n\tint mk;\n\tvector<vector<int>> fG;\n\tvector<vector<int>> ori;\n\tvector<int> trans;\npublic:\n\tgraph(int sz) {\n\t\tn = sz;\n\t\tG.resize(n);\n\t\trG.resize(n);\n\t\tused.resize(n);\n\n\t\tfG.resize(n);\n\t\ttrans.resize(n, -1);\n\t\tori.resize(n);\n\t}\n\tvoid add_edge(int a, int b) {\n\t\tG[a].push_back(b);\n\t\trG[b].push_back(a);\n\t}\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\trep(i, G[v].size()) {\n\t\t\tif (!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.push_back(v);\n\t}\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = true;\n\t\tqueue<int> q; q.push(v);\n\t\tvector<int> c;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tori[k].push_back(id);\n\t\t\trep(j, rG[id].size()) {\n\t\t\t\tint to = rG[id][j];\n\t\t\t\tif (used[to]) {\n\t\t\t\t\tif (trans[to] >= 0)c.push_back(trans[to]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());\n\t\tint len = unique(c.begin(), c.end()) - c.begin();\n\t\trep(i, len) {\n\t\t\tfG[c[i]].push_back(k);\n\t\t}\n\t\trep(i, ori[k].size()) {\n\t\t\ttrans[ori[k][i]] = k;\n\t\t}\n\t}\n\tvoid scc() {\n\t\tfill(used.begin(), used.end(), false);\n\t\trep(i, n) {\n\t\t\tif (!used[i])dfs(i);\n\t\t}\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tper(i, (int)vs.size()) {\n\t\t\tif (!used[vs[i]]) {\n\t\t\t\trdfs(vs[i], k); k++;\n\t\t\t}\n\t\t}\n\t\tmk = k;\n\t}\n\tvoid query(int s) {\n\t\tvector<bool> sc(mk, false);\n\t\tvector<bool> exi(mk, false);\n\t\tqueue<int> q;\n\t\tq.push(trans[s]);\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\trep(j, fG[id].size()) {\n\t\t\t\tint to = fG[id][j];\n\t\t\t\tif (exi[to])continue;\n\t\t\t\texi[to] = true;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t\trep(j, mk) {\n\t\t\tif (!exi[j])continue;\n\t\t\trep(k, fG[j].size()) {\n\t\t\t\tint to = fG[j][k];\n\t\t\t\tsc[to] = true;\n\t\t\t}\n\t\t}\n\t\tvector<int> num(mk, 0);\n\t\trep(j, oriG[s].size()) {\n\t\t\tint to = oriG[s][j];\n\t\t\tto = trans[to];\n\t\t\tnum[to]++;\n\t\t\tif (num[to] >= 2)sc[to] = true;\n\t\t}\n\t\t/*rep(j, fG[trans[s]].size()) {\n\t\t\tint to = fG[trans[s]][j];\n\t\t\tnum[to]++;\n\t\t\tif (num[to] >= 2) {\n\t\t\t\tsc[to] = true;\n\t\t\t}\n\t\t}*/\n\t\trep(i, n) {\n\t\t\tif (i == s)continue;\n\t\t\tif (id[s][i] < 0)continue;\n\t\t\tif (e[i][s] && !sc[trans[i]]) {\n\t\t\t\t//cout << s << \" ! \" << i<<endl;\n\t\t\t\tans[id[s][i]] = true;\n\t\t\t}\n\t\t\tif (!e[i][s] && sc[trans[i]]) {\n\t\t\t\t//cout << s << \" \" << i << endl;\n\t\t\t\tans[id[s][i]] = true;\n\t\t\t}\n\t\t}\n\t}\n};\n\nvector<int> G[1000];\n\nvoid solve(){\n\tint m; cin >> n >> m;\n\trep(i, n)rep(j, n)id[i][j] = -1;\n\tvector<int> a(m), b(m);\n\trep(i, m) {\n\t\tcin >> a[i] >> b[i]; a[i]--; b[i]--;\n\t\tid[a[i]][b[i]] = i;\n\t\tG[a[i]].push_back(b[i]);\n\t\toriG[a[i]].push_back(b[i]);\n\t}\n\trep(i, n) {\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\te[i][i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j];\n\t\t\t\tif (e[i][to])continue;\n\t\t\t\tq.push(to);\n\t\t\t\te[i][to] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tgraph g(n);\n\t\trep(j, m)if (b[j] != i)g.add_edge(a[j], b[j]);\n\t\tg.scc();\n\t\tg.query(i);\n\t}\n\trep(i, m) {\n\t\tif (ans[i]) {\n\t\t\tcout << \"diff\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"same\" << endl;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nstruct eg{int to;eg*nx;}e[200100],*la[1010],*cnt=e;\nint ans[200100],fr[1010][1010],tg[1010][1010],sta[1010],ta,I;\ninline void addE(re int a,re int b)\n{\n\t*++cnt=(eg){b,la[a]};la[a]=cnt;\n}\nvoid dfs(re int a,re int*ff)\n{\n\tfor(re eg*i=la[a];i;i=i->nx)if(!ff[i->to])\n\t{\n\t\tff[i->to]=ff[a];dfs(i->to,ff);\n\t}\n}\nint main()\n{\n\tre int n,m,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re int i=1;i<=m;i++)scanf(\"%d%d\",&x,&y),addE(x,y);\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfr[I][I]=tg[I][I]=-1;\n\t\tfor(re eg*i=la[I];i;i=i->nx)\n\t\t{\n\t\t\tsta[++ta]=i->to;if(!fr[I][i->to])\n\t\t\t{\n\t\t\t\tfr[I][i->to]=i->to;dfs(i->to,fr[I]);\n\t\t\t}\n\t\t}\n\t\tfor(;ta;ta--)if(!tg[I][sta[ta]])\n\t\t{//printf(\"*t*%d %d\\n\",I,sta[ta]);\n\t\t\ttg[I][sta[ta]]=sta[ta];dfs(sta[ta],tg[I]);\n\t\t}\n\t}\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfor(re eg*i=la[I];i;i=i->nx)if(i->to==I)ans[i-e]=1;\n\t\telse{//printf(\"**%d %d %d\\n\",I,i->to,tg[I][i->to]);\n\t\t\tans[i-e]=(fr[I][i->to]==i->to&&tg[I][i->to]==i->to)==(fr[i->to][I]==0);\n\t\t}\n\t}\n\tfor(re int i=1;i<=m;i++)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[1010];\nint n,m,mi[1010],ma[1010],bel[1010],sta[1010],tp,dfn[1010],low[1010],x,y,cnt,t[1010],tn,q[1010],l,r,ans[200010];\nvector<int> v[1010],p[1010];\n\nvoid tarjan(int x)\n{\n\tdfn[x]=low[x]=(++cnt),sta[++tp]=x,bo[x]=1;\n\tfor (int i=0,sz=v[x].size(); i<sz; i++)\n\t\tif (!dfn[v[x][i]]) tarjan(v[x][i]),low[x]=min(low[x],low[v[x][i]]);\n\t\telse if (bo[v[x][i]]) low[x]=min(low[x],dfn[v[x][i]]);\n\tif (dfn[x]==low[x])\n\t{\n\t\tbel[x]=x;\n\t\twhile (sta[tp]!=x) bel[sta[tp]]=x,bo[sta[tp]]=0,tp--;\n\t\ttp--,bo[x]=0;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),cnt=0;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),v[x].push_back(y),p[x].push_back(i);\n\tmemset(bo,0,sizeof(bo)),tp=cnt=0;\n\tfor (int i=1; i<=n; i++) if (!dfn[i]) tarjan(i);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ttn=0;\n\t\tfor (int j=0,sz=v[i].size(); j<sz; j++) t[++tn]=v[i][j];\n\t\tfor (int j=1; j<=n; j++) mi[j]=ma[j]=-1;\n\t\tmi[i]=ma[i]=0;\n\t\tfor (int j=1; j<=tn; j++) if (mi[t[j]]==-1)\n\t\t{\n\t\t\tq[l=r=1]=t[j],mi[t[j]]=j;\n\t\t\twhile (l<=r)\n\t\t\t{\n\t\t\t\tx=q[l++];\n\t\t\t\tfor (int k=0,sz=v[x].size(); k<sz; k++)\n\t\t\t\t\tif (mi[v[x][k]]==-1) mi[q[++r]=v[x][k]]=j;\n\t\t\t}\n\t\t}\n\t\tfor (int j=tn; j; j--) if (ma[t[j]]==-1)\n\t\t{\n\t\t\tq[l=r=1]=t[j],ma[t[j]]=j;\n\t\t\twhile (l<=r)\n\t\t\t{\n\t\t\t\tx=q[l++];\n\t\t\t\tfor (int k=0,sz=v[x].size(); k<sz; k++)\n\t\t\t\t\tif (ma[v[x][k]]==-1) ma[q[++r]=v[x][k]]=j;\n\t\t\t}\n\t\t}\n\t\tfor (int j=0,sz=v[i].size(); j<sz; j++)\n\t\t\tans[p[i][j]]=((mi[v[i][j]]!=ma[v[i][j]])^(bel[i]==bel[v[i][j]]));\n\t}\n\tfor (int j=1; j<=m; j++) puts(ans[j]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define N 1005\n#define M 200005\nusing namespace std;\nstruct Edge{\n\tint to,next,last;\n}edge[M];\nint head[N],tot,first[N];\nvoid addedge(int from,int to){\n\tedge[++tot].to=to;\n\tif(head[from]){\n\t\tedge[head[from]].last=tot;\n\t}else{\n\t\tfirst[from]=tot;\n\t}\n\tedge[tot].next=head[from];\n\thead[from]=tot;\n}\nint p1[N][N];\nbool vis[N];\nvoid dfs1(int now,int p){\n\tif(vis[now]){\n\t\treturn;\n\t}\n\tvis[now]=true;\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=now;\n\t\tdfs1(v,p);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p){\n\tif(vis[now]){\n\t\treturn;\n\t}\n\tvis[now]=true;\n\tfor(int i=first[now];i;i=edge[i].last){\n\t\tint v=edge[i].to;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=now;\n\t\tdfs2(v,p);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;++i){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\taddedge(u[i],v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tmemset(vis,0,sizeof vis);\n\t\tdfs1(i,i);\n\t\tmemset(vis,0,sizeof vis);\n\t\tdfs2(i,i);\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cstring>\nusing namespace std;\nconst int N = 1005;\nconst int M = 2e5 + 5;\nvector<int> v[N];\nbitset<N> vis;\nint n, m, g1[N][N], g2[N][N], pre[N];\nstruct node{int x, y;}e[M];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid dfs(int x, int now)\n{\n\tg1[now][x] = 1; vis.set(x);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, now);\n\t}\n}\nvoid dfs(int x, int id, int k, int now)\n{\n\tif(!k) pre[x] = id; else g2[now][x] = (pre[x] != id);\n\tvis.set(x);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, id, k, now);\n\t}\n}\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read();\n\tfor(int i = 1, x, y; i <= m; i ++)\n\t{\n\t\tx = read(); y = read();\n\t\tv[x].push_back(y); e[i] = node{x, y};\n\t}\n\tfor(int i = 1; i <= n; i ++) {vis.reset(); dfs(i, i);}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tvis.reset(); vis.set(i); memset(pre, 0, sizeof(pre)); int d = v[i].size();\n\t\tfor(int j = 0; j < d; j ++) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 0, i);\n\t\tvis.reset(); vis.set(i);\n\t\tfor(int j = d - 1; j >= 0; j --) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 1, i);//d - 1\n\t}\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tif(g1[e[i].y][e[i].x] ^ g2[e[i].x][e[i].y]) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200200;\ninline int read(int x=0,bool f=0,char ch=getchar()){\n\tfor(;!isdigit(ch);ch=getchar()) f=ch=='-';\n\tfor(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\nint n,m,tot,fi[N],to[N],u[N],ne[N];\nbool vis[1010][1010];\nint pre[1010][1010],suf[1010][1010];\nvoid bfs(int x){\n\tqueue<int> s; s.push(x); vis[x][x]=true;\n\twhile(!s.empty()){\n\t\tint y=s.front(); s.pop();\n\t\tfor(int i=fi[y];i;i=ne[i]) if(!vis[x][to[i]]) vis[x][to[i]]=true,s.push(to[i]);\n\t}\n}\nvoid dfs1(int x,int id,int k){\n\tpre[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!pre[id][x]) dfs1(to[i],id,k);\n}\nvoid dfs2(int x,int id,int k){\n\tsuf[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!suf[id][x]) dfs2(to[i],id,k);\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;++i) x=read(),y=read(),ne[++tot]=fi[x],u[tot]=x,to[fi[x]=tot]=y;\n\tfor(int i=1;i<=n;++i) bfs(i);\n\tfor(int i=1;i<=n;++i){\n\t\tvector<int> s; int sz=0; pre[i][i]=suf[i][i]=1;\n\t\tfor(int j=fi[i];j;j=ne[j]) s.push_back(to[j]);\n\t\tfor(int j:s){\n\t\t\t++sz;\n\t\t\tif(!pre[i][j]) dfs1(j,i,sz);\n\t\t}\n\t\treverse(s.begin(),s.end());\n\t\tfor(int j:s){\n\t\t\tif(!suf[i][j]) dfs2(j,i,sz);\n\t\t\t--sz;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint x=u[i],y=to[i];\n\t\tif(vis[y][x]^(pre[x][y]!=suf[x][y])) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ps[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(++pn;z[zn]!=x;)inz[z[--zn]]=0,++ps[p[z[zn]]=pn];\n}\nvoid dfs1(int x)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs1(e[i].t),uu[i>>1]=1;\n}\nvoid dfs2(int x)\n{\n\tu[x]=1;\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs2(e[i].t),uu[i>>1]=1;\n}\nvoid dd(int x,int y,int xs,int ys)\n{\n\td[x]=l[x]=++cnt;inz[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if((i>>1)!=y&&p[e[i].t]==p[x])\n\t\tif(!d[e[i].t])dd(e[i].t,y,xs,ys),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(x==xs)if(!d[ys])dd(ys,y,xs,ys),l[x]=min(l[x],l[ys]);else if(inz[ys])l[x]=min(l[x],d[ys]);\n\tinz[x]=0;\n\tif(d[x]==l[x]&&d[x]>1)cnt+=MN+5;\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tfor(i=1;i<=n;++i)if(!u[i])dfs1(i);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=n;++i)if(!u[i])dfs2(i);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(k=c[q[j]];k;k=e[k].nx)if(!g[i][e[k].t]++)q[++qn]=e[k].t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(!uu[i]){puts(\"same\");continue;}\n\t\t\tmemset(d,cnt=0,sizeof(d));\n\t\t\tdd(x[i],i,y[i],x[i]);\n\t\t\tputs(cnt==ps[p[x[i]]]?\"same\":\"diff\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1'009;\n\nvector<int> g[N];\nbool was[N];\nvector<int> order;\n\nvoid dfs1(int x) {\n  was[x] = true;\n  for (int y : g[x]) {\n    if (!was[y]) {\n      dfs1(y);\n    }\n  }\n  order.push_back(x);\n}\n\nvector<int> gt[N];\n\nvoid dfs2(int x, int ncomp, int *comp) {\n  comp[x] = ncomp;\n  for (int y : gt[x]) {\n    if (comp[y] == -1) {\n      dfs2(y, ncomp, comp);\n    }\n  }\n}\n\nbool can[N][N];\nint q[N];\nint cnt[N];\nint comp1[N];\nint comp2[N];\nint p[N];\nbool lo[N];\nbool hi[N];\nint in[N];\nint out[N];\n\nconst int M = 200'009;\n\nint from[M];\nint to[M];\nbool ans[M];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", from + i, to + i);\n    --from[i];\n    --to[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n    gt[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    g[from[i]].push_back(to[i]);\n    gt[to[i]].push_back(from[i]);\n  }\n  memset(was, false, sizeof was);\n  order.clear();\n  for (int i = 0; i < n; ++i) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  memset(comp1, -1, sizeof comp1);\n  int ncomp1 = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (comp1[order[i]] == -1) {\n      dfs2(order[i], ncomp1, comp1);\n      ++ncomp1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    if (comp1[from[i]] != comp1[to[i]]) {\n      g[comp1[from[i]]].push_back(i);\n    }\n  }\n  memset(can, false, sizeof can);\n  for (int i = 0; i < ncomp1; ++i) {\n    can[i][i] = true;\n    q[0] = i;\n    for (int qh = 0, qt = 1; qh < qt; ++qh) {\n      int x = q[qh];\n      for (int id : g[x]) {\n        int y = comp1[to[id]];\n        if (!can[i][y]) {\n          can[i][y] = true;\n          q[qt++] = y;\n        }\n      }\n    }\n  }\n  memset(ans, false, sizeof ans);\n  for (int x = 0; x < ncomp1; ++x) {\n    memset(cnt, 0, sizeof cnt);\n    for (int id : g[x]) {\n      ++cnt[comp1[to[id]]];\n    }\n    for (int id : g[x]) {\n      if (cnt[comp1[to[id]]] >= 2) {\n        ans[id] = true;\n      }\n    }\n    vector<int> w;\n    for (int id : g[x]) {\n      w.push_back(comp1[to[id]]);\n    }\n    sort(w.begin(), w.end());\n    w.resize(distance(w.begin(), unique(w.begin(), w.end())));\n    for (int id : g[x]) {\n      int y = comp1[to[id]];\n      for (int z : w) {\n        if (z != y && can[z][y]) {\n          ans[id] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    memset(p, -1, sizeof p);\n    int sz = 0;\n    for (int j = 0; j < n; ++j) {\n      if (j != i && comp1[j] == comp1[i]) {\n        p[j] = sz++;\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      g[j].clear();\n      gt[j].clear();\n    }\n    for (int j = 0; j < m; ++j) {\n      if (p[from[j]] != -1 && p[to[j]] != -1) {\n        g[p[from[j]]].push_back(p[to[j]]);\n        gt[p[to[j]]].push_back(p[from[j]]);\n      }\n    }\n    memset(was, false, sizeof was);\n    order.clear();\n    for (int j = 0; j < sz; ++j) {\n      if (!was[j]) {\n        dfs1(j);\n      }\n    }\n    memset(comp2, -1, sizeof comp2);\n    int ncomp2 = 0;\n    for (int j = sz - 1; j >= 0; --j) {\n      if (comp2[order[j]] == -1) {\n        dfs2(order[j], ncomp2, comp2);\n        ++ncomp2;\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      hi[j] = true;\n      lo[j] = true;\n    }\n    for (int j = 0; j < m; ++j) {\n      if (p[from[j]] != -1 && p[to[j]] != -1) {\n        if (comp2[p[from[j]]] != comp2[p[to[j]]]) {\n          lo[comp2[p[from[j]]]] = false;\n          hi[comp2[p[to[j]]]] = false;\n        }\n      }\n    }\n    memset(in, 0, sizeof in);\n    memset(out, 0, sizeof out);\n    for (int j = 0; j < m; ++j) {\n      if (from[j] == i && p[to[j]] != -1) {\n        if (hi[comp2[p[to[j]]]]) {\n          ++in[comp2[p[to[j]]]];\n        }\n      } else\n      if (to[j] == i && p[from[j]] != -1) {\n        if (lo[comp2[p[from[j]]]]) {\n          ++out[comp2[p[from[j]]]];\n        }\n      }\n    }\n    for (int j = 0; j < m; ++j) {\n      if (from[j] == i && p[to[j]] != -1) {\n        if (hi[comp2[p[to[j]]]] && in[comp2[p[to[j]]]] == 1) {\n          ans[j] = true;\n        }\n      } else\n      if (to[j] == i && p[from[j]] != -1) {\n        if (lo[comp2[p[from[j]]]] && out[comp2[p[from[j]]]] == 1) {\n          ans[j] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    puts(ans[i] ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n\tx=0;register char c=getchar();register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar();if(f)x=-x;\n}\nconst int N=1e3+10,M=2e5+10;\nint n,m,f[N],g[N],id[N][N];\nbool ans[M],vis[N][N];\nstd::vector<int> G[N];\nvoid dfs(int u,bool *vis){vis[u]=1;for(int v:G[u])if(!vis[v])dfs(v,vis);}\nvoid search(int u,int *f){for(int v:G[u])if(!f[v])f[v]=f[u],search(v,f);}\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),read(m);\n\tfor(int u,v,i=1;i<=m;i++)read(u),read(v),G[u].push_back(v),id[u][v]=i;\n\tfor(int i=1;i<=n;i++)dfs(i,vis[i]);\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=1;i<=n;i++)f[i]=g[i]=0; f[u]=g[u]=-1;\n\t\tfor(int v:G[u])if(!f[v])f[v]=v,search(v,f); std::reverse(G[u].begin(),G[u].end());\n\t\tfor(int v:G[u])if(!g[v])g[v]=v,search(v,g); std::reverse(G[u].begin(),G[u].end());\n\t\tfor(int v:G[u])if(vis[v][u]^(f[v]!=v||g[v]!=v))ans[id[u][v]]=true;\n\t}\n\tfor(int i=1;i<=m;i++)puts(ans[i]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nvector<int> G[1005], revG[1005];\nint u[200005], v[200005];\nint reach[1005][1005];\nvector<int> topo;\nbool used[1005];\nint scc[1005];\n\nvoid tpsort(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!used[G[v][i]]) tpsort(G[v][i]);\n\t}\n\ttopo.push_back(v);\n}\nvoid sccdfs(int v, int id)\n{\n\tused[v] = true;\n\tscc[v] = id;\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(!used[revG[v][i]]) sccdfs(revG[v][i], id);\n\t}\n}\n\nvoid dfs(int v, int s, int t)\n{\n\tif(reach[s][v] == 0) reach[s][v] = t;\n\telse reach[s][v] = -1;\n\t\n\tint u;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tu = G[v][i];\n  \t\tif(reach[s][u] == -1 || reach[s][u] == t) continue;\n\t\tdfs(u, s, t);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> u[i] >> v[i];\n\t\tG[u[i]].push_back(v[i]);\n\t\trevG[v[i]].push_back(u[i]);\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\treach[i][i] = -1;\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tdfs(G[i][j], i, G[i][j]);\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++) if(!used[i]) tpsort(i);\n\treverse(topo.begin(), topo.end());\n\tint id = 0;\n\tfor(int i = 1; i <= n; i++) used[i] = false;\n\tfor(int i = 0; i < topo.size(); i++) if(!used[topo[i]]) sccdfs(topo[i], id++);\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tif(scc[u[i]] != scc[v[i]]){\n\t\t\tif(reach[u[i]][v[i]] == -1) cout << \"diff\" << \"\\n\";\n\t\t\telse cout << \"same\" << \"\\n\";\n\t\t}\n\t\telse{\n\t\t\tif(reach[u[i]][v[i]] != -1) cout << \"diff\" << \"\\n\";\n\t\t\telse cout << \"same\" << \"\\n\";\n\t\t}\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> e(N);\n    using P = pair<int, int>;\n    vector<P> edge(M);\n    vector<vector<int>> start(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        e[a].push_back(b);\n        edge[i] = {a, b};\n        start[a].push_back(i);\n    }\n    vector<vector<bool>> ok(N, vector<bool>(N, false));\n    for (int i = 0; i < N; i++) {\n        queue<int> q;\n        q.push(i);\n        ok[i][i] = true;\n        while (not q.empty()) {\n            const int s = q.front();\n            q.pop();\n            for (const int to : e[s]) {\n                if (ok[i][to]) { continue; }\n                ok[i][to] = true;\n                q.push(to);\n            }\n        }\n    }\n    vector<bool> ans(M);\n    for (int i = 0; i < N; i++) {\n        vector<int> dp(N, -1);  // -1: yet, M: doubled\n        queue<int> q;\n        for (const int c : start[i]) {\n            dp[edge[c].second] = c;\n            q.push(edge[c].second);\n        }\n        while (not q.empty()) {\n            const int s = q.front();\n            q.pop();\n            if (s == i) { continue; }\n            for (const int to : e[s]) {i\n                if (dp[to] == M or dp[to] == dp[s]) { continue; }\n                if (dp[to] == -1) {\n                    dp[to] = dp[s];\n                    q.push(to);\n                } else {\n                    dp[to] = M;\n                    q.push(to);\n                }\n            }\n        }\n        for (const int c : start[i]) {\n            const bool ts = ok[edge[c].second][edge[c].first];\n            const bool dst = dp[edge[c].second] == M;\n            ans[c] = ts ^ dst;\n        }\n    }\n    for (int i = 0; i < M; i++) { cout << (ans[i] ? \"diff\" : \"same\") << endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\ntypedef unsigned long long ull;\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nvoid dfs(int k){\n\tvis[D][k]=1;\n\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k]){\n\t\tdfs(e[i].k);\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint o=vis[i][e[p].k];\n\t\t\tdfs(e[p].k);\n\t\t\tvis[i][e[p].k]=o;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\nusing namespace std;\ntypedef pair<int, int> PP;\ntypedef long long LL;\n#define pb push_back\n#define fr first\n#define sc second\n#define bitcnt __builtin_popcount\n#define all(x) x.begin(), x.end()\ninline LL ri() {LL x; scanf(\"%lld\", &x); return x;}\n#define rep2(i, n, ...) for (int i = 0; i < (n); i ++) \n#define rep3(i, a, b, ...) for (int i = (a); i < (b); i ++)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define drep2(i, n, ...) for (int i = (n) - 1; i >= 0; i --)\n#define drep3(i, a, b) for (int i = (a) - 1; i >= (b); i --)\n#define drep(...) GET_MACRO(__VA_ARGS__, drep3, drep2)(__VA_ARGS__)\ntemplate<typename T>inline bool smax(T&a, T b){if(a<b){a=b;return true;}return false;} \ntemplate<typename T>inline bool smin(T&a, T b){if(a>b){a=b;return true;}return false;} \n/*}}}*/\n\n\nconst int maxm = 1000010, maxn = 1003;\nint idx[maxn], low[maxn], ins[maxn], vis[maxn], scc[maxn];\nvector<int> g[maxn], gid[maxn];\nPP e[maxm];\nint n, m;\nint ec[maxn][maxn];\n\nshort viscnt[maxn];\n\nint curidx = 1;\nint scccnt = 0;\nvector<int> tstask;\n\nvoid dfs(int x) {\n  low[x] = idx[x] = curidx++;\n  tstask.push_back(x);\n  ins[x] = 1;\n\n  for (auto t : g[x]) {\n    if (idx[t] == 0) {\n      dfs(t);\n      smin(low[x], low[t]);\n    } else if (ins[t]) {\n      smin(low[x], idx[t]); \n    }\n  }\n\n  if (idx[x] == low[x]) {\n    while (!tstask.empty() && tstask.back() != x) {\n      int t = tstask.back(); tstask.pop_back();\n      ins[t] = 0;\n      scc[t] = x;\n    }\n    ins[x] = 0;\n    scc[x] = x;\n    tstask.pop_back();\n  }\n}\n\n//void run(int x) {\n  ////viscnt[x] = 1;\n  ////for (auto t : g[x]) {\n    ////if (viscnt[t]) {\n      ////viscnt[t] ++;\n    ////} else {\n      ////run(t);\n    ////}\n  ////}\n//}\n\nbool direct[maxn];\nint forbid=-1;\nvoid run(int x) {\n  //viscnt[x] = 1;\n  for (auto t : g[x]) {\n    if (direct[t]) {\n      if (t != forbid){\n        viscnt[t] = 2;\n      }\n    } else if (!viscnt[t]) {\n      viscnt[t] = 1;\n      run(t);\n    }\n  }\n}\n\nint res[maxm];\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; i ++) {\n    int u, v; \n    scanf(\"%d %d\", &u, &v);\n    u --; v --;\n    e[i] = PP(u, v);\n    g[u].pb(v);\n    gid[u].pb(i);\n  }\n\n  for (int i = 0; i < n; i ++) {\n    if (!idx[i]) {\n      dfs(i);\n    }\n  }\n\n  rep(i, m) {\n    ec[scc[e[i].fr]][scc[e[i].sc]] ++;\n  }\n\n  rep(i, n) {\n    //cerr << i << endl;\n    memset(viscnt, 0, sizeof viscnt);\n    memset(direct, 0, sizeof direct);\n    for (auto t: g[i]) {\n      direct[t] = 1;\n    }\n    viscnt[i] = 1;\n    for (auto t : g[i]) {\n      forbid = t;\n      run(t);\n    }\n    rep(j, g[i].size()) {\n      int d = gid[i][j];\n      int u = i, v = g[i][j];\n\n      if (scc[u] == scc[v]) {\n        res[d] = viscnt[g[i][j]] <= 1;\n      } else if (ec[scc[u]][scc[v]] == 1) {\n        res[d] = viscnt[g[i][j]] > 1;\n      } else {\n        res[d] = 1;\n      }\n    }\n  }\n\n  rep(i, m) {\n    printf(\"%s\\n\", (res[i]?\"diff\":\"same\"));\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int>E[1010];\nint n, m, b[200020][2];\nbool vis[1010], f[200020][2];\nint q[1010], h, t, l[1010], r[1010];\nint st[1010], tp;\n\nvoid dfs1(int v, int a[], int w)\n{\n\tvis[v] = 1, a[v] = w;\n\tfor (auto u : E[v])if (!vis[u])dfs1(u, a, w);\n}\nvoid work(int v)\n{\n\ttp = 0;\n\tfor (auto u : E[v])st[++tp] = u;\n\tmemset(vis + 1, 0, n); vis[v] = 1;\n\tfor (int i = 1; i <= tp; ++i)if (!vis[st[i]])dfs1(st[i], l, i);\n\tmemset(vis + 1, 0, n); vis[v] = 1;\n\tfor (int i = tp; i; --i)if (!vis[st[i]])dfs1(st[i], r, i);\n\tfor (int i = 1; i <= m; ++i)if (b[i][0] == v)f[i][0] = l[b[i][1]] != r[b[i][1]];\n}\nvoid dfs(int v)\n{\n\tvis[v] = 1;\n\tfor (auto u : E[v])if (!vis[u])dfs(u);\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tint x, y;\n\tfor (int i = 1; i <= m; ++i)scanf(\"%d %d\", &x, &y), E[x].emplace_back(y), b[i][0] = x, b[i][1] = y;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tmemset(vis + 1, 0, n);\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= m; ++j)if (b[j][1] == i)f[j][1] = vis[b[j][0]];\n\t}\n\tfor (int i = 1; i <= n; ++i)work(i);\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (f[i][0] != f[i][1])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int N=1000+10;\nconst int M=200000+10;\n\nint n,m;\nvector<int> G[N];\nbool f[N][N],g[N][N],t[N];\n\nvoid dfs(int o,int u)\n{\n\tf[o][u]=true;\n\tfor(vector<int>::iterator it(G[u].begin());it!=G[u].end();++it)if(!f[o][*it])\n\t\tdfs(o,*it);\n}\n\nvoid dfs2(int o,int u)     \n{                          \n\tt[u]=true;\n\tfor(vector<int>::iterator it(G[u].begin());it!=G[u].end();++it)if(*it!=o&&!t[*it])\n\t\tdfs2(o,*it);\n}\n\nvoid prework()\n{\n\tint i;\n\tfor(i=1;i<=n;++i)\n\t\tdfs(i,i);\n\tvector<int>::iterator it;\n\tvector<int>::reverse_iterator it2;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tmemset(t,0,sizeof t);\n\t\tfor(it=G[i].begin();it!=G[i].end();++it)\n\t\t\tif(!t[*it])dfs2(i,*it);\n\t\t\telse g[i][*it]=true;\n\t\tmemset(t,0,sizeof t);\n\t\tfor(it2=G[i].rbegin();it2!=G[i].rend();++it2)\n\t\t\tif(!t[*it2])dfs2(i,*it2);\n\t\t\telse g[i][*it2]=true;\n\t}\n}\n\nint u[M],v[M];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tint i;\n\tfor(i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",u+i,v+i);\n\t\tG[u[i]].push_back(v[i]);\n\t}\n\tprework();\n\tfor(i=1;i<=m;++i)\n\t\tprintf((f[v[i]][u[i]]^g[u[i]][v[i]])?\"diff\\n\":\"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e3+5;\nint n,m,A[N],B[N],vis[N],tag[N],flag[2][N][N];\nvector <int> G[N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nvoid dfs(int u,int rt) {\n\tif(vis[u]) return;\n\tflag[0][rt][u]=vis[u]=true;\n\tfor(auto v:G[u]) dfs(v,rt);\n}\nvoid dfs(int u,int rt,int id,int now) {\n\tif(vis[u]) return;\n\tvis[u]=true;\n\tif(!now) tag[u]=id;\n\telse flag[1][rt][u]=(bool)(tag[u]!=id);\n\tfor(auto v:G[u]) dfs(v,rt,id,now);\n}\n\nint main() {\n\tIN(n),IN(m);\n\tfor(int i=1;i<=m;++i)\n\t\tIN(A[i]),IN(B[i]),G[A[i]].push_back(B[i]);\n\tfor(int u=1;u<=n;++u) memset(vis,0,sizeof(vis)),dfs(u,u);\n\tfor(int u=1;u<=n;++u) {\n\t\tmemset(tag,0,sizeof(tag));\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=0;i<=(int)G[u].size()-1;++i) dfs(G[u][i],u,i,0);\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=(int)G[u].size()-1;i>=0;--i) dfs(G[u][i],u,i,1);\n\t}\n\tfor(int i=1;i<=m;++i)\n\t\tputs(flag[0][B[i]][A[i]]^flag[1][A[i]][B[i]]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1007;\nconst int MAXM=2e6+7;\nint head[MAXN],b[MAXN],num,n,m,l,x[MAXM],y[MAXM],s,t;\nstruct po\n{\n\tint nxt,to;\n}edge[MAXM];\ninline int read()\n{\n    int x=0,c=1;\n    char ch=' ';\n    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();\n    while(ch=='-')c*=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();\n    return x*c;\n}\ninline void add_edge(int from,int to)\n{\n\tedge[++num].nxt=head[from];\n\tedge[num].to=to;\n\thead[from]=num;\n}\ninline int bfs1()\n{\n\tmemset(b,0,sizeof(b));\n\tb[s]=1;\n\tqueue<int> q;\n\twhile(!q.empty()) q.pop();\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\t\tint v=edge[i].to;\n\t\t\tif(u==s&&v==t) continue;\n\t\t\tif(!b[v]){\n\t\t\t\tb[v]=1;\n\t\t\t\tif(v==t) return 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\ninline int bfs2()\n{\n\tmemset(b,0,sizeof(b));\n\tb[t]=1;\n\tqueue<int> q;\n\twhile(!q.empty()) q.pop();\n\tq.push(t);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\t\tint v=edge[i].to;\n\t\t\tif(!b[v]){\n\t\t\t\tb[v]=1;\n\t\t\t\tif(v==s) return 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=m;i++){\n\t\tx[i]=read();y[i]=read();\n\t\tadd_edge(x[i],y[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\ts=x[i],t=y[i];\n\t\tint c1=bfs1();\n\t\tint c2=bfs2();\n\t\tif(c1==c2) puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3,\"Ofast\")\n#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  int x=0,f=1;char c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return f?x:-x;\n  }\ntemplate <typename mitsuha>\ninline bool read(mitsuha &x){\n  x=0;int f=1;char c=gc();\n  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';\n  if (!~c) return 0;\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return x=f?x:-x,1;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x,int b=10){\n  if (!x) return 0&pc(48);\n  if (x<0) x=-x,pc('-');\n  int bit[99],i,p=0;\n  for (;x;x/=b) bit[++p]=x%b;\n  for (i=p;i;--i) pc(bit[i]+(bit[i]<10?48:55));\n  return 0;\n  }\ntemplate <typename mitsuha>\ninline int rwrite(mitsuha x,int b=10){\n  mitsuha ans=0,d=1;\n  for (;x;x/=10,d*=b) ans=ans+x%10*d;\n  return ans;\n  }\ninline char fuhao(){\n  char c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=2e5;\ntypedef int fuko[yuzu|10];\nvector<int> lj[yuzu|10];\nstruct edge{int u,v;}eg[yuzu|10];\nint cnt[1010][1011],vis[1010],can[1010][1010];\n\nvoid dfs(int p,int u){\nvis[u]=1,cnt[p][u]++;\nfor (int i:lj[u]) if (!vis[i]) dfs(p,i);\n}\n\nvoid dfs2(int p,int u){\nvis[u]=1,can[p][u]=1;\nfor (int v:lj[u]) if (!vis[v]) dfs2(p,v);\n}\n\nint main(){\nint i,n=read(),m=read();\nfor (i=1;i<=m;++i){\n  int u=read(),v=read();\n  lj[u].push_back(v);\n  eg[i]=edge{u,v};\n  }\nfor (i=1;i<=n;++i){\n  for (int j:lj[i]){\n    memset(vis,0,sizeof vis);\n    vis[i]=1,dfs(i,j);\n    } \n  }\nfor (i=1;i<=n;++i){\n  memset(vis,0,sizeof vis);\n  dfs2(i,i);\n  }\nfor (i=1;i<=m;++i){\n  int u=eg[i].u,v=eg[i].v;\n  //cout<<(cnt[u][v])<<\" \"<<can[v][u]<<endl;\n  puts(((cnt[u][v]==1)^(!can[v][u]))?\"diff\":\"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int kMaxN = 1005, kMaxM = 200005;\n\nint n, m, T;\nvector<int> g[kMaxN];\nint mat[kMaxM][2], p[kMaxN][kMaxN], q[kMaxN][kMaxN], vis[kMaxN];\n\nvoid Mark(int st, int now, int id, int a[]) {\n  if (now == st || vis[now] == T)\n    return;\n  vis[now] = T;\n  a[now] = id;\n  for (int nxt : g[now]) {\n      Mark(st, nxt, id, a);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 1, a, b; i <= m; i++) {\n    cin >> a >> b;\n    mat[i][0] = a;\n    mat[i][1] = b;\n    g[a].push_back(b);\n  }\n  for (int i = 1; i <= n; i++) {\n    ++T;\n    int id = 0;\n    for (int k : g[i])\n      Mark(i, k, ++id, p[i]);\n    reverse(g[i].begin(), g[i].end());\n    ++T;\n    id = g[i].size();\n    for (int k : g[i])\n      Mark(i, k, id--, q[i]);\n  }\n  for (int i = 1; i <= m; i++) {\n    if ((p[mat[i][1]][mat[i][0]] > 0) == (p[mat[i][0]][mat[i][1]] != q[mat[i][0]][mat[i][1]])) {\n      cout << \"same\\n\";\n    } else {\n      cout << \"diff\\n\";\n    }\n  }\n  cout << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define maxn 200100\nusing namespace std;\nint n,m,tot,head[1010];\nbool vis[1010];short th[1010][1010];\nstruct point{\n\tint fr,to,nxt;\n}a[maxn];\nint read(){\n\tint x=0;char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn x;\n}\ninline void add(int x,int y)\n{\n\ta[++tot].fr=x;\n\ta[tot].to=y;\n\ta[tot].nxt=head[x];\n\thead[x]=tot;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tvis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tdfs(a[i].to,s,cur);\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tx=read(); y=read();\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=head[i];j;j=a[j].nxt) dfs(a[j].to,i,j);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].fr,y=a[i].to;\n\t\tif((th[y][x]&&th[x][y]!=-1)||(!th[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+7;\nconst int M=2e5+7;\ninline int read(){\n\tint x=0; bool f=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\n\nint n,m;\nint u[M],v[M],ans[M];\nint head[N],to[M],nx[M],ec=1;\ninline void add(int a,int b){\n\tnx[++ec]=head[a]; head[a]=ec; to[ec]=b;\n}\n\nint q[M],h,t;\nvector<int>vec[N];\nvector<int>pre[N];\ninline void solve(int x){\n\tint hst=x;\n\tfor(int i=1;i<=n;++i) pre[i].clear();\n\th=1; t=0; pre[x].resize(2);\n\tfor(int i=head[x];i;i=nx[i]){\n\t\tint v=to[i]; q[++t]=v;\n\t\tpre[v].push_back(i);\n\t}\n\twhile(h<=t){\n\t\tx=q[h++];\n\t\tif(pre[x].size()==2){\n\t\t\tfor(int i=head[x];i;i=nx[i]){\n\t\t\t\tint v=to[i];\n\t\t\t\tif(pre[v].size()==2) continue;\n\t\t\t\tif(pre[v].size()==1) pre[v].push_back(pre[x][pre[x][0]==pre[v][0]]);\n\t\t\t\telse pre[v]=pre[x]; q[++t]=v;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=head[x];i;i=nx[i]){\n\t\t\t\tint v=to[i];\n\t\t\t\tif(pre[v].size()==2) continue;\n\t\t\t\tif(pre[v].size()==1&&pre[v][0]==pre[x][0]) continue;\n\t\t\t\tpre[v].push_back(pre[x][0]); q[++t]=v;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<vec[hst].size();++i){\n\t\tint id=vec[hst][i],x=u[id],y=v[id];\n\t\tif(hst==y&&pre[x].size()>0) ans[id]^=1;\n\t\tif(hst==x&&pre[y].size()>1) ans[id]^=1;\n\t}\n}\n\nint main(){\n\tn=read(); m=read();\n\tfor(int i=1;i<=m;++i){\n\t\tu[i]=read(); v[i]=read(); add(u[i],v[i]);\n\t\tvec[u[i]].push_back(i); vec[v[i]].push_back(i);\n\t}\n\tfor(int i=1;i<=n;++i) if(vec[i].size()) solve(i);\n\tfor(int i=1;i<=m;++i) puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e3 + 5;\n\nint n, m, a[N], b[N], used[N];\nint comp[N], sz;\nvector <int> g[N], rg[N], vec;\nvector < pair <int, int> > c;\nmap < pair <int, int>, int > mp;\n\nvoid dfs(int v){\n      used[v] = 1;\n      for(int to : g[v]){\n            if(!used[to]) dfs(to);\n      }\n      vec.push_back(v);\n}\n\nvoid Dfs(int v){\n      comp[v] = sz;\n      used[v] = 0;\n      for(int to : rg[v]) {\n            if(used[to]) Dfs(to);\n      }\n}\n\nvoid vis(int v){\n      used[v] = 1;\n      for(int to : g[v]) if(!used[to]) vis(to);\n}\n\nint main(){\n      cin >> n >> m;\n\n      for(int i = 1; i <= m; i ++){\n            cin >> a[i] >> b[i];\n            g[a[i]].push_back(b[i]);\n            rg[b[i]].push_back(a[i]);\n            c.push_back(make_pair(a[i], b[i]));\n      }\n\n      for(int i = 1; i <= n; i ++)\n            if(!used[i]) dfs(i);\n\n      reverse(vec.begin(), vec.end());\n\n      for(int v : vec)\n            if(used[v]) sz ++, Dfs(v);\n\n      for(int v = 1; v <= n; v ++){\n            memset(used, 0, sizeof(used));\n            used[v] = 1;\n            for(int to : g[v]){\n                  if(used[to]){\n                        mp[make_pair(v, to)] = 1;\n                  }\n                  vis(to);\n            }\n            memset(used, 0, sizeof(used));\n            used[v] = 1;\n            reverse(g[v].begin(), g[v].end());\n            for(int to : g[v]){\n                  if(used[to]){\n                        mp[make_pair(v, to)] = 1;\n                  }\n                  vis(to);\n            }\n      }\n\n      for(auto i : c){\n            if(comp[i.first] != comp[i.second]) mp[i] = 1 - mp[i];\n            if(mp[i]){\n                  puts(\"same\");\n            } else {\n                  puts(\"diff\");\n            }\n      }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010, M = 200010;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\n\nint n, m, fr[M], to[M], nxt[M], tt, s, t, id[N], h[N];\nbool vis[N][N], can[M];\nvector<int> E[N];\n\nvoid addedge (int u,int v) {\n\tfr[++tt] = u, to[tt] = v;\n\tnxt[tt] = h[u], h[u] = tt;\n\tE[u].push_back(v);\n}\n\nvoid dfs (int u) {\n\tvis[s][u] = true;\n\tif (id[u]) return;\n\tid[u] = t;\n\tfor (auto v : E[u]) {\n\t\tif(!id[v] && v != s) dfs(v);\n\t}\n}\n\nint main () {\n\tcin >> n >> m;\n\tfor(int i = 1, u, v; i <= m; i++) read(u), read(v), addedge(u,v);\n\t\n\tfor(s = 1; s <= n; s++) {\n\t\tmemset(id, 0, sizeof(id));\n\t\tvector<int> son;\n\n\t\tfor(int i = h[s], v; v = to[i], i; i=nxt[i]) son.push_back(v), dfs(t = v);\n\t\treverse(son.begin(),son.end());\n\t\tfor(int i = h[s], v; v = to[i], i; i=nxt[i]) {\n\t\t\tif(id[v] != v) can[i] = 1;\n\t\t}\n\n\t\tmemset(id, 0, sizeof(id));\n\t\tfor(auto v : son) dfs(t = v);\n\t\tfor(int i = h[s], v; v = to[i], i; i = nxt[i]) {\n\t\t\tif(id[v] != v) can[i] = 1;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= m; i++) {\n\t\tint u = fr[i], v = to[i];\n\t\tif(can[i] == vis[v][u]) cout << \"same\\n\";\n\t\telse cout << \"diff\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=1111;\nconst int maxm=200111;\n\nbitset<maxn> con[maxn];\nvector<int> g[maxn];\nint n,m,eu[maxm],ev[maxm],piv;\nbool can[maxn][maxn],can2[maxn][maxn];\n\nbitset<maxn> use;\nvoid dfs(int x,int tmp=1)\n{\n\tcan[piv][x]=1;\n\tcan2[piv][x]|=tmp;\n\tuse.set(x);\n\twhile(true)\n\t{\n\t\tint cur=(con[x]&~use)._Find_first();\n\t\tif(cur>=1&&cur<=n)dfs(cur);\n\t\telse break;\n\t}\n}\n\nvoid solve(int x)\n{\n\tpiv=x;\n\tuse.reset();use.set(x);\n\tfor(int i=0;i<(int)g[x].size();i++)if(!use[g[x][i]])dfs(g[x][i],0);\n\tuse.reset();use.set(x);\n\tfor(int i=(int)g[x].size()-1;i>=0;i--)if(!use[g[x][i]])dfs(g[x][i],0);\n}\n\nint main()\n{\n\tget2(n,m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tget2(eu[i],ev[i]);\n\t\tg[eu[i]].pb(ev[i]);\n\t\tcon[eu[i]].set(ev[i]);\n\t}\n\t\n\tfor(int i=1;i<=n;i++)solve(i);\n\t\n\tfor(int i=1;i<=m;i++)if(can[ev[i]][eu[i]]^can2[eu[i]][ev[i]])puts(\"diff\");else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1010\n#define M 200100\nusing namespace std;\ninline void read(int &x)\n{\n\tx=0;\n\tstatic int p;p=1;\n\tstatic char c;c=getchar();\n\twhile(!isdigit(c)){if(c=='-')p=-1;c=getchar();}\n\twhile(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}\n\tx*=p;\n}\nint n,m,e,e1;\nint to[M],beg[N],nex[M];\nint to1[M],beg1[N],nex1[M];\nint vis[N],stan[M],stcn;\nint cnt,pd,from[M],from1[M];\nvector<int>s;\nvoid add(int x,int y)\n{\n    to[++e]=y;\n\tfrom[e]=x;\n    nex[e]=beg[x];\n    beg[x]=e;\n}\nvoid add1(int x,int y)\n{\n    to1[++e1]=y;\n\tfrom1[e1]=x;\n    nex1[e1]=beg1[x];\n    beg1[x]=e1;\n}\nvoid dfs1(int x)\n{\n    vis[x]=1;\n\tif(to[pd]==x&&!vis[from[pd]])dfs1(from[pd]);\n    for(int i=beg[x];i;i=nex[i])\n        if(i!=pd&&!vis[to[i]])dfs1(to[i]);\n    s.push_back(x);\n}\nvoid dfs2(int x)\n{\n    vis[x]=1;\n\tif(to1[pd]==x&&!vis[from1[pd]])dfs2(from1[pd]);\n\tfor(int i=beg1[x];i;i=nex1[i])\n        if(i!=pd&&!vis[to1[i]])dfs2(to1[i]);\n}\nint main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tread(n);read(m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tstatic int x,y;\n\t\tread(x);read(y);\n\t\tadd(x,y);add1(y,x);\n\t}\n\tfor(register int i=1;i<=n;i++)\n\t\tif(!vis[i])dfs1(i);\n\tmemset(vis,0,sizeof(vis));\n\tfor(register int i=s.size()-1;i>=0;i--)\n\t\tif(!vis[s[i]])cnt++,dfs2(s[i]);\n\tstcn=cnt;\n\tmemset(vis,0,sizeof(vis));\n\tfor(int j=1;j<=m;j++)\n\t{\n\t\tcnt=0;\n\t\tpd=j;\n\t\ts.clear();\n\t\tfor(register int i=1;i<=n;i++)\n\t\t\tif(!vis[i])dfs1(i);\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(register int i=s.size()-1;i>=0;i--)\n\t\t\tif(!vis[s[i]])cnt++,dfs2(s[i]);\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(cnt!=stcn)puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint v,nxt,id;\n}e[400050];\n\nint head[1050],ecnt;\nint flg1[200050],flg2[200050];\nint vis1[200050],vis2[200050];\n\nvoid adde(int u,int v,int id)\n{\n\te[++ ecnt].id = id;\n\te[ecnt].v = v;\n\te[ecnt].nxt = head[u];\n\thead[u] = ecnt;\n}\n\nvector<pair<int,int> > come[1050];\n\nvoid dfs1(int pos,int tag)\n{\n\tvis1[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis1[v])\n\t\t\tdfs1(v,tag);\n\t}\n}\n\nvoid dfs2(int pos,int tag)\n{\n\tvis2[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis2[v])\n\t\t\tdfs2(v,tag);\n\t}\n}\n\nint main()\n{\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\tadde(u,v,i); come[v].push_back(make_pair(u,i));\n\t}\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tmemset(vis1,0,sizeof(vis1));\n\t\tmemset(vis2,0,sizeof(vis2));\n\t\tvector<int> histo;\n\t\tvis1[i] = vis2[i] = -1;\n\t\tfor(int j = head[i];j;j = e[j].nxt)\n\t\t{\n\t\t\tint v = e[j].v;\n\t\t\thisto.push_back(j);\n\t\t\tif(!vis1[v])\n\t\t\t\tdfs1(v,e[j].id);\n\t\t}\n\t\tfor(int j = histo.size() - 1;j >= 0; -- j)\n\t\t{\n\t\t\tint v = e[histo[j]].v;\n\t\t\tif(!vis2[v])\n\t\t\t\tdfs2(v,e[histo[j]].id);\n\t\t}\n\t\tfor(int j = 0;j < histo.size(); ++ j)\n\t\t\tif(vis1[e[histo[j]].v] != vis2[e[histo[j]].v])\n\t\t\t\tflg2[e[histo[j]].id] = 1;\n\t\tfor(auto v : come[i])\n\t\t\tif(vis1[v.first]) flg1[v.second] = 1;\n\t}\n\tfor(int i = 1;i <= m; ++ i)\n\t\tprintf(\"%s\\n\",flg1[i] + flg2[i] == 1 ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define vec vector<int>\n#define dead not_bad\n#define bad gooood\n\n#define left not_right\n#define y1 what\n\nusing namespace std;\n\nconst int N = (int) 1e3 + 10;\nconst int M = (int) 2e5 + 10;\nconst int K = (int) 350;\nconst ll LINF = (ll) 1e18;\nconst int INF = (int) 1e9 + 7;\nconst int ALPHA = 26;\nconst int mod = INF + 2;\nconst double PI = 3.14159265359;\nconst ld EPS = (ld) 1e-12;\n\nint n, m;\nvector<pii> v[N];\nint from[M], to[M];\nint u[2][N];\nint bad_id;\n\nvoid dfs(int r, int x) {\n  u[r][x] = 1;\n  for (auto it : v[x]) {\n    if (it.s == bad_id) {\n      continue;\n    }\n    if (!u[r][it.f]) {\n      dfs(r, it.f);\n    }\n  }\n}\n\nint main() {\n  #define fn \"saddle\"\n  #ifdef witch\n      freopen(\"input.txt\", \"r\", stdin);\n      freopen(\"output.txt\", \"w\", stdout);\n  #else\n      //freopen(fn\".in\", \"r\", stdin);\n      //freopen(fn\".out\", \"w\", stdout);\n  #endif\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> from[i] >> to[i];\n    v[from[i]].pb(mp(to[i], i));\n  }\n  for (int i = 1; i <= m; i++) {\n    memset(u, 0, sizeof(u));\n    bad_id = i;\n    dfs(0, from[i]);\n    dfs(1, to[i]);\n    //cout << u[0][to[i]] << ' ' << u[1][from[i]] << \"\\n\";\n    if (u[0][to[i]] + u[1][from[i]] == 1) {\n      cout << \"diff\\n\";\n    } else {\n      cout << \"same\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <bitset>\n\nusing namespace std;\n\nclass SCC {\n    public:\n    SCC(int n) : size(n), graph(n), num_scc(0), mapping(n) {};\n    void add_edge(int from, int to);\n    void add_undirected_edge(int from, int to);\n    void decompose();\n    int get_size();\n    vector <vector <int> > get_graph();\n    vector <vector <int> > get_rgraph();\n    vector <int> get_mapping();\n    vector <int> get_weight();\n    map <pair<int, int>, int> get_edge_weight();\n    \n    private:\n    vector <vector <int> > graph;\n    int size;\n    int num_scc;\n    vector <int> mapping;\n};\n\nvoid SCC::add_edge(int from, int to) {\n    graph[from].push_back(to);\n}\n\nvoid SCC::add_undirected_edge(int from, int to) {\n    graph[from].push_back(to);\n    graph[to].push_back(from);\n}\n\nvoid SCC::decompose() {\n    int num_visit = 0, num_stack = 0, num_dfs = 0;\n    int *order = (int *)malloc(sizeof(int) * size);\n    int *low = (int *)malloc(sizeof(int) * size);\n    bool *in = (bool *)malloc(sizeof(bool) * size);\n    int *stack = (int *)malloc(sizeof(int) * size);\n    int *dfs_v = (int *)malloc(sizeof(int) * size);\n    int *dfs_index = (int *)malloc(sizeof(int) * size);\n    \n    for (int i = 0; i < size; i++) {\n        order[i] = -1;\n        in[i] = false;\n    }\n    for (int i = 0; i < size; i++) {\n        if (order[i] != -1) continue;\n        dfs_v[num_dfs] = i;\n        dfs_index[num_dfs++] = -1;\n        while (num_dfs > 0) {\n            int v = dfs_v[--num_dfs];\n            int index = dfs_index[num_dfs];\n            if (index == -1) {\n                order[v] = low[v] = num_visit++;\n                stack[num_stack++] = v;\n                in[v] = true;\n            } else {\n                low[v] = min(low[v], low[graph[v][index]]);\n            }\n            for (index++; index < graph[v].size(); index++) {\n                int w = graph[v][index];\n                if (order[w] == -1) {\n                    dfs_v[num_dfs] = v;\n                    dfs_index[num_dfs++] = index;\n                    dfs_v[num_dfs] = w;\n                    dfs_index[num_dfs++] = -1;\n                    break;\n                } else if (in[w] == true) {\n                    low[v] = min(low[v], order[w]);\n                }\n            }\n            if (index == graph[v].size() && low[v] == order[v]) {\n                while (true) {\n                    int w = stack[--num_stack];\n                    in[w] = false;\n                    mapping[w] = num_scc;\n                    if (v == w) break;\n                }\n                num_scc++;\n            }\n        }\n    }\n    \n    free(order);\n    free(low);\n    free(in);\n    free(stack);\n    free(dfs_v);\n    free(dfs_index);\n}\n\nint SCC::get_size() {\n    return num_scc;\n}\n\nvector <vector <int> > SCC::get_graph() {\n    vector <vector <int> > new_graph(num_scc);\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < graph[i].size(); j++) {\n            if (mapping[i] != mapping[graph[i][j]]) new_graph[mapping[i]].push_back(mapping[graph[i][j]]);\n        }\n    }\n    return new_graph;\n}\n\nvector <vector <int> > SCC::get_rgraph() {\n    vector <vector <int> > new_graph(num_scc);\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < graph[i].size(); j++) {\n            if (mapping[i] != mapping[graph[i][j]]) new_graph[mapping[graph[i][j]]].push_back(mapping[i]);\n        }\n    }\n    return new_graph;\n}\n\nvector <int> SCC::get_mapping() {\n    return mapping;\n}\n\nvector <int> SCC::get_weight() {\n    vector <int> weight(num_scc, 0);\n    for (int i = 0; i < size; i++) weight[mapping[i]]++;\n    return weight;\n}\n\nmap <pair<int, int>, int> SCC::get_edge_weight() {\n    map <pair<int, int>, int> weight;\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < graph[i].size(); j++) {\n            if (mapping[i] != mapping[graph[i][j]]) weight[make_pair(mapping[i], mapping[graph[i][j]])]++;\n        }\n    }\n    return weight;\n}\n\nint a[200000];\nint b[200000];\nint f[1000];\nbitset <1000> b1[1000];\nbitset <1000> b2[1000];\nvector <pair<int, int>> v[1000];\nvector <vector <int>> g;\nvector <vector <int>> rg;\nvector <int> mapping;\n\nvoid dfs(int x) {\n    int i;\n    \n    f[x] = 1;\n    \n    for (i = 0; i < g[x].size(); i++) {\n        dfs(g[x][i]);\n        b1[x][g[x][i]] = true;\n        b1[x] |= b1[g[x][i]];\n    }\n}\n\nvoid dfs2(int x) {\n    int i;\n    \n    f[x] = 1;\n    \n    for (i = 0; i < rg[x].size(); i++) {\n        dfs2(rg[x][i]);\n        b2[x][rg[x][i]] = true;\n        b2[x] |= b2[rg[x][i]];\n    }\n}\n\nbool dfs3(int x, int y, int z) {\n    int i;\n    \n    f[x] = 1;\n    \n    if (x == y) return true;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        int nx = v[x][i].first;\n        \n        if (f[nx] == 1) continue;\n        if (mapping[nx] != mapping[x]) continue;\n        if (v[x][i].second == z) continue;\n        \n        if (dfs3(nx, y, z)) return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    int n, m, i, j;\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    SCC scc(n);\n    \n    for (i = 0; i < m; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n        \n        a[i]--;\n        b[i]--;\n        \n        v[a[i]].push_back(make_pair(b[i], i));\n        scc.add_edge(a[i], b[i]);\n    }\n    \n    scc.decompose();\n    \n    g = scc.get_graph();\n    rg = scc.get_rgraph();\n    mapping = scc.get_mapping();\n    map <pair<int, int>, int> weight = scc.get_edge_weight();\n    \n    for (i = 0; i < g.size(); i++) {\n        if (f[i] == 0) dfs(i);\n    }\n    \n    for (i = 0; i < g.size(); i++) f[i] = 0;\n    \n    for (i = 0; i < g.size(); i++) {\n        if (f[i] == 0) dfs2(i);\n    }\n    \n    for (i = 0; i < m; i++) {\n        int x = mapping[a[i]], y = mapping[b[i]];\n        \n        if (x == y) {\n            for (j = 0; j < n; j++) f[j] = 0;\n            \n            if (dfs3(a[i], b[i], i)) {\n                puts(\"same\");\n            } else {\n                puts(\"diff\");\n            }\n        } else {\n            if (weight[make_pair(x, y)] > 1 || (b1[x] & b2[y]).any()) {\n                puts(\"diff\");\n            } else {\n                puts(\"same\");\n            }\n        }\n        fflush(stdout);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            topo_sort[topo_cnt++] = u;\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    sort(topo_sort, topo_sort + topo_cnt, [] (int u, int v) -> bool {\n        if (dag_edge[u][v]) {\n            return true;\n        } else if (dag_edge[v][u]) {\n            return false;\n        }\n        return u < v;\n    });\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    for (auto u : piv) {\n        int t = find_stars(u.second, u.first);\n        if (unf[u.first] == unf[u.second]) {\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            puts(dag_second_visit[unf[u.first]].test(unf[u.second]) ? \"diff\" : \"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(int x){write(x);putchar('\\n');}\nconst int MAXN=1005;\nconst int MAXM=200005;\nstruct edge{int x,y;}a[MAXM];\nvector<pii> vec[MAXN];\n\n//bitset<MAXN> bi[MAXM+MAXN],bnow;\nint vi[MAXN][MAXN],cnt;\nvoid dfs1(int x,int o)\n{\n\tif(vi[o][x])return ;\n\tvi[o][x]=1;\n\tfor(int i=0;i<vec[x].size();++i)cnt++,dfs1(vec[x][i].first,o);\n}\nint bi[2][MAXN],tim;\nvoid dfs2(int x,int o)\n{\n\tif(bi[o][x])return ;\n\tbi[o][x]=tim;\n\tfor(int i=0;i<vec[x].size();++i)dfs2(vec[x][i].first,o);\n}\nint ans[MAXM],sta[MAXM],tp;\nint n,m;\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tvec[x].push_back(mp(y,i));\n\t\ta[i].x=x;a[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++)dfs1(i,i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttp=0;memset(bi,0,sizeof(bi));\n\t\tbi[0][i]=bi[1][i]=1;\n//\t\tfor(int k=last[i],lst=1;k;k=a[k].next,lst++)\n\t\tfor(int k=0,lst=1;k<vec[i].size();k++,lst++) \n\t\t{\n\t\t\tsta[++tp]=vec[i][k].second;tim=lst;\n\t\t\tdfs2(vec[i][k].first,0);\n\t\t}\n\t\tsta[tp+1]=0;\n\t\twhile(tp)\n\t\t{\n\t\t\tif(sta[tp+1])dfs2(a[sta[tp+1]].y,1);\n\t\t\tint y=a[sta[tp]].y;\n\t\t\tif(vi[y][i]==(bi[1][y]||(bi[0][y]<tp&&bi[0][y])))\n\t\t\t\tans[sta[tp]]=1;\n\t\t\ttp--;\n\t\t}\n\t}\n//\treturn 0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ans[i])puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=1010;\nconst int M=2e5+10;\nvector<pii> e[N];\ninline void add(int u,int v,int id){e[u].push_back(mp(v,id));}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[N];\nint main(){\n    n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n     }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    rep(x,1,n){\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tfor(auto k:e[x]){\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs2(v,x);\n\t}\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tint sz=(int)e[x].size()-1;\n\trpe(j,sz,0){\n\t    pii k=e[x][j];\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nvector<int> G[1010],R[1010],T[1010],id[1010];\nint ord[1010];\nbool vis[1010];\nint mem[1010];\nint cnt,cnt1,cnt2;\nvector<int> V;\nint A[200010],B[200010];\nbool can[200010];\nint now = 0;\n\nvoid unit(int v)\n{\n    if(vis[v])return;\n    vis[v] = true;\n    mem[v] = 1;\n    for(int i = 0; i < G[v].size(); i++)if(now != v || (i < cnt1 && cnt2 < i))unit(G[v][i]);\n    return;\n}\n\nvoid DFS1(int v)\n{\n    if(vis[v])return;\n    vis[v] = true;\n    for(int i = 0; i < G[v].size(); i++)DFS1(G[v][i]);\n    V.push_back(v);\n    return;\n}\n\nvoid DFS2(int v)\n{\n    if(ord[v] != 0)return;\n    ord[v] = cnt;\n    for(int i = 0; i < R[v].size(); i++)DFS2(R[v][i]);\n    return;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < M; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        R[b].push_back(a);\n        A[i] = a;\n        B[i] = b;\n        id[a].push_back(i);\n    }\n\n    memset(vis,false,sizeof(vis));\n    cnt = 0;\n    for(int i = 1; i <= N; i++)if(!vis[i])DFS1(i);\n    reverse(V.begin(),V.end());\n    for(int i = 1; i <= N; i++)if(ord[i] == 0)cnt++,DFS2(i);\n\n\n    for(int i = 1; i <= N; i++)\n    {\n        now++;\n        memset(mem,0,sizeof(mem));\n        memset(vis,false,sizeof(vis));\n        cnt1 = cnt2 = 0;\n        for(int j = 0; j < G[i].size(); j++)\n        {\n            cnt1++;\n            if(mem[B[id[i][j]]])can[id[i][j]] = true;\n            unit(G[i][j]);\n        }\n        memset(mem,0,sizeof(mem));\n        memset(vis,false,sizeof(vis));\n        cnt1 = cnt2 = G[i].size() - 1;\n        for(int j = G[i].size() - 1; j >= 0; j--)\n        {\n            cnt2--;\n            if(mem[B[id[i][j]]])can[id[i][j]] = true;\n            unit(G[i][j]);\n        }\n    }\n\n    for(int i = 0; i < M; i++)\n    {\n        int a = A[i],b = B[i];\n        if(ord[a] != ord[b])\n        {\n            if(can[i])printf(\"diff\\n\");\n            else printf(\"same\\n\");\n        }\n        else\n        {\n            if(can[i])printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N = 1005, M = 200005;\n\nint n, m, sc, cc, non, wh[N], col[N];\nbool vis[N], ans[M], shu[N], can[N];\npii e[M];\n\nvector<int> adj[N], rev[N], scc[N], out[N], st;\n\nvoid tdfs (int I) {\n\tif(vis[I]) return;\n\tvis[I] = true;\n\tfor(auto &T : adj[I]) if(T != non) tdfs(T);\n\tst.push_back(I);\n}\n\nvoid rdfs (int I) {\n\tif(vis[I]) return;\n\twh[I] = sc;\n\tvis[I] = true;\n\tfor(auto &T : rev[I]) if(T != non) rdfs(T);\n}\n\nvoid toposort (int I) {\n\tnon = I; sc = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vis[i]) tdfs(i);\n\t}\n\tfill(vis+1, vis+1+n, 0);\n\twhile(!st.empty()) {\n\t\tint T; T = st.back(); st.pop_back();\n\t\tif(!vis[T]) {rdfs(T); sc++;}\n\t}\n\tfill(vis+1, vis+1+n, 0);\n}\n\nvoid cdfs (int I) {\n\tcol[I] = cc;\n\tvis[I] = true;\n\tif(shu[I] && I != st[cc]) {\n\t\tcan[I] = true;\n\t\tif(wh[I] == wh[st[cc]]) can[st[cc]] = true;\n\t}\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T]) {\n\t\t\tif(col[I] == col[T]) continue;\n\t\t\tif(wh[T] == wh[st[col[T]]]) can[st[col[T]]] = true;\n\t\t}\n\t\telse if(T != non) cdfs(T);\n\t}\n}\n\nvoid solve (int I) {\n\ttoposort(I);\n\tfor(auto &T : adj[I]) shu[T] = true;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T]) continue;\n\t\tst.push_back(T);\n\t\tcdfs(T); cc++;\n\t}\n\tfor(auto &T : out[I]) {\n\t\tans[T] = can[e[T].Y];\n\t}\n\tcc = 0;\n\tfill(vis+1, vis+1+n, 0);\n\tst.clear();\n\tfor(auto &T : adj[I]) {\n\t\tshu[T] = false;\n\t\tcan[T] = false;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\te[i] = {A, B};\n\t\tout[A].push_back(i);\n\t\tadj[A].push_back(B);\n\t\trev[B].push_back(A);\n\t}\n\tfor(int i=1;i<=n;i++) solve(i);\n\ttoposort(0);\n\tfor(int i=1;i<=m;i++) {\n\t\tputs(ans[i] ^ wh[e[i].X] == wh[e[i].Y] ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define CO const\n#define IN inline\ntypedef long long int64;\n\ntemplate<class T> IN T read(){\n\tT x=0,w=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar())if(c=='-') w=-w;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*w;\n}\ntemplate<class T> IN T read(T&x){\n\treturn x=read<T>();\n}\n\nCO int N=1e3+10,M=2e5+10;\nstruct edge {int v,id;};\nvector<edge> to[N];\npair<int,int> E[M];\nint f[N][N][2],vis[N],T;\n\nvoid dfs(int u,int src,int id,int type){\n\tf[src][u][type]=id,vis[u]=T;\n\tfor(CO edge&e:to[u])if(vis[e.v]!=T)\n\t\tdfs(e.v,src,id,type);\n}\nvoid work(int src){\n\t++T,vis[src]=T;\n\tfor(CO edge&e:to[src])if(vis[e.v]!=T) // edit 1: vis check\n\t\tdfs(e.v,src,e.id,0);\n\treverse(to[src].begin(),to[src].end());\n\t++T,vis[src]=T;\n\tfor(CO edge&e:to[src])if(vis[e.v]!=T)\n\t\tdfs(e.v,src,e.id,1);\n}\nint main(){\n\tint n=read<int>(),m=read<int>();\n\tfor(int i=1;i<=m;++i){\n\t\tint u=read<int>(),v=read<int>();\n\t\tto[u].push_back({v,i});\n\t\tE[i]={u,v};\n\t}\n\tfor(int i=1;i<=n;++i) work(i);\n\tfor(int i=1;i<=m;++i){\n\t\tint u=E[i].first,v=E[i].second;\n\t\tputs((f[v][u][0]!=0)^(f[u][v][0]!=i or f[u][v][1]!=i)?\"diff\":\"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1005\n#define M 200005\nusing namespace std;\n\nint n,m;\nbool irp[N][N],lnk[N][N];\nint rt,cnt,fir[N];\nbool col[N];\nvector<int>to[N];\nstruct edge{int u,v;}e[M];\n\ninline int read()\n{\n\tint ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\ninline void add(int a,int b){to[a].push_back(b);e[++cnt]=(edge){a,b};}\n\ninline void dfs(int x)\n{\n\tcol[x]=lnk[rt][x]=1;\n\tfor(auto it:to[x]) if(!col[it]) dfs(it);\n}\n\ninline void insert(int x)\n{\n\trt=x;\n\tmemset(col+1,0,n*sizeof(col[0]));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n\treverse(to[x].begin(),to[x].end());\n\tmemset(col+1,0,n*sizeof(col[0]));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n}\n\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint a=read(),b=read();\n\t\tadd(a,b);\n\t}\n\tfor(int i=1;i<=n;++i)insert(i);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x=e[i].u,y=e[i].v;\n\t\tputs(irp[x][y]^lnk[y][x]?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\nconst int N=1005;\n\nint n,m;\nint ans[N],t[N][N],tt[N],b[N*200],a[N*200];\n\nint D,del,clk,vis[N];\nvoid dfs(int u)\n{\n\tif (vis[u]) return;\n\tif (u==del) return;\n\tvis[u]=clk;\n\tfor (int i=1;i<=tt[u];i++) dfs(b[t[u][i]]);\n}\n\nvoid work(int u)\n{\n\tdel=u;\n\tmemset(vis,0,sizeof(vis));\n\tfor (int v,i=1;i<=tt[u];i++)\n\t{\n\t\tclk=v=b[t[u][i]];\n\t\tdfs(v);\n\t}\n\tfor (int v,i=1;i<=tt[u];i++) \n\t{\n\t\tv=b[t[u][i]];\n\t\tif (v!=vis[v]) ans[t[u][i]]=1;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int u,v,i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\ta[i]=u,b[i]=v;\n\t\tt[u][++tt[u]]=i;\n\t}\n\t\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\twork(u);\n\t\tfor (int i=1;i<=tt[u]/2;i++) swap(t[u][i],t[u][ tt[u]-i+1 ]);\n\t\twork(u);\n\t}\n\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tclk=1;\n\t\tdel=0;\n\t\tdfs(u);\n\t\tfor (int i=1;i<=m;i++) if (b[i]==u) ans[i]^=vis[a[i]];\n\t}\n\n\tfor (int i=1;i<=m;i++) if (ans[i]) puts(\"diff\");else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nint a[maxm], b[maxm];\nint x[maxm], v[maxn][maxn], y[maxm], vis1[maxn], vis2[maxn];\nint rt;\nint *vis;\nvector<int> to[maxn], num[maxn]; int tot;\n\nvoid add(int a,int b){\n\tto[a].push_back(b);\n\tnum[a].push_back(++tot);\n}\n\nvoid dfs2(int u) {\n\tv[rt][u] = 1;\n\tfor (int v: to[u]) {\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = vis[u];\n\t\t\tdfs2(v);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", a+i, b+i);\n\t\tadd(a[i], b[i]);\n\t}\n\tfor (rt = 1; rt <= n; ++rt) {\n\t\tmemset(vis1, 0, sizeof(vis1));\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis1[rt] = vis2[rt] = rt;\n\t\tvis = vis1;\n\t\tfor (int v: to[rt]) {\n\t\t\tif (!vis[v]) vis[v] = v, dfs2(v);\n\t\t}\n\t\tvis = vis2;\n\t\treverse(to[rt].begin(), to[rt].end());\n\t\treverse(num[rt].begin(), num[rt].end());\n\t\tfor (int i = 0; i < (int)to[rt].size(); ++i) {\n\t\t\tint v = to[rt][i], e = num[rt][i];\n\t\t\tif (!vis[v]) vis[v] = v, dfs2(v);\n\t\t\tif (vis2[v] == vis1[v]) y[e] = false;\n\t\t\telse y[e] = true;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tputs(v[b[i]][a[i]]^y[i]?\"diff\":\"same\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint nowp[1100],ask[4400],to[200100];\nbool ans1[200100],ans2[200100];\nint main() {\n\tvector<int>G[1100];\n\tint n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        int a;\n\t\tscanf(\"%d%d\",&a,&to[i]);\n        G[a].push_back(i);\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++) nowp[j] = 0;\n        int s=1,t=0;\n        for(int p=0;p<G[i].size();p++) nowp[ask[++t]=to[G[i][p]]]=G[i][p];\n        while(s<=t) {\n            int x=ask[s++],y=nowp[x];\n            for(int p=0;p<G[x].size();p++) {\n                int q = to[G[x][p]];\n                if(q!=i&&nowp[q]!=-1){\n                    if(!nowp[q]) nowp[ask[++t]= q] = y;\n                    else if(nowp[q]!=y) nowp[ask[++t]=q] = -1;\n                }\n                else ans1[G[x][p]] = 1;\n            }\n        }\n        for(int p=0;p<G[i].size();p++) if(nowp[to[G[i][p]]]==-1) ans2[G[i][p]]=1;\n    }\n    for(int i=1;i<=m;i++){\n    \tif(ans1[i]==ans2[i]) puts(\"same\");\n    \telse puts(\"diff\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint nowp[1100],ask[4400],to[200100];\nbool ans1[200100],ans2[200100];\nvector<int>G[1100];\nint main() {\n\tint n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        int a;\n\t\tscanf(\"%d%d\",&a,&to[i]);\n        G[a].push_back(i);\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++) nowp[j] = 0;\n        int s=1,t=0;\n        for(int p=0;p<G[i].size();p++) nowp[ask[++t]=to[G[i][p]]]=G[i][p];\n        while(s<=t) {\n            int x=ask[s++],y=nowp[x];\n            for(int p=0;p<G[x].size();p++) {\n                int q = to[G[x][p]];\n                if(q!=i){\n                \tif(nowp[q]!=-1){\n                \t\tif(nowp[q]==0) nowp[ask[++t]=q]=y;\n                   \t\telse if(nowp[q]!=y) nowp[ask[++t]=q]=-1;\n\t\t\t\t\t}\n                }\n                else ans1[G[x][p]] = 1;\n            }\n        }\n        for(int p=0;p<G[i].size();p++)\n\t\t\tif(nowp[to[G[i][p]]]==-1) ans2[G[i][p]]=1;\n    }\n    for(int i=1;i<=m;i++){\n    \tif(ans1[i]==ans2[i]) puts(\"same\");\n    \telse puts(\"diff\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000 + 5;\nconst int M = 200000 + 5;\n\nint n, m;\nint vis[N], flag;\nvector<pair<int, int>> adj[N];\nint ans[M];\nint minv[N];\n\nvoid dfs(int u, int mark = 1, int forbid = -1)\n{\n    if (u == forbid) return;\n    if (vis[u]) return;\n    vis[u] = mark;\n    for (auto e : adj[u]) {\n        int v = e.first;\n        dfs(v, mark, forbid);\n    }\n}\n\nvoid solve()\n{\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u, --v;\n        adj[u].push_back(make_pair(v, i));\n    }\n\n    for (int i = 0; i < n; i++) {\n        memset(vis, 0, sizeof vis);\n        dfs(i);\n        for (int u = 0; u < n; u++) {\n            if (! vis[u]) continue;\n            for (auto e : adj[u]) {\n                if (e.first != i) continue;\n                ans[e.second] ++;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        memset(vis, 0, sizeof vis);\n        for (auto e : adj[i]) {\n            dfs(e.first, e.second + 1, i);\n        }\n        for (int j = 0; j < n; j++) {\n            minv[j] = vis[j];\n        }\n        memset(vis, 0, sizeof vis);\n        for (auto e = adj[i].rbegin(); e != adj[i].rend(); e++) {\n            dfs(e->first, e->second + 1, i);\n        }\n        for (auto e : adj[i]) {\n            int v = e.first;\n            if (e.second + 1 != minv[v] || e.second + 1 != vis[v]) {\n                ans[e.second] += 2;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        puts(ans[i] == 3 || ans[i] == 0 ? \"same\" : \"diff\");\n        //cout << ans[i] % 2 << ' ' << ans[i] / 2 << endl;\n    }\n\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#define maxn 200100\nusing namespace std;\nint n,m,tot,vis[1010],sz[1010],fr[1010],to[1010],th[1010][1010];\nvector<int> v[1010];\nint read(){\n\tint x=0;char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn x;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tvis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=0;i<sz[x];i++)\n\t\tdfs(v[x][i],s,cur);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&fr[i],&to[i]);\n\t\tv[fr[i]].push_back(to[i]); sz[fr[i]]++;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=0;j<sz[i];j++) dfs(v[i][j],i,v[i][j]);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=fr[i],y=to[i];\n\t\tif((th[y][x]&&th[x][y]!=-1)||(!th[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1005;\nint n,m,i,x,y,ans[N],dfn[N],low[N],xb,st[N],w,bel[N],scnt,f[N];\nvector<pair<int,int>>e[N],tmp,tmp2;\nbool b[N];\nvoid dfs(int x){\n\tdfn[x]=low[x]=++xb;st[++w]=x;\n\tfor(auto u:e[x])if(!dfn[u.first]){\n\t\tdfs(u.first);low[x]=min(low[x],low[u.first]);\n\t}else if(!bel[u.first])low[x]=min(low[x],low[u.first]);\n\tif(dfn[x]==low[x])for(++scnt;;){\n\t\tbel[st[w]]=scnt;\n\t\tfor(auto u:e[st[w]])if(bel[u.first] && bel[u.first]!=scnt)\n\t\t\tf[scnt]=max(f[scnt],f[bel[u.first]]+1);\n\t\tif(st[w--]==x)break;\n\t}\n}\nvoid dfs2(int x){b[x]=1;for(auto u:e[x])if(!b[u.first])dfs2(u.first);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=m;++i)cin>>x>>y,e[x].push_back(make_pair(y,i));\n\tfor(i=1;i<=n;++i)if(!dfn[i])dfs(i);\n\tfor(i=1;i<=n;++i){\n\t\ttmp.clear();\n\t\tfor(auto u:e[i])if(bel[u.first]!=bel[i]){if(f[bel[i]]>f[bel[u.first]]+1)ans[u.second]=1;}\n\t\t\telse tmp.push_back(u);\n\t\te[i]=tmp;\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tmemset(b+1,0,n);b[i]=1;tmp.clear();tmp2.clear();\n\t\tfor(auto u:e[i])if(!b[u.first])tmp.push_back(u),dfs2(u.first);\n\t\t\telse tmp2.push_back(u);\n\t\tmemset(b+1,0,n);b[i]=1;reverse(tmp.begin(),tmp.end());\n\t\tfor(auto u:tmp2)dfs2(u.first);\n\t\tfor(auto u:tmp)if(!b[u.first])ans[u.second]=1,dfs2(u.first);\n\t}\n\tfor(i=1;i<=m;++i)cout<<(ans[i]?\"diff\\n\":\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(e, E) for (const auto& e : E)\n#define RESIDUE(s, t) (capacity[s][t] - flow[s][t])\nusing Weight = ll;\nusing Array = vector<ll>;\nusing Matrix = vector<vector<ll>>;\nstruct Edge\n{\n    Edge() = default;\n    Edge(const int src, const int dst, const ll weight) : src{src}, dst{dst}, weight{weight} {}\n    int src;\n    int dst;\n    ll weight;\n};\nusing Graph = vector<vector<Edge>>;\nGraph cutTree(const Graph& g)\n{\n    int n = g.size();\n    Matrix capacity(n, Array(n)), flow(n, Array(n));\n    for (int u = 0; u < n; u++) {\n        for (const auto e : g[u]) {\n            capacity[u][e.src] += e.weight;\n        }\n    }\n\n    vector<int> p(n), prev;\n    vector<Weight> w(n);\n    for (int s = 1; s < n; ++s) {\n        int t = p[s];  // max-flow(s, t)\n        REP(i, n)\n        REP(j, n)\n        flow[i][j] = 0;\n        Weight total = 0;\n        while (1) {\n            queue<int> Q;\n            Q.push(s);\n            prev.assign(n, -1);\n            prev[s] = s;\n            while (!Q.empty() && prev[t] < 0) {\n                int u = Q.front();\n                Q.pop();\n                FOR(e, g[u])\n                if (prev[e.dst] < 0 && RESIDUE(u, e.dst) > 0) {\n                    prev[e.dst] = u;\n                    Q.push(e.dst);\n                }\n            }\n            if (prev[t] < 0) goto esc;\n            Weight inc = INF<ll>;\n            for (int j = t; prev[j] != j; j = prev[j])\n                inc = min(inc, RESIDUE(prev[j], j));\n            for (int j = t; prev[j] != j; j = prev[j])\n                flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n            total += inc;\n        }\n    esc:\n        w[s] = total;  // make tree\n        REP(u, n)\n        if (u != s && prev[u] != -1 && p[u] == t)\n            p[u] = s;\n        if (prev[p[t]] != -1)\n            p[s] = p[t], p[t] = s, w[s] = w[t], w[t] = total;\n    }\n    Graph T(n);  // (s, p[s]) is a tree edge of weight w[s]\n    REP(s, n)\n    if (s != p[s]) {\n        T[s].push_back(Edge(s, p[s], w[s]));\n        T[p[s]].push_back(Edge(p[s], s, w[s]));\n    }\n    return T;\n}\n\n// Gomory-Hu tree を用いた最大流 O(n)\nWeight maximumFlow(const Graph& T, int u, int t, int p = -1, Weight w = INF<ll>)\n{\n    if (u == t) return w;\n    Weight d = INF<ll>;\n    FOR(e, T[u])\n    if (e.dst != p)\n        d = min(d, maximumFlow(T, e.dst, t, u, min(w, e.weight)));\n    return d;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    using P = pair<int, int>;\n    vector<P> edge(M);\n    Graph g(N);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(Edge{u, v, 1});\n        edge[i] = {u, v};\n    }\n\n    const auto tree = cutTree(g);\n    for (int i = 0; i < M; i++) {\n        const int u = edge[i].first;\n        const int v = edge[i].second;\n        const ll stcut = maximumFlow(tree, u, v);\n        const ll tscut = maximumFlow(tree, v, u);\n        cout << (tscut > 0 and stcut > 1 ? \"same\" : \"diff\") << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 1010;\nconst int MM = 100010;\n\nint N, M;\nint a[MM], b[MM];\n\nvector<pii> g[MN];\n\nbool no_need[MM];\nbool vis[MN];\nbool can[MN][MN];\n\nvoid dfs(int v, int st) {\n\tvis[v] = 1;\n\tfor (auto e : g[v]) {\n\t\tif (!vis[e.fi] && e.fi != st) {\n\t\t\tdfs(e.fi, st);\n\t\t} \n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\n\trep(i, M) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].eb(b[i], i);\n\t}\n\n\trep(i, N) {\n\t\tqueue<int> que;\n\t\tcan[i][i] = 1;\n\t\tque.push(i);\n\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (auto e : g[v]) {\n\t\t\t\tif (!can[i][e.fi]) {\n\t\t\t\t\tcan[i][e.fi] = 1;\n\t\t\t\t\tque.push(e.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(t, 2) {\n\t\t\tmemset(vis, 0, sizeof(vis));\n\n\t\t\tfor (auto e : g[i]) {\n\t\t\t\tif (vis[e.fi]) {\n\t\t\t\t\tno_need[e.se] = true;\n\t\t\t\t} else {\n\t\t\t\t\tdfs(e.fi, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(ALL(g[i]));\n\t\t}\n\t}\n\n\trep(i, M) {\n\t\tputs(no_need[i] == can[b[i]][a[i]] ? \"same\" : \"diff\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=1005;\nconst int maxm=200005;\nint n,m,ql,qr;\nvector<pii>dat[maxn];\nbitset<maxn>edge[maxn],val1[maxn],val2,vis,cur;\nint que[maxn];\nbool ans[maxm];\n\nvoid bfs(){\n\twhile(ql<qr){\n\t\tint x=que[ql++];\n\t\tcur=~vis&edge[x];\n\t\tint y=-1;\n\t\tfor(;;){\n\t\t\ty=cur._Find_next(y);\n\t\t\tif(y==maxn)break;\n\t\t\tvis[y]=1;\n\t\t\tque[qr++]=y;\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tedge[u][v]=1;\n\t\tdat[u].pb(mp(v,i));\n\t}\n\trep(i,n){\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\tque[qr++]=i;\n\t\tbfs(); \n\t\tval1[i]=vis;\n\t}\n\trep(i,n){\n\t\tval2=0;\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\trep(j,int(dat[i].size())){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tif(vis[k])val2[k]=1;\n\t\t\tvis[k]=1;\n\t\t\tque[qr++]=k;\n\t\t\tbfs();\n\t\t}\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\tfor(int j=int(dat[i].size())-1;j>=0;j--){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tif(vis[k])val2[k]=1;\n\t\t\tvis[k]=1;\n\t\t\tque[qr++]=k;\n\t\t\tbfs();\n\t\t}\n\t\trep(j,int(dat[i].size())){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tans[dat[i][j].snd]=(val1[k][i]!=val2[k]);\n\t\t}\n\t}\n\trep(i,m)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\nint n, m, clk, cnt;\nstd::vector<std::vector<std::pair<int, int>>> e;\nstd::vector<int> a, b, ans, dfn, low, belong, stk;\nstd::vector<std::vector<int>> f;\nvoid dfs(int u) {\n    stk.push_back(u);\n    dfn[u] = low[u] = clk++;\n    for (auto &&edge : e[u]) {\n        int v, i;\n        std::tie(v, i) = edge;\n        if (dfn[v] == -1) {\n            dfs(v);\n            low[u] = std::min(low[u], low[v]);\n        } else if (belong[v] == -1) {\n            low[u] = std::min(low[u], dfn[v]);\n        }\n    }\n    if (dfn[u] == low[u]) {\n        int v;\n        do {\n            v = stk.back();\n            stk.pop_back();\n            belong[v] = cnt;\n        } while (v != u);\n        ++cnt;\n    }\n}\nvoid solve() {\n    for (int s = 0; s < n; ++s) {\n        f.assign(n, std::vector<int>(2, -1));\n        std::queue<std::pair<int, int>> que;\n        f[s][0] = f[s][1] = s;\n        for (auto &&edge : e[s]) {\n            int v, i;\n            std::tie(v, i) = edge;\n            f[v][0] = v;\n            que.emplace(v, 0);\n        }\n        while (!que.empty()) {\n            int u, j;\n            std::tie(u, j) = que.front();\n            que.pop();\n            for (auto &&edge : e[u]) {\n                int v, i;\n                std::tie(v, i) = edge;\n                if (f[v][0] == -1) {\n                    f[v][0] = f[u][j];\n                    que.emplace(v, 0);\n                } else if (f[v][1] == -1 && f[v][0] != f[u][j]) {\n                    f[v][1] = f[u][j];\n                    que.emplace(v, 1);\n                }\n            }\n        }\n        for (auto &&edge : e[s]) {\n            int v, i;\n            std::tie(v, i) = edge;\n            if (f[v][1] != -1)\n                ans[i] ^= 1;\n        }\n    }\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n >> m;\n    a.resize(m);\n    b.resize(m);\n    ans.resize(m);\n    e.resize(n);\n    dfn.assign(n, -1);\n    low.resize(n);\n    belong.assign(n, -1);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> a[i] >> b[i];\n        --a[i];\n        --b[i];\n        e[a[i]].emplace_back(b[i], i);\n    }\n    for (int i = 0; i < n; ++i)\n        if (dfn[i] == -1)\n            dfs(i);\n    for (int i = 0; i < m; ++i)\n        if (belong[a[i]] == belong[b[i]])\n            ans[i] = 1;\n    solve();\n    for (int i = 0; i < m; ++i)\n        std::cout << (ans[i] == 1 ? \"diff\" : \"same\") << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nvector<int> G[1010],R[1010],T[1010],id[1010];\nint ord[1010] = {0};\nbool vis[1010];\nint mem[1010];\nint cnt,cnt1,cnt2;\nvector<int> V;\nint A[200010],B[200010];\nbool can[200010];\nint now = 0;\n\nvoid unit(int v)\n{\n    if(vis[v])return;\n    vis[v] = true;\n    mem[v] = 1;\n    for(int i = 0; i < G[v].size(); i++)if(now != v || (i < cnt1 && cnt2 < i))unit(G[v][i]);\n    return;\n}\n\nvoid DFS1(int v)\n{\n    if(vis[v])return;\n    vis[v] = true;\n    for(int i = 0; i < G[v].size(); i++)DFS1(G[v][i]);\n    V.push_back(v);\n    return;\n}\n\nvoid DFS2(int v)\n{\n    if(ord[v] != 0)return;\n    ord[v] = cnt;\n    for(int i = 0; i < R[v].size(); i++)DFS2(R[v][i]);\n    return;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < M; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        R[b].push_back(a);\n        A[i] = a;\n        B[i] = b;\n        id[a].push_back(i);\n    }\n\n    memset(vis,false,sizeof(vis));\n    cnt = 0;\n    for(int i = 1; i <= N; i++)if(!vis[i])DFS1(i);\n    reverse(V.begin(),V.end());\n    for(int i = 0; i < N; i++)if(ord[V[i]] == 0)cnt++,DFS2(V[i]);\n\n\n    for(int i = 1; i <= N; i++)\n    {\n        now++;\n        memset(mem,0,sizeof(mem));\n        memset(vis,false,sizeof(vis));\n        cnt1 = cnt2 = 0;\n        for(int j = 0; j < G[i].size(); j++)\n        {\n            cnt1++;\n            if(mem[B[id[i][j]]])can[id[i][j]] = true;\n            unit(G[i][j]);\n        }\n        memset(mem,0,sizeof(mem));\n        memset(vis,false,sizeof(vis));\n        cnt1 = cnt2 = G[i].size() - 1;\n        for(int j = G[i].size() - 1; j >= 0; j--)\n        {\n            cnt2--;\n            if(mem[B[id[i][j]]])can[id[i][j]] = true;\n            unit(G[i][j]);\n        }\n    }\n\n    for(int i = 0; i < M; i++)\n    {\n        int a = A[i],b = B[i];\n        if(ord[a] != ord[b])\n        {\n            if(can[i])printf(\"diff\\n\");\n            else printf(\"same\\n\");\n        }\n        else\n        {\n            if(can[i])printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#define maxn 1005\n#define _ 0\nusing namespace std;\nstruct nod\n{\n\tint nex,id;\n\tnod(int a,int b)\n\t{\n\t\tnex=a;\n\t\tid=b;\n\t}\n\tnod(){}\n};\nint n,m,tim;\nint vis[maxn];\nint bel[maxn][maxn][2];\nint u[maxn*maxn],v[maxn*maxn];\nvector<nod> edge[maxn];\nvoid dfs(int now,int fa,int b,int f)\n{\n//\tcerr<<now<<\" \"<<fa<<\" \"<<b<<\" \"<<f<<endl;\n\tvis[now]=tim; bel[fa][now][f]=b;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,fa,b,f);\n}\nvoid solve(int now)\n{\n\ttim++; vis[now]=tim;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,0);\n\n\treverse(edge[now].begin(),edge[now].end());\n\n\ttim++; vis[now]=tim;\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsolve(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif( (bel[v[i]][u[i]][0]!=0) ^ _ ^ (bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i) )\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+10;\nconst int M=2e5+10;\n#define pb push_back\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,fr[M],to[M],nxt[M],tt,s,t,id[N],h[N];\nbool vis[N][N],can[M];\nvector<int> E[N];\n\nvoid adde(int u,int v) {\n\tfr[++tt]=u,to[tt]=v,nxt[tt]=h[u],h[u]=tt;\n\tE[u].push_back(v);\n}\n\nvoid dfs(int u) {\n\tvis[s][u]=1;\n\tif(id[u]) return;\n\tid[u]=t;\n\tfor(auto v:E[u]) if(!id[v]&&v!=s) dfs(v);\n}\n\nint main() {\n\tcin>>n>>m;\n\tfor(int i=1,u,v;i<=m;i++) u=gi(),v=gi(),adde(u,v);\n\tfor(s=1;s<=n;s++) {\n\t\tmemset(id,0,sizeof(id));\n\t\tvector<int> son;\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tson.push_back(v),dfs(t=v);\n\t\treverse(son.begin(),son.end());\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tif(id[v]!=v) can[i]=1;\n\t\tmemset(id,0,sizeof(id));\n\t\tfor(auto v:son) dfs(t=v);\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tif(id[v]!=v) can[i]=1;\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tint u=fr[i],v=to[i];\n\t\tif((can[i])==(vis[v][u])) cout<<\"same\\n\";\n\t\telse cout<<\"diff\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-04-27 20:30:30\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst int N=1111;\nconst int M=211111;\nvii eg[N];\npii an[M];\nint fg,start,p[N],q[N];\nbool vis[N][N],can[N][N];\nvoid dfs(int u){\n    if(vis[start][u])return;\n    vis[start][u]=1;\n    for(auto j:eg[u])dfs(j.x);\n}\nvoid gao(int u,int *f){\n    if(u==start)return;\n    if(f[u]!=0)return;\n    f[u]=fg;\n    for(auto j:eg[u])gao(j.x,f);\n}\nint main(){\n    int n,m;cin>>n>>m;\n    rep(i,0,m){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);--a;--b;\n        an[i]={a,b};\n        eg[a].eb(b,i);\n    }\n    rep(i,0,n){start=i;dfs(i);}\n    rep(i,0,n){\n        clr(p);clr(q);\n        fg=0;\n        start=i;\n        for(auto j:eg[i]){\n            ++fg;\n            gao(j.x,p);\n        }\n        per(j,SZ(eg[i]),0){\n            gao(eg[i][j].x,q);\n            --fg;\n        }\n        int t=0;\n        for(auto j:eg[i]){\n            ++t;\n            if(p[j.x]!=t || q[j.x]!=t)can[i][j.x]=1;\n        }\n    }\n    rep(i,0,m){\n        int x,y;tie(x,y)=an[i];\n        // OUT(x,y,can[x][y],vis[y][x]);\n        if(can[x][y]==vis[y][x])puts(\"same\");\n        else puts(\"diff\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n \nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[N] , B[N];\nint stk[N] , top;\nint ans[M];\nint L[N][N], R[N][N];\n\nvoid add(int x, int y) {\n\tne[++ cnt] = fir[x];\n\tfir[x] = cnt;\n\tto[cnt] = y;\n}\n\nbool can[N][N];\n\nqueue <int> q;\n\nvector <int> son[N];\n\n#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\nvoid solve(int x) {\n\twhile(!q.empty()) q.pop();\n\tq.push(x);\n\twhile(!q.empty()) {\n\t\tint ind = q.front();\n\t\tcan[x][ind] = 1;\n\t\tq.pop();\n\t\tForeachson(i, ind) {\n\t\t\tint V = to[i];\n\t\t\tif(can[x][V]) continue;\n\t\t\tq.push(V);\n\t\t}\n\t}\n\t\n\tForeachson(i, x) {\n\t\tint V = to[i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!L[x][V]) {\n\t\t\tq.push(V);\n\t\t\tL[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tForeachson(i, ind) {\n\t\t\t\tint v = to[i];\n\t\t\t\tif(!L[x][v] && v != x) {\n\t\t\t\t\tL[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < (int) son[x].size(); ++ i) {\n\t\tint V = son[x][i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!R[x][V]) {\n\t\t\tq.push(V);\n\t\t\tR[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < (int) son[ind].size(); ++ i) {\n\t\t\t\tint v = son[ind][i];\n\t\t\t\tif(!R[x][v] && v != x) {\n\t\t\t\t\tR[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x, y);\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tForeachson(j, i) {\n\t\t\tint V = to[j];\n\t\t\tson[i].push_back(V);\n\t\t}\n\t\treverse(son[i].begin(), son[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tsolve(i);\n\t}\n\t\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(L[A[i]][B[i]] != B[i] || R[A[i]][B[i]] != B[i]) {\n\t\t\tif(!can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\telse {\n\t\t\tif(can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\n// for i in f..<t { as swift\n#define forin(i, f, t) for(auto i = f; i < t; i++)\n\nusing namespace std;\nusing ll = long long;\n\nusing XY = pair<int, int>;\n\nvector<vector<int>> nodes;\nvector<bool> visited;\n\nvoid mark(int t, int c, int id, vector<int> &map) {\n    if (c == t || visited[c]) return;\n    visited[c] = true;\n    map[c] = id;\n    forin(i, 0, nodes[c].size()) {\n        mark(t, nodes[c][i], id, map);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<XY> e(m);\n    nodes.resize(n + 1);\n    forin(i, 0, m) {\n        cin >> e[i].first >> e[i].second;\n        nodes[e[i].first].push_back(e[i].second);\n    }\n    vector<vector<int>> fMap(n + 1, vector<int>(n + 1, 0)), dMap(n + 1, vector<int>(n + 1, 0));\n    forin(i, 1, n + 1) {\n        visited.assign(n + 1, false);\n        int id = 1;\n        forin(j, 0, nodes[i].size()) {\n            mark(i, nodes[i][j], id++, fMap[i]);\n        }\n        visited.assign(n + 1, false);\n        id = (int)nodes[i].size();\n        for (auto j = nodes[i].size(); j > 0; --j) {\n            mark(i, nodes[i][j - 1], id--, dMap[i]);\n        }\n    }\n    forin(i, 0, m) {\n        auto edge = e[i];\n        if ((fMap[edge.first][edge.second] != dMap[edge.first][edge.second]) == (fMap[edge.second][edge.first] > 0)) {\n            cout << \"same\" << endl;\n        } else {\n            cout << \"diff\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint chA[100005], chB[100005];\nvector<int> ch[1005];\nbool two[1005][1005];\nbool care[1005];\nint sccid[1005];\nbool ons[1005];\nint vis[1005];\nint idx[1005];\nvector<int> S;\nint lo[1005];\nint n, m;\n\nvoid dfs1(int at, int fr, int via)\n{\n\tif (care[at] && via != at) two[fr][at] = true;\n\tif (vis[at] == -1) vis[at] = via;\n\telse if (vis[at] == -2) return;\n\telse if (vis[at] == via) return;\n\telse vis[at] = -2;\n\tfor (int u: ch[at]) dfs1(u, fr, via);\n}\n\nint dfs2(int at)\n{\n\tstatic int Y, Z;\n\tidx[at] = lo[at] = ++Z;\n\tS.push_back(at); ons[at] = true;\n\tfor (int u: ch[at])\n\t\tif (!idx[u]) lo[at] = min(lo[at], dfs2(u));\n\t\telse if (ons[u]) lo[at] = min(lo[at], idx[u]);\n\tif (idx[at] == lo[at])\n\t{\n\t\tY++;\n\t\twhile (true)\n\t\t{\n\t\t\tint u = S.back(); S.pop_back();\n\t\t\tons[u] = false;\n\t\t\tsccid[u] = Y;\n\t\t\tif (u == at) break;\n\t\t}\n\t}\n\treturn lo[at];\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0;i < m;i++)\n\t{\n\t\tscanf(\"%d%d\", chA+i, chB+i);\n\t\tch[--chA[i]].push_back(--chB[i]);\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tfor (int u: ch[i]) care[u] = true;\n\t\tfor (int j = 0;j < n;j++) vis[j] = -1;\n\t\tvis[i] = -2;\n\t\tfor (int u: ch[i]) dfs1(u, i, u);\n\t\tfor (int u: ch[i]) care[u] = false;\n\t}\n\tfor (int i = 0;i < n;i++) if (!idx[i]) dfs2(i);\n\tfor (int i = 0;i < m;i++) printf(\"%s\\n\", ((sccid[chA[i]] == sccid[chB[i]]) == (two[chA[i]][chB[i]]))?\"same\":\"diff\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\nstruct graph_t\n{\n\tint front,nex;\n}graph[201001];\nint tail=1000;\n\nvoid addedge(int u,int v)\n{\n\tint tmp=graph[u].nex;\n\tgraph[u].nex=++tail;\n\tgraph[tail].front=v;\n\tgraph[tail].nex=tmp;\n}\n\nint vis[1001][1001];\npair<int,int> edge[200001];\nint mark[1001];\nint times=1;\n\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=times;\n\tfor(int i=graph[now].nex;i;i=graph[i].nex)\n\t{\n\t\tif(now==from)continue; \n\t\tif(vis[from][graph[i].front]<2&&mark[graph[i].front]!=times)\n\t\t{\n\t\t\tdfs(from,graph[i].front);\n\t\t}\n\t}\n//\tmark[now]=false;\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i]=make_pair(from,to);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=graph[i].nex;j;j=graph[j].nex)\n\t\t{\n\t\t\tif(vis[i][graph[j].front]<2)\n\t\t\t{\n\t\t\t\tdfs(i,graph[j].front);\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nstruct Edge{\n    int to,id;\n};\nconst int maxn=1005;\nconst int maxm=2e5+7;\nvc<Edge> G[maxn];\npi edge[maxm];\nbool vis[maxn];\nbool can[maxn][maxn];\nint go[maxn][maxn][2];\nvoid dfs(int u,int st,int tp,int fi=-1)\n{\n    if(vis[u]) return ;\n    can[st][u]=1;\n    vis[u]=1;\n    go[st][u][tp]=fi;\n    for(auto e:G[u])if(!vis[e.to])\n    {\n        int v=e.to;\n        dfs(v,st,tp,fi==-1?e.id:fi);\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    for(int i=0,u,v;i<m;i++)\n    {\n        cin>>u>>v;\n        edge[i]={u,v};\n        G[u].push_back(Edge{v,i});\n    }\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        dfs(i,i,0);\n        memset(vis,0,sizeof(vis));\n        reverse(G[i].begin(),G[i].end());\n        dfs(i,i,1);\n    }\n    for(int i=0,u,v;i<m;i++)\n    {\n        u=edge[i].first,v=edge[i].second;\n        //dbg(u,v,can[v][u]);\n        if(can[v][u]^(go[u][v][0]!=i||go[u][v][1]!=i)) cout<<\"diff\\n\";\n        else cout<<\"same\\n\";\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 1005\nstruct node{\n\tint to;\n\tint id;\n\tnode(int a,int b){\n\t\tto=a;\n\t\tid=b;\n\t}\n\tnode(){}\n};\nint n,m;\nint tot;\nint vis[maxn];\nint bh[maxn][maxn][3];\nvector<node> e[maxn];\nint u[maxn*maxn*2];\nint v[maxn*maxn*2];\nvoid dfs(int root,int fa,int b,int f){\n\tvis[root]=tot;\n\tbh[fa][root][f]=b;\n\tint len=e[root].size();\n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[root][i].to]!=tot)\n\t\tdfs(e[root][i].to,fa,b,f);\n\t}\n}\nvoid s(int now){\n\ttot++;\n\tvis[now]=tot;\n\tint len=e[now].size();\n//\tcout<<now<<\" \"<<len<<endl; \n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[now][i].to]!=tot)\n\t\tdfs(e[now][i].to,now,e[now][i].id,0);\n\t}\n\treverse(e[now].begin(),e[now].end());\n\ttot++;\n\tvis[now]=tot;\n//\tint len=e[now].size();\n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[now][i].to]!=tot)\n\t\tdfs(e[now][i].to,now,e[now][i].id,1);\n\t}\t\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\te[u[i]].push_back(node(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\ts(i);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif((bh[u[i]][v[i]][0]!=i||bh[u[i]][v[i]][1]!=i) ^ 0 ^ (bh[v[i]][u[i]][0]!=0)){\n\t\t\tputs(\"diff\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define mem(a) memset(a,0,sizeof(a))\ninline char get_char(){\n\tstatic char buf[1000000],*p1,*p2;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read(){\n    int numm=0;\n    char _;_=get_char();\n    while(_<'0'||_>'9'){_=get_char();} \n    while(_>='0'&&_<='9'){numm=(numm<<3)+(numm<<1)+(_^48);_=get_char();   }\n    return numm;\n}\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nvector<int>E[maxn];\nint n,m,beg[maxn],len,num[maxn][maxn];\nbool can[maxn][maxn],vis[maxn],can1[maxn][maxn];\nint vis1[maxn],vis2[maxn],from[maxm],to[maxm];\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tint size=E[u].size()-1;\n\tREP(i,0,size){\n\t\tint v=E[u][i];\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nvoid dfs1(int u){\n\tvis[u]=1;\n\tint size=E[u].size()-1;\n\tREP(i,0,size){\n\t\tint v=E[u][i];\n\t\tif(vis[v])continue;\n\t\tvis1[v]=num[u][v];\n\t\tdfs1(v);\n\t}\n}\nvoid dfs2(int u){\n\tvis[u]=1;\n\tint size=E[u].size()-1;\n\tDREP(i,size,0){\n\t\tint v=E[u][i];\n\t\tif(vis[v])continue;\n\t\tvis2[v]=num[u][v];\n\t\tdfs2(v);\n\t}\n}\nint main(){\n//\tfreopen(\"test.txt\",\"r\",stdin);\n\tn=read();m=read();\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tu=read();v=read();\n\t\tE[u].push_back(v);\n\t\tnum[u][v]=++len;\n\t\tfrom[len]=u;\n\t\tto[len]=v;\n\t}\n\tREP(i,1,n){\n\t\tdfs(i,i);\n\t\tmem(vis);\n\t}\n\tREP(i,1,n){\n\t\tdfs1(i);\n\t\tmem(vis);\n\t\tdfs2(i);\n\t\tmem(vis);\n\t\tint size=E[i].size()-1;\n\t\tREP(j,0,size){\n\t\t\tint v=E[i][j];\n\t\t\tif(vis1[v]!=num[i][v] || vis2[v]!=num[i][v])\n\t\t\t\tcan1[i][v]=1;\n\t\t}\n\t\tmem(vis1);\n\t\tmem(vis2);\n\t}\n\tREP(i,1,m){\n\t\tint u=from[i],v=to[i];\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tputs(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n一个有向图, 对每一条边查询反向后强连通块的数目是否改变\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=3003;\nconst int M=2e5+5;\n\nint n,m,v[M],u[M],F[N][N][3];\n\nbool vis[N];\n\nstruct node{\n\tint id,v;\n};\n\nvector<node>Link[N];\n\nvoid dfs(int x,int fa,int Id,int sta){\n\tvis[x]=1;F[fa][x][sta]=Id;\n\tint Len=Link[x].size();\n\tfor(int i=0;i<Len;i++)\n\t\tif(!vis[Link[x][i].v])\n\t\t\tdfs(Link[x][i].v,fa,Id,sta);\n}\n\nvoid sol(int x){\n\tint Len=Link[x].size();\n\tmemset(vis,0,sizeof(vis));\n\tvis[x]=1;\n\tfor(int i=0;i<Len;i++)\n\t\tif(!vis[Link[x][i].v])\n\t\t\tdfs(Link[x][i].v,x,Link[x][i].id,0);\n\treverse(Link[x].begin(),Link[x].end());\n\tmemset(vis,0,sizeof(vis));\n\tvis[x]=1;\n\tfor(int i=0;i<Len;i++)\n\t\tif(!vis[Link[x][i].v])\n\t\t\tdfs(Link[x][i].v,x,Link[x][i].id,1);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tLink[u[i]].push_back((node){i,v[i]});\n\t}\n\tfor(int i=1;i<=n;i++) sol(i);\n\tfor(int i=1;i<=m;i++){\n\t\tif((F[v[i]][u[i]][0]>0)^(F[u[i]][v[i]][0]!=i||F[u[i]][v[i]][1]!=i))\n\t\t\tprintf(\"diff\\n\");\n\t\telse \n\t\t\tprintf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\nint n, m, clk, cnt;\nstd::vector<std::vector<std::pair<int, int>>> e;\nstd::vector<int> a, b, ans, dfn, low, belong, stk;\nstd::vector<std::vector<int>> f;\nvoid dfs(int u) {\n    stk.push_back(u);\n    dfn[u] = low[u] = clk++;\n    for (auto &&edge : e[u]) {\n        int v, i;\n        std::tie(v, i) = edge;\n        if (dfn[v] == -1) {\n            dfs(v);\n            low[u] = std::min(low[u], low[v]);\n        } else if (belong[v] == -1) {\n            low[u] = std::min(low[u], dfn[v]);\n        }\n    }\n    if (dfn[u] == low[u]) {\n        int v;\n        do {\n            v = stk.back();\n            stk.pop_back();\n            belong[v] = cnt;\n        } while (v != u);\n        ++cnt;\n    }\n}\nvoid solve() {\n    for (int s = 0; s < n; ++s) {\n        f.assign(n, std::vector<int>(2, -1));\n        std::queue<std::pair<int, int>> que;\n        f[s][0] = f[s][1] = s;\n        for (auto &&edge : e[s]) {\n            int v, i;\n            std::tie(v, i) = edge;\n            f[v][0] = v;\n            que.emplace(v, 0);\n        }\n        while (!que.empty()) {\n            int u, j;\n            std::tie(u, j) = que.front();\n            que.pop();\n            for (auto &&edge : e[u]) {\n                int v, i;\n                std::tie(v, i) = edge;\n                if (f[v][0] == -1) {\n                    f[v][0] = f[u][j];\n                    que.emplace(v, 0);\n                } else if (f[v][1] == -1 && f[v][0] != f[u][j]) {\n                    f[v][1] = f[u][j];\n                    que.emplace(v, 1);\n                }\n            }\n        }\n        for (auto &&edge : e[s]) {\n            int v, i;\n            std::tie(v, i) = edge;\n            if (f[v][1] != -1)\n                ans[i] ^= 1;\n        }\n    }\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n >> m;\n    a.resize(m);\n    b.resize(m);\n    ans.resize(m);\n    e.resize(n);\n    dfn.assign(n, -1);\n    low.resize(n);\n    belong.assign(n, -1);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> a[i] >> b[i];\n        --a[i];\n        --b[i];\n        e[a[i]].emplace_back(b[i], i);\n    }\n    for (int i = 0; i < n; ++i)\n        if (dfn[i] == -1)\n            dfs(i);\n    for (int i = 0; i < m; ++i)\n        if (belong[a[i]] == belong[b[i]])\n            ans[i] = 1;\n    solve();\n    for (int i = 0; i < m; ++i)\n        std::cout << (ans[i] == 1 ? \"diff\" : \"same\") << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=1005,MAXM=200005;\n\nint N,M;\nvector<int> adj[MAXN];\nint E[MAXM][2];\n\nint p[MAXN][MAXN],q[MAXN][MAXN];\nbool vis[MAXN];\n\nvoid mark(int s,int u,int id,int mk[])\n{\n\tif(u==s||vis[u])return;\n\tvis[u]=true;\n\tmk[u]=id;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t\tmark(s,adj[u][i],id,mk);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1,a,b;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tE[i][0]=a;E[i][1]=b;\n\t\tadj[a].push_back(b);\n\t}\n\t\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tint id=0;\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],++id,p[i]);\n\t\tmemset(vis,0,sizeof vis);\n\t\treverse(adj[i].begin(),adj[i].end());\n\t\tid=adj[i].size();\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],id--,q[i]);\n\t}\n\t\n\tfor(int i=1;i<=M;i++)\n\t\tif((p[E[i][1]][E[i][0]]>0)==(p[E[i][0]][E[i][1]]!=q[E[i][0]][E[i][1]]))\n\t\t\tputs(\"same\");\n\t\telse\n\t\t\tputs(\"diff\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <vector>\ntypedef long long lint;\nconst int N=1005;\nint n,val[N];\nstd::bitset <N> use;\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nint main(){\n\tstd::vector <int> step;\n\tn=nxi();\n\t{\n\t\tlint v[2]={0};\n\t\tbool all_neg=1;\n\t\tint xpos=1;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tval[i]=nxi();\n\t\t\tif(val[i]>0) v[i&1]+=val[i];\n\t\t\tall_neg&=val[i]<0;\n\t\t\tif(val[xpos]<val[i]) xpos=i;\n\t\t}\n\t\tbool p=v[1]>v[0];\n\t\tprintf(\"%lld\\n\",all_neg?(lint)val[xpos]:v[p]);\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tuse[i]=(i&1)==p&&val[i]>=0;\n\t\t}\n\t\tif(all_neg) use[xpos]=1;\n\t}\n\tfor(int x=n; n>1; apn(x,n)){\n\t\tfor(; x&&(use[x]||(x!=1&&x!=n&&use[x-1]!=use[x+1])); --x);\n\t\tassert(x);\n\t\tstep.push_back(x);\n\t\tconst int p=2-(x==1||x==n);\n\t\tn-=p;\n\t\tuse=(use>>(x+p)<<x)|(use^(use>>x<<x));\n\t}\n\tprintf(\"%d\\n\",(int)step.size());\n\tfor(std::vector <int> ::iterator it=step.begin(); it!=step.end(); ++it){\n\t\tprintf(\"%d\\n\",*it);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n// for testing\n\n//*\n\nvoid kosaraju(int);\nvoid kosaraju2(int, int);\n\nint mat[1010][1010];\n\nvoid kosaraju_mat(int f) {\n    for (int u=1; u<=n; ++u) {\n        if (mat[f][u] && !starred[u]) {\n            starred[u] = true;\n            kosaraju_mat(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2_mat(int f, int f2) {\n    unf[f] = f2;\n    for (int u=1; u<=n; ++u) {\n        if (mat[f][u] && !unf[u]) {\n            kosaraju2_mat(u, f2);\n        }\n    }\n}\n\nvoid slow_print() {\n    memset(starred, 0, 1010 * sizeof(bool));\n    memset(unf, 0, 1010 * sizeof(int));\n    kos.clear();\n    for (auto u : piv) {\n        mat[u.first][u.second] = 1;\n    }\n    int c = 0, i;\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            ++c;\n            kosaraju2(u, u);\n        }\n    }\n    for (auto u : piv) {\n        int tc = 0;\n        --mat[u.first][u.second];\n        ++mat[u.second][u.first];\n        kos.clear();\n        memset(starred, 0, 1010 * sizeof(bool));\n        memset(unf, 0, 1010 * sizeof(int));\n        for (i=1; i<=n; ++i) {\n            if (!starred[i]) {\n                starred[i] = true;\n                kosaraju_mat(i);\n            }\n        }\n        for (int u : kos) {\n            if (!unf[u]) {\n                ++tc;\n                kosaraju2_mat(u, u);\n            }\n        }\n        puts(c == tc ? \"same\" : \"diff\");\n        ++mat[u.first][u.second];\n        --mat[u.second][u.first];\n    }\n}\n\n//*/\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    if (n * n * m <= 2e8) {\n        slow_print();\n        return 0;\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            topo_sort[topo_cnt++] = u;\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    reverse(topo_sort, topo_sort + topo_cnt);\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=0; i<topo_cnt; ++i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    /*\n    for (i=1; i<=n; ++i) {\n        for (int j=1; j<=n; ++j) {\n            printf(\"%s\", dag_visit[i].test(j) ? \"1\" : \"0\");\n        }\n        puts(\"\");\n    }\n    //*/\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            int n1 = unf[u.first], n2 = unf[u.second];\n            puts(dag_edge[n1][n2] >= 2 || dag_second_visit[n1].test(n2) ? \"diff\" : \"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//save code\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\nstruct graph_t\n{\n\tint front,nex;\n}graph[201001],graph2[201001];\nint tail=1000,tail2=1000;\n\nvoid addedge(int u,int v)\n{\n\tint tmp=graph[u].nex;\n\tgraph[u].nex=++tail;\n\tgraph[tail].front=v;\n\tgraph[tail].nex=tmp;\n}\n\nvoid addedge2(int u,int v)\n{\n\tint tmp=graph2[u].nex;\n\tgraph2[u].nex=++tail2;\n\tgraph2[tail].front=v;\n\tgraph2[tail].nex=tmp;\n}\n\nint vis[1001];\npair<int,int> edge[200001];\nint nfinish=0;\nint finish[1001];\nint nconnect=0;\nint connect[1001];\nint indegree[1001],outdegree[1001];\n\nvoid dfs1(int now)\n{\n\tvis[now]=1;\n\tfor(int i=graph[now].nex;i;i=graph[i].nex)\n\t{\n\t\tif(vis[graph[i].front]!=1)\n\t\t{\n\t\t\tdfs1(graph[i].front);\n\t\t}\n\t}\n\tfinish[nfinish++]=now;\n}\n\nvoid dfs2(int now)\n{\n\tvis[now]=2;\n\tconnect[now]=nconnect;\n\tfor(int i=graph2[now].nex;i;i=graph2[i].nex)\n\t{\n\t\tif(vis[graph2[i].front]!=2)\n\t\t{\n\t\t\tdfs2(graph2[i].front);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\taddedge(to,from);\n\t\tedge[i]=make_pair(from,to);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i]!=1)dfs1(i);\n\t}\n\tfor(int i=nfinish-1;i>=0;i--)\n\t{\n\t\tif(vis[i]!=2)\n\t\t{\n\t\t\tnconnect++;\n\t\t\tdfs2(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=graph[i].nex;j;j=graph[j].nex)\n\t\t{\n\t\t\tif(connect[j]==connect[graph[j].front])\n\t\t\t{\n\t\t\t\toutdegree[i]++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=graph2[i].nex;j;j=graph2[j].nex)\n\t\t{\n\t\t\tif(connect[j]==connect[graph2[j].front])\n\t\t\t{\n\t\t\t\tindegree[i]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<vis[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\t\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nconst int MV = 1003;\nconst int ME = 200005;\n\nint n, m;\nint fst[MV], nxt[ME], u[ME], v[ME], lnum;\nint way[MV][MV], dir[MV][MV];\n\nvoid addeg(int nu, int nv)\n{\n\tnxt[++lnum] = fst[nu];\n\tfst[nu] = lnum;\n\tu[lnum] = nu;\n\tv[lnum] = nv;\n}\n\nvoid input()\n{\n\tread(n), read(m);\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tread(a), read(b);\n\t\tdir[a][b]++;\n\t\taddeg(a, b);\n\t}\n}\n\nbool vis[MV];\n\nvoid dfs(int x, int *s, int src, int len)\n{\n\tvis[x] = 1;\n\tif(len >= 2) s[x]++;\n\tfor(int i=fst[x]; i; i=nxt[i])\n\t\tif(!vis[v[i]])\n\t\t\tif(!len || (len&&!s[v[i]]))\n\t\t\t\tdfs(v[i], s, src, len+1);\n\tvis[x] = 0;\n}\n\nvoid work()\n{\n\tfor(int i=1; i<=n; i++) dfs(i, way[i], i, 0);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tway[i][j] += dir[i][j];\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a = u[i], b = v[i];\n\t\tif(way[a][b]==1 && !way[b][a]) puts(\"same\");\n\t\telse if(way[a][b]>=2 && !way[b][a]) puts(\"diff\");\n\t\telse if(way[a][b]==1 && way[b][a]) puts(\"diff\");\n\t\telse if(way[a][b]>=2 && way[b][a]) puts(\"same\");\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// kAAzuki Hoshino\n/*\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long long ll;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n//#define inf 1000000000\n#define mod 1000000007\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n    return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n    o<<\"{\";\n    for(const T& v:vc) o<<v<<\",\";\n    o<<\"}\";\n    return o;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MAXM = 200005;\nconst int MAXN = 1005;\nint used[MAXN], condition[MAXM], vis[MAXN][MAXN], a[MAXM], b[MAXM] ;\nvi adj[MAXN];\nint N,M;\nint r[MAXN],cond[MAXM];\n\nvoid dfs(int s, int base){\n\tif(vis[base][s])return;\n\tvis[base][s]=1;\n\tfor(auto t:adj[s]){\n\t\tdfs(t, base);\n\t}\n}\n\nvoid bfs(int s){\n\tmemset(used,0,sizeof(used));\n\tmemset(r,-1,sizeof(r));\n\tfor(auto t:adj[s]){\n\t\tif(r[t]!=-1){\n\t\t\tused[t]=1;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push(t);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tr[v] = t;\n\t\t\tfor(auto u:adj[v]){\n\t\t\t\tif(u==s)continue;\n\t\t\t\tif(r[u]!=-1){\n\t\t\t\t\tif(r[u]!=t)used[u]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor(int i=1;i<=N;i++)if(used[i])q.push(i);\n\twhile(!q.empty()){\n\t\tint v = q.front();q.pop();\n\t\tused[v]=1;\n\t\tfor(auto t:adj[v]){\n\t\t\tif(t==s)continue;\n\t\t\tif(used[t])continue;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\tfor(int i=1;i<=M;i++){\n\t\tif(a[i]==s){\n\t\t\tcondition[i] = used[b[i]];\n\t\t}\n\t\tif(b[i]==s){\n\t\t\tcond[i] = (r[a[i]]!=-1);\n\t\t}\n\t}\n\n}\n\nsigned main(){\nIOS;\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n\t\n\tcin >> N >> M;\n  for(int i=1;i<=M;i++){\n  \tcin >> a[i] >> b[i];\n  \tadj[a[i]].pb(b[i]);\n  }  \n  // for(int i=1;i<=N;i++){\n  // \tdfs(i, i);\n  // }\n  for(int i=1;i<=N;i++){\n  \tbfs(i);\n  }\n  for(int i=1;i<=M;i++){\n  \tif(condition[i]==cond[i]){\n  \t\tcout << \"same\" << endl;\n  \t}\n  \telse cout << \"diff\" << endl;\n  }\n\nreturn 0;\n}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  UnWeightedGraph gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n    for (int i = 0; i < g.size(); i++)\n    {\n        sort(gg[i].begin(),gg[i].end());\n        sort(rg[i].begin(),rg[i].end());\n    }\n  }\n\n  void revEdge(int a, int b){\n      auto itrgg_erase = lower_bound(gg[a].begin(),gg[a].end(),b);\n      gg[a].erase(itrgg_erase);\n      auto itrrg_erase = lower_bound(rg[b].begin(),rg[b].end(),a);\n      rg[b].erase(itrrg_erase);\n      auto itrgg_insert = lower_bound(gg[b].begin(),gg[b].end(),a);\n      gg[b].insert(itrgg_insert,a);\n      auto itrrg_insert = lower_bound(rg[a].begin(),rg[a].end(),b);\n      rg[a].insert(itrrg_insert,b);\n  }\n\n  int operator[](int k) {\n    return comp[k];\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(UnWeightedGraph &t) {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      for(auto &to : g[i]) {\n        int x = comp[i], y = comp[to];\n        if(x == y) continue;\n        t[x].push_back(y);\n      }\n    }\n  }\n};\n\n\nint N;\nll M;\nvector<ll> A,B;\nUnWeightedGraph g, revG;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N >> M;\n    g.resize(N);\n    revG.resize(N);\n    for (int i = 0; i < M; i++)\n    {\n        int a,b;\n        cin >> a >> b;\n        a--;\n        b--;\n        A.push_back(a);\n        B.push_back(b);\n        g[a].emplace_back(b);\n    }\n    \n}\n\nint solve(){\n    StronglyConnectedComponents< UnWeightedGraph > scc(g);\n    UnWeightedGraph buff;\n    scc.build(buff);\n    int cntG=0;\n    vector<bool> seen(N);\n    for (int i = 0; i < N; i++)\n    {\n        if(!seen[scc[i]]) cntG++;\n        seen[scc[i]] = true;\n    }\n    DBG(cntG)\n    for (int i = 0; i < M; i++)\n    {\n        StronglyConnectedComponents< UnWeightedGraph > sccrev(g);\n        // strcpy(sccrev,scc);\n        sccrev.revEdge(A[i],B[i]);\n        sccrev.build(buff);\n        int cntrevG=0;\n        vector<bool> seen_revG(N);\n        for (int i = 0; i < N; i++)\n        {\n            if(!seen_revG[sccrev[i]]) cntrevG++;\n            seen_revG[sccrev[i]] = true;\n        }\n        if(cntG==cntrevG) cout << \"same\" << \"\\n\";\n        else cout << \"diff\" << \"\\n\";\n    }\n    \n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+10;\nconst int M=2e5+10;\n#define pb push_back\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,fr[M],to[M],nxt[M],tt,s,t,id[N],h[N];\nbool vis[N][N],can[M];\n\nvoid adde(int u,int v) {\n\tfr[++tt]=u,to[tt]=v,nxt[tt]=h[u],h[u]=tt;\n}\n\nvoid dfs(int u) {\n\tvis[s][u]=1;\n\tif(id[u]) return;\n\tid[u]=t;\n\tfor(int i=h[u],v;v=to[i],i;i=nxt[i]) if(!id[v]&&v!=s) dfs(v);\n}\n\nint main() {\n\tcin>>n>>m;\n\tfor(int i=1,u,v;i<=m;i++) u=gi(),v=gi(),adde(u,v);\n\tfor(s=1;s<=n;s++) {\n\t\tmemset(id,0,sizeof(id));\n\t\tvector<int> son;\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tson.push_back(v),dfs(t=v);\n\t\treverse(son.begin(),son.end());\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tif(id[v]!=v) can[i]=1;\n\t\tmemset(id,0,sizeof(id));\n\t\tfor(auto v:son) dfs(t=v);\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tif(id[v]!=v) can[i]=1;\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tint u=fr[i],v=to[i];\n\t\tif((can[i])==(vis[v][u])) cout<<\"same\\n\";\n\t\telse cout<<\"diff\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <vector>\n#define PB push_back\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1010,M=1003;\nbitset<M> G[N],A[N],B;\nint n,m;\nint vis[N][2];\nint inq[N];\nqueue<int> que;\nvoid push(int u,int t) {\n\tif(!vis[u][0]) vis[u][0]=t;\n\telse if(!vis[u][1]&&vis[u][0]!=t) vis[u][1]=t,B[u]=0;\n\telse return;\n\tA[t][u]=0;\n\tif(!inq[u]) que.push(u),inq[u]=1;\n}\nvoid dfs(int u) {\n//\tcout<<u<<' ';\n\twhile(1) {\n\t\tint v=((A[vis[u][0]]|A[vis[u][1]])&G[u]&B)._Find_first();\n\t\tif(v==M) break;\n\t\tpush(v,vis[u][0]),push(v,vis[u][1]),dfs(v);\n\t}\n}\nint mp[N][N],p1[N][N],p2[N][N];\nvoid sol(int s) {\n//\tcout<<\"Solve\"<<s<<':';\n\tB[s]=0;\n\tfor(int i=1;i<=n;++i) if(mp[s][i]) push(i,i);\n\twhile(!que.empty()) {\n\t\tint u=que.front(); que.pop(),inq[u]=0;\n\t\twhile(1) {\n\t\t\tint v=((A[vis[u][0]]|A[vis[u][1]])&G[u]&B)._Find_first();\n\t\t\tif(v==M) break;\n\t\t\tpush(v,vis[u][0]),push(v,vis[u][1]);\n\t\t}\n\t}\n//\tcout<<endl;\n\tfor(int i=1;i<=n;++i) if(s!=i) {\n\t\tp1[s][i]=vis[i][0]||vis[i][1]||mp[s][i];\n\t\tp2[s][i]=(vis[i][0]&&vis[i][0]!=i)||(vis[i][1]&&vis[i][1]!=i);\n\t}\n//\tfor(int i=1;i<=n;++i) printf(\"(%d,%d) \",vis[i][0],vis[i][1]); puts(\"\");\n\tfor(int i=1;i<=n;++i) A[vis[i][0]][i]=A[vis[i][1]][i]=1,vis[i][0]=vis[i][1]=0,B[i]=1;\n}\nvector<PII> E;\nint main() {\n\trd(n),rd(m);\n\tfor(int i=1,x,y;i<=m;++i) rd(x),rd(y),G[x][y]=mp[x][y]=1,E.PB(MP(x,y));\n\tfor(int i=0;i<=n;++i) for(int j=1;j<=n;++j) A[i][j]=1;\n\tfor(int i=1;i<=n;++i) B[i]=1;\n\tfor(int i=1;i<=n;++i) sol(i);\n//\tcout<<\"Check:\"<<p1[1][4]<<' '<<p2[4][1]<<endl;\n\tfor(int i=0;i<E.size();++i) { \n\t\tint x=E[i].fir,y=E[i].sec,flg;\n\t\tif(p1[y][x]) flg=(p2[x][y]==1);\n\t\telse flg=(p2[x][y]==0);\n\t\tif(flg) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#define maxn 1005\n#define _ 0\nusing namespace std;\nstruct nod\n{\n\tint nex,id;\n\tnod(int a,int b)\n\t{\n\t\tnex=a;\n\t\tid=b;\n\t}\n\tnod(){}\n};\nint n,m,tim;\nint vis[maxn];\nint bel[maxn][maxn][2];\nint u[maxn*maxn],v[maxn*maxn];\nvector<nod> edge[maxn];\nvoid dfs(int now,int fa,int b,int f)\n{\n//\tcerr<<now<<\" \"<<fa<<\" \"<<b<<\" \"<<f<<endl;\n\tvis[now]=tim; bel[fa][now][f]=b;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,fa,b,f);\n}\nvoid solve(int now)\n{\n\ttim++; vis[now]=tim;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,0);\n \n\treverse(edge[now].begin(),edge[now].end());\n \n\ttim++; vis[now]=tim;\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsolve(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif( (bel[v[i]][u[i]][0]!=0) ^ _ ^ (bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i) )\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nstruct Edge\n{\n\tint from;\n\tint to;\n\tint nxt;\n}e[200005];\nint n,m,edgenum,head[1005],minn[1005],maxx[1005],tmp[1005],top;\nbool f1[1005][1005],f2[1005][1005];\nbool flag[1005];\nqueue<int>q;\nvoid add(int u,int v)\n{\n\te[++edgenum].to=v;\n\te[edgenum].from=u;\n\te[edgenum].nxt=head[u];\n\thead[u]=edgenum;\n}\nvoid bfs(int s,bool*flag,int*a)\n{\n\t\t\tflag[s]=1;\n\t\t\ta[s]=s;\n\t\t\tq.push(s);\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tint node=q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor(int hd=head[node];hd;hd=e[hd].nxt)\n\t\t\t\t{\n\t\t\t\t\tint to=e[hd].to;\n\t\t\t\t\tif(!flag[to])\n\t\t\t\t\t{\n\t\t\t\t\t\tflag[to]=1;\n\t\t\t\t\t\ta[to]=s;\n\t\t\t\t\t\tq.push(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t}\n\tfor(int i=1;i<=n;i++)bfs(i,f1[i],tmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttop=0;\n\t\tfor(int hd=head[i];hd;hd=e[hd].nxt)tmp[++top]=e[hd].to;\n\t\tsort(tmp+1,tmp+top+1);\n\t\tmemset(flag,0,sizeof(flag));\n\t\tflag[i]=1;\n\t\tfor(int j=1;j<=top;j++)\n\t\t{\n\t\t\tif(flag[tmp[j]])continue;\n\t\t\tbfs(tmp[j],flag,minn);\n\t\t}\n\t\tmemset(flag,0,sizeof(flag));\n\t\tflag[i]=1;\n\t\tfor(int j=top;j>=1;j--)\n\t\t{\n\t\t\tif(flag[tmp[j]])continue;\n\t\t\tbfs(tmp[j],flag,maxx);\n\t\t}\n\t\tfor(int j=1;j<=top;j++)f2[i][tmp[j]]=minn[tmp[j]]<maxx[tmp[j]];\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u=e[i].from,v=e[i].to;\n\t\tif(f1[v][u]^f2[u][v])puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 1010;\nconst int MAXM = 200010;\n\nstruct Edge {\n\tint u, v;\n\n\tEdge() {}\n\tEdge(int u, int v):u(u), v(v) {}\n}E[MAXM];\n\nvector<int>to[MAXN];\n\nint Mark[MAXN];\nbitset<MAXN>vis;\nbool G1[MAXN][MAXN];\nbool G2[MAXN][MAXN];\n\ninline void dfs1(int x, int st) {\n\tG1[st][x] = 1, vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs1(u, st);\n}\n\ninline void dfs2(int x, int col, int k, int st) {\n\tif(k) G2[st][x] = Mark[x] != col;\n\telse Mark[x] = col; vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs2(u, col, k, st);\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tint n = ri, m = ri;\n\tfor(int i = 1; i <= m; i++) {\n\t\tint u = ri, v = ri;\n\t\tto[u].push_back(v);\n\t\tE[i] = Edge(u, v);\n\t}\n\tfor(int i = 1; i <= n; i++) vis.reset(), dfs1(i, i);\n\tfor(int i = 1; i <= n; i++) {\n\t\tvis.reset(), vis.set(i);\n\t\tmemset(Mark, 0, sizeof(Mark));\n\t\tint d = to[i].size();\n\t\tfor(int j = 0; j < d; j++) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 0, i);\n\t\tvis.reset(), vis.set(i);\n\t\tfor(int j = d - 1; ~j; --j) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 1, i);\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tputs(G1[E[i].v][E[i].u] ^ G2[E[i].u][E[i].v] ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nstruct edge {int dest, home; };\nint n, m;\nint pre[MAXN], suf[MAXN];\nbool vis[MAXN][MAXN], ans[MAXN];\nvector <edge> a[MAXN];\nvoid dfs(int from, int pos) {\n\tvis[from][pos] = true;\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (!vis[from][a[pos][i].dest]) dfs(from, a[pos][i].dest);\n}\nvoid dfspre(int pos, int val) {\n\tpre[pos] = val;\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (pre[a[pos][i].dest] == -1) dfspre(a[pos][i].dest, val);\n}\nvoid dfssuf(int pos, int val) {\n\tsuf[pos] = val;\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (suf[a[pos][i].dest] == -1) dfssuf(a[pos][i].dest, val);\n}\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\ta[x].push_back((edge) {y, i});\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tdfs(i, i);\n\tfor (int i = 1; i <= n; i++)\n\tfor (unsigned j = 0; j < a[i].size(); j++)\n\t\tif (vis[a[i][j].dest][i]) ans[a[i][j].home] ^= true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(pre, -1, sizeof(pre));\n\t\tmemset(suf, -1, sizeof(suf));\n\t\tpre[i] = suf[i] = 0;\n\t\tfor (unsigned j = 0; j < a[i].size(); j++)\n\t\t\tif (pre[a[i][j].dest] == -1) dfspre(a[i][j].dest, j);\n\t\tfor (unsigned j = a[i].size(); j > 0; j--)\n\t\t\tif (suf[a[i][j - 1].dest] == -1) dfssuf(a[i][j - 1].dest, j - 1);\n\t\tfor (unsigned j = 0; j < a[i].size(); j++)\n\t\t\tif (pre[a[i][j].dest] != suf[a[i][j].dest]) ans[a[i][j].home] ^= true;\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ans[i]) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{edge*nx;int t;}e[MM*3+5],*h[MN+5],*r[MN+5],*c[MN+5];\nint en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(edge**h,int x,int y){e[++en]=(edge){h[x],y};h[x]=e+en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)\n\t\tif(!d[i->t])dfs(i->t),l[x]=min(l[x],l[i->t]);\n\t\telse if(inz[i->t])l[x]=min(l[x],d[i->t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(edge**h,int x,int z)\n{\n\tu[x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)if(!u[i->t])d1(h,i->t,z),uu[i-e>>1]|=z;\n}\nvoid d2(edge**h,int x,int d,int xs,int ys)\n{\n\tint i;\n\tfor(u[q[i=qn=0]=x]=1;i<=qn;++i)for(edge*j=h[q[i]];j;j=j->nx)\n\t\tif((j-e>>1)!=d&&!u[j->t])u[q[++qn]=j->t]=1;\n\tif(u[xs]&&!u[ys])u[q[++qn]=ys]=1;\n\tfor(;i<=qn;++i)for(edge*j=h[q[i]];j;j=j->nx)\n\t\tif((j-e>>1)!=d&&!u[j->t])u[q[++qn]=j->t]=1;\n}\nint main()\n{\n\tint n=read(),m=read(),i,j;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tmemset(h,0,sizeof(h));memset(r,0,sizeof(r));en=1;\n\tfor(i=1;i<=m;++i)if(p[x[i]]==p[y[i]])ins(h,x[i],y[i]),ins(r,y[i],x[i]);else en+=2;\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(edge*k=c[q[j]];k;k=k->nx)if(!g[i][k->t]++)q[++qn]=k->t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i]&1)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,ph[p[x[i]]],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i]&2)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,ph[p[x[i]]],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<bitset>\nusing namespace std;\nconst int MAXN=1005,MAXM=200005;\nint n,m;\nint ex[MAXM],ey[MAXM];\nvector<int> ver[MAXN];\nbool ok[MAXN][MAXN];\nvoid dfs(int u,bool tag[]) {\n\ttag[u]=1;\n\tfor(int v:ver[u])\n\t\tif(!tag[v]) dfs(v,tag);\n}\nint a[MAXN][MAXN],b[MAXN][MAXN];\nvoid mak_tag(int u,int tag[],int id) {\n\ttag[u]=id;\n\tfor(int v:ver[u]) if(!tag[v])\n\t\tmak_tag(v,tag,id);\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tver[x].push_back(y);\n\t\tex[i]=x,ey[i]=y;\n\t}\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tdfs(i,ok[i]);\n\tfor(int i=1;i<=n;i++) {\n\t\ta[i][i]=-1;\n\t\tfor(int j=0;j<(int)ver[i].size();j++)\n\t\t\tif(!a[i][ver[i][j]]) mak_tag(ver[i][j],a[i],j+1);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tb[i][i]=-1;\n\t\tfor(int j=ver[i].size()-1;~j;j--)\n\t\t\tif(!b[i][ver[i][j]]) mak_tag(ver[i][j],b[i],j+1);\n\t}\n\n\tfor(int i=1;i<=m;i++) {\n\t\tint x=ex[i],y=ey[i];\n\t\tputs((ok[y][x])^(a[x][y]!=b[x][y])?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nbool bz[N],bz1[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1]))continue;\n            if (!F[y][0]){\n                F[y][0]=v;\n                dfs(y,s,v);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y])dfs(y,s,v);\n            }\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) cerr << #A << \" = \"; for (int i=1; i<=n; ++i) cerr << A[i] << ' '; cerr << '\\n';\n#define PR0(A, n) cerr << #A << \" = \"; for (int i=0; i<n; ++i) cerr << A[i] << ' '; cerr << '\\n';\n\nconst int maxn = 1002;\nconst int maxm = 200002;\nconst int inf = 1e9;\n\nint n, m, cnt[maxn], num[maxn], low[maxn], nTime;\nint scc[maxn], nSCC, curBranch[maxn];\nstack<int> st;\nbool ok[maxn][maxn];\nvector<int> g[maxn];\npair<int, int> e[maxm];\n\nint readInt() {\n\tchar c;\n\tfor (c=getchar(); c<'0' || c>'9'; c=getchar());\n\tint res = c - '0';\n\tfor (c=getchar(); '0'<=c && c<='9'; c=getchar())\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nvoid tarjan(int u) {\n\tst.push(u);\n\tnum[u] = ++nTime;\n\tlow[u] = inf;\n\tfor (int i=0; i<g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (scc[v]!=0)\n\t\t\tcontinue;\n\t\tif (num[v])\n\t\t\tlow[u] = min(low[u], num[v]);\n\t\telse {\n\t\t\ttarjan(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t}\n\t}\n\tif (low[u]<num[u])\n\t\treturn;\n\t++nSCC;\n\twhile (true) {\n\t\tint x = st.top(); st.pop();\n\t\tscc[x] = nSCC;\n\t\tif (x==u)\n\t\t\tbreak;\n\t}\n}\n\nvoid visit(int u, int branch, int root) {\n\tif (u!=branch)\n\t\tok[root][u] = true;\n\t++cnt[u];\n\tfor (int i=0; i<g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v!=root && cnt[v]<2 && curBranch[v]!=branch) {\n\t\t\tcurBranch[v] = branch;\n\t\t\tvisit(v, branch, root);\n\t\t}\n\t}\n}\n\nvoid init(int x) {\n\tmemset(cnt, 0, sizeof(cnt));\n\tmemset(curBranch, 0, sizeof(curBranch));\n\tfor (int i=0; i<g[x].size(); ++i) {\n\t\tint u = g[x][i];\n\t\tcurBranch[u] = u;\n\t\t//debug(u);\n\t\t//debug(ok[3][4]);\n\t\tvisit(u, u, x);\n\t}\n}\n\nint main() {\n\t//freopen(\"data.inp\", \"r\", stdin);\n\t//freopen(\"data.out\", \"w\", stdout);\n\tn = readInt(); m = readInt();\n\tfor (int i=1; i<=m; ++i) {\n\t\te[i].first = readInt();\n\t\te[i].second = readInt();\n\t\tg[e[i].first].push_back(e[i].second);\n\t}\n\tfor (int i=1; i<=n; ++i) {\n\t\tif (scc[i]==0) {\n\t\t\ttarjan(i);\n\t\t}\n\t}\n\tinit(3);\n\t//debug(ok[3][4]);\n\tfor (int i=1; i<=n; ++i) {\n\t\tinit(i);\n\t}\n\t//debug(ok[3][4]);\n\tfor (int i=1; i<=m; ++i) {\n\t\tint u = e[i].first, v = e[i].second;\n\t\tif (scc[u]==scc[v]) {\n\t\t\tif (ok[u][v])\n\t\t\t\tputs(\"same\");\n\t\t\telse \n\t\t\t\tputs(\"diff\");\n\t\t}\n\t\telse {\n\t\t\tif (ok[u][v])\n\t\t\t\tputs(\"diff\");\n\t\t\telse \n\t\t\t\tputs(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb          emplace_back\n#define ll          long long\n#define fi          first\n#define se          second\n#define mp          make_pair\n#define sz(x)       int(x.size())\n//#define int         int64_t\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e3 + 1;\nconst int M = 2e5 + 1;\nconst ll inf = (ll)1e18;\n\nbitset<N> can[N];\nint Max[N][N], Min[N][N], lab[N][N];\nint n, m, u, v;\nvector<int> adj[N];\npii e[M];\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    #define Task        \"test\"\n    if(fopen(Task\".inp\", \"r\")) {\n        freopen(Task\".inp\", \"r\", stdin);\n        freopen(Task\".out\", \"w\", stdout);\n    }\n    cin >> n >> m;\n    for(int i = 1; i <= m; ++i) {\n        cin >> u >> v, adj[u].pb(v);\n        e[i] = mp(u, v);\n    }\n    for(int i = 1; i <= n; ++i) {\n        can[i].set(i);\n        function<void(int)> dfs = [&](int u) {\n            for(int v: adj[u]) if(!can[i][v]) {\n                can[i].set(v);\n                dfs(v);\n            }\n        };\n        dfs(i);\n    }\n    for(int i = 1; i <= n; ++i) {\n        fill(Min[i], Min[i] + n + 1, n + n);\n        fill(Max[i], Max[i] + n + 1, -1);\n        Min[i][i] = -1, Max[i][i] = n + n;\n        for(int j = 0; j < sz(adj[i]); ++j) {\n            function<void(int)> dfs = [&](int u) {\n                if(Min[i][u] != n + n) return;\n                Min[i][u] = min(Min[i][u], j);\n                for(int v: adj[u])\n                    if(Min[i][v] == n + n) dfs(v);\n            };\n            dfs(adj[i][j]); lab[i][adj[i][j]] = j;\n        }\n        for(int j = sz(adj[i]) - 1; j >= 0; --j) {\n            function<void(int)> dfs = [&](int u) {\n                if(Max[i][u] != -1) return;\n                Max[i][u] = max(Max[i][u], j);\n                for(int v: adj[u])\n                    if(Max[i][v] == -1) dfs(v);\n            };\n            dfs(adj[i][j]);\n        }\n    }\n    bool ans, res;\n    for(int i = 1; i <= m; ++i) {\n        tie(u, v) = e[i];\n        ans = can[v][u];\n        res = (Min[u][v] != lab[u][v]) | (Max[u][v] != lab[u][v]);\n        if(ans == res) cout << \"same\\n\";\n        else cout << \"diff\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1005;\nint n,m,i,x,y,ans[200005],dfn[N],low[N],xb,st[N],w,bel[N],scnt,f[N];\nvector<pair<int,int>>e[N],tmp,tmp2;\nbool b[N];\nvoid dfs(int x){\n\tdfn[x]=low[x]=++xb;st[++w]=x;\n\tfor(auto u:e[x])if(!dfn[u.first]){\n\t\tdfs(u.first);low[x]=min(low[x],low[u.first]);\n\t}else if(!bel[u.first])low[x]=min(low[x],low[u.first]);\n\tif(dfn[x]==low[x])for(++scnt;;){\n\t\tbel[st[w]]=scnt;\n\t\tfor(auto u:e[st[w]])if(bel[u.first] && bel[u.first]!=scnt)\n\t\t\tf[scnt]=max(f[scnt],f[bel[u.first]]+1);\n\t\tif(st[w--]==x)break;\n\t}\n}\nvoid dfs2(int x){b[x]=1;for(auto u:e[x])if(!b[u.first])dfs2(u.first);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=m;++i)cin>>x>>y,e[x].push_back(make_pair(y,i));\n\tfor(i=1;i<=n;++i)if(!dfn[i])dfs(i);\n\tfor(i=1;i<=n;++i){\n\t\ttmp.clear();\n\t\tfor(auto u:e[i])if(bel[u.first]!=bel[i]){if(f[bel[i]]>f[bel[u.first]]+1)ans[u.second]=1;}\n\t\t\telse tmp.push_back(u);\n\t\te[i]=tmp;\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tmemset(b+1,0,n);b[i]=1;tmp.clear();tmp2.clear();\n\t\tfor(auto u:e[i])if(!b[u.first])tmp.push_back(u),dfs2(u.first);\n\t\t\telse tmp2.push_back(u);\n\t\tmemset(b+1,0,n);b[i]=1;reverse(tmp.begin(),tmp.end());\n\t\tfor(auto u:tmp2)dfs2(u.first);\n\t\tfor(auto u:tmp)if(!b[u.first])ans[u.second]=1,dfs2(u.first);\n\t}\n\tfor(i=1;i<=m;++i)cout<<(ans[i]?\"diff\\n\":\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nint n,m;\nint a[200010],b[200010];\nvector<P> G[1002];\n\nint ok[1002][1002];\nvoid solve(int s){\n\tqueue<P> que;\n\tint id[1002] = {};\n\tbool used[1002];\n\tfor(int i = 0 ; i < 1002 ; i ++){\n\t\tused[i] = false;\n\t}\n\tid[s] = n+1;\n\tused[s] = true;\n\tfor(int i = 0 ; i < G[s].size() ; i ++){\n\t\tint v = G[s][i].fr;\n\t\tid[v] = v;\n\t\tque.push(P(v,id[v]));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.front(); que.pop();\n\t\tif(used[p.fr])continue;\n\t\tfor(int i = 0 ; i < G[p.fr].size() ; i ++){\n\t\t\tP ed = G[p.fr][i];\n\t\t\tif(id[ed.fr] != n+1 && id[ed.fr] != p.sc){\n\t\t\t\tif(id[ed.fr] == 0){\n\t\t\t\t\tid[ed.fr] = p.sc;\n\t\t\t\t\tused[ed.fr] = false;\n\t\t\t\t\tque.push(P(ed.fr,id[ed.fr]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tid[ed.fr] = n+1;\n\t\t\t\t\tused[ed.fr] = false;\n\t\t\t\t\tque.push(P(ed.fr,id[ed.fr]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tif(id[i] == 0)ok[s][i] = 0;\n\t\telse if(id[i] <= n)ok[s][i] = 1;\n\t\telse ok[s][i] = 2;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0 ; i < m ; i ++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].push_back(P(b[i],i));\n\t}\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tsolve(i);\n\t}\n\tfor(int i = 0 ; i < m ; i ++){\n\t\tint cnt = 0;\n\t\tif(ok[a[i]][b[i]] == 2)cnt ++;\n\t\tif(ok[b[i]][a[i]] >= 1)cnt ++;\n\t\tif(cnt == 1)puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, m;\nbool can[1000][1000], can2[1000][1000];\nvector<vi> e;\n\nvoid rec1(bool *v, int c){\n\tv[c] = 1;\n\tfor(int i : e[c]) if(!v[i]) rec1(v, i);\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m; assert(n > 2);\n\te.resize(n);\n\tmap<pi, int> id;\n\trep(i, m){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\tid[pi(a, b)] = i;\n\t}\n\trep(i, n) sort(all(e[i]));\n\trep(i, n) rec1(can[i], i);\n\trep(i, n) rep(it, 2){\n\t\tbool v[1000] = {};\n\t\tv[i] = 1;\n\t\tfor(int j : e[i]){\n\t\t\tif(v[j]) can2[i][j] = 1;\n\t\t\trec1(v, j);\n\t\t}\n\t\treverse(all(e[i]));\n\t}\n\tconst char *res[] = {\"diff\", \"same\"};\n\tvi ans(m);\n\tfor(auto i : id){\n\t\tint a = i.first.first, b = i.first.second;\n\t\tans[i.second] = can2[a][b] ? can[b][a] : !can[b][a];\n\t\t\n\t}\n\trep(i, m) cout << res[ans[i]] << endl;\n\t/*\n\tdbg(\"can\");\n\trep(i, n) rep(j, n) cerr<<can[i][j]<<(j==n-1?\"\\n\":\" \");\n\tdbg(\"can2\");\n\trep(i, n) rep(j, n) cerr<<can2[i][j]<<(j==n-1?\"\\n\":\" \");\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint n,m,x[200005],y[200005];\nvector<pair<int,int> > v[1005];\nbool vis[1005],ff[1005][1005];\nint f[2005],g[2005];\nbool ans[200005];\nvoid dfs(int x)\n{\n\tvis[x]=true;\n\tfor (int i=0;i<v[x].size();++i)\n\t{\n\t\tint y=v[x][i].second;\n\t\tif (vis[y]) continue;\n\t\tdfs(y);\n\t}\n}\nvoid dfs2(int x,int id)\n{\n\tif (f[x]!=-1) return;\n\tf[x]=id;\n\tfor (int i=0;i<v[x].size();++i)\n\t{\n\t\tint y=v[x][i].second;\n\t\tif (f[y]!=-1) continue;\n\t\tdfs2(y,id);\n\t}\n}\nvoid dfs3(int x,int id)\n{\n\tif (g[x]!=-1) return;\n\tg[x]=id;\n\tfor (int i=0;i<v[x].size();++i)\n\t{\n\t\tint y=v[x][i].second;\n\t\tif (g[y]!=-1) continue;\n\t\tdfs3(y,id);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tv[x[i]].push_back(make_pair(i,y[i]));\n\t}\n\tfor (int i=1;i<=n;++i) sort(v[i].begin(),v[i].end());\n\tmemset(ff,false,sizeof(ff));\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=1;j<=n;++j) vis[j]=false;\n\t\tdfs(i);\n\t\tfor (int j=1;j<=n;++j) ff[i][j]=vis[j];\n\t}\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=1;j<=n;++j) f[j]=g[j]=-1;\n\t\tvis[i]=true;\n\t\tf[i]=g[i]=0;\n\t\tfor (int j=0;j<v[i].size();++j)\n\t\t{\n\t\t\tint x=i,y=v[i][j].second,id=v[i][j].first;\n\t\t\tdfs2(y,id);\n\t\t}\n\t\tfor (int j=(int)v[i].size()-1;j>=0;--j)\n\t\t{\n\t\t\tint x=i,y=v[i][j].second,id=v[i][j].first;\n\t\t\tdfs3(y,id);\n\t\t}\n\t\tfor (int j=0;j<v[i].size();++j)\n\t\t{\n\t\t\tint y=v[i][j].second,id=v[i][j].first;\n\t\t\tif (f[y]==id&&g[y]==id) ans[id]=false;\n\t\t\telse ans[id]=true;\n\t\t}\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tif (ans[i]==ff[y[i]][x[i]]) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\n\nint n , vis[1001][1001], m, a[200001], b[200001], source, br, q[1001][1001], p[1001][1001];\nvector<int> g[1001];\n\nvoid dfs(int u) {\n\tif (vis[source][u])return;\n\tvis[source][u] = 1;\n\tfor (int i = 0; i < g[u].size(); ++i)dfs(g[u][i]);\n}\nvoid pre(int u, int vis[]) {\n\tif (u == source)return;\n\tif (vis[u])return;\n\tvis[u] = br;\n\tfor (int i = 0; i < g[u].size(); ++i)pre(g[u][i], vis);\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tg[a[i]].pb(b[i]);\n\t}\n\tfor (source = 1; source <= n ; ++source) {\n\t\tdfs(source);\n\t\tfor (int i = 0 ; i < g[source].size(); ++i) {\n\t\t\tbr = g[source][i];\n\t\t\tpre(br, p[source]);\n\t\t}\n\t\tfor (int i = g[source].size() - 1; i >= 0 ; --i) {\n\t\t\tbr = g[source][i];\n\t\t\tpre(br, q[source]);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; ++i){\n\t\tbool yes = (vis[b[i]][a[i]] ^ (q[a[i]][b[i]]!=b[i] || p[a[i]][b[i]]!= b[i]));\n\t\tif(!yes)puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, SCC[1010], v[1010], ord[1010], cnt;\nvector<int>E[1010], F[1010], L1[1010], L2[1010];\nvoid DFS1(int a) {\n\tv[a] = 1;\n\tfor (auto &t : E[a])if (!v[t])DFS1(t);\n\tord[++cnt] = a;\n}\nvoid DFS2(int a) {\n\tSCC[a] = cnt;\n\tfor (auto &t : F[a])if (!SCC[t])DFS2(t);\n}\nstruct Edge {\n\tint a, b;\n}w[201000];\nvector<int>T;\nvoid DFS3(int a) {\n\tv[a] = 1;\n\tfor (int i = 0; i < E[a].size(); i++) {\n\t\tif (!v[E[a][i]]) {\n\t\t\tT.push_back(L1[a][i]);\n\t\t\tDFS3(E[a][i]);\n\t\t}\n\t}\n}\nvoid DFS4(int a) {\n\tv[a] = 1;\n\tfor (int i = 0; i < F[a].size(); i++) {\n\t\tif (!v[F[a][i]]) {\n\t\t\tT.push_back(L2[a][i]);\n\t\t\tDFS4(F[a][i]);\n\t\t}\n\t}\n}\nint Q[1010];\nbool BFS(int a, int chk, int cc) {\n\tint head = 0, tail = 0, i;\n\tfor (i = 1; i <= n; i++)v[i] = 0;\n\tv[a] = 1, Q[++tail] = a;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (i = 0; i < E[x].size(); i++) {\n\t\t\tif (L1[x][i] == chk)continue;\n\t\t\tint t = E[x][i];\n\t\t\tif (!v[t]) {\n\t\t\t\tQ[++tail] = t;\n\t\t\t\tv[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (tail != cc)return true;\n\tfor (i = 1; i <= n; i++)v[i] = 0;\n\thead = tail = 0;\n\tv[a] = 1, Q[++tail] = a;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (i = 0; i < F[x].size(); i++) {\n\t\t\tif (L2[x][i] == chk)continue;\n\t\t\tint t = F[x][i];\n\t\t\tif (!v[t]) {\n\t\t\t\tQ[++tail] = t;\n\t\t\t\tv[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn tail != cc;\n}\nint Res[201000];\nvoid Do(int a) {\n\tint i, cc = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tE[i].clear();\n\t\tF[i].clear();\n\t\tL1[i].clear();\n\t\tL2[i].clear();\n\t\tif (SCC[i] == a)cc++;\n\t}\n\tT.clear();\n\tint rt = 0;\n\tfor (i = 1; i <= m; i++) {\n\t\tif (SCC[w[i].a] != a || SCC[w[i].b] != a)continue;\n\t\trt = w[i].a;\n\t\tE[w[i].a].push_back(w[i].b);\n\t\tF[w[i].b].push_back(w[i].a);\n\t\tL1[w[i].a].push_back(i);\n\t\tL2[w[i].b].push_back(i);\n\t}\n\tfor (i = 1; i <= n; i++)v[i] = 0;\n\tDFS3(rt);\n\tfor (i = 1; i <= n; i++)v[i] = 0;\n\tDFS4(rt);\n\tfor (auto &t : T) {\n\t\tif (BFS(rt, t, cc)) {\n\t\t\tRes[t] = 1;\n\t\t}\n\t}\n}\nint D[1010][1010], Mod = 1000000007;\nint main() {\n\tint i, j, a, b;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tw[i] = { a,b };\n\t\tE[a].push_back(b);\n\t\tF[b].push_back(a);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif (!v[i]) {\n\t\t\tDFS1(i);\n\t\t}\n\t}\n\tcnt = 0;\n\tfor (i = n; i >= 1; i--) {\n\t\tif (!SCC[ord[i]]) {\n\t\t\tcnt++;\n\t\t\tDFS2(ord[i]);\n\t\t}\n\t}\n\tfor (i = 1; i <= cnt; i++) {\n\t\tDo(i);\n\t}\n\tfor (i = 1; i <= cnt; i++) {\n\t\tD[i][i] = 1;\n\t\tE[i].clear();\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tif (SCC[w[i].a] != SCC[w[i].b]) {\n\t\t\tE[SCC[w[i].a]].push_back(SCC[w[i].b]);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (auto &t : E[i]) {\n\t\t\tfor (j = 1; j <= i; j++) {\n\t\t\t\tD[t][j] = (D[t][j] + D[i][j]) % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tif (SCC[w[i].a] != SCC[w[i].b]) {\n\t\t\tif (D[SCC[w[i].b]][SCC[w[i].a]] != D[SCC[w[i].a]][SCC[w[i].a]])Res[i] = 1;\n\t\t}\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tif (Res[i])puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[2][N],vi[N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(vi[v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tmemset(vi,0,sizeof(vi));\n\t\tdfs_vis(i,i);\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid,LL rt){\n\tp[pid][u] = col;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(vi[v]) continue;\n\t\tdfs_sol(v,col,pid,rt);\n\t}\n}\n\nvoid solve(LL u){\n\tmemset(p,0,sizeof(p));\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!vi[G[u][i]]) dfs_sol(G[u][i],i + 1,0,u);\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!vi[G[u][i]]) dfs_sol(G[u][i],i + 1,1,u);\n\tfor(LL i = 1;i <= n;i ++) if(vi[i] && p[0][i] != p[1][i]) vis[1][u][i] = 1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(ev[i]);\n\t}\n\tget_vis();\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tif(vis[i][e[p].k]) continue;\n\t\t\ts[++top]=e[p].k;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>1;p--){\n\t\t\tif(vis[i][s[p]]) continue;\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nint a[maxm], b[maxm];\nint head[maxn], nxt[maxm], to[maxm], tot;\nint x[maxm], v[maxn][maxn], y[maxm], vis[maxn], vis2[maxn];\nint s[maxm], S;\nint rt;\n\nvoid add(int x, int y) {\n\t++tot;\n\tnxt[tot] = head[x];\n\tto[tot] = y;\n\thead[x] = tot;\n}\n\nvoid dfs2(int u, int *vis) {\n\tv[rt][u] = 1;\n\tfor (int e = head[u]; e; e = nxt[e]) {\n\t\tint v = to[e];\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = vis[u];\n\t\t\tdfs2(v, vis);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", a+i, b+i);\n\t\tadd(a[i], b[i]);\n\t}\n\tfor (rt = 1; rt <= n; ++rt) {\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis[rt] = vis2[rt] = rt;\n\t\tS = 0;\n\t\tfor (int e = head[rt]; e; e = nxt[e]) {\n\t\t\ts[S++] = e;\n\t\t\tint j = to[e];\n\t\t\tif (!vis[j]) vis[j] = e, dfs2(j, vis);\n\t\t}\n\t\twhile (S) {\n\t\t\tint e = s[--S];\n\t\t\tint j = to[e];\n\t\t\tif (!vis2[j]) vis2[j] = e, dfs2(j, vis2);\n\t\t\tif (vis2[j] == vis[j]) y[e] = false;\n\t\t\telse y[e] = true;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tputs(v[b[i]][a[i]]^y[i]?\"diff\":\"same\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <tuple>\n#include <iterator>\n\nusing namespace std;\n\nstruct edg\n{\n    int x, i;\n};\n\nvector<edg> arr[1010];\n\nint dis[1010];\nstack<int> stk;\nint tim;\n\nint low[1010];\nint num[1010];\nvector<int> scc[1010];\nint siz;\n\nvoid f(int x)\n{\n    dis[x] = ++tim;\n    low[x] = dis[x];\n    stk.push(x);\n\n    for(edg &e : arr[x])\n    {\n        if(!dis[e.x])\n        {\n            f(e.x);\n            low[x] = min(low[x], low[e.x]);\n        }\n        else if(!num[e.x])\n            low[x] = min(low[x], dis[e.x]);\n    }\n\n    if(low[x] == dis[x])\n    {\n        siz++;\n        while(1)\n        {\n            int t = stk.top();\n            stk.pop();\n\n            num[t] = siz;\n            scc[siz].push_back(t);\n            if(t == x)\n                break;\n        }\n    }\n}\n\nbool chk1[1010];\nbool chk2[1010];\n\nvoid dfs(int x, bool *chk)\n{\n    chk[x] = 1;\n    for(edg &e : arr[x])\n        if(!chk[e.x])\n            dfs(e.x, chk);\n}\n\nbool res[200010];\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    int n, m, i;\n    scanf(\"%d%d\", &n, &m);\n    for(i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        arr[x].push_back({ y, i });\n    }\n\n    for(i = 1; i <= n; i++)\n        if(!dis[i])\n            f(i);\n\n    for(i = 1; i <= n; i++)\n        for(edg &e : arr[i])\n            if(num[i] == num[e.x])\n                res[e.i] = 1;\n\n    for(i = 1; i <= n; i++)\n    {\n        memset(chk1, 0, sizeof chk1);\n        memset(chk2, 0, sizeof chk2);\n        chk1[i] = chk2[i] = 1;\n        for(edg &e : arr[i])\n        {\n            if(num[i] == num[e.x])\n            {\n                if(chk1[e.x])\n                    res[e.i] = 0;\n\n                dfs(e.x, chk1);\n            }\n            else\n            {\n                if(chk2[e.x])\n                    res[e.i] = 1;\n\n                dfs(e.x, chk2);\n            }\n        }\n\n        reverse(arr[i].begin(), arr[i].end());\n\n        memset(chk1, 0, sizeof chk1);\n        memset(chk2, 0, sizeof chk2);\n        chk1[i] = chk2[i] = 1;\n        for(edg &e : arr[i])\n        {\n            if(num[i] == num[e.x])\n            {\n                if(chk1[e.x])\n                    res[e.i] = 0;\n\n                dfs(e.x, chk1);\n            }\n            else\n            {\n                if(chk2[e.x])\n                    res[e.i] = 1;\n\n                dfs(e.x, chk2);\n            }\n        }\n    }\n\n    for(i = 0; i < m; i++)\n    {\n        if(res[i])\n            printf(\"diff\\n\");\n        else\n            printf(\"same\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1010\n#define M 200010\nvector <int> G[N];\nint to[M],tag[N],q[2*N];\nbool ans1[M],ans2[M];\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\nsigned main(){\n\tint n=read(),m=read();\n\tfor (int i=1;i<=m;++i){\n\t\tint x=read();to[i]=read();\n\t\tG[x].push_back(i);\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j) tag[j]=0;\n\t\tint t=1,w=0;\n\t\tfor (auto &x:G[i]){\n\t\t\tq[++w]=to[x];tag[to[x]]=x;\n\t\t}\n\t\twhile (t<=w){\n\t\t\tint x=q[t++],y=tag[x];\n\t\t\tfor (auto &p:G[x]){\n\t\t\t\tint tmp=to[p];\n\t\t\t\tif (tmp!=i){\n\t\t\t\t\tif (tag[tmp]!=1){\n\t\t\t\t\t\tif (tag[tmp]==0){\n\t\t\t\t\t\t\tq[++w]=tmp;tag[tmp]=y;\n\t\t\t\t\t\t}else if (tag[tmp]!=y){\n\t\t\t\t\t\t\tq[++w]=tmp;tag[tmp]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else ans1[p]=1;\n\t\t\t}\n\t\t}\n\t\tfor (auto &x:G[i]){\n\t\t\tif (tag[to[x]]==-1) ans2[x]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=m;++i) puts(ans1[i]^ans2[i]?\"diff\":\"same\");\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n\nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[N] , B[N];\nint stk[N] , top;\n\nvector <int> G[N];\nvector <int> who[N];\n\nvoid add(int x , int y , int id) {\n\tne[++ cnt] = fir[x]; fir[x] = cnt; to[cnt] = y; Id[cnt] = id;\n}\n\n#define Foreachson(i , x) for(int i = fir[x];i;i = ne[i])\n\nvoid dfs(int x) {\n\tint cur = top;\n\tdfn[x] = low[x] = ++ dfs_clock; stk[++ top] = x;\n\tForeachson(i , x) {\n\t\tint V = to[i];\n\t\tif(!dfn[V]) {\n\t\t\tdfs(V);\n\t\t\tlow[x] = min(low[x] , low[V]);\n\t\t}\n\t\telse if(!scc[V]) low[x] = min(low[x] , low[V]);\n\t}\n\tif(dfn[x] == low[x]) {\n\t\t++ scc_tot;\n\t\twhile(top > cur) {\n\t\t\twho[scc_tot].push_back(stk[top]);\n\t\t\tscc[stk[top]] = scc_tot;\n\t\t\t-- top;\n\t\t}\n\t}\n}\n\nbool vis[N];\n\nint dp[N][N] , rd[N] , cd[N] , cur[N];\n\nvoid solve(int x) {\n\tif(vis[x]) \n\treturn;\n\tvis[x] = 1;\n\tfor(int i = 0;i < (int) G[x].size();++ i) {\n\t\tint V = G[x][i];\n\t\tsolve(V);\n\t\tfor(register int j = 1;j <= n;++ j) dp[x][j] += dp[V][j];\n\t}\n\t++ dp[x][x];\n\tfor(int i = 1;i <= n;++ i) dp[x][i] = min(dp[x][i] , 2);\n}\n\nint ans[M];\n\nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x , y , i);\n\t}\n\tfor(int i = 1;i <= n;++ i) if(!dfn[i]) dfs(i);\n\tfor(int x = 1;x <= n;++ x) {\n\t\tForeachson(i , x) {\n\t\t\tint V = to[i];\n\t\t\tif(scc[V] == scc[x]) {\n\t\t\t\t++ rd[V]; ++ cd[x];\n\t\t\t}\n\t\t\telse\n\t\t\tG[scc[x]].push_back(scc[V]);\n\t\t}\n\t}\n\tfor(int i = 1;i <= scc_tot;++ i) {\n\t\tif(!vis[i]) solve(i);\n\t}\n\tfor(int i = 1;i <= m;++ i) {\n\t\tint x = A[i] , V = B[i];\n\t\tif(scc[x] == scc[V]) {\n\t\t\tint a = cd[x] - 1 , b = rd[V] - 1;\n\t\t\tif(!a || !b) ans[i] = 1;\n\t\t\telse ans[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tif(dp[scc[x]][scc[V]] >= 2) ans[i] = 1;\n\t\t\telse ans[i] = 0;\n\t\t}\n\t}\n\tfor(int i = 1;i <= m;++ i) if(ans[i]) puts(\"diff\"); else puts(\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint v,nxt,id;\n}e[400050];\n\nint head[1050],ecnt;\nint flg1[200050],flg2[200050];\nint vis1[1050],vis2[1050];\n\nvoid adde(int u,int v,int id)\n{\n\te[++ ecnt].id = id;\n\te[ecnt].v = v;\n\te[ecnt].nxt = head[u];\n\thead[u] = ecnt;\n}\n\nvector<pair<int,int> > come[1050];\n\nvoid dfs1(int pos,int tag)\n{\n\tvis1[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis1[v])\n\t\t\tdfs1(v,tag);\n\t}\n}\n\nvoid dfs2(int pos,int tag)\n{\n\tvis2[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis2[v])\n\t\t\tdfs2(v,tag);\n\t}\n}\n\nint main()\n{\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\tadde(u,v,i); come[v].push_back(make_pair(u,i));\n\t}\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tmemset(vis1,0,sizeof(vis1));\n\t\tmemset(vis2,0,sizeof(vis2));\n\t\tvector<int> histo;\n\t\tvis1[i] = vis2[i] = -1;\n\t\tfor(int j = head[i];j;j = e[j].nxt)\n\t\t{\n\t\t\tint v = e[j].v;\n\t\t\thisto.push_back(j);\n\t\t\tif(!vis1[v])\n\t\t\t\tdfs1(v,e[j].id);\n\t\t}\n\t\tfor(int j = histo.size() - 1;j >= 0; -- j)\n\t\t{\n\t\t\tint v = e[histo[j]].v;\n\t\t\tif(!vis2[v])\n\t\t\t\tdfs2(v,e[histo[j]].id);\n\t\t}\n\t\tfor(int j = 0;j < histo.size(); ++ j)\n\t\t\tif(vis1[e[histo[j]].v] != vis2[e[histo[j]].v])\n\t\t\t\tflg2[e[histo[j]].id] = 1;\n\t\tfor(auto v : come[i])\n\t\t\tif(vis1[v.first]) flg1[v.second] = 1;\n\t}\n\tfor(int i = 1;i <= m; ++ i)\n\t\tprintf(\"%s\\n\",flg1[i] + flg2[i] == 1 ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "// u -> v same: ban u -> v, u is reachable from v ^ vice versa = 0\n// Problem : F - Two Faced Edges\n// Contest : AtCoder Regular Contest 092\n// URL : https://atcoder.jp/contests/arc092/tasks/arc092_d\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define sort(a, n) sort(a + 1, a + n + 1)\n#define temptts template <class T, class... Ts>\n\nconst int N = 2e5 + 2, mod = 1e9 + 7, inf = 2e9;\n\nstruct edge_list {\n\tint u, v, pre, nex;\n} edge[N];\n\nbool vis[N];\nint n, m, ban, ans[N], cur[N], head[N], tail[N];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor (int i = head[v]; i; i = edge[i].pre) {\n\t\tint u = edge[i].v;\n\t\tif (u == ban || vis[u]) continue;\n\t\tdfs(u);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tedge[i] = {u, v, head[u], 0};\n\t\thead[u] = i;\n\t}\n\tfor (int i = m; i >= 1; i--) {\n\t\tint u = edge[i].u;\n\t\tedge[i].nex = tail[u];\n\t\ttail[u] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tban = 0;\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint u = edge[j].u, v = edge[j].v;\n\t\t\tif (v == i) ans[j] ^= vis[u];\n\t\t}\n\t\tban = i;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int j = head[i]; j; j = edge[j].pre) {\n\t\t\tint u = edge[j].v;\n\t\t\tcur[j] |= vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int j = tail[i]; j; j = edge[j].nex) {\n\t\t\tint u = edge[j].v;\n\t\t\tans[j] ^= cur[j] | vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tcout << (ans[i] ? \"diff\" : \"same\") << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <queue>\n#include <sstream>\nusing namespace std;\n#define x first\n#define y second\n#define mp make_pair\n#define elif else if\n#define prev prev2\n#define Edge pair <int, int>\n#define next next2\n#define u first\n#define v second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1007, N = 1007, MAXM = 2e5 + 7;\nvector<int> g[MAXM], gt[MAXM];\nint a[MAXM], b[MAXM], c1[MAXM], c2[MAXM];\nvector<int> topsort;\nint vis[MAXM];\nEdge ed[MAXM];\nbool used[MAXM];\nvoid dfs(int u) {\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (!used[v]) dfs(v);\n    }   \n}   \nvoid solve(int u) {\n    //cout << \"u: \" << u << endl;\n    memset(used, 0, sizeof used);\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        //cout << v << \" \" << used[v] << endl;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n    memset(used, 0, sizeof used);\n    reverse(g[u].begin(), g[u].end());\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n}   \nvoid dfst1(int v) {\n    vis[v] = 1;\n    for (int e : g[v]) {\n        int u = b[e];\n        if (!vis[u])\n            dfst1(u);\n    }\n    topsort.push_back(v);\n}\nint clr = 0;\nvoid dfst2(int v) {\n    vis[v] = clr;\n    for (int e : gt[v]) {\n        int u = a[e];\n        if (!vis[u])\n            dfst2(u);\n    }\n}\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        cin >> a[i] >> b[i];\n        --a[i];\n        --b[i];\n        g[a[i]].push_back(i);\n        gt[b[i]].push_back(i);\n    }\n    for (int i = 0; i < n; ++i)\n        if (!vis[i])\n            dfst1(i);\n    fill(vis, vis + n, 0);\n    reverse(topsort.begin(), topsort.end());\n    for (int v : topsort)\n        if (!vis[v]) {\n            ++clr;\n            dfst2(v);\n        }\n\n    for (int i = 0; i < m; ++i) \n        c1[i] = (vis[a[i]] == vis[b[i]]);\n    for (int i = 0; i < m; ++i) {\n        ed[i] = {a[i], b[i]};\n    }   \n    for (int i = 0; i < n; ++i) {\n        solve(i);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        //cout << c1[i] << c2[i];\n        if (c1[i] ^ c2[i]) {\n            cout << \"diff\\n\";\n        }   \n        else {\n            cout << \"same\\n\";\n        }\n    }   \n    return;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.01.2020 17:37:20       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nvector<int> find_scc(const digraph<T> &g, int &cnt) {\n  digraph<T> g_rev = g.reverse();\n  vector<int> order;\n  vector<bool> was(g.n, false);\n  function<void(int)> dfs1 = [&](int v) {\n    was[v] = true;\n    for (int id : g.g[v]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (!was[to]) {\n        dfs1(to);\n      }\n    }\n    order.push_back(v);\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  vector<int> c(g.n, -1);\n  function<void(int)> dfs2 = [&](int v) {\n    for (int id : g_rev.g[v]) {\n      auto &e = g_rev.edges[id];\n      int to = e.to;\n      if (c[to] == -1) {\n        c[to] = c[v];\n        dfs2(to);\n      }\n    }\n  };\n  cnt = 0;\n  for (int id = g.n - 1; id >= 0; id--) {\n    int i = order[id];\n    if (c[i] != -1) {\n      continue;\n    }\n    c[i] = cnt++;\n    dfs2(i);\n  }\n  return c;\n  // c[i] <= c[j] for every edge i -> j\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> from(m), to(m);\n  digraph<int> g(n);\n  vector<vector<int>> gr(n);\n  for (int i = 0; i < m; i++) {\n    cin >> from[i] >> to[i];\n    --from[i]; --to[i];\n    g.add(from[i], to[i]);\n    gr[from[i]].push_back(to[i]);\n  }\n  int cnt;\n  vector<int> comp = find_scc(g, cnt);\n  vector<vector<int>> gc(cnt);\n  for (int i = 0; i < m; i++) {\n    if (comp[from[i]] != comp[to[i]]) {\n      gc[comp[from[i]]].push_back(comp[to[i]]);\n    }\n  }\n  vector<vector<int>> reach(cnt, vector<int>(cnt, 0));\n  for (int i = 0; i < cnt; i++) {\n    reach[i][i] = 1;\n    for (int j = i; j < cnt; j++) {\n      if (reach[i][j]) {\n        for (int k : gc[j]) {\n          reach[i][k] = min(2, reach[i][k] + reach[i][j]);\n        }\n      }\n    }\n  }\n  vector<vector<int>> root(n, vector<int>(n, -1));\n  for (int start = 0; start < n; start++) {\n    vector<int> que;\n    for (int j : gr[start]) {\n      que.emplace_back(j);\n      root[start][j] = j;\n    }\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int j : gr[que[b]]) {\n        if (j == start) {\n          continue;\n        }\n        if (root[start][j] == -1 || (root[start][j] >= 0 && root[start][j] != root[start][que[b]])) {\n          que.push_back(j);\n          if (root[start][j] == -1) {\n            root[start][j] = root[start][que[b]];\n          } else {\n            root[start][j] = -2;\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    if (comp[from[i]] != comp[to[i]]) {\n      cout << (reach[comp[from[i]]][comp[to[i]]] == 1 ? \"same\" : \"diff\") << '\\n';\n    } else {\n      cout << (root[from[i]][to[i]] == to[i] ? \"diff\" : \"same\") << '\\n';\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\nvector <pii> G[N],T[N];\nint n,m,ans[N],x[N],y[N];\nbool vis[N];\nvoid dfs0 (int u)\n{\n\tvis[u]=1;\n\tfor (pii x:G[u])\n\t\tif (!vis[x.fi]) dfs0 (x.fi);\n}\nint p[N],q[N];\nvoid dfs00 (int u,int rt,bool fg)\n{\n\tif (!fg) { if (!p[u]) p[u]=rt; }\n\telse { if (!q[u]) q[u]=rt; }\n\tvis[u]=1;\n\tfor (pii x:G[u])\n\t\tif (!vis[x.fi]) dfs00 (x.fi,rt,fg);\n}\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tsc(x[i]),sc(y[i]);\n\t\tG[x[i]].pb (mp(y[i],i));\n\t\tT[y[i]].pb (mp(x[i],i));\n\t}\n\tfor (int u=1; u<=n; u++)\n\t{\n\t\tmemset (vis,0,sizeof (bool)*(n+1));\n\t\tdfs0 (u);\n\t\tfor (pii x:T[u])\n\t\t\tif (vis[x.fi]) ans[x.se]=1;\n\t}\n\tfor (int u=1; u<=n; u++)\n\t{\n\t\tmemset (p,0,sizeof (int)*(n+1)),memset (q,0,sizeof (int)*(n+1));\n\t\tmemset (vis,0,sizeof (bool)*(n+1)),vis[u]=1;\n\t\tfor (pii x:G[u])\n\t\t\tdfs00 (x.fi,x.fi,0);\n\t\treverse (G[u].begin (),G[u].end ());\n\t\tmemset (vis,0,sizeof (bool)*(n+1)),vis[u]=1;\n\t\tfor (pii x:G[u])\n\t\t\tdfs00 (x.fi,x.fi,1);\n\t\tfor (pii x:G[u])\n\t\t\tif (p[x.fi]!=q[x.fi]) ans[x.se]^=1;\n\t}\n\tfor (int i=1; i<=m; i++)\n\t\tputs(ans[i]?\"diff\":\"same\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// #include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\n// using namespace __gnu_pbds;\n// using namespace __gnu_cxx;\n\ntypedef long long ll;\ntypedef unsigned int ul;\ntypedef unsigned long long ull;\ntypedef vector <int> vi;\ntypedef map<int, vector<int> > mvii;\ntypedef map<int, int> mii;\ntypedef queue <int> qi;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef vector<pair<int,int> > vpii;\n\n// Order Statistic Tree\n\n/* Special functions: \n\n\t\tfind_by_order(k) --> returns iterator to the kth largest element counting from 0\n\t\torder_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\n// typedef tree<\n// int,\n// null_type,\n// less<int>,\n// rb_tree_tag,\n// tree_order_statistics_node_update>\n// ordered_set;\n\n#define MP make_pair\n#define SORT(a) sort (a.begin(), a.end())\n#define REVERSE(a) reverse (a.begin(), a.end())\n#define ALL(a) a.begin(), a.end()\n#define PI acos(-1)\n#define ms(x,y) memset (x, y, sizeof (x))\n#define inf 1e9\n#define INF 1e16\n#define pb push_back\n#define MAX 1005\n#define debug(a,b) cout<<a<<\": \"<<b<<endl\n#define Debug cout<<\"Reached here\"<<endl\n#define prnt(a) cout<<a<<\"\\n\"\n#define mod 1000000007LL\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define FORr(i,a,b) for (int i=(a); i>=(b); i--)\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define lc ((node)<<1)\n#define rc ((node)<<1|1)\n#define VecPrnt(v) FOR(J,0,v.size()) cout<<v[J]<<\" \"; cout<<endl\n#define endl \"\\n\"\n#define PrintPair(x) cout<<x.first<<\" \"<<x.second<<endl\n#define EPS 1e-9\n#define ArrPrint(a,st,en) for(int J=st; J<=en; J++) cout<<a[J]<<\" \"; cout<<endl;\n\n/* Direction Array */\n\n// int fx[]={1,-1,0,0};\n// int fy[]={0,0,1,-1};\n// int fx[]={0,0,1,-1,-1,1,-1,1};\n// int fy[]={-1,1,0,0,1,1,-1,-1};\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    ll ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\ninline ll getnum()\n{\n    char c = getchar();\n    ll num,sign=1;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')sign=-1;\n    for(num=0;c>='0'&&c<='9';)\n    {\n        c-='0';\n        num = num*10+c;\n        c=getchar();\n    }\n    return num*sign;\n}\n\ninline ll power(ll a, ll b)\n{\n\tll multiply=1;\n\tFOR(i,0,b)\n\t{\n\t\tmultiply*=a;\n\t}\n\treturn multiply;\n}\n\n/****** END OF HEADER ******/\n\nint n, m;\nvi graph[MAX], ids[MAX];\nbool visited[MAX][MAX][2], reach[MAX][MAX];\nint way[MAX][MAX][2];\nstring ans[200005];\n\nvoid dfs(int u, int beg, int id, bool fl)\n{\n\tif(visited[beg][u][fl]) return;\n\n\t// prnt(u);\n\n\tway[beg][u][fl]=id;\n\tvisited[beg][u][fl]=true;\n\n\tfor(auto v: graph[u])\n\t{\n\t\tif(v==beg) continue;\n\n\t\tdfs(v,beg,id,fl);\n\t}\n}\n\nvoid dfs(int u, int beg)\n{\n\tif(reach[beg][u]) return;\n\treach[beg][u]=true;\n\n\tfor(auto v: graph[u])\n\t{\n\t\tdfs(v,beg);\n\t}\n}\n\nvoid solve()\n{\n\tFOR(i,1,n+1)\n\t{\n\t\tdfs(i,i);\n\t}\n\n\t// Debug;\n\n\tFOR(i,1,n+1)\n\t{\n\t\t// prnt(graph[i][0]);\n\t\tFOR(j,0,graph[i].size())\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\tdfs(v,i,id,0);\n\t\t}\n\n\t\tFORr(j,(int)graph[i].size()-1,0)\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\tdfs(v,i,id,1);\n\t\t}\n\n\t\t// cout<<\"starting from vertex \"<<i<<endl;\n\n\t\t// FOR(j,0,graph[i].size())\n\t\t// {\n\t\t// \tint v=graph[i][j];\n\t\t// \tcout<<\"to go to vertex \"<<v<<\" using edge \"<<way[i][v][0]<<\" \"<<way[i][v][1]<<endl;\n\t\t// \tcout<<\"reaching from \"<<v<<\" to \"<<i<<\" is \"<<reach[v][i]<<endl;\n\t\t// }\n\n\t\tFOR(j,0,graph[i].size())\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\t// debug(\"v\",v);\n\n\t\t\tif(way[i][v][0]==way[i][v][1])\n\t\t\t{\n\t\t\t\tif(!reach[v][i]) ans[id]=\"same\";\n\t\t\t\telse ans[id]=\"diff\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(reach[v][i]) ans[id]=\"same\";\n\t\t\t\telse ans[id]=\"diff\";\n\t\t\t}\n\t\t}\n\t}\n\n\tFOR(i,0,m) printf(\"%s\\n\", ans[i].c_str());\n}\n\nint main()\n{\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(NULL); cout.tie(NULL);\n    // freopen(\"in.txt\",\"r\",stdin);\n\n    int test, cases=1;\n\n    scanf(\"%d%d\", &n, &m);\n\n    int u, v;\n\n    FOR(i,0,m)\n    {\n    \tscanf(\"%d%d\", &u, &v);\n    \tgraph[u].pb(v);\n    \tids[u].pb(i);\n    }\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<vector<pair<int,int> > > graph;\n\n#define ALL(obj) (obj).begin(), (obj).end() \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n\nbool dfs_condition_1(graph &g,vector<bool> &check,int now,int dest){\n    if(now==dest) return true;\n    check[now-1] = true;\n    //cout << now << endl;\n    rep(i,g[now-1].size()){\n        if(!check[g[now-1][i].second-1]){ \n            if(dfs_condition_1(g, check,g[now-1][i].second,dest)) return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs_condition_2(graph &g,vector<int> &check,int num, int now,int a){\n\n    if(check[now-1]==-1) check[now-1] = num;\n          \n    rep(i,g[now-1].size()){\n        if(g[now-1][i].second!=a && check[g[now-1][i].second-1]==-1) dfs_condition_2(g, check, num, g[now-1][i].second, a);\n\n    }\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<pair<pair<int,int>, int> > e(m);\n    rep(i,m){\n        int a,b; \n        cin >> a; \n        cin >> b; \n        e[i] = make_pair(make_pair(a,b), i);\n    }\n    graph g(n);\n    sort(ALL(e));\n    int j=0;\n    rep(i,n){\n        while(j<m && e[j].first.first==i+1){\n            g[i].push_back(e[j].first);\n            j++;\n        }\n    }\n   \n    vector<bool> cf(m), cs(m);\n     \n    rep(i,m){\n        vector<bool> check(n);\n        cf[e[i].second] = dfs_condition_1(g, check, e[i].first.second, e[i].first.first);\n    } \n \n    rep(i,n){\n        vector<int> cmax(n),cmin(n);\n        rep(k,n){cmax[k]=-1; cmin[k]=-1;}\n        rep(k,g[i].size()){\n            dfs_condition_2(g, cmin, k, g[i][k].second, i+1);\n        }\n\n        rep(k,g[i].size()){\n            dfs_condition_2(g, cmax, g[i].size() - k - 1, g[i][g[i].size() - k - 1].second, i+1);\n        }\n        //rep(k,n) cout << cmax[k] << endl;\n        pair<pair<int,int>, int> pp = make_pair(make_pair(i + 1, 0), 0);\n        vector<pair<pair<int,int>, int> >::iterator itr = lower_bound(e.begin(), e.end(), pp);\n        rep(k,g[i].size()){\n           if(cmax[g[i][k].second-1]==k && cmin[g[i][k].second-1]==k) cs[(*itr++).second]=true;\n        }\n\n    }\n    //rep(i,m) if(cf[i]) cout << i+1 << \": cf true\" << endl;\n    //rep(i,m) if(cs[i]) cout << i+1 << \": cs true\" << endl;\n    rep(i,m){\n        if((cf[i]||cs[i])&&!(cf[i]&&cs[i])) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nstruct CostGraph\n{\n    using T = ll;\n    CostGraph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    struct Edge\n    {\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        const int from;\n        const int to;\n        const T cost;\n        bool operator<(const Edge& e) const { return cost != e.cost ? cost < e.cost : to < e.to; }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge(to, from, cost));\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n};\nclass StrongConnectedComponent\n{\npublic:\n    StrongConnectedComponent(const CostGraph& g)\n        : comp_num{0}, size(g.V), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            for (const auto& e : g.edge[i]) {\n                edge.push_back(make_pair(e.from, e.to));\n            }\n        }\n        vector<int> st;\n        vector<bool> used(size, false);\n        for (int i = 0; i < size; i++) {\n            if (not used[i]) {\n                dfs1_scc(g, i, st, used);\n            }\n        }\n        for (int i = 0; i < st.size(); i++) {\n            const int s = st[st.size() - i - 1];\n            if (comp[s] == -1) {\n                dfs2_scc(g, s, comp_num);\n                comp_num++;\n            }\n        }\n    }\n    const vector<int>& getComp() const { return comp; }\n    CostGraph toDAG() const\n    {\n        CostGraph dag(comp_num);\n        for (const auto& e : edge) {\n            const int u = comp[e.first];\n            const int v = comp[e.second];\n            if (u != v) {\n                dag.addEdge(u, v, 1);\n            }\n        }\n        return dag;\n    }\n\nprivate:\n    void dfs1_scc(const CostGraph& g, const int s, vector<int>& st, vector<bool>& used)\n    {\n        used[s] = true;\n        for (const auto& e : g.edge[s]) {\n            if (not used[e.to]) {\n                dfs1_scc(g, e.to, st, used);\n            }\n        }\n        st.push_back(s);\n    }\n    void dfs2_scc(const CostGraph& g, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g.rev_edge[s]) {\n            if (comp[e.to] == -1) {\n                dfs2_scc(g, e.to, c);\n            }\n        }\n    };\n    int comp_num;\n    const int size;\n    vector<int> comp;\n    vector<pair<int, int>> edge;\n};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(e, E) for (const auto& e : E)\n#define RESIDUE(s, t) (capacity[s][t] - flow[s][t])\nusing Weight = ll;\nusing Array = vector<ll>;\nusing Matrix = vector<vector<ll>>;\nstruct Edge\n{\n    Edge() = default;\n    Edge(const int src, const int dst, const ll weight) : src{src}, dst{dst}, weight{weight} {}\n    int src;\n    int dst;\n    ll weight;\n};\nusing Graph = vector<vector<Edge>>;\nGraph cutTree(const Graph& g)\n{\n    int n = g.size();\n    Matrix capacity(n, Array(n)), flow(n, Array(n));\n    for (int u = 0; u < n; u++) {\n        for (const auto e : g[u]) {\n            capacity[u][e.src] += e.weight;\n        }\n    }\n\n    vector<int> p(n), prev;\n    vector<Weight> w(n);\n    for (int s = 1; s < n; ++s) {\n        int t = p[s];  // max-flow(s, t)\n        REP(i, n)\n        REP(j, n)\n        flow[i][j] = 0;\n        Weight total = 0;\n        while (1) {\n            queue<int> Q;\n            Q.push(s);\n            prev.assign(n, -1);\n            prev[s] = s;\n            while (!Q.empty() && prev[t] < 0) {\n                int u = Q.front();\n                Q.pop();\n                FOR(e, g[u])\n                if (prev[e.dst] < 0 && RESIDUE(u, e.dst) > 0) {\n                    prev[e.dst] = u;\n                    Q.push(e.dst);\n                }\n            }\n            if (prev[t] < 0) goto esc;\n            Weight inc = INF<ll>;\n            for (int j = t; prev[j] != j; j = prev[j])\n                inc = min(inc, RESIDUE(prev[j], j));\n            for (int j = t; prev[j] != j; j = prev[j])\n                flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n            total += inc;\n        }\n    esc:\n        w[s] = total;  // make tree\n        REP(u, n)\n        if (u != s && prev[u] != -1 && p[u] == t)\n            p[u] = s;\n        if (prev[p[t]] != -1)\n            p[s] = p[t], p[t] = s, w[s] = w[t], w[t] = total;\n    }\n    Graph T(n);  // (s, p[s]) is a tree edge of weight w[s]\n    REP(s, n)\n    if (s != p[s]) {\n        T[s].push_back(Edge(s, p[s], w[s]));\n        T[p[s]].push_back(Edge(p[s], s, w[s]));\n    }\n    return T;\n}\n\n// Gomory-Hu tree を用いた最大流 O(n)\nWeight maximumFlow(const Graph& T, int u, int t, int p = -1, Weight w = INF<ll>)\n{\n    if (u == t) return w;\n    Weight d = INF<ll>;\n    FOR(e, T[u])\n    if (e.dst != p)\n        d = min(d, maximumFlow(T, e.dst, t, u, min(w, e.weight)));\n    return d;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    CostGraph g(N);\n    using P = pair<int, int>;\n    vector<P> edge(M);\n    Graph g_(N);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g.addEdge(u, v, 1);\n        g_[u].push_back(Edge{u, v, 1});\n        edge[i] = {u, v};\n    }\n\n    const auto tree = cutTree(g_);\n    StrongConnectedComponent scc(g);\n    const vector<int> comp = scc.getComp();\n    for (int i = 0; i < M; i++) {\n        const int u = edge[i].first;\n        const int v = edge[i].second;\n        if (comp[u] != comp[v]) {\n            const ll cut = maximumFlow(tree, u, v);\n            if (cut > 1) {\n                cout << \"diff\" << endl;\n            } else {\n                cout << \"same\" << endl;\n            }\n        } else {\n            const ll cut = maximumFlow(tree, u, v);\n            if (cut > 1) {\n                cout << \"diff\" << endl;\n            } else {\n                cout << \"same\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M;\nint A[1 << 18], B[1 << 18];\nint Answer[1 << 18];\n\n// 強連結成分分解\nvector<int> X[1009], Y[1009], I;\nbool used[1009];\nint col[1009], group[1009], cnts;\n\nvoid dfs1(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs1(X[pos][i]);\n\t}\n\tI.push_back(pos);\n}\n\nvoid dfs2(int pos) {\n\tcol[pos] = cnts; group[cnts]++;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (col[Y[pos][i]] >= 1) continue;\n\t\tdfs2(Y[pos][i]);\n\t}\n}\n\n// DAG における計算\nvector<pair<int, int>> Z[1009];\nint dp[1009][1009];\n\n// サイクルの列挙\nvector<pair<int, int>> P[1009], Q[1009];\nint Score1[1 << 18], Score2[1 << 18];\n\nint dfs5(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < P[pos].size(); i++) {\n\t\tif (used[P[pos][i].first] == true) continue;\n\t\tr += dfs5(P[pos][i].first);\n\t}\n\treturn r;\n}\n\nint dfs6(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < Q[pos].size(); i++) {\n\t\tif (used[Q[pos][i].first] == true) continue;\n\t\tr += dfs6(Q[pos][i].first);\n\t}\n\treturn r;\n}\n\n// 最後の計算\nvector<int> J[1009], J2[1009], K;\nint colo[1009], cntv;\n\nvoid dfs3(int pos) {\n\tused[pos] = true;\n\tfor (int i : J[pos]) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\tK.push_back(pos);\n}\n\nvoid dfs4(int pos) {\n\tcolo[pos] = cntv;\n\tfor (int i : J2[pos]) {\n\t\tif (colo[i] >= 1) continue;\n\t\tdfs4(i);\n\t}\n}\n\nbool calc(int pos) {\n\tfor (int i = 1; i <= N; i++) J[i].clear();\n\tfor (int i = 1; i <= N; i++) J2[i].clear();\n\tfor (int i = 1; i <= N; i++) used[i] = false;\n\tfor (int i = 1; i <= N; i++) colo[i] = 0;\n\tcntv = 0;\n\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (i == pos) continue;\n\t\tJ[A[i]].push_back(B[i]);\n\t\tJ2[B[i]].push_back(A[i]);\n\t}\n\tK.clear();\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\t\n\tfor (int i = K.size() - 1; i >= 0; i--) {\n\t\tif (colo[K[i]] >= 1) continue;\n\t\tcntv++; dfs4(K[i]);\n\t}\n\n\tif (cnts == cntv) return false;\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= M; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tX[A[i]].push_back(B[i]);\n\t\tY[B[i]].push_back(A[i]);\n\t}\n\n\t// ステップ 1: 強連結成分ごとに分ける\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs1(i);\n\t}\n\tfor (int i = I.size() - 1; i >= 0; i--) {\n\t\tif (col[I[i]] >= 1) continue;\n\t\tcnts++; dfs2(I[i]);\n\t}\n\n\t// ステップ 2: DAG のグラフを処理する\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tZ[col[A[i]]].push_back(make_pair(col[B[i]], i));\n\t}\n\tvector<pair<int, int>> FF;\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tfor (int j = 0; j < Z[i].size(); j++) FF.push_back(make_pair(i, Z[i][j].first));\n\t}\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tdp[i][i] = 1;\n\t\tfor (pair<int, int> j : FF) dp[i][j.second] += dp[i][j.first];\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tif (dp[col[A[i]]][col[B[i]]] != 1) Answer[i] = 2;\n\t\telse Answer[i] = 1;\n\t}\n\n\t// ステップ 3: 候補辺の列挙\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tP[A[i]].push_back(make_pair(B[i], i));\n\t\tQ[B[i]].push_back(make_pair(A[i], i));\n\t\tAnswer[i] = 1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < P[i].size(); j++) {\n\t\t\tint V1 = dfs5(P[i][j].first);\n\t\t\tScore1[P[i][j].second] = V1;\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < Q[i].size(); j++) {\n\t\t\tint V2 = dfs6(Q[i][j].first);\n\t\t\tScore2[Q[i][j].second] = V2;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tif (group[col[A[i]]] <= Score1[i] + Score2[i]) Answer[i] = 0;\n\t}\n\n\t// ステップ 4: 最後の計算\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] >= 1) continue;\n\t\tbool flag = calc(i);\n\t\tif (flag == false) Answer[i] = 1;\n\t\telse Answer[i] = 2;\n\t}\n\n\t// 出力\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] == 1) printf(\"same\\n\");\n\t\tif (Answer[i] == 2) printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define maxn 200100\nusing namespace std;\nint n,m,tot,head[1010],th[1010][1010];\nbool vis[1010];\nstruct point{\n\tint fr,to,nxt;\n}a[maxn];\nint read(){\n\tint x=0;char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn x;\n}\ninline void add(int x,int y)\n{\n\ta[++tot].fr=x;\n\ta[tot].to=y;\n\ta[tot].nxt=head[x];\n\thead[x]=tot;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tvis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tdfs(a[i].to,s,cur);\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tx=read(); y=read();\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=head[i];j;j=a[j].nxt) dfs(a[j].to,i,j);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].fr,y=a[i].to;\n\t\tif((th[y][x]&&th[x][y]!=-1)||(!th[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nvector<int>G[MAXN + 5]; int to[MAXM + 5];\nvoid addedge(int u, int i) {G[u].push_back(i);}\n\nint tag[MAXN + 5], que[2*MAXN + 5];\nbool ans1[MAXM + 5], ans2[MAXM + 5];\n\nint n, m;\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for(int i=1;i<=m;i++) {\n        int a; scanf(\"%d%d\", &a, &to[i]);\n        addedge(a, i);\n    }\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=n;j++) tag[j] = 0;\n        int s = 1, t = 0;\n        for(int p=0;p<G[i].size();p++)\n            tag[que[++t] = to[G[i][p]]] = G[i][p];\n        while( s <= t ) {\n            int x = que[s++], y = tag[x];\n            for(int p=0;p<G[x].size();p++) {\n                int q = to[G[x][p]];\n                if( q != i ) {\n                    if( tag[q] != -1 ) {\n                        if( tag[q] == 0 )\n                            tag[que[++t] = q] = y;\n                        else if( tag[q] != y )\n                            tag[que[++t] = q] = -1;\n                    }\n                }\n                else ans1[G[x][p]] = 1;\n            }\n        }\n        for(int p=0;p<G[i].size();p++)\n            if( tag[to[G[i][p]]] == -1 ) ans2[G[i][p]] = 1;\n    }\n    for(int i=1;i<=m;i++)\n        puts(ans1[i] ^ ans2[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=1005;\nconst int M=2e5+5;\nint n,m;\nbool irp[M],lnk[N][N];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nnamespace G{\n\tint rt,cnt,fir[N],col[N];\n\tstruct edge{\n\t\tint fr,to,nx;\n\t}eg[M];\n\n\tinline void add(const int a,const int b){\n\t\teg[++cnt]=(edge){a,b,fir[a]};\n\t\tfir[a]=cnt;\n\t}\n\n\tvoid dfs(const int x,const int c){\n\t\tif(col[x]) return;\n\t\tlnk[rt][x]=1;\n\t\tcol[x]=c;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tdfs(eg[i].to,c);\n\t\t}\n\t}\n\n\tvoid getrep(const int x){\n\t\tfor(int i=fir[x],j=1; i; i=eg[i].nx,++j){\n\t\t\tirp[i]|=col[eg[i].to]!=j;\n\t\t}\n\t}\n\n\tvoid set(const int x){\n\t\tstatic int buk[N];\n\t\tint cnt=0;\n\t\trt=x;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tbuk[++cnt]=eg[i].to;\n\t\t}\n\t\tmemset(col+1,0,n*sizeof(col[0]));\n\t\tcol[x]=-1;\n\t\tfor(int i=1; i<=cnt; ++i){\n\t\t\tdfs(buk[i],i);\n\t\t}\n\t\tgetrep(x);\n\t\tmemset(col+1,0,n*sizeof(col[0]));\n\t\tcol[x]=-1;\n\t\tfor(int i=cnt; i>=1; --i){\n\t\t\tdfs(buk[i],i);\n\t\t}\n\t\tgetrep(x);\n\t}\n}\n\nint main(){\n\tn=nxi(),m=nxi();\n\tfor(int i=1; i<=m; ++i){\n\t\tconst int a=nxi(),b=nxi();\n\t\tG::add(a,b);\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tG::set(i);\n\t}\n\tfor(int i=1; i<=m; ++i){\n\t\tputs(irp[i]^lnk[G::eg[i].to][G::eg[i].fr]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint a[200001],b[200001];\nbool reachable[1001][1001];\nbool visit[1001];\nvector<pair<int,int> > edge[1001];\n\nvoid dfs(int x){\n\tvisit[x]=true;\n\tfor(auto it:edge[x])\n\t\tif(!visit[it.first])\n\t\t\tdfs(it.first);\n}\n\nint minmark[1001][1001],maxmark[1001][1001];\nvoid dfs2(int from,int x,int stp){\n\tminmark[from][x]=stp;\n\tfor(int i=0;i<edge[x].size();i++)\n\t\tif(!minmark[from][edge[x][i].first])\n\t\t\tdfs2(from,edge[x][i].first,stp);\n}\nvoid dfs3(int from,int x,int stp){\n\tmaxmark[from][x]=stp;\n\tfor(int i=edge[x].size()-1;i>=0;i--)\n\t\tif(!maxmark[from][edge[x][i].first])\n\t\t\tdfs3(from,edge[x][i].first,stp);\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tedge[a[i]].emplace_back(make_pair(b[i],i));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(visit,0,sizeof visit);\n\t\tdfs(i);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\treachable[i][j]=visit[j];\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tminmark[i][i]=-1;\n\t\tfor(int j=0;j<edge[i].size();j++)\n\t\t\tif(!minmark[i][edge[i][j].first])\n\t\t\t\tdfs2(i,edge[i][j].first,edge[i][j].second);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxmark[i][i]=-1;\n\t\tfor(int j=edge[i].size()-1;j>=0;j--)\n\t\t\tif(!maxmark[i][edge[i][j].first])\n\t\t\t\tdfs3(i,edge[i][j].first,edge[i][j].second);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(reachable[b[i]][a[i]]){\n\t\t\tif((minmark[a[i]][b[i]]==i||minmark[a[i]][b[i]]==0)&&(maxmark[a[i]][b[i]]==i||maxmark[a[i]][b[i]]==0))\n\t\t\t\tcout<<\"diff\"<<'\\n';\n\t\t\telse\n\t\t\t\tcout<<\"same\"<<'\\n';\n\t\t}\n\t\telse{\n\t\t\tif((minmark[a[i]][b[i]]==i||minmark[a[i]][b[i]]==0)&&(maxmark[a[i]][b[i]]==i||maxmark[a[i]][b[i]]==0))\n\t\t\t\tcout<<\"same\"<<'\\n';\n\t\t\telse\n\t\t\t\tcout<<\"diff\"<<'\\n';\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 1e3 + 5;\nconst int INF = 1e9 + 10;\nusing namespace std;\n\nstruct P {\n    int to, flag, id;\n    P() {}\n    P(int t, int f, int i) : to(t), flag(f), id(i) {}\n};\nint n, m, T, kase = 1;\nvector<P> G[maxn];\nbool can[maxn][maxn];\nint min_flag[maxn], max_flag[maxn];\nint ans[200 * maxn];\n\nbool can_arrive(int x) {\n    can[x][x] = true;\n    queue<int> que; que.push(x);\n    while(!que.empty()) {\n        int u = que.front(); que.pop();\n        for(int i = 0; i < G[u].size(); i++) {\n            int to = G[u][i].to;\n            if(can[x][to]) continue;\n            can[x][to] = true; que.push(to);\n        }\n    }\n}\n\nvoid dfs(int x, int t, int flag) {\n    if(flag == 0 && min_flag[x] != INF) return ;\n    if(flag == 1 && max_flag[x] != -INF) return ;\n    if(flag == 0) min_flag[x] = min(min_flag[x], t);\n    if(flag == 1) max_flag[x] = max(max_flag[x], t);\n    for(int i = 0; i < G[x].size(); i++) {\n        int to = G[x][i].to;\n        dfs(to, t, flag);\n    }\n}\n\nvoid solve(int x) {\n    for(int i = 1; i <= n; i++) {\n        min_flag[i] = INF;\n        max_flag[i] = -INF;\n    }\n    min_flag[x] = max_flag[x] = 0;\n    for(int i = 0; i < G[x].size(); i++) {\n        int to = G[x][i].to;\n        dfs(to, G[x][i].flag, 0);\n    }\n    for(int i = G[x].size() - 1; i >= 0; i--) {\n        int to = G[x][i].to;\n        dfs(to, G[x][i].flag, 1);\n    }\n    for(int i = 0; i < G[x].size(); i++) {\n        int flag = 1, to = G[x][i].to;\n        if(min_flag[to] == max_flag[to]) flag = 0;\n        if(can[to][x] != flag) flag = 0;\n        else flag = 1;\n        ans[G[x][i].id] = flag;\n    }\n}\n\n\nint main() {\n    while(scanf(\"%d %d\", &n, &m) != EOF) {\n        for(int i = 0; i < maxn; i++) G[i].clear();\n        for(int i = 1; i <= m; i++) {\n            int u, v, sz;\n            scanf(\"%d %d\", &u, &v);\n            sz = G[u].size() + 1;\n            G[u].push_back(P(v, sz, i));\n        }\n        memset(can, false, sizeof can);\n        for(int i = 1; i <= n; i++) can_arrive(i);\n        for(int i = 1; i <= n; i++) solve(i);\n        for(int i = 1; i <= m; i++) printf(\"%s\\n\", ans[i] ? \"same\" : \"diff\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll llINF=0x3f3f3f3f3f3f3f3f;\nconst int N=1e5+10;\n \nstruct Edg{\n    int u, v, nxt;\n    ll w;\n}e[N<<1], edg[N<<2], tmp[N<<1];\n \nint n, m, dfs_clock, dfn[N], low[N], head[N], cn, cnt;\nint f[N], fa[N], pos[N];\n \null ans;\nll c[N][40][2];\n \nint _find(int x){\n    return f[x]==x?x:f[x]=_find(f[x]);\n}\n \nvoid init(){\n    dfs_clock=0;\n    cn=0; cnt=0; ans=0;\n    for(int i=1; i<=n; i++){\n        head[i]=-1, dfn[i]=0;\n        f[i]=i;\n        for(int j=0; j<=30; j++){\n            c[i][j][0]=((i>>j)&1)^1;\n            c[i][j][1]=(i>>j)&1;\n        }\n    }\n}\n \nvoid addEdg(int u, int v, ll w){\n    edg[cnt].u=u, edg[cnt].v=v, edg[cnt].w=w;\n    edg[cnt].nxt=head[u],head[u]=cnt++;\n}\n \nvoid cal_cir(int fir, int las, int q){\n    int num=0, id=las;\n    while(id!=fir){\n        tmp[++num]=edg[pos[id]];\n        id=fa[id];\n    }\n    tmp[++num]=edg[q];\n    ll mn=llINF;\n    for(int i=1; i<=num; i++){\n        if(tmp[i].w<mn){\n            mn=tmp[i].w; id=i;\n        }\n    }\n    for(int i=1; i<=num; i++){\n        if(i!=id){\n            e[++cn]=tmp[i];\n            e[cn].w+=mn;\n        }\n    }\n}\n \nvoid tarjan(int u, int f){\n    dfn[u]=low[u]=++dfs_clock;\n    fa[u]=f;\n    for(int i=head[u]; ~i; i=edg[i].nxt){\n        int v=edg[i].v;\n        if(v==f) continue;\n \n        if(!dfn[v]) pos[v]=i, tarjan(v, u), low[u]=min(low[u], low[v]);\n        else low[u]=min(low[u], dfn[v]);\n    }\n \n    for(int i=head[u]; ~i; i=edg[i].nxt){\n        int v=edg[i].v;\n        if(low[v]>dfn[u])\n            e[++cn]=edg[i];\n        else if(dfn[v]>dfn[u]&&fa[v]!=u)\n            cal_cir(u, v, i);\n    }\n \n}\n \nbool cmp(Edg a, Edg b){\n    return a.w>b.w;\n}\n \nint main()\n{\n\tios::sync_with_stdio(false);\n    int T;\n    cin>>T;\n    while(T--){\n        cin>>n>>m;\n        init();\n        int u, v;\n        ll w;\n        for(int i=1; i<=m; i++){\n            cin>>u>>v>>w;\n            addEdg(u, v, w);\n            addEdg(v, u, w);\n        }\n \n        tarjan(1, -1);\n \n        sort(e+1, e+1+cn, cmp);\n \n        for(int i=1; i<=cn; i++){\n            int ta=_find(e[i].u), tb=_find(e[i].v);\n            ll w=e[i].w;\n \n            for(int j=0; j<=30; j++){\n                 if (w & (1ll << j)) {\n                    ans += c[ta][j][0] * c[tb][j][0] * (1ll << j);\n                    ans += c[ta][j][1] * c[tb][j][1] * (1ll << j);\n                }\n                else {\n                    ans += c[ta][j][0] * c[tb][j][1] * (1ll << j);\n                    ans += c[ta][j][1] * c[tb][j][0] * (1ll << j);\n                }\n            }\n            f[ta]=tb;\n            for(int j=0; j<=30; j++){\n                c[tb][j][0]+=c[ta][j][0];\n                c[tb][j][1]+=c[ta][j][1];\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n#define N (1010)\n#define M (200010)\n#define PB push_back\nint n, m;\nvector<int> v[N];\nint src, cv;\nint vst[N], a[M], b[M], suc[N];\nint f[N][N], g[N][N];\nvoid dfs(int x){\n    for (auto it = v[x].begin(); it != v[x].end(); ++it){\n        int y = *it;\n        if (cv != vst[y]){\n            if (suc[y]) f[src][y] = 1;\n            vst[y] = cv;\n            dfs(y);\n        }\n    }\n}\nvoid dfs2(int x){\n    vst[x] = cv;\n    for (auto it = v[x].begin(); it != v[x].end(); ++it){\n        int y = *it;\n        if (vst[y] != cv){\n            dfs2(y);\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= m; ++i) {\n        scanf(\"%d%d\", a+i, b+i);\n        v[a[i]].PB(b[i]);\n    }\n    for (int i = 1; i <= n; ++i){\n        src = i;\n        for (int j = 1; j <= n; ++j){\n            suc[j] = 0;\n        }\n        for (auto it = v[i].begin(); it!=v[i].end(); ++it){\n            suc[*it] = 1;\n        }\n        for (auto it = v[i].begin(); it != v[i].end(); ++it){\n            vst[i] = vst[*it] = ++cv;\n            dfs(*it);\n        }\n        cv++;\n        dfs2(i);\n        for (int j = 1; j <= n; ++j){\n            g[i][j] = vst[j] == cv;\n        }\n    }\n    for (int i  =1; i <= m; ++i){\n        // printf(\"%d %d\\n\", f[a[i]][b[i]], g[b[i]][a[i]]);\n        printf(\"%s\\n\", !(f[a[i]][b[i]] ^ g[b[i]][a[i]]) ? \"same\" : \"diff\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct StronglyConnectedComponent {\n        int n;\n        vector<bool> used;\n        vector<int> order, cmp;\n        vector<vector<int>> g, rg;\n        StronglyConnectedComponent(int x) {\n                n = x;\n                g.resize(x);\n                rg.resize(x);\n                used.resize(x);\n                cmp.resize(x);\n        }\n        void add_edge(int from, int to) {\n                g[from].push_back(to);\n                rg[to].push_back(from);\n        }\n        void dfs(int u) {\n                used[u] = true;\n                for (auto v : g[u]) if (!used[v]) {\n                        dfs(v);\n                }\n                order.push_back(u);\n        }\n        void rdfs(int u, int k) {\n                used[u] = true;\n                cmp[u] = k;\n                for (auto v : rg[u]) if (!used[v]) {\n                        rdfs(v, k);\n                }\n        }\n        int init() {\n                used.assign(n, false);\n                for (int u = 0; u < n; u ++) {\n                        if (!used[u]) {\n                                dfs(u);\n                        }\n                }\n                used.assign(n, false);\n                int k = 0;\n                for (int i = order.size() - 1; i >= 0; i --) {\n                        if (!used[order[i]]) {\n                                rdfs(order[i], k ++);\n                        }\n                }\n                return k;\n        }\n};\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    /*\n    if (m > 2000) {\n        assert(false);\n    }\n    */\n    StronglyConnectedComponent scc(n);\n    vector<vector<int>> g(n);\n    vector<pair<int, int>> es;\n    for (int i = 0; i < m; i ++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a --, b --;\n        scc.add_edge(a, b);\n        es.emplace_back(a, b);\n    }\n    scc.init();\n    for (int no = 0; no < m; no ++) {\n        vector<vector<int>> g(n);\n        for (int i = 0; i < m; i ++) {\n            if (i == no) continue;\n            int a, b;\n            tie(a, b) = es[i];\n            g[a].push_back(b);\n        }\n        int s = es[no].first;\n        int t = es[no].second;\n        vector<bool> used(n, false);\n        function<void (int)> dfs = [&](int u) {\n            used[u] = true;\n            for (auto v : g[u]) if (!used[v]) {\n                dfs(v);\n            }\n        };\n        dfs(s);\n        if ((scc.cmp[s] == scc.cmp[t] && !used[t]) || (scc.cmp[s] != scc.cmp[t] && used[t])) {\n            printf(\"diff\\n\");\n        } else {\n            printf(\"same\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\nvector<int> ll[1010];\nvector<pii> edges;\nbool reachable[1010][1010];\nint removed[2][1010][1010];\n\nvoid dfs(int st, int now) {\n    for (int u : ll[now]) {\n        if (!reachable[st][u]) {\n            reachable[st][u] = true;\n            dfs(st, u);\n        }\n    }\n}\n\nvoid removed_dfs(int rm, int v, int now, int k) {\n    if (rm == now) return;\n    for (int u : ll[now]) {\n        if (!removed[k][rm][u]) {\n            removed[k][rm][u] = v;\n            removed_dfs(rm, v, u, k);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    while (m--) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        edges.emplace_back(a, b);\n    }\n    int i;\n    for (i=1; i<=n; ++i) {\n        reachable[i][i] = true;\n        dfs(i, i);\n    }\n    for (i=1; i<=n; ++i) {\n        int j = 1;\n        for (int u : ll[i]) {\n            if (!removed[0][i][u]) {\n                removed[0][i][u] = j;\n                removed_dfs(i, j, u, 0);\n            }\n            ++j;\n        }\n        for (auto it = ll[i].rbegin(); it != ll[i].rend(); ++it) {\n            int u = *it;\n            --j;\n            if (!removed[1][i][u]) {\n                removed[1][i][u] = j;\n                removed_dfs(i, j, u, 1);\n            }\n        }\n    }\n    for (pii u : edges) {\n        if (reachable[u.second][u.first]) {\n            puts(removed[0][u.first][u.second] == removed[1][u.first][u.second] ? \"diff\" : \"same\");\n        } else {\n            puts(removed[0][u.first][u.second] == removed[1][u.first][u.second] ? \"same\" : \"diff\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \n#define rint register int\nusing namespace std;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\nconst int N = 2333;\nint dfn[N], low[N], dfs_clock = 0;\nint S[N], top = 0, scc_cnt = 0, sccno[N];\nint c[N], d[N], a[N][N];\nint n, m, ans[N * N];\nvector<int> g[N];\n\ninline void tarjan(int u, int fat) {\n  dfn[u] = low[u] = ++ dfs_clock;\n  S[++ top] = u;\n  for (int v : g[u]) {\n    if (!dfn[v]) {\n      tarjan(v, u);\n      low[u] = min(low[u], low[v]);\n    }\n    else if (!sccno[v])\n      low[u] = min(low[u], dfn[v]);\n  }\n  if (low[u] == dfn[u]) {\n    ++ scc_cnt;\n    for (;;) {\n      int v = S[top --];\n      sccno[v] = scc_cnt;\n      if (v == u) break;\n    }\n  }\n}\n\ninline void dfs1(int u, int cl) {\n  if (c[u]) return ;\n  c[u] = cl;\n  for (int v : g[u])\n    dfs1(v, cl);\n}\n\ninline void dfs2(int u, int cl) {\n  if (d[u]) return ;\n  d[u] = cl;\n  for (int v : g[u])\n    dfs2(v, cl);\n}\n\nmain(void) {\n  read(n); read(m);\n  for (int i = 1; i <= m; i ++) {\n    int x, y; read(x); read(y);\n    a[x][y] = i; g[x].push_back(y);\n  }\n  for (int i = 1; i <= n; i ++)\n    if (!dfn[i]) tarjan(i, 0);\n  // for (int i = 1; i <= n; i ++)\n  //   cout << sccno[i] << \" \"; puts(\"\");\n  for (int i = 1; i <= n; i ++) {\n    memset(c, 0, sizeof c); \n    sort(g[i].begin(), g[i].end());\n    c[i] = i;\n    for (int v : g[i])\n      dfs1(v, v);\n    \n    memset(d, 0, sizeof d);\n    reverse(g[i].begin(), g[i].end());\n    d[i] = i;\n    for (int v : g[i])\n      dfs2(v, v);\n    \n    // cout << i << \"qwq\\n\";\n    // for (int v = 1; v <= n; v ++)\n    //   cout << c[v] << \" \"; puts(\"\");\n    // for (int v = 1; v <= n; v ++)\n    //   cout << d[v] << \" \"; puts(\"\");\n    for (int v : g[i])\n      ans[a[i][v]] = (sccno[i] == sccno[v]) ^ (c[v] != d[v]);\n  }\n  for (int i = 1; i <= m; i ++)\n    puts(ans[i] ? \"diff\" : \"same\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 2010\n#define M 200010\n#define pb push_back\nvector<int> v[N];\nint vis[N],c[N],X[M],Y[M],G1[N][N],G2[N][N];\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\ninline void dfs1(int x,int st) {\n    vis[x]=true,G1[st][x]=true;\n    for (auto y:v[x]) if (!vis[y]) dfs1(y,st);\n}\ninline void dfs2(int x,int col,int k,int st) {\n    if (k) G2[st][x]=(c[x]!=col); else c[x]=col;\n    vis[x]=true; for (auto y:v[x]) if (!vis[y]) dfs2(y,col,k,st);\n}\nint main() {\n    int n=read(),m=read();\n    for (int i=1;i<=m;i++) {\n        int x=read(),y=read();\n        v[x].pb(y),X[i]=x,Y[i]=y;\n    }\n    for (int i=1;i<=n;i++) {\n        memset(vis,0,sizeof(vis)),dfs1(i,i);\n    }\n    for (int i=1;i<=n;i++) {\n        memset(vis,0,sizeof(vis)),vis[i]=true;\n        memset(c,0,sizeof(c));\n        for (int j=0;j<v[i].size();j++) \n            if (!vis[v[i][j]]) dfs2(v[i][j],j+1,0,i);\n        memset(vis,0,sizeof(vis)),vis[i]=true;\n        for (int j=v[i].size()-1;j>=0;j--)\n            if (!vis[v[i][j]]) dfs2(v[i][j],j+1,1,i);\n    }\n    // for (int i=1;i<=n;i++,putchar('\\n'))\n        // for (int j=1;j<=n;j++) printf(\"%d \",G1[i][j]);\n    for (int i=1;i<=m;i++) puts(G1[Y[i]][X[i]]^G2[X[i]][Y[i]]?\"diff\":\"same\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\n#define forin(i, f, t) for(auto i = f; i < t; i++)\n\nusing namespace std;\nusing ll = long long;\n\nusing Edge = pair<int, int>;\nvector<vector<int>> nodes;\nvector<bool> visited;\n\nvoid mark(int t, int c, int id, vector<int> &map) {\n    if (c == t || visited[c]) return;\n    visited[c] = true;\n    map[c] = id;\n    cerr << c << endl;\n    forin(i, 0, nodes[c].size()) {\n        mark(t, nodes[c][i], id, map);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Edge> e(m);\n    nodes.resize(n + 1);\n    forin(i, 0, m) {\n        cin >> e[i].first >> e[i].second;\n        nodes[e[i].first].push_back(e[i].second);\n    }\n    vector<vector<int>> fMap(n + 1, vector<int>(n, 0)), dMap(n + 1, vector<int>(n, 0));\n    forin(i, 1, n + 1) {\n        visited.assign(n, false);\n        int id = 1;\n        forin(j, 0, nodes[i].size()) {\n            mark(i, nodes[i][j], id++, fMap[i]);\n        }\n        visited.assign(n, false);\n        id = (int)nodes[i].size();\n        for (auto j = nodes[i].size(); j > 0; --j) {\n            mark(i, nodes[i][j - 1], id--, dMap[i]);\n        }\n    }\n    forin(i, 0, m) {\n        auto edge = e[i];\n        if (fMap[edge.first][edge.second] != dMap[edge.first][edge.second] == fMap[edge.second][edge.first] > 0) {\n            cout << \"same\" << endl;\n        } else {\n            cout << \"diff\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 1005\n#define M 200005\nvector<int>E[N];\nint n, m, beg[N], len, num[N][N];\nbool can[N][N], vis[N], can1[N][N];\nint vis1[N], vis2[N], frm[M], tar[M];\nvoid Dfs(int u, int rt)\n{\n\tvis[u] = 1;\n\tcan[rt][u] = 1;\n\tint t = E[u].size() - 1;\n\tfor (int i = 0; i <= t; i++)\n\t{\n\t\tint v = E[u][i];\n\t\tif (vis[v])\n\t\t\tcontinue;\n\t\tDfs(v, rt);\n\t}\n}\nvoid Dfs1(int u)\n{\n\tvis[u] = 1;\n\tint t = E[u].size() - 1;\n\tfor (int i = 0; i <= t; i++)\n\t{\n\t\tint v = E[u][i];\n\t\tif (vis[v])\n\t\t\tcontinue;\n\t\tvis1[v] = num[u][v];\n\t\tDfs1(v);\n\t}\n}\nvoid Dfs2(int u)\n{\n\tvis[u] = 1;\n\tint t = E[u].size() - 1;\n\tfor (int i = t; i >= 0; i--)\n\t{\n\t\tint v = E[u][i];\n\t\tif (vis[v])\n\t\t\tcontinue;\n\t\tvis2[v] = num[u][v];\n\t\tDfs2(v);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tnum[u][v]=++len;\n\t\tfrm[len]=u;\n\t\ttar[len]=v;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tDfs(i,i);\n\t\tmemset(vis, 0, sizeof(vis));\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tDfs1(i);\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tDfs2(i);\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tint t =E[i].size()-1;\n\t\tfor (int j = 0; j <= t; j++)\n\t\t{\n\t\t\tint v=E[i][j];\n\t\t\tif(vis1[v]!=num[i][v] || vis2[v]!=num[i][v])\n\t\t\t\tcan1[i][v]=1;\n\t\t}\n\t\tmemset(vis1, 0, sizeof(vis1));\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u = frm[i], v = tar[i];\n\t\tif (can[v][u] == can1[u][v])\n\t\t\tputs(\"same\");\n\t\telse\n\t\t\tputs(\"diff\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[M],V[M],id,f[N],dfn[N],low[N];\nvector<int>e[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=666;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis1[e[i][j]])\n            dfs1(e[i][j],j+1);\n        for(int j=up-1;j>=0;j--)\n            if(!vis2[e[i][j]])\n            dfs2(e[i][j],j+1);\n        for(int j=1;j<=n;j++)\n            if(vis1[j])\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=2010,M=2e5+10;\nstruct node{int to,num;};\nvector<node>v[N];\nint n,m,ans[N][2],vis[N],num[N],q[M];\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n        {int x,y;scanf(\"%d%d\",&x,&y);v[x].push_back((node){y,i});}\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)num[j]=0;\n        int hd=1,tl=0;\n        for(int j=0;j<v[i].size();j++)\n            num[v[i][j].to]=v[i][j].num,q[++tl]=v[i][j].to;\n        while(hd<=tl)\n        {\n            int s1=q[hd++],z=num[s1];\n            for(int j=0;j<v[s1].size();j++)\n            {\n                int s2=v[s1][j].to;\n                if(s2==i)ans[v[s1][j].num][0]=1;\n                else if(num[s2]!=-1)\n                {\n                    if(!num[s2])num[s2]=z,q[++tl]=s2;\n                    else if(num[s2]!=z)num[s2]=-1,q[++tl]=s2;\n                }\n            }\n        }\n        for(int j=0;j<v[i].size();j++)\n            ans[v[i][j].num][1]|=num[v[i][j].to]==-1;\n    }\n    for(int i=1;i<=m;i++)printf(\"%s\\n\",ans[i][0]==ans[i][1]?\"same\":\"diff\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#define maxn 1005\n#define _ 0\nusing namespace std;\nstruct nod\n{\n\tint nex,id;\n\tnod(int a,int b)\n\t{\n\t\tnex=a;\n\t\tid=b;\n\t}\n\tnod(){}\n};\nint n,m,tim;\nint vis[maxn];\nint bel[maxn][maxn][2];\nint u[maxn*maxn],v[maxn*maxn];\nvector<nod> edge[maxn];\nvoid dfs(int now,int fa,int b,int f)\n{\n//\tcerr<<now<<\" \"<<fa<<\" \"<<b<<\" \"<<f<<endl;\n\tvis[now]=tim; bel[fa][now][f]=b;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,fa,b,f);\n}\nvoid solve(int now)\n{\n\ttim++; vis[now]=tim;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,0);\n \n\treverse(edge[now].begin(),edge[now].end());\n \n\ttim++; vis[now]=tim;\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsolve(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif( (bel[v[i]][u[i]][0]!=0) ^ _ ^ (bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i) )\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  int x=0,f=1;char c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return f?x:-x;\n  }\ntemplate <typename mitsuha>\ninline bool read(mitsuha &x){\n  x=0;int f=1;char c=gc();\n  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';\n  if (!~c) return 0;\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return x=f?x:-x,1;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x,int b=10){\n  if (!x) return 0&pc(48);\n  if (x<0) x=-x,pc('-');\n  int bit[99],i,p=0;\n  for (;x;x/=b) bit[++p]=x%b;\n  for (i=p;i;--i) pc(bit[i]+(bit[i]<10?48:55));\n  return 0;\n  }\ntemplate <typename mitsuha>\ninline int rwrite(mitsuha x,int b=10){\n  mitsuha ans=0,d=1;\n  for (;x;x/=10,d*=b) ans=ans+x%10*d;\n  return ans;\n  }\ninline char fuhao(){\n  char c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=2e5;\ntypedef int fuko[yuzu|10];\nfuko head,net,to;\nstruct edge{int u,v;}eg[yuzu|10];\nint cnt[1010][1011],vis[1010],can[1010][1010];\n\ninline void addedge(int u,int v){\nto[++head[0]]=v,net[head[0]]=head[u],head[u]=head[0];\n}\n\nvoid dfs(int p,int u){\nvis[u]=1,cnt[p][u]++;\nfor (int i=head[u];i;i=net[i]){\n  int v=to[i];\n  if (!vis[v]) dfs(p,v);\n  }\n}\n\nvoid dfs2(int p,int u){\nvis[u]=1,can[p][u]=1;\nfor (int i=head[u];i;i=net[i]){\n  int v=to[i];\n  if (!vis[v]) dfs2(p,v);\n  }\n}\n\nint main(){\nint i,n=read(),m=read();\nfor (i=1;i<=m;++i){\n  int u=read(),v=read();\n  addedge(u,v);\n  eg[i]=edge{u,v};\n  }\nfor (i=1;i<=n;++i){\n  for (int j=head[i];j;j=net[j]){\n    memset(vis,0,sizeof vis);\n    vis[i]=1,dfs(i,to[j]);\n    } \n  }\nfor (i=1;i<=n;++i){\n  memset(vis,0,sizeof vis);\n  dfs2(i,i);\n  }\nfor (i=1;i<=m;++i){\n  int u=eg[i].u,v=eg[i].v;\n  //cout<<(cnt[u][v])<<\" \"<<can[v][u]<<endl;\n  puts(((cnt[u][v]==1)^(!can[v][u]))?\"diff\":\"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\nvector<vector<int> > opposite_graph(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<vector<int> > h(n);\n    REP (i, n) for (int j : g[i]) h[j].push_back(i);\n    return h;\n}\npair<int, vector<int> > decompose_to_strongly_connected_components(vector<vector<int> > const & g, vector<vector<int> > const & g_rev) {\n    int n = g.size();\n    vector<int> acc(n); {\n        vector<bool> used(n);\n        function<void (int)> dfs = [&](int i) {\n            used[i] = true;\n            for (int j : g[i]) if (not used[j]) dfs(j);\n            acc.push_back(i);\n        };\n        REP (i,n) if (not used[i]) dfs(i);\n        reverse(ALL(acc));\n    }\n    int size = 0;\n    vector<int> component_of(n); {\n        vector<bool> used(n);\n        function<void (int)> rdfs = [&](int i) {\n            used[i] = true;\n            component_of[i] = size;\n            for (int j : g_rev[i]) if (not used[j]) rdfs(j);\n        };\n        for (int i : acc) if (not used[i]) {\n            rdfs(i);\n            ++ size;\n        }\n    }\n    return { size, move(component_of) };\n}\nvector<vector<int> > decomposed_graph(int size, vector<int> const & component_of, vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<vector<int> > h(size);\n    REP (i, n) for (int j : g[i]) {\n        if (component_of[i] != component_of[j]) {\n            h[component_of[i]].push_back(component_of[j]);\n        }\n    }\n    REP (k, size) {\n        sort(ALL(h[k]));\n        h[k].erase(unique(ALL(h[k])), h[k].end());\n    }\n    return h;\n}\n\ntemplate <typename AdjacencyList>\nbool breadth_first_search(int n, int src, int dst, AdjacencyList for_each_adjacent_vertex) {\n    vector<int> dist(n, INT_MAX);\n    queue<int> que;\n    dist[src] = 0;\n    que.push(src);\n    while (not que.empty()) {\n        int i = que.front(); que.pop();\n        if (i == dst) return true;\n        for_each_adjacent_vertex(i, [&](int j) {\n            if (dist[j] == INT_MAX) {\n                dist[j] = dist[i] + 1;\n                que.push(j);\n            }\n        });\n    }\n    return false;\n}\n\nvector<bool> solve(int n, int m, vector<int> const & a, vector<int> const & b) {\n    // prepare graphs\n    vector<vector<int> > g(n);\n    REP (i, m) {\n        g[a[i]].push_back(b[i]);\n    }\n    int size; vector<int> component_of; tie(size, component_of) = decompose_to_strongly_connected_components(g, opposite_graph(g));\n    vector<vector<int> > h = decomposed_graph(size, component_of, g);\n    // check for each edge\n    vector<bool> diff(m);\n    REP (i, m) {\n        if (component_of[a[i]] == component_of[b[i]]) {\n            diff[i] = not breadth_first_search(n, a[i], b[i], [&](int j, auto callback) {\n                for (int k : g[j]) if (component_of[k] == component_of[a[i]]) {\n                    if (j == a[i] and k == b[i]) continue;\n                    callback(k);\n                }\n            });\n        } else {\n            diff[i] = breadth_first_search(size, component_of[a[i]], component_of[b[i]], [&](int j, auto callback) {\n                for (int k : h[j]) {\n                    if (j == component_of[a[i]] and k == component_of[b[i]]) continue;\n                    callback(k);\n                }\n            });\n        }\n    }\n    return diff;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<int> a(m), b(m);\n    REP (i, m) {\n        cin >> a[i] >> b[i];\n        -- a[i];\n        -- b[i];\n    }\n    vector<bool> answer = solve(n, m, a, b);\n    REP (i, m) {\n        cout << (answer[i] ? \"diff\" : \"same\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\ntypedef long long lint;\nconst int N=1005;\nint n,val[N];\nbool use[N];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nint main(){\n\tstd::vector <int> step;\n\tn=nxi();\n\t{\n\t\tlint v[2]={0};\n\t\tbool all_neg=1;\n\t\tint xpos=1;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tval[i]=nxi();\n\t\t\tif(val[i]>0) v[i&1]+=val[i];\n\t\t\tall_neg&=val[i]<0;\n\t\t\tif(val[xpos]<val[i]) xpos=i;\n\t\t}\n\t\tbool p=v[1]>v[0];\n\t\tprintf(\"%lld\\n\",v[p]);\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tuse[i]=(i&1)==p&&val[i]>=0;\n\t\t}\n\t\tif(all_neg) use[xpos]=1;\n\t}\n\twhile(n>1){\n\t\tint x=n;\n\t\tfor(; x&&(use[x]||(x!=1&&x!=n&&use[x-1]!=use[x+1])); --x);\n\t\tassert(x);\n\t\tstep.push_back(x);\n\t\tif(x==1||x==n){\n\t\t\tn-=1;\n\t\t\tfor(int i=x; i<=n; ++i) use[i]=use[i+1];\n\t\t}\n\t\telse{\n\t\t\tn-=2;\n\t\t\tfor(int i=x; i<=n; ++i) use[i]=use[i+2];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(int)step.size());\n\tfor(std::vector <int> ::iterator it=step.begin(); it!=step.end(); ++it){\n\t\tprintf(\"%d\\n\",*it);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// u -> v same: ban u -> v, u is reachable from v ^ vice versa = 0\n// Problem : F - Two Faced Edges\n// Contest : AtCoder Regular Contest 092\n// URL : https://atcoder.jp/contests/arc092/tasks/arc092_d\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define sort(a, n) sort(a + 1, a + n + 1)\n#define temptts template <class T, class... Ts>\n\nconst int N = 1001, M = 2e5 + 2, mod = 1e9 + 7, inf = 2e9;\n\nstruct edge_list {\n\tint u, v, pre, nex;\n} edge[M];\n\nbool vis[N];\nint n, m, ban, ans[M], cur[M], head[N], tail[N];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor (int i = head[v]; i; i = edge[i].pre) {\n\t\tint u = edge[i].v;\n\t\tif (u == ban || vis[u]) continue;\n\t\tdfs(u);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tedge[i] = {u, v, head[u], 0};\n\t\thead[u] = i;\n\t}\n\tfor (int i = m; i >= 1; i--) {\n\t\tint u = edge[i].u;\n\t\tedge[i].nex = tail[u];\n\t\ttail[u] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tban = 0;\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint u = edge[j].u, v = edge[j].v;\n\t\t\tif (v == i) ans[j] ^= vis[u];\n\t\t}\n\t\tban = i;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int j = head[i]; j; j = edge[j].pre) {\n\t\t\tint u = edge[j].v;\n\t\t\tcur[j] |= vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t\t// memset(vis, 0, sizeof vis);\n\t\t// for (int j = tail[i]; j; j = edge[j].nex) {\n\t\t\t// int u = edge[j].v;\n\t\t\t// ans[j] ^= cur[j] | vis[u];\n\t\t\t// dfs(u);\n\t\t// }\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tputs(ans[i] ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// F.\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> II;\nvector<int> ei[1000];\nbool vis[1000];\nvector<II> edges;\nbool edge_enabled[200000];\n\nbool dfs(int s, int e) {\n\tvis[s] = true;\n\tfor (int i : ei[s]) {\n\t\tif (edge_enabled[i]) {\n\t\t\tint n = edges[i].second;\n\t\t\tif (n == e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!vis[n] && dfs(n, e)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(int argc, char *argv[])\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tei[a - 1].push_back(edges.size());\n\t\tedges.push_back(II(a - 1, b - 1));\n\t}\n\tfill(edge_enabled, edge_enabled + m, true);\n\tfor (int i = 0; i < m; ++i) {\n\t\tedge_enabled[i] = false;\n\t\tfill(vis, vis + n, false);\n\t\tbool ab = dfs(edges[i].first, edges[i].second);\n\t\tfill(vis, vis + n, false);\n\t\tbool ba = dfs(edges[i].second, edges[i].first);\n\t\tcout << (ab == ba ? \"same\" : \"diff\") << endl;\n\t\tedge_enabled[i] = true;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,x[200005],y[200005],book[1005];\nint top,nex[200005],to[200005],fir[1005];\nmap<int,int> mp[1005],mp2[1005];\nvoid lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\nvoid ss(int v,int w){\n\tbook[v]=i;\n\tmp[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss(to[top1],w==0?top1:w);\n}\nvoid ss2(int v,int w){\n\tbook[v]=i;\n\tmp2[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss2(to[top1],w==0?top1:w);\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=m;i++){\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t\tlj(x[i],y[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tss(i,0);\n\tfor(i=1;i<=top;i++){\n\t\tnex[i]=0;\n\t\tto[i]=0;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tbook[i]=0;\n\t\tfir[i]=0;\n\t}\n\ttop=0;\n\tfor(i=m;i>=1;i--)\n\t\tlj(x[i],y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tss2(i,0);\n\tfor(i=1;i<=m;i++){\n\t\tif((mp[y[i]][x[i]]!=0)+(mp[x[i]][y[i]]+mp2[x[i]][y[i]]==m+1)==1)\n\t\t\tprintf(\"same\\n\");\n\t\telse\n\t\t\tprintf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1005\nint n,m,tim,vis[N],f[N][N][2],u[N*N],v[N*N];\nstruct st{int to,id;};\nvector<st>g[N];\nvoid dfs(int x,int p,int b,int k)\n{\n\tvis[x]=tim;f[p][x][k]=b;\n\tfor(int i=0;i<g[x].size();i++)if(vis[g[x][i].to]!=tim)dfs(g[x][i].to,p,b,k);\n}\nvoid sol(int x)\n{\n\ttim++;vis[x]=tim;\n\tfor(int i=0;i<g[x].size();i++)if(vis[g[x][i].to]!=tim)dfs(g[x][i].to,x,g[x][i].id,0);\n\treverse(g[x].begin(),g[x].end());\n\ttim++;vis[x]=tim;\n\tfor(int i=0;i<g[x].size();i++)if(vis[g[x][i].to]!=tim)dfs(g[x][i].to,x,g[x][i].id,1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){scanf(\"%d%d\",&u[i],&v[i]);g[u[i]].push_back((st){v[i],i});}\n\tfor(int i=1;i<=n;i++)sol(i);\n\tfor(int i=1;i<=m;i++)if((f[v[i]][u[i]][0]!=0)^(f[u[i]][v[i]][0]!=i||f[u[i]][v[i]][1]!=i))puts(\"diff\");else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, x[200005], y[200005], mn[1005], mx[1005];\nvector<int> g[1005];\nbool bs[1005][1005], ans[200005];\n\nvoid dfs(int u, bool *bs) {\n\tif (bs[u]) return;\n\tbs[u] = true;\n\tfor (int e : g[u]) dfs(y[e], bs);\n}\nvoid dfs(int u, int *bel, int what, int ban) {\n\tif (bel[u] || u == ban) return;\n\tbel[u] = what;\n\tfor (int e : g[u]) dfs(y[e], bel, what, ban);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tg[x[i]].push_back(i);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tdfs(i, bs[i]);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(mn, 0, sizeof mn);\n\t\tmemset(mx, 0, sizeof mx);\n\t\tfor (int e : g[i]) dfs(y[e], mn, e, i);\n\t\treverse(g[i].begin(), g[i].end());\n\t\tfor (int e : g[i]) dfs(y[e], mx, e, i);\n\t\tfor (int e : g[i])\n\t\t\tif (mn[y[e]] != mx[y[e]]) ans[e] = 1;\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tans[i] ^= bs[y[i]][x[i]];\n\t\tputs(ans[i] ? \"diff\" : \"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\ntypedef unsigned long long ull;\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nvoid dfs(int k){\n\tif(k==D) return;\n\tvis[D][k]=1;\n\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k]){\n\t\tdfs(e[i].k);\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint o=vis[i][e[p].k];\n\t\t\ts[++top]=e[p].k;\n\t\t\tdfs(e[p].k);\n\t\t\tvis[i][e[p].k]=o;\n\t\t}\n\t\tif(vis[i][s[1]]) continue;\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tbool t=0;\n\t\tfor(int p=top;p>1;p--){\n\t\t\tdfs(s[p]);\n\t\t\tif(vis[i][s[1]]){\n\t\t\t\tt=1;break;\n\t\t\t}\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]=temp[p];\n\t\tif(t) vis[i][s[1]]=1;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n, m;\nbool used[1001];\nint cmp[1001];\nvector<P> g[1001], gr[1001];\nvector<int> vs;\nvector<P> dag[1001];\n\nvoid add_edge(int x, int y, int i){\n\tg[x].push_back(P(y, i));\n\tgr[y].push_back(P(x, i));\n}\n\nvoid dfs(int x){\n\tused[x]=1;\n\tfor(auto q:g[x]){\n\t\tint y=q.first;\n\t\tif(!used[y]) dfs(y);\n\t}\n\tvs.push_back(x);\n}\n \nvoid rdfs(int v, int k){\n\tused[v]=1;\n\tcmp[v]=k;\n\tfor(auto q:gr[v]){\n\t\tint y=q.first;\n\t\tif(!used[y]){\n\t\t\trdfs(y, k);\n\t\t}else if(cmp[y]!=k){\n\t\t\tdag[cmp[y]].push_back(P(k, q.second));\n\t\t}\n\t}\n}\n \nint scc(){\n\tfill(used, used+n, 0);\n\tvs.clear();\n\tfor(int i=0; i<n; i++){\n\t\tif(!used[i]) dfs(i);\n\t}\n\tfill(used, used+n, 0);\n\tint k=0;\n\tfor(int i=vs.size()-1; i>=0; i--){\n\t\tif(!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\n\nint cmp2[1001];\n\nvoid dfs2(int x, int a){\n\tused[x]=1;\n\tfor(auto q:g[x]){\n\t\tint y=q.first;\n\t\tif(y==a) continue;\n\t\tif(!used[y]) dfs2(y, a);\n\t}\n\tvs.push_back(x);\n}\n \nvoid rdfs2(int v, int k, int a){\n\tused[v]=1;\n\tcmp2[v]=k;\n\tfor(auto q:gr[v]){\n\t\tint y=q.first;\n\t\tif(y==a) continue;\n\t\tif(!used[y]){\n\t\t\trdfs2(y, k, a);\n\t\t}else if(cmp2[y]!=k){\n\t\t\tdag[cmp2[y]].push_back(P(k, q.second));\n\t\t}\n\t}\n}\n \nint scc2(int a){\n\tfill(used, used+n, 0);\n\tfill(cmp2, cmp2+n, 0);\n\tfor(int i=0; i<n; i++) dag[i].clear();\n\tvs.clear();\n\tfor(int i=0; i<n; i++){\n\t\tif(i==a) continue;\n\t\tif(!used[i]) dfs2(i, a);\n\t}\n\tfill(used, used+n, 0);\n\tint k=0;\n\tfor(int i=vs.size()-1; i>=0; i--){\n\t\tif(!used[vs[i]]) rdfs2(vs[i], k++, a);\n\t}\n\treturn k;\n}\n\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=0; i<m; i++){\n\t\tint a, b; cin>>a>>b; a--; b--;\n\t\tadd_edge(a, b, i);\n\t}\n\tint k=scc();\n\tint ans[200000]={};\n\tfor(int i=0; i<k; i++){\n\t\tint ct[1001]={};\n\t\tfor(auto q:dag[i]){\n\t\t\tct[q.first]++;\n\t\t}\n\t\tfor(int j=0; j<k; j++){\n\t\t\tfor(auto q:dag[j]){\n\t\t\t\tct[q.first]+=ct[j];\n\t\t\t\tif(ct[q.first]>2) ct[q.first]=2;\n\t\t\t}\n\t\t}\n\t\tfor(auto q:dag[i]){\n\t\t\tif(ct[q.first]>1){\n\t\t\t\tans[q.second]=-1;\n\t\t\t}else{\n\t\t\t\tans[q.second]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tint k2=scc2(i);\n\t\tint ct[1001]={};\n\t\tfor(auto q:g[i]){\n\t\t\tif(ans[q.second]==0) ct[cmp2[q.first]]++;\n\t\t}\n\t\tfor(int j=0; j<k2; j++){\n\t\t\tfor(auto q:dag[j]){\n\t\t\t\tct[q.first]+=ct[j];\n\t\t\t\tif(ct[q.first]>2) ct[q.first]=2;\n\t\t\t}\n\t\t}\n\t\tfor(auto q:g[i]){\n\t\t\tif(ans[q.second]!=0) continue;\n\t\t\tif(ct[cmp2[q.first]]>1) ans[q.second]=1;\n\t\t\telse ans[q.second]=-1;\n\t\t}\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tif(ans[i]==1) cout<<\"same\"<<endl;\n\t\telse cout<<\"diff\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 1005\n#define M 200005\nusing namespace std;\nstruct Edge{\n\tint to,next,last;\n}edge[M];\nint head[N],tot,first[N];\nvoid addedge(int from,int to){\n\tedge[++tot].to=to;\n\tif(head[from]){\n\t\tedge[head[from]].last=tot;\n\t}else{\n\t\tfirst[from]=tot;\n\t}\n\tedge[tot].next=head[from];\n\thead[from]=tot;\n}\nint p1[N][N];\nvoid dfs1(int now,int p,int cnt){\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=cnt;\n\t\tdfs1(v,p,cnt);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p,int cnt){\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=cnt;\n\t\tdfs2(v,p,cnt);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;++i){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\taddedge(u[i],v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tp1[i][i]=i;\n\t\tfor(int j=head[i];j;j=edge[j].next){\n\t\t\tint v=edge[j].to;\n\t\t\tif(p1[i][v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp1[i][v]=v;\n\t\t\tdfs1(v,i,v);\n\t\t}\n\t\tp2[i][i]=i;\n\t\tfor(int j=first[i];j;j=edge[j].last){\n\t\t\tint v=edge[j].to;\n\t\t\tif(p2[i][v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp2[i][v]=v;\n\t\t\tdfs2(v,i,v);\n\t\t}\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define sz(a) (int)(a).size()\n#define rep(i, a, b) for (int i = (a), _b = (b); i < _b; ++i)\n#define frep(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<ii> vii;\n\nconst int inf = 1e9 + 7;\nconst ll linf  = 1ll * inf * inf;\nconst int N = 1000 + 7;\nconst int M = 20;\nconst int multipleTest = 0;\n\nint ways[N][N];\nint n, m;\n\nvii edge;\n\nclass StrComp {\npublic:\n\tint num[N], low[N];\n\tint cs[N];\n\tvector<int> adj[N];\n\t int cnt = 0;\n\t int comps = 0;\n\tbitset<N> go[N];\n\tvector<int> rev[N];\n\tint tIn[N];\n\t\n\tint dp[N];\n\t\n\tvoid init(int r) {\n\t\trep(i, 1, n + 1) {\n\t\t\tnum[i] = low[i] = cs[i] = 0;\n\t\t\tadj[i].clear();\n\t\t\tgo[i].reset();\n\t\t\trev[i].clear();\n\t\t\ttIn[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tcnt = comps = 0;\n\t\tvector<int> nxt;\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tadj[e.first].push_back(e.second);\n\t\t\t} else if (e.first == r) {\n\t\t\t\tnxt.push_back(e.second);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (!num[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t\t\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tif (cs[e.first] != cs[e.second]) {\n\t\t\t\t\tint u = cs[e.first], v = cs[e.second];\n\t\t\t\t\tif (!go[u][v]) {\n\t\t\t\t\t\tgo[u][v] = 1;\n\t\t\t\t\t\trev[u].push_back(v);\n\t\t\t\t\t\t++tIn[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) dp[cs[v]]++;\n\t\t\n\t\tstatic int q[N], bot, top;\n\t\tbot = top = 0;\n\t\tfor (int i = 1; i <= comps; ++i) if (!tIn[i]) q[top++] = i;\n\t\t\n\t\twhile (bot < top) {\n\t\t\tint u = q[bot++];\n\t\t\tfor (int v : rev[u]) {\n\t\t\t\ttIn[v]--;\n\t\t\t\tdp[v] += dp[u];\n\t\t\t\tif (!tIn[v]) {\n\t\t\t\t\tq[top++] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) if (dp[cs[v]] > 1) ways[r][v] = true;\n\t}\n\t\n\tvoid dfs(int u) {\n\t\tstatic stack<int> stk;\n\t\tlow[u] = num[u] = ++cnt;\n\t\tstk.push(u);\n\t\tfor (int v : adj[u]) {\n\t\t\tif (cs[v]) continue;\n\t\t\tif (!num[v]) {\n\t\t\t\tdfs(v);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], num[v]);\n\t\t\t}\n\t\t}\n\t\tif (low[u] == num[u]) {\n\t\t\tcs[u] = ++comps;\n\t\t\twhile (stk.top() != u) {\n\t\t\t\tcs[stk.top()] = comps;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\tstk.pop();\n\t\t}\n\t}\n} st;\n\n\n\n\nvoid solve() {\n\tcin >> n >> m;\n\trep(i, 0, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tedge.push_back({u, v});\n\t}\n\tfor (int i = 1; i <= n; ++i) st.init(i);\n\t\n\tst.init(0);\n\tfor (ii e : edge) {\n\t\tint u = e.first;\n\t\tint v = e.second;\n\t\tif (st.cs[u] == st.cs[v]) {\n\t\t\tif (ways[u][v]) puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t} else {\n\t\t\tif (ways[u][v]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\t\n\t}\n}\n\nint main() {\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint Test = 1;\n\tif (multipleTest) {\n\t\tcin >> Test;\n\t}\n\tfor(int i = 0; i < Test; ++i) {\n\t\t//        printf(\"Case #%d: \", i + 1);\n\t\tsolve();\n\t}\n#ifdef _LOCAL_\n\tcout << \"\\n\" << 1.0 * clock() / CLOCKS_PER_SEC << \"\\n\";\n#endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n\ntypedef pair<int, int> P;\n\n#define fir first\n#define sec second\n\nvector<P> G[N];\n\nbool mark[N][N], mp[N][N], vis[N]; int ct[N][N];\n\nint rt, n; \n\nvoid dfs(int u, int dep) {\n    vis[u] = 1;\n    if (mp[rt][u] && dep != 1) ct[rt][u] |= 1;\n    for (auto v : G[u]) if (!vis[v.sec]) dfs(v.sec, dep + 1);\n}\n\ninline void clr() {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\ninline void solve(int u) {\n    rt = u, clr(), vis[u] = 1;\n    for (auto v : G[u]) if (!vis[v.sec]) dfs(v.sec, 1);\n    clr(), vis[u] = 1;\n    for (int i = (int)G[u].size() - 1; i >= 0; i--) if (!vis[G[u][i].sec]) dfs(G[u][i].sec, 1);\n    for (int i = 1; i <= n; i++) if (vis[i]) ct[i][u] |= 2;\n}\n\nint ans[N * 20];\n\nint main() {\n    int m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(P(i, b)), mp[a][b] = 1;\n    for (int i = 1; i <= n; i++) solve(i);\n    for (int i = 1; i <= n; i++) for (auto v : G[i]) \n        if (ct[i][v.sec] != 0 && ct[i][v.sec] != 3) ans[v.fir] = 1;\n    for (int i = 1; i <= m; i++) puts(ans[i] ? \"diff\" : \"same\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSR(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<P>edge[1005];\nint ans[200005][2];\nbool used[1005],r[1005][1005];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tedge[a].pb(mp(i,b));\n\t\t\n\t}\n\trepn(i,n) SORT(edge[i]);\n\trepn(i,n){\n\t\tmemset(used,0,sizeof(used));\n\t\tused[i] = 1;\n\t\tqueue<int>que;\n\t\trep(j,edge[i].size()){\n\t\t\tif(used[edge[i][j].sc]){\n\t\t\t\tans[edge[i][j].fi][0] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tque.push(edge[i][j].sc);\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tint q = que.front(); que.pop(); \n\t\t\t\t\tif(used[q]) continue;used[q] = 1;\n\t\t\t\t\trep(k,edge[q].size()){\n\t\t\t\t\t\tint to = edge[q][k].sc;\n\t\t\t\t\t\tif(used[to]) continue;\n\t\t\t\t\t\tque.push(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trepn(i,n) reverse(edge[i].begin(),edge[i].end());\n\trepn(i,n){\n\t\tmemset(used,0,sizeof(used));\n\t\tused[i] = 1;\n\t\tqueue<int>que;\n\t\trep(j,edge[i].size()){\n\t\t\tif(used[edge[i][j].sc]){\n\t\t\t\tans[edge[i][j].fi][0] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tque.push(edge[i][j].sc);\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\t\tif(used[q]) continue;used[q] = 1;\n\t\t\t\t\trep(k,edge[q].size()){\n\t\t\t\t\t\tint to = edge[q][k].sc;\n\t\t\t\t\t\tif(used[to]) continue;\n\t\t\t\t\t\tque.push(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trepn(i,n){\n\t\tmemset(used,0,sizeof(used));\n\t\tr[i][i] = 1;\n\t\tqueue<int>que;\n\t\trep(j,edge[i].size()){\n\t\t\tque.push(edge[i][j].sc);\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint q = que.front(); que.pop();\n\t\t\tif(used[q]) continue;used[q] = 1;\n\t\t\tr[i][q] = 1;\n\t\t\trep(k,edge[q].size()){\n\t\t\t\tint to = edge[q][k].sc;\n\t\t\t\tif(used[to]) continue;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\trepn(i,n){\n\t\trep(j,edge[i].size()){\n\t\t\tint u = edge[i][j].sc,v = i;\n\t\t\tans[edge[i][j].fi][1] = r[u][v];\n\t\t}\n\t}\n\trep(i,m) printf((ans[i][0]^ans[i][1])==1?\"diff\\n\":\"same\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\n#define ll long long\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define vint vector<int>\nusing namespace std;\n\nstruct _in {\n\tconst _in operator,(int&a)const {\n\t\ta = 0; char k = getchar(); int f = 1;\n\t\tfor (;!isdigit(k); k = getchar()) if (k == '-') f = -1;\n\t\tfor (; isdigit(k); k = getchar()) a = a * 10 + k - '0';\n\t\ta *= f; return*this;\n\t}\n}in;\n\nconst int N = 1000 + 5, M = 200000 + 5;\nvint G[N], ID[N];\nint n, m, con[N][N], x1[M], x2[M];\n\nvoid saber (int p, int x) {\n\tcon[x][p] = 1;\n\tfor (int i = 0; i < (signed)G[p].size(); ++i) {\n\t\tint v = G[p][i]; if (con[x][v]) continue;\n\t\tsaber (v, x);\n\t}\n}\n\nint sign[N], sign2[N], nowid;\n\nvoid dfs (int p, int x) {\n\t// if (p == 3 && x == 0) printf (\"x\");\n\tsign[p] = x + 1;\n\tfor (int i = 0; i < (signed)G[p].size(); ++i) {\n\t\tint v = G[p][i]; if (!sign[v] && v != nowid) dfs (v, x);\n\t}\n}\n\nvoid dfs2 (int p, int x) {\n\tsign2[p] = x + 1;\n\tfor (int i = 0; i < (signed)G[p].size(); ++i) {\n\t\tint v = G[p][i]; if (!sign2[v] && v != nowid) dfs2 (v, x);\n\t}\n}\n\nint typ[M];\n\nvoid solve (int p) {\n\tmemset (sign, 0, sizeof sign);\n\tmemset (sign2, 0, sizeof sign2);\n\tfor (int i = 0; i < (signed)G[p].size(); ++i) {\n\t\tint v = G[p][i]; if (!sign[v] && v != nowid) dfs (v, i);\n\t\tv = G[p][(signed)G[p].size() - i - 1]; if (!sign2[v] && v != nowid) dfs2 (v, (signed)G[p].size() - i - 1);\n\t}\n\tfor (int i = 0; i < (signed)G[p].size(); ++i) {\n\t\tint v = G[p][i], i1 = sign[v] - 1, i2 = sign2[v] - 1;\n\t\tif (i1 < i || i2 > i) typ[ ID[p][i] ] = 1;\n\t}\n}\n\nint main ()\n{\n\tin, n, m;\n\trep (i, 1, m) {\n\t\tint x, y; in, x, y;\n\t\tG[x].pb (y), ID[x].pb (i);\n\t\tx1[i] = x, x2[i] = y;\n\t}\n\tfor (int i = 1; i <= n; ++i) saber (i, i);\n\tfor (int i = 1; i <= n; ++i) solve (nowid = i);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint x = x1[i], y = x2[i];\n\t\tif (con[y][x] ^ typ[i]) printf (\"diff\\n\");\n\t\telse printf (\"same\\n\");\n\t}\n\t// rep (i, 1, n) rep (j, 1, n) printf (\"%d%c\", con[i][j], \" \\n\"[j == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// u -> v same: ban u -> v, u is reachable from v ^ vice versa = 0\n// Problem : F - Two Faced Edges\n// Contest : AtCoder Regular Contest 092\n// URL : https://atcoder.jp/contests/arc092/tasks/arc092_d\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define sort(a, n) sort(a + 1, a + n + 1)\n#define temptts template <class T, class... Ts>\n\nconst int N = 1001, M = 2e5 + 2, mod = 1e9 + 7, inf = 2e9;\n\nstruct edge_list {\n\tint u, v;\n} edge[M];\n\nbool vis[N];\nvector<int> adj[N], radj[N];\nint n, m, ban, ans[M], cur[M];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor (auto id : adj[v]) {\n\t\tint u = edge[id].v;\n\t\tif (u == ban || vis[u]) continue;\n\t\tdfs(u);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tedge[i] = {u, v};\n\t\tadj[u].push_back(i);\n\t\tradj[v].push_back(i);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tban = 0;\n\t\tdfs(i);\n\t\tfor (auto id : radj[i]) {\n\t\t\tans[id] ^= vis[edge[id].u];\n\t\t}\n\t\tban = i;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (auto id : adj[i]) {\n\t\t\tint u = edge[id].v;\n\t\t\tcur[id] |= vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int k = size(adj[i]) - 1; k >= 0; k--) {\n\t\t\tint id = adj[i][k], u = edge[id].v;\n\t\t\tans[id] ^= cur[id] | vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tputs(ans[i] ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1200\n\nint n,m,x[N],y[N],vis[2][N][N];\nvector<int> vec[N];\n\nvoid dfs(int op,int o,int u,int k){\n\tif (vis[op][o][u]) return;\n\tvis[op][o][u]=k;\n\tfor (int i=0;i<(int)vec[u].size();++i)\n\t\tdfs(op,o,vec[u][i],k);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;++i){scanf(\"%d%d\",&x[i],&y[i]); vec[x[i]].push_back(y[i]);}\n\tfor (int i=1;i<=n;++i){\n\t\tvis[0][i][i]=vis[1][i][i]=1;\n\t\tfor (int j=0;j<(int)vec[i].size();++j)\n\t\t\tdfs(0,i,vec[i][j],j+1);\n\t\tif (vec[i].size())\n\t\t\tfor (int j=(int)vec[i].size()-1;j>=0;--j)\n\t\t\t\tdfs(1,i,vec[i][j],j+1);\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tint u=x[i],v=y[i];\n\t\tputs((vis[0][u][v]!=vis[1][u][v])^(vis[0][v][u]>0)?\"diff\":\"same\");\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M;\nint A[1 << 18], B[1 << 18];\nint Answer[1 << 18];\n\n// 強連結成分分解\nvector<int> X[1009], Y[1009], I;\nbool used[1009];\nint col[1009], group[1009], cnts;\n\nvoid dfs1(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs1(X[pos][i]);\n\t}\n\tI.push_back(pos);\n}\n\nvoid dfs2(int pos) {\n\tcol[pos] = cnts; group[cnts]++;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (col[Y[pos][i]] >= 1) continue;\n\t\tdfs2(Y[pos][i]);\n\t}\n}\n\n// DAG における計算\nvector<pair<int, int>> Z[1009];\nint dp[1009][1009], dp2[1009];\n\n// サイクルの列挙\nvector<pair<int, int>> P[1009], Q[1009];\nint Score1[1 << 18], Score2[1 << 18];\n\nint dfs5(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < P[pos].size(); i++) {\n\t\tif (used[P[pos][i].first] == true) continue;\n\t\tr += dfs5(P[pos][i].first);\n\t}\n\treturn r;\n}\n\nint dfs6(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < Q[pos].size(); i++) {\n\t\tif (used[Q[pos][i].first] == true) continue;\n\t\tr += dfs6(Q[pos][i].first);\n\t}\n\treturn r;\n}\n\n// 最後の計算\nvector<int> J[1009], J2[1009], K;\nint colo[1009], cntv;\n\nvoid dfs3(int pos) {\n\tused[pos] = true;\n\tfor (int i : J[pos]) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\tK.push_back(pos);\n}\n\nvoid dfs4(int pos) {\n\tcolo[pos] = cntv;\n\tfor (int i : J2[pos]) {\n\t\tif (colo[i] >= 1) continue;\n\t\tdfs4(i);\n\t}\n}\n\nbool calc(int pos) {\n\tfor (int i = 1; i <= N; i++) J[i].clear();\n\tfor (int i = 1; i <= N; i++) J2[i].clear();\n\tfor (int i = 1; i <= N; i++) used[i] = false;\n\tfor (int i = 1; i <= N; i++) colo[i] = 0;\n\tcntv = 0;\n\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (i == pos) continue;\n\t\tJ[A[i]].push_back(B[i]);\n\t\tJ2[B[i]].push_back(A[i]);\n\t}\n\tK.clear();\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\t\n\tfor (int i = K.size() - 1; i >= 0; i--) {\n\t\tif (colo[K[i]] >= 1) continue;\n\t\tcntv++; dfs4(K[i]);\n\t}\n\n\tif (cnts == cntv) return false;\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= M; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tX[A[i]].push_back(B[i]);\n\t\tY[B[i]].push_back(A[i]);\n\t}\n\n\t// ステップ 1: 強連結成分ごとに分ける\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs1(i);\n\t}\n\tfor (int i = I.size() - 1; i >= 0; i--) {\n\t\tif (col[I[i]] >= 1) continue;\n\t\tcnts++; dfs2(I[i]);\n\t}\n\n\t// ステップ 2: DAG のグラフを処理する\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tZ[col[A[i]]].push_back(make_pair(col[B[i]], i));\n\t}\n\tvector<pair<int, int>> FF;\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tfor (int j = 0; j < Z[i].size(); j++) FF.push_back(make_pair(i, Z[i][j].first));\n\t}\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tdp2[i] = 1;\n\t\tfor (pair<int, int> j : FF) dp2[j.second] += dp2[j.first];\n\t\tfor (int j = 1; j <= cnts; j++) { dp[i][j] = dp2[j]; dp2[j] = 0; }\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tif (dp[col[A[i]]][col[B[i]]] != 1) Answer[i] = 2;\n\t\telse Answer[i] = 1;\n\t}\n\n\t// ステップ 3: 候補辺の列挙\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tP[A[i]].push_back(make_pair(B[i], i));\n\t\tQ[B[i]].push_back(make_pair(A[i], i));\n\t\tAnswer[i] = 1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < P[i].size(); j++) {\n\t\t\tint V1 = dfs5(P[i][j].first);\n\t\t\tScore1[P[i][j].second] = V1;\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < Q[i].size(); j++) {\n\t\t\tint V2 = dfs6(Q[i][j].first);\n\t\t\tScore2[Q[i][j].second] = V2;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tif (group[col[A[i]]] <= Score1[i] + Score2[i]) Answer[i] = 0;\n\t}\n\n\t// ステップ 4: 最後の計算\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] >= 1) continue;\n\t\tbool flag = calc(i);\n\t\tif (flag == false) Answer[i] = 1;\n\t\telse Answer[i] = 2;\n\t}\n\n\t// 出力\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] == 1) printf(\"same\\n\");\n\t\tif (Answer[i] == 2) printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    if(vis1[u]) return;\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    if(vis2[u]) return;\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=2;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            dfs1(e[i][j],j+1);\n        for(int j=up-1;j>=0;j--)\n            dfs2(e[i][j],j+1);\n        for(int j=1;j<=n;j++)\n            if(vis1[j])\n        {\n            assert(vis2[j]);\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n        else printf(\"diff\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAXN 1005\n#define MAXM 200005\n\nint n,m,u,v;\nint id[MAXN][MAXN],d[MAXN][MAXN],d2[MAXN][MAXN],q[MAXN][2];\nint ans[MAXM];\nvector<int> a[MAXN];\n\nvoid dfs(int x,int fa)\n{\n    d[fa][x]=1;\n    for(int i=0;i<(int)a[x].size();i++)\n        if(d[fa][a[x][i]]==0)\n            dfs(a[x][i],fa);\n}\n\nvoid dfs1(int x,int f,int flag)\n{\n    q[x][flag]=f;\n    for(int i=0;i<(int)a[x].size();i++)\n        if(!q[a[x][i]][flag])\n            dfs1(a[x][i],f,flag);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        id[u][v]=i;\n        a[u].push_back(v);\n    }\n    for(int i=1;i<=n;i++)\n        dfs(i,i);\n    for(int i=1;i<=n;i++)\n    {\n        memset(q,0,sizeof q);\n        q[i][0]=q[i][1]=-1;\n        for(int j=0;j<(int)a[i].size();j++)\n            if(!q[a[i][j]][0])\n                dfs1(a[i][j],j+1,0);\n        for(int j=a[i].size()-1;j>=0;j--)\n            if(!q[a[i][j]][1])\n                dfs1(a[i][j],j+1,1);\n        for(int j=0;j<(int)a[i].size();j++)\n            if(q[a[i][j]][0]!=j+1||q[a[i][j]][1]!=j+1)\n                d2[i][a[i][j]]=1;\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(d[j][i]==d2[i][j]&&id[i][j])\n                ans[id[i][j]]=1;\n    for(int i=1;i<=m;i++)\n    {\n        if(ans[i]==1)\n            printf(\"same\\n\");\n        else\n            printf(\"diff\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1010;\nint n, m, u[200010], v[200010], chk[maxn];\nbool vis[maxn][maxn], ok[maxn][maxn];\nvector<int> G[maxn];\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d %d\", &u[i], &v[i]);\n        G[u[i]].push_back(v[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        memset(chk, 0, sizeof(chk));\n        queue<int> q;\n        for (int j : G[i]) {\n            q.push(j), chk[j] = j;\n        }\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            vis[i][v] = 1;\n            if (i == v) continue;\n            for (int u : G[v]) if (~chk[u]) {\n                if (chk[u] == chk[v]) continue;\n                chk[u] = !chk[u] ? chk[v] : -1, q.push(u);\n            }\n        }\n        for (int j : G[i]) {\n            if (!~chk[j]) ok[i][j] = 1;\n        }\n    }\n    for (int i = 1; i <= m; i++) {\n        printf(\"%s\\n\", ok[u[i]][v[i]] == vis[v[i]][u[i]] ? \"same\" : \"diff\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*==============================\n * Authot : ylsoi\n * Time : 2018.3.20\n * Problem : ARC92F\n * File : ARC92F.cpp\n * Algorithm : Strange Algorithm\n * ===========================*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid File(){\n\tfreopen(\"ARC92F.in\",\"r\",stdin);\n\tfreopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define MREP(i,x) for(register int i=beg[x];i;i=E[i].last)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nint n,m,beg[maxn],len;\nbool can[maxn][maxn],can1[maxn][maxn],vis[maxn];\nstruct edge{\n\tint from;\n\tint to;\n\tint last;\n}E[maxm];\nvoid add(int u,int v){\n\t++len;\n\tE[len].from=u;\n\tE[len].to=v;\n\tE[len].last=beg[u];\n\tbeg[u]=len;\n}\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tMREP(i,u){\n\t\tint v=E[i].to;\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nbool flag;\nvoid dfs1(int u,int e,int rt){\n\tvis[u]=1;\n\tMREP(i,u){\n\t\tif(flag)return;\n\t\tint v=E[i].to;\n\t\tif(i==e)continue;\n\t\tif(v==E[e].to){\n\t\t\tcan1[rt][v]=1;\n\t\t\tflag=1;\n\t\t}\n\t\tif(vis[v])continue;\n\t\tdfs1(v,e,rt);\n\t}\n}\nint main(){\n\t//File();\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t}\n\tREP(i,1,n){\n\t\t//dfs(i,i);\n\t\tmem(vis);\n\t}\n\tREP(i,1,m){\n\t\t//dfs1(E[i].from,i,E[i].from);\n\t\tmem(vis);\n\t\tflag=0;\n\t}\n\tREP(i,1,m){\n\t\tint u=E[i].from,v=E[i].to;\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tputs(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1005;\n\nvector<int> graph[N];\n\nint n, m, l[200005], r[200005], cnt[N][N], vis[N][N];\n\nvoid dfs(int u, int p, int root, int mark) {\n    if(u == root) return ;\n    if(cnt[root][u] >= 2) return ;\n    if(vis[root][u] == mark) return ;\n    vis[root][u] = mark; cnt[root][u]++;\n    for(int i = 0; i < graph[u].size(); i++) {\n        int v = graph[u][i];\n        if(v == p) continue;\n        dfs(v, u, root, mark);\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++) {\n        cin >> l[i] >> r[i];\n        graph[l[i]].pb(r[i]);\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < graph[i].size(); j++) {\n            int v = graph[i][j];\n            dfs(v, i, i, v);\n        }\n    }\n    for(int i = 1; i <= m; i++) {\n        if(cnt[l[i]][r[i]] >= 2) {\n            if(cnt[r[i]][l[i]] == 0)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n        else {//1\n            if(cnt[r[i]][l[i]] >= 1)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{edge*nx;int t;}e[MM*3+5],*h[MN+5],*r[MN+5],*c[MN+5];\nint en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(edge**h,int x,int y){e[++en]=(edge){h[x],y};h[x]=e+en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)\n\t\tif(!d[i->t])dfs(i->t),l[x]=min(l[x],l[i->t]);\n\t\telse if(inz[i->t])l[x]=min(l[x],d[i->t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(edge**h,int x,int z)\n{\n\tu[x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)if(!u[i->t])d1(h,i->t,z),uu[i-e>>1]|=z;\n}\nbool d2(edge**h,int x,int d,int s)\n{\n\tmemset(u,0,sizeof(u));int i;\n\tfor(u[q[i=qn=0]=x]=1;i<=qn;++i)for(edge*j=h[q[i]];j;j=j->nx)\n\t{\n\t\tif((j-e>>1)!=d&&!u[j->t])u[q[++qn]=j->t]=1;\n\t\tif(q[i]==s)return false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n=read(),m=read(),i,j;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tmemset(h,0,sizeof(h));memset(r,0,sizeof(r));en=1;\n\tfor(i=1;i<=m;++i)if(p[x[i]]==p[y[i]])ins(h,x[i],y[i]),ins(r,y[i],x[i]);else en+=2;\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(edge*k=c[q[j]];k;k=k->nx)if(!g[i][k->t]++)q[++qn]=k->t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse puts(((uu[i]&1)&&d2(h,ph[p[x[i]]],i,y[i]))\n\t\t\t\t||((uu[i]&2)&&d2(r,ph[p[x[i]]],i,x[i]))?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct ede\n{\n\tint v,nxt;\n}e2[200050];\n\nvector<pair<int,int> > edge[1050];\n\nint head[1050],ecnt,hd[1050],ec;\nint flg1[200050],flg2[200050];\nint vis1[1050],vis2[1050];\n\ninline void adde(int u,int v,int id)\n{\n\tedge[u].push_back(make_pair(v,id));\n\te2[++ ec].v = u;\n\te2[ec].nxt = hd[v];\n\thd[v] = ec;\n}\n\nvoid dfs1(int pos,int tag)\n{\n\tvis1[pos] = tag;\n\tfor(auto v : edge[pos])\n\t{\n\t\tif(!vis1[v.first])\n\t\t\tdfs1(v.first,tag);\n\t}\n}\n\nvoid dfs2(int pos,int tag)\n{\n\tvis2[pos] = tag;\n\tfor(auto v : edge[pos])\n\t{\n\t\tif(!vis2[v.first])\n\t\t\tdfs2(v.first,tag);\n\t}\n}\n\nint histo[200050],hc;\n\nint main()\n{\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\tadde(u,v,i);\n\t}\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t//\tcerr << i << endl;\n\t\tmemset(vis1,0,sizeof(vis1));\n\t\tmemset(vis2,0,sizeof(vis2));\n\t\thc = 0;\n\t\tvis1[i] = vis2[i] = -1;\n\t\tfor(auto v : edge[i])\n\t\t{\n\t\t\tif(!vis1[v.first])\n\t\t\t\tdfs1(v.first,v.second);\n\t\t}\n\t\tfor(int j = edge[i].size() - 1;j >= 0; -- j)\n\t\t{\n\t\t\tauto v = edge[i][j];\n\t\t\tif(!vis2[v.first])\n\t\t\t\tdfs2(v.first,v.second);\n\t\t\tif(vis1[v.first] != vis2[v.first])\n\t\t\t\tflg2[v.second] = 1;\n\t\t}\n\t\tfor(int j = hd[i];j;j = e2[j].nxt)\n\t\t\tif(vis1[e2[j].v])\n\t\t\t\tflg1[j] = 1;\n\t}\n\tfor(int i = 1;i <= m; ++ i)\n\t\tputs(flg1[i] + flg2[i] == 1 ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint fir[1010],dis[200010],nxt[200010],id,ex[200010],ey[200010];\nvoid link(int a,int b){nxt[++id]=fir[a],fir[a]=id,dis[id]=b;}\nint vis[1010][1010],que[1010],hd,tl,from[1010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),x,y;\n\tfor(int i=1;i<=m;++i)ex[i]=x=gi(),ey[i]=y=gi(),link(x,y);\n\tfor(int s=1;s<=n;++s){\n\t\tint*v=vis[s];\n\t\tv[s]=1;hd=tl=0,que[tl++]=s;from[s]=0;\n\t\twhile(hd^tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=fir[x];i;i=nxt[i]){\n\t\t\t\tif(!v[dis[i]])v[dis[i]]=1,from[dis[i]]=x==s?dis[i]:from[x],que[tl++]=dis[i];\n\t\t\t\telse if(dis[i]!=from[x])++v[dis[i]];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tx=ex[i],y=ey[i];\n\t\tif(vis[y][x])puts(vis[x][y]==1?\"diff\":\"same\");\n\t\telse puts(vis[x][y]==1?\"same\":\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1005;\nconst int M=200005;\nstruct edge{\n\tint to,next;\n}e[M];\nint head[N],tot;\nint n,m,x[N],y[N];\nint co1[N][N],co2[N][N];\nint vis[N],q[N];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nvoid dfs(int x,int co){\n\tvis[x]=co;\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (!vis[e[i].to])\n\t\t\tdfs(e[i].to,co);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,m){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tadd(x[i],y[i]);\n\t}\n\tFor(i,1,n){\n\t\t*q=0;\n\t\tfor (int j=head[i];j;j=e[j].next)\n\t\t\tq[++*q]=e[j].to;\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tFor(j,1,*q) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co1[i][j]=vis[j];\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tRep(j,*q,1) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co2[i][j]=vis[j];\n\t}\n\tFor(i,1,m){\n\t\tbool f1=(co1[y[i]][x[i]]!=0);\n\t\tbool f2=(co2[x[i]][y[i]]&&co2[x[i]][y[i]]!=y[i])||(co1[x[i]][y[i]]&&co1[x[i]][y[i]]!=y[i]);\n\t\tputs(f1^f2?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1005;\n\nvector<int> graph[N];\n\nint n, m, l[N], r[N], cnt[N][N], vis[N][N];\n\nvoid dfs(int u, int p, int root, int mark) {\n    if(u == root) return ;\n    if(cnt[root][u] >= 2) return ;\n    if(vis[root][u] == mark) return ;\n    vis[root][u] = mark; cnt[root][u]++;\n    for(int i = 0; i < graph[u].size(); i++) {\n        int v = graph[u][i];\n        if(v == p) continue;\n        dfs(v, u, root, mark);\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++) {\n        cin >> l[i] >> r[i];\n        graph[l[i]].pb(r[i]);\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < graph[i].size(); j++) {\n            int v = graph[i][j];\n            dfs(v, i, i, v);\n        }\n    }\n    for(int i = 1; i <= m; i++) {\n        if(cnt[l[i]][r[i]] >= 2) {\n            if(cnt[r[i]][l[i]] == 0)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n        else {//1\n            if(cnt[r[i]][l[i]] >= 1)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define M 200000\n#define N 1001\nusing namespace std;\nint a[N],b[M],c[M],d[M],e[N][N],f[N][N],m,n;bool x[N];\ninline bool cmp(int u,int v){return b[u]==b[v]?c[u]<c[v]:b[u]<b[v];}\nvoid dfs(int u,int*w){for(int i=a[u-1];i<a[u];i++)if(!w[b[i]])w[b[i]]=w[u],dfs(b[i],w);}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++)scanf(\"%d%d\",b+i,c+i),a[b[d[i]=i]]++;\n\tsort(d,d+m,cmp);\n\tfor(int i=1;i<=n;i++)a[i]+=a[i-1],e[i][i]=f[i][i]=-1;\n\tfor(int i=0;i<m;i++)b[i]=c[d[i]];\n\tfor(int i=0;i<m;i++)c[i]=d[i];\n\tfor(int i=1;i<=n;i++)for(int j=a[i-1];j<a[i];j++)if(!e[i][b[j]])dfs(e[i][b[j]]=b[j],e[i]);\n\tfor(int i=1;i<=n;i++)for(int j=a[i];a[i-1]<j--;)if(!f[i][b[j]])dfs(f[i][b[j]]=b[j],f[i]);\n\tfor(int i=1;i<=n;i++)for(int j=a[i-1];j<a[i];j++)x[c[j]]=(bool)e[b[j]][i]^e[i][b[j]]==f[i][b[j]];\n\tfor(int i=0;i<m;i++)puts(x[i]?\"same\":\"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=2010,M=2e5+10;\nstruct node{int to,num;};\nvector<node>v[N];\nint n,m,ans[M][2],num[N],q[M*10];\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n        {int x,y;scanf(\"%d%d\",&x,&y);v[x].push_back((node){y,i});}\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)num[j]=0;\n        int hd=1,tl=0;\n        for(int j=0;j<v[i].size();j++)\n            num[v[i][j].to]=v[i][j].num,q[++tl]=v[i][j].to;\n        while(hd<=tl)\n        {\n            int s1=q[hd++],z=num[s1];\n            for(int j=0;j<v[s1].size();j++)\n            {\n                int s2=v[s1][j].to;\n                if(s2==i)ans[v[s1][j].num][0]=1;\n                else if(num[s2]!=-1)\n                {\n                    if(!num[s2])num[s2]=z,q[++tl]=s2;\n                    else if(num[s2]!=z)num[s2]=-1,q[++tl]=s2;\n                }\n            }\n        }\n        for(int j=0;j<v[i].size();j++)\n            ans[v[i][j].num][1]|=num[v[i][j].to]==-1;\n    }\n    for(int i=1;i<=m;i++)printf(\"%s\\n\",ans[i][0]==ans[i][1]?\"same\":\"diff\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <map>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long lint;\n#define p(a,b) make_pair(a,b)\n\nint main(){\n    lint N,M;\n    cin >> N >> M;\n    vector<int> edge[1001];\n    int *A,*B;\n    A=new int[M+1];\n    B=new int[M+1];\n    map<pair<int,int>,int> eind;\n    for(int i=1;i<=M;i++){\n        int a,b;\n        cin >> a >> b;\n        A[i]=a;\n        B[i]=b;\n        edge[a].push_back(b);\n        eind[p(a,b)]=i;\n    }\n\n    bool *conn;\n    conn=new bool[M+1];\n    for(int i=1;i<=M;i++) conn[i]=false;\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=N;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=0;e+1<edge[v].size();e++){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e+1]]) conn[eind[p(v,edge[v][e+1])]]=true;\n        }\n    }\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=1000;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=-1+edge[v].size();e>0;e--){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e-1]]) conn[eind[p(v,edge[v][e-1])]]=true;\n        }\n    }\n\n    bitset<1001> map[1001];\n    for(int i=1;i<=N;i++){\n        map[i]=0;\n        map[i][i]=true;\n    }\n\n    for(int v=1;v<=N;v++){\n        for(int e=1;e<=M;e++) map[A[e]]|=map[B[e]];\n    }\n\n    for(int i=1;i<=M;i++){\n        if(map[B[i]][A[i]]==conn[i]) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n\n    delete[] A,B,conn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1010;\nint n, m, u[200010], v[200010], chk[maxn];\nbool vis[maxn][maxn], ok[maxn][maxn];\nvector<int> G[maxn];\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d %d\", &u[i], &v[i]);\n        G[u[i]].push_back(v[i]);\n    }\n    for (int i = 1; i <= n; i++) {\n        memset(chk, 0, sizeof(chk));\n        queue<int> q;\n        for (int j : G[i]) {\n            q.push(j), chk[j] = j;\n        }\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            vis[i][v] = 1;\n            for (int u : G[v]) if (!chk[u] || chk[u] == u) {\n                if (chk[u] == chk[v]) continue;\n                chk[u] = chk[v], q.push(u);\n            }\n        }\n        for (int j : G[i]) {\n            if (chk[j] ^ j) ok[i][j] = 1;\n        }\n    }\n    for (int i = 1; i <= m; i++) {\n        printf(\"%s\\n\", ok[u[i]][v[i]] == vis[v[i]][u[i]] ? \"same\" : \"diff\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<vl> mat;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst double PI = 4*atan(1);\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint N,M;\nbitset<1000> reach[1000];\nint flow[1000][1000];\nvi adj[1000];\nset<pi> bad;\nvpi edge;\n\nvoid init() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> M;\n    F0R(i,M) {\n        int x,y; cin >> x >> y;\n        x--, y--;\n        edge.pb({x,y});\n        adj[x].pb(y);\n        reach[x][y] = 1;\n    }\n    F0R(k,N) \n        F0R(i,N) if (reach[i][k])\n            reach[i] |= reach[k];\n}\n\nbool posi[1000], ok[1000];\n\nvoid dfs(int cur, int x) {\n    if (posi[cur] || cur == x) return;\n    posi[cur] = 1;\n    for (int i: adj[cur]) dfs(i,x);\n}\n\nvoid genBad(int x) {\n    F0R(i,N) posi[i] = 0, ok[i] = 1;\n    for (int i: adj[x]) {\n        if (posi[i]) ok[i] = 0;\n        dfs(i,x);\n    }\n    F0R(i,N) posi[i] = 0;\n    F0Rd(I,sz(adj[x])) {\n        int i = adj[x][I];\n        if (posi[i]) ok[i] = 0;\n        dfs(i,x);\n    }\n    for (int i: adj[x]) {\n        if (ok[i]) bad.insert({x,i});\n    }\n}\n\nint main() {\n    init();\n    F0R(i,N) genBad(i);\n    for (auto a: edge) {\n        if (reach[a.s][a.f]) {\n            if (bad.count(a)) cout << \"diff\\n\";\n            else cout << \"same\\n\";\n        } else {\n            if (!bad.count(a)) cout << \"diff\\n\";\n            else cout << \"same\\n\";\n        }\n    }\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int id)\n{\n\tSCC scc; scc.init(n);\n\tint cntscc=0;\n\tfor(int i=0;i<edges.size();i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tif(i==id) swap(u,v);\n\t\tscc.addedge(u,v);\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcntscc=max(cntscc,scc.sccidx[i]);\n\t}\n\tif(cntscc!=mxscc) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,x);\n\t}\n}\n\nbool reach[1111][1111];\nmap<ii,int> CNT;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i][i]=1;\n\t\tqueue<int> q; q.push(i);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front(); q.pop();\n\t\t\tfor(ii x:adj[u])\n\t\t\t{\n\t\t\t\tint v=x.fi; \n\t\t\t\tif(!reach[v]) q.push(v);\n\t\t\t\treach[i][v]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tbool pos=0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j==i) continue;\n\t\t\t\t\tif(j==v) continue;\n\t\t\t\t\tif(reach[i][j]&&reach[j][v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpos=1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=1005,MAXM=200005;\n \nint N,M;\nvector<int> adj[MAXN];\nint E[MAXM][2];\n \nint p[MAXN][MAXN],q[MAXN][MAXN];\nbool vis[MAXN];\n \nvoid mark(int s,int u,int id,int mk[])\n{\n\tif(u==s||vis[u])return;\n\tvis[u]=true;\n\tmk[u]=id;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t\tmark(s,adj[u][i],id,mk);\n}\n \nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1,a,b;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tE[i][0]=a;E[i][1]=b;\n\t\tadj[a].push_back(b);\n\t}\n\t\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tint id=0;\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],++id,p[i]);\n\t\tmemset(vis,0,sizeof vis);\n\t\treverse(adj[i].begin(),adj[i].end());\n\t\tid=adj[i].size();\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],id--,q[i]);\n\t}\n\t\n\tfor(int i=1;i<=M;i++)\n\t\tif((p[E[i][1]][E[i][0]]>0)==(p[E[i][0]][E[i][1]]!=q[E[i][0]][E[i][1]]))\n\t\t\tputs(\"same\");\n\t\telse\n\t\t\tputs(\"diff\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m;\npii edges[252521];\nint ids[252521];\n\nconst int B = 500;\n\nstruct SCC {\n  int n;\n  vector<vi> g;\n  // scc\n  // http://www.prefield.com/algorithm/graph/strongly_connected_components.html\n  vi num;\n  vi low;\n  stack<int> S;\n  vector<bool> inS;\n  int time;\n  vector<vi> scc;\n  int count;\n  bool construct;\n  vi rev;\n\n  SCC(int n):n(n){\n    g.resize(n);\n  }\n  void add_edge(int a, int b){\n    g[a].push_back(b);\n  }\n  void add_edge(pii P){\n    add_edge(P.first, P.second);\n  }\n  void visit(int v){\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    REP(e,g[v].size()){\n      int w = g[v][e];\n      if(num[w]==0){\n        visit(w);\n        low[v] = min(low[v], low[w]);\n      }else if(inS[w]){\n        low[v] = min(low[v], num[w]);\n      }\n    }\n    if(low[v] == num[v]){\n      if(construct)scc.push_back(vi());\n      count++;\n      while(true){\n        int w = S.top(); S.pop(); inS[w] = false;\n        if(construct){\n          scc.back().push_back(w);\n          rev[w] = scc.size()-1;\n        }\n        if(v == w)break;\n      }\n    }\n  }\n  int calc(bool _const){\n    num.assign(n,0);\n    low.assign(n,0);\n    inS.assign(n,false);\n    time = 0;\n    count = 0;\n    construct = _const;\n    if(construct){\n      rev.assign(n,0);\n    }\n    REP(u,n)if(num[u]==0){\n      visit(u);\n    }\n    return count;\n  }\n};\n\n// O(sqrt(m) (m + n))\n\nbool ans[252521];\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  REP(i,m){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    edges[i] = pii(a,b);\n  }\n  // initial scc\n  int num = 0;\n  {\n    SCC scc(n);\n    REP(i,m)scc.add_edge(edges[i]);\n    num = scc.calc(false);\n  }\n  REP(i,m)ids[i] = i;\n  srand(83025);\n  // random_shuffle(ids,ids+m);\n  REP(tims, (m+B-1)/B){\n    int beg = B*tims, end = min(B*(tims+1), m);\n    // construct partial graph\n    SCC scc(n);\n    REP(i,m)if(i<beg || end<=i){\n      scc.add_edge(edges[ids[i]]);\n    }\n    scc.calc(true);\n    set<pii> e2;\n    REP(i,m)if(i<beg || end<=i)e2.insert(pii(scc.rev[edges[i].first], scc.rev[edges[i].second]));\n    FOR(i,beg,end){\n      SCC scc2(scc.count);\n      for(pii P : e2){\n        scc2.add_edge(P);\n      }\n      FOR(j,beg,end){\n        if(i==j){\n          scc2.add_edge(scc.rev[edges[ids[j]].second], scc.rev[edges[ids[j]].first]);\n        }else{\n          scc2.add_edge(scc.rev[edges[ids[j]].first], scc.rev[edges[ids[j]].second]);\n        }\n      }\n      int num2 = scc2.calc(false);\n      ans[ids[i]] = num == num2;\n    }\n  }\n  REP(i,m)puts(ans[i]?\"same\":\"diff\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1005;\nconst int M = 200005;\nbool not_necessary[N][N];\nvector<int> con[N];\nint a[M], b[M];\nint vis[N];\nint fe[N];\n\nstruct graph {\n  int n;\n  vector<vector<int>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst) {\n    adj[src].push_back(dst);\n  }\n\n  vector<vector<int>> strongly_connected_components() {\n    vector<vector<int>> scc;\n    vector<int> S, B, I(n);\n    function<void(int)> dfs = [&](int u) {\n      B.push_back(I[u] = S.size());\n      S.push_back(u);\n      for (int v: adj[u]) {\n        if (!I[v]) dfs(v);\n        else while (I[v] < B.back()) B.pop_back();\n      }\n      if (I[u] == B.back()) {\n        scc.push_back({});\n        B.pop_back();\n        for (; I[u] < S.size(); S.pop_back()) {\n          scc.back().push_back(S.back());\n          I[S.back()] = n + scc.size();\n        }\n      }\n    };\n    for (int u = 0; u < n; ++u)\n      if (!I[u]) dfs(u);\n    return scc; // I[u] - n is the index of u\n  }\n};\n\ntemplate<class T>\nstruct fixedSizeQueue{\n\tint n, L, R;\n\tT * arr;\n\tfixedSizeQueue(int n) : n(n){\n\t\tarr = new T[2 * n + 10];\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tvoid push_back(T x){\n\t\tarr[++R] = x; \n\t}\n\n\tvoid push_front(T x){\n\t\tarr[--L] = x;\n\t}\n\t\n\tT front(){\n\t\treturn arr[L];\n\t}\n\n\tT back(){\n\t\treturn arr[R];\n\t}\n\n\tT pop_front(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[L++];\n\t}\n\n\tT pop_back(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[R--];\n\t}\n\n\tvoid re_init_indices(){\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tbool empty(){\n\t\treturn L > R;\n\t}\n};\nint main(){\n\tint n, m; sd(n); sd(m);\n\tgraph g(n + 1);\n\tfor(int i = 1; i <= m; i++){\n\t\tsd(a[i]);\n\t\tsd(b[i]);\n\t\tcon[a[i]].push_back(b[i]);\n\t\tg.add_edge(a[i], b[i]);\n\t}\n\tvector<vector<int>> comp = g.strongly_connected_components();\n\tvector<int> where(n + 1);\n\tfor(int i = 0; i < comp.size(); i++)\n\t\tfor(auto it : comp[i])\n\t\t\twhere[it] = i;\n\tfixedSizeQueue<pii> q(2 * n);\n\tfor(int i = 1; i <= n; i++){\n\t\tq.re_init_indices();\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int v : con[i]){\n\t\t\tq.push_front({v, v});\n\t\t\tvis[v] = 1;\n\t\t\tfe[v] = v;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tauto it = q.pop_back();\n\t\t\tint u = it.F, firstEdge = it.S;\n\t\t\tfor(int v : con[u]){\n\t\t\t\tif(v == i || vis[v] >= 2) continue;\n\t\t\t\tif(vis[v] == 1 && firstEdge == fe[v]) continue;\n\t\t\t\tq.push_front({v, firstEdge});\n\t\t\t\tif(vis[v] == 0)\n\t\t\t\t\tfe[v] = firstEdge;\n\t\t\t\tvis[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int v : con[i]) if(vis[v] == 2){\n\t\t\tnot_necessary[i][v] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\n\t\tprintf( (not_necessary[a[i]][b[i]] ^ (where[a[i]] != where[b[i]] )) ? \"same\\n\" : \"diff\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int MAXN = 1005;\nconst int MAXM = 2e5 + 10;\n\ntypedef pair<int, int> mypair;\n\nvector<int> linker[MAXN];\nint n, m, vis[MAXN], from[MAXM], to[MAXM];\nbool g1[MAXN][MAXN], g2[MAXN][MAXN];\nmypair pre[MAXN];\n\nvoid dfs1(int x)\n{\n\tvis[x] = 1;\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (vis[cur]) continue;\n\t\tpre[cur] = mypair(x, i), dfs1(cur);\n\t}\n}\n\nvoid dfs2(int x)\n{\n\tvis[x] = 1;\n\tfor (int i = linker[x].size() - 1; i >= 0; i --)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (vis[cur]) continue;\n\t\tpre[cur] = mypair(x, i), dfs2(cur);\n\t}\n}\n\nint main()\n{\n\tn = read(), m = read();\n\tfor (int i = 1; i <= m; i ++)\n\t{\n\t\tfrom[i] = read(), to[i] = read();\n\t\tlinker[from[i]].push_back(to[i]);\n\t}\n\tfor (int s = 1; s <= n; s ++)\n\t{\n\t\tmemset(vis, 0, sizeof vis);\n\t\tstatic mypair tmp[MAXN];\n\t\tdfs1(s);\n\t\tmemcpy(tmp, pre, sizeof pre);\n\t\tmemset(vis, 0, sizeof vis);\n\t\tdfs2(s);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t{\n\t\t\tif (vis[i])\n\t\t\t{\n\t\t\t\tg1[s][i] = 1;\n\t\t\t\tif (pre[i].first != s || tmp[i].first != s)\n\t\t\t\t\tg2[s][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i ++)\n\t{\n\t\tint u = from[i], v = to[i];\n\t\tif (g1[v][u] ^ g2[u][v]) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define sz(a) (int)(a).size()\n#define rep(i, a, b) for (int i = (a), _b = (b); i < _b; ++i)\n#define frep(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<ii> vii;\n\nconst int inf = 1e9 + 7;\nconst ll linf  = 1ll * inf * inf;\nconst int N = 1000 + 7;\nconst int M = 20;\nconst int multipleTest = 0;\n\nint ways[N][N];\nint n, m;\n\nvii edge;\n\nclass StrComp {\npublic:\n\tint num[N], low[N];\n\tint cs[N];\n\tvector<int> adj[N];\n\t int cnt = 0;\n\t int comps = 0;\n\tbitset<N> go[N];\n\tvector<int> rev[N];\n\tint tIn[N];\n\tvector<int> nxt;\n\t\n\tint dp[N];\n\t\n\tvoid init(int r) {\n\t\trep(i, 1, n + 1) {\n\t\t\tnum[i] = low[i] = cs[i] = 0;\n\t\t\tadj[i].clear();\n\t\t\tgo[i].reset();\n\t\t\trev[i].clear();\n\t\t\ttIn[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tcnt = comps = 0;\n\t\t nxt.clear();\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tadj[e.first].push_back(e.second);\n\t\t\t} else if (e.first == r) {\n\t\t\t\tnxt.push_back(e.second);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (!num[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t\tif (!r || nxt.size() <= 1) return;\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tif (cs[e.first] != cs[e.second]) {\n\t\t\t\t\tint u = cs[e.first], v = cs[e.second];\n\t\t\t\t\tif (!go[u][v]) {\n\t\t\t\t\t\tgo[u][v] = 1;\n\t\t\t\t\t\trev[u].push_back(v);\n\t\t\t\t\t\t++tIn[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) dp[cs[v]]++;\n\t\t\n\t\tstatic int q[N], bot, top;\n\t\tbot = top = 0;\n\t\tfor (int i = 1; i <= comps; ++i) if (!tIn[i]) q[top++] = i;\n\t\t\n\t\twhile (bot < top) {\n\t\t\tint u = q[bot++];\n\t\t\tfor (int v : rev[u]) {\n\t\t\t\ttIn[v]--;\n\t\t\t\tdp[v] += dp[u];\n\t\t\t\tif (!tIn[v]) {\n\t\t\t\t\tq[top++] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) if (dp[cs[v]] > 1) ways[r][v] = true;\n\t}\n\t\n\tvoid dfs(int u) {\n\t\tstatic stack<int> stk;\n\t\tlow[u] = num[u] = ++cnt;\n\t\tstk.push(u);\n\t\tfor (int v : adj[u]) {\n\t\t\tif (cs[v]) continue;\n\t\t\tif (!num[v]) {\n\t\t\t\tdfs(v);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], num[v]);\n\t\t\t}\n\t\t}\n\t\tif (low[u] == num[u]) {\n\t\t\tcs[u] = ++comps;\n\t\t\twhile (stk.top() != u) {\n\t\t\t\tcs[stk.top()] = comps;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\tassert(!stk.empty() && stk.top() == u);\n\t\t\tstk.pop();\n\t\t}\n\t}\n} st;\n\n\n\n\nvoid solve() {\n\tcin >> n >> m;\n\trep(i, 0, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tedge.push_back({u, v});\n\t}\n\tfor (int i = 1; i <= n; ++i) st.init(i);\n\t\n\tst.init(0);\n\tfor (ii e : edge) {\n\t\tint u = e.first;\n\t\tint v = e.second;\n\t\tif (st.cs[u] == st.cs[v]) {\n\t\t\tif (ways[u][v]) puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t} else {\n\t\t\tif (ways[u][v]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint Test = 1;\n\tif (multipleTest) {\n\t\tcin >> Test;\n\t}\n\tfor(int i = 0; i < Test; ++i) {\n\t\t//        printf(\"Case #%d: \", i + 1);\n\t\tsolve();\n\t}\n#ifdef _LOCAL_\n\tcout << \"\\n\" << 1.0 * clock() / CLOCKS_PER_SEC << \"\\n\";\n#endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 1010;\ntypedef std::vector<int> VI;\ntypedef std::pair<int, int> pi;\nVI out[MAXN], rout[MAXN], ine[MAXN];\nint n, m;\nint * ind; VI * so;\nvoid dfs(int t) {\n\t// std::cout << \"DFS \" << t << std::endl;\n\tfor (auto i : so[t]) if (!ind[i]) ind[i] = t, dfs(i);\n}\nstd::map<pi, int> u2v, v2u;\nint xs[MAXN], ys[MAXN];\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tstd::cin >> xs[i] >> ys[i];\n\t\tout[xs[i]].push_back(ys[i]);\n\t\tine[ys[i]].push_back(xs[i]);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::sort(out[i].begin(), out[i].end());\n\t\trout[i].assign(out[i].rbegin(), out[i].rend());\n\t}\n\tstatic int i1[MAXN], i2[MAXN];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(i1, 0, n + 1 << 2);\n\t\tmemset(i2, 0, n + 1 << 2);\n\t\tso = out,  ind = i1, i1[i] = n + 1; dfs(i);\n\t\tso = rout, ind = i2, i2[i] = n + 1; dfs(i);\n\t\tfor (auto t : ine[i]) if (i1[t]) v2u[pi(t, i)] = true;\n\t\tfor (auto t : out[i])\n\t\t\tif (i1[t] != i2[t] || i1[t] != i)\n\t\t\t\tu2v[pi(i, t)] = true;\n\t//\tstd::cout << \"DEBUG \" << i << \" : \";\n\t//\tfor (int j = 1; j <= n; ++j)\n\t//\t\tstd::cout << i1[j] << ',' << i2[j] << ' ';\n\t//\tstd::cout << std::endl;\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tauto t = pi(xs[i], ys[i]);\n\t\t// std::cout << \"DBG \" << xs[i] << ' ' << ys[i] << ' ' << u2v[t] << ' ' << v2u[t] << std::endl;\n\t\tstd::cout << (u2v[t] ^ v2u[t] ? \"diff\\n\" : \"same\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 1054, M = 200054;\n\nstruct edge {\n\tint u, v;\n\tedge (int u0 = 0, int v0 = 0) : u(u0), v(v0) {}\n} e[M];\n\nint V, E, tag, root;\nint first[N], next[M], from[N], que[N];\nbool saturated[N], connected[N][N], reversible[N][N];\n\ninline void addedge(int u, int v, int id) {e[id] = edge(u, v), next[id] = first[u], first[u] = id;}\n\nvoid bfs(int si) {\n\tint i, x, y, h, t = 1; *que = si;\n\tfrom[si] ? (saturated[si] = true) : (from[si] = tag);\n\tfor (h = 0; h < t; ++h) {\n\t\tx = que[h];\n\t\tfor (i = first[x]; i; i = next[i])\n\t\t\tif (!saturated[y = e[i].v] && from[y] != tag)\n\t\t\t\tfrom[y] ? (saturated[y] = true) : (from[y] = tag), que[t++] = y;\n\t}\n}\n\nvoid solve() {\n\tint i;\n\tmemset(saturated, false, V + 1), saturated[root] = true;\n\tmemset(from, 0, (V + 1) << 2);\n\tfor (i = first[root]; i; i = next[i]) if (!saturated[tag = e[i].v]) bfs(tag);\n\tfor (i = 1; i <= V; ++i) if (i != root)\n\t\tconnected[root][i] = saturated[i] || from[i],\n\t\treversible[root][i] = saturated[i] || (from[i] && from[i] != i);\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (i = 1; i <= E; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v, i);\n\tfor (root = 1; root <= V; ++root) solve();\n\tfor (i = 1; i <= E; ++i)\n\t\tu = e[i].u, v = e[i].v, puts(connected[v][u] == reversible[u][v] ? \"same\" : \"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n        /*\n        printf(\"i = %d\\n\", i);\n        for (int j=1; j<=n; ++j) {\n            printf(\"%d %d\\n\", starred[j], res[i][j]);\n        }\n        //*/\n    }\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else puts(\"diff\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n,m;\nvector<ll> g[1010];\nvector<P> es;\nll cnt[1010][1010];\nbool vis[1010];\n\nvoid dfs(ll v,ll st){\n  vis[v]=true;\n  cnt[st][v]++;\n  for(ll nv : g[v]){\n    if(vis[nv]||nv==st)continue;\n    dfs(nv,st);\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,m){\n    ll a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    es.push_back(P(a,b));\n  }\n\n  rep(i,n){\n    for(ll v : g[i]){\n      memset(vis,0,sizeof(vis));\n      dfs(v,i);\n    }\n  }\n\n  rep(i,m){\n    ll a=cnt[es[i].fi][es[i].se];\n    ll b=cnt[es[i].se][es[i].fi];\n    if((a>=2&&b>=1)||(a<2&&b<1))cout<<\"same\"<<endl;\n    else cout<<\"diff\"<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1010;\nconst int maxm = 200010;\nconst int inf = 0x3f3f3f3f;\n\nint l[maxn], e, ban_id;\n\nstruct Edge {\n\tint v, id, x;\n} E[maxm];\n\nint e_u[maxm], e_v[maxm], Q[maxn], vis[maxn], n, m;\nint col[maxn], rt[maxn], dfn[maxn], low[maxn], sta[maxn], cnt, top, tim;\nint fa[maxn][20], dep[maxn], mn_id[maxn], mx[maxn][maxn], ontree[maxm];\n\nvector<int> G[maxn];\n\ninline void addEdge(int u, int v, int id) {\n\tE[e].v = v, E[e].x = l[u], E[e].id = id, l[u] = e++;\n}\n\nvoid init_vis() {\n\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\nvoid dfs_calmx(int u) {\n\tfor (int i = 1; i <= n; i++) mx[u][i] = -inf;\n\tmx[u][u] = 0;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (!vis[v]) dfs_calmx(v);\n\t\tfor (int j = 1; j <= n; j++) mx[u][j] = max(mx[u][j], mx[v][j] + 1);\n\t}\n}\n\nint check(int a, int b) {\n\tinit_vis();\n\tvis[a] = 1;\n\tint s = 0, t = 0; Q[t++] = a;\n\twhile (s < t) {\n\t\tint u = Q[s++];\n\t\tif (u == b) return 1;\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\tif (E[p].id != ban_id && !vis[v]) {\n\t\t\t\tvis[v] = 1;\n\t\t\t\tQ[t++] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid tarjan(int u) {\n\tdfn[u] = low[u] = ++ tim; sta[++ top] = u; vis[u] = 1;\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (!dfn[v]) {\n\t\t\ttarjan(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else if (vis[v]) {\n\t\t\tlow[u] = min(low[u], dfn[v]);\n\t\t}\n\t}\n\tif (low[u] == dfn[u]) {\n\t\tint t = 0; rt[++ cnt] = u;\n\t\tdo {\n\t\t\tt = sta[top --];\n\t\t\tcol[t] = cnt;\n\t\t\tvis[t] = 0;\n\t\t} while (t != u);\n\t}\n}\n\nvoid dfs_buildtree(int u, int f) {\n\tvis[u] = 1;\n\tfa[u][0] = f;\n\tfor (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (col[v] == col[u] && !vis[v]) {\n\t\t\tontree[E[p].id] = 1;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tdfs_buildtree(v, u);\n\t\t}\n\t}\n}\n\nint lca(int u, int v) {\n\tif (dep[u] < dep[v]) swap(u, v);\n\tif (dep[u] > dep[v]) {\n\t\tint c = dep[u] - dep[v];\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tif (c & (1<<i)) {\n\t\t\t\tu = fa[u][i];\n\t\t\t\tv = fa[u][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (u == v) return u;\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (fa[u][i] != fa[v][i]) {\n\t\t\tu = fa[u][i];\n\t\t\tv = fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\taddEdge(u, v, i);\n\t\te_u[i] = u, e_v[i] = v;\n\t}\n\tfor (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] != col[v]) {\n\t\t\tG[col[u]].push_back(col[v]);\n\t\t}\n\t}\n\tinit_vis();\n\tfor (int i = 1; i <= cnt; i++) dfs_buildtree(rt[i], 0);\n\tinit_vis();\n\tfor (int i = 1; i <= cnt; i++) if (!vis[i]) dfs_calmx(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] == col[v]) {\n\t\t\tif (!mn_id[u] || dep[lca(u,v)] < dep[mn_id[u]]) \n\t\t\t\tmn_id[u] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] != col[v]) {\n\t\t\tif (mx[col[u]][col[v]] > 1) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t} else {\n\t\t\tif (mn_id[u] != i && !ontree[i]) {\n\t\t\t\tputs(\"same\");\n\t\t\t} else {\n\t\t\t\tban_id = i;\n\t\t\t\tint t = check(u, v);\n\t\t\t\tif (t) puts(\"same\");\n\t\t\t\telse puts(\"diff\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x << \" = \" << x << endl\n#define fori(i, ini, lim) for(int i = int(ini); i < int(lim); i++)\n#define ford(i, ini, lim) for(int i = int(ini); i >= int(lim); i--)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\n\nconst int MAX = 1e3 + 5;\nbool path[MAX][MAX], two_path[MAX][MAX];\nint mark[MAX];\nvector<int> adj[MAX];\nint n, m;\n\nvoid bfs(int start) {\n\tqueue<int> q;\n\tq.push(start);\n\tpath[start][start] = true;\n\twhile(!q.empty()) {\n\t\tint cur = q.front(); q.pop();\n\t\tfor(auto &each : adj[cur]) {\n\t\t\tif(!path[start][each]) {\n\t\t\t\tpath[start][each] = true;\n\t\t\t\tq.push(each);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int node, int start, int first_malandro) {\n\tfor(auto &each : adj[node]) {\n\t\tif(each != start && mark[each] == -1) {\n\t\t\tmark[each] = first_malandro;\n\t\t\tdfs(each, start, first_malandro);\n\t\t}\n\t}\n}\n\nvoid roll(int start) {\n\tmemset(mark, -1, sizeof mark);\n\n\tfor(auto &each : adj[start]) {\n\t\tif(mark[each] == -1) {\n\t\t\tmark[each] = each;\n\t\t}\n\t\tdfs(each, start, each);\n\t}\n\n\tfor(auto &each : adj[start]) {\n\t\tif(mark[each] != -1 && mark[each] != each) {\n\t\t\ttwo_path[start][each] = true;\n\t\t}\n\t}\n\n\tmemset(mark, -1, sizeof mark);\n\n\tford(i, adj[start].size() - 1, 0) {\n\t\tint each = adj[start][i];\n\t\tif(mark[each] == -1) {\n\t\t\tmark[each] = each;\n\t\t}\n\t\tdfs(each, start, each);\n\t}\n\n\tfor(auto &each : adj[start]) {\n\t\tif(mark[each] != -1 && mark[each] != each) {\n\t\t\ttwo_path[start][each] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tvector<ii> edges;\n\tfori(i, 1, m + 1) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tadj[a].push_back(b);\n\n\t\tedges.emplace_back(a, b);\n\t}\n\n\tfori(i, 1, n + 1) {\n\t\tbfs(i);\n\t\troll(i);\n\t}\n\n\tfor(auto &edge : edges) {\n\t\tint a, b;\n\t\ttie(a, b) = edge;\n\n\t\tif(path[a][b] && path[b][a]) { // same scc\n\t\t\tif(two_path[a][b]) {\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(two_path[a][b]) {\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[100000];\nusing int64 = unsigned long long;\nbool ans[100000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 64) {\n\n\n    int l = _, r = min< int >(g[idx].size(), _ + 64);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else dp[e.first] |= dp[p];\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxn=1000+50;\nconst int maxm=200000+50;\nint n,m;\nint dfc;\nint tim;\nint top;\nint scnt;\nint f[maxn];\nint cnt[maxn];\nint deg[maxn];\nint dfn[maxn];\nint low[maxn];\nint que[maxn];\nint ran[maxn];\nint sta[maxn];\nint vis[maxn];\nint head[maxn];\nint sccno[maxn];\nbool an[maxm];\nvector<int> scc[maxn];\nvector<pii> adj[maxn];\nstruct edge\n{\n\tint to,nex;\n\tedge(int to=0,int nex=0):to(to),nex(nex){}\n};\nvector<edge> G;\ninline void addedge(int u,int v)\n{\n\tG.push_back(edge(v,head[u])),head[u]=G.size()-1;\n}\ninline void adde(int u,int v,int w)\n{\n\tadj[u].push_back(make_pair(v,w));\n\t++deg[v];\n}\nvoid tarjan(int u)\n{\n\tlow[u]=dfn[u]=++dfc;\n\tsta[++top]=u;\n\tfor(int i=head[u];~i;i=G[i].nex)\n\t{\n\t\tint v=G[i].to;\n\t\tif(!dfn[v])\n\t\t{\n\t\t\ttarjan(v);\n\t\t\tlow[u]=min(low[u],low[v]);\n\t\t}\n\t\telse if(!sccno[v])\n\t\t{\n\t\t\tlow[u]=min(low[u],dfn[v]);\n\t\t}\n\t}\n\tif(low[u]>=dfn[u])\n\t{\n\t\t++scnt;\n\t\twhile(true)\n\t\t{\n\t\t\tint v=sta[top--];\n\t\t\tsccno[v]=scnt;\n\t\t\tscc[scnt].push_back(v);\n\t\t\tif(u==v) break;\n\t\t}\n\t}\n}\nvoid findscc()\n{\n\tfor(int i=1;i<=n;++i) if(!dfn[i])\n\t{\n\t\ttarjan(i);\n\t}\n\tfor(int u=1;u<=n;++u)\n\t{\n\t\tfor(int i=head[u];~i;i=G[i].nex)\n\t\t{\n\t\t\tint v=G[i].to;\n\t\t\tif(sccno[u]!=sccno[v])\n\t\t\t{\n\t\t\t\tadde(sccno[u],sccno[v],i);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid topsort()\n{\n\tint hd=0,tl=0; \n\tfor(int i=1;i<=scnt;++i) if(deg[i]==0)\n\t{\n\t\tque[tl++]=i; \n\t} \n\twhile(hd<tl)\n\t{\n\t\tint u=que[hd++];\n\t\tfor(unsigned int i=0;i<adj[u].size();++i)\n\t\t{\n\t\t\tint v=G[i].to;\n\t\t\tif(--deg[v]==0)\n\t\t\t{\n\t\t\t\tque[tl++]=v;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;++i) ran[que[i]]=i;\n}\nvoid solve1(int x)\n{\n\tmemset(f,0,sizeof(f));\n\tf[x]=1;\n\tfor(int j=ran[x];j<n;++j)\n\t{\n\t\tint u=que[j];\n\t\tfor(unsigned int i=0;i<adj[u].size();++i)\n\t\t{\n\t\t\tint v=adj[u][i].fi;\n\t\t\tf[v]=min(2,f[u]+f[v]);\n\t\t}\n\t}\n\tfor(unsigned int i=0;i<adj[x].size();++i)\n\t{\n\t\tint v=adj[x][i].fi;\n\t\tif(f[v]>1) an[adj[x][i].se]=true;\n\t}\n}\nvoid dfs(int u)\n{\n\tif(vis[u]==tim||cnt[u]==2) return;\n\tvis[u]=tim;\n\t++cnt[u];\n\tfor(int i=head[u];~i;i=G[i].nex)\n\t{\n\t\tint v=G[i].to;\n\t\tif(sccno[v]==sccno[u])\n\t\t{\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nvoid solve2(int x)\n{\n\tfor(unsigned int j=0;j<scc[x].size();++j)\n\t{\n\t\tint u=scc[x][j];\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tfor(int i=head[u];~i;i=G[i].nex)\n\t\t{\n\t\t\tint v=G[i].to;\n\t\t\tif(sccno[v]==x)\n\t\t\t{\n\t\t\t\tvis[u]=++tim;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t\t}\n\t\tfor(int i=head[u];~i;i=G[i].nex)\n\t\t{\n\t\t\tint v=G[i].to;\n\t\t\tif(sccno[v]==x)\n\t\t\t{\n\t\t\t\tif(cnt[v]==1) an[i]=true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve()\n{\n\tfindscc();\n\ttopsort();\n\tfor(int i=1;i<=scnt;++i)\n\t{\n\t\tsolve1(i);\n\t\tsolve2(i);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\taddedge(a,b);\n\t}\n\tsolve();\n\tfor(int i=0;i<m;++i)\n\t{\n\t\tputs(an[i]?\"diff\":\"same\");\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "3 3\n1 2\n1 3\n2 3"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nconst int N=1010,M=200100;\n\nbool g[N][N],ans[N][N];\nint f0[N],f1[N];\n\nint begin[N],next[M],to[M];\nint e;\n\nvoid add(int x,int y)\n{\n\tto[++e]=y;\n\tnext[e]=begin[x];\n\tbegin[x]=e;\n}\n\nvoid dfs(int p,int h)\n{\n\tif(g[h][p])return;g[h][p]=1;\n\tfor(int i=begin[p];i;i=next[i])\n\t\tdfs(to[i],h);\n}\n\nvoid Dfs(int p,int h,int *f)\n{\n\tif(f[p])return;\n\tf[p]=h;\n\tfor(int i=begin[p];i;i=next[i])\n\t\tDfs(to[i],h,f);\n}\n\nint n,m;\n\nvoid work(int p)\n{\n\tstatic int seq[N],tot;\n\ttot=0;\n\tfor(int i=begin[p];i;i=next[i])\n\t\tseq[++tot]=to[i];\n\tstd::sort(seq+1,seq+tot+1);\n\tmemset(f0,0,sizeof(f0)),memset(f1,0,sizeof(f1));\n\tf0[p]=f1[p]=2333;\n\n\tfor(int i=1;i<=tot;i++)\n\t\tDfs(seq[i],seq[i],f0);\n\tfor(int i=tot;i;i--)\n\t\tDfs(seq[i],seq[i],f1);\n\n\tfor(int i=1;i<=n;i++)\n\t\tans[p][i]=f0[i]!=f1[i];\n}\n\nint E[M][2];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,u,v;i<=m;i++)\n\t\tscanf(\"%d%d\",&u,&v),E[i][0]=u,E[i][1]=v,add(u,v);\n\tfor(int i=1;i<=n;i++)dfs(i,i);\n\tfor(int i=1;i<=n;i++)work(i);\n\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u=E[i][0],v=E[i][1];\n\t\tif(g[v][u])printf(\"%s\\n\",ans[u][v]?\"same\":\"diff\");\n\t\telse printf(\"%s\\n\",ans[u][v]?\"diff\":\"same\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int N=1010,M=200200;\nint n,m,u,v,vi[N],bo[N],g[N][N],ans[M];\nmap<P,int>id;\nvector<int>ve[N];\nvoid dfs(int u,int*a){a[u]=1;for(int v:ve[u])if(!a[v]) dfs(v,a);}\nvoid work(int u){\n\tFOR(i,1,n) vi[i]=i==u;\n\tfor(int v:ve[u]) vi[v]?bo[v]=1:(dfs(v,vi),0);\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tFOR(i,1,m) scanf(\"%d%d\",&u,&v),ve[u].push_back(v),id[P(u,v)]=i;\n\tFOR(i,1,n) dfs(i,g[i]);\n\tFOR(i,1,n){\n\t\tfor(int v:ve[i]) bo[v]=0;\n\t\twork(i);\n\t\treverse(ve[i].begin(),ve[i].end());\n\t\twork(i);\n\t\tfor(int v:ve[i]) ans[id[P(i,v)]]=g[v][i]^bo[v];\n\t}\n\tFOR(i,1,m) puts(ans[i]?\"diff\":\"same\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define spln(i,n) (i==n?'\\n':' ')\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar())&&c!='-')if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,bel[1005][1005][2],px[200005],py[200005];\nvector<pair<int,int> > bi[1005];\nvoid dfs(int x,int y,int z,int typ)\n{\n\tif(bel[y][x][typ]){\n\t\treturn;\n\t}\n\tbel[y][x][typ]=z;\n\tff(bi[x],it){\n\t\tdfs(it->first,y,z,typ);\n\t}\n}\nint main()\n{\n\tread(n);read(m);\n\tfz1(i,m){\n\t\tread(px[i]);read(py[i]);\n\t\tbi[px[i]].push_back(make_pair(py[i],i));\n\t}\n\tfz1(i,n){\n\t\tbel[i][i][0]=bel[i][i][1]=-1;\n\t\tff(bi[i],it){\n\t\t\tdfs(it->first,i,it->second,0);\n\t\t}\n\t\treverse(bi[i].begin(),bi[i].end());\n\t\tff(bi[i],it){\n\t\t\tdfs(it->first,i,it->second,1);\n\t\t}\n\t}\n\tfz1(i,m){\n\t\tif((!!bel[py[i]][px[i]][0])^(bel[px[i]][py[i]][0]!=i||bel[px[i]][py[i]][1]!=i)){\n\t\t\tputs(\"diff\");\n\t\t\tcontinue;\n\t\t}\n\t\tputs(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e3 + 5, M = 2e5 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nvector <int> v[N];\nstruct edge {int x, y;} e[M];\nint n, m, vis[N], tag[N], g1[N][N], g2[N][N];\nvoid dfs(int x, int rt) {\n\tg1[rt][x] = 1; vis[x] = 1;\n\tfor(int i = 0; i < v[x].size(); ++ i) if(! vis[v[x][i]]) dfs(v[x][i], rt);\n}\nvoid dfs(int x, int col, int type, int rt) {\n\tvis[x] = 1;\n\tif(! type) tag[x] = col;\n\telse g2[rt][x] = tag[x] != col;\n\tfor(int i = 0; i < v[x].size(); ++ i) if(! vis[v[x][i]]) dfs(v[x][i], col, type, rt);\n}\nsigned main() {\n\tn = read(); m = read();\n\tfor(int i = 1, x, y; i <= m; ++ i) {\n\t\tx = read(); y = read();\n\t\tv[x].push_back(y);\n\t\te[i] = (edge){x, y};\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) vis[j] = 0;\n\t\tdfs(i, i);\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 1; j <= n; ++ j) tag[j] = vis[j] = 0; vis[i] = 1;\n\t\tfor(int j = 0; j < v[i].size(); ++ j) if(! vis[v[i][j]]) dfs(v[i][j], j + 1, 0, i);\n\t\tfor(int j = 1; j <= n; ++ j) vis[j] = 0; vis[i] = 1;\n\t\tfor(int j = v[i].size() - 1; j >= 0; -- j) if(! vis[v[i][j]]) dfs(v[i][j], j + 1, 1, i);\n\t}\n\tfor(int i = 1; i <= m; ++ i) puts(g1[e[i].y][e[i].x] ^ g2[e[i].x][e[i].y] ? \"diff\" : \"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define sz(a) (int)(a).size()\n#define rep(i, a, b) for (int i = (a), _b = (b); i < _b; ++i)\n#define frep(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<ii> vii;\n\nconst int inf = 1e9 + 7;\nconst ll linf  = 1ll * inf * inf;\nconst int N = 1000 + 7;\nconst int M = 20;\nconst int multipleTest = 0;\n\nint ways[N][N];\nint n, m;\n\nvii edge;\n\nclass StrComp {\npublic:\n\tint num[N], low[N];\n\tint cs[N];\n\tvector<int> adj[N];\n\t int cnt = 0;\n\t int comps = 0;\n\tbitset<N> go[N];\n\tvector<int> rev[N];\n\tint tIn[N];\n\tset<int> nxt;\n\t\n\tint dp[N];\n\t\n\tvoid init(int r) {\n\t\trep(i, 1, n + 1) {\n\t\t\tnum[i] = low[i] = cs[i] = 0;\n\t\t\tadj[i].clear();\n\t\t\tgo[i].reset();\n\t\t\trev[i].clear();\n\t\t\ttIn[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tcnt = comps = 0;\n\t\t nxt.clear();\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tadj[e.first].push_back(e.second);\n\t\t\t} else if (e.first == r) {\n\t\t\t\tnxt.insert(e.second);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (!num[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t\tif (!r || nxt.size() <= 1) return;\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tif (cs[e.first] != cs[e.second]) {\n\t\t\t\t\tint u = cs[e.first], v = cs[e.second];\n\t\t\t\t\tif (!go[u][v]) {\n\t\t\t\t\t\tgo[u].set(v);\n\t\t\t\t\t\trev[u].push_back(v);\n\t\t\t\t\t\t++tIn[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) dp[cs[v]]++;\n\t\t\n\t\tstatic int q[N], bot, top;\n\t\tbot = top = 0;\n\t\tfor (int i = 1; i <= comps; ++i) if (!tIn[i]) q[top++] = i;\n\t\t\n\t\twhile (bot < top) {\n\t\t\tint u = q[bot++];\n\t\t\tfor (int v : rev[u]) {\n\t\t\t\ttIn[v]--;\n\t\t\t\tdp[v] += dp[u];\n\t\t\t\tif (!tIn[v]) {\n\t\t\t\t\tq[top++] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) if (dp[cs[v]] > 1) ways[r][v] = true;\n\t}\n\t\n\tvoid dfs(int u) {\n\t\tstatic stack<int> stk;\n\t\tlow[u] = num[u] = ++cnt;\n\t\tstk.push(u);\n\t\tfor (int v : adj[u]) {\n\t\t\tif (cs[v]) continue;\n\t\t\tif (!num[v]) {\n\t\t\t\tdfs(v);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], num[v]);\n\t\t\t}\n\t\t}\n\t\tif (low[u] == num[u]) {\n\t\t\tcs[u] = ++comps;\n\t\t\twhile (stk.top() != u) {\n\t\t\t\tcs[stk.top()] = comps;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\tassert(!stk.empty() && stk.top() == u);\n\t\t\tstk.pop();\n\t\t}\n\t}\n} st;\n\nbool can[N][N];\nint root;\nvector<int> adj[N];\n\nvoid dfs(int u) {\n\tcan[root][u] = true;\n\tfor (int v : adj[u]) {\n\t\tif (can[root][v]) continue;\n\t\tdfs(v);\n\t}\n}\n\n\nvoid solve() {\n\tcin >> n >> m;\n\tmemset(ways, 0, sizeof(ways));\n\trep(i, 0, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tedge.push_back({u, v});\n\t\tadj[u].push_back(v);\n\t}\n\tfor (int i = 1; i <= n; ++i) st.init(i);\n\tfor (int i = 1; i <= n; ++i) {\n\t\troot = i;\n\t\tdfs(i);\n\t}\n\tfor (ii e : edge) {\n\t\tint u = e.first;\n\t\tint v = e.second;\n\t\tif (can[v][u]) {\n\t\t\tif (ways[u][v]) puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t} else {\n\t\t\tif (ways[u][v]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint Test = 1;\n\tif (multipleTest) {\n\t\tcin >> Test;\n\t}\n\tfor(int i = 0; i < Test; ++i) {\n\t\t//        printf(\"Case #%d: \", i + 1);\n\t\tsolve();\n\t}\n#ifdef _LOCAL_\n\tcout << \"\\n\" << 1.0 * clock() / CLOCKS_PER_SEC << \"\\n\";\n#endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N = 1005, M = 200005;\n\nint n, m, sc, cc, non, wh[N], col[N];\nbool vis[N], ans[M], shu[N], can[N];\npii e[M];\n\nvector<int> adj[N], rev[N], out[N], st;\n\nvoid tdfs (int I) {\n\tif(vis[I]) return;\n\tvis[I] = true;\n\tfor(auto &T : adj[I]) if(T != non) tdfs(T);\n\tst.push_back(I);\n}\n\nvoid rdfs (int I) {\n\tif(vis[I]) return;\n\twh[I] = sc;\n\tvis[I] = true;\n\tfor(auto &T : rev[I]) if(T != non) rdfs(T);\n}\n\nvoid toposort (int I) {\n\tnon = I; sc = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vis[i]) tdfs(i);\n\t}\n\tfill(vis+1, vis+1+n, 0);\n\twhile(!st.empty()) {\n\t\tint T; T = st.back(); st.pop_back();\n\t\tif(!vis[T]) {rdfs(T); sc++;}\n\t}\n\tfill(vis+1, vis+1+n, 0);\n}\n\nvoid cdfs (int I) {\n\tcol[I] = cc;\n\tvis[I] = true;\n\tif(shu[I] && I != st[cc]) {\n\t\tcan[I] = true;\n\t\tif(wh[I] == wh[st[cc]]) can[st[cc]] = true;\n\t}\n\tfor(auto &T : adj[I]) {\n\t\tif(T == non) continue;\n\t\tif(vis[T]) {\n\t\t\tif(col[I] == col[T]) continue;\n\t\t\tif(wh[T] == wh[st[col[T]]]) can[st[col[T]]] = true;\n\t\t}\n\t\telse cdfs(T);\n\t}\n}\n\nvoid solve (int I) {\n\ttoposort(I);\n\tfor(auto &T : adj[I]) shu[T] = true;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T]) continue;\n\t\tst.push_back(T);\n\t\tcdfs(T); cc++;\n\t}\n\tfor(auto &T : out[I]) {\n\t\tans[T] = can[e[T].Y];\n\t}\n\tcc = 0;\n\tfill(vis+1, vis+1+n, 0);\n\tfill(shu+1, shu+1+n, 0);\n\tfill(can+1, can+1+n, 0);\n\tst.clear();\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\te[i] = {A, B};\n\t\tout[A].push_back(i);\n\t\tadj[A].push_back(B);\n\t\trev[B].push_back(A);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!out[i].empty()) solve(i);\n\t}\n\ttoposort(0);\n\tfor(int i=1;i<=m;i++) {\n\t\tputs(ans[i] ^ (wh[e[i].X] == wh[e[i].Y]) ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint n;\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        starred[u] = true;\n    }\n    for (int u : bll[removed]) {\n        find_stars(removed, u);\n    }\n    for (int i=1; i<=n; ++i) {\n        find_stars(removed, i);\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        int t = find_stars(u.second, u.first);\n        if (unf[u.first] == unf[u.second]) {\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else puts(t == -1  || t == u.first ? \"same\" : \"diff\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N = 1005, M = 200005;\n\nint n, m, sc, cc, non, wh[N], col[N];\nbool vis[N], ans[M], shu[N], can[N];\npii e[M];\n\nvector<int> adj[N], rev[N], out[N], st;\n\nvoid tdfs (int I) {\n\tif(vis[I]) return;\n\tvis[I] = true;\n\tfor(auto &T : adj[I]) if(T != non) tdfs(T);\n\tst.push_back(I);\n}\n\nvoid rdfs (int I) {\n\tif(vis[I]) return;\n\twh[I] = sc;\n\tvis[I] = true;\n\tfor(auto &T : rev[I]) if(T != non) rdfs(T);\n}\n\nvoid toposort (int I) {\n\tnon = I; sc = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vis[i]) tdfs(i);\n\t}\n\tfill(vis+1, vis+1+n, 0);\n\twhile(!st.empty()) {\n\t\tint T; T = st.back(); st.pop_back();\n\t\tif(!vis[T]) {rdfs(T); sc++;}\n\t}\n\tfill(vis+1, vis+1+n, 0);\n}\n\nvoid cdfs (int I) {\n\tcol[I] = cc;\n\tvis[I] = true;\n\tif(shu[I] && I != st[cc]) {\n\t\tcan[I] = true;\n\t\tif(wh[I] == wh[st[cc]]) can[st[cc]] = true;\n\t}\n\tfor(auto &T : adj[I]) {\n\t\tif(T == non)  continue;\n\t\tif(vis[T]) {\n\t\t\tif(col[I] == col[T]) continue;\n\t\t\tif(wh[T] == wh[st[col[T]]]) can[st[col[T]]] = true;\n\t\t}\n\t\telse cdfs(T);\n\t}\n}\n\nvoid solve (int I) {\n\ttoposort(I);\n\tfor(auto &T : adj[I]) shu[T] = true;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T]) continue;\n\t\tst.push_back(T);\n\t\tcdfs(T); cc++;\n\t}\n\tfor(auto &T : out[I]) {\n\t\tans[T] = can[e[T].Y];\n\t}\n\tcc = 0;\n\tfill(vis+1, vis+1+n, 0);\n\tfill(shu+1, shu+1+n, 0);\n\tfill(can+1, can+1+n, 0);\n\tst.clear();\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\te[i] = {A, B};\n\t\tout[A].push_back(i);\n\t\tadj[A].push_back(B);\n\t\trev[B].push_back(A);\n\t}\n\tfor(int i=1;i<=n;i++) solve(i);\n\ttoposort(0);\n\tfor(int i=1;i<=m;i++) {\n\t\tputs(ans[i] ^ (wh[e[i].X] == wh[e[i].Y]) ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 1024;\nint N,M;\nvector<int> V[MC];\nvector<P2> E;\nbool visited[MC];\n\nbool solve(P2 p , int q , int t){\n\tif(q == t) return 1;\n\tvisited[q] = 1;\n\tfor(auto u : V[q]){\n\t\tif(p.first == q && p.second == u || visited[u]) continue;\n\t\tif(solve(p,u,t)) return 1;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin >> N >> M;\n\trepp(i,0,M){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tV[a].PB(b);\n\t\tE.PB(MP(a,b));\n\t}\n\tfor(auto u : E){\n\t\tfill(visited,visited+MC,0);\n\t\tbool b = solve(u,u.second,u.first);\n\t\tfill(visited,visited+MC,0);\n\t\tb ^= solve(u,u.first,u.second);\n\t\tcout << (b?\"diff\":\"same\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1010;\nint n,m,ind,cnt,top;\nint vis[N],que[N],stk[N],bl[N],dfn[N],low[N],u[N*200],v[N*200];\nbool ok[N*200],ins[N];\nvector<int> ve[N],id[N];\ninline void tarjan(int x){\n\tstk[++top]=x; ins[x]=1; dfn[x]=low[x]=++ind;\n\tfor(auto to:ve[x])\n\t\tif(!dfn[to]) tarjan(to),low[x]=min(low[x],low[to]);\n\t\telse if(ins[to]) low[x]=min(low[x],dfn[to]);\n\tif(low[x]==dfn[x]){\n\t\tint y; ++cnt;\n\t\tdo y=stk[top--],ins[y]=0,bl[y]=cnt;\n\t\twhile(y!=x);\n\t}\n}\ninline void solve(int rt){\n\tint head=1,tail=0; vis[rt]=++ind;\n\tfor(int i=0;i<ve[rt].size();++i){\n\t\tok[id[rt][i]]|=vis[ve[rt][i]]==ind;\n\t\tif(vis[ve[rt][i]]!=ind) vis[ve[rt][i]]=ind,que[++tail]=ve[rt][i];\n\t\twhile(head<=tail){\n\t\t\tint x=que[head++];\n\t\t\tfor(auto to:ve[x]) if(vis[to]!=ind) vis[to]=ind,que[++tail]=to;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,a,b;i<=m;++i) scanf(\"%d%d\",&a,&b),ve[a].push_back(b),id[a].push_back(i),u[i]=a,v[i]=b;\n\tfor(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);\n\tfor(int i=1;i<=n;++i) solve(i),reverse(ve[i].begin(),ve[i].end()),reverse(id[i].begin(),id[i].end()),solve(i);\n\tfor(int i=1;i<=m;++i){\n\t\tif(bl[u[i]]==bl[v[i]]) puts(ok[i]?\"same\":\"diff\");\n\t\telse puts(ok[i]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010, M = 200010;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\n\nint n, m, fr[M], to[M], nxt[M], tt, s, t, id[N], h[N];\nbool vis[N][N], can[M];\nvector<int> E[N];\n\nvoid addedge (int u,int v) {\n\tfr[++tt] = u, to[tt] = v;\n\tnxt[tt] = h[u], h[u] = tt;\n\tE[u].push_back(v);\n}\n\nvoid dfs (int u) {\n\tvis[s][u] = true;\n\tif (id[u]) return;\n\tid[u] = t;\n\tfor (auto v : E[u]) {\n\t\tif(!id[v] && v != s) dfs(v);\n\t}\n}\n\nint main () {\n\tcin >> n >> m;\n\tfor(int i = 1, u, v; i <= m; i++) read(u), read(v), addedge(u,v);\n\t\n\tfor(s = 1; s <= n; s++) {\n\t\tmemset(id, 0, sizeof(id));\n\t\tvector<int> son;\n\n\t\tfor(int i = h[s], v; v = to[i], i; i=nxt[i]) son.push_back(v), dfs(t = v);\n\t\treverse(son.begin(),son.end());\n\t\tfor(int i = h[s], v; v = to[i], i; i=nxt[i]) {\n\t\t\tif(id[v] != v) can[i] = 1;\n\t\t}\n\n\t\tmemset(id, 0, sizeof(id));\n\t\tfor(auto v : son) dfs(t = v);\n\t\tfor(int i = h[s], v; v = to[i], i; i = nxt[i]) {\n\t\t\tif(id[v] != v) can[i] = 1;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= m; i++) {\n\t\tint u = fr[i], v = to[i];\n\t\tif(can[i] == vis[v][u]) cout << \"same\\n\";\n\t\telse cout << \"diff\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m;cin>>n>>m;\n\tvc<pi> es;\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tes.eb(a,b);\n\t\tg[a].pb(b);\n\t}\n\t\n\tvvc<int> w1(n,vi(n));\n\tvvc<int> w2(n,vi(n));\n\trep(i,n){\n\t\tvc<array<int,2>> vis(n,{-1,-1});\n\t\tvis[i][0]=-2;\n\t\tvis[i][1]=-2;\n\t\tvc<pi> x;\n\t\tauto r=[&](int v,int f){\n\t\t\tif(vis[v][0]==f)return;\n\t\t\trep(k,2)if(vis[v][k]==-1){\n\t\t\t\tvis[v][k]=f;\n\t\t\t\tx.eb(v,f);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tint tmp=0;\n\t\tfor(auto j:g[i]){\n\t\t\tr(j,tmp++);\n\t\t}\n\t\twhile(x.size()){\n\t\t\tint v,f;tie(v,f)=x.back();x.pop_back();\n\t\t\tfor(auto j:g[v])r(j,f);\n\t\t}\n\t\trep(j,n)w1[i][j]=vis[j][1]!=-1;\n\t\trep(j,n)w2[i][j]=vis[j][0]!=-1;\n\t}\n\tdmp(w1);\n\tdmp(w2);\n\tfor(auto e:es){\n\t\tint x=w1[e.a][e.b];\n\t\tint y=w2[e.b][e.a];\n\t\tif(x!=y)cout<<\"diff\\n\";\n\t\telse cout<<\"same\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace SCC {\n\tconst int N = 110000;\n\tvector<int> con[N], rcon[N];\n\tint n, vis[N], visT;\n\tint id[N], idn;\n\tvoid init(int nn = 0) {\n\t\tn = nn, visT = idn = 0;\n\t\tfor (int i = 1; i <= n; i++) con[i].clear(), rcon[i].clear();\n\t}\n\tvoid add_edge(int u, int v) {\n\t\tcon[u].push_back(v);\n\t\trcon[v].push_back(u);\n\t}\n\tvoid dfs(int u) {\n\t\tvis[u] = 1;\n\t\tfor (int v : con[u]) if (!vis[v]) dfs(v);\n\t\tid[idn++] = u;\n\t}\n\tvoid rdfs(int u) {\n\t\tvis[u] = visT;\n\t\tfor (int v : rcon[u]) if (!vis[v]) rdfs(v);\n\t}\n\tvoid SCC() {\n\t\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\t\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n\t\tfor (int i = idn - 1; i >= 0; i--) if (!vis[id[i]]) visT++, rdfs(id[i]);\n\t}\n};\n\nconst int N = 1100;\nconst int M = 220000;\n\nvector<int> con[N];\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u = 0, int v = 0) : u(u), v(v) {}\n} E[M];\n\nint adj[N][N];\nint vis[N], visT;\nint son[2][N][N];\n\ninline bool Find(int u, int tar) {\n\tif (adj[u][tar] > 1) return true;\n\treturn son[0][u][tar] != tar || son[1][u][tar] != tar;\n}\n\nvoid dfs(int u, int id, int rt, int __rt) {\n\tvis[u] = visT;\n\tson[id][__rt][u] = rt;\n\tfor (int v : con[u]) if (vis[v] != visT) dfs(v, id, rt, __rt);\n}\n\nvoid init(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tvisT++;\n\t\tvis[i] = visT;\n\t\tfor (int v : con[i]) if (vis[v] != visT) dfs(v, 0, v, i);\n\t\treverse(con[i].begin(), con[i].end());\n\t\tvisT++;\n\t\tvis[i] = visT;\n\t\tfor (int v : con[i]) if (vis[v] != visT) dfs(v, 1, v, i);\n\t}\n}\n\nint main() {\n\t\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint n, m; cin >> n >> m;\n\tSCC::init(n + 10);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tE[i] = Edge(u, v);\n\t\tcon[u].push_back(v);\n\t\tadj[u][v]++;\n\t\tSCC::add_edge(u, v);\n\t}\n\tSCC::SCC();\n\t\n\tinit(n);\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tauto a = SCC::vis[E[i].u], b = SCC::vis[E[i].v];\n\t\tif (a == b) {\n\t\t\tif (Find(E[i].u, E[i].v)) cout << \"same\\n\";\n\t\t\telse cout << \"diff\\n\";\n\t\t} else {\n\t\t\tif (Find(E[i].u, E[i].v)) cout << \"diff\\n\";\n\t\t\telse cout << \"same\\n\";\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nint n, m;\nvector<pair<int, int> > e[MAXN];\nvector<int> adj[MAXN];\nvector<int> radj[MAXN];\n\nint ans[MAXM];\n\nint q[MAXN], qhead, qtail;\nint mn[MAXN], mx[MAXN]; bool reach[MAXN];\n\nvoid solve() {\n\tREP(i, m) ans[i] = -1;\n\tREP(i, n) {\n\t\tREP(j, n) mn[j] = INT_MAX; mn[i] = -1; qhead = qtail = 0;\n\t\tREPSZ(j, e[i]) {\n\t\t\tint rt = e[i][j].first; if (mn[rt] != INT_MAX) continue;\n\t\t\tq[qhead++] = rt; mn[rt] = j;\n\t\t\twhile (qtail < qhead) { int at = q[qtail++]; REPSZ(i, adj[at]) { int to = adj[at][i]; if (mn[to] == INT_MAX) mn[to] = j, q[qhead++] = to; } }\n\t\t}\n\t\tREP(j, n) mx[j] = INT_MIN; mx[i] = -1; qhead = qtail = 0;\n\t\tfor (int j = SZ(e[i]) - 1; j >= 0; --j) {\n\t\t\tint rt = e[i][j].first; if (mx[rt] != INT_MIN) continue;\n\t\t\tq[qhead++] = rt; mx[rt] = j;\n\t\t\twhile (qtail < qhead) { int at = q[qtail++]; REPSZ(i,adj[at]) { int to = adj[at][i]; if (mx[to] == INT_MIN) mx[to] = j, q[qhead++] = to; } }\n\t\t}\n\t\tREP(j, n) reach[j] = false; qhead = qtail = 0;\n\t\tq[qhead++] = i; reach[i] = true;\n\t\twhile (qtail < qhead) { int at = q[qtail++]; REPSZ(i,radj[at]) { int to = radj[at][i]; if (!reach[to]) reach[to] = true, q[qhead++] = to; } }\n\t\tREPSZ(j, e[i]) {\n\t\t\tint x = e[i][j].second, to = e[i][j].first;\n\t\t\tbool ab = mn[to] != mx[to], ba = reach[to];\n\t\t\t//printf(\"%d->%d: ab=%d ba=%d\\n\", i + 1, to + 1, ab ? 1 : 0, ba ? 1 : 0);\n\t\t\tans[x] = ab == ba ? 0 : 1;\n\t\t}\n\t}\n}\n\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &m);\n\tREP(i, n) e[i].clear(), adj[i].clear(), radj[i].clear();\n\tREP(i, m) { \n\t\tint a, b; scanf(\"%d%d\", &a, &b); --a, --b;\n\t\te[a].PB(MP(b, i)); adj[a].PB(b); radj[b].PB(a);\n\t}\n\n\tsolve();\n\n\tREP(i, m) printf(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}\n\nvoid stress() {\n\tprintf(\"start\\n\"); fflush(stdout);\n\tREP(rep, 100) {\n\t\tn = MAXN, m = MAXM; REP(i, n) e[i].clear(), adj[i].clear(), radj[i].clear();\n\t\tset<pair<int, int> > seen;\n\t\tREP(i, m) while (true) {\n\t\t\tint a = rand() % n, b = rand() % n; if (a == b || seen.count(MP(a, b))) continue;  \n\t\t\te[a].PB(MP(b, i)); adj[a].PB(b); radj[b].PB(a);\n\t\t\tbreak; \n\t\t}\n\t\tsolve();\n\t\tprintf(\".\");\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n\ntypedef pair<int, int> P;\n\n#define fir first\n#define sec second\n\nvector<P> G[N];\n\nbool vis[N]; int ct[N][N], wkr[N];\n\nint rt, n, col; \n\nvoid dfs(int u, int type) {\n    if (!type) wkr[u] = col;\n    else if (wkr[u] != col) ct[rt][u] |= 1;\n    vis[u] = 1;\n    for (auto v : G[u]) if (!vis[v.sec]) dfs(v.sec, type);\n}\n\ninline void clr() {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\ninline void solve(int u) {\n    rt = u, clr(), vis[u] = 1;\n    for (auto v : G[u]) if (!vis[v.sec]) dfs(col = v.sec, 0);\n    clr(), vis[u] = 1;\n    for (int i = (int)G[u].size() - 1; i >= 0; i--) if (!vis[G[u][i].sec]) dfs(col = G[u][i].sec, 1);\n    for (int i = 1; i <= n; i++) if (vis[i]) ct[i][u] |= 2;\n}\n\nint ans[N * 200];\n\nint main() {\n    int m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(P(i, b));\n    for (int i = 1; i <= n; i++) solve(i);\n    for (int i = 1; i <= n; i++) for (auto v : G[i]) \n        if (ct[i][v.sec] != 0 && ct[i][v.sec] != 3) ans[v.fir] = 1;\n    for (int i = 1; i <= m; i++) puts(ans[i] ? \"diff\" : \"same\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n//INSERT ABOVE HERE\nInt dp[2][1010][1010];\nInt pv[1010][1010];\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++) cin>>a[i]>>b[i],a[i]--,b[i]--;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++) G[a[i]].emplace_back(b[i]);\n\n  memset(dp,0,sizeof(dp));\n  memset(pv,-1,sizeof(pv));\n  \n  using T = tuple<Int, Int, Int>;\n  queue<T> q;\n  for(Int i=0;i<m;i++){\n    pv[a[i]][b[i]]=i;\n    dp[0][a[i]][b[i]]=1;\n    q.emplace(0,a[i],b[i]);\n  }\n  while(!q.empty()){\n    Int t,x,y;\n    tie(t,x,y)=q.front();q.pop();\n    //cout<<t<<\":\"<<x<<\":\"<<y<<\"::\"<<pv[x][y]<<endl;\n    for(Int z:G[y]){\n      if(x==z) continue;\n      Int nt=t||(~pv[x][z]&&pv[x][y]!=pv[x][z]);\n      if(dp[nt][x][z]) continue;\n      if(pv[x][z]<0) pv[x][z]=pv[x][y];\n      dp[nt][x][z]=1;\n      q.emplace(nt,x,z);\n    }    \n  }\n\n  for(Int i=0;i<m;i++){\n    Int s=dp[1][a[i]][b[i]];\n    Int t=dp[0][b[i]][a[i]]|dp[1][b[i]][a[i]];\n    //cout<<s<<\" \"<<t<<endl;\n    cout<<(s^t?\"diff\":\"same\")<<endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e3+5;\nconst int M=2e5+5;\n\nint n,m,A[M],B[M],vis[N],tag[N],flag[2][N][N];\nvector <int> G[N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nvoid dfs(int u,int rt) {\n\tif(vis[u]) return;\n\tflag[0][rt][u]=vis[u]=true;\n\tfor(auto v:G[u]) dfs(v,rt);\n}\nvoid dfs(int u,int rt,int id,int now) {\n\tif(vis[u]) return;\n\tvis[u]=true;\n\tif(!now) tag[u]=id;\n\telse flag[1][rt][u]=(bool)(tag[u]!=id);\n\tfor(auto v:G[u]) dfs(v,rt,id,now);\n}\n\nint main() {\n\tIN(n),IN(m);\n\tfor(int i=1;i<=m;++i)\n\t\tIN(A[i]),IN(B[i]),G[A[i]].push_back(B[i]);\n\tfor(int u=1;u<=n;++u) memset(vis,0,sizeof(vis)),dfs(u,u);\n\tfor(int u=1;u<=n;++u) {\n\t\tmemset(tag,0,sizeof(tag));\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=0;i<=(int)G[u].size()-1;++i) dfs(G[u][i],u,i,0);\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=(int)G[u].size()-1;i>=0;--i) dfs(G[u][i],u,i,1);\n\t}\n\tfor(int i=1;i<=m;++i)\n\t\tputs(flag[0][B[i]][A[i]]^flag[1][A[i]][B[i]]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*==============================\n * Authot : ylsoi\n * Time : 2018.3.20\n * Problem : ARC92F\n * File : ARC92F.cpp\n * Algorithm : Strange Algorithm\n * ===========================*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid File(){\n\tfreopen(\"ARC92F.in\",\"r\",stdin);\n\tfreopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define MREP(i,x) for(register int i=beg[x];i;i=E[i].last)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nint n,m,beg[maxn],len;\nbool can[maxn][maxn],can1[maxn][maxn],vis[maxn];\nstruct edge{\n\tint from;\n\tint to;\n\tint last;\n}E[maxm];\nvoid add(int u,int v){\n\t++len;\n\tE[len].from=u;\n\tE[len].to=v;\n\tE[len].last=beg[u];\n\tbeg[u]=len;\n}\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tMREP(i,u){\n\t\tint v=E[i].to;\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nbool flag;\nvoid dfs1(int u,int e,int rt){\n\tvis[u]=1;\n\tMREP(i,u){\n\t\tif(flag)return;\n\t\tint v=E[i].to;\n\t\tif(i==e)continue;\n\t\tif(v==E[e].to){\n\t\t\tcan1[rt][v]=1;\n\t\t\tflag=1;\n\t\t}\n\t\tif(vis[v])continue;\n\t\tdfs1(v,e,rt);\n\t}\n}\nint main(){\n\t//File();\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t}\n\tREP(i,1,n){\n\t\tdfs(i,i);\n\t\tmem(vis);\n\t}\n\tREP(i,1,m){\n\t\t//dfs1(E[i].from,i,E[i].from);\n\t\tmem(vis);\n\t\tflag=0;\n\t}\n\tREP(i,1,m){\n\t\tint u=E[i].from,v=E[i].to;\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tputs(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nvector<vector<vector<int>>> reachable(auto G) {\n  vector<vector<vector<int>>> ok(2, vector<vector<int>>(G.size(), vector<int>(G.size(), -1)));\n\n  auto bfs = [&](auto root) {\n    queue<int> q;\n    vector<bool> used(G.size());\n    used[root] = true;\n    for(auto i=0; i<G[root].size(); ++i) {\n      auto v = G[root][i];\n      ok[0][root][v] = ok[1][root][v] = i;\n      q.emplace(v);\n      used[v] = true;\n    }\n    while(!q.empty()) {\n      auto u = q.front();\n      q.pop();\n      for(auto v: G[u]) {\n        if(ok[0][root][v] == -1) ok[0][root][v] = ok[0][root][u];\n        ok[0][root][v] = min(ok[0][root][v], ok[0][root][u]);\n        ok[1][root][v] = max(ok[1][root][v], ok[1][root][u]);\n        if(used[v]) continue;\n        q.emplace(v);\n        used[v] = true;\n      }\n    }\n  };\n\n  for(auto root=0; root<G.size(); ++root) bfs(root);\n  return ok;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  vector<int> a(M), b(M);\n  for(auto i=0; i<M; ++i) {\n    cin >> a[i] >> b[i];\n    --a[i]; --b[i];\n    G[a[i]].push_back(b[i]);\n  }\n\n  auto ok = reachable(G);\n\n  for(auto i=0; i<M; ++i) {\n    auto u = a[i], v = b[i];\n    auto ab = ok[0][u][v]!=ok[1][u][v];\n    auto ba = ok[0][v][u]!=-1;\n    if(ab==ba) cout << \"same\" << endl;\n    else       cout << \"diff\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[2][N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(vis[0][rt][v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tdfs_vis(i,i);\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid,LL rt){\n\tp[pid][u] = col;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(p[pid][v]) continue;\n\t\tdfs_sol(v,col,pid,rt);\n\t}\n}\n\nvoid solve(LL u){\n\tmemset(p,0,sizeof(p)); p[0][u] = 1; p[1][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!p[0][G[u][i]]) dfs_sol(G[u][i],i + 1,0,u);\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!p[1][G[u][i]]) dfs_sol(G[u][i],i + 1,1,u);\n\tfor(LL i = 1;i <= n;i ++) if(p[0][i] != p[1][i]) vis[1][u][i] = 1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(ev[i]);\n\t}\n\tget_vis();\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<ctime>\nusing namespace std;\n#define N 1050\n#define M 200500\nint head[N],cnt,scc[N],dfn[N],low[N],f[N][13],s[M][2],as[M],vl[N],ct,ct2,vis[N][N],id[N],ct1,dep[N],is[N],n,m,ct3;\nstruct edge{int t,next,id;}ed[M];\nvoid adde(int f,int t,int id){ed[++cnt]=(edge){t,head[f],id};head[f]=cnt;}\nstack<int> tp,tp2,v[N],tp3;\nvoid dfs1(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\ttp.push(u);\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs1(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])\n\t{\n\t\tint s=tp.top(),id=++ct2;tp.pop();\n\t\tscc[s]=id;\n\t\twhile(s!=u)\n\t\ts=tp.top(),tp.pop(),scc[s]=id;\n\t}\n}\nvoid dfs2(int u,int s){for(int i=head[u];i;i=ed[i].next)if(!vis[s][ed[i].t])vis[s][ed[i].t]=1,dfs2(ed[i].t,s);else vis[s][ed[i].t]++;}\nint LCA(int x,int y){if(dep[x]<dep[y])x^=y^=x^=y;for(int i=10;i>=0;i--)if(dep[x]-dep[y]>=(1<<i))x=f[x][i];if(x==y)return x;for(int i=10;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];return f[x][0];}\nvoid dfs3(int u,int fa)\n{\n\tdfn[u]=1;dep[u]=dep[fa]+1;f[u][0]=fa;vl[u]=0;for(int i=1;i<=10;i++)f[u][i]=f[f[u][i-1]][i-1];\n\tfor(int i=head[u];i;i=ed[i].next)\n\tif(!dfn[ed[i].t])tp.push(ed[i].id),dfs3(ed[i].t,u),vl[u]+=vl[ed[i].t];\n\telse{int s=LCA(u,ed[i].t);vl[u]++;vl[s]--;tp2.push(ed[i].id);}\n}\nvoid dfs4(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs4(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])ct2++;\n}\nbool check(int x)\n{\n\tfor(int i=1;i<=n;i++)dfn[i]=scc[i]=head[i]=0;\n\tcnt=0;ct2=0;\n\tfor(int i=1;i<=m;i++)if(i!=x)adde(s[i][0],s[i][1],-1);else adde(s[i][1],s[i][0],-2);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs4(i);\n\treturn ct2!=ct3;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&s[i][0],&s[i][1]),adde(s[i][0],s[i][1],1);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);ct3=ct2;\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])adde(scc[s[i][0]],scc[s[i][1]],-3);\n\tfor(int i=1;i<=ct2;i++)dfs2(i,i);\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])as[i]=vis[scc[s[i][0]]][scc[s[i][1]]]>1;else v[scc[s[i][0]]].push(i);\n\tfor(int i=1;i<=ct2;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)dfn[j]=0,head[j]=0;\n\t\tct1=0;cnt=0;\n\t\tfor(int j=1;j<=n;j++)if(scc[j]==i)id[j]=++ct1;\n\t\twhile(!v[i].empty())\n\t\t{\n\t\t\tint q=v[i].top();v[i].pop();\n\t\t\tadde(id[s[q][0]],id[s[q][1]],q);\n\t\t}\n\t\tdfs3(1,0);\n\t\twhile(!tp2.empty())\n\t\t{\n\t\t\tint st=tp2.top();tp2.pop();\n\t\t\tint l=id[s[st][0]],r=id[s[st][1]];\n\t\t\tr=LCA(l,r);\n\t\t\tint fg=0;\n\t\t\twhile(l!=r)fg|=(vl[l]==1),l=f[l][0];\n\t\t\tas[st]=fg;\n\t\t}\n\t}\n\twhile(!tp.empty()){int st=tp.top();tp.pop();as[st]=check(st);}\n\tfor(int i=1;i<=m;i++)printf(\"%s\\n\",as[i]?\"diff\":\"same\");\n}///"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <vector>\n#define PB push_back\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1010,M=1003;\nbitset<M> G[N],A[N],B;\nint n,m;\nint vis[N][2];\nvoid push(int u,int t) {\n\tif(!vis[u][0]) vis[u][0]=t;\n\telse if(!vis[u][1]&&vis[u][0]!=t) vis[u][1]=t,B[u]=0;\n\telse return;\n\tA[t][u]=0;\n}\nvoid dfs(int u) {\n//\tcout<<u<<' ';\n\twhile(1) {\n\t\tint v=((A[vis[u][0]]|A[vis[u][1]])&G[u]&B)._Find_first();\n\t\tif(v==M) break;\n\t\tpush(v,vis[u][0]),push(v,vis[u][1]),dfs(v);\n\t}\n}\nint mp[N][N],p1[N][N],p2[N][N];\nvoid sol(int s) {\n//\tcout<<\"Solve\"<<s<<':';\n\tB[s]=0;\n\tfor(int i=1;i<=n;++i) if(mp[s][i]) push(i,i);\n\tfor(int i=1;i<=n;++i) if(mp[s][i]) dfs(i);\n//\tcout<<endl;\n\tfor(int i=1;i<=n;++i) if(s!=i) {\n\t\tp1[s][i]=vis[i][0]||vis[i][1]||mp[s][i];\n\t\tp2[s][i]=(vis[i][0]&&vis[i][0]!=i)||(vis[i][1]&&vis[i][1]!=i);\n\t}\n//\tfor(int i=1;i<=n;++i) printf(\"(%d,%d) \",vis[i][0],vis[i][1]); puts(\"\");\n\tfor(int i=1;i<=n;++i) A[vis[i][0]][i]=A[vis[i][1]][i]=1,vis[i][0]=vis[i][1]=0,B[i]=1;\n}\nvector<PII> E;\nint main() {\n\trd(n),rd(m);\n\tfor(int i=1,x,y;i<=m;++i) rd(x),rd(y),G[x][y]=mp[x][y]=1,E.PB(MP(x,y));\n\tfor(int i=0;i<=n;++i) for(int j=1;j<=n;++j) A[i][j]=1;\n\tfor(int i=1;i<=n;++i) B[i]=1;\n\tfor(int i=1;i<=n;++i) sol(i);\n//\tcout<<\"Check:\"<<p1[1][4]<<' '<<p2[4][1]<<endl;\n\tfor(int i=0;i<E.size();++i) { \n\t\tint x=E[i].fir,y=E[i].sec,flg;\n\t\tif(p1[y][x]) flg=(p2[x][y]==1);\n\t\telse flg=(p2[x][y]==0);\n\t\tif(flg) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=1005,M=200005;\nint n,m;\nvector <int> o[N];\nint Map[N][N];\nstruct Edge{\n\tint x,y,res;\n}e[M];\nint cnt[N],vis[N],Tg=0;\nvoid dfs(int x){\n\tcnt[x]++;\n\tvis[x]=Tg;\n\tfor (auto i : o[x])\n\t\tif (vis[e[i].y]!=Tg&&cnt[e[i].y]<2)\n\t\t\tdfs(e[i].y);\n}\nint main(){\n\tn=read(),m=read();\n\tFor(i,1,m){\n\t\te[i].x=read(),e[i].y=read();\n\t\to[e[i].x].pb(i);\n\t\tMap[e[i].x][e[i].y]=i;\n\t}\n\tFor(i,1,n){\n\t\tclr(cnt);\n\t\tcnt[i]=2;\n\t\tfor (auto j : o[i]){\n\t\t\tTg=j;\n\t\t\tif (cnt[e[j].y]<2)\n\t\t\t\tdfs(e[j].y);\n\t\t}\n\t\tfor (auto j : o[i])\n\t\t\te[j].res^=cnt[e[j].y]==2;\n\t\tFor(j,1,n)\n\t\t\tif (Map[j][i]){\n\t\t\t\tint k=Map[j][i];\n\t\t\t\te[k].res^=cnt[j]>0;\n\t\t\t}\n\t}\n\tFor(i,1,m)\n\t\tputs(!e[i].res?\"same\":\"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  UnWeightedGraph gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n    for (int i = 0; i < g.size(); i++)\n    {\n        sort(gg[i].begin(),gg[i].end());\n        sort(rg[i].begin(),rg[i].end());\n    }\n  }\n\n  void revEdge(int a, int b){\n      auto itrgg_erase = lower_bound(gg[a].begin(),gg[a].end(),b);\n      gg[a].erase(itrgg_erase);\n      auto itrrg_erase = lower_bound(rg[b].begin(),rg[b].end(),a);\n      rg[b].erase(itrrg_erase);\n      auto itrgg_insert = lower_bound(gg[b].begin(),gg[b].end(),a);\n      gg[b].insert(itrgg_insert,a);\n      auto itrrg_insert = lower_bound(rg[a].begin(),rg[a].end(),b);\n      rg[a].insert(itrrg_insert,b);\n  }\n\n  int operator[](int k) {\n    return comp[k];\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(UnWeightedGraph &t) {\n    order.clear();\n    fill(comp.begin(),comp.end(),-1);\n    fill(used.begin(),used.end(), 0);\n    \n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      for(auto &to : g[i]) {\n        int x = comp[i], y = comp[to];\n        if(x == y) continue;\n        t[x].push_back(y);\n      }\n    }\n  }\n};\n\n\nint N;\nll M;\nvector<ll> A,B;\nUnWeightedGraph g, revG;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N >> M;\n    g.resize(N);\n    revG.resize(N);\n    for (int i = 0; i < M; i++)\n    {\n        int a,b;\n        cin >> a >> b;\n        a--;\n        b--;\n        A.push_back(a);\n        B.push_back(b);\n        g[a].emplace_back(b);\n    }\n    \n}\n\n// O(NM)かかる\n// O(M)でないとTLEしちゃう\nint TLEsolve(){\n    StronglyConnectedComponents< UnWeightedGraph > scc(g);\n    UnWeightedGraph buff;\n    scc.build(buff);\n    int cntG=0;\n    vector<bool> seen(N);\n    for (int i = 0; i < N; i++)\n    {\n        if(!seen[scc[i]]) cntG++;\n        seen[scc[i]] = true;\n    }\n    DBG(cntG)\n    for (int i = 0; i < M; i++)\n    {\n        // StronglyConnectedComponents< UnWeightedGraph > sccrev(g);\n        // strcpy(sccrev,scc);\n        scc.revEdge(A[i],B[i]);\n        scc.build(buff);\n        int cntrevG=0;\n        vector<bool> seen_revG(N);\n        for (int i = 0; i < N; i++)\n        {\n            if(!seen_revG[scc[i]]) cntrevG++;\n            seen_revG[scc[i]] = true;\n        }\n        if(cntG==cntrevG) cout << \"same\" << \"\\n\";\n        else cout << \"diff\" << \"\\n\";\n        scc.revEdge(B[i],A[i]);\n    }\n    \n    return 0;\n}   \n\nint main()\n{\n    input();\n    TLEsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define P pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\nconst int N=1005,M=2e5+5;\nint n,m,x,y;\nint d[N];\nvector<P>e[N];\nvector<int>e2[N];\nbool can[M],bz[N],bz2[N];\nvoid cover(int x){\n\tif(bz2[x])return;\n\tbz2[x]=1;d[1]=x;\n\tfor(int l=0,r=1;x=d[++l],l<=r;)\n\t\tfor(P i:e[x])if(!bz2[i.fi])\n\t\t\tbz2[i.fi]=1,d[++r]=i.fi;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfo(i,1,m){\n\t\tcin>>x>>y;\n\t\te[x].pb(P(y,i));\n\t\te2[y].pb(x);\n\t}\n\tfo(i,1,n){\n\t\tfo(j,1,n)bz2[j]=bz[j]=0;\n\t\td[1]=i;bz[i]=1;\n\t\tfor(int l=0,r=1;x=d[++l],l<=r;)\n\t\t\tfor(int i:e2[x])if(!bz[i])\n\t\t\t\tbz[i]=1,d[++r]=i;\n\t\tbz2[i]=1;\n\t\tfor(P j:e[i]){\n\t\t\tcan[j.se]=bz2[j.fi];\n\t\t\tcover(j.fi);\n\t\t}\n\t\tfo(j,1,n)bz2[j]=0;\n\t\tfd(j,0,e[i].size()-1){\n\t\t\tx=e[i][j].fi;\n\t\t\ty=e[i][j].se;\n\t\t\tcan[y]|=bz2[x];\n\t\t\tcover(x);\n\t\t\tcan[y]=can[y]?(bz[x]?0:1):(bz[x]?1:0);\n\t\t}\n\t}\n\tfo(i,1,m)printf(can[i]?\"diff\\n\":\"same\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0' || ch>'9')\n\t{\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0' && ch<='9')\n\t{\n\t\tx=10*x+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nconst int Maxn=1005;\nconst int Maxm=200005;\nstruct Edge\n{\n\tint u,v,next;\n} w[Maxm<<1];\nint cnt,head[Maxn];\nint n,m,vis[Maxn][Maxn];\nbool used[Maxm];\nvoid AddEdge(int u,int v)\n{\n\tcnt++;\n\tw[cnt].u=u;\n\tw[cnt].v=v;\n\tw[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int start,int x)\n{\n\tif(used[x])\treturn;\n\tvis[start][x]++;\n\tused[x]=true;\n\tfor(int i=head[x]; i; i=w[i].next)\n\t{\n\t\tdfs(start,w[i].v);\n\t}\n\tused[x]=false;\n}\nvoid init()\n{\n\tn=read();\n\tm=read();\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a=read();\n\t\tint b=read();\n\t\tAddEdge(a,b);\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tmemset(used,0,sizeof(used));\n\t\tdfs(i,i);\n\t}\n}\ninline bool SSC(int u,int v)\n{\n\treturn vis[u][v] && vis[v][u];\n}\nint main()\n{\n\tinit();\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint from=w[i].u;\n\t\tint to=w[i].v;\n\t\tif(SSC(from,to))\n\t\t{\n\t\t\tif(vis[from][to]==1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n*/"
  },
  {
    "language": "C++",
    "code": "/*input\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n\n2 2\n1 2\n2 1\n\n3 3\n1 2\n1 3\n2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define N 1005\n#define bit(x,y) ((x>>y)&1LL)\n#define loop(i,l,r) for(int i=(signed)(l); i<=(signed)(r); i++)\n\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &a) {\n    return os << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    for (unsigned int i = 0; i < a.size(); i++)\n        os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n    os << ']';\n    return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &a) {\n    os << '{';\n    for (typename set<T>::iterator it = a.begin(); it != a.end(); it++) {\n        typename set<T>::iterator jt = it;\n        os << *it << (++jt != a.end() ? \", \" : \"\");\n    }\n    os << '}';\n    return os;\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, map<T1, T2> &a) {\n    os << \"{\\n\";\n    for (typename map<T1, T2>::iterator it = a.begin(); it != a.end(); it++) {\n        typename map<T1, T2>::iterator jt = it;\n        os << \"  \" << it->first << \": \" << it->second << (++jt != a.end() ? \",\\n\" : \"\\n\");\n    }\n    os << '}';\n    return os;\n}\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint cnt[N][N];\nint mark[N][N];\nbool ansOrder[200005];\n\nvoid dfs(int u, int p, const int root, const int source) {\n    if (u == root) return;\n    if (cnt[root][u] >= 2) return;\n    if (cnt[root][u] == 1 && mark[root][u] == source) return;\n    cnt[root][u]++; mark[root][u] = source;\n    for (auto it : a[u]) {\n        int v = it.fi;\n        if (v == p) continue;\n        dfs(v, u, root, source);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    loop(i, 1, m) {\n        int u, v; cin >> u >> v;\n        a[u].push_back(mp(v, i));\n    }\n    loop(u, 1, m) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            dfs(v, u, u, v);\n        }\n    }\n    loop(u, 1, m) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            bool diff = false;\n            if (cnt[u][v] >= 2) {\n                if (cnt[v][u] == 0) diff = true;\n            }\n            else if (cnt[u][v] == 1) {\n                if (cnt[v][u] >= 1) diff = true;\n            }\n            ansOrder[it.se] = diff;\n        }\n    }\n    loop(i, 1, m) {\n        if (ansOrder[i] == false) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=1005,MAXM=200005;\n \nint N,M;\nvector<int> adj[MAXN];\nint E[MAXM][2];\n \nint p[MAXN][MAXN],q[MAXN][MAXN];\nbool vis[MAXN];\n \nvoid mark(int s,int u,int id,int mk[])\n{\n\tif(u==s||vis[u])return;\n\tvis[u]=true;\n\tmk[u]=id;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t\tmark(s,adj[u][i],id,mk);\n}\n \nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1,a,b;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tE[i][0]=a;E[i][1]=b;\n\t\tadj[a].push_back(b);\n\t}\n\t\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tint id=0;\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],++id,p[i]);\n\t\tmemset(vis,0,sizeof vis);\n\t\treverse(adj[i].begin(),adj[i].end());\n\t\tid=adj[i].size();\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],id--,q[i]);\n\t}\n\t\n\tfor(int i=1;i<=M;i++)\n\t\tif((p[E[i][1]][E[i][0]]>0)==(p[E[i][0]][E[i][1]]!=q[E[i][0]][E[i][1]]))\n\t\t\tputs(\"same\");\n\t\telse\n\t\t\tputs(\"diff\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nint head[maxn], nxt[maxm], to[maxm], tot;\nint x[maxm], v[maxn][maxn], y[maxm], vis[maxn], vis2[maxn];\nint s[maxm], S;\n\nvoid add(int x, int y) {\n\t++tot;\n\tnxt[tot] = head[x];\n\tto[tot] = y;\n\thead[x] = tot;\n}\n\nvoid dfs(int x, int y) {\n\tv[y][x] = 1;\n\tfor (int e = head[x]; e; e = nxt[e]) {\n\t\tint z = to[e];\n\t\tif (!v[y][z]) dfs(z, y);\n\t}\n}\n\nvoid dfs2(int u, int *vis) {\n\tif (!vis[u]) vis[u] = u;\n\tfor (int e = head[u]; e; e = nxt[e]) {\n\t\tint v = to[e];\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = vis[u];\n\t\t\tdfs2(v, vis);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tint a, b;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd(a, b);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdfs(i, i);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis[i] = vis2[i] = i;\n\t\tS = 0;\n\t\tfor (int e = head[i]; e; e = nxt[e]) {\n\t\t\ts[S++] = e;\n\t\t\tint j = to[e];\n\t\t\tif (!vis[j]) dfs2(j, vis);\n\t\t}\n\t\twhile (S) {\n\t\t\tint e = s[--S];\n\t\t\tint j = to[e];\n\t\t\tif (!vis2[j]) dfs2(j, vis2);\n\t\t\tif (vis2[j] == vis[j]) y[e] = false;\n\t\t\telse y[e] = true;\n\t\t\tif (v[j][i]) x[e] = true;\n\t\t\telse x[e] = false;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tputs(x[i]^y[i]?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MX=200010, inf=2e9;\n\nint n, m;\nbool ans[MX];\npii E[MX];\n\nint U[MX];\nint find(int x){\n    return x==U[x] ? x : U[x]=find(U[x]);\n}\nvoid unite(int x, int y){\n    U[find(y)]=find(x);\n}\n\nvector<int> G[1010], R[1010];\nbool vis[1010];\nvoid dfs1(int v, stack<int> &S){\n    vis[v]=true;\n    for(int x:G[v]) if(!vis[x]) dfs1(x,S);\n    S.push(v);\n}\nvoid dfs2(int v){\n    vis[v]=true;\n    for(int x:R[v]){\n        if(vis[x]) continue;\n        unite(x,v); dfs2(x);\n    }\n}\nvoid scc(){\n    iota(U, U+n+1, 0);\n    stack<int> stk;\n    fill(vis, vis+n+1, false);\n    for(int i=1; i<=n; i++) if(!vis[i]) dfs1(i, stk);\n    fill(vis, vis+n+1, false);\n    while(!stk.empty()){\n        int v=stk.top(); stk.pop();\n        if(vis[v]) continue;\n        dfs2(v);\n    }\n}\n\nvector<pii> GG[1010];\nint D[1010][1010][2];\n\nvoid dfs3(int v, int st, int idx){\n    if(D[st][v][0]==0) D[st][v][0]=idx;\n    else D[st][v][1]=idx;\n    for(int x:G[v]){\n        if(D[st][x][0]!=0 && D[st][x][1]!=0) continue;\n        if(D[st][x][0]==idx || D[st][x][1]==idx) continue;\n        dfs3(x,st,idx);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>m;\n    for(int i=1; i<=m; i++){\n        int u,v; cin>>u>>v;\n        E[i]={u,v};\n        G[u].push_back(v);\n        R[v].push_back(u);\n        GG[u].push_back({v,i});\n    }\n    scc();\n\n    for(int v=1; v<=n; v++){\n        D[v][v][0]=D[v][v][1]=-1;\n        for(pii &p:GG[v]){\n            int x,idx; tie(x,idx)=p;\n            if(D[v][x][0]!=0 && D[v][x][1]!=0) continue;\n            dfs3(x,v,idx);\n        }\n    }\n\n    for(int i=1; i<=m; i++){\n        int u,v; tie(u,v)=E[i];\n        // cout<<u<<' '<<v<<\": \"<<D[u][v][0]<<' '<<D[u][v][1]<<'\\n';\n        if(D[u][v][0]==i && D[u][v][1]==0) ans[i]=false;\n        else ans[i]=true;\n        // cout<<ans[i]<<\", \"<<(find(u)!=find(v))<<'\\n';\n        if(find(u)!=find(v)) ans[i]=!ans[i];\n    }\n    for(int i=1; i<=m; i++) cout<<(ans[i] ? \"same\" : \"diff\")<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint o=vis[i][e[p].k];\n\t\t\ts[++top]=e[p].k;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=o;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>1;p--){\n\t\t\tint o=vis[i][s[p]];\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=o;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N, M;\nvector<pair<int, int>> edge_list;\nvector<vector<int>> adj;\nvector<vector<bool>> reach;\n\nvoid reach_dfs(int source, int node) {\n    if (reach[source][node])\n        return;\n\n    reach[source][node] = true;\n\n    for (int neighbor : adj[node])\n        if (!reach[source][neighbor])\n            reach_dfs(source, neighbor);\n}\n\nvector<vector<bool>> reach_without;\nvector<int> best_index;\n\nvoid without_dfs(int index, int node) {\n    if (best_index[node] >= 0)\n        return;\n\n    best_index[node] = index;\n\n    for (int neighbor : adj[node])\n        if (best_index[neighbor] < 0)\n            without_dfs(index, neighbor);\n}\n\nvoid solve_reach_without(int source) {\n    reach_without[source][source] = true;\n    int neighbors = adj[source].size();\n    best_index.assign(N, -1);\n    best_index[source] = N;\n\n    for (int i = 0; i < neighbors; i++)\n        without_dfs(i, adj[source][i]);\n\n    for (int i = 0; i < neighbors; i++) {\n        int neighbor = adj[source][i];\n\n        if (best_index[neighbor] >= 0 && best_index[neighbor] != i)\n            reach_without[source][neighbor] = true;\n    }\n\n    best_index.assign(N, -1);\n    best_index[source] = N;\n\n    for (int i = neighbors - 1; i >= 0; i--)\n        without_dfs(i, adj[source][i]);\n\n    for (int i = 0; i < neighbors; i++) {\n        int neighbor = adj[source][i];\n\n        if (best_index[neighbor] >= 0 && best_index[neighbor] != i)\n            reach_without[source][neighbor] = true;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> M;\n    edge_list.resize(M);\n    adj.assign(N, {});\n\n    for (pair<int, int> &edge : edge_list) {\n        cin >> edge.first >> edge.second;\n        edge.first--; edge.second--;\n        adj[edge.first].push_back(edge.second);\n    }\n\n    reach.assign(N, vector<bool>(N, false));\n\n    for (int i = 0; i < N; i++)\n        reach_dfs(i, i);\n\n    reach_without.assign(N, vector<bool>(N, false));\n\n    for (int i = 0; i < N; i++)\n        solve_reach_without(i);\n\n    for (pair<int, int> &edge : edge_list) {\n        bool answer1 = reach_without[edge.first][edge.second];\n        bool answer2 = reach[edge.second][edge.first];\n        cout << (answer1 ^ answer2 ? \"diff\" : \"same\") << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nbool bz[N],bz1[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v,int dep){ \n    static int y;\n    if (dep>100)return;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1])){\n                bz1[x]|=bz1[y];\n                continue;\n            }\n            if (!F[y][0]){\n                F[y][0]=v;\n                dfs(y,s,v,dep+1);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y])dfs(y,s,v,dep+1);\n            }\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n\n2 2\n1 2\n2 1\n\n3 3\n1 2\n1 3\n2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define N 1005\n#define bit(x,y) ((x>>y)&1LL)\n#define loop(i,l,r) for(int i=(signed)(l); i<=(signed)(r); i++)\n\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &a) {\n    return os << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    for (unsigned int i = 0; i < a.size(); i++)\n        os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n    os << ']';\n    return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &a) {\n    os << '{';\n    for (typename set<T>::iterator it = a.begin(); it != a.end(); it++) {\n        typename set<T>::iterator jt = it;\n        os << *it << (++jt != a.end() ? \", \" : \"\");\n    }\n    os << '}';\n    return os;\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, map<T1, T2> &a) {\n    os << \"{\\n\";\n    for (typename map<T1, T2>::iterator it = a.begin(); it != a.end(); it++) {\n        typename map<T1, T2>::iterator jt = it;\n        os << \"  \" << it->first << \": \" << it->second << (++jt != a.end() ? \",\\n\" : \"\\n\");\n    }\n    os << '}';\n    return os;\n}\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint cnt[N][N];\nint mark[N][N];\nbool ansOrder[200005];\n\nvoid dfs(int u, int p, const int root, const int source) {\n    if (u == root) return;\n    if (cnt[root][u] >= 2) return;\n    if (cnt[root][u] == 1 && mark[root][u] == source) return;\n    cnt[root][u]++; mark[root][u] = source;\n    for (auto it : a[u]) {\n        int v = it.fi;\n        if (v == p) continue;\n        dfs(v, u, root, source);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    loop(i, 1, m) {\n        int u, v; cin >> u >> v;\n        a[u].push_back(mp(v, i));\n    }\n    loop(u, 1, m) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            dfs(v, u, u, v);\n        }\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            bool diff = false;\n            if (cnt[u][v] >= 2) {\n                if (cnt[v][u] == 0) diff = true;\n            }\n            else if (cnt[u][v] == 1) {\n                if (cnt[v][u] >= 1) diff = true;\n            }\n            ansOrder[it.se] = diff;\n        }\n    }\n    loop(i, 1, m) {\n        if (ansOrder[i] == false) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=2e5+10;\nint w[M],ne[M],la[N],t,ans[M];\nvoid link(int x,int y){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n}\nint arv[N][N],n,m,X,mrk[N],ti,mrk2[N];\nvector<int> e[N];\n//void dfs(int x){\n//\tarv[X][x]=1;\n//\tfor (int y=la[x];y;y=ne[y])\n//\t\tif (!arv[X][w[y]])dfs(w[y]);\n//}\nvoid go(int x){\n\tmrk[x]=ti;\n\tfor (auto z:e[x])\n\t\tif (z!=X&&!mrk[z])go(z);\n}\nvoid go2(int x){\n\tmrk2[x]=ti;\n\tfor (auto z:e[x])\n\t\tif (z!=X&&!mrk2[z])go2(z);\n}\nvector<int> c;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t\te[x].push_back(y);\n\t}\n\tfor (X=1;X<=n;X++){\n\t\tc.clear();\n\t\tfor (int y=la[X];y;y=ne[y]){\n\t\t\tti++;\n\t\t\tif (!mrk[w[y]])go(w[y]);\n\t\t\tc.push_back(w[y]);\n\t\t}\n\t\twhile (c.size()){\n\t\t\tif (!mrk2[c.back()])go2(c.back());\n\t\t\tc.pop_back();\n\t\t\tti--;\n\t\t}\n\t\tfor (int y=la[X];y;y=ne[y])ans[y]=(mrk[w[y]]<mrk2[w[y]]);\n\t\tfor (int i=1;i<=n;i++)arv[X][i]=(bool)mrk[i],mrk[i]=mrk2[i]=0;\n\t}\n\tfor (int x=1;x<=n;x++)\n\t\tfor(int y=la[x];y;y=ne[y])\n\t\t\tans[y]=ans[y]==arv[w[y]][x];\n\tfor (int i=1;i<=m;i++)\n\t\tputs(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N, M;\nvector<pair<int, int>> edge_list;\nvector<vector<int>> adj;\nvector<vector<bool>> reach;\n\nvoid reach_dfs(int source, int node) {\n    if (reach[source][node])\n        return;\n\n    reach[source][node] = true;\n\n    for (int neighbor : adj[node])\n        reach_dfs(source, neighbor);\n}\n\nvector<vector<bool>> reach_without;\nvector<int> best_index;\n\nvoid without_dfs(int index, int node) {\n    if (best_index[node] >= 0)\n        return;\n\n    best_index[node] = index;\n\n    for (int neighbor : adj[node])\n        without_dfs(index, neighbor);\n}\n\nvoid solve_reach_without(int source) {\n    reach_without[source][source] = true;\n    int neighbors = adj[source].size();\n    best_index.assign(N, -1);\n    best_index[source] = N;\n\n    for (int i = 0; i < neighbors; i++)\n        without_dfs(i, adj[source][i]);\n\n    for (int i = 0; i < neighbors; i++) {\n        int neighbor = adj[source][i];\n\n        if (best_index[neighbor] >= 0 && best_index[neighbor] != i)\n            reach_without[source][neighbor] = true;\n    }\n\n    best_index.assign(N, -1);\n    best_index[source] = N;\n\n    for (int i = neighbors - 1; i >= 0; i--)\n        without_dfs(i, adj[source][i]);\n\n    for (int i = 0; i < neighbors; i++) {\n        int neighbor = adj[source][i];\n\n        if (best_index[neighbor] >= 0 && best_index[neighbor] != i)\n            reach_without[source][neighbor] = true;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> M;\n    edge_list.resize(M);\n    adj.assign(N, {});\n\n    for (pair<int, int> &edge : edge_list) {\n        cin >> edge.first >> edge.second;\n        edge.first--; edge.second--;\n        adj[edge.first].push_back(edge.second);\n    }\n\n    reach.assign(N, vector<bool>(N, false));\n\n    for (int i = 0; i < N; i++)\n        reach_dfs(i, i);\n\n    reach_without.assign(N, vector<bool>(N, false));\n\n    for (int i = 0; i < N; i++)\n        solve_reach_without(i);\n\n    for (pair<int, int> &edge : edge_list) {\n        bool answer1 = reach_without[edge.first][edge.second];\n        bool answer2 = reach[edge.second][edge.first];\n        cout << (answer1 ^ answer2 ? \"diff\" : \"same\") << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <queue>\n#include <sstream>\nusing namespace std;\n#define x first\n#define y second\n#define mp make_pair\n#define elif else if\n#define prev prev2\n#define Edge pair <int, int>\n#define next next2\n#define u first\n#define v second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1000, N = 1000, MAXM = 2e5;\nvector<int> g[MAXN], gt[MAXN];\nint a[MAXN], b[MAXN], c1[MAXN], c2[MAXN];\nvector<int> topsort;\nint vis[MAXN];\nEdge ed[MAXM];\nbool used[N];\nvoid dfs(int u) {\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (!used[v]) dfs(v);\n    }   \n}   \nvoid solve(int u) {\n\t//cout << \"u: \" << u << endl;\n    memset(used, 0, sizeof used);\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        //cout << v << \" \" << used[v] << endl;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n    memset(used, 0, sizeof used);\n    reverse(g[u].begin(), g[u].end());\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n}   \nvoid dfst1(int v) {\n\tvis[v] = 1;\n\tfor (int e : g[v]) {\n\t\tint u = b[e];\n\t\tif (!vis[u])\n\t\t\tdfst1(u);\n\t}\n\ttopsort.push_back(v);\n}\nint clr = 0;\nvoid dfst2(int v) {\n\tvis[v] = clr;\n\tfor (int e : gt[v]) {\n\t\tint u = a[e];\n\t\tif (!vis[u])\n\t\t\tdfst2(u);\n\t}\n}\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\t--a[i];\n\t\t--b[i];\n\t\tg[a[i]].push_back(i);\n\t\tgt[b[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!vis[i])\n\t\t\tdfst1(i);\n\tfill(vis, vis + n, 0);\n\treverse(topsort.begin(), topsort.end());\n\tfor (int v : topsort)\n\t\tif (!vis[v]) {\n\t\t\t++clr;\n\t\t\tdfst2(v);\n\t\t}\n\n\tfor (int i = 0; i < m; ++i) \n\t\tc1[i] = (vis[a[i]] == vis[b[i]]);\n\tfor (int i = 0; i < m; ++i) {\n        ed[i] = {a[i], b[i]};\n    }   \n    for (int i = 0; i < n; ++i) {\n        solve(i);\n    }\n\n\tfor (int i = 0; i < m; ++i) {\n\t\t//cout << c1[i] << c2[i];\n        if (c1[i] ^ c2[i]) {\n            cout << \"diff\\n\";\n        }   \n        else {\n            cout << \"same\\n\";\n        }\n    }   \n\treturn;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid File(){\n    freopen(\"ARC92F.in\",\"r\",stdin);\n    freopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nvector<int>E[maxn];\nint n,m,beg[maxn],len,num[maxn][maxn];\nbool can[maxn][maxn],vis[maxn],can1[maxn][maxn];\nint vis1[maxn],vis2[maxn],from[maxm],to[maxm];\nvoid dfs(int u,int rt){\n    vis[u]=1;\n    can[rt][u]=1;\n    int size=E[u].size()-1;\n    REP(i,0,size){\n        int v=E[u][i];\n        if(vis[v])continue;\n        dfs(v,rt);\n    }\n}\nvoid dfs1(int u){\n    vis[u]=1;\n    int size=E[u].size()-1;\n    REP(i,0,size){\n        int v=E[u][i];\n        if(vis[v])continue;\n        vis1[v]=num[u][v];\n        dfs1(v);\n    }\n}\nvoid dfs2(int u){\n    vis[u]=1;\n    int size=E[u].size()-1;\n    DREP(i,size,0){\n        int v=E[u][i];\n        if(vis[v])continue;\n        vis2[v]=num[u][v];\n        dfs2(v);\n    }\n}\nint main(){\n    //File();\n    scanf(\"%d%d\",&n,&m);\n    REP(i,1,m){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        E[u].push_back(v);\n        num[u][v]=++len;\n        from[len]=u;\n        to[len]=v;\n    }\n    REP(i,1,n){\n        dfs(i,i);\n        mem(vis);\n    }\n    REP(i,1,n){\n        dfs1(i);\n        mem(vis);\n        dfs2(i);\n        mem(vis);\n        int size=E[i].size()-1;\n        REP(j,0,size){\n            int v=E[i][j];\n            if(vis1[v]!=num[i][v] || vis2[v]!=num[i][v])\n                can1[i][v]=1;\n        }\n        mem(vis1);\n        mem(vis2);\n    }\n    REP(i,1,m){\n        int u=from[i],v=to[i];\n        if((can[v][u]^can1[u][v])==0)\n            puts(\"same\");\n        else puts(\"diff\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printc;\nusing io::prints;\n\nconst int N = 1e3 + 7, M = 2e5 + 7;\nint n, m, u[M], v[M];\nbool w[N][N];\nint p[N][N], q[N][N];\nvi e[N];\n\nvoid dfs(int x, bool *w) {\n\tw[x] = 1;\n\tfor (int y : e[x])\n\t\tif (!w[y]) dfs(y, w);\n}\n\nvoid dfs(int x, int *p, int z) {\n\tp[x] = z;\n\tfor (int y : e[x])\n\t\tif (!p[y]) dfs(y, p, z);\n}\n\nint main() {\n\trd(n, m);\n\tfor (int i = 1; i <= m; i++) rd(u[i], v[i]), e[u[i]].pb(v[i]);\n\tfor (int x = 1; x <= n; x++) {\n\t\tdfs(x, w[x]);\n\t\tp[x][x] = q[x][x] = x;\n\t\tfor (int y : e[x]) if (!p[x][y]) dfs(y, p[x], y);\n\t\treverse(e[x].begin(), e[x].end());\n\t\tfor (int y : e[x]) if (!q[x][y]) dfs(y, q[x], y);\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tprints((w[v[i]][u[i]] ^ (p[u[i]][v[i]] != q[u[i]][v[i]])) ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//test\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\nstruct graph_t\n{\n\tint front,nex;\n}graph[201001],graph2[201001];\nint tail=1000,tail2=1000;\n\nvoid addedge(int u,int v)\n{\n\tint tmp=graph[u].nex;\n\tgraph[u].nex=++tail;\n\tgraph[tail].front=v;\n\tgraph[tail].nex=tmp;\n}\n\nvoid addedge2(int u,int v)\n{\n\tint tmp=graph2[u].nex;\n\tgraph2[u].nex=++tail2;\n\tgraph2[tail].front=v;\n\tgraph2[tail].nex=tmp;\n}\n\nint vis[1001][1001];\npair<int,int> edge[200001];\nset <pair<int,int> > visedge;\nset <int> nowvis; \n\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tnowvis.insert(now);\n\tfor(int i=graph[now].nex;i;i=graph[i].nex)\n\t{\n\t\tif(!nowvis.count(graph[i].front)&&!visedge.count(make_pair(now,graph[i].front)))\n\t\t{\n\t\t\tvisedge.insert(make_pair(now,graph[i].front));\n\t\t\tdfs(from,graph[i].front);\n\t\t}\n\t}\n\tnowvis.erase(now);\n}\n\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i]=make_pair(from,to);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tvisedge.clear();\n\t\tdfs(i,i);\n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<vis[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint ans[100010];\nvector<int> adj[100010], sadj[100010], U, V;\nint tin[100010], bck[100010], id[100010], timer, scnt;\nstack<int> stk;\n\nvoid dfs(int u) {\n    tin[u] = timer++;\n    bck[u] = tin[u];\n    stk.push(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int e = adj[u][i];\n        int v = V[e];\n        if(tin[v] == -1) {\n            dfs(v);\n            bck[u] = min(bck[u], bck[v]);\n        }\n        else if(id[v] == -1) {\n            bck[u] = min(bck[u], tin[v]);\n        }\n    }\n    if(bck[u] == tin[u]) {\n        while(1) {\n            int t = stk.top(); stk.pop();\n            id[t] = scnt;\n            if(t == u) break;\n        }\n        scnt++;\n    }\n}\n\nint cc[1010][1010];\nint dp(int u, int d) {\n    int &ret = cc[u][d];\n    if(ret != -1) return ret;\n    if(u == d) return ret = 0;\n\n    ret = 0;\n    for(int i = 0; i < sadj[u].size(); i++) {\n        int e = sadj[u][i];\n        int v = id[ V[e] ];\n        ret = max(ret, 1 + dp(v, d));\n    }\n    return ret;\n}\n\nvoid scc() {\n    memset(tin, -1, sizeof(tin));\n    memset(id, -1, sizeof(id));\n    for(int i = 0; i < N; i++) if(tin[i] == -1) {\n        dfs(i);\n    }\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            sadj[ id[u] ].push_back(e);\n        }\n    }\n    memset(cc, -1, sizeof(cc));\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            if(dp(id[u], id[v]) > 1) ans[e] = 1;\n            else ans[e] = 0;\n        }\n    }\n}\n\nqueue<int> q1, q2;\nint dist1[1010], dist2[1010], par1[1010], par2[1010];\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < M; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(i);\n        U.push_back(u);\n        V.push_back(v);\n    }\n\n    scc();\n\n    for(int u = 0; u < N; u++) {\n        memset(dist1, -1, sizeof(dist1));\n        memset(dist2, -1, sizeof(dist2));\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int e = adj[u][i];\n            int v = V[e];\n            if(id[u] == id[v]) {\n                q1.push(v);\n                dist1[v] = 0;\n                par1[v] = v;\n            }\n        }\n        while(!q1.empty()) {\n            int t = q1.front(); q1.pop();\n\n            for(int i = 0; i < adj[t].size(); i++) {\n                int e = adj[t][i];\n                int v = V[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist1[v] == -1) {\n                        dist1[v] = dist1[t] + 1;\n                        par1[v] = par1[t];\n                        q1.push(v);\n                    }\n                    else if(dist2[v] == -1 && par1[v] != par1[t]) {\n                        dist2[v] = dist1[t] + 1;\n                        par2[v] = par1[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n        while(!q2.empty()) {\n            int t = q2.front(); q2.pop();\n\n            for(int i = 0; i < adj[t].size(); i++) {\n                int e = adj[t][i];\n                int v = V[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist2[v] == -1 && par1[v] != par2[t]) {\n                        dist2[v] = dist2[t] + 1;\n                        par2[v] = par2[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int e = adj[u][i];\n            int v = V[e];\n            if(id[u] == id[v]) {\n                if(dist2[v] != -1) ans[e] = 0;\n                else ans[e] = 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++) {\n        if(ans[i]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MAX_V = 1100;\nstruct Graph {\n    int V;\n    vector<int> list[MAX_V];\n    vector<int> back[MAX_V];\n    \n    Graph(int n = 0) : V(n) {}\n    void init(int n = 0) {V = n; for (int i = 0; i < MAX_V; ++i) {list[i].clear(); back[i].clear();} }\n    inline vector<int>& operator [] (int i) {return list[i];}\n    \n    void direct(int f, int t) {\n        list[f].push_back(t);\n        back[t].push_back(f);\n    }\n    \n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.V; ++i) {s << i << \" : \" << G.list[i] << endl;}return s;\n    }\n} G;\n\nvector<vector<int> > scc;\nGraph SG;\nint cmp[MAX_V];\n\nstatic bool used[MAX_V];\nstatic set<pair<int,int> > se;\nstatic vector<int> vs, rvs;\n\nvoid dfs(Graph &G, int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); ++i) {\n        if (!used[G[v][i]]) dfs(G, G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(Graph &G, int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < G.back[v].size(); ++i) {\n        if (!used[G.back[v][i]]) rdfs(G, G.back[v][i], k);\n    }\n    rvs.push_back(v);\n}\n\nvoid make_dag(Graph &G) {\n    int SV = scc.size();\n    SG.init(SV);\n    se.clear();\n    for (int i = 0; i < G.V; ++i) {\n        int u = cmp[i];\n        for (int j = 0; j < G[i].size(); ++j) {\n            int v = cmp[G[i][j]];\n            if (u == v) continue;\n            if (!se.count(make_pair(u, v))) SG.direct(u, v);\n            used[v] = true;\n        }\n    }\n}\n\nvoid SCC(Graph &G) {\n    vs.clear();\n    scc.clear();\n    memset(used, 0, sizeof(used));\n    for (int i = 0; i < G.V; ++i) {\n        if (!used[i]) dfs(G, i);\n    }\n    int k = 0;\n    memset(used, 0, sizeof(used));\n    for (int i = vs.size()-1; i >= 0; --i) {\n        if (!used[vs[i]]) {\n            rvs.clear();\n            rdfs(G, vs[i], k++);\n            scc.push_back(rvs);\n        }\n    }\n    make_dag(G);\n}\n\n\n\nint N, M;\nint a[210000], b[210000];\n\nbool can[MAX_V][MAX_V];\nint dist[MAX_V][MAX_V];\n\nint main() {\n    while (cin >> N >> M) {\n        G.init(N);\n        for (int i = 0; i < M; ++i) {\n            cin >> a[i] >> b[i];\n            --a[i], --b[i];\n            G.direct(a[i], b[i]);\n        }\n        SCC(G);\n        \n        memset(can, 0, sizeof(can));\n        memset(dist, -1, sizeof(dist));\n        for (int v = 0; v < N; ++v) {\n            dist[v][v] = 0;\n            queue<int> que;\n            que.push(v);\n            while (!que.empty()) {\n                int cur = que.front();\n                que.pop();\n                for (auto e : G[cur]) {\n                    if (dist[v][e] == 1 && dist[cur] > 0) {\n                        can[v][e] = true;\n                    }\n                    if (dist[v][e] == -1) {\n                        dist[v][e] = dist[v][cur] + 1;\n                        que.push(e);\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < M; ++i) {\n            bool isbri = false;\n            if (cmp[a[i]] != cmp[b[i]]) {\n                isbri = true;\n            }\n            \n            if (isbri) {\n                if (can[a[i]][b[i]]) puts(\"diff\");\n                else puts(\"same\");\n            }\n            else {\n                if (can[a[i]][b[i]]) puts(\"same\");\n                else puts(\"diff\");\n            }\n        }\n        \n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 1010;\nconst int MM = 200010;\n\nint N, M;\nint a[MM], b[MM];\n\nvector<pii> g[MN];\n\nbool no_need[MM];\nbool vis[MN];\nbool can[MN][MN];\n\nvoid dfs(int v, int st) {\n\tvis[v] = 1;\n\tfor (auto e : g[v]) {\n\t\tif (!vis[e.fi] && e.fi != st) {\n\t\t\tdfs(e.fi, st);\n\t\t} \n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\n\trep(i, M) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].eb(b[i], i);\n\t}\n\n\trep(i, N) {\n\t\tqueue<int> que;\n\t\tcan[i][i] = 1;\n\t\tque.push(i);\n\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (auto e : g[v]) {\n\t\t\t\tif (!can[i][e.fi]) {\n\t\t\t\t\tcan[i][e.fi] = 1;\n\t\t\t\t\tque.push(e.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, N) {\n\t\trep(t, 2) {\n\t\t\tmemset(vis, 0, sizeof(vis));\n\n\t\t\tfor (auto e : g[i]) {\n\t\t\t\tif (vis[e.fi]) {\n\t\t\t\t\tno_need[e.se] = true;\n\t\t\t\t} else {\n\t\t\t\t\tdfs(e.fi, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(ALL(g[i]));\n\t\t}\n\t}\n\n\trep(i, M) {\n\t\tputs(no_need[i] == can[b[i]][a[i]] ? \"same\" : \"diff\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define all(x) x.begin(),x.end()\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,M=N*N;\nvector<int> g[N];\nint n,m,ans[M],vis[N],clk;\nint a[M],b[M],tim[N],del;\nvoid dfs(int v){\n\tvis[v]=clk;\n\tfor (int d:g[v]){\n\t\tif((!vis[d])&&d!=del)dfs(d);\n\t}\n}\nvoid gao(int x){\n\tdel=x;\n\tmem(vis,0);\n\tclk=0;\n\tfor(int d:g[x]){\n\t\t++clk;\n\t\ttim[d]=clk;\n\t\tif(!vis[d])dfs(d);\n\t}\n\trep(i,1,m)if(a[i]==x&&vis[b[i]]!=tim[b[i]])ans[i]=1;\n\n}\nint main(int argc,char*argv[]){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,m){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tg[a[i]].pb(b[i]);\n\t}\n\trep(x,1,n){\n\t\tgao(x);\n\t\treverse(all(g[x]));\n\t\tgao(x);\n\t}\n\trep(x,1,n){\n\t\tdel=0;\n\t\tmem(vis,0);\n\t\tdfs(x);\n\t\trep(i,1,m)if(b[i]==x)ans[i]^=vis[a[i]];\n\t}\n\trep(i,1,m)printf(\"%s\\n\",ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=2e5+10;\nint w[M],ne[M],la[N],t,ans[M];\nvoid link(int x,int y){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n}\nint arv[N][N],n,m,X,mrk[N],ti,mrk2[N];\nvoid dfs(int x){\n\tarv[X][x]=1;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (!arv[X][w[y]])dfs(w[y]);\n}\nvoid go(int x){\n\tmrk[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk[w[y]])go(w[y]);\n}\nvoid go2(int x){\n\tmrk2[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk2[w[y]])go2(w[y]);\n}\nvector<int> c;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tfor (X=1;X<=n;X++)dfs(X);\n\tfor (X=1;X<=n;X++){\n\t\tfor (int i=1;i<=n;i++)mrk[i]=mrk2[i]=0;\n\t\tc.clear();\n\t\tfor (int y=la[X];y;y=ne[y]){\n\t\t\tti++;\n\t\t\tif (!mrk[y])go(w[y]);\n\t\t\tc.push_back(w[y]);\n\t\t}\n\t\twhile (c.size()){\n\t\t\tif (!mrk2[c.back()])go2(c.back());\n\t\t\tc.pop_back();\n\t\t\tti--;\n\t\t}\n\t\tfor (int y=la[X];y;y=ne[y])\n\t\t\tans[y]=(mrk[w[y]]<mrk2[w[y]])==arv[w[y]][X];\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tputs(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nstruct eg{int to;eg*nx;}e[400100],*la[1010],*la1[1010],*cnt=e,*cnt1;\nint bl[1010],bl1[1010],num[1010],sta[1010],d[1010],ta,I,tot,tt,dfn[1010],low[1010];\nint ans[200100],x[200100],y[200100];\nbool in[1010],is[1010][1010],ia[1010];\ninline void addE(re int a,re int b)\n{\n\t*++cnt=(eg){b,la[a]};la[a]=cnt;\n}\ninline void addE1(re int a,re int b)\n{\n\t*++cnt=(eg){b,la1[a]};la1[a]=cnt;\n}\nvoid dfs(re int a)\n{\n\tlow[a]=dfn[a]=++tot;\n\tin[a]=1;sta[++ta]=a;\n\tfor(re eg*i=la[a];i;i=i->nx)if(i->to!=I)\n\t{\n\t\tif(!dfn[i->to])dfs(i->to),low[a]=std::min(low[a],low[i->to]);\n\t\telse if(in[i->to])low[a]=std::min(low[a],dfn[i->to]);\n\t}\n\tif(low[a]==dfn[a])\n\t{\n\t\ttt++;\n\t\tdo\n\t\t{\n\t\t\tbl[sta[ta]]=tt;in[sta[ta]]=0;\n\t\t}while(sta[ta--]!=a);\n\t}\n}\nint main()\n{\n\tre int n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re int i=1;i<=m;i++)scanf(\"%d%d\",&x[i],&y[i]),addE(x[i],y[i]);\n\tfor(re int i=1;i<=n;i++)if(!dfn[i])dfs(i);\n\tfor(re int i=1;i<=n;i++)bl1[i]=bl[i];\n\tfor(I=1;I<=n;I++)\n\t{\n\t\ttt=tot=ta=0;cnt1=cnt;\n\t\tmemset(dfn,0,sizeof(dfn));\n\t\tmemset(la1,0,sizeof(la1));\n\t\tmemset(num,0,sizeof(num));\n\t\tmemset(ia,0,sizeof(ia));\n\t\tbl[I]=0;\n\t\tfor(re int i=1;i<=n;i++)if((!dfn[i])&&i!=I)dfs(i);\n\t\tfor(re eg*i=la[I];i;i=i->nx)if(!ia[i->to])(num[bl[i->to]]=(num[bl[i->to]])?2:1),ia[i->to]=1;\n\t\tfor(re int i=1;i<=m;i++)if(bl[x[i]]!=bl[y[i]]&&bl[x[i]]&&bl[y[i]])\n\t\t{\n\t\t\tif(!is[bl[x[i]]][bl[y[i]]])\n\t\t\taddE1(bl[x[i]],bl[y[i]]),d[bl[y[i]]]++,is[bl[x[i]]][bl[y[i]]]=1;\n\t\t}\n\t\tfor(re int i=1;i<=tt;i++)if(!d[i])sta[++ta]=i;\n\t\tfor(re int i=1;i<=ta;i++)\n\t\t{\n\t\t\tre int x=sta[i];\n\t\t\tfor(re eg*i1=la1[x];i1;i1=i1->nx)\n\t\t\t{\n\t\t\t\tif(!num[i1->to])num[i1->to]=num[x];\n\t\t\t\telse if(num[x])num[i1->to]=2;\n\t\t\t\td[i1->to]--;\n\t\t\t\tif(!d[i1->to])sta[++ta]=i1->to;\n\t\t\t}\n\t\t}\n\t\tfor(re int i=1;i<=m;i++)\n\t\t{\n\t\t\tis[bl[x[i]]][bl[y[i]]]=0;\n\t\t}\n\t\tfor(re eg*i=la[I];i;i=i->nx)\n\t\tif(i->to!=I){\n\t\t\tans[i-e]=(bl1[I]==bl1[i->to])==(num[bl[i->to]]>1);\n\t\t}else ans[i-e]=1;\n\t\tcnt=cnt1;\n\t}\n\tfor(re int i=1;i<=m;i++)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=1010;\nconst int M=2e5+10;\nstruct node{\n    int next,to,id;\n}e[M<<1];\nint head[N],cnt;\ninline void add(int u,int v,int id){\n    e[cnt].id=id;e[cnt].to=v;e[cnt].next=head[u];head[u]=cnt++;\n}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(p[frm][v]||v==frm) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(q[frm][v]||v==frm) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[N];\nint main(){\n    mst(head,-1);n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n    }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    rep(x,1,n){\n\tvector<int> fk;\n\trpp(i,x,e,head){\n\t    fk.push_back(i);\n\t    col=e[i].id;\n\t    int v=e[i].to;if(p[x][v]) continue;\n\t    dfs2(v,x);\n\t}\n\treverse(fk.begin(),fk.end());\n\tfor(auto i:fk){\n\t    col=e[i].id;\n\t    int v=e[i].to;if(q[x][v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define MN 1010 \n#define MM 201000\n\ntypedef std::pair<int, int> P;\n\nP d[MN][2], q[MN * 2];\nint Ans[MN][MN], Ans2[MN][MN];\nint hh = 0, tt = 0;\nint x[MM], y[MM];\nint h[MN], nxt[MM], to[MM], K = 0;\n\nvoid ins(int u, int v) {nxt[++K] = h[u]; h[u] = K; to[K] = v;}\n\nvoid bfs(int S)\n{\n\thh = 0; tt = 0;\n\tmemset(d, -1, sizeof(d));\n\tfor(int i = h[S]; i; i = nxt[i])\n\t\td[to[i]][0] = P(1, to[i]), q[tt++] = P(to[i], 0);\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh].first, o = q[hh].second; hh++;\n\t\tfor(int i = h[u]; i; i = nxt[i])\n\t\t{\n\t\t\tif(to[i] == S) continue;\n\t\t\tif(d[to[i]][0].first == -1)\n\t\t\t{\n\t\t\t\td[to[i]][0].first = d[u][o].first + 1;\n\t\t\t\td[to[i]][0].second = d[u][o].second;\n\t\t\t\tq[tt++] = P(to[i], 0);\n\t\t\t}\n\t\t\telse if(d[to[i]][1].first == -1 && d[to[i]][0].second != d[u][o].second)\n\t\t\t{\n\t\t\t\td[to[i]][1].first = d[u][o].first + 1;\n\t\t\t\td[to[i]][1].second = d[u][o].second;\n\t\t\t\tq[tt++] = P(to[i], 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tins(x[i], y[i]);\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tbfs(i);\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(d[j][0].second != j) Ans[i][j] = d[j][0].first;\n\t\t\telse Ans[i][j] = d[j][1].first;\n\t\t\tAns2[i][j] = d[j][0].first; \n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++) \n\t{\n\t\tif(Ans[x[i]][y[i]] == -1 && Ans2[y[i]][x[i]] != -1 || Ans[x[i]][y[i]] != -1 && Ans2[y[i]][x[i]] == -1)\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n \nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[N] , B[N];\nint stk[N] , top;\nint ans[M];\nint L[N][N], R[N][N];\n\nvoid add(int x, int y) {\n\tne[++ cnt] = fir[x];\n\tfir[x] = cnt;\n\tto[cnt] = y;\n}\n\nbool can[N][N];\n\nqueue <int> q;\n\nvector <int> son[N];\n\n#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\nvoid solve(int x) {\n\twhile(!q.empty()) q.pop();\n\tq.push(x);\n\twhile(!q.empty()) {\n\t\tint ind = q.front();\n\t\tcan[x][ind] = 1;\n\t\tq.pop();\n\t\tForeachson(i, ind) {\n\t\t\tint V = to[i];\n\t\t\tif(can[x][V]) continue;\n\t\t\tq.push(V);\n\t\t}\n\t}\n\t\n\tForeachson(i, x) {\n\t\tint V = to[i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!L[x][V]) {\n\t\t\tq.push(V);\n\t\t\tL[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tForeachson(i, ind) {\n\t\t\t\tint v = to[i];\n\t\t\t\tif(!L[x][v] && v != x) {\n\t\t\t\t\tL[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < (int) son[x].size(); ++ i) {\n\t\tint V = son[x][i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!R[x][V]) {\n\t\t\tq.push(V);\n\t\t\tR[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < (int) son[ind].size(); ++ i) {\n\t\t\t\tint v = son[ind][i];\n\t\t\t\tif(!R[x][v] && v != x) {\n\t\t\t\t\tR[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x, y);\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tForeachson(j, i) {\n\t\t\tint V = to[j];\n\t\t\tson[i].push_back(V);\n\t\t}\n\t\treverse(son[i].begin(), son[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tsolve(i);\n\t}\n\t\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(L[A[i]][B[i]] != B[i] || R[A[i]][B[i]] != B[i]) {\n\t\t\tif(!can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\telse {\n\t\t\tif(can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nint n,m,u[210000],v[210000],tmp[1100][2];\nbool ans1[1100][1100],ans2[1100][1100];\nvector<int> vec[1100];\nvoid dfs(int u,int rt){\n    ans1[rt][u]=true;\n    for(int i=0;i<vec[u].size();i++)\n        if (!ans1[rt][vec[u][i]]) dfs(vec[u][i],rt);\n}\nvoid dfs2(int u,int num,int f){\n    tmp[u][f]=num;\n    for(int i=0;i<vec[u].size();i++)\n        if (!tmp[vec[u][i]][f]) dfs2(vec[u][i],num,f);\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=m;i++){\n        scanf(\"%d%d\",&u[i],&v[i]);\n        vec[u[i]].push_back(v[i]);\n    }\n    for (int i=1;i<=n;i++) dfs(i,i);\n    for (int i=1;i<=n;i++){\n        memset(tmp,0,sizeof(tmp));\n        tmp[i][0]=-1; tmp[i][1]=-1;\n        for (int j=0;j<vec[i].size();j++)\n            if (!tmp[vec[i][j]][0]) dfs2(vec[i][j],j+1,0);\n        for (int j=vec[i].size()-1;j>=0;j--)\n            if (!tmp[vec[i][j]][1]) dfs2(vec[i][j],j+1,1);\n        for (int j=0;j<vec[i].size();j++)\n            if (tmp[vec[i][j]][0]!=j+1||tmp[vec[i][j]][1]!=j+1) ans2[i][vec[i][j]]=true;\n    }\n    for (int i=1;i<=m;i++)\n        if (ans1[v[i]][u[i]]==ans2[u[i]][v[i]]) puts(\"same\");\n        else puts(\"diff\");\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 1000;\n\nint N, M;\nint a[MAX_N], b[MAX_N];\nbool G[MAX_N][MAX_N];\nbool visited[MAX_N];\n\nbool bfs(int s, int t){\n\tvisited[s] = true;\n\tqueue<int> qa;\n\tqa.push(s);\n\twhile(!qa.empty()){\n\t\tint u = qa.front(); qa.pop();\n\t\tfor(int v = 0; v < N; v++){\n\t\t\tif(G[u][v] && !visited[v]){\n\t\t\t\tqa.push(v);\n\t\t\t\tvisited[v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn visited[t];\n}\n\nint main(){\n\tcin >> N >> M;\n\tfill(G[0], G[N], false);\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t\tG[a[i]][b[i]] = true;\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tfill(visited, visited + N, false);\n\t\tbool def1 = bfs(b[i], a[i]);\n\t\tfill(visited, visited + N, false);\n\t\tG[a[i]][b[i]] = false;\n\t\tbool def2 = bfs(a[i], b[i]);\n\t\tG[a[i]][b[i]] = true;\n\t\tif(!(def1 ^ def2)) cout << \"same\" << endl;\n\t\telse cout << \"diff\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n\ntypedef pair<int, int> P;\n\n#define fir first\n#define sec second\n\nvector<P> G[N];\n\nbool mark[N][N], vis[N]; int ct[N][N], mp[N][N];\n\nint rt, n; \n\nvoid dfs(int u, int type) {\n    vis[u] = 1;\n    if (mp[rt][u] && !mark[rt][u]) ct[rt][u] |= 1;\n    if (!type) {\n        for (auto v : G[u]) if (!vis[v.sec])\n            mark[u][v.sec] = 1, dfs(v.sec, type), mark[u][v.sec] = 0;\n    } else for (int i = G[u].size() - 1; i >= 0; i--) if (!vis[G[u][i].sec])\n        mark[u][G[u][i].sec] = 1, dfs(G[u][i].sec, type), mark[u][G[u][i].sec] = 0;\n}\n\ninline void clr() {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\ninline void solve(int u) {\n    rt = u, clr(), dfs(u, 0), clr(), dfs(u, 1);\n    for (int i = 1; i <= n; i++) if (vis[i]) ct[i][u] |= 2;\n}\n\nint ans[N * 20];\n\nint main() {\n    int m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(P(i, b)), mp[a][b]++;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) if (mp[i][j] > 1) ct[i][j] |= 1;\n    for (int i = 1; i <= n; i++) sort(G[i].begin(), G[i].end());\n    for (int i = 1; i <= n; i++) solve(i);\n    for (int i = 1; i <= n; i++) for (auto v : G[i]) \n        if (ct[i][v.sec] != 0 && ct[i][v.sec] != 3) ans[v.fir] = 1;\n    for (int i = 1; i <= m; i++) puts(ans[i] ? \"diff\" : \"same\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma optimize(\"Ofast\")\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 1005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint id, to, nxt;\n} graph[M];\nint head[N], n, m, cnt = 0;\nbool g[N][N];\n\nvoid addedge (int id, int u, int v) {\n\tedge e = {id, v, head[u]};\n\tgraph[head[u] = cnt++] = e;\n}\n\nint s, t, vis_mn[N][N], vis_mx[N][N], ans[M];\nvoid dfs1 (int u) {\n\tif (vis_mn[s][u]) return ;\n\tvis_mn[s][u] = t;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (v == s) continue;\n\t\tdfs1(v);\n\t}\n}\n\nvoid dfs2 (int u) {\n\tif (vis_mx[s][u]) return ;\n\tvis_mx[s][u] = t;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (v == s) continue;\n\t\tdfs2(v);\n\t}\n}\n\nint main () {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) {\n\t\thead[i] = -1;\n\t\tfor (int j = 1; j <= n; j++) g[i][j] = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\taddedge(i, u, v), g[u][v] = true;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) vis_mn[i][j] = vis_mx[i][j] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (g[i][j]) s = i, t = j, dfs1(j);\n\t\t}\n\t\tfor (int j = n; j; j--) {\n\t\t\tif (g[i][j]) s = i, t = j, dfs2(j);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = head[i]; ~j; j = graph[j].nxt) {\n\t\t\tint u = i, v = graph[j].to;\n\t\t\tbool ans1 = vis_mn[v][u], ans2 = (vis_mn[u][v] < vis_mx[u][v]);\n\t\t\tans[graph[j].id] = (ans1 == ans2);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) puts(ans[i] ? \"same\" : \"diff\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1003,M=200005;\nusing namespace std;\nint n,m,to[M],hd[M],lk[N],\nu,nl[N],nr[N],st[N],t;\nbool mp[N][N],ans[M];\nvoid dfs(int x){\n\tif(mp[u][x])return;\n\tmp[u][x]=1;\n\tfor(int i=lk[x];i;i=hd[i])\n\tdfs(to[i]);\n}\nvoid ssfd(int x){\n\tnl[x]=t;\n\tfor(int s,i=lk[x];i;i=hd[i])\n\tif(!nl[s=to[i]]&&s^u)ssfd(s);\n}\nvoid dfss(int x){\n\tnr[x]=t;\n\tfor(int s,i=lk[x];i;i=hd[i])\n\tif(!nr[s=to[i]]&&s^u)dfss(s);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,to+i);\n\t\thd[i]=lk[u],lk[u]=i;\n\t}\n\tfor(int i=1;i<=n;i++)dfs(u=i);\n\tfor(int i=1;i<=n;i++){\n\t\tt=0,u=i;\n\t\tfor(int j=1;j<=n;j++)\n\t\tnl[j]=nr[j]=0;\n\t\tfor(int j=lk[i];j;j=hd[j])\n\t\tif(!nl[to[st[++t]=j]])ssfd(to[j]);\n\t\tfor(int s;t;t--){\n\t\tif(!nr[s=to[st[t]]])dfss(s);\n\t\t//cerr<<st[t]<<\":\"<<i<<\"->\"<<s<<' '<<mp[s][i]<<','<<nl[s]<<','<<nr[s]<<endl,\n\t\tans[st[t]]=mp[s][i]^(nl[s]<t||nr[s]>t);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\tputs(ans[i]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint ans[200010];\nvector<int> adj[1010], radj[1010], sadj[1010], U, V;\nint tin[1010], bck[1010], id[1010], timer, scnt;\nstack<int> stk;\n\nvoid dfs(int u) {\n    tin[u] = timer++;\n    bck[u] = tin[u];\n    stk.push(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int e = adj[u][i];\n        int v = V[e];\n        if(tin[v] == -1) {\n            dfs(v);\n            bck[u] = min(bck[u], bck[v]);\n        }\n        else if(id[v] == -1) {\n            bck[u] = min(bck[u], tin[v]);\n        }\n    }\n    if(bck[u] == tin[u]) {\n        while(1) {\n            int t = stk.top(); stk.pop();\n            id[t] = scnt;\n            if(t == u) break;\n        }\n        scnt++;\n    }\n}\n\nint cc[1010][1010];\nint dp(int u, int d) {\n    int &ret = cc[u][d];\n    if(ret != -1) return ret;\n    if(u == d) return ret = 0;\n\n    ret = 0;\n    for(int i = 0; i < sadj[u].size(); i++) {\n        int e = sadj[u][i];\n        int v = id[ V[e] ];\n        ret = max(ret, 1 + dp(v, d));\n    }\n    return ret;\n}\n\nvoid scc() {\n    memset(tin, -1, sizeof(tin));\n    memset(id, -1, sizeof(id));\n    for(int i = 0; i < N; i++) if(tin[i] == -1) {\n        dfs(i);\n    }\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            sadj[ id[u] ].push_back(e);\n        }\n    }\n    memset(cc, -1, sizeof(cc));\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            if(dp(id[u], id[v]) > 1) ans[e] = 1;\n            else ans[e] = 0;\n        }\n    }\n}\n\nqueue<int> q1, q2;\nint dist1[1010], dist2[1010], par1[1010], par2[1010];\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < M; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(i);\n        radj[v].push_back(i);\n        U.push_back(u);\n        V.push_back(v);\n    }\n\n    scc();\n\n    for(int u = 0; u < N; u++) {\n        memset(dist1, -1, sizeof(dist1));\n        memset(dist2, -1, sizeof(dist2));\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                q1.push(v);\n                dist1[v] = 0;\n                par1[v] = v;\n            }\n        }\n        while(!q1.empty()) {\n            int t = q1.front(); q1.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist1[v] == -1) {\n                        dist1[v] = dist1[t] + 1;\n                        par1[v] = par1[t];\n                        q1.push(v);\n                    }\n                    else if(dist2[v] == -1 && par1[v] != par1[t]) {\n                        dist2[v] = dist1[t] + 1;\n                        par2[v] = par1[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n        while(!q2.empty()) {\n            int t = q2.front(); q2.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist2[v] == -1 && par1[v] != par2[t]) {\n                        dist2[v] = dist2[t] + 1;\n                        par2[v] = par2[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                if(dist2[v] != -1) ans[e] = 0;\n                else ans[e] = 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++) {\n        if(ans[i]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nint n, m;\nint ghead[MAXN], gnxt[MAXM], gto[MAXM];\nint rhead[MAXN], rnxt[MAXM], rto[MAXM];\n\nint ans[MAXM];\n\nint cur[MAXN], ncur;\nint q[MAXN], qhead, qtail;\nint mn[MAXN], mx[MAXN]; bool reach[MAXN];\n\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &m);\n\tREP(i, n) ghead[i] = -1, rhead[i] = -1;\n\tREP(i, m) { \n\t\tint a, b; scanf(\"%d%d\", &a, &b); --a, --b;\n\t\tgnxt[i] = ghead[a], ghead[a] = i, gto[i] = b; \n\t\trnxt[i] = rhead[b], rhead[b] = i, rto[i] = a;\n\t}\n\n\tREP(i, m) ans[i] = -1;\n\tREP(i, n) {\n\t\tncur = 0; for (int x = ghead[i]; x != -1; x = gnxt[x]) cur[ncur++] = x;\n\t\tREP(j, n) mn[j] = INT_MAX; mn[i] = -1; qhead = qtail = 0;\n\t\tREP(j, ncur) { \n\t\t\tint x = cur[j], rt = gto[x]; if (mn[rt] != INT_MAX) continue;\n\t\t\tq[qhead++] = rt; mn[rt] = j;\n\t\t\twhile (qtail < qhead) { int at = q[qtail++]; for (int y = ghead[at]; y != -1; y = gnxt[y]) { int to = gto[y]; if (mn[to] == INT_MAX) mn[to] = j, q[qhead++] = to; } }\n\t\t}\n\t\tREP(j, n) mx[j] = INT_MIN; mx[i] = -1; qhead = qtail = 0;\n\t\tfor (int j = ncur - 1; j >= 0; --j) {\n\t\t\tint x = cur[j], rt = gto[x]; if (mx[rt] != INT_MIN) continue;\n\t\t\tq[qhead++] = rt; mx[rt] = j;\n\t\t\twhile (qtail < qhead) { int at = q[qtail++]; for (int y = ghead[at]; y != -1; y = gnxt[y]) { int to = gto[y]; if (mx[to] == INT_MIN) mx[to] = j, q[qhead++] = to; } }\n\t\t}\n\t\tREP(j, n) reach[j] = false; qhead = qtail = 0;\n\t\tq[qhead++] = i; reach[i] = true;\n\t\twhile (qtail < qhead) { int at = q[qtail++]; for (int y = rhead[at]; y != -1; y = rnxt[y]) { int to = rto[y]; if (!reach[to]) reach[to] = true, q[qhead++] = to; } }\n\t\tREP(j, ncur) {\n\t\t\tint x = cur[j], to = gto[x];\n\t\t\tbool ab = mn[to] != mx[to], ba = reach[to];\n\t\t\t//printf(\"%d->%d: ab=%d ba=%d\\n\", i + 1, to + 1, ab ? 1 : 0, ba ? 1 : 0);\n\t\t\tans[x] = ab == ba ? 0 : 1;\n\t\t}\n\t}\n\n\tREP(i, m) printf(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <map>\n#include <utility>\nusing namespace std;\n\ntypedef long long lint;\n#define p(a,b) make_pair(a,b)\n\nint main(){\n    lint N,M;\n    cin >> N >> M;\n    vector<int> edge[1001];\n    for(int i=1;i<=1000;i++) edge[i].clear();\n    int *A,*B;\n    A=new int[M+1];\n    B=new int[M+1];\n    map<pair<int,int>,int> eind;\n    for(int i=1;i<=M;i++){\n        int a,b;\n        cin >> a >> b;\n        A[i]=a;\n        B[i]=b;\n        edge[a].push_back(b);\n        eind[p(a,b)]=i;\n    }\n\n    bool *conn;\n    conn=new bool[M+1];\n    for(int i=1;i<=M;i++) conn[i]=false;\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=N;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=0;e+1<edge[v].size();e++){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e+1]]) conn[eind[p(v,edge[v][e+1])]]=true;\n        }\n    }\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=1000;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=-1+edge[v].size();e>0;e--){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e-1]]) conn[eind[p(v,edge[v][e-1])]]=true;\n        }\n    }\n\n    bool map[1001][1001];\n    for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++){\n            map[i][j]=(i==j);\n        }\n    }\n    for(int v=1;v<=N;v++){\n        stack<int> prev;\n        prev.push(v);\n        while(!prev.empty()){\n            int t=prev.top();\n            prev.pop();\n            map[v][t]=true;\n            for(int x:edge[t]){\n                if(!map[v][x]) prev.push(x);\n            }\n        }\n    }\n\n    for(int i=1;i<=M;i++){\n        if(map[B[i]][A[i]]==conn[i]) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n\n    delete[] A,B,conn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,M=200005,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,m,ans[M];\nbitset<N> h,a[N];\nvector< pair<int,int> > e[N];\nvoid work(int x){\n\th[x]=1;\n\tfor (auto t : e[x])\n\tif (!h[t.first]) work(t.first);\n}\nint main(){\n\tn=read();m=read();\n\tfor (int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\te[u].push_back(make_pair(v,i));\n\t}\n\tfor (int x=1;x<=n;x++){\n\t\th.reset();h[x]=1;\n\t\tfor (auto t : e[x]){\n\t\t\tint y=t.first;\n\t\t\tif (h[y]) ans[t.second]=1;\n\t\t\telse work(y);\n\t\t}\n\t\ta[x]|=h;\n\t\th.reset();h[x]=1;\n\t\treverse(e[x].begin(),e[x].end());\n\t\tfor (auto t : e[x]){\n\t\t\tint y=t.first;\n\t\t\tif (h[y]) ans[t.second]=1;\n\t\t\telse work(y);\n\t\t}\n\t}\n\tfor (int x=1;x<=n;x++)\n\tfor (auto t : e[x]){\n\t\tint y=t.first,i=t.second;\n\t\tans[i]^=a[y][x];\n\t}\n\tfor (int i=1;i<=m;i++) puts(ans[i] ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1005;\nconst int M=200005;\nstruct edge{\n\tint to,next;\n}e[M];\nint head[N],tot;\nint n,m,x[M],y[M];\nint co1[N][N],co2[N][N];\nint vis[N],q[N];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nvoid dfs(int x,int co){\n\tvis[x]=co;\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (!vis[e[i].to])\n\t\t\tdfs(e[i].to,co);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,m){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tadd(x[i],y[i]);\n\t}\n\tFor(i,1,n){\n\t\t*q=0;\n\t\tfor (int j=head[i];j;j=e[j].next)\n\t\t\tq[++*q]=e[j].to;\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tFor(j,1,*q) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co1[i][j]=vis[j];\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tRep(j,*q,1) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co2[i][j]=vis[j];\n\t}\n\tFor(i,1,m){\n\t\tbool f1=(co1[y[i]][x[i]]!=0);\n\t\tbool f2=(co2[x[i]][y[i]]&&co2[x[i]][y[i]]!=y[i])||\n\t\t\t\t(co1[x[i]][y[i]]&&co1[x[i]][y[i]]!=y[i]);\n\t\tputs(f1^f2?\"diff\":\"same\");\n\t}\n}\n/*\n3 3\n1 2\n1 3\n2 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing bstype = std::bitset<1000>;\nint vis[1000];\nbstype bs[1000];\nbstype bs2[1000];\nbstype bs3[1000];\nstd::pair<int,int> p[200003];\nint n,m;\nint q[1000],qa,qb;\nint vis1[1000],vis2[1000];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0;i < m;++i) {\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);--a,--b;\n\t\tp[i].first = a;p[i].second = b;\n\t\tbs[a][b] = 1;\n\t}\n\tfor(int i = 0;i < n;++i) {\n\t\tq[0] = i;qa = 0;qb = 1;bs2[i][i] = 1;\n\t\twhile(qa < qb) {\n\t\t\tint cur = q[qa++];\n\t\t\tbstype nex = ~bs2[i]&bs[cur];\n\t\t\tbs2[i] |= nex;\n\t\t\tfor(int j = 0;j < n;++j) if(nex[j]) q[qb++] = j;\n\t\t}\n\t}\n\t// 0->2?\n\tfor(int i = 0;i < n;++i) {\n\t\tmemset(vis1,-1,sizeof(vis1));\n\t\tmemset(vis2,-1,sizeof(vis2));\n\t\tbstype v1, v2;\n\t\tfor(int j = 0;j < n;++j) if(bs[i][j] && vis1[j] == -1) {\n\t\t\tq[0] = j;qa = 0;qb = 1;vis1[j] = j;v1[i] = v1[j] = true;\n\t\t\twhile(qa < qb) {\n\t\t\t\tint cur = q[qa++];\n\t\t\t\tbstype res = ~v1&bs[cur];\n\t\t\t\tv1 |= res;\n\t\t\t\tfor(int k = 0;k < n;++k) if(res[k]) {\n\t\t\t\t\tvis1[k] = j;\n\t\t\t\t\tq[qb++] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = n-1;j >= 0;--j) if(bs[i][j] && vis2[j] == -1) {\n\t\t\tq[0] = j;qa = 0;qb = 1;vis2[j] = j;v2[i] = v2[j] = true;\n\t\t\twhile(qa < qb) {\n\t\t\t\tint cur = q[qa++];\n\t\t\t\tbstype res = ~v2&bs[cur];\n\t\t\t\tv2 |= res;\n\t\t\t\tfor(int k = 0;k < n;++k) if(res[k]) {\n\t\t\t\t\tvis2[k] = j;\n\t\t\t\t\tq[qb++] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < n;++j) if(vis1[j] != vis2[j]) bs3[i][j] = 1;\n\t}\n\tfor(int i = 0;i < m;++i) {\n\t\tint a = p[i].first, b = p[i].second;\n\t\tif(bs2[b][a] == bs3[a][b]) {\n\t\t\tprintf(\"same\\n\");\n\t\t} else {\n\t\t\tprintf(\"diff\\n\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nint a[maxm], b[maxm];\nint head[maxn], nxt[maxm], to[maxm], tot;\nint x[maxm], v[maxn][maxn], y[maxm], vis1[maxn], vis2[maxn];\nint s[maxm], S;\nint rt;\nint *vis;\n\nvoid add(int x, int y) {\n\t++tot;\n\tnxt[tot] = head[x];\n\tto[tot] = y;\n\thead[x] = tot;\n}\n\nvoid dfs2(int u) {\n\tv[rt][u] = 1;\n\tfor (int e = head[u]; e; e = nxt[e]) {\n\t\tint v = to[e];\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = vis[u];\n\t\t\tdfs2(v);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", a+i, b+i);\n\t\tadd(a[i], b[i]);\n\t}\n\tfor (rt = 1; rt <= n; ++rt) {\n\t\tmemset(vis1, 0, sizeof(vis1));\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis1[rt] = vis2[rt] = rt;\n\t\tvis = vis1;\n\t\tS = 0;\n\t\tfor (int e = head[rt]; e; e = nxt[e]) {\n\t\t\ts[S++] = e;\n\t\t\tint j = to[e];\n\t\t\tif (!vis[j]) vis[j] = e, dfs2(j);\n\t\t}\n\t\tvis = vis2;\n\t\twhile (S) {\n\t\t\tint e = s[--S];\n\t\t\tint j = to[e];\n\t\t\tif (!vis[j]) vis[j] = e, dfs2(j);\n\t\t\tif (vis2[j] == vis1[j]) y[e] = false;\n\t\t\telse y[e] = true;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tputs(v[b[i]][a[i]]^y[i]?\"diff\":\"same\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=2e5+10;\nint w[M],ne[M],la[N],t,ans[M];\nvoid link(int x,int y){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n}\nint arv[N][N],n,m,X,mrk[N],ti,mrk2[N];\nvoid dfs(int x){\n\tarv[X][x]=1;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (!arv[X][w[y]])dfs(w[y]);\n}\nvoid go(int x){\n\tmrk[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk[w[y]])go(w[y]);\n}\nvoid go2(int x){\n\tmrk2[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk2[w[y]])go2(w[y]);\n}\nvector<int> c;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tfor (X=1;X<=n;X++)dfs(X);\n\tfor (X=1;X<=n;X++){\n\t\tfor (int i=1;i<=n;i++)mrk[i]=mrk2[i]=0;\n\t\tc.clear();\n\t\tfor (int y=la[X];y;y=ne[y]){\n\t\t\tti++;\n\t\t\tif (!mrk[w[y]])go(w[y]);\n\t\t\tc.push_back(w[y]);\n\t\t}\n\t\twhile (c.size()){\n\t\t\tif (!mrk2[c.back()])go2(c.back());\n\t\t\tc.pop_back();\n\t\t\tti--;\n\t\t}\n\t\tfor (int y=la[X];y;y=ne[y])\n\t\t\tans[y]=(mrk[w[y]]<mrk2[w[y]])==arv[w[y]][X];\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tputs(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1005;\nconst int M = 200005;\nbool not_necessary[N][N];\nvector<int> con[N];\nint a[M], b[M];\nint vis[N];\nint fe[N];\n\nstruct graph {\n  int n;\n  vector<vector<int>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst) {\n    adj[src].push_back(dst);\n  }\n\n  vector<vector<int>> strongly_connected_components() {\n    vector<vector<int>> scc;\n    vector<int> S, B, I(n);\n    function<void(int)> dfs = [&](int u) {\n      B.push_back(I[u] = S.size());\n      S.push_back(u);\n      for (int v: adj[u]) {\n        if (!I[v]) dfs(v);\n        else while (I[v] < B.back()) B.pop_back();\n      }\n      if (I[u] == B.back()) {\n        scc.push_back({});\n        B.pop_back();\n        for (; I[u] < S.size(); S.pop_back()) {\n          scc.back().push_back(S.back());\n          I[S.back()] = n + scc.size();\n        }\n      }\n    };\n    for (int u = 0; u < n; ++u)\n      if (!I[u]) dfs(u);\n    return scc; // I[u] - n is the index of u\n  }\n};\n\n\nint main(){\n\tint n, m; sd(n); sd(m);\n\tgraph g(n + 1);\n\tfor(int i = 1; i <= m; i++){\n\t\tsd(a[i]);\n\t\tsd(b[i]);\n\t\tcon[a[i]].push_back(b[i]);\n\t\tg.add_edge(a[i], b[i]);\n\t}\n\tvector<vector<int>> comp = g.strongly_connected_components();\n\tvector<int> where(n + 1);\n\tfor(int i = 0; i < comp.size(); i++)\n\t\tfor(auto it : comp[i])\n\t\t\twhere[it] = i;\n\tqueue<pii> q;\n\tfor(int i = 1; i <= n; i++){\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int v : con[i]){\n\t\t\tq.push({v, v});\n\t\t\tvis[v] = 1;\n\t\t\tfe[v] = v;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tauto it = q.front();\n\t\t\tq.pop();\n\t\t\tint u = it.F, firstEdge = it.S;\n\t\t\tfor(int v : con[u]){\n\t\t\t\tif(v == i || vis[v] >= 2) continue;\n\t\t\t\tif(vis[v] == 1 && firstEdge == fe[v]) continue;\n\t\t\t\tq.push({v, firstEdge});\n\t\t\t\tif(vis[v] == 0)\n\t\t\t\t\tfe[v] = firstEdge;\n\t\t\t\tvis[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int v : con[i]) if(vis[v] == 2){\n\t\t\tnot_necessary[i][v] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tprintf( (not_necessary[a[i]][b[i]] ^ (where[a[i]] != where[b[i]] )) ? \"same\\n\" : \"diff\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo[1010];\nint n,m,mi[1010],ma[1010],bel[1010],sta[1010],tp,dfn[1010],low[1010],x,y,cnt,hd[1010],t[1010],tn;\nstruct node{int to,next,ans;}e[200010];\n\nvoid addedge(int x,int y) {e[++cnt]=(node){y,hd[x],0},hd[x]=cnt;}\n\nvoid tarjan(int x)\n{\n\tdfn[x]=low[x]=(++cnt),sta[++tp]=x,bo[x]=1;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tif (!dfn[e[i].to]) tarjan(e[i].to),low[x]=min(low[x],low[e[i].to]);\n\t\telse if (bo[e[i].to]) low[x]=min(low[x],dfn[e[i].to]);\n\tif (dfn[x]==low[x])\n\t{\n\t\tbel[x]=x;\n\t\twhile (sta[tp]!=x) bel[sta[tp]]=x,bo[sta[tp]]=0,tp--;\n\t\ttp--,bo[x]=0;\n\t}\n}\n\nvoid dfs(int x,int v)\n{\n\tmi[x]=v;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tif (mi[e[i].to]==-1) dfs(e[i].to,v);\n}\n\nvoid Dfs(int x,int v)\n{\n\tma[x]=v;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tif (ma[e[i].to]==-1) Dfs(e[i].to,v);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),cnt=0;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),addedge(x,y);\n\tmemset(bo,0,sizeof(bo)),tp=cnt=0;\n\tfor (int i=1; i<=n; i++) if (!dfn[i]) tarjan(i);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ttn=0;\n\t\tfor (int j=hd[i]; j; j=e[j].next) t[++tn]=e[j].to;\n\t\tfor (int j=1; j<=n; j++) mi[j]=ma[j]=-1;\n\t\tmi[i]=ma[i]=0;\n\t\tfor (int j=1; j<=tn; j++) if (mi[t[j]]==-1) dfs(t[j],j);\n\t\tfor (int j=tn; j; j--) if (ma[t[j]]==-1) Dfs(t[j],j);\n\t\tfor (int j=hd[i]; j; j=e[j].next)\n\t\t\te[j].ans=((mi[e[j].to]!=ma[e[j].to])^(bel[i]==bel[e[j].to]));\n\t}\n\tfor (int j=1; j<=m; j++) puts(e[j].ans?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[M],V[M],id,f[N],dfn[N],low[N];\nvector<int>e[N],d[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n        d[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=666;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis1[e[i][j]])\n            dfs1(e[i][j],d[i][j]);\n        for(int j=up-1;j>=0;j--)\n            if(!vis2[e[i][j]])\n            dfs2(e[i][j],d[i][j]);\n        for(int j=1;j<=n;j++)\n            if(vis1[j]&&j!=i)\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200200;\ninline int read(int x=0,bool f=0,char ch=getchar()){\n\tfor(;!isdigit(ch);ch=getchar()) f=ch=='-';\n\tfor(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\nint n,m,tot,fi[N],to[N],u[N],ne[N];\nbool vis[1010][1010];\nint pre[1010][1010],suf[1010][1010],que[N],l,r;\nvoid bfs(int x){\n\tque[l=r=1]=x; vis[x][x]=true;\n\twhile(l<=r){\n\t\tint y=que[l++];\n\t\tfor(int i=fi[y];i;i=ne[i]) if(!vis[x][to[i]]) vis[x][to[i]]=true,que[++r]=to[i];\n\t}\n}\nvoid dfs1(int x,int id,int k){\n\tpre[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!pre[id][to[i]]) dfs1(to[i],id,k);\n}\nvoid dfs2(int x,int id,int k){\n\tsuf[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!suf[id][to[i]]) dfs2(to[i],id,k);\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;++i) x=read(),y=read(),ne[++tot]=fi[x],u[tot]=x,to[fi[x]=tot]=y;\n\tfor(int i=1;i<=n;++i) bfs(i);\n\tfor(int i=1;i<=n;++i){\n\t\tvector<int> s; int sz=0; pre[i][i]=suf[i][i]=1;\n\t\tfor(int j=fi[i];j;j=ne[j]) s.push_back(to[j]);\n\t\tfor(int j:s){\n\t\t\t++sz;\n\t\t\tif(!pre[i][j]) dfs1(j,i,sz);\n\t\t}\n\t\treverse(s.begin(),s.end());\n\t\tfor(int j:s){\n\t\t\tif(!suf[i][j]) dfs2(j,i,sz);\n\t\t\t--sz;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint x=u[i],y=to[i];\n\t\tif(vis[y][x]^(pre[x][y]!=suf[x][y])) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 2005;\n\nconst int M = 4e5 + 5;\n\nint n, m, x, y;\nint fi[N], nt[M], to[M], tot;\n\nvoid link(int x, int y) {\n\tnt[++ tot] = fi[x], to[tot] = y, fi[x] = tot;\n}\n\nint bz[N];\n\nvoid dg(int x) {\n\tif(bz[x]) return;\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tdg(to[i]);\n}\n\nint b[N][N];\n\nint d[N], d0, ky[N];\n\nvoid dfs(int x) {\n\tif(bz[x]) return;\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tdfs(to[i]);\n}\n\n#define mem(a) memset(a, 0, sizeof a)\n\nint ans[M];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tlink(x, y);\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz);\n\t\tdg(st);\n\t\tfo(j, 1, n) b[st][j] = bz[j];\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz); mem(ky); d0 = 0;\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\td[++ d0] = to[i];\n\t\tbz[st] = 1;\n\t\tfo(i, 1, d0) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tmem(bz); bz[st] = 1;\n\t\tfd(i, d0, 1) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\tans[i] = b[to[i]][st] ^ ky[to[i]];\n\t}\n\tfo(i, 1, m) pp(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 1005\n#define M 200005\nusing namespace std;\nint read(){\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tcontinue;\n\t}\n\tint num=c^48;\n\tc=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tnum=num*10+(c^48);\n\t\tc=getchar();\n\t}\n\treturn num;\n}\nstruct Edge{\n\tint to,next,last;\n}edge[M];\nint head[N],tot,first[N];\nvoid addedge(int from,int to){\n\tedge[++tot].to=to;\n\tif(head[from]){\n\t\tedge[head[from]].last=tot;\n\t}else{\n\t\tfirst[from]=tot;\n\t}\n\tedge[tot].next=head[from];\n\thead[from]=tot;\n}\nint p1[N][N];\nvoid dfs1(int now,int p,int cnt){\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=cnt;\n\t\tdfs1(v,p,cnt);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p,int cnt){\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=cnt;\n\t\tdfs2(v,p,cnt);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tn=read();\n\tm=read();\n\tfor(int i=0;i<m;++i){\n\t\tu[i]=read();\n\t\tv[i]=read();\n\t\taddedge(u[i],v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tp1[i][i]=i;\n\t\tfor(int j=head[i];j;j=edge[j].next){\n\t\t\tint v=edge[j].to;\n\t\t\tif(p1[i][v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp1[i][v]=v;\n\t\t\tdfs1(v,i,v);\n\t\t}\n\t\tp2[i][i]=i;\n\t\tfor(int j=first[i];j;j=edge[j].last){\n\t\t\tint v=edge[j].to;\n\t\t\tif(p2[i][v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp2[i][v]=v;\n\t\t\tdfs2(v,i,v);\n\t\t}\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\n#define C(x,y) memset(x,y,sizeof(x))\n#define STS system(\"pause\")\ntemplate<class D>I read(D &res){\n\tres=0;register D g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nvector<int>e[1010];\nint n,m,now,tot,xu[1010],v[1010],a[202000],b[202000];\nint w[1010][1010],c[1010][1010];\nI D_1(int x){\n\tw[now][x]=v[x]=1;\n\tfor(auto d:e[x])if(!v[d])D_1(d);\n}\nI D_2(int x){\n\txu[x]=tot;v[x]=1;\n\tfor(auto d:e[x])if(!v[d])D_2(d);\n}\nI D_3(int x){\n\tif(xu[x]!=tot)c[now][x]=1;v[x]=1;\n\tfor(auto d:e[x])if(!v[d])D_3(d);\n}\nint main(){\n\tread(n);read(m);\n\tF(i,1,m){\n\t\tread(a[i]);read(b[i]);e[a[i]].emplace_back(b[i]);\n\t}\n\tF(i,1,n){\n\t\tnow=i;C(v,0);D_1(i);\n\t}\n//\tF(i,1,n){\n//\t\tF(j,1,n)cout<<w[i][j];\n//\t\tcout<<endl;\n//\t}\n\tF(i,1,n){\n\t\tnow=i;\n\t\tC(v,0);C(xu,0);tot=0;v[i]=1;\n\t\tfor(auto d:e[i]){\n\t\t\t++tot;\n\t\t\tif(!v[d])D_2(d);\n\t\t}\n\t\tC(v,0);re sz=e[i].size();v[i]=1;tot=sz+1;\n\t\tFOR(j,sz-1,0){\n\t\t\t--tot;\n\t\t\tif(!v[e[i][j]])D_3(e[i][j]);\n\t\t}\n\t}\n\tF(i,1,m){\n\t\tif(w[b[i]][a[i]]^c[a[i]][b[i]])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1010\n#define M 200100\nusing namespace std;\ninline void read(int &x)\n{\n\tx=0;\n\tstatic int p;p=1;\n\tstatic char c;c=getchar();\n\twhile(!isdigit(c)){if(c=='-')p=-1;c=getchar();}\n\twhile(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}\n\tx*=p;\n}\nint n,m,e,e1;\nint to[M],beg[N],nex[M];\nint to1[M],beg1[N],nex1[M];\nint vis[N],vis1[N],stan[M],stcn,sb;\nint cnt,pd,from[M],from1[M];\nint s[N],tot;\nvoid add(int x,int y)\n{\n    to[++e]=y;\n\tfrom[e]=x;\n    nex[e]=beg[x];\n    beg[x]=e;\n}\nvoid add1(int x,int y)\n{\n    to1[++e1]=y;\n\tfrom1[e1]=x;\n    nex1[e1]=beg1[x];\n    beg1[x]=e1;\n}\nvoid dfs1(int x)\n{\n    vis[x]=sb;\n\tif(to[pd]==x&&vis[from[pd]]!=sb)dfs1(from[pd]);\n    for(int i=beg[x];i;i=nex[i])\n        if(i!=pd&&vis[to[i]]!=sb)dfs1(to[i]);\n    s[++tot]=x;\n}\nvoid dfs2(int x)\n{\n    vis1[x]=sb;\n\tif(to1[pd]==x&&vis1[from1[pd]]!=sb)dfs2(from1[pd]);\n\tfor(int i=beg1[x];i;i=nex1[i])\n        if(i!=pd&&vis1[to1[i]]!=sb)dfs2(to1[i]);\n}\nint main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tread(n);read(m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tstatic int x,y;\n\t\tread(x);read(y);\n\t\tadd(x,y);add1(y,x);\n\t}\n\tsb=1;\n\tfor(register int i=1;i<=n;i++)\n\t\tif(vis[i]!=sb)dfs1(i);\n\tfor(register int i=tot;i>=1;i--)\n\t\tif(vis1[s[i]]!=sb)cnt++,dfs2(s[i]);\n\tstcn=cnt;\n\tfor(int j=1;j<=m;j++)\n\t{\n\t\tsb++;cnt=0;pd=j;tot=0;\n\t\tfor(register int i=1;i<=n;i++)\n\t\t\tif(vis[i]!=sb)dfs1(i);\n\t\tfor(register int i=tot;i>=1;i--)\n\t\t\tif(vis1[s[i]]!=sb)cnt++,dfs2(s[i]);\n\t\tif(cnt!=stcn)puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,id;\n}E[200005];\nint head[1005],sumE,M,N,a[200005],b[200005];\nbool a1[200005],a2[200005],mark[1005];\nint low[1005],dfn[1005],idx,sta[1005],top,instack[1005],col[1005],tot,cnt;\nbitset<1005> reachable[1005];\nvector<int> L[1005],v;\nvoid add(int u,int v,int id) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].id = id;\n    head[u] = sumE;\n}\n\nvoid Tarjan(int u) {\n    dfn[u] = low[u] = ++idx;\n    sta[++top] = u;\n    instack[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!dfn[v]) {Tarjan(v);low[u] = min(low[v],low[u]);}\n\telse if(instack[v] == 1) low[u] = min(low[u],dfn[v]);\n    }\n    if(low[u] == dfn[u]) {\n\t++tot;\n\twhile(1) {\n\t    int x = sta[top--];\n\t    col[x] = tot;\n\t    L[tot].pb(x);\n\t    instack[x] = 2;\n\t    if(x == u) break;\n\t}\n\tint s = L[tot].size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    for(int j = 0 ; j < s ; ++j) {\n\t\treachable[L[tot][i]][L[tot][j]] = 1;\n\t    }\n\t}\n    }\n}\nvoid dfs(int u) {\n    if(mark[u]) return;\n    mark[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!mark[v]) dfs(v);\n    }\n}\nvoid Solve() {\n    read(N);read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(a[i]);read(b[i]);\n\tadd(a[i],b[i],i);\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(!dfn[i]) Tarjan(i);\n    }\n    \n    for(int i = 1 ; i <= tot ; ++i) {\n\tint s = L[i][0];\n\tfor(auto k : L[i]) {\n\t    for(int j = head[k] ; j ; j = E[j].next) {\n\t\tint v = E[j].to;\n\t\tif(col[v] != i) reachable[s] |= reachable[v];  \n\t    }\n\t}\n\tfor(auto k : L[i]) {\n\t    if(k != s) reachable[k] |= reachable[s];\n\t}\n    }\n    for(int u = 1 ; u <= N ; ++u) {\n\tv.clear();\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    v.pb(E[i].id);\n\t}\n\tmemset(mark,0,sizeof(mark));\n\tmark[u] = 1;\n\tint s = v.size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    dfs(b[v[i]]);\n\t}\n\tmemset(mark,0,sizeof(mark));\n\tmark[u] = 1;\n\tfor(int i = s - 1 ; i >= 0 ; --i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    dfs(b[v[i]]);\n\t}\n    }\n    for(int i = 1 ; i <= M ; ++i) {\n\tif(reachable[b[i]][a[i]]) a1[i] = 1;\n\tif(a1[i] ^ a2[i]) puts(\"diff\");\n\telse puts(\"same\");\n    }\n    \n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\nstruct MaxFlow{\n\tusing D = int;\n\tconst D inf = 1e9;\n\tstruct edge{\n\t\tint to;\n\t\tD cap;\n\t\tint rev;\n\t\tedge(int to,D cap,int rev):to(to),cap(cap),rev(rev){}\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\n\tMaxFlow(int V):V(V){\n\t\tG = vector<vector<edge>>(V);\n\t\tlevel = vector<int>(V);\n\t\titer = vector<int>(V);\n\t}\n\n\tvoid add_edge(int from, int to, D cap){\n\t\tedge e1(to,cap,(int)G[to].size());\n\t\tedge e2(from,0,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tvoid bfs(int s){\n\t\tlevel = vector<int>(V,-1);\n\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tD dfs(int v,int t,D f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tD d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tD max_flow(int s,int t){\n\t\tD flow=0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tD f;\n\t\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t\t}\n\t}\n};\n\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\tMaxFlow MF(N*2+2);\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tMF.add_edge(a,b,10000);\n\t}\n\tint S = N*2, T = N*2+1;\n\trep(i,N){\n\t\tMF.add_edge(S,i,10001);\n\t\tMF.add_edge(i+N,T,10001);\n\t}\n\tint ans = 2*N - MF.max_flow(S,T)%10000;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1005;\nconst int M = 200005;\nbool edge[N][N];\nbool not_necessary[N][N];\nvector<int> con[N];\nint a[M], b[M];\nint vis[N];\nint fe[N];\n\nstruct graph {\n  int n;\n  vector<vector<int>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst) {\n    adj[src].push_back(dst);\n  }\n\n  vector<vector<int>> strongly_connected_components() {\n    vector<vector<int>> scc;\n    vector<int> S, B, I(n);\n    function<void(int)> dfs = [&](int u) {\n      B.push_back(I[u] = S.size());\n      S.push_back(u);\n      for (int v: adj[u]) {\n        if (!I[v]) dfs(v);\n        else while (I[v] < B.back()) B.pop_back();\n      }\n      if (I[u] == B.back()) {\n        scc.push_back({});\n        B.pop_back();\n        for (; I[u] < S.size(); S.pop_back()) {\n          scc.back().push_back(S.back());\n          I[S.back()] = n + scc.size();\n        }\n      }\n    };\n    for (int u = 0; u < n; ++u)\n      if (!I[u]) dfs(u);\n    return scc; // I[u] - n is the index of u\n  }\n};\n\n\nint main(){\n\tint n, m; sd(n); sd(m);\n\tgraph g(n + 1);\n\tfor(int i = 1; i <= n; i++){\n\t\tsd(a[i]);\n\t\tsd(b[i]);\n\t\tcon[a[i]].push_back(b[i]);\n\t\tg.add_edge(a[i], b[i]);\n\t}\n\tvector<vector<int>> comp = g.strongly_connected_components();\n\tvector<int> where(n + 1);\n\tfor(int i = 0; i < comp.size(); i++)\n\t\tfor(auto it : comp[i])\n\t\t\twhere[it] = i;\n\tqueue<pii> q;\n\tfor(int i = 1; i <= n; i++){\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int v : con[i]){\n\t\t\tq.push({v, v});\n\t\t\tvis[v] = 1;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tauto it = q.front();\n\t\t\tq.pop();\n\t\t\tint u = it.F, firstEdge = it.S;\n\t\t\tfor(int v : con[u]){\n\t\t\t\tif(v == i || vis[v] >= 2) continue;\n\t\t\t\tif(vis[v] == 1 && firstEdge == fe[v]) continue;\n\t\t\t\tq.push({v, firstEdge});\n\t\t\t\tif(vis[v] == 0)\n\t\t\t\t\tfe[v] = firstEdge;\n\t\t\t\tvis[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int v : con[i]) if(vis[v] == 2){\n\t\t\tnot_necessary[i][v] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tprintf( (not_necessary[a[i]][b[i]] ^ (where[a[i]] != where[b[i]] )) ? \"same\\n\" : \"diff\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace SCC {\n\tconst int N = 110000;\n\tvector<int> con[N], rcon[N];\n\tint n, vis[N], visT;\n\tint id[N], idn;\n\tvoid init(int nn = 0) {\n\t\tn = nn, visT = idn = 0;\n\t\tfor (int i = 1; i <= n; i++) con[i].clear(), rcon[i].clear();\n\t}\n\tvoid add_edge(int u, int v) {\n\t\tcon[u].push_back(v);\n\t\trcon[v].push_back(u);\n\t}\n\tvoid dfs(int u) {\n\t\tvis[u] = 1;\n\t\tfor (int v : con[u]) if (!vis[v]) dfs(v);\n\t\tid[idn++] = u;\n\t}\n\tvoid rdfs(int u) {\n\t\tvis[u] = visT;\n\t\tfor (int v : rcon[u]) if (!vis[v]) rdfs(v);\n\t}\n\tvoid SCC() {\n\t\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\t\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n\t\tfor (int i = idn - 1; i >= 0; i--) if (!vis[id[i]]) visT++, rdfs(id[i]);\n\t}\n};\n\nconst int N = 1100;\nconst int M = 220000;\n\nvector<int> con[N];\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u = 0, int v = 0) : u(u), v(v) {}\n} E[N];\n\nint adj[N][N];\nint que[N], vis[N], visT;\n\ninline bool Find(int u, int tar) {\n\tif (adj[u][tar] > 1) return true;\n\tint hd = 0, tl = 0;\n\tvisT++;\n\tque[tl++] = u, vis[u] = visT;\n\twhile (hd < tl) {\n\t\tint cur = que[hd++];\n\t\tfor (int v : con[cur]) if (vis[v] != visT) {\n\t\t\tif (cur == u && v == tar) continue;\n\t\t\tif (v == tar) return true;\n\t\t\tvis[v] = visT, que[tl++] = v;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint n, m; cin >> n >> m;\n\tSCC::init(n + 10);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tE[i] = Edge(u, v);\n\t\tcon[u].push_back(v);\n\t\tadj[u][v]++;\n\t\tSCC::add_edge(u, v);\n\t}\n\tSCC::SCC();\n\tfor (int i = 0; i < m; i++) {\n\t\tauto a = SCC::vis[E[i].u], b = SCC::vis[E[i].v];\n\t\tif (a == b) {\n\t\t\tif (Find(E[i].u, E[i].v)) cout << \"same\\n\";\n\t\t\telse cout << \"diff\\n\";\n\t\t} else {\n\t\t\tif (Find(E[i].u, E[i].v)) cout << \"diff\\n\";\n\t\t\telse cout << \"same\\n\";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint v,nxt;\n}e[200050],e2[200050];\n\nint head[1050],ecnt,hd[1050],ec;\nint flg1[200050],flg2[200050];\nint vis1[1050],vis2[1050];\n\nvoid adde(int u,int v,int id)\n{\n\te[++ ecnt].v = v;\n\te[ecnt].nxt = head[u];\n\thead[u] = ecnt;\n\te2[++ ec].v = u;\n\te2[ec].nxt = hd[v];\n\thd[v] = ec;\n}\n\nvoid dfs1(int pos,int tag)\n{\n\tvis1[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis1[v])\n\t\t\tdfs1(v,tag);\n\t}\n}\n\nvoid dfs2(int pos,int tag)\n{\n\tvis2[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis2[v])\n\t\t\tdfs2(v,tag);\n\t}\n}\n\nint histo[200050],hc;\n\nint main()\n{\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\tadde(u,v,i);\n\t}\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t//\tcerr << i << endl;\n\t\tmemset(vis1,0,sizeof(vis1));\n\t\tmemset(vis2,0,sizeof(vis2));\n\t\thc = 0;\n\t\tvis1[i] = vis2[i] = -1;\n\t\tfor(int j = head[i];j;j = e[j].nxt)\n\t\t{\n\t\t\tint v = e[j].v;\n\t\t\thisto[++ hc] = j;\n\t\t\tif(!vis1[v])\n\t\t\t\tdfs1(v,j);\n\t\t}\n\t\tfor(int j = hc;j >= 1; -- j)\n\t\t{\n\t\t\tint v = e[histo[j]].v;\n\t\t\tif(!vis2[v])\n\t\t\t\tdfs2(v,histo[j]);\n\t\t\tif(vis1[e[histo[j]].v] != vis2[e[histo[j]].v])\n\t\t\t\tflg2[histo[j]] = 1;\n\t\t}\n\t\tfor(int j = hd[i];j;j = e2[j].nxt)\n\t\t\tif(vis1[e2[j].v])\n\t\t\t\tflg1[j] = 1;\n\t}\n\tfor(int i = 1;i <= m; ++ i)\n\t\tputs(flg1[i] + flg2[i] == 1 ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,id;\n}E[200005];\nint head[1005],sumE,M,N,a[200005],b[200005];\nbool a1[200005],a2[200005];\nint low[1005],dfn[1005],idx,sta[1005],top,instack[1005],col[1005],tot,cnt;\nbitset<1005> reachable[1005],block[1005],mark;\nvector<int> L[1005],v;\nvoid add(int u,int v,int id) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].id = id;\n    head[u] = sumE;\n}\n\nvoid Tarjan(int u) {\n    dfn[u] = low[u] = ++idx;\n    sta[++top] = u;\n    instack[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!dfn[v]) {Tarjan(v);low[u] = min(low[v],low[u]);}\n\telse if(instack[v] == 1) low[u] = min(low[u],dfn[v]);\n    }\n    if(low[u] == dfn[u]) {\n\t++tot;\n\twhile(1) {\n\t    int x = sta[top--];\n\t    col[x] = tot;\n\t    L[tot].pb(x);\n\t    instack[x] = 2;\n\t    if(x == u) break;\n\t}\n\tint s = L[tot].size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    block[tot][L[tot][i]] = 1;\n\t}\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    reachable[L[tot][i]] = block[tot];\n\t}\n    }\n}\nvoid dfs(int u) {\n    if(mark[u]) return;\n    mark[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!mark[v]) {\n\t    if(col[v] != col[u]) mark |= reachable[v];\n\t    else dfs(v);\n\t}\n    }\n}\nvoid Solve() {\n    read(N);read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(a[i]);read(b[i]);\n\tadd(a[i],b[i],i);\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(!dfn[i]) Tarjan(i);\n    }\n    \n    for(int i = 1 ; i <= tot ; ++i) {\n\tint s = L[i][0];\n\tfor(auto k : L[i]) {\n\t    for(int j = head[k] ; j ; j = E[j].next) {\n\t\tint v = E[j].to;\n\t\tif(reachable[s][v]) continue;\n\t\tif(col[v] != i) {reachable[s] |= reachable[v];}  \n\t    }\n\t}\n\tfor(auto k : L[i]) {\n\t    if(k != s) reachable[k] |= reachable[s];\n\t}\n    }\n    \n    for(int u = 1 ; u <= N ; ++u) {\n\tv.clear();\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    v.pb(E[i].id);\n\t}\n\tmark.reset();\n\tmark[u] = 1;\n\tint s = v.size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    if(col[b[v[i]]] != col[u]) mark |= reachable[b[v[i]]];\n\t    else dfs(b[v[i]]);\n\t}\n\tmark.reset();\n\tmark[u] = 1;\n\tfor(int i = s - 1 ; i >= 0 ; --i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    if(col[b[v[i]]] != col[u]) mark |= reachable[b[v[i]]];\n\t    else dfs(b[v[i]]);\n\t}\n    }\n    for(int i = 1 ; i <= M ; ++i) {\n\tif(reachable[b[i]][a[i]]) a1[i] = 1;\n\tif(a1[i] ^ a2[i]) puts(\"diff\");\n\telse puts(\"same\");\n    }\n    \n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <list>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <utility>\n#include <complex>\n#include <assert.h>\n#include <limits.h>\n//#include <bits/stdc++.h>\nusing namespace std;\n#define rank rankk\n#define mp make_pair\n#define pb push_back\n#define xo(a,b) ((b)&1?(a):0)\n#define tm tmp\n\n//#define LL ll\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll>pil;\ntypedef pair<ll,ll> pll;\n//const double INF=1e20;\nconst int INF=0x3f3f3f3f;\n//const int INF= 0x7fffffff;\n//const ll INF=0x3f3f3f3f3f3f3f3fll;\n//const ll INFF=0x3f3f3f3f3f3f3fll;\n//const ll INFF=1e14+5;\nconst int MAX=2e5+5;\n//const ll MAXN=2e8;\n//const int MAX_N=MAX;\n//const ll MOD=1e9+7;\nconst int MOD=1e9+7;\n//const long double pi=acos(-1.0);\n//const double eps=0.00000001;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntemplate<typename T>inline T abs(T a) {return a>0?a:-a;}\ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c=='-') start=neg=true;\n        else if(c>='0' && c<='9') {\n            start=true;\n            num=num*10+c-'0';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\ninline ll powMM(ll a,ll b,ll M){\n    ll ret=1;\n    a%=M;\n//    b%=M;\n    while (b){\n        if (b&1) ret=ret*a%M;\n        b>>=1;\n        a=a*a%M;\n    }\n    return ret;\n}\n//const long double eps=-1.0;\n//clock_t t1 = clock();\n//fprintf(stderr, \"%ld ms\\n\", clock() - t1);\nvoid open()\n{\n    freopen(\"in2.txt\",\"r\",stdin);\n    freopen(\"out2.txt\",\"w\",stdout);\n}\nconst int maxn=1e3+5;\nvector<int> G[maxn];//存原图 初始化仅需初始此\nint n,m;\nint a[MAX],b[MAX];\nint da[1005][1005],xiao[1005][1005];\n//bool vi[1005];\nvoid dfs(int now,int id,int st,int x[1005][1005] )\n{\n//    printf(\"now=%d id=%d st=%d\\n\",now,id,st);\n//    vi[now]=true;\n    x[st][now]=id;\n    for(int u:G[now])\n        if(x[st][u]==-1&&u!=st)dfs(u,id,st,x);\n}\nvoid solve(int st)\n{\n    for(int i=0;i<G[st].size();i++)\n    {\n        int to=G[st][i];\n//        memset(vi,false,sizeof(vi));\n//        vi[st]=1;\n        if(xiao[st][to]==-1)\n            dfs(to,i,st,xiao);\n    }\n//    memset(vi,false,sizeof(vi));\n    for(int i=G[st].size()-1;i>=0;i--)\n    {\n        int to=G[st][i];\n//        memset(vi,false,sizeof(vi));\n//        vi[st]=1;\n        if(da[st][to]==-1)\n            dfs(to,i,st,da);\n    }\n}\nint main()\n{\n    read(n);read(m);\n    memset(da,-1,sizeof(da));\n    memset(xiao,-1,sizeof(xiao));\n    for(int i=1;i<=m;i++){read(a[i]);read(b[i]);G[a[i]].pb(b[i]);}\n//    find_scc(n);\n    for(int i=1;i<=n;i++)\n        solve(i);\n    for(int i=1;i<=m;i++)\n    {\n//        printf(\"%d %d %d\\n\",da[a[i]][b[i]],xiao[a[i]][b[i]],da[b[i]][a[i]]);\n        if((da[a[i]][b[i]]!=xiao[a[i]][b[i]])==(da[b[i]][a[i]]!=-1))printf(\"same\\n\");\n        else printf(\"diff\\n\");\n    }\n\n}\n/*\n4\n1 2 3 2\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e3+5;\nint n,m,A[N],B[N],vis[N],tag[N],flag[2][N][N];\nvector <int> G[N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nvoid dfs(int u,int rt) {\n\tflag[0][rt][u]=vis[u]=true;\n\tfor(auto v:G[u]) if(!vis[v]) dfs(v,rt);\n}\nvoid dfs(int u,int rt,int id,int now) {\n\tif(vis[u]) return;\n\tvis[u]=true;\n\tif(!now) tag[u]=id;\n\telse flag[1][rt][u]=(bool)(tag[u]!=id);\n\tfor(auto v:G[u]) dfs(v,rt,id,now);\n}\n\nint main() {\n\tIN(n),IN(m);\n\tfor(int i=1;i<=m;++i)\n\t\tIN(A[i]),IN(B[i]),G[A[i]].push_back(B[i]);\n\tfor(int u=1;u<=n;++u) memset(vis,0,sizeof(vis)),dfs(u,u);\n\tfor(int u=1;u<=n;++u) {\n\t\tmemset(tag,0,sizeof(tag));\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=0;i<=(int)G[u].size()-1;++i) dfs(G[u][i],u,i,0);\n\t\tmemset(vis,0,sizeof(vis)),vis[u]=true;\n\t\tfor(int i=(int)G[u].size()-1;i>=0;--i) dfs(G[u][i],u,i,1);\n\t}\n\tfor(int i=1;i<=m;++i)\n\t\tputs(flag[0][B[i]][A[i]]^flag[1][A[i]][B[i]]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*200][2],g[N],a[N*200][2];\nauto F=f[0];\nbool bz[N],bz1[N],bz2[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    bz2[x]=1;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1])){\n                bz1[x]|=bz1[y];\n                continue;\n            }\n            if (!F[y][0]){\n                F[y][0]=v;\n                if (!bz2[y])dfs(y,s,v);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y]&&!bz2[y])dfs(y,s,v);\n            }\n        }\n    bz2[x]=0;\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\ts[++top]=e[p].k;\n\t\t\tif(vis[i][e[p].k]) continue;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=0;\n\t\t}\n\t\tint mn=1;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\ttemp[p]=vis[i][p];\n\t\t\tif(!temp[p]&&mn==1) mn=p;\n\t\t}\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>mn;p--){\n\t\t\tif(vis[i][s[p]]) continue;\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 100000000\n#define MOD 1000000007\n#define PI 3.14159265359\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint mp[1111][1111];\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\tvector<P> v;\n\tREP(i,n)REP(j,n)mp[i][j] = INF;\n\tREP(i,n)mp[i][i] = 0;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv.PB(MP(a,b));\n\t\tmp[a][b] = 1;\n\t}\n\t\n\t\n\tREP(k,n)REP(i,n)REP(j,n){\n\t\tmp[i][j] = min(mp[i][j],mp[i][k] + mp[k][j]);\n\t}\n\t\n\tREP(i,m){\n\t\tint a = v[i].FI;\n\t\tint b = v[i].SE;\n\t\tint ab = 1;\n\t\tint ba = INF;\n\t\tREP(j,n){\n\t\t\tif(mp[a][j]+mp[j][b] < INF && mp[a][j] != mp[a][b] + mp[b][j] && mp[j][b] != mp[j][a] + mp[a][b])ab = max(ab,mp[a][j]+mp[j][b]);\n\t\t\tif((j == a || j == b) || mp[b][j] != mp[b][a] + mp[a][j] && mp[j][a] != mp[j][b] + mp[b][a])ba = min(ba,mp[b][j]+mp[j][a]);\n\t\t}\n\t\t//cout << ab << ' ' << ba << endl;\n\t\tif((ab > 1 && ba == INF) || (ab == 1 && ba < INF)){\n\t\t\tcout << \"diff\" << '\\n';\n\t\t}\n\t\telse{\n\t\t\tcout << \"same\" << '\\n';\n\t\t}\n\t}\n\t\t\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nint head[maxn], nxt[maxm], to[maxm], tot;\nint x[maxm], v[maxn][maxn], y[maxm], vis[maxn], vis2[maxn];\n\nvoid add(int x, int y) {\n\t++tot;\n\tnxt[tot] = head[x];\n\tto[tot] = y;\n\thead[x] = tot;\n}\n\nvoid dfs(int x, int y) {\n\tv[y][x] = 1;\n\tfor (int e = head[x]; e; e = nxt[e]) {\n\t\tint z = to[e];\n\t\tif (!v[y][z]) dfs(z, y);\n\t}\n}\n\nvoid dfs2(int u, int *vis) {\n\tif (!vis[u]) vis[u] = u;\n\tfor (int e = head[u]; e; e = nxt[e]) {\n\t\tint v = to[e];\n\t\tif (!vis[v]) {\n\t\t\tvis[v] = vis[u];\n\t\t\tdfs2(v, vis);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tint a, b;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd(a, b);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdfs(i, i);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis[i] = vis2[i] = i;\n\t\tstack<int> s;\n\t\tfor (int e = head[i]; e; e = nxt[e]) {\n\t\t\ts.push(e);\n\t\t\tint j = to[e];\n\t\t\tif (!vis[j]) dfs2(j, vis);\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tint e = s.top(); s.pop();\n\t\t\tif (!vis2[to[e]]) dfs2(to[e], vis2);\n//\t\t\tprintf(\"%d %d %d\\n\", e, vis[to[e]], vis2[to[e]]);\n\t\t\tif (vis2[to[e]] == vis[to[e]]) y[e] = false;\n\t\t\telse y[e] = true;\n\t\t\tif (v[to[e]][i]) x[e] = true;\n\t\t\telse x[e] = false;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n//\t\tprintf(\"%d %d%d\\n\", i, x[i], y[i]);\n\t\tputs(x[i]^y[i]?\"diff\":\"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\ntypedef pair<int, int> P;\nbool can[1000][1000];\nbool ans[200000];\nbool reach[200000];\nvector<P> G[200000];\nbool vis[1000];\nvoid dfs(int s, int v) {\n\tcan[s][v] = 1;\n\tfor (P e : G[v]) {\n\t\tif (!can[s][e.first]) {\n\t\t\tdfs(s, e.first);\n\t\t}\n\t}\n}\nvoid dfs2(int v) {\n\tvis[v] = 1;\n\tfor (P e : G[v]) {\n\t\tif (!vis[e.first]) {\n\t\t\tdfs2(e.first);\n\t\t}\n\t}\n}\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].emplace_back(b, i);\n\t}\n\tfor (int i = 0; i < N; i++) dfs(i, i);\n\tfor (int i = 0; i < N; i++) {\n\t\tvector<P> edge = G[i];\n\t\tG[i].clear();\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tfor (P e : edge) {\n\t\t\tif (vis[e.first]) reach[e.second] = 1;\n\t\t\tG[i].push_back(e);\n\t\t\tdfs2(i);\n\t\t}\n\t\treverse(edge.begin(), edge.end());\n\t\tG[i].clear();\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tfor (P e : edge) {\n\t\t\tif (vis[e.first]) reach[e.second] = 1;\n\t\t\tG[i].push_back(e);\n\t\t\tdfs2(i);\n\t\t}\n\t\tfor (P e : edge) {\n\t\t\tif (can[e.first][i] == reach[e.second]) ans[e.second] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ans[i]) cout << \"same\" << endl;\n\t\telse cout << \"diff\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nstruct edge{\n\tint to, id;\n\tedge *nxt;\n}edges[MAXM + 5], *adj[MAXN + 5], *ecnt = edges;\nvoid addedge(int u, int v, int i) {\n\tedge *p = (++ecnt);\n\tp->to = v, p->id = i, p->nxt = adj[u], adj[u] = p;\n}\n\nbool ans1[MAXM + 5], ans2[MAXM + 5];\n\nint tag[MAXN + 5];\n\nint n, m;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\taddedge(a, b, i);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) tag[j] = 0;\n\t\tqueue<pair<int, int> >que;\n\t\tfor(edge *p=adj[i];p;p=p->nxt)\n\t\t\tque.push(make_pair(p->to, tag[p->to] = p->id));\n\t\twhile( !que.empty() ) {\n\t\t\tpair<int, int>f = que.front(); que.pop();\n\t\t\tint x = f.first, y = f.second;\n\t\t\tfor(edge *p=adj[x];p;p=p->nxt) {\n\t\t\t\tif( p->to == i )\n\t\t\t\t\tans1[p->id] = 1;\n\t\t\t\telse {\n\t\t\t\t\tif( tag[p->to] != -1 ) {\n\t\t\t\t\t\tif( tag[p->to] == 0 )\n\t\t\t\t\t\t\tque.push(make_pair(p->to, tag[p->to] = y));\n\t\t\t\t\t\telse if( tag[p->to] != y )\n\t\t\t\t\t\t\tque.push(make_pair(p->to, tag[p->to] = -1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(edge *p=adj[i];p;p=p->nxt)\n\t\t\tif( tag[p->to] == -1 ) ans2[p->id] = 1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tputs(ans1[i] ^ ans2[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1010\n#define M 200200\nusing namespace std;\n\nint n, m;\nvector<int> G[N];\n\nqueue<int> q;\nvoid bfs(int s, int mark, int *vis) {\n    q.push(s), vis[s] = mark;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : G[u]) {\n            if (vis[v]) continue;\n            vis[v] = mark, q.push(v);\n        }\n    }\n}\n\nint vis[N][N], v1[N], v2[N], vis2[N][N], ans[N], stk[N], top, id[N][N];\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n    \n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; ++i)\n        scanf(\"%d%d\", &u, &v), id[u][v] = i,\n        G[u].push_back(v);\n\n    for (int i = 1; i <= n; ++i)\n        bfs(i, 1, vis[i]);\n\n    for (int u = 1; u <= n; ++u) {\n        memset(v1, 0, sizeof v1);\n        memset(v2, 0, sizeof v2);\n        top = 0;\n        for (int v : G[u])\n            stk[++top] = v; \n        for (int i = 1, v; i <= top; ++i)\n            if (!v1[v = stk[i]])\n                v1[u] = i, bfs(v, i, v1);\n        for (int i = top, v; i >= 1; --i)\n            if (!v2[v = stk[i]])\n                v2[u] = i, bfs(v, i, v2);\n        for (int i = 1, v; i <= top; ++i) {\n            v = stk[i];\n            if (vis[v][u] == (v1[v] != i || v2[v] != i))\n                ans[id[u][v]] = 1;\n        }\n    }\n    \n    for (int i = 1; i <= m; ++i)\n        puts(ans[i] ? \"same\" : \"diff\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\ntypedef bitset<1001> b100;\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\nvector<ii> E[1111];\nint siz[1111];\nvi ADJ[1111];\nvoid computeE(int sccid)\n{\n\tvi coord;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tE[sccid].pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E[sccid].size();i++)\n\t{\n\t\tE[sccid][i].fi=lower_bound(coord.begin(),coord.end(),E[sccid][i].fi)-coord.begin();\n\t\tE[sccid][i].se=lower_bound(coord.begin(),coord.end(),E[sccid][i].se)-coord.begin();\n\t}\n\tsiz[sccid]=coord.size();\n}\nvoid check_edge(int n, int sccid, int id)\n{\n\t/*\n\tSCC scc; scc.init(siz[sccid]);\n\tfor(int i=0;i<E[sccid].size();i++)\n\t{\n\t\tif(G[sccid][i]==id) scc.addedge(E[sccid][i].se,E[sccid][i].fi);\n\t\telse scc.addedge(E[sccid][i].fi,E[sccid][i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n\t*/\n\tint u=edges[id].fi; int vv=edges[id].se;\n\tqueue<int> q;\n\tb100 visited;\n\tq.push(u); visited.set(u,1);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front(); q.pop();\n\t\tif(visited[vv]) return ;\n\t\tfor(int v:ADJ[x])\n\t\t{\n\t\t\tif(x==u&&v==vv) continue;\n\t\t\tif(!visited[v])\n\t\t\t{\n\t\t\t\tvisited.set(v,1); q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(!visited[vv]) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\t//computeE(id);\n\t//assert(important.size()<=2*siz[id]);\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\nb100 reach[1111];\nmap<ii,int> CNT;\nb100 reach2[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tADJ[u].pb(v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i].set(i,1);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\treach[i]|=reach[v];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(reach[i][j])\n\t\t\t{\n\t\t\t\treach2[j].set(i,1);\n\t\t\t}\n\t\t}\n\t\treach[i].set(i,0); reach2[i].set(i,0);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tif((reach[i]&reach2[v]).count()!=0) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nvoid dfs(int k){\n\tif(k==D) return;\n\tvis[D][k]=1;\n\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k]){\n\t\tdfs(e[i].k);\n\t}\n}\nint main(){\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint o=vis[i][e[p].k];\n\t\t\ts[++top]=e[p].k;\n\t\t\tdfs(e[p].k);\n\t\t\tvis[i][e[p].k]=o;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>1;p--){\n\t\t\tint o=vis[i][s[p]];\n\t\t\tdfs(s[p]);\n\t\t\tvis[i][s[p]]=o;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\nconst int maxn = 1000, maxm = 2e5;\ntypedef pair<int, int> pii;\n\nint n, m;\nvector<pii> g[maxn];\nint ans1[maxm], ans2[maxm];\nbool reach[maxn][maxn];\nbool vis[maxn];\n\nint Min[maxn], Max[maxn];\n\nvoid Dfs1(int u) {\n  vis[u] = true;\n  for (auto x : g[u]) {\n    int v = x.first;\n    if (!vis[v]) {\n      Dfs1(v);\n    }\n  }\n}\n\nvoid Dfs2(int u, int ban, int *label, int value) {\n  label[u] = value;\n  for (auto x : g[u]) {\n    int v = x.first;\n    if (v != ban && label[v] == -1) {\n      Dfs2(v, ban, label, value);\n    }\n  }\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    --a; --b;\n    g[a].push_back(make_pair(b, i));\n  }\n  for (int i = 0; i < n; ++i) {\n    FILL(vis, n, 0);\n    Dfs1(i);\n    COPY(vis, n, reach[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    for (auto x : g[i]) {\n      int j = x.first, id = x.second;\n      ans2[id] = reach[j][i];\n    }\n  }\n  for (int p = 0; p < n; ++p) {\n    FILL(Min, n, -1);\n    for (int i = 0; i < g[p].size(); ++i) {\n      int q = g[p][i].first;\n      if (Min[q] == -1) Dfs2(q, p, Min, i);\n    }\n    FILL(Max, n, -1);\n    for (int i = (int)g[p].size() - 1; i >= 0; --i) {\n      int q = g[p][i].first;\n      if (Max[q] == -1) Dfs2(q, p, Max, i);\n    }\n    for (auto x : g[p]) {\n      int q = x.first, id = x.second;\n      ans1[id] = (Min[q] != -1 && Min[q] != Max[q]);\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    puts(ans1[i] == ans2[i] ? \"same\" : \"diff\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#define lowbit(i) (i&(-i))\n#define ll long long\n#define mid ((l+r)>>1)\nusing namespace std;\nconst int N=1005,M=2e5+5;\nint n,m;\nstruct st\n{\n\tint from,nxt,to,ans;\n}ed[M]; int head[N],num;\nvoid add(int from,int to)\n{\n\ted[++num].to=to,ed[num].from=from;\n\ted[num].nxt=head[from];\n\thead[from]=num;\n}\nint stk[N],top,dfn[N],low[N],refl[N],t,numb; bool cn[N];\nvoid tarjan(int x)\n{\n\tdfn[x]=low[x]=++numb,stk[++top]=x,cn[x]=1;\n\tfor(int u,i=head[x];i;i=ed[i].nxt)\n\t{\n\t\tu=ed[i].to;\n\t\tif(!dfn[u])tarjan(u),low[x]=min(low[x],low[u]);\n\t\telse if(cn[u])low[x]=min(low[x],dfn[u]);\n\t}\n\tif(dfn[x]==low[x])\n\t{\n\t\t++t;\n\t\twhile(stk[top]!=x)\n\t\t\trefl[stk[top]]=t,cn[stk[top]]=0,--top;\n\t\trefl[stk[top]]=t,cn[stk[top]]=0,--top;\n\t}\n}\nint fir[2][N];\nvoid dfs(int x,int id,int typ)\n{\n\tif(fir[typ][x])return; fir[typ][x]=id;\n\tfor(int u,i=head[x];i;i=ed[i].nxt)\n\t{\n\t\tu=ed[i].to;\n\t\tif(!fir[typ][u])dfs(u,id,typ);\n\t}\n}\nint E[M],tot;\nint main()\n{\n\tint u,v; scanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&u,&v),add(u,v);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);\n\tfor(int i=1;i<=m;i++)if(refl[ed[i].to]==refl[ed[i].from])ed[i].ans=1;\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tfor(int i=1;i<=n;i++)fir[0][i]=fir[1][i]=0;\n\t\tfir[0][x]=fir[1][x]=1,tot=0;\n\t\tfor(int i=head[x];i;i=ed[i].nxt)E[++tot]=i;\n\t\tfor(int i=1;i<=tot;i++)dfs(ed[E[i]].to,E[i],0);\n\t\tfor(int i=tot;i;i--)dfs(ed[E[i]].to,E[i],1);\n\t\tfor(int i=head[x];i;i=ed[i].nxt)\n\t\t\tif(fir[0][ed[i].to]!=i||fir[1][ed[i].to]!=i)ed[i].ans++;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(ed[i].ans==1)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}\n/*\n3 3\n1 2\n2 3\n1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[200001];\nint n,m,op[1001][1001],a[200001],b[200001];\ninline void read(int &x){\n\tint a;scanf(\"%d\",&a);x=a;\n}\nbool visit[1001]={false};\nvoid dfs(int u,int c){//cout<<u<<\" \";\n\tvisit[u]=true;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(!visit[v]){\n\t\t\top[c][v]++;\n\t\t\tdfs(v,c);\n\t\t}\n\t}\n\tvisit[u]=false;\n}\nint main(){\n\tread(n);read(m);\n\tfor(int i=1;i<=m;i++){\n\t\tread(a[i]);read(b[i]);\n\t\tg[a[i]].push_back(b[i]);\n\t}\n\tfor(int i=1;i<=n;i++)dfs(i,i);\n\tfor(int i=1;i<=m;i++){\n\t\tif(op[a[i]][b[i]]&&op[b[i]][a[i]]){//qlt\n\t\t\tif(op[a[i]][b[i]]==1)printf(\"diff\\n\");\n\t\t\telse printf(\"same\\n\");\n\t\t}\n\t\telse{//bqlt\n\t\t\tif(op[a[i]][b[i]]==1)printf(\"same\\n\");\n\t\t\telse printf(\"diff\\n\");\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 1005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint id, to, nxt;\n} graph[M];\nint head[N], n, m, cnt = 0;\nbool g[N][N];\n\nvoid addedge (int id, int u, int v) {\n\tedge e = {id, v, head[u]};\n\tgraph[head[u] = cnt++] = e;\n}\n\nint vis_mn[N][N], vis_mx[N][N], ans[M];\nvoid dfs1 (int u, int r, int val) {\n\tif (vis_mn[r][u]) return ;\n\tvis_mn[r][u] = val;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (v == r) continue;\n\t\tdfs1(v, r, val);\n\t}\n}\n\nvoid dfs2 (int u, int r, int val) {\n\tif (vis_mx[r][u]) return ;\n\tvis_mx[r][u] = val;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (v == r) continue;\n\t\tdfs2(v, r, val);\n\t}\n}\n\nint main () {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) {\n\t\thead[i] = -1;\n\t\tfor (int j = 1; j <= n; j++) g[i][j] = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\taddedge(i, u, v), g[u][v] = true;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) vis_mn[i][j] = vis_mx[i][j] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (g[i][j]) dfs1(j, i, j);\n\t\t}\n\t\tfor (int j = n; j; j--) {\n\t\t\tif (g[i][j]) dfs2(j, i, j);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = head[i]; ~j; j = graph[j].nxt) {\n\t\t\tint u = i, v = graph[j].to;\n\t\t\tbool ans1 = vis_mn[v][u], ans2 = (vis_mn[u][v] < vis_mx[u][v]);\n\t\t\tans[graph[j].id] = (ans1 == ans2);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) puts(ans[i] ? \"same\" : \"diff\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    random_shuffle(begin(g[a]), end(g[a]));\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 63) {\n\n\n    int l = _, r = min< int >(g[idx].size(), _ + 63);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else {\n          dp[e.first] |= dp[p];\n        }\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 2005;\n\nconst int M = 4e5 + 5;\n\nint n, m, x, y;\nint fi[N], nt[M], to[M], tot;\n\nvoid link(int x, int y) {\n\tnt[++ tot] = fi[x], to[tot] = y, fi[x] = tot;\n}\n\nint bz[N];\n\nvoid dg(int x) {\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tif(!bz[to[i]]) dg(to[i]);\n}\n\nint b[N][N];\n\nint d[N], d0, xx, ky[N];\n\nvoid dfs(int x) {\n\tbz[x] = 1;\n\tif(xx == x) return;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tif(!bz[to[i]]) dfs(to[i]);\n}\n\n#define mem(a) memset(a, 0, sizeof a)\n\nint ans[M];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tlink(x, y);\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz);\n\t\tdg(st);\n\t\tfo(j, 1, n) b[st][j] = bz[j];\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz); mem(ky); d0 = 0;\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\td[++ d0] = to[i];\n\t\txx = st;\n\t\tfo(i, 1, d0) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tmem(bz);\n\t\tfd(i, d0, 1) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\tans[i] = b[to[i]][st] ^ ky[to[i]];\n\t}\n\tfo(i, 1, m) pp(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\ninline int qread(){\n\tint x=0,sign=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') sign=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*sign;\n}\nint n,m; \nstruct edge{\n\tint from;\n\tint to;\n\tint next;\n}E[maxm];\nint sz=0; \nint head[maxn];\nvoid add_edge(int u,int v){\n\tsz++;\n\tE[sz].from=u;\n\tE[sz].to=v;\n\tE[sz].next=head[u];\n\thead[u]=sz;\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tused[x]=1;\n\troute[s][x]++;\n\tfor(int i=head[x];i;i=E[i].next){\n\t\tint y=E[i].to;\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nchar a[]=\"same\",b[]=\"diff\";\nvoid qprint(char *s,int len){\n\tfor(int i=0;i<len;i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('\\n');\n}\nint main(){\n//\tscanf(\"%d %d\",&n,&m);\n\tn=qread();\n\tm=qread(); \n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n//\t\tscanf(\"%d %d\",&u,&v);\n\t\tu=qread();\n\t\tv=qread();\n\t\tadd_edge(u,v);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=head[i];j;j=E[j].next){\n\t\t\tint y=E[j].to;\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(E[i].from,E[i].to)) qprint(b,4);\n\t\telse qprint(a,4);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\ninline int qread(){\n\tint x=0,sign=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') sign=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*sign;\n}\nint n,m; \nint s[maxm],e[maxm];\nvector<int>E[maxn];\nvoid add_edge(int u,int v){\n\tE[u].push_back(v);\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tint y;\n\tused[x]=1;\n\troute[s][x]++;\n\tint cnt=E[x].size();\n\tfor(int i=0;i<cnt;i++){\n\t\ty=E[x][i];\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nchar a[]=\"same\",b[]=\"diff\";\nvoid qprint(char *s,int len){\n\tfor(int i=0;i<len;i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('\\n');\n}\nint main(){\n//\tscanf(\"%d %d\",&n,&m);\n\tn=qread();\n\tm=qread(); \n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n//\t\tscanf(\"%d %d\",&u,&v);\n\t\ts[i]=qread();\n\t\te[i]=qread();\n\t\tadd_edge(s[i],e[i]);\n\t}\n\tint y;\n\tfor(int i=1;i<=n;i++){\n\t\tint cnt=E[i].size();\n\t\tfor(int j=0;j<cnt;j++){\n\t\t\ty=E[i][j];\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(s[i],e[i]) )qprint(b,4);\n\t\telse qprint(a,4);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nbool bz[N],bz1[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v,int dep){ \n    static int y;\n    if (dep>1000)return;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1])){\n                bz1[x]|=bz1[y];\n                continue;\n            }\n            if (!F[y][0]){\n                F[y][0]=v;\n                dfs(y,s,v,dep+1);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y])dfs(y,s,v,dep+1);\n            }\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#include<unordered_map>\n#include<vector>\ntypedef long long ll;\nusing namespace std;\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define N 1010\n#define M 200010\nvector<int>G[N];\nint a[M],b[M],vis[2][N][N];\nvoid dfs(int mod,int a,int b,int col){\n\tif(vis[mod][a][b])return;\n\tvis[mod][a][b]=col;\n\tfor(auto q:G[b])dfs(mod,a,q,col);\n}\nint main(){\n\tint i,j,n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].pb(b[i]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tvis[0][i][i]=vis[1][i][i]=1;\n\t\tfor(j=0;j<G[i].size();j++)dfs(0,i,G[i][j],j+1);\n\t\tfor(j=G[i].size()-1;j>=0;j--)dfs(1,i,G[i][j],j+1);\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tint x=(vis[0][a[i]][b[i]]!=vis[1][a[i]][b[i]]);\n\t\tint y=vis[0][b[i]][a[i]];\n\t\tif(x^y)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nvoid debug(vec &v) {\n\tint n = v.size();\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << \"\\n\";\n}\n\nint n;\nbool e[1000][1000];\nint id[1000][1000];\nbool ans[200000];\n\n\nvector<int> G[1000];\n\nvector<int> cG[1000];\nbool used[1000];\n\nvoid dfs(int id) {\n\trep(j, cG[id].size()) {\n\t\tint to = cG[id][j];\n\t\tif (!used[to]) {\n\t\t\tused[to] = true;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint m; cin >> n >> m;\n\trep(i, n)rep(j, n)id[i][j] = -1;\n\tvector<int> a(m), b(m);\n\trep(i, m) {\n\t\tcin >> a[i] >> b[i]; a[i]--; b[i]--;\n\t\tid[a[i]][b[i]] = i;\n\t\tG[a[i]].push_back(b[i]);\n\t}\n\trep(i, n) {\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\te[i][i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j];\n\t\t\t\tif (e[i][to])continue;\n\t\t\t\tq.push(to);\n\t\t\t\te[i][to] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n)cG[j].clear();\n\t\tfill(used, used + n, false);\n\t\tused[i] = true;\n\t\trep(j, m) {\n\t\t\tif (a[j] != i)cG[a[j]].push_back(b[j]);\n\t\t}\n\t\tsort(G[i].begin(), G[i].end());\n\t\tvector<int> cnt(G[i].size(),0);\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (used[to])cnt[j]++;\n\t\t\telse dfs(to);\n\n\t\t}\n\t\tfill(used, used + n, false);\n\t\tused[i] = true;\n\t\tper(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (used[to])cnt[j]++;\n\t\t\telse dfs(to);\n\n\t\t}\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (cnt[j] < 1 && e[to][i])ans[id[i][to]] = true;\n\t\t\telse if (cnt[j] >= 1 && !e[to][i])ans[id[i][to]] = true;\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (ans[i]) {\n\t\t\tcout << \"diff\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"same\" << endl;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfreopen(\"test.in\",\"r\",stdin);\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\ts[++top]=e[p].k;\n\t\t\tif(vis[i][e[p].k]) continue;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=0;\n\t\t}\n\t\tint mn=1;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\ttemp[p]=vis[i][p];\n\t\t\tif(!temp[p]) mn=p;\n\t\t}\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>mn;p--){\n\t\t\tif(vis[i][s[p]]) continue;\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//using pi = pair<int, int>;\nconst int MAXN = 1005;\nconst int MAXM = 200005;\n \nvector<int> gph[MAXN];\nint adj[MAXN][MAXN], vis[MAXN];\nint n, m;\nint s[MAXM], e[MAXM];\n \nvoid dfs(int r, int v){\n\tvis[v] = 1;\n\tadj[r][v]++;\n\tint cnt=gph[v].size();\n\tfor(int it=0;it<cnt;it++){\n\t\tint i=gph[v][it];\n\t\tif(i == r) continue;\n\t\tif(!vis[i] && adj[r][i] < 2){\n\t\t\tdfs(r, i);\n\t\t}\n\t}\n}\n \nint main(){\n\tcin >> n >> m;\n\tfor(int i=0; i<m; i++){\n\t\tscanf(\"%d %d\",&s[i],&e[i]);\n\t\tgph[s[i]].push_back(e[i]);\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tint cnt=gph[i].size();\n\t\tfor(int it=0;it<cnt;it++){\n\t\t\tint j=gph[i][it];\n\t\t\tif(adj[i][j] < 2){\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tdfs(i, j);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t    for(int j=1;j<=n;j++){\n//\t        printf(\"%d \",adj[i][j]);\n//\t    }\n//\t    printf(\"\\n\");\n//\t}\n\tfor(int i=0; i<m; i++){\n\t\tif(adj[e[i]][s[i]] == 0){\n\t\t\tputs(adj[s[i]][e[i]] > 1 ? \"diff\" : \"same\");\n\t\t}\n\t\telse{\n\t\t\tputs(adj[s[i]][e[i]] > 1 ? \"same\" : \"diff\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <tuple>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n#define to_pair(x, y) (((x) << 10) | (y))\n\n#define N_MAX 1024\n\nusing namespace std;\n\nint d[N_MAX * N_MAX];\nint ind[N_MAX * N_MAX];\nint visited[N_MAX];\n\nvector< vector<int> > e, re;\n\n\nvoid dfs(int u, int r) {\n    visited[u] = 1;\n    d[to_pair(u, r)] = 1;\n    for (int w : e[u]) {\n        if (!visited[w]) {\n            dfs(w, r);\n        }\n    }\n}\n\nvoid solve(int n, int m, vector<int>& edges) {\n\n    fill(d, d + N_MAX, 0);\n    fill(ind, ind + N_MAX, 0);\n\n    for (int i = 1; i <= n; ++i) {\n        fill(visited, visited + N_MAX, 0);\n        dfs(i, i);\n    }\n    for (int i = 1; i <= n; ++i) {\n        fill(visited, visited + N_MAX, 0);\n        visited[i] = 1;\n        for (auto pj = e[i].begin(); pj != e[i].end(); ++pj) {\n            if (visited[*pj]) {\n                ind[to_pair(i, *pj)] = 1;\n            } else {\n                dfs(*pj, i);\n            }\n        }\n        fill(visited, visited + N_MAX, 0);\n        visited[i] = 1;\n        for (auto pj = e[i].rbegin(); pj != e[i].rend(); ++pj) {\n            if (visited[*pj]) {\n                ind[to_pair(i, *pj)] = 1;\n            } else {\n                dfs(*pj, i);\n            }\n        }\n    }\n\n    for (int x : edges) {\n        cout << ((d[x] ^ ind[x]) ? \"diff\" : \"same\") << endl;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n\n    int n, m;\n    int a, b;\n    vector<int> edges;\n    \n    cin >> n >> m;\n    e.resize(n + 1);\n    re.resize(n + 1);\n    rep(i, 0, m) {\n        cin >> a >> b;\n        edges.push_back(to_pair(a, b));\n        e[a].push_back(b);\n        re[b].push_back(a);\n    }\n\n    solve(n, m, edges);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e3 + 10,M = 2e5 + 10;\n\nstruct node {\n\tint x,y;\n}G[M];\nint to[M],nex[M],beg[N],cnt[N][N],vis[N];\nint e;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\ninline void dfs(int St,int cur,int To) {\n\tif(St == cur || vis[cur] == To || cnt[St][cur] >= 2) return;\n\tcnt[St][cur]++;\n\tif(cnt[St][cur] == 1) vis[cur] = To;\n\tfor(int i = beg[cur];i;i = nex[i]) dfs(St,to[i],To);\n}\n\nint main() {\n\n\tint n = read(),m = read();\n\tFor(i,1,m) {\n\t\tint x = read(),y = read();\n\t\tadd(x,y),G[i] = (node){x,y};\n\t}\n\n\tFor(i,1,n) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int j = beg[i];j;j = nex[j]) dfs(i,to[j],to[j]);\n\t}\n\n\tFor(i,1,m) {\n\t\tif((cnt[G[i].x][G[i].y] >= 2) ^ (cnt[G[i].y][G[i].x] >= 1)) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 1010;\n\nint n, m;\nvector<pair<int, int> > eds[MAXN];\nvector<pair<int, int> > vv[MAXN];\nqueue<pair<int, int> > qu;\nint ans[200010];\n\nvector<int> e[MAXN], _e[MAXN];\nint AA[200010],BB[200010];\n\nbool mark[MAXN];\nint ord[MAXN], tim;\nint to[MAXN],cc;\n\nvoid dfs(int x){\n\tif(mark[x])return;\n\tmark[x] = true;\n\tfor(vector<int>::iterator it = e[x].begin(); it != e[x].end(); it++){\n\t\tint y = *it;\n\t\tdfs(y);\n\t}\n\tord[tim++] = x;\n}\nvoid _dfs(int x){\n\tif(!mark[x])return;\n\tmark[x] = false;\n\tto[x] = cc;\n\tfor(vector<int>::iterator it = _e[x].begin(); it != _e[x].end(); it++){\n\t\tint y = *it;\n\t\t_dfs(y);\n\t}\n}\nvoid scc(){\n\tfor(int i=0; i<n; i++)\n\t\tif(!mark[i])\n\t\t\tdfs(i);\n\twhile(tim--){\n\t\tint x = ord[tim];\n\t\tif(mark[x]){\n\t\t\t_dfs(x);\n\t\t\tcc++;\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\n\tfor (int i = 0; i < n; ++i)\n\t\teds[i].clear();\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a;\n\t\t--b;\n\t\te[a].push_back(b);\n\t\t_e[b].push_back(a);\n\t\teds[a].push_back(make_pair(b, i));\n\t\tAA[i] = a;\n\t\tBB[i] = b;\n\t}\n\tscc();\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tvv[j].clear();\n\t\tfor (int j = 0; j < (int)eds[i].size(); ++j) {\n\t\t\tint u = eds[i][j].first;\n\t\t\tvv[u].push_back(make_pair(1, j));\n\t\t\tqu.push(make_pair(u, 0));\n\t\t}\n\t\twhile (!qu.empty()) {\n\t\t\tint x = qu.front().first;\n\t\t\tint y = qu.front().second;\n\t\t\tqu.pop();\n\t\t\tfor (int j = 0; j < (int)eds[x].size(); ++j) {\n\t\t\t\tint u = eds[x][j].first;\n\t\t\t\tif (u == i)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vv[u].size() >= 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vv[u].empty() || vv[u][0].second != vv[x][y].second)\n\t\t\t\t\tqu.push(make_pair(u, vv[u].size())), vv[u].push_back(make_pair(vv[x][y].first + 1, vv[x][y].second));\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (int)eds[i].size(); ++j) {\n\t\t\tint u = eds[i][j].first;\n\t\t\tif (vv[u].size() < 2)\n\t\t\t\tans[eds[i][j].second] = 0;\n\t\t\telse\n\t\t\t\tans[eds[i][j].second] = vv[u][1].first;\n\t\t}\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tputs((ans[i] == 0) == (to[AA[i]] != to[BB[i]]) ? \"same\" : \"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\nvector<int> gr[1100];\nvector<int> igr[1100];\nvector<int> ban;\n\nint V,e;\nint visit[1100]={0},gro[1100]={0};\n\nvoid dfs(int i){\n\tif(visit[i]==0){\n\t\tvisit[i]=1;\n\t\tfor(int k=0;k<gr[i].size();k++) dfs(gr[i][k]);\n\t\tban.push_back(i);\n\t}\n}\n\nvoid idfs(int i,int h){\n\tif(visit[i]==0){\n\t\tvisit[i]=1;\n\t\tgro[i]=h;\n\t\tfor(int k=0;k<igr[i].size();k++) idfs(igr[i][k],h);\n\t}\n}\n\nvoid kyouren(){\n\tfor(int i=0;i<V;i++){\n\t\tdfs(i);\n\t}\n\tfor(int i=0;i<V;i++) visit[i]=0;\n\tfor(int i=V-1;i>=0;i--){\n\t\tidfs(ban[i],ban[i]);\n\t}\n\n\n}\n\nvector<pa> eda;\nmap<pa,int> ma;\n\n\nvector<pa> naibu[1100];\nint GG[1100][1100]={};\nvector<pa> G[1100];\nvector<pa> H[1100];\nvector<int> G2[1100];\nint owari[1100]={};\nint ans[200020]={};\n// sonomama ->1\n// kawaru ->2\n\n\nint tmp[1100];\nint sumi[1100];\n\nint dfs1(int r,int p){\n\tif(sumi[r])return tmp[r];\n\tsumi[r]=1;\n\tif(r==p){\n\t\ttmp[r]=0;\n\t}\n\telse{\n\t\tint ima=-100;\n\t\tfor(auto v:G2[r])ima=max(ima,dfs1(v,p));\n\t\t\n\t\tima++;\n\t\tif(ima<0) tmp[r]=-100;\n\t\telse tmp[r]=ima;\n\t}\n\treturn tmp[r];\n}\n\nvoid dagdag(int r,int n){\n\tfor(int i=0;i<n;i++)sumi[i]=0;\n\tfor(auto v:G[r]){\n\t\tif(v.second==-1) continue;\n\t//\tcout<<\" \"<<v.first<<\" \"<<r<<\" \"<<dfs1(v.first,r)<<endl;\n\t\tif(dfs1(v.first,r)>1) ans[v.second]=2;\n\t\telse ans[v.second]=1;\n\t}\n}\nvector<int> cho[1010];\n\nvector<int> T[1010];\nvector<int> T2[1010];\n\nint dfs2(int r,int p,int mae){\n\tif(sumi[r])return tmp[r];\n\tsumi[r]=1;\n\tif(r==p){\n\t\ttmp[r]=0;\n\t}\n\telse{\n\t\tint ima=-100;\n\t\tfor(auto v:T2[r])if(v!=mae)ima=max(ima,dfs2(v,p,r));\n\t\t\n\t\tima++;\n\t\tif(ima<0) tmp[r]=-100;\n\t\telse tmp[r]=ima;\n\t}\n\treturn tmp[r];\n}\nint vis[1100];\nvoid ddff(int r){\n\tif(vis[r]) return;\n\tvis[r]=1;\n\tfor(auto v:T[r])if(!vis[v])ddff(v);\n}\n\nvoid uti(int r,int n){\n\tfor(auto v:cho[r]){\n\t\t\n\t\t\n\t\tif(T[v].size()==1){\n\t\t\tans[ma[{v,T[v][0]}]]=2;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tint f=T[v].size();\n\t\t\tvector<int> ve(f,0);\n\t\t\tfor(int i=0;i<n;i++)vis[i]=0;\n\t\t\tvis[v]=1;\n\t\t\tfor(int i=0;i<f;i++){\n\t\t\t\t\n\t\t\t\tif(vis[T[v][i]])ve[i]=1;\n\t\t\t\tddff(T[v][i]);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++)vis[i]=0;\n\t\t\tvis[v]=1;\n\t\t\tfor(int i=f-1;i>=0;i--){\n\t\t\t\tif(vis[T[v][i]])ve[i]=1;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tddff(T[v][i]);\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<f;i++){\n\t\t\t\tif(ve[i]) ans[ma[{v,T[v][i]}]]=1;\n\t\t\t\telse ans[ma[{v,T[v][i]}]]=2;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\nsigned main(){\n\n\t\t\t  cin.tie(0);\n\t\t\tios::sync_with_stdio(false);\nint n,m;\ncin>>n>>m;\n\tV=n;\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\ty--;\n\t\tyy--;\n\t\tma[{y,yy}]=i;\n\t\t\teda.pb({y,yy});\n\t\tgr[y].pb(yy);\n\t\tigr[yy].pb(y);\n\t}\n\tkyouren();\n\tfor(int i=0;i<n;i++)cho[gro[i]].pb(i);\n\tfor(int i=0;i<m;i++){\n\t\tpa v=eda[i];\n\t\tif(gro[v.first]==gro[v.second]){\n\t\t\tnaibu[gro[v.first]].pb(v);\n\t\t\tT[v.first].pb(v.second);\n\t\t\tT2[v.second].pb(v.first);\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tGG[gro[v.first]][gro[v.second]]++;\n\t\t\t\tH[gro[v.first]].pb({gro[v.second],i});\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(auto v:H[i]){\n\t\t\tif(GG[i][v.first]==1){\n\t\t\t\tG[i].pb(v);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans[v.second]=2;\n\t\t\t}\n\t\t}\n\t\tfor(auto v:H[i]){\n\t\t\tif(GG[i][v.first]>1){\n\t\t\t\tG[i].pb(v);\n\t\t\t\tG[i].back().second=-1;\n\t\t\t\tGG[i][v.first]=0;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<n;i++){\n\t\tif((int)G[i].size()>1){\n\t\tfor(auto v:G[i]){\n\t\t\tans[v.second]=1;\n\t\t}\n\t\towari[i]=1;\n\t\twhile(G[i].size()>1)G[i].pop_back();\n\t\t}\n\t\telse if(G[i].size()==0) owari[i]=1;\n\t}\n\t*/\n\t\n\tfor(int i=0;i<n;i++)for(auto v:G[i]){\n\t//\tcout<<i<<\" \"<<v.first<<\" \"<<v.second<<endl;\n\t\tG2[v.first].pb(i);\n\t}\n\tfor(int i=0;i<n;i++)if(!owari[i]){\n\t\tdagdag(i,n);\n\t}\n\t//\tfor(int i=0;i<m;i++)cout<<ans[i]<<endl;\n\n\tfor(int i=0;i<n;i++)if(naibu[i].size()) uti(i,n);\n\t\n\tfor(int i=0;i<m;i++)cout<<(ans[i]==1?\"same\":\"diff\")<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 1000\n#define MM 200000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nvector<int> v[MN+5],w[MN+5],V[MN+5],W[MN+5];\nint n,m,bel[MN+5],head[MN+5],cnt,Ans[MM+5],q[MN+5],cc,in[MN+5],now;\nint top,dfn[MN+5],low[MN+5],c[MN+5],num,dn,inq[MN+5],mx[MN+5],mn[MN+5],f[MN+5];\nstruct edge{int to,next,w;}e[MM+5];\ninline void ins(int f,int t,int w){e[++cnt]=(edge){t,head[f],w};head[f]=cnt;}\nvoid MarkMn(int x,int c)\n{\n\tmn[x]=c;\n\tfor(int i=0;i<v[x].size();++i) \n\t\tif(!(x==now&&i+1>c)&&mn[v[x][i]]==n) MarkMn(v[x][i],c);\n}\nvoid MarkMx(int x,int c)\n{\n\tmx[x]=c;\n\tfor(int i=0;i<v[x].size();++i) \n\t\tif(!(x==now&&i+1<c)&&!mx[v[x][i]]) MarkMx(v[x][i],c);\n}\nvoid Solve()\n{\n\tfor(int i=1;i<=num;++i) for(int j=head[c[i]];j;j=e[j].next) \n\t\tif(bel[e[j].to]==cc) v[c[i]].push_back(e[j].to),w[c[i]].push_back(e[j].w);\n\tfor(int i=1;i<=num;++i)\n\t{\n\t\tfor(int j=1;j<=num;++j) mx[c[j]]=0,mn[c[j]]=n;now=c[i];\n\t\tfor(int j=0;j<v[c[i]].size();++j) if(mn[v[c[i]][j]]==n) MarkMn(v[c[i]][j],j+1);\n\t\tfor(int j=v[c[i]].size()-1;~j;--j) if(!mx[v[c[i]][j]]) MarkMx(v[c[i]][j],j+1);\n\t\tfor(int j=1;j<=num;++j) \n\t\t\tif(i!=j&&mn[c[j]]==mx[c[j]]) Ans[w[c[i]][mn[c[j]]-1]]=1;\n\t}\n}\nvoid Tarjan(int x)\n{\n\tdfn[x]=low[x]=++dn;q[++top]=x;inq[x]=1;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(!dfn[e[i].to]) Tarjan(e[i].to),low[x]=min(low[x],low[e[i].to]);\n\t\telse if(inq[e[i].to]) low[x]=min(low[x],dfn[e[i].to]);\n\tif(dfn[x]==low[x])\n\t{\n\t\tfor(num=0,++cc;q[top+1]!=x;inq[q[top--]]=0) c[++num]=q[top],bel[q[top]]=cc;\n\t\tSolve();\t\n\t}\n}\ninline void R(int&x,int y){x=min(2,x+y);}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1,j;i<=m;++i) j=read(),ins(j,read(),i);\n\tfor(int i=1;i<=n;++i) if(!dfn[i]) Tarjan(i); \n\tfor(int i=1;i<=n;++i) for(int j=head[i];j;j=e[j].next) if(bel[i]!=bel[e[j].to]) \n\t\tV[bel[i]].push_back(bel[e[j].to]),W[bel[i]].push_back(e[j].w);\n\tfor(int i=1;i<=cc;++i)\n\t{\n\t\tmemset(f,0,sizeof(f));memset(in,0,sizeof(in));\n\t\tfor(int j=1;j<=cc;++j) for(int k=0;k<V[j].size();++k) ++in[V[j][k]];\n\t\tf[i]=1;q[top=1]=i;\n\t\tfor(int j=1;j<=top;++j)\n\t\t\tfor(int k=0;k<V[q[j]].size();++k)\n\t\t\t\tif(R(f[V[q[j]][k]],f[q[j]]),!--in[V[q[j]][k]]) q[++top]=V[q[j]][k];\n\t\tfor(int j=0;j<V[i].size();++j) if(f[V[i][j]]!=1) Ans[W[i][j]]=1;\n\t}\n\tfor(int i=1;i<=m;++i) puts(Ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define inlien inline\n#define retrun return\n#define cpnst const\nbool can[1111][1111],exc[1111][1111];\ninline bool ask(int x,int y)\n{return can[y][x]^exc[x][y];}\nint x[222222],y[222222],n,m;\n#include<vector>\nstd::vector<int>v[1111];\nbool vis[1111];\ninline void dfs(int s,int p)\n{\n\tif(vis[p])return;\n\tvis[p]=can[s][p]=1;\n\tfor(register int i=0;i<v[p].size();i++)\n\t\tdfs(s,v[p][i]);\n}\nint frm[1111];\ninline void efs(int fs,int s,int p)\n{\n\tif(vis[p])return;vis[p]=1;\n\tif(frm[p])if(frm[p]^s)exc[fs][p]=1;frm[p]=s;\n\tfor(register int i=0;i<v[p].size();i++)\n\t\tefs(fs,s,v[p][i]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tregister int i,ii;\n\tfor(i=1;i<=m;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]),v[x[i]].push_back(y[i]);\n\tfor(i=1;i<=n;i++)\n\t{for(ii=1;ii<=n;ii++)vis[ii]=0;dfs(i,i);}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(ii=1;ii<=n;ii++)vis[ii]=frm[ii]=0;vis[i]=1;\n\t\tfor(ii=0;ii<v[i].size();ii++)efs(i,v[i][ii],v[i][ii]);\n\t\tfor(ii=1;ii<=n;ii++)vis[ii]=0;vis[i]=1;\n\t\tfor(ii=v[i].size()-1;~ii;ii--)efs(i,v[i][ii],v[i][ii]);\n\t}for(i=1;i<=m;i++)puts(ask(x[i],y[i])?\"diff\":\"same\");\n}\n/*\nGiving the world a better yourself is giving yourself a better world. \n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring> \n#define qwq int\n#define re register\nusing namespace std;\nnamespace Solve{\n\tinline void read(qwq &x){\n\t\tx=0;qwq f=1;char c=getchar();\n\t\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\t\tfor(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';\n\t\tx*=f; \n\t}\n\t#define N 1010\n\t#define M 200200\n\tqwq n,m,a,b;\n\tqwq cnt;\n\tqwq head[M];\n\tstruct node{\n\t\tqwq to,next;\n\t}edge[M];\n\tstruct extra{\n\t\tqwq from,to;\n\t}ignore[M];\n\tinline void add(qwq a,qwq b){\n\t\tedge[++cnt].to=b,edge[cnt].next=head[a],head[a]=cnt;\n\t}\n\tqwq S;\n\tqwq vis[N][N],f[N][N];\n\tinline void dfs(qwq now,qwq fa){\n\t\tvis[fa][now]=1,++f[S][now];\n\t\tfor(re qwq i=head[now];i;i=edge[i].next){\n\t\t\tqwq to=edge[i].to;\n\t\t\tif(vis[now][to])continue;\n\t\t\tdfs(to,now);\n\t\t}\n\t}\n\tinline void solve(){\n\t\tread(n),read(m);\n\t\tfor(re qwq i=1;i<=m;++i){\n\t\t\tqwq a,b;\n\t\t\tread(a),read(b);\n\t\t\tadd(a,b),ignore[cnt].from=a,ignore[cnt].to=b;\n\t\t}\n\t\tfor(re qwq i=1;i<=n;++i){\n\t\t\tS=i;\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tdfs(S,S);\n\t\t}\n\t\tfor(re qwq i=1;i<=m;++i){\n\t\t\tqwq from=ignore[i].from,to=ignore[i].to;\n\t\t\tif(f[from][to]<1||f[to][from]<1){\n\t\t\t\tif(f[from][to]>1){\n\t\t\t\t\tcout<<\"diff\"<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"same\"<<endl; \n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(f[from][to]>1){\n\t\t\t\t\tcout<<\"same\"<<endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"diff\"<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nusing namespace Solve;\nqwq main(){\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define OK puts(\"OK\");\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int inf = (int)1e9 + 7;\nconst int N = (int)2e5 + 7;\n\nint n,m;\nint x,y;\nint u[N],comp[N];\nint sz;\n\nvector <int> g[N],rg[N];\nvector <pair<int,int> > e;\nvector <int> t;\nmap<pair<int,int>,int> ans;\n\nvoid SCC (int v) {\n    u[v] = 1;\n\n    for (auto to : g[v])\n        if (!u[to])\n            SCC(to);\n    t.pb(v);\n}\nvoid RSCC (int v) {\n    comp[v] = sz;\n    u[v] = 1;\n    for (auto to : rg[v])\n        if (!u[to])\n            RSCC(to);\n}\nvoid dfs (int v) {\n    u[v] = 1;\n    for (auto to : g[v])\n        if (!u[to])\n            dfs(to);\n}\n\nmain () {\n    cin >> n >> m;\n\n    for (int i = 1; i <= m; i ++) {\n        cin >> x >> y;\n        e.pb({x,y});\n        g[x].pb(y);\n        rg[y].pb(x);\n    }\n    for (int i = 1; i <= n; i ++)\n        if (!u[i])\n            SCC(i);\n\n    reverse (t.begin(),t.end());\n    memset(u,0,sizeof(u));\n\n    for (auto to : t)\n        if (!u[to]) {\n            sz ++;\n            RSCC(to);\n        }\n\n    for (int v = 1; v <= n; v ++) {\n        for (int i = 1; i <= n; i ++)\n            u[i] = 0;\n        u[v] = 1;\n        for (auto to : g[v]) {\n            if (u[to])\n                ans[{v,to}] = 1;\n            dfs(to);\n        }\n\n        for (int i = 1; i <= n; i ++)\n            u[i] = 0;\n\n        reverse(g[v].begin(),g[v].end());\n\n        u[v] = 1;\n\n        for (auto to : g[v]) {\n            if (u[to])\n                ans[{v,to}] = 1;\n            dfs(to);\n        }\n    }\n    for (auto c : e) {\n        if (comp[c.fr] != comp[c.sc]) ans[{c.fr,c.sc}] ^= 1;\n        if (ans[{c.fr,c.sc}])\n            puts(\"same\");\n        else\n            puts(\"diff\");\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  int x=0,f=1;char c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return f?x:-x;\n  }\ntemplate <typename mitsuha>\ninline bool read(mitsuha &x){\n  x=0;int f=1;char c=gc();\n  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';\n  if (!~c) return 0;\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return x=f?x:-x,1;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x,int b=10){\n  if (!x) return 0&pc(48);\n  if (x<0) x=-x,pc('-');\n  int bit[99],i,p=0;\n  for (;x;x/=b) bit[++p]=x%b;\n  for (i=p;i;--i) pc(bit[i]+(bit[i]<10?48:55));\n  return 0;\n  }\ntemplate <typename mitsuha>\ninline int rwrite(mitsuha x,int b=10){\n  mitsuha ans=0,d=1;\n  for (;x;x/=10,d*=b) ans=ans+x%10*d;\n  return ans;\n  }\ninline char fuhao(){\n  char c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=2e5;\ntypedef int fuko[yuzu|10];\nvector<int> lj[yuzu|10];\nstruct edge{int u,v;}eg[yuzu|10];\nint cnt[1010][1011],vis[1010],can[1010][1010];\n\nvoid dfs(int p,int u){\nvis[u]=1,cnt[p][u]++;\nfor (int i:lj[u]) if (!vis[i]) dfs(p,i);\n}\n\nvoid dfs2(int p,int u){\nvis[u]=1,can[p][u]=1;\nfor (int v:lj[u]) if (!vis[v]) dfs2(p,v);\n}\n\nint main(){\nint i,n=read(),m=read();\nfor (i=1;i<=m;++i){\n  int u=read(),v=read();\n  lj[u].push_back(v);\n  eg[i]=edge{u,v};\n  }\nfor (i=1;i<=n;++i){\n  for (int j:lj[i]){\n    memset(vis,0,sizeof vis);\n    vis[i]=1,dfs(i,j);\n    } \n  }\nfor (i=1;i<=n;++i){\n  memset(vis,0,sizeof vis);\n  dfs2(i,i);\n  }\nfor (i=1;i<=m;++i){\n  int u=eg[i].u,v=eg[i].v;\n  //cout<<(cnt[u][v])<<\" \"<<can[v][u]<<endl;\n  puts(((cnt[u][v]==1)^(!can[v][u]))?\"diff\":\"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n\nstruct enode\n{\n    int num;\n    int id;\n    int f;\n    enode(){}\n    enode(int nn,int ii,int ff)\n    {\n        num=nn;\n        id=ii;\n        f=ff;\n    }\n};\n\nvector<vector<enode> >edge;\nvector<vector<bool> >r;\n\nvector<bool>cover;\n\nint n,m;\n\nvoid dfs(int now ,int st)\n{\n    int i;\n    r[st][now]=1;\n    for(i=0;i<edge[now].size();i++)\n    {\n        if(r[st][edge[now][i].num]==0)\n        {\n            dfs(edge[now][i].num,st);\n        }\n    }\n    return ;\n}\n\nvoid dfs2(int now,int x)\n{\n   int i;\n   cover[now]=1;\n   for(i=0;i<edge[now].size();i++)\n   {\n       if(edge[now][i].num==x)continue;\n       if(cover[edge[now][i].num]==0)\n       {\n           dfs2(edge[now][i].num,x);\n       }\n   }\n}\n\n\nvoid gao()\n{\n    int i,j;\n    for(i=1;i<=n;i++)\n    {\n        cover=vector<bool>(n+1,0);\n        for(j=0;j<edge[i].size();j++)\n        {\n             //cout<<i<<' '<<j<<\" ^^^\"<<endl;\n             if(cover[edge[i][j].num]==1)\n             {\n                  edge[i][j].f=1;\n                  //cout<<i<<' '<<j<<\"   &&&\"<<endl;\n                  continue;\n             }\n             \n             dfs2(edge[i][j].num,i);\n        }\n    }\n}\n\nint ans[200011];\nint main()\n{\n    int i,j,k;\n    int xx,yy;\n    \n    scanf(\"%d %d\",&n,&m);\n    \n    edge=vector<vector<enode> >(n+1,vector<enode>());\n    r=vector<vector<bool> >(n+1,vector<bool>(m+1,0));\n    \n    for(i=1;i<=m;i++)\n    {\n        scanf(\"%d %d\",&xx,&yy);\n        edge[xx].push_back(enode(yy,i,0));\n    }\n    \n    for(i=1;i<=n;i++)\n    {\n        dfs(i,i);\n    }\n    \n    /*\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=n;j++)\n        {\n            cout<<r[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    */\n    //system(\"pause\");\n    gao();\n    //system(\"pause\");\n    for(i=1;i<=n;i++)\n    {\n        reverse(edge[i].begin(),edge[i].end());\n    }\n    gao();\n    \n    //system(\"pause\");\n    for(i=1;i<=n;i++)\n    {\n        for(j=0;j<edge[i].size();j++)\n        {\n            \n            ans[edge[i][j].id]=(edge[i][j].f^r[edge[i][j].num][i]);\n        }\n    }\n    \n    for(i=1;i<=m;i++)\n    {\n        if(ans[i]==0)\n        {\n            printf(\"same\\n\");\n        }\n        else\n        {\n            printf(\"diff\\n\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\ninline int qread(){\n\tint x=0,sign=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') sign=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*sign;\n}\nint n,m; \nint s[maxm],e[maxm];\nvector<int>E[maxn];\nvoid add_edge(int u,int v){\n\tE[u].push_back(v);\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tint y;\n\tused[x]=1;\n\troute[s][x]++;\n\tint cnt=E[x].size();\n\tfor(int i=0;i<cnt;i++){\n\t\ty=E[x][i];\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nchar a[]=\"same\",b[]=\"diff\";\nvoid qprint(char *s,int len){\n\tfor(int i=0;i<len;i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('\\n');\n}\nint main(){\n//\tscanf(\"%d %d\",&n,&m);\n\tn=qread();\n\tm=qread(); \n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n//\t\tscanf(\"%d %d\",&u,&v);\n\t\ts[i]=qread();\n\t\te[i]=qread();\n\t\tadd_edge(s[i],e[i]);\n\t}\n\tint y;\n\tfor(int i=1;i<=n;i++){\n\t\tint cnt=E[i].size();\n\t\tfor(int j=0;j<cnt;j++){\n\t\t\ty=E[i][j];\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(s[i],e[i]) )qprint(b,4);\n\t\telse qprint(a,4);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\n/*\nidom : immediate dominator\ndominator tree : idom[v]->v\n*/\nstruct DominatorTree{\n\tint n;\n\tvector<vector<int>>G,rG;\n\tvector<int>semi,id,et,par,mn,uf;\n\n\tDominatorTree(int n):\n\t\tn(n),G(n),rG(n),semi(n),\n\t\tid(n,-1),et(n),par(n,-1),mn(n),uf(n)\n\t{\n        for(int i=0;i<n;i++){\n            semi[i]=mn[i]=uf[i]=i;\n        }\n\t}\n\n\tvoid addEdge(int a,int b){\n\t\tG[a].push_back(b);\n        rG[b].push_back(a);\n\t}\n\tint find(int v){\n\t\tif(uf[v]==v)return v;\n\t\tint a=find(uf[v]);\n\t\tif(id[semi[mn[uf[v]]]]<id[semi[mn[v]]])mn[v]=mn[uf[v]];\n\t\treturn uf[v]=a;\n\t}\n\n\tvoid link(int c,int p){\n\t\tuf[c]=p;\n\t}\n\n\tvoid dfs(int v,int p,int &k){\n\t\tid[v]=k;\n\t\tet[k++]=v;\n\t\tpar[v]=p;\n\t\tfor(int c:G[v])if(id[c]==-1)dfs(c,v,k);\n\t}\n\n\tvector<int>calc(int root){\n\t\tint sz=0;\n\t\tdfs(root,-1,sz);\n\n        vector<int>us(n);\n        vector<vector<int>>bucket(n);\n\n\t\tfor(int i=sz-1;i>0;i--){\n\t\t\tint w=et[i];\n\t\t\tfor(int v:rG[w])if(id[v]!=-1){\n\t\t\t\tfind(v);\n\t\t\t\tif(id[semi[mn[v]]]<id[semi[w]])semi[w]=semi[mn[v]];\n\t\t\t}\n\t\t\tbucket[semi[w]].pb(w);\n\t\t\tfor(int v:bucket[par[w]]){\n\t\t\t\tfind(v);\n\t\t\t\tus[v]=mn[v];\n\t\t\t}\n\t\t\tbucket[par[w]].clear();\n\t\t\tlink(w,par[w]);\n\t\t}\n\n        vector<int>idom(n,-1);\n\t\tfor(int i=1;i<sz;i++){\n\t\t\tint w=et[i];\n\t\t\tif(semi[w]==semi[us[w]])idom[w]=semi[w];\n\t\t\telse idom[w]=idom[us[w]];\n\t\t}\n\t\treturn idom;\n\t}\n};\n\nint N, M;\nint A[214514];\nint B[214514];\nint rev[1145];\nbool ans[214514];\nvector<pii> eds[1145];\n\ntypedef vector<vector<int>> Graph;\nstruct Scc{\n  stack<int> S;\n  vector<int> inS,low,num;\n  int time=0;\npublic:\n  Graph rdag;\n  vector<int> inv;\n  Graph scc;\n  void visit(const Graph &g, int v){\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v]=1;\n    for(const int  &w:g[v]){\n      if(!num[w]){\n        visit(g,w);\n        low[v]=min(low[v],low[w]);\n      }else if(inS[w]) low[v]=min(low[v],num[w]);\n    }\n    if(low[v]==num[v]){\n      scc.eb();\n      while(1){\n        int w = S.top(); S.pop(); inS[w]=0;\n        scc.back().pb(w);\n        if(v==w) break;\n      }\n    }\n  }\n  Scc(const Graph &g) {\n    const int n = g.size();\n    num.resize(n); low.resize(n); inS.resize(n);\n    rep(u,n)if(!num[u]) visit(g,u);\n    reverse(all(scc));\n    \n    inv.resize(n); \n    rdag.resize(scc.size());\n    rep(i,scc.size())for(auto v:scc[i]) inv[v]=i;\n    rep(i,scc.size())for(auto v:scc[i])for(auto e:g[v])\n      if(inv[e]!=i) {\n        rdag[inv[e]].pb(i);\n      } \n  }\n};\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N >> M;\n  Graph es(N);\n  rep(i, M) {\n    cin >> A[i] >> B[i];\n    --A[i];\n    --B[i];\n    es[A[i]].eb(B[i]);\n    eds[A[i]].eb(pii(B[i], i));\n  }\n\n  Scc scc(es);\n\n  rep(v, N) {\n    DominatorTree dom(N+eds[v].size());\n    int idx = N;\n    rep(i, M) {\n      if (A[i] == v) {\n        dom.addEdge(A[i], idx);\n        dom.addEdge(idx, B[i]);\n        rev[B[i]] = idx;\n        ++idx;\n      } else {\n        dom.addEdge(A[i], B[i]);\n      }\n    }\n\n    auto idom = dom.calc(v);\n    for (auto &e : eds[v]) {\n      int u = e.XX;\n      int w = rev[u];\n      ans[e.YY] = (idom[u] != w) ^ (scc.inv[u] == scc.inv[v]);\n    }\n  }\n\n  rep(i, M) {\n    if (ans[i]) cout << \"diff\\n\";\n    else cout << \"same\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by swift on 2020/8/6.\n//\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nstruct edge{\n    int s,t;\n}e[200001];\nvector<int>v[1001];\nint vis[1001],a[1001][1001],b[1001][1001];\nvoid dfs1(int now,int st){\n    vis[now]=1;\n    a[st][now]=1;\n    for(int i=0;i<v[now].size();i++){\n        if(!vis[v[now][i]]){\n            dfs1(v[now][i],st);\n        }\n    }\n}\nint col[1001];\nvoid dfs2(int now,int st,int type,int c){\n    if(type==0){\n        col[now]=c;\n    }\n    else{\n        b[st][now]=(col[now]!=c);\n    }\n    vis[now]=1;\n    for(int i=0;i<v[now].size();i++){\n        if(!vis[v[now][i]])\n        dfs2(v[now][i],st,type,c);\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d\",&e[i].s,&e[i].t);\n        v[e[i].s].push_back(e[i].t);\n    }\n    for(int i=1;i<=n;i++){\n        memset(vis,0,sizeof(vis));\n        dfs1(i,i);\n    }\n    for(int i=1;i<=n;i++){\n        memset(col,0,sizeof(col));\n        memset(vis,0,sizeof(vis));\n        vis[i]=1;\n        for(int j=0;j<v[i].size();j++){\n            if(!vis[v[i][j]]){\n                dfs2(v[i][j],i,0,j+1);\n            }\n        }\n        memset(vis,0,sizeof(vis));\n        vis[i]=1;\n        for(int j=v[i].size()-1;j>=0;j--){\n            if(!vis[v[i][j]]){\n                dfs2(v[i][j],i,1,j+1);\n            }\n        }\n    }\n    /*for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++){\n            cout<<a[i][j]<<\" \";\n            if(j==n)cout<<endl;\n        }\n    cout<<endl;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++){\n            cout<<b[i][j]<<\" \";\n            if(j==n)cout<<endl;\n        }*/\n    for(int i=1;i<=m;i++){\n        if(a[e[i].t][e[i].s]^b[e[i].s][e[i].t]){\n            puts(\"diff\");\n        }\n        else{\n            puts(\"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n \nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[M] , B[M];\nint stk[N] , top;\nint ans[M];\nint L[N][N], R[N][N];\n\nvoid add(int x, int y) {\n\tne[++ cnt] = fir[x];\n\tfir[x] = cnt;\n\tto[cnt] = y;\n}\n\nbool can[N][N];\n\nqueue <int> q;\n\nvector <int> son[N];\n\n#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\nvoid solve(int x) {\n\twhile(!q.empty()) q.pop();\n\tq.push(x);\n\twhile(!q.empty()) {\n\t\tint ind = q.front();\n\t\tcan[x][ind] = 1;\n\t\tq.pop();\n\t\tfor(auto V : son[ind]) {\n\t\t\tif(can[x][V]) continue;\n\t\t\tq.push(V);\n\t\t\tcan[x][V] = 1;\n\t\t}\n\t}\n\t\n\tForeachson(i, x) {\n\t\tint V = to[i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!L[x][V]) {\n\t\t\tq.push(V);\n\t\t\tL[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int j = son[ind].size() - 1; j >= 0; -- j){\n\t\t\t\tint v = son[ind][j];\n\t\t\t\tif(!L[x][v] && v != x) {\n\t\t\t\t\tL[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < (int) son[x].size(); ++ i) {\n\t\tint V = son[x][i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!R[x][V]) {\n\t\t\tq.push(V);\n\t\t\tR[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int j = 0; j < (int) son[ind].size(); ++ j) {\n\t\t\t\tint v = son[ind][j];\n\t\t\t\tif(!R[x][v] && v != x) {\n\t\t\t\t\tR[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x, y);\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tForeachson(j, i) {\n\t\t\tint V = to[j];\n\t\t\tson[i].push_back(V);\n\t\t}\n\t\treverse(son[i].begin(), son[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tsolve(i);\n\t}\n\t\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(L[A[i]][B[i]] != B[i] || R[A[i]][B[i]] != B[i]) {\n\t\t\tif(!can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\telse {\n\t\t\tif(can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 2005;\n\nconst int M = 4e5 + 5;\n\nint n, m, x, y;\nint fi[N], nt[M], to[M], tot;\nvector<int> e[N];\n\nvoid link(int x, int y) {\n\tnt[++ tot] = fi[x], to[tot] = y, fi[x] = tot;\n\te[x].push_back(y);\n}\n\nint bz[N];\n\nint b[N][N];\n\nint d[N], d0, ky[N][N];\n\nvoid dfs(int x) {\n\tif(bz[x]) return;\n\tbz[x] = 1;\n\tff(i, 0, e[x].size()) dfs(e[x][i]);\n}\n\n#define mem(a) memset(a, 0, sizeof a)\n\nint ans[M];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tlink(x, y);\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz); d0 = 0;\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\td[++ d0] = to[i];\n\t\tbz[st] = 1;\n\t\tfo(i, 1, d0) {\n\t\t\tky[st][d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfo(j, 1, n) b[st][j] |= bz[j];\n\t\tmem(bz); bz[st] = 1;\n\t\tfd(i, d0, 1) {\n\t\t\tky[st][d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfo(j, 1, n) b[st][j] |= bz[j];\n\t}\n\tfo(st, 1, n) {\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\tans[i] = b[to[i]][st] ^ ky[st][to[i]];\n\t}\n\tfo(i, 1, m) pp(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1010;\nconst int MAXM = 200010;\n\nstruct Edge {\n\tint u, v;\n\n\tEdge() {}\n\tEdge(int u, int v):u(u), v(v) {}\n}E[MAXM];\n\nvector<int>to[MAXN];\n\nint n, m, Mark[MAXN];\nbitset<MAXN>vis;\nbool G1[MAXN][MAXN];\nbool G2[MAXN][MAXN];\n\ninline void dfs1(int x, int st) {\n\tG1[st][x] = 1, vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs1(u, st);\n}\n\ninline void dfs2(int x, int col, int k, int st) {\n\tif(k) G2[st][x] = Mark[x] != col;\n\telse Mark[x] = col; vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs2(u, col, k, st);\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor(int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tto[u].push_back(v);\n\t\tE[i] = Edge(u, v);\n\t}\n\tfor(int i = 1; i <= n; i++) vis.reset(), dfs1(i, i);\n\tfor(int i = 1; i <= n; i++) {\n\t\tvis.reset(), vis.set(i);\n\t\tmemset(Mark, 0, sizeof(Mark));\n\t\tint d = to[i].size();\n\t\tfor(int j = 0; j < d; j++) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 0, i);\n\t\tvis.reset(), vis.set(i);\n\t\tfor(int j = d - 1; ~j; --j) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 1, i);\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tputs(G1[E[i].v][E[i].u] ^ G2[E[i].u][E[i].v] ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nint N,M;\nint A[222222],B[222222];\nbool flag1[222222],flag2[222222];\n\nvint G[1111];\n\nint r[1111];\nbool used[1111];\n\nvoid solve(int s){\n    memset(r,-1,sizeof(r));\n    memset(used,0,sizeof(used));\n\n    for(auto v:G[s]){\n        if(r[v]!=-1){\n            used[v]=true;\n            continue;\n        }\n        r[v]=v;\n        queue<int>que;\n        que.push(v);\n        while(que.size()){\n            int u=que.front();\n            que.pop();\n            for(auto w:G[u]){\n                if(w==s)continue;\n                if(r[w]!=-1){\n                    if(r[w]!=v)used[w]=true;\n                    continue;\n                }\n                r[w]=v;\n                que.push(w);\n            }\n        }\n    }\n\n    queue<int>que;\n    rep(i,N)if(used[i])que.push(i);\n\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:G[v]){\n            if(u==s)continue;\n            if(used[u])continue;\n            used[u]=true;\n            que.push(u);\n        }\n    }\n\n    rep(i,M){\n        if(A[i]==s){\n            flag1[i]|=used[B[i]];\n        }\n        if(B[i]==s){\n            flag2[i]|=r[A[i]]!=-1;\n        }\n    }\n}\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,M){\n        cin>>A[i]>>B[i];A[i]--;B[i]--;\n        G[A[i]].pb(B[i]);\n    }\n\n    rep(i,N)solve(i);\n    rep(i,M){\n        if(flag1[i]==flag2[i])puts(\"same\");\n        else puts(\"diff\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int N = 1005;\nconst int M = 2e5 + 5;\nvector<int> v[N];\nint n, m, vis[N], g1[N][N], g2[N][N], pre[N];\nstruct node{int x, y;}e[M];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid dfs(int x, int now)\n{\n\tg1[now][x] = 1;\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(g1[now][y]) continue;\n\t\tdfs(y, now);\n\t}\n}\nvoid dfs(int x, int id, int k, int now)\n{\n\tvis[x] = 1;\n\tif(!k) pre[x] = id; else g2[now][x] = (pre[x] != id);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, id, k, now);\n\t}\n}\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read();\n\tfor(int i = 1, x, y; i <= m; i ++)\n\t{\n\t\tx = read(); y = read();\n\t\tv[x].push_back(y); e[i] = node{x, y};\n\t}\n\tfor(int i = 1; i <= n; i ++) dfs(i, i);\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++) pre[j] = vis[j] = 0; vis[i] = 1;\n\t\tint d = v[i].size();\n\t\tfor(int j = 0; j < d; j ++) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 0, i);\n\t\tfor(int j = 1; j <= n; j ++) vis[j] = 0; vis[i] = 1;\n\t\tfor(int j = d - 1; j >= 0; j --) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 1, i);//d - 1\n\t}\n\tfor(int i = 1; i <= m; i ++)\n\t\tif(g1[e[i].x][e[i].y] ^ g2[e[i].x][e[i].y]) puts(\"diff\");\n\t\telse puts(\"same\");\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#define maxn 1005\n#define _ 0\nusing namespace std;\nstruct nod\n{\n\tint nex,id;\n\tnod(int a,int b)\n\t{\n\t\tnex=a;\n\t\tid=b;\n\t}\n\tnod(){}\n};\nint n,m,tim;\nint vis[maxn];\nint bel[maxn][maxn][2];\nint u[maxn*maxn],v[maxn*maxn];\nvector<nod> edge[maxn];\nvoid dfs(int now,int fa,int b,int f)\n{\n\tvis[now]=tim; bel[fa][now][f]=b;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,fa,b,f);\n}\nvoid solve(int now)\n{\n\ttim++; vis[now]=tim;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,0);\n \n\treverse(edge[now].begin(),edge[now].end());\n \n\ttim++; vis[now]=tim;\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsolve(i);\n\tfor(int i=1;i<=m;i++){\n\t\tif( (bel[v[i]][u[i]][0]!=0) ^ _ ^ (bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i) )\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\nconst int limit = 1010;\nusing edge = struct{int to,id;};\nvector<edge> graph[limit];\n\nint a[200010],b[200010];\n\nbool visited[limit][limit];\nvoid dfs(int v,int root){\n\tvisited[root][v] = true;\n\tfor(auto &e:graph[v]){\n\t\tif(visited[root][e.to]) continue;\n\t\tdfs(e.to,root);\n\t}\n}\n\nint small[limit][limit];\nvoid dfs2(int v,int root,int id){\n\tsmall[root][v] = id;\n\tfor(auto &e:graph[v]){\n\t\tif(small[root][e.to] != -1) continue;\n\t\tdfs2(e.to,root,id);\n\t}\n}\n\n\nint large[limit][limit];\nvoid dfs3(int v,int root,int id){\n\tlarge[root][v] = id;\n\tfor(auto &e:graph[v]){\n\t\tif(large[root][e.to] != -1) continue;\n\t\tdfs3(e.to,root,id);\n\t}\n}\n\nstring ans[200010];\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\n\trep(i,m){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--,b[i]--;\n\t\tgraph[a[i]].push_back({b[i],i});\n\t}\n\n\trep(i,n) dfs(i,i);\n\n\trep(i,n){\n\t\tconst int l = graph[i].size();\n\t\t\t\n\t\trep(j,n) small[i][j] = -1;\n\t\tsmall[i][i] = 0;\n\t\trep(j,l) if(small[i][graph[i][j].to] == -1) dfs2(graph[i][j].to,i,j);\n\n\t\trep(j,n) large[i][j] = -1;\n\t\tlarge[i][i] = 0;\n\t\trrep(j,l) if(large[i][graph[i][j].to] == -1) dfs3(graph[i][j].to,i,j);\n\t}\n\n\trep(i,n){\n\t\tconst int l = graph[i].size();\t\n\t\trep(j,l){\n\t\t\tconst int to = graph[i][j].to;\n\t\t\tbool ab = false;\n\t\t\tif(small[i][to] != -1 and small[i][to] <= j - 1) ab = true; \n\t\t\tif(large[i][to] != -1 and j + 1 <= large[i][to]) ab = true; \n\t\t\t//cerr << small[i][to] << \" \" << large[i][to] << endl;\n\t\t\tbool ba = visited[to][i];\n\t\t\t//cerr << graph[i][j].id << \" \" << ab << \" \" << ba << endl;\n\t\t\tans[graph[i][j].id] = (ab != ba) ? \"diff\" : \"same\";\n\t\t}\n\t}\n\n\trep(i,m) cout << ans[i] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nauto rd=read<int>;\nconst int N=1001, M=2e5;\nint n, m, a[M], b[M], head[N], next[M], rhead[N], rnext[N];\nint queue[N], *qhead, *qtail, min[N], max[N];\nbool vis[N], rev[M], without[M];\nvoid bfs(int u) {\n\tqhead=qtail=queue;\n\tif(vis[u]) return;\n\tvis[*qtail++=u]=true;\n\twhile(qhead!=qtail) {\n\t\tu=*qhead++;\n\t\tfor(int j=head[u]; j!=-1; j=next[j])\n\t\t\tif(!vis[b[j]]) vis[*qtail++=b[j]]=true;\n\t}\n}\nint main() {\n\tn=rd(), m=rd();\n\tmemset(head, -1, n*sizeof(int));\n\tmemset(rhead, -1, n*sizeof(int));\n\tfor(int i=0; i<m; ++i) {\n\t\ta[i]=rd()-1, b[i]=rd()-1;\n\t\tnext[i]=head[a[i]];\n\t\thead[a[i]]=i;\n\t\trnext[i]=rhead[b[i]];\n\t\trhead[b[i]]=i;\n\t}\n\tfor(int i=0; i<n; ++i) {\n\t\tmemset(vis, 0, n);\n\t\tbfs(i);\n\t\tfor(int j=rhead[i]; j!=-1; j=rnext[j]) rev[j]=vis[a[j]];\n\t}\n\tfor(int i=0; i<n; ++i) {\n\t\tstd::vector<int> out;\n\t\tfor(int j=head[i]; j!=-1; j=next[j]) out.push_back(j);\n\t\tmemset(vis, 0, n);\n\t\tvis[i]=true;\n\t\tfor(int j: out) {\n\t\t\tbfs(b[j]);\n\t\t\tfor(int *p=queue; p!=qtail; ++p) max[*p]=j;\n\t\t}\n\t\tstd::reverse(out.begin(), out.end());\n\t\tmemset(vis, 0, n);\n\t\tvis[i]=true;\n\t\tfor(int j: out) {\n\t\t\tbfs(b[j]);\n\t\t\tfor(int *p=queue; p!=qtail; ++p) min[*p]=j;\n\t\t}\n\t\tfor(int j=head[i]; j!=-1; j=next[j]) without[j]=(min[b[j]]!=j)||(max[b[j]]!=j);\n\t}\n\tfor(int i=0; i<m; ++i) puts(rev[i]^without[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, a[1009];\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tif (*max_element(a, a + n) <= 0) {\n\t\tint ptr = max_element(a, a + n) - a;\n\t\tcout << a[ptr] << endl; ptr++;\n\t\tcout << n - 1 << endl;\n\t\tfor (int i = n; i > ptr; i--) cout << i << endl;\n\t\tfor (int i = 1; i < ptr; i++) cout << 1 << endl;\n\t}\n\telse {\n\t\tvector<int> v; long long cs = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tlong long ss = 0; vector<int> sv;\n\t\t\tfor (int j = i; j < n; j += 2) {\n\t\t\t\tif (a[j] > 0) ss += a[j], sv.push_back(j + 1);\n\t\t\t}\n\t\t\tif (ss > cs) {\n\t\t\t\tcs = ss;\n\t\t\t\tv = sv;\n\t\t\t}\n\t\t}\n\t\tvector<int> seq;\n\t\tfor (int i = n; i > v.back(); i--) seq.push_back(i);\n\t\tfor (int i = (int)v.size() - 2; i >= 0; i--) {\n\t\t\tfor (int j = (v[i] + v[i + 1]) / 2; j > v[i] + 1; j--) {\n\t\t\t\tseq.push_back(j);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < v.front(); i++) seq.push_back(1);\n\t\tfor (int i = 0; i < (int)v.size() - 1; i++) seq.push_back(2);\n\t\tcout << cs << endl;\n\t\tcout << seq.size() << endl;\n\t\tfor (int i : seq) cout << i << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*200][2],g[N],a[N*200][2];\nauto F=f[0];\nbool bz[N],bz1[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1])){\n                bz1[x]|=bz1[y];\n                continue;\n            }\n            if (!F[y][0]){\n                F[y][0]=v;\n                dfs(y,s,v);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y])dfs(y,s,v);\n            }\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::endl;\n\nconst int N = 1e3 + 5, M = 2e5 + 5;\n\nint n, m, ban;\nstruct Edge { int x, y; } E[M];\nbool A[N][N], B[N][N];\nstd::vector<int> G[N];\nint que[N], ql, qr;\nint vis[N], tag[N], ver;\n\ninline void bfs1(int st) {\n  que[ql = qr = 0] = st;\n  vis[st] = 1;\n  while (ql <= qr) {\n    int x = que[ql++];\n    for (int y : G[x])\n      if (!vis[y]) {\n        vis[y] = 1;\n        que[++qr] = y;\n      }\n  }\n  for (int i = 1; i <= n; ++i)\n    A[st][i] = vis[i], vis[i] = 0;\n}\n\ninline void bfs2(int st) {\n  ++ver, tag[st] = ver;\n  ++vis[st];\n  que[ql = qr = 0] = st;\n  while (ql <= qr) {\n    int x = que[ql++];\n    for (int y : G[x])\n      if (vis[y] < 2 && tag[y] != ver) {\n        ++vis[y];\n        tag[y] = ver;\n        que[++qr] = y;\n      }\n  }\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1, x, y; i <= m; ++i) {\n    scanf(\"%d %d\", &x, &y);\n    E[i] = { x, y };\n    G[x].push_back(y);\n  }\n  for (int i = 1; i <= n; ++i)\n    bfs1(i);\n  for (int i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    vis[i] = 233;\n    for (int j : G[i])\n      if (vis[j] < 2)\n        bfs2(j);\n    for (int j = 1; j <= n; ++j)\n      if (vis[j] >= 2)\n        B[i][j] = 1;\n  }\n  for (int i = 1; i <= m; ++i) {\n    int x = E[i].x, y = E[i].y,\n        cnt = A[y][x] + B[x][y];\n    puts(cnt == 1 ? \"diff\" : \"same\");\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pi = pair<int, int>;\nconst int MAXN = 1005;\nconst int MAXM = 200005;\n\nvector<int> gph[MAXN];\nint adj[MAXN][MAXN], vis[MAXN];\nint n, m;\nint s[MAXM], e[MAXM];\n\nvoid dfs(int r, int v){\n\tvis[v] = 1;\n\tadj[r][v]++;\n\tfor(auto &i : gph[v]){\n\t\tif(i == r) continue;\n\t\tif(!vis[i] && adj[r][i] < 2){\n\t\t\tdfs(r, i);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i=0; i<m; i++){\n\t\tscanf(\"%d %d\",&s[i],&e[i]);\n\t\tgph[s[i]].push_back(e[i]);\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(adj[i][j] < 2){\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tdfs(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tif(adj[e[i]][s[i]] == 0){\n\t\t\tputs(adj[s[i]][e[i]] > 1 ? \"diff\" : \"same\");\n\t\t}\n\t\telse{\n\t\t\tputs(adj[s[i]][e[i]] > 1 ? \"same\" : \"diff\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[M],V[M];\nvector<int>e[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs1(int u,int k)\n{\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=666;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis1[e[i][j]])\n            dfs1(e[i][j],j+1);\n        for(int j=up-1;j>=0;j--)\n            if(!vis2[e[i][j]])\n            dfs2(e[i][j],j+1);\n        for(int j=1;j<=n;j++)\n            if(vis1[j]&&j!=i)\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(mp[U[i]][V[i]]&&mp[V[i]][U[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cctype>\n#include<vector>\nusing namespace std;\nint read()\n{\n    char tmp;\n    int f(1),x(0);\n    for(tmp=getchar();!isdigit(tmp);tmp=getchar()) if(tmp=='-') f=-1;\n    for(;isdigit(tmp);tmp=getchar()) x=x*10+tmp-'0';\n    return f*x;\n}\ntypedef struct edge{\n    int index,to;\n    edge(){}\n    edge(const int & a,const int & b):index(a),to(b){}\n}EDGE;\nvector<vector<EDGE> > graph;\nint from[200001],to[200001];\nint searcharr[1001][1001][2]={0},tme;\nint n,m,visited[1001],u,v;\nvoid DFS(const int & k,const int & num,const int & from,const int & flag)\n{\n    int limit=graph[k].size();\n    visited[k]=tme;\n    searcharr[from][k][flag]=num;\n    for(int i=0;i<limit;i++)\n        if(visited[graph[k][i].to]!=tme)\n            DFS(graph[k][i].to,num,from,flag);\n}\nvoid solve(const int & k)\n{\n    int limit=graph[k].size();\n    visited[k]=++tme;\n    for(int i=0;i<limit;i++)\n        if(visited[graph[k][i].to]!=tme)\n            DFS(graph[k][i].to,graph[k][i].index,k,0);\n    reverse(graph[k].begin(),graph[k].end());\n    visited[k]=++tme;\n    for(int i=0;i<limit;i++)\n        if(visited[graph[k][i].to]!=tme)\n            DFS(graph[k][i].to,graph[k][i].index,k,1);\n}\nint main()\n{\n    n=read(); m=read();\n    graph.resize(n+1);\n    for(int i=1;i<=m;i++)\n    {\n        u=read(); v=read();\n        from[i]=u; to[i]=v;\n        graph[u].push_back(EDGE(i,v));\n    }\n    for(int i=1;i<=n;i++)\n        solve(i);\n    for(int i=1;i<=m;i++)\n    {\n        if((searcharr[to[i]][from[i]][0]!=0)^(searcharr[from[i]][to[i]][0]!=i||searcharr[from[i]][to[i]][1]!=i))\n            printf(\"diff\\n\");\n        else\n            printf(\"same\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[N],vi[N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vi[v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tmemset(vi,0,sizeof(vi));\n\t\tdfs_vis(i,i);\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid,LL rt){\n\tif(pid) vis[1][rt][u] = (p[u] != col);\n\telse p[u] = col;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vi[v]) continue;\n\t\tdfs_sol(v,col,pid,rt);\n\t}\n}\n\nvoid solve(LL u){\n\tmemset(p,0,sizeof(p));\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!vi[ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,0,u);\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!vi[ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,1,u);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(i);\n\t}\n\tget_vis();\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n//\tfor(LL i = 1;i <= m;i ++) cout << ans[0][i] << ' ' << ans[1][i] << endl;\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\nint n,m; \nstruct edge{\n\tint from;\n\tint to;\n\tint next;\n}E[maxm];\nint sz=0; \nint head[maxn];\nvoid add_edge(int u,int v){\n\tsz++;\n\tE[sz].from=u;\n\tE[sz].to=v;\n\tE[sz].next=head[u];\n\thead[u]=sz;\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tused[x]=1;\n\troute[s][x]++;\n\tfor(int i=head[x];i;i=E[i].next){\n\t\tint y=E[i].to;\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tadd_edge(u,v);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=head[i];j;j=E[j].next){\n\t\t\tint y=E[j].to;\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tprintf(\"%d \",route[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(E[i].from,E[i].to)) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//test\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\nint n, m, clk, cnt;\nstd::vector<std::vector<std::pair<int, int>>> e;\nstd::vector<int> a, b, ans, dfn, low, belong, stk;\nstd::vector<std::vector<int>> f;\nvoid dfs(int u) {\n    stk.push_back(u);\n    dfn[u] = low[u] = clk++;\n    for (auto &&edge : e[u]) {\n        int v, i;\n        std::tie(v, i) = edge;\n        if (dfn[v] == -1) {\n            dfs(v);\n            low[u] = std::min(low[u], low[v]);\n        } else if (belong[v] == -1) {\n            low[u] = std::min(low[u], dfn[v]);\n        }\n    }\n    if (dfn[u] == low[u]) {\n        int v;\n        do {\n            v = stk.back();\n            stk.pop_back();\n            belong[v] = cnt;\n        } while (v != u);\n        ++cnt;\n    }\n}\nvoid solve() {\n    for (int s = 0; s < n; ++s) {\n        f.assign(n, std::vector<int>(2, -1));\n        std::queue<std::pair<int, int>> que;\n        f[s][0] = f[s][1] = s;\n        for (auto &&edge : e[s]) {\n            int v, i;\n            std::tie(v, i) = edge;\n            f[v][0] = v;\n            que.emplace(v, 0);\n        }\n        while (!que.empty()) {\n            int u, j;\n            std::tie(u, j) = que.front();\n            que.pop();\n            for (auto &&edge : e[u]) {\n                int v, i;\n                std::tie(v, i) = edge;\n                if (f[v][0] == -1) {\n                    f[v][0] = f[u][j];\n                    que.emplace(v, 0);\n                } else if (f[v][1] == -1 && f[v][0] != f[u][j]) {\n                    f[v][1] = f[u][j];\n                    que.emplace(v, 1);\n                }\n            }\n        }\n        for (auto &&edge : e[s]) {\n            int v, i;\n            std::tie(v, i) = edge;\n            if (f[v][1] != -1)\n                ans[i] ^= 1;\n        }\n    }\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n >> m;\n    a.resize(m);\n    b.resize(m);\n    ans.resize(m);\n    e.resize(n);\n    dfn.assign(n, -1);\n    low.resize(n);\n    belong.assign(n, -1);\n    for (int i = 0; i < m; ++i) {\n        std::cin >> a[i] >> b[i];\n        --a[i];\n        --b[i];\n        e[a[i]].emplace_back(b[i], i);\n    }\n    for (int i = 0; i < n; ++i)\n        if (dfn[i] == -1)\n            dfs(i);\n    for (int i = 0; i < m; ++i)\n        if (belong[a[i]] == belong[b[i]])\n            ans[i] = 1;\n    solve();\n    for (int i = 0; i < m; ++i)\n        std::cout << (ans[i] == 1 ? \"diff\" : \"same\") << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tcin >> N >> M;\n\tvector<vector<int>>edge(N);\n\tvector<vector<int>>index(N, vector<int>(N, -1));\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tR--;\n\t\tedge[L].push_back(R);\n\t\tindex[L][R] = i;\n\t}\n\tvector<string>ans(M);\n\tvector<int>num(M);\n\tvector<vector<int>>connect(N, vector<int>(N));\n\tqueue<int>Q;\n\tfor (int i = 0; i < N; i++) {\n\t\tQ.push(i);\n\t\tconnect[i][i] = 1;\n\t\twhile (!Q.empty()) {\n\t\t\tint cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (auto j : edge[cn]) {\n\t\t\t\tif (connect[i][j])continue;\n\t\t\t\tconnect[i][j] = 1;\n\t\t\t\tQ.push(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tvector<int>visit(N);\n\t\tvisit[i] = 1;\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (visit[j])num[index[i][j]] = 1;\n\t\t\telse {\n\t\t\t\tvisit[j] = 1;\n\t\t\t\tQ.push(j);\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint cn = Q.front();\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (auto k : edge[cn]) {\n\t\t\t\t\t\tif (visit[k])continue;\n\t\t\t\t\t\tvisit[k] = 1;\n\t\t\t\t\t\tQ.push(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tvector<int>visit(N);\n\t\tvisit[i] = 1;\n\t\treverse(edge[i].begin(), edge[i].end());\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (visit[j])num[index[i][j]] = 1;\n\t\t\telse {\n\t\t\t\tvisit[j] = 1;\n\t\t\t\tQ.push(j);\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint cn = Q.front();\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (auto k : edge[cn]) {\n\t\t\t\t\t\tif (visit[k])continue;\n\t\t\t\t\t\tvisit[k] = 1;\n\t\t\t\t\t\tQ.push(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tnum[index[i][j]] -= connect[j][i];\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcout << (num[i] ? \"diff\" : \"same\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// u -> v same: ban u -> v, u is reachable from v ^ vice versa = 0\n// Problem : F - Two Faced Edges\n// Contest : AtCoder Regular Contest 092\n// URL : https://atcoder.jp/contests/arc092/tasks/arc092_d\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define sort(a, n) sort(a + 1, a + n + 1)\n#define temptts template <class T, class... Ts>\n\nconst int N = 1001, M = 2e5 + 2, mod = 1e9 + 7, inf = 2e9;\n\nstruct edge_list {\n\tint u, v, pre, nex;\n} edge[M];\n\nbool vis[N];\nint n, m, ban, ans[M], cur[M], head[N], tail[N];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor (int i = head[v]; i; i = edge[i].pre) {\n\t\tint u = edge[i].v;\n\t\tif (u == ban || vis[u]) continue;\n\t\tdfs(u);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tedge[i] = {u, v, head[u], 0};\n\t\thead[u] = i;\n\t}\n\tfor (int i = m; i >= 1; i--) {\n\t\tint u = edge[i].u;\n\t\tedge[i].nex = tail[u];\n\t\ttail[u] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tban = 0;\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint u = edge[j].u, v = edge[j].v;\n\t\t\tif (v == i) ans[j] ^= vis[u];\n\t\t}\n\t\tban = i;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int j = head[i]; j; j = edge[j].pre) {\n\t\t\tint u = edge[j].v;\n\t\t\tcur[j] |= vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int j = tail[i]; j; j = edge[j].nex) {\n\t\t\tint u = edge[j].v;\n\t\t\tans[j] ^= cur[j] | vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tcout << (ans[i] ? \"diff\" : \"same\") << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int sccid, int id)\n{\n\tSCC scc; \n\tvi coord; vector<ii> E;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tif(lab==id) swap(u,v);\n\t\tE.pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tE[i].fi=lower_bound(coord.begin(),coord.end(),E[i].fi)-coord.begin();\n\t\tE[i].se=lower_bound(coord.begin(),coord.end(),E[i].se)-coord.begin();\n\t}\n\tscc.init(coord.size());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tscc.addedge(E[i].fi,E[i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\n\nbool reach[1111][1111];\nmap<ii,int> CNT;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i][i]=1;\n\t\tqueue<int> q; q.push(i);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front(); q.pop();\n\t\t\tfor(ii x:adj[u])\n\t\t\t{\n\t\t\t\tint v=x.fi; \n\t\t\t\tif(!reach[i][v]) q.push(v);\n\t\t\t\treach[i][v]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tbool pos=0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j==i) continue;\n\t\t\t\t\tif(j==v) continue;\n\t\t\t\t\tif(reach[i][j]&&reach[j][v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpos=1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/// kAAzuki Hoshino\n/*\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long long ll;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n//#define inf 1000000000\n#define mod 1000000007\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n    return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n    o<<\"{\";\n    for(const T& v:vc) o<<v<<\",\";\n    o<<\"}\";\n    return o;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MAXM = 200005;\nconst int MAXN = 1005;\nint used[MAXN], condition[MAXM], vis[MAXN][MAXN], a[MAXM], b[MAXM] ;\nvi adj[MAXN];\nint N,M;\nint r[MAXN],cond[MAXM];\n\nvoid dfs(int s, int base){\n\tif(vis[base][s])return;\n\tvis[base][s]=1;\n\tfor(auto t:adj[s]){\n\t\tdfs(t, base);\n\t}\n}\n\nvoid bfs(int s){\n\tmemset(used,0,sizeof(used));\n\tmemset(r,-1,sizeof(r));\n\tfor(auto t:adj[s]){\n\t\tif(r[t]!=-1){\n\t\t\tused[t]=1;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push(t);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tr[v] = t;\n\t\t\tfor(auto u:adj[v]){\n\t\t\t\tif(u==s)continue;\n\t\t\t\tif(r[u]!=-1){\n\t\t\t\t\tif(r[u]!=t)used[u]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor(int i=1;i<=N;i++)if(used[i])q.push(i);\n\twhile(!q.empty()){\n\t\tint v = q.front();q.pop();\n\t\tused[v]=1;\n\t\tfor(auto t:adj[v]){\n\t\t\tif(t==s)continue;\n\t\t\tif(used[t])continue;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\tfor(int i=1;i<=M;i++){\n\t\tif(a[i]==s){\n\t\t\tcondition[i] = used[b[i]];\n\t\t}\n\t\tif(b[i]==s){\n\t\t\tcond[i] = (r[a[i]]!=-1);\n\t\t}\n\t}\n\n}\n\nsigned main(){\nIOS;\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n\t\n\tcin >> N >> M;\n  for(int i=1;i<=M;i++){\n  \tcin >> a[i] >> b[i];\n  \tadj[a[i]].pb(b[i]);\n  }  \n  for(int i=1;i<=N;i++){\n  \tdfs(i, i);\n  }\n  for(int i=1;i<=N;i++){\n  \tbfs(i);\n  }\n  for(int i=1;i<=M;i++){\n  \tif(condition[i]==cond[i]){\n  \t\tcout << \"same\" << endl;\n  \t}\n  \telse cout << \"diff\" << endl;\n  }\n\nreturn 0;\n}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#define maxn 2000100\nusing namespace std;\nint n,m,tot,vis[1010],sz[1010],fr[1010],to[1010],dis[1010][1010],th[1010][1010];\nvector<int> v[1010];\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tdis[s][x]=1; vis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=0;i<sz[x];i++)\n\t\tdfs(v[x][i],s,cur);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&fr[i],&to[i]);\n\t\tv[fr[i]].push_back(to[i]); sz[fr[i]]++;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=0;j<sz[i];j++) dfs(v[i][j],i,j+1);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=fr[i],y=to[i];\n\t\tif((dis[y][x]&&th[x][y]!=-1)||(!dis[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{edge*nx;int t;}e[MM*3+5],*h[MN+5],*r[MN+5],*c[MN+5];\nint en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(edge**h,int x,int y){e[++en]=(edge){h[x],y};h[x]=e+en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)\n\t\tif(!d[i->t])dfs(i->t),l[x]=min(l[x],l[i->t]);\n\t\telse if(inz[i->t])l[x]=min(l[x],d[i->t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(edge**h,int x,int z)\n{\n\tu[x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)if(!u[i->t])d1(h,i->t,z),uu[i-e>>1]|=z;\n}\nbool d2(edge**h,int x,int d,int s)\n{\n\tmemset(u,0,sizeof(u));int i;\n\tfor(u[q[i=qn=0]=x]=1;i<=qn;++i)for(edge*j=h[q[i]];j;j=j->nx)\n\t{\n\t\tif((j-e>>1)!=d&&!u[j->t])u[q[++qn]=j->t]=1;\n\t\tif(u[s])return false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n=read(),m=read(),i,j;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tmemset(h,0,sizeof(h));memset(r,0,sizeof(r));en=1;\n\tfor(i=1;i<=m;++i)if(p[x[i]]==p[y[i]])ins(h,x[i],y[i]),ins(r,y[i],x[i]);else en+=2;\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(edge*k=c[q[j]];k;k=k->nx)if(!g[i][k->t]++)q[++qn]=k->t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse puts(((uu[i]&1)&&d2(h,ph[p[x[i]]],i,y[i]))\n\t\t\t\t||((uu[i]&2)&&d2(r,ph[p[x[i]]],i,x[i]))?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define inlien inline\n#define retrun return\n#define cpnst const\nbool can[1111][1111],exc[1111][1111];\ninline bool ask(int x,int y)\n{return can[y][x]^exc[x][y];}\nint x[222222],y[222222],n,m;\n#include<vector>\nstd::vector<int>v[1111];\nbool vis[1111];\ninline void dfs(int s,int p)\n{\n\tif(vis[p])return;\n\tvis[p]=can[s][p]=1;\n\tfor(register int i=0;i<v[p].size();i++)\n\t\tdfs(s,v[p][i]);\n}\nint frm[1111];\ninline void efs(int fs,int s,int p)\n{\n\tif(vis[p])return;vis[p]=1;\n\tif(frm[p])if(frm[p]^s)exc[fs][p]=1;frm[p]=s;\n\tfor(register int i=0;i<v[p].size();i++)\n\t\tefs(fs,s,v[p][i]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tregister int i,ii;\n\tfor(i=1;i<=m;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]),v[x[i]].push_back(y[i]);\n\tfor(i=1;i<=n;i++)\n\t{for(ii=1;ii<=n;ii++)vis[ii]=0;dfs(i,i);}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(ii=1;ii<=n;ii++)vis[ii]=frm[ii]=0;\n\t\tvis[i]=1;\n\t\tfor(ii=0;ii<v[i].size();ii++)efs(i,v[i][ii],v[i][ii]);\n\t\tfor(ii=1;ii<=n;ii++)vis[ii]=0;\n\t\tfor(ii=v[i].size()-1;~ii;ii--)efs(i,v[i][ii],v[i][ii]);\n\t}for(i=1;i<=m;i++)puts(ask(x[i],y[i])?\"diff\":\"same\");\n}\n/*\nGiving the world a better yourself is giving yourself a better world. \n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\nconst int N=1005;\n\nint n,m;\nint ans[N*200],t[N][N],tt[N],b[N*200],a[N*200];\n\nint D,del,clk,vis[N];\nvoid dfs(int u)\n{\n\tif (vis[u]) return;\n\tif (u==del) return;\n\tvis[u]=clk;\n\tfor (int i=1;i<=tt[u];i++) dfs(b[t[u][i]]);\n}\n\nvoid work(int u)\n{\n\tdel=u;\n\tmemset(vis,0,sizeof(vis));\n\tfor (int v,i=1;i<=tt[u];i++)\n\t{\n\t\tclk=v=b[t[u][i]];\n\t\tdfs(v);\n\t}\n\tfor (int v,i=1;i<=tt[u];i++) \n\t{\n\t\tv=b[t[u][i]];\n\t\tif (v!=vis[v]) ans[t[u][i]]=1;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int u,v,i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\ta[i]=u,b[i]=v;\n\t\tt[u][++tt[u]]=i;\n\t}\n\t\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\twork(u);\n\t\tfor (int i=1;i<=tt[u]/2;i++) swap(t[u][i],t[u][ tt[u]-i+1 ]);\n\t\twork(u);\n\t}\n\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tclk=1;\n\t\tdel=0;\n\t\tdfs(u);\n\t\tfor (int i=1;i<=m;i++) if (b[i]==u) ans[i]^=vis[a[i]];\n\t}\n\n\tfor (int i=1;i<=m;i++) if (ans[i]) puts(\"diff\");else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s){\n    for (int i=g[x];i;i=a[i][1])\n        if (a[i][0]!=s){\n            if (!f[s][a[i][0]][0])f[s][a[i][0]][0]=x;\n            else\n                if (!f[s][a[i][0]][1])f[s][a[i][0]][1]=x;\n            if (f[s][a[i][0]][0]==x)dfs(a[i][0],s);\n        }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for (int i=1;i<=m;i++){\n        cin>>e[i][0]>>e[i][1];\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++)\n        dfs(i,i);\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][0])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][0]));\n        sig==sig1?cout<<\"same\"<<endl:cout<<\"diff\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxm 200010\n#define maxn 1010\nusing namespace std;\ntypedef long long LL;\nstruct Edge {\n    int from, to, ne;\n}edge[maxm];\nint head[maxn], ne[maxm], pre[maxm], T, tot;\nbool flag[maxn][maxn];\nint f1[maxn][maxn], f2[maxn][maxn], vis[maxn];\nvoid add(int u, int v) {\n    if (~ne[u]) pre[ne[u]] = tot;\n    else head[u] = tot;\n    edge[tot] = {u, v, ne[u]};\n    ne[u] = tot++;\n}\nvoid dfs1(int src, int u) {\n    flag[src][u] = true; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v] != T) dfs1(src, v);\n    }\n}\nvoid dfs2(int src, int exc, int u, int f[maxn][maxn]) {\n    if (~f[exc][u]) return;\n    f[exc][u] = src; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v]!=T && v!=exc) dfs2(src, exc, v, f);\n    }\n}\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    int n, m;\n    memset(ne, -1, sizeof ne);\n    memset(head, -1, sizeof head);\n    memset(f1, -1, sizeof f1);\n    memset(f2, -1, sizeof f2);\n    scanf(\"%d%d\", &n, &m);\n    F(i, 0, m) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u, v);\n    }\n//    F2(i, 1, n) printf(\"%d\\n\", head[i]);\n//    F(i, 0, m) printf(\"%d\\n\", pre[i]);\n//    F2(i, 1, n) {\n//        ++T; dfs1(i, i);\n//    }\n    F2(i, 1, n) {\n        for (int j = ne[i]; ~j; j = edge[j].ne) {\n            int v = edge[j].to;\n            ++T;\n            dfs2(j, i, edge[j].to, f1);\n        }\n        if (head[i]==-1) continue;\n        for (int j = head[i]; ; j = pre[j]) {\n//            printf(\"dfs2 : %d %d\\n\", i, j);\n            int v = edge[j].to;\n            ++T; dfs2(j, i, edge[j].to, f2);\n            if (j==ne[i]) break;\n        }\n    }\n\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", flag[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f1[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f2[i][j]); puts(\"\");\n//    }\n    F(i, 0, m) {\n        int u=edge[i].from, v=edge[i].to;\n        if (f1[u][v]!=-1 ^ (f1[u][v]!=i||f2[u][v]!=i)) puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 1005;\n\nvector<int> G[MAX_N];\nvector<int> gx[MAX_N],gy[MAX_N];\nbool visit[MAX_N][MAX_N];\nbool ok[200001];\nbool okk[200001];\nbool x[MAX_N][MAX_N],y[MAX_N][MAX_N];\nint id[MAX_N][MAX_N];\n\nvoid dfs(const int st,int u,bool hoge[MAX_N][MAX_N],vector<int>* g)\n{\n\thoge[st][u] = true;\n\teach(v,g[u]){\n\t\tif(!hoge[st][v]){\n\t\t\tdfs(st,v,hoge,g);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m;\n\tcin >> n >> m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a,--b;\n\t\tG[a].pb(b);\n\t\tid[a][b] = i;\n\t}\n\trep(i,n){\n\t\tdfs(i,i,visit,G);\n\t}\n\trep(i,n){\n\t\tx[i][i] = y[i][i] = true;\n\t\trep(j,n){\n\t\t\tgx[j].clear(),gy[j].clear();\n\t\t\tif(i == j) continue;\n\t\t\trep(k,len(G[j])){\n\t\t\t\tgx[j].pb(G[j][k]);\n\t\t\t\tgy[j].pb(G[j][k]);\n\t\t\t}\n\t\t}\n\t\trep(j,len(G[i])){\n\t\t\tokk[id[i][G[i][j]]] = visit[G[i][j]][i];\n\t\t\tok[id[i][G[i][j]]] |= x[i][G[i][j]];\n\t\t\tgx[i].pb(G[i][j]);\n\t\t\tdfs(i,G[i][j],x,gx);\n\t\t}\n\t\trrep(j,len(G[i])){\n\t\t\tok[id[i][G[i][j]]] |= y[i][G[i][j]];\n\t\t\tgy[i].pb(G[i][j]);\n\t\t\tdfs(i,G[i][j],y,gy);\n\t\t}\n\t}\n\trep(i,m){\n\t\tif(ok[i] == okk[i]){\n\t\t\tcout << \"same\\n\";\n\t\t}else{\n\t\t\tcout << \"diff\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\nusing ll = long long;\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\nvector< vector<int> > e, re;\n\nUnionFind cc(1024);\nUnionFind scc(1024);\nint post[1024];\nint rev[1024];\nbool visited[1024];\nbool visited2[1024];\n\nint t = 1;\n\nvoid dfs0(int u, int r) {\n    cc.unite(u, r);\n    post[u] = 1;  // dummy\n    for (int w : e[u]) {\n        if (!post[w]) {\n            dfs0(w, r);\n        }\n    }\n    post[u] = t;\n    rev[t] = u;\n    ++t;\n}\n\nvoid dfs1(int u, int r, int cr, bool visited[]) {\n    scc.unite(u, r);\n    visited[u] = true;\n    for (int w : re[u]) {\n        if (cc.find(w) != cr) {\n            continue;\n        }\n        if (!visited[w]) {\n            dfs1(w, r, cr, visited);\n        }\n    }\n}\n\nvoid dfs2(int u, int r, int first, set< pair<int, int> >& rs, bool visited[]) {\n    visited[u] = true;\n    for (int w : e[u]) {\n        if (!visited[w]) {\n            dfs2(w, r, first, rs, visited);\n        } else if (w != r && w != first) {\n            rs.insert(make_pair(r, w));\n        }\n    }\n}\n\nvoid traverse(int n, int s, set< pair<int, int> >& rs) {\n    fill(visited2, visited2 + n + 1, false);\n    visited2[s] = true;\n    for (int w : e[s]) {\n        visited2[w] = true;\n    }\n    for (int w : e[s]) {\n        dfs2(w, s, w, rs, visited2);\n    }\n}\n\nvoid solve(int n, int m, vector< pair<int, int> >& edges) {\n    int cur;\n    int r1, cr;\n\n    fill(post, post + n + 1, 0);\n    fill(rev, rev + n + 1, 0);\n\n    fill(visited, visited + n + 1, false);\n    rep(r, 1, n + 1) {\n        if (!post[r]) {\n            cur = t;\n            dfs0(r, r);\n            cr = cc.find(r);\n            for (int v = t - 1; v >= cur; --v) {\n                r1 = rev[v];\n                if (!visited[r1]) {\n                    dfs1(r1, r1, cr, visited);\n                }\n            }\n        }\n    }\n\n    set< pair<int, int> > path_exists;\n    int a, b;\n    int scc_a, scc_b;\n    bool exist;\n    \n    fill(visited, visited + n + 1, false);\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        if (!visited[a]) {\n            visited[a] = true;\n            traverse(n, a, path_exists);\n        }\n    }\n\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        scc_a = scc.find(a);\n        scc_b = scc.find(b);\n        exist = (path_exists.find(make_pair(a, b)) != path_exists.end());\n        cout << ((scc_a == scc_b) ^ exist ? \"diff\" : \"same\") << endl;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n\n    int n, m;\n    int a, b;\n    vector< pair<int, int> > edges;\n    \n    cin >> n >> m;\n    e.resize(n + 1);\n    re.resize(n + 1);\n    rep(i, 0, m) {\n        cin >> a >> b;\n        edges.push_back(make_pair(a, b));\n        e[a].push_back(b);\n        re[b].push_back(a);\n    }\n\n    solve(n, m, edges);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 1005;\nconst int Maxm = 200005;\n\nint n, m;\nint a[Maxm], b[Maxm];\nvector <ii> neigh[Maxn];\nint cur, tim[Maxn], low[Maxn];\nint imp[Maxm];\nint my[Maxn];\nvector <int> S;\nbool onStack[Maxn];\nint curcol, col[Maxn];\nint res[Maxm];\nint dp[Maxn];\nvector <int> gneigh[Maxn];\nbool vis[Maxn];\n\nint Connect(int v)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tmy[v] = -1;\n\tS.push_back(v); onStack[v] = true;\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (!tim[u.first]) {\n\t\t\timp[u.second] |= 2;\n\t\t\tres += Connect(u.first); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v]) {\n\t\t\tif (my[v] != -1) imp[my[v]] ^= 1;\n\t\t\tlow[v] = tim[u.first];\n\t\t\timp[u.second] ^= 1; \n\t\t\tmy[v] = u.second;\n\t\t}\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tcurcol++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tcol[w] = curcol;\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int v, int forb)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tS.push_back(v); onStack[v] = true;\n\tif (v == b[forb]) {\n\t\tint u = a[forb];\n\t\tif (!tim[u]) {\n\t\t\tres += Count(u, forb); low[v] = min(low[v], low[u]); \n\t\t} else if (onStack[u] && tim[u] < low[u])\n\t\t\tlow[u] = tim[u];\n\t}\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (u.second == forb) continue;\n\t\tif (!tim[u.first]) {\n\t\t\tres += Count(u.first, forb); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v])\n\t\t\tlow[v] = tim[u.first];\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int forb)\n{\n\tint ans = 0;\n\tfill(tim, tim + Maxn, 0); fill(low, low + Maxn, 0);\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tans += Count(i, forb);\n\treturn ans; \n}\n\nint Visit(int v)\n{\n\tif (vis[v]) return dp[v];\n\tint res = 0;\n\tfor (int i = 0; i < gneigh[v].size(); i++)\n\t\tres = max(res, Visit(gneigh[v][i]) + 1);\n\tdp[v] = res; vis[v] = true;\n\treturn dp[v];\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\", &a[i], &b[i]);\n\t\tneigh[a[i]].push_back(ii(b[i], i));\n\t}\n\tint comp = 0;\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tcomp += Connect(i);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (col[a[i]] != col[b[i]]) {\n\t\t\tgneigh[col[a[i]]].push_back(col[b[i]]);\n\t\t} else if (imp[i]) res[i] = Count(i) != comp;\n\tfor (int i = 1; i <= curcol; i++)\n\t\tVisit(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!imp[i] && col[a[i]] != col[b[i]]) res[i] = abs(dp[col[a[i]]] - dp[col[b[i]]]) > 1;\n\t\tprintf(\"%s\\n\", res[i]? \"diff\": \"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=2e5+10;\nint w[M],ne[M],la[N],t,ans[M];\nvoid link(int x,int y){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n}\nint arv[N][N],n,m,X,mrk[N],ti,mrk2[N];\nvoid dfs(int x){\n\tarv[X][x]=1;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (!arv[X][w[y]])dfs(w[y]);\n}\nvoid go(int x){\n\tmrk[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk[w[y]])go(w[y]);\n}\nvoid go2(int x){\n\tmrk2[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk2[w[y]])go2(w[y]);\n}\nvector<int> c;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tfor (X=1;X<=n;X++){\n\t\tc.clear();\n\t\tfor (int y=la[X];y;y=ne[y]){\n\t\t\tti++;\n\t\t\tif (!mrk[w[y]])go(w[y]);\n\t\t\tc.push_back(w[y]);\n\t\t}\n\t\twhile (c.size()){\n\t\t\tif (!mrk2[c.back()])go2(c.back());\n\t\t\tc.pop_back();\n\t\t\tti--;\n\t\t}\n\t\tfor (int y=la[X];y;y=ne[y])ans[y]=(mrk[w[y]]<mrk2[w[y]]);\n\t\tfor (int i=1;i<=n;i++)arv[X][i]=mrk[i],mrk[i]=mrk2[i]=0;\n\t}\n\tfor (int x=1;x<=n;x++)\n\t\tfor(int y=la[x];y;y=ne[y])\n\t\t\tans[y]=ans[y]==arv[w[y]][x];\n\tfor (int i=1;i<=m;i++)\n\t\tputs(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1100;\nconst int maxm = 220000;\n\nint u[maxm], v[maxm];\nvector<int> g[maxn];\nbool chk[maxn][maxn];\nint root;\nbool vis[maxn];\n\nnamespace SCC {\n\tconst int N = 1100;\n\tint T, qn;\n\tint q[N], vis[N];\n\tvector<int> adj[N], radj[N];\n\t\n\tvoid dfs(int u) {\n\t\tvis[u] = 1;\n\t\tfor (int v : adj[u]) {\n\t\t\tif (!vis[v]) dfs(v);\n\t\t}\n\t\tq[++qn] = u;\n\t}\n\t\n\tvoid rdfs(int u) {\n\t\tvis[u] = T;\n\t\tfor (int v : radj[u]) {\n\t\t\tif (!vis[v]) rdfs(v);\n\t\t}\n\t}\n\t\n\tvoid SCC(int n) {\n\t\tmemset(vis, 0, sizeof(int) * (n + 1));\n\t\tqn = 0;\n\t\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\t\tmemset(vis, 0, sizeof(int) * (n + 1));\n\t\tfor (int i = n; i > 0; i--) if (!vis[q[i]]) ++T, rdfs(q[i]);\n\t}\n};\n\ninline void dfs(int u) {\n\tvis[u] = true;\n\tfor(auto v : g[u]) {\n\t\tif(vis[v]) {\n\t\t\tif(u == root) chk[root][v] = false;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v);\n\t\tif(u == root) chk[root][v] &= true;\n\t\telse chk[root][v] = false;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n, m; cin >> n >> m;\n\tfor(int i = 0; i < m; ++ i) {\n\t\tcin >> u[i] >> v[i];\n\t\tg[u[i]].push_back(v[i]);\n\t\tSCC::adj[u[i]].push_back(v[i]);\n\t\tSCC::radj[v[i]].push_back(u[i]);\n\t}\n\t// get SCC\n\tSCC::SCC(n);\n\t// check the u -> v edge is the unique way.\n\tfor(int i = 1; i <= n; ++ i) for(int j = 1; j <= n; ++ j) chk[i][j] = true;\n\tfor(int step = 0; step < 2; ++ step) {\n\t\tfor(int i = 1; i <= n; ++ i) {\n\t\t\troot = i;\n\t\t\tif(step) reverse(g[i].begin(), g[i].end());\n\t\t\tmemset(vis, false, sizeof vis);\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++ i) {\n\t\tint flag = SCC::vis[u[i]] == SCC::vis[v[i]];\n\t\tif(chk[u[i]][v[i]] == flag) cout << \"diff\\n\";\n\t\telse cout << \"same\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n// for testing\n\n//*\n\nvoid kosaraju(int);\nvoid kosaraju2(int, int);\n\nint mat[1010][1010];\n\nvoid kosaraju_mat(int f) {\n    for (int u=1; u<=n; ++u) {\n        if (mat[f][u] && !starred[u]) {\n            starred[u] = true;\n            kosaraju_mat(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2_mat(int f, int f2) {\n    unf[f] = f2;\n    for (int u=1; u<=n; ++u) {\n        if (mat[f][u] && !unf[u]) {\n            kosaraju2_mat(u, f2);\n        }\n    }\n}\n\nvoid slow_print() {\n    memset(starred, 0, 1010 * sizeof(bool));\n    memset(unf, 0, 1010 * sizeof(int));\n    kos.clear();\n    for (auto u : piv) {\n        mat[u.first][u.second] = 1;\n    }\n    int c = 0, i;\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            ++c;\n            kosaraju2(u, u);\n        }\n    }\n    for (auto u : piv) {\n        int tc = 0;\n        --mat[u.first][u.second];\n        ++mat[u.second][u.first];\n        kos.clear();\n        memset(starred, 0, 1010 * sizeof(bool));\n        memset(unf, 0, 1010 * sizeof(int));\n        for (i=1; i<=n; ++i) {\n            if (!starred[i]) {\n                starred[i] = true;\n                kosaraju_mat(i);\n            }\n        }\n        for (int u : kos) {\n            if (!unf[u]) {\n                ++tc;\n                kosaraju2_mat(u, u);\n            }\n        }\n        puts(c == tc ? \"same\" : \"diff\");\n        ++mat[u.first][u.second];\n        --mat[u.second][u.first];\n    }\n}\n\n//*/\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    if ((lli)n * n * m <= 2e8) {\n        slow_print();\n        return 0;\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            topo_sort[topo_cnt++] = u;\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    reverse(topo_sort, topo_sort + topo_cnt);\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=0; i<topo_cnt; ++i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    /*\n    for (i=1; i<=n; ++i) {\n        for (int j=1; j<=n; ++j) {\n            printf(\"%s\", dag_visit[i].test(j) ? \"1\" : \"0\");\n        }\n        puts(\"\");\n    }\n    //*/\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            int n1 = unf[u.first], n2 = unf[u.second];\n            puts(dag_edge[n1][n2] >= 2 || dag_second_visit[n1].test(n2) ? \"diff\" : \"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M;\nint A[1 << 18], B[1 << 18];\nint Answer[1 << 18];\n\n// 強連結成分分解\nvector<int> X[1009], Y[1009], I;\nbool used[1009];\nint col[1009], group[1009], cnts;\n\nvoid dfs1(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs1(X[pos][i]);\n\t}\n\tI.push_back(pos);\n}\n\nvoid dfs2(int pos) {\n\tcol[pos] = cnts; group[cnts]++;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (col[Y[pos][i]] >= 1) continue;\n\t\tdfs2(Y[pos][i]);\n\t}\n}\n\n// DAG における計算\nvector<pair<int, int>> Z[1009];\nint dp[1009][1009];\n\n// サイクルの列挙\nvector<pair<int, int>> P[1009], Q[1009];\nint Score1[1 << 18], Score2[1 << 18];\n\nint dfs5(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < P[pos].size(); i++) {\n\t\tif (used[P[pos][i].first] == true) continue;\n\t\tr += dfs5(P[pos][i].first);\n\t}\n\treturn r;\n}\n\nint dfs6(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < Q[pos].size(); i++) {\n\t\tif (used[Q[pos][i].first] == true) continue;\n\t\tr += dfs6(Q[pos][i].first);\n\t}\n\treturn r;\n}\n\n// 最後の計算\nvector<int> J[1009], J2[1009], K;\nint colo[1009], cntv;\n\nvoid dfs3(int pos) {\n\tused[pos] = true;\n\tfor (int i : J[pos]) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\tK.push_back(pos);\n}\n\nvoid dfs4(int pos) {\n\tcolo[pos] = cntv;\n\tfor (int i : J2[pos]) {\n\t\tif (colo[i] >= 1) continue;\n\t\tdfs4(i);\n\t}\n}\n\nbool calc(int pos) {\n\tfor (int i = 1; i <= N; i++) J[i].clear();\n\tfor (int i = 1; i <= N; i++) J2[i].clear();\n\tfor (int i = 1; i <= N; i++) used[i] = false;\n\tfor (int i = 1; i <= N; i++) colo[i] = 0;\n\tcntv = 0;\n\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (i == pos) continue;\n\t\tJ[A[i]].push_back(B[i]);\n\t\tJ2[B[i]].push_back(A[i]);\n\t}\n\tK.clear();\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\t\n\tfor (int i = K.size() - 1; i >= 0; i--) {\n\t\tif (colo[K[i]] >= 1) continue;\n\t\tcntv++; dfs4(K[i]);\n\t}\n\n\tif (cnts == cntv) return false;\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= M; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tX[A[i]].push_back(B[i]);\n\t\tY[B[i]].push_back(A[i]);\n\t}\n\n\t// ステップ 1: 強連結成分ごとに分ける\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs1(i);\n\t}\n\tfor (int i = I.size() - 1; i >= 0; i--) {\n\t\tif (col[I[i]] >= 1) continue;\n\t\tcnts++; dfs2(I[i]);\n\t}\n\n\t// ステップ 2: DAG のグラフを処理する\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tZ[col[A[i]]].push_back(make_pair(col[B[i]], i));\n\t}\n\tvector<pair<int, int>> FF;\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tfor (int j = 0; j < Z[i].size(); j++) FF.push_back(make_pair(i, Z[i][j].first));\n\t}\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tdp[i][i] = 1;\n\t\tfor (pair<int, int> j : FF) dp[i][j.second] += dp[i][j.first];\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tif (dp[col[A[i]]][col[B[i]]] != 1) Answer[i] = 2;\n\t\telse Answer[i] = 1;\n\t}\n\n\t// ステップ 3: 候補辺の列挙\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tP[A[i]].push_back(make_pair(B[i], i));\n\t\tQ[B[i]].push_back(make_pair(A[i], i));\n\t\tAnswer[i] = 1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < P[i].size(); j++) {\n\t\t\tif (used[P[i][j].first] == true) continue;\n\t\t\tint V1 = dfs5(P[i][j].first);\n\t\t\tScore1[P[i][j].second] = V1;\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < Q[i].size(); j++) {\n\t\t\tif (used[Q[i][j].first] == true) continue;\n\t\t\tint V2 = dfs6(Q[i][j].first);\n\t\t\tScore2[Q[i][j].second] = V2;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tif (group[col[A[i]]] <= Score1[i] + Score2[i]) Answer[i] = 0;\n\t}\n\n\t// ステップ 4: 最後の計算\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] >= 1) continue;\n\t\tbool flag = calc(i);\n\t\tif (flag == false) Answer[i] = 1;\n\t\telse Answer[i] = 2;\n\t}\n\n\t// 出力\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] == 1) printf(\"same\\n\");\n\t\tif (Answer[i] == 2) printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(int*h,int x,int z)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])d1(h,e[i].t,z),uu[i>>1]|=z;\n}\nvoid d2(int*h,int x,int d,int xs,int ys)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=d&&!u[e[i].t])d2(h,e[i].t,d,xs,ys);\n\tif(x==xs&&!u[ys])d2(h,ys,d,xs,ys);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(k=c[q[j]];k;k=e[k].nx)if(!g[i][e[k].t]++)q[++qn]=e[k].t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i]&1)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,ph[p[x[i]]],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i]&2)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,ph[p[x[i]]],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e3 + 10;\nconst int M = 2e5 + 10;\n\nbool ans[M];\nint n, m, tot;\nint Min[N][N], Max[N][N];\nvector<pair<int, int> > g[N];\n\nvoid dfs(int *a, int x, int v)\n{\n\tif(!a[x])a[x] = v;\n\telse return;\n\tfor(int i = 0; i < (int)g[x].size(); i++)\n\t\tdfs(a, g[x][i].first, v);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x].push_back(make_pair(y, ++tot));\n\t}\n\tfor(int x = 1; x <= n; x++)\n\t{\n\t\tMin[x][x] = Max[x][x] = 1;\n\t\tfor(int i = 0; i < (int)g[x].size(); i++)\n\t\t{\n\t\t\tint y = g[x][i].first;\n\t\t\tdfs(Min[x], y, g[x][i].second);\n\t\t}\n\t\tfor(int i = g[x].size() - 1; ~i; i--)\n\t\t{\n\t\t\tint y = g[x][i].first;\n\t\t\tdfs(Max[x], y, g[x][i].second); \n\t\t}\n\t}\n\tfor(int x = 1; x <= n; x++)\n\t{\n\t\tfor(int i = 0; i < (int)g[x].size(); i++)\n\t\t{\n\t\t\tint y = g[x][i].first, num = g[x][i].second;\n\t\t\tbool flag1 = Min[y][x] > 0;\n\t\t\tbool flag2 = (Min[x][y] && Min[x][y] != num) || (Max[x][y] && Max[x][y] != num);\n\t\t\tif((flag1 && !flag2) || (!flag1 && flag2))ans[num] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= tot; i++)\n\t\tif(ans[i])puts(\"diff\");\n\t\telse puts(\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=2;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis1[e[i][j]])\n            dfs1(e[i][j],j+1);\n        for(int j=up-1;j>=0;j--)\n            if(!vis2[e[i][j]])\n            dfs2(e[i][j],j+1);\n        for(int j=1;j<=n;j++)\n            if(vis1[j])\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n\nint fir[M] , ne[M] , to[M] , cnt , x , y , scc[M] , scc_tot , dfs_clock , dfn[M] , low[M] , Id[M] , n , m;\nint A[M] , B[M];\nint stk[M] , top;\n\nvector <int> G[N];\nvector <int> who[N];\n\nvoid add(int x , int y , int id) {\n\tne[++ cnt] = fir[x]; fir[x] = cnt; to[cnt] = y; Id[cnt] = id;\n}\n\n#define Foreachson(i , x) for(int i = fir[x];i;i = ne[i])\n\nvoid dfs(int x) {\n\tint cur = top;\n\tdfn[x] = low[x] = ++ dfs_clock; stk[++ top] = x;\n\tForeachson(i , x) {\n\t\tint V = to[i];\n\t\tif(!dfn[V]) {\n\t\t\tdfs(V);\n\t\t\tlow[x] = min(low[x] , low[V]);\n\t\t}\n\t\telse if(!scc[V]) low[x] = min(low[x] , low[V]);\n\t}\n\tif(dfn[x] == low[x]) {\n\t\t++ scc_tot;\n\t\twhile(top > cur) {\n\t\t\twho[scc_tot].push_back(stk[top]);\n\t\t\tscc[stk[top]] = scc_tot;\n\t\t\t-- top;\n\t\t\tif(stk[top + 1] == x) break;\n\t\t}\n\t}\n}\n\nbool vis[N];\n\nint dp[N][N] , rd[N] , cd[N];\n\nvoid solve(int x) {\n\tif(vis[x]) \n\treturn;\n\tvis[x] = 1;\n\tfor(int i = 0;i < (int) G[x].size();++ i) {\n\t\tint V = G[x][i];\n\t\tsolve(V);\n\t\tfor(register int j = 1;j <= scc_tot;++ j) dp[x][j] += dp[V][j];\n\t}\n\t++ dp[x][x];\n\tfor(int i = 1;i <= scc_tot;++ i) dp[x][i] = min(dp[x][i] , 20);\n}\n\nint ans[M];\n\nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x , y , i);\n\t}\n\tfor(int i = 1;i <= n;++ i) if(!dfn[i]) dfs(i);\n\tfor(int x = 1;x <= n;++ x) {\n\t\tForeachson(i , x) {\n\t\t\tint V = to[i];\n\t\t\tif(scc[V] == scc[x]) {\n\t\t\t\t++ rd[V]; ++ cd[x];\n\t\t\t}\n\t\t\telse\n\t\t\tG[scc[x]].push_back(scc[V]);\n\t\t}\n\t}\n\tfor(int i = 1;i <= scc_tot;++ i) {\n\t\tif(!vis[i]) solve(i);\n\t}\n\tfor(int i = 1;i <= m;++ i) {\n\t\tint x = A[i] , V = B[i];\n\t\tif(scc[x] == scc[V]) {\n\t\t\tint a = cd[x] - 1 , b = rd[V] - 1;\n\t\t\tif(!a || !b) ans[i] = 1;\n\t\t\telse ans[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tif(dp[scc[x]][scc[V]] >= 2) ans[i] = 1;\n\t\t\telse ans[i] = 0;\n\t\t}\n\t}\n\tfor(int i = 1;i <= m;++ i) if(ans[i]) puts(\"diff\"); else puts(\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  int x=0,f=1;char c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return f?x:-x;\n  }\ntemplate <typename mitsuha>\ninline bool read(mitsuha &x){\n  x=0;int f=1;char c=gc();\n  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';\n  if (!~c) return 0;\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return x=f?x:-x,1;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x){\n  if (!x) return 0&pc(48);\n  if (x<0) x=-x,pc('-');\n  int bit[20],i,p=0;\n  for (;x;x/=10) bit[++p]=x%10;\n  for (i=p;i;--i) pc(bit[i]+48);\n  return 0;\n  }\ninline char fuhao(){\n  char c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=2e5;\ntypedef int fuko[yuzu|10];\nfuko u,v;int vis[2][yuzu>>6][yuzu>>6];\nvector<int> lj[yuzu|10];\n\nvoid dfs(int id,int p,int u,int col){\nif (vis[id][p][u]) return;\nvis[id][p][u]=col;\nfor (int i:lj[u]) dfs(id,p,i,col);\n}\n\nint main(){\nint i,n=read(),m=read();\nfor (i=1;i<=m;++i){\n  u[i]=read(),v[i]=read();\n  lj[u[i]].push_back(v[i]);\n  } \nfor (i=1;i<=n;++i){\n  vis[0][i][i]=vis[1][i][i]=1;\n  int now=0;for (int j:lj[i]) dfs(0,i,j,++now);\n  if (lj[i].size()) for (int j=lj[i].size()-1;~j;--j) dfs(1,i,lj[i][j],j+1);\n  }\nfor (i=1;i<=m;++i){\n  puts((vis[0][u[i]][v[i]]!=vis[1][u[i]][v[i]])^(vis[0][v[i]][u[i]]>0)?\"diff\":\"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std; \nconst int maxn=1000+50;\nconst int maxm=200000+50;\nint N,M;\nint p[maxn];\nint q[maxn];\nint c[maxn][maxn];\nbool an[maxm];\nstruct edge\n{\n\tint to,id;\n\tedge(int to=0,int id=0):to(to),id(id){}\n};\nvector<edge> adj[maxn];\nvoid dfs(int u,int root)\n{\n\tif(c[root][u]) return;\n\tc[root][u]=1;\n\tfor(unsigned int i=0;i<adj[u].size();++i)\n\t{\n\t\tint v=adj[u][i].to;\n\t\tdfs(v,root); \n\t}\n}\nvoid dfs(int u,int c,int *p)\n{\n\tif(p[u]!=-1) return;\n\tp[u]=c;\n\tfor(unsigned int i=0;i<adj[u].size();++i)\n\t{\n\t\tint v=adj[u][i].to;\n\t\tdfs(v,c,p);\n\t}\n}\nvoid solve()\n{\n\tfor(int i=1;i<=N;++i)\n\t{\n\t\tdfs(i,i);\n\t}\n\tfor(int u=1;u<=N;++u)\n\t{\n\t\tmemset(p,-1,sizeof(p));\n\t\tmemset(q,-1,sizeof(q));\n\t\tint l=p[u]=q[u]=adj[u].size();\n\t\tfor(int i=0;i<l;++i)\n\t\t{\n\t\t\tint v=adj[u][i].to;\n\t\t\tdfs(v,i,p);\n\t\t}\n\t\tfor(int i=l-1;~i;--i)\n\t\t{\n\t\t\tint v=adj[u][i].to;\n\t\t\tdfs(v,i,q);\n\t\t}\n\t\tfor(int i=0;i<l;++i)\n\t\t{\n\t\t\tint v=adj[u][i].to;\n\t\t\tint d=adj[u][i].id;\n\t\t\tan[d]=c[v][u]^(p[v]!=i||q[v]!=i);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=M;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a].push_back(edge(b,i));\n\t}\n\tsolve();\n\tfor(int i=1;i<=M;++i)\n\t{\n\t\tputs(an[i]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=3e3+10;\nconst int M=2e5+10;\nvector<pii> e[N];\ninline void add(int u,int v,int id){e[u].push_back(mp(v,id));}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[M];\nint main(){\n    n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n    }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    rep(x,1,n){\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tfor(auto k:e[x]){\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs2(v,x);\n\t}\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tint sz=(int)e[x].size()-1;\n\trpe(j,sz,0){\n\t    pii k=e[x][j];\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define all(x) x.begin(),x.end()\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\ntypedef long long ll;\nconst int N=1005;\nvector<int> g[N];\nint n,m,ans[N],vis[N],clk;\nint a[N*N],b[N*N],tim[N],del;\nvoid dfs(int v){\n\tvis[v]=clk;\n\tfor (int d:g[v]){\n\t\tif((!vis[d])&&d!=del)dfs(d);\n\t}\n}\nvoid gao(int x){\n\tdel=x;\n\tmem(vis,0);\n\tclk=0;\n\tfor(int d:g[x]){\n\t\t++clk;\n\t\ttim[d]=clk;\n\t\tif(!vis[d])dfs(d);\n\t}\n\trep(i,1,m)if(a[i]==x&&vis[b[i]]!=tim[b[i]])ans[i]=1;\n\n}\nint main(int argc,char*argv[]){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,m){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tg[a[i]].pb(b[i]);\n\t}\n\trep(x,1,n){\n\t\tgao(x);\n\t\treverse(all(g[x]));\n\t\tgao(x);\n\t}\n\trep(x,1,n){\n\t\tdel=0;\n\t\tmem(vis,0);\n\t\tdfs(x);\n\t\trep(i,1,m)if(b[i]==x)ans[i]^=vis[a[i]];\n\t}\n\trep(i,1,m)printf(\"%s\\n\",ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 1054, M = 200054;\n\nstruct edge {\n\tint u, v;\n\tedge (int u0 = 0, int v0 = 0) : u(u0), v(v0) {}\n} e[M];\n\nint V, E, tag, root;\nint first[N], next[M], from[N], que[N];\nbool saturated[N], connected[N][N], reversible[N][N];\n\ninline void addedge(int u, int v, int id) {e[id] = edge(u, v), next[id] = first[u], first[u] = id;}\n\nvoid bfs(int si) {\n\tint i, x, y, h, t = 1; *que = si;\n\tfor (h = 0; h < t; ++h) {\n\t\tx = que[h];\n\t\tfrom[x] ? (saturated[x] = true) : (from[x] = tag);\n\t\tfor (i = first[x]; i; i = next[i])\n\t\t\tif (!saturated[y = e[i].v] && from[y] != tag)\n\t\t\t\tque[t++] = y;\n\t}\n}\n\nvoid solve() {\n\tint i;\n\tmemset(saturated, false, V + 1), saturated[root] = true;\n\tmemset(from, 0, (V + 1) << 2);\n\tfor (i = first[root]; i; i = next[i]) if (!saturated[tag = e[i].v]) bfs(tag);\n\tfor (i = 1; i <= V; ++i) if (i != root)\n\t\tconnected[root][i] = saturated[i] || from[i],\n\t\treversible[root][i] = saturated[i] || (from[i] && from[i] != i);\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (i = 1; i <= E; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v, i);\n\tfor (root = 1; root <= V; ++root) solve();\n\tfor (i = 1; i <= E; ++i)\n\t\tu = e[i].u, v = e[i].v, puts(connected[v][u] == reversible[u][v] ? \"same\" : \"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#define maxn 200100\nusing namespace std;\nint n,m,tot,vis[1010],sz[1010],fr[maxn],to[maxn],th[1010][1010];\nvector<int> v[1010];\nint read(){\n\tint x=0;char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn x;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tvis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=0;i<sz[x];i++)\n\t\tdfs(v[x][i],s,cur);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&fr[i],&to[i]);\n\t\tv[fr[i]].push_back(to[i]); sz[fr[i]]++;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=0;j<sz[i];j++) dfs(v[i][j],i,v[i][j]);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=fr[i],y=to[i];\n\t\tif((th[y][x]&&th[x][y]!=-1)||(!th[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eb emplace_back\nusing namespace std;\n\nconst int MAXN = 1005;\nconst int MAXM = 200005;\n\nvector<int> G[MAXN];\n\nint D[MAXN][MAXN][2], Dn[MAXN][MAXN];\n\nbitset<MAXN> C[MAXN];\n\nint A[MAXM], B[MAXM];\n\nint N, M;\n\nvoid dfs(int i, bitset<MAXN> &chk) {\n\tchk[i] = true;\n\tfor(int v : G[i]) if(!chk[v])\n\t\tdfs(v, chk);\n}\n\nvoid f(int i, int ri, int c) {\n\tif(2 == Dn[ri][i]) return;\n\tif(1 == Dn[ri][i] && D[ri][i][0] == c) return;\n\tD[ri][i][Dn[ri][i]++] = c;\n\tfor(int v : G[i]) f(v, ri, c);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> M;\n\tfor(int i = 1; i <= M; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tG[A[i]].eb(B[i]);\n\t}\n\n\tfor(int i = 1; i <= N; i++) dfs(i, C[i]);\n\tfor(int i = 1; i <= N; i++) {\n\t\tDn[i][i] = 2;\n\t\tfor(int v : G[i]) f(v, i, v);\n\t}\n\n\tfor(int i = 1, a, b; i <= M; i++) {\n\t\ta = A[i]; b = B[i];\n\n\t\tbool flag = false;\n\t\tif(1 == Dn[a][b]) {\n\t\t\tif(b != D[a][b][0]) flag = true;\n\t\t} else if(2 == Dn[a][b]) {\n\t\t\tif(b != D[a][b][0]) flag = true;\n\t\t\tif(b != D[a][b][1]) flag = true;\n\t\t}\n\n\t\tputs((flag == C[b][a]) ? \"same\" : \"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1007;\nstruct nod\n{\n\tint to,id;\n\tnod(int a,int b)\n\t{\n\t\tto=a;\n\t\tid=b;\n\t}\n\tnod(){}\n};\nint n,m,tim;\nint vis[MAXN],can[MAXN][MAXN][2];\nint u[MAXN*MAXN],v[MAXN*MAXN];\nvector<nod> edge[MAXN];\nvoid dfs(int now,int fa,int b,int f)\n{\n\tvis[now]=tim; can[fa][now][f]=b;\n\tfor(int i=0;i<edge[now].size();i++){\n\t\tint v=edge[now][i].to;\n\t\tif(vis[v]!=tim) dfs(v,fa,b,f);\n\t}\n}\ninline void solve(int now)\n{\n\ttim++; vis[now]=tim;\n\tfor(int i=0;i<edge[now].size();i++){\n\t\tint v=edge[now][i].to;\n\t\tif(vis[v]!=tim) dfs(edge[now][i].to,now,edge[now][i].id,0);\n\t}\n\treverse(edge[now].begin(),edge[now].end());\n\ttim++; vis[now]=tim;\n\tfor(int i=0;i<edge[now].size();i++){\n\t\tif(vis[edge[now][i].to]!=tim) dfs(edge[now][i].to,now,edge[now][i].id,1);\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>u[i]>>v[i];\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++) solve(i);\n\tfor(int i=1;i<=m;i++){\n\t\tif((can[v[i]][u[i]][0]!=0)^0^(can[u[i]][v[i]][0]!=i||can[u[i]][v[i]][1]!=i))\n\t\t\tcout<<(\"diff\\n\");\n\t\telse cout<<(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\n#define MAXN 1005\n#define MAXM 200005\n\nint n,m,u,v;\nint id[MAXN][MAXN],d[MAXN][MAXN],d2[MAXN][MAXN],q[MAXN][2];\nint ans[MAXM];\nvector<int> a[MAXN];\n\nvoid dfs(int x,int fa)\n{\n    d[fa][x]=1;\n    for(int i=0;i<(int)a[x].size();i++)\n        if(d[fa][a[x][i]]==0)\n            dfs(a[x][i],fa);\n}\n\nvoid dfs1(int x,int f,int flag)\n{\n    q[x][flag]=f;\n    for(int i=0;i<(int)a[x].size();i++)\n        if(!q[a[x][i]][flag])\n            dfs1(a[x][i],f,flag);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        id[u][v]=i;\n        a[u].push_back(v);\n    }\n    for(int i=1;i<=n;i++)\n        dfs(i,i);\n    for(int i=1;i<=n;i++)\n    {\n        memset(q,0,sizeof q);\n        for(int j=0;j<(int)a[i].size();j++)\n            if(!q[a[i][j]][0])\n                dfs1(a[i][j],j+1,0);\n        for(int j=a[i].size()-1;j>=0;j--)\n            if(!q[a[i][j]][1])\n                dfs1(a[i][j],j+1,1);\n        for(int j=0;j<(int)a[i].size();j++)\n            if(q[a[i][j]][0]!=j+1||q[a[i][j]][1]!=j+1)\n                d2[i][a[i][j]]=1;\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(d[j][i]==d2[i][j]&&id[i][j])\n                ans[id[i][j]]=1;\n    for(int i=1;i<=m;i++)\n    {\n        if(ans[i]==1)\n            printf(\"same\\n\");\n        else\n            printf(\"diff\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/// kAAzuki Hoshino\n/*\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long long ll;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n//#define inf 1000000000\n#define mod 1000000007\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n    return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n    o<<\"{\";\n    for(const T& v:vc) o<<v<<\",\";\n    o<<\"}\";\n    return o;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MAXM = 200005;\nconst int MAXN = 1005;\nint used[MAXN], condition[MAXM], vis[MAXN][MAXN], a[MAXM], b[MAXM] ;\nvi adj[MAXN];\nint N,M;\nint r[MAXN],cond[MAXM];\n\nvoid dfs(int s, int base){\n\tif(vis[base][s])return;\n\tvis[base][s]=1;\n\tfor(auto t:adj[s]){\n\t\tdfs(t, base);\n\t}\n}\n\nvoid bfs(int s){\n\tmemset(used,0,sizeof(used));\n\tmemset(r,-1,sizeof(r));\n\tfor(auto t:adj[s]){\n\t\tif(r[t]!=-1){\n\t\t\tused[t]=1;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push(t);\n\t\tr[t] = t;\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tfor(auto u:adj[v]){\n\t\t\t\tif(u==s)continue;\n\t\t\t\tif(r[u]!=-1){\n\t\t\t\t\tif(r[u]!=t)used[u]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr[u]=t;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor(int i=1;i<=N;i++)if(used[i])q.push(i);\n\twhile(!q.empty()){\n\t\tint v = q.front();q.pop();\n\t\tfor(auto t:adj[v]){\n\t\t\tif(t==s)continue;\n\t\t\tif(used[t])continue;\n\t\t\tused[t]=1;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\tfor(int i=1;i<=M;i++){\n\t\tif(a[i]==s){\n\t\t\tcondition[i] = used[b[i]];\n\t\t}\n\t\tif(b[i]==s){\n\t\t\tcond[i] = (r[a[i]]!=-1);\n\t\t}\n\t}\n\n}\n\nsigned main(){\nIOS;\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n\t\n\tcin >> N >> M;\n  for(int i=1;i<=M;i++){\n  \tcin >> a[i] >> b[i];\n  \tadj[a[i]].pb(b[i]);\n  }  \n  // for(int i=1;i<=N;i++){\n  // \tdfs(i, i);\n  // }\n  for(int i=1;i<=N;i++){\n  \tbfs(i);\n  }\n  for(int i=1;i<=M;i++){\n  \tif(condition[i]==cond[i]){\n  \t\tcout << \"same\" << endl;\n  \t}\n  \telse cout << \"diff\" << endl;\n  }\n\nreturn 0;\n}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,id;\n}E[200005];\nint head[1005],sumE,M,N,a[200005],b[200005];\nbool reachable[1005][1005],mark[1005],a1[200005],a2[200005];\nvector<int> v;\nvoid add(int u,int v,int id) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].id = id;\n    head[u] = sumE;\n}\nvoid dfs(int id,int u) {\n    reachable[id][u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!reachable[id][v]) {\n\t    dfs(id,v);\n\t}\n    }\n}\nvoid dfs2(int u) {\n    mark[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!mark[v]) dfs2(v);\n    }\n}\nvoid Solve() {\n    read(N);read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(a[i]);read(b[i]);\n\tadd(a[i],b[i],i);\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tdfs(i,i);\n    }\n    for(int u = 1 ; u <= N ; ++u) {\n\tv.clear();\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    v.pb(E[i].id);\n\t}\n\tmemset(mark,0,sizeof(mark));\n\tmark[u] = 1;\n\tint s = v.size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    dfs2(b[v[i]]);\n\t}\n\tmemset(mark,0,sizeof(mark));\n\tmark[u] = 1;\n\tfor(int i = s - 1 ; i >= 0 ; --i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    dfs2(b[v[i]]);\n\t}\n    }\n    for(int i = 1 ; i <= M ; ++i) {\n\tif(reachable[b[i]][a[i]]) a1[i] = 1;\n\tif(a1[i] ^ a2[i]) puts(\"diff\");\n\telse puts(\"same\");\n    }\n    \n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#include<unordered_map>\n#include<vector>\ntypedef long long ll;\nusing namespace std;\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define N 1010\n#define M 200010\nvector<int>G[N];\nint a[M],b[M],vis[2][N][N];\nvoid dfs(int mod,int a,int b,int col){\n\tif(vis[mod][a][b])return;\n\tvis[mod][a][b]=col;\n\tfor(auto q:G[b])dfs(mod,a,q,col);\n}\nint main(){\n\tint i,j,n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].pb(b[i]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tvis[0][i][i]=vis[1][i][i]=1;\n\t\tfor(j=0;j<G[i].size();j++)dfs(0,i,G[i][j],j+1);\n\t\tfor(j=G[i].size()-1;j>=0;j--)dfs(1,i,G[i][j],j+1);\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tint x=(vis[0][a[i]][b[i]]!=vis[1][a[i]][b[i]]);\n\t\tint y=vis[0][b[i]][a[i]]!=0;\n\t\tif(x^y)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <vector>\n#include <queue>\n#define PB push_back\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1010,M=1003;\nbitset<M> G[N],A[N],B;\nint n,m;\nint vis[N][2];\nint inq[N];\nqueue<int> que;\nvoid push(int u,int t) {\n\tif(!vis[u][0]) vis[u][0]=t;\n\telse if(!vis[u][1]&&vis[u][0]!=t) vis[u][1]=t,B[u]=0;\n\telse return;\n\tA[t][u]=0;\n\tif(!inq[u]) que.push(u),inq[u]=1;\n}\nint mp[N][N],p1[N][N],p2[N][N];\nvoid sol(int s) {\n\tB[s]=0;\n\tfor(int i=1;i<=n;++i) if(mp[s][i]) push(i,i);\n\twhile(!que.empty()) {\n\t\tint u=que.front(); que.pop(),inq[u]=0;\n\t\twhile(1) {\n\t\t\tint v=((A[vis[u][0]]|A[vis[u][1]])&G[u]&B)._Find_first();\n\t\t\tif(v==M) break;\n\t\t\tpush(v,vis[u][0]),push(v,vis[u][1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) if(s!=i) {\n\t\tp1[s][i]=vis[i][0]||vis[i][1]||mp[s][i];\n\t\tp2[s][i]=(vis[i][0]&&vis[i][0]!=i)||(vis[i][1]&&vis[i][1]!=i);\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tif(vis[i][0]) A[vis[i][0]][i]=1,vis[i][0]=0;\n\t\tif(vis[i][1]) A[vis[i][1]][i]=1,vis[i][1]=0;\n\t\tB[i]=1;\n\t}\n}\nvector<PII> E;\nint main() {\n\trd(n),rd(m);\n\tfor(int i=1,x,y;i<=m;++i) rd(x),rd(y),G[x][y]=mp[x][y]=1,E.PB(MP(x,y));\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) A[i][j]=1;\n\tfor(int i=1;i<=n;++i) B[i]=1;\n\tfor(int i=1;i<=n;++i) sol(i);\n\tfor(int i=0;i<E.size();++i) { \n\t\tint x=E[i].fir,y=E[i].sec,flg;\n\t\tif(p1[y][x]) flg=(p2[x][y]==1);\n\t\telse flg=(p2[x][y]==0);\n\t\tif(flg) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst int maxN = 1024;\n\nint n, m, i, x, y;\nvector< pair<int, int> > to[maxN], from[maxN], list[maxN];\npair<int, int> rez[maxN * maxN];\n\nbool way_back[maxN][maxN];\nbool way_forw[maxN * maxN];\nbool us[maxN];\n\nvoid dfs_back(int node, int src) {\n    way_back[src][node] = true;\n\n    for (auto e : to[node])\n        if (way_back[src][e.first] == false)\n            dfs_back(e.first, src);\n}\n\nvoid dfs_forw(int node, int deny) {\n    us[node] = true;\n    for (auto e : to[node])\n        if (us[e.first] == false && deny != e.first)\n            dfs_forw(e.first, deny);\n}\n\nvoid solve_forw(int node) {\n    int i;\n\n    memset(us, 0, sizeof(us));\n    for (auto y : to[node]) {\n        if (us[y.first]) {\n            way_forw[y.second] = true;\n        } else {\n            dfs_forw(y.first, node);\n        }\n    }\n\n    memset(us, 0, sizeof(us));\n    reverse(to[node].begin(), to[node].end());\n    for (auto y : to[node]) {\n        if (us[y.first]) {\n            way_forw[y.second] = true;\n        } else {\n            dfs_forw(y.first, node);\n        }\n    }\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n >> m;\n    for (i = 1; i <= m; i++) {\n        cin >> x >> y;\n        rez[i] = mp(x, y);\n        to[x].pb(mp(y, i));\n        from[y].pb(mp(x, i));\n\n        list[x].pb(mp(y, i));\n        list[y].pb(mp(x, i));\n    }\n\n    for (i = 1; i <= n; i++)\n        dfs_back(i, i);\n\n    for (i = 1; i <= n; i++)\n        solve_forw(i);\n\n    for (i = 1; i <= m; i++) {\n        x = rez[i].first;\n        y = rez[i].second;\n\n        if (way_back[y][x] == way_forw[i])\n            cout << \"same\\n\";\n        else\n            cout << \"diff\\n\";\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    for (int i=g[x];i;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1]))continue;\n            if (!F[y][0])F[y][0]=v;\n            else\n                F[y][1]=v;\n            dfs(y,s,v);\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <queue>\n#include <sstream>\nusing namespace std;\n#define x first\n#define y second\n#define mp make_pair\n#define elif else if\n#define prev prev2\n#define Edge pair <int, int>\n#define next next2\n#define u first\n#define v second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1000, N = 1000, MAXM = 2e5;\nvector<int> g[MAXN], gt[MAXN];\nint a[MAXN], b[MAXN], c1[MAXN], c2[MAXN];\nvector<int> topsort;\nint vis[MAXN];\nEdge ed[MAXM];\nbool used[N];\nvoid dfs(int u) {\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (!used[v]) dfs(v);\n    }   \n}   \nvoid solve(int u) {\n\t//cout << \"u: \" << u << endl;\n    memset(used, 0, sizeof used);\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        //cout << v << \" \" << used[v] << endl;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n    memset(used, 0, sizeof used);\n    reverse(g[u].begin(), g[u].end());\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n}   \nvoid dfst1(int v) {\n\tvis[v] = 1;\n\tfor (int e : g[v]) {\n\t\tint u = b[e];\n\t\tif (!vis[u])\n\t\t\tdfst1(u);\n\t}\n\ttopsort.push_back(v);\n}\nint clr = 0;\nvoid dfst2(int v) {\n\tvis[v] = clr;\n\tfor (int e : gt[v]) {\n\t\tint u = a[e];\n\t\tif (!vis[u])\n\t\t\tdfst2(u);\n\t}\n}\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\t--a[i];\n\t\t--b[i];\n\t\tg[a[i]].push_back(i);\n\t\tgt[b[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!vis[i])\n\t\t\tdfst1(i);\n\tfill(vis, vis + n, 0);\n\treverse(topsort.begin(), topsort.end());\n\tfor (int v : topsort)\n\t\tif (!vis[v]) {\n\t\t\t++clr;\n\t\t\tdfst2(v);\n\t\t}\n\n\tfor (int i = 0; i < m; ++i) \n\t\tc1[i] = (vis[a[i]] == vis[b[i]]);\n\tfor (int i = 0; i < m; ++i) {\n        ed[i] = {a[i], b[i]};\n    }   \n    for (int i = 0; i < n; ++i) {\n        solve(i);\n    }\n\n\tfor (int i = 0; i < m; ++i) {\n\t\t//cout << c1[i] << c2[i];\n        if (c1[i] ^ c2[i]) {\n            cout << \"diff\\n\";\n        }   \n        else {\n            cout << \"same\\n\";\n        }\n    }   \n\treturn;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nvoid topological_sort(int f) {\n    if (starred[f]) return;\n    starred[f] = true;\n    for (int u : ll[f]) {\n        topological_sort(unf[u]);\n    }\n    topo_sort[topo_cnt++] = f;\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    memset(starred + 1, 0, n * sizeof(bool));\n    for (i=1; i<=n; ++i) {\n        int f = unf[i];\n        if (!starred[f]) {\n            topological_sort(f);\n        }\n    }\n    for (i=0; i<topo_cnt/2; ++i) {\n        swap(topo_sort[i], topo_sort[topo_cnt - 1 - i]);\n    }\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    for (auto u : piv) {\n        int t = find_stars(u.second, u.first);\n        if (unf[u.first] == unf[u.second]) {\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            puts(dag_second_visit[unf[u.first]].test(unf[u.second]) ? \"diff\" : \"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cstring>\nusing namespace std;\nconst int N = 1005;\nconst int M = 2e5 + 5;\nvector<int> v[N];\nbitset<N> vis;\nint n, m, g1[N][N], g2[N][N], pre[N];\nstruct node{int x, y;}e[M];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid dfs(int x, int now)\n{\n\tg1[now][x] = 1; vis.set(x);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, now);\n\t}\n}\nvoid dfs(int x, int id, int k, int now)\n{\n\tif(!k) pre[x] = id; else g2[now][x] = (pre[x] != id);\n\tvis.set(x);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, id, k, now);\n\t}\n}\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read();\n\tfor(int i = 1, x, y; i <= m; i ++)\n\t{\n\t\tx = read(); y = read();\n\t\tv[x].push_back(y); e[i] = node{x, y};\n\t}\n\tfor(int i = 1; i <= n; i ++) {vis.reset(); dfs(i, i);}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tvis.reset(); vis.set(i); memset(pre, 0, sizeof(pre)); int d = v[i].size();\n\t\tfor(int j = 0; j < d; j ++) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 0, i);\n\t\tvis.reset(); vis.set(i);\n\t\tfor(int j = d - 1; j >= 0; j --) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 1, i);//d - 1\n\t}\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tif(g1[e[i].x][e[i].y] ^ g2[e[i].x][e[i].y]) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ld inf = 2e18;\nconst int N = 1020;\nconst int maxn = 200020;\nconst ll mod = 998244353;\n\n/*struct node{\n\tint next,to;\n}e[maxn * 2];*/\nvector <int> e[N];\nint head[maxn],cnt;\nint reach[N][N],vis[N],tag[N];\nint n,m;\nvector <pr> edge;\n\ninline void adde(int x,int y){\n\t//e[++cnt].to = y;\n\t//e[cnt].next = head[x];\n\t//head[x] = cnt;\n\te[x].pb(y);\n}\nvoid dfs(int x,int from){\n//\tif ( vis[x] >= 2 ) return;\n\tif ( !vis[x] ) vis[x] = 1 , tag[x] = from;\n\telse{\n\t\tif ( from != tag[x] ) vis[x]++;\n\t\telse return;\n\t\tif ( vis[x] > 2 ) return;\n\t}\n\trvc(i,e[x]){\n\t//\tdfs(e[i].to,from);\n\t\tif ( vis[e[x][i]] < 2 ) dfs(e[x][i],from);\n\t}\n}\nvoid solve(int id){\n\trep(i,1,n) vis[i] = 0;\n\tvis[id] = n;\t\n\trvc(i,e[id]){\n\t\tdfs(e[id][i],e[id][i]);\n\t}\n\trep(i,1,n){\n\t\treach[id][i] = vis[i];\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,m){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y);\n\t\tedge.pb(mp(x,y));\n\t}\n\trep(i,1,n) solve(i);\n//\trep(i,1,n) rep(j,i + 1,n){\n//\t\tcout<<i<<\" \"<<j<<\" \"<<reach[i][j]<<endl;\n//\t\tcout<<j<<\" \"<<i<<\" \"<<reach[j][i]<<endl;\n//\t}\n\trep(i,0,m - 1){\n\t\tint x = edge[i].fi , y = edge[i].se;\n\t\tif ( reach[x][y] > 1 && reach[y][x] ) puts(\"same\");\n\t\telse if ( reach[x][y] == 1 && !reach[y][x] ) puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020, M = 403000, inf = 0x3f3f3f3f;\nint n,m,head[N],nxt[M],to[M],edgenum,a[M],b[M],d[N],mx[N],res[M];Vi e[N];\nvoid add(int u, int v){\n\tto[++edgenum]=v;nxt[edgenum]=head[u];head[u]=edgenum;\n}\nVi g[N];\nint tot;\ninline void dfs(int u, int *d){\n\trep(i,0,SZ(g[u])-1)if(d[g[u][i]]==inf)d[g[u][i]]=d[u],dfs(g[u][i],d);\n//\tL(i,u)\n//\tfor(int i=head[u];i;i=nxt[i])\n//\t{tot++;if(d[to[i]]==inf)d[to[i]]=d[u],dfs(to[i],d);}\n}\nint main() {//freopen(\"1.in\",\"r\",stdin);\n\tread(n);read(m);rep(i,1,m)read(a[i]),read(b[i]),add(a[i],b[i]),e[b[i]].pb(i);\n\trep(i,1,m)g[a[i]].pb(b[i]);\n\trep(u,1,n){\n\t//\tprintf(\"u = %d %d\\n\",u,tot);\n\t//\tint f=1,r=1;\n\t\tmemset(d,inf,4*(n+2));memset(mx,inf,4*(n+2));\n\t//\tL(i,u)q[r++]=to[i];\n\t\td[u]=mx[u]=0;\n\t\t/*while(f!=r){\n\t\t\tint u=q[f++];\n\t\t\tL(i,u)if(d[to[i]]>d[u]||mx[to[i]]<mx[u])\n\t\t\t\tmx[to[i]]=mx[u],d[to[i]]=d[u],q[r++]=to[i];\n\t\t}*/\n\t\tstatic int s[N];int len=0;L(i,u)s[++len]=to[i];\n\t\trep(i,1,len)if(d[s[i]]==inf)d[s[i]]=s[i],dfs(s[i],d);\n\t\tper(i,len,1)if(mx[s[i]]==inf)mx[s[i]]=s[i],dfs(s[i],mx);\n\t\tL(i,u)res[i]^=d[to[i]]!=to[i]||mx[to[i]]!=to[i];\n\t\tper(i,SZ(e[u])-1,0)res[e[u][i]]^=d[a[e[u][i]]]<inf;\n\t}\n\trep(i,1,m)printf(\"%s\\n\",res[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=1010;\nconst int M=200010;\nconst int inf=0x3f3f3f3f;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,m;\nint x[M],y[M];\nbool g[N][N],f[N][N];\nint p[2][N];\nvector<int>G[N];\ninline void dfs(int u,int x,int f)\n{\n\tif(p[f][u])return;\n\tp[f][u]=x;\n\tFor(i,0,SZ(G[u])-1)dfs(G[u][i],x,f);\n}\ninline void Solve(int u)\n{\n\tFor(i,1,n)p[0][i]=p[1][i]=0;\n\tp[0][u]=p[1][u]=1;\n\t For(i,0,SZ(G[u])-1)dfs(G[u][i],i+1,0);\n\trFor(i,SZ(G[u])-1,0)dfs(G[u][i],i+1,1);\n\tFor(i,1,n)g[u][i]=p[0][i]!=p[1][i],f[u][i]=p[0][i]||p[1][i];\n}\nint main()\n{\n\tfile();\n\tread(n),read(m);\n\tFor(i,1,m)read(x[i]),read(y[i]),G[x[i]].pb(y[i]);\n\tFor(i,1,n)Solve(i);\n\tFor(i,1,m)printf(\"%s\\n\",g[x[i]][y[i]]^f[y[i]][x[i]]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 31) {\n    int l = _, r = min< int >(g[idx].size(), _ + 31);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else {\n          dp[e.first] |= dp[p];\n        }\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\nbool v[2000][2000];\n\nvoid dfs2(int idx, int idx2) {\n  if(v[idx][idx2]++) return;\n  for(auto &to : g[idx]) dfs2(to.first, idx2);\n}\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n    dfs2(i, i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (v[Y[i]][Y[i]]) ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\nint N, M, A[201010], B[201010];\nvector<pair<int,int>> E[1010];\nint ma[1010][1010], mi[1010][1010], vis[1010];\ntemplate<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n//---------------------------------------------------------------------------------------------------\nvoid dfs1(int i, int cu, int v) {\n    if (i == cu) return;\n    if (ma[cu][i]) return;\n    ma[cu][i] = v;\n    fore(p, E[i]) dfs1(p.second, cu, v);\n}\n//---------------------------------------------------------------------------------------------------\nvoid dfs2(int i, int cu, int v) {\n    if (i == cu) return;\n    if (mi[cu][i]) return;\n    mi[cu][i] = v;\n    fore(p, E[i]) dfs2(p.second, cu, v);\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M;\n    rep(i, 0, M) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        E[a].push_back({ i + 1, b });\n        //E[b].push_back({ i + 1, a });\n        A[i] = a;\n        B[i] = b;\n    }\n\n    // for max\n    rep(i, 0, N) sort(all(E[i]), greater<pair<int, int>>());\n    rep(cu, 0, N) fore(p, E[cu]) dfs1(p.second, cu, p.first);\n\n    // for min\n    rep(i, 0, N) sort(all(E[i]));\n    rep(cu, 0, N) fore(p, E[cu]) dfs2(p.second, cu, p.first);\n\n    rep(i, 0, M) {\n        int a = A[i], b = B[i];\n\n        if (mi[a][b] != ma[a][b] and mi[b][a]) {\n            printf(\"same\\n\");\n        }\n        else if (mi[a][b] == ma[a][b] and !mi[b][a]) {\n            printf(\"same\\n\");\n        } else printf(\"diff\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 1005\nint cgy;\nstruct node{\n\tint to;\n\tint id;\n\tnode(int a,int b){\n\t\tto=a;\n\t\tid=b;\n\t}\n\tnode(){}\n};\nint n,m;\nint tot;\nint vis[maxn];\nint bh[maxn][maxn][3];\nvector<node> e[maxn];\nint u[maxn*maxn*2];\nint v[maxn*maxn*2];\nvoid dfs(int root,int fa,int b,int f){\n\tvis[root]=tot;\n\tbh[fa][root][f]=b;\n\tint len=e[root].size();\n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[root][i].to]!=tot)\n\t\tdfs(e[root][i].to,fa,b,f);\n\t}\n}\nvoid s(int now){\n\ttot++;\n\tvis[now]=tot;\n\tint len=e[now].size();\n//\tcout<<now<<\" \"<<len<<endl; \n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[now][i].to]!=tot)\n\t\tdfs(e[now][i].to,now,e[now][i].id,0);\n\t}\n\treverse(e[now].begin(),e[now].end());\n\ttot++;\n\tvis[now]=tot;\n//\tint len=e[now].size();\n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[now][i].to]!=tot)\n\t\tdfs(e[now][i].to,now,e[now][i].id,1);\n\t}\t\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\te[u[i]].push_back(node(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\ts(i);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif((bh[u[i]][v[i]][0]!=i||bh[u[i]][v[i]][1]!=i) ^ 0 ^ (bh[v[i]][u[i]][0]!=0)){\n\t\t\tputs(\"diff\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N, M;\nvector <int> G[1005];\nbool A[1005][1005];\nint Min[1005][1005], Max[1005][1005];\nbool Use[1005];\nint Pos[1005][1005];\npair <int, int> E[200005];\nvoid DFS(int node)\n{\n    Use[node] = 1;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(Use[neighb] == 0)\n            DFS(neighb);\n    }\n}\nvoid precalcA(int node)\n{\n    for(int i = 1; i <= N; i++)\n        Use[i] = 0;\n    DFS(node);\n    for(int i = 1; i <= N; i++)\n        A[node][i] = Use[i];\n}\nvoid DFS2(int node, int a, int b)\n{\n    Min[a][node] = b;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == a)\n            continue;\n        if(Min[a][neighb] == 0)\n            DFS2(neighb, a, b);\n    }\n}\nvoid precalcMin(int node)\n{\n    for(int j = 0; j < G[node].size(); j++)\n    {\n        int neighb = G[node][j];\n        if(Min[node][neighb] == 0)\n            DFS2(neighb, node, j + 1);\n    }\n}\nvoid DFS3(int node, int a, int b)\n{\n    Max[a][node] = b;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == a)\n            continue;\n        if(Max[a][neighb] == 0)\n            DFS3(neighb, a, b);\n    }\n}\nvoid precalcMax(int node)\n{\n    for(int j = G[node].size() - 1; j >= 0; j--)\n    {\n        int neighb = G[node][j];\n        if(Max[node][neighb] == 0)\n            DFS3(neighb, node, j + 1);\n    }\n}\n\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        Pos[x][y] = G[x].size();\n        E[i] = make_pair(x, y);\n    }\n}\n\nvoid Solve()\n{\n    for(int i = 1; i <= N; i++)\n        precalcA(i);\n    for(int i = 1; i <= N; i++)\n    {\n        precalcMin(i);\n        precalcMax(i);\n    }\n    for(int i = 1; i <= M; i++)\n    {\n        int x = E[i].first, y = E[i].second;\n        int cnt = 0;\n        if(A[y][x] == 1)\n            ++cnt;\n        if(Min[x][y] != Pos[x][y] || Max[x][y] != Pos[x][y])\n            ++cnt;\n        if(cnt == 2 || cnt == 0)\n            cout << \"same\\n\";\n        else\n            cout << \"diff\\n\";\n    }\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=1010;\nconst int M=2e5+10;\nstruct node{\n    int next,to,id;\n}e[M<<1];\nint head[N],cnt;\ninline void add(int u,int v,int id){\n    e[cnt].id=id;e[cnt].to=v;e[cnt].next=head[u];head[u]=cnt++;\n}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(p[frm][v]) continue;\n\tif(v==frm) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(q[frm][v]||v==frm) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[N];\nint main(){\n    mst(head,-1);n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n    }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    //rep(i,1,n) {rep(j,1,n) cerr<<rea[i][j]<<\" \";pts;}\n    rep(x,1,n){\n\t//dbg(x);\n\tvector<int> fk;\n\trpp(i,x,e,head){\n\t    fk.push_back(i);\n\t    col=e[i].id;\n\t    int v=e[i].to;if(p[x][v]) continue;\n\t    dfs2(v,x);\n\t}\n\treverse(fk.begin(),fk.end());\n\tfor(auto i:fk){\n\t    //dbg(e[i].id);\n\t    col=e[i].id;\n\t    int v=e[i].to;if(q[x][v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    //rep(i,1,n){rep(j,1,n) cerr<<p[i][j]<<\" \";pts;}\n    //rep(i,1,n){rep(j,1,n) cerr<<q[i][j]<<\" \";pts;}\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];//dbg(k);\n\t//dbg(p[u][v]);dbg(q[u][v]);\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\t//dbg(k);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,id;\n}E[200005];\nint head[1005],sumE,M,N,a[200005],b[200005],mark[1005],tims;\nbool a1[200005],a2[200005];\nbool reachable[1005][1005];\nvector<int> v;\nvoid add(int u,int v,int id) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].id = id;\n    head[u] = sumE;\n}\nvoid dfs(int f,int u) {\n    mark[u] = tims;\n    reachable[f][u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(mark[v] != tims) {\n\t    dfs(f,v);\n\t}\n    }\n}\nvoid Solve() {\n    read(N);read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(a[i]);read(b[i]);\n\tadd(a[i],b[i],i);\n    }\n    \n    for(int u = 1 ; u <= N ; ++u) {\n\tv.clear();\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    v.pb(E[i].id);\n\t}\n\t++tims;\n\tmark[u] = tims;\n\tint s = v.size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    if(mark[b[v[i]]] == tims) a2[v[i]] = 1;\n\t    else dfs(u,b[v[i]]); \n\t}\n\t++tims;\n\tmark[u] = tims;\n\tfor(int i = s - 1 ; i >= 0 ; --i) {\n\t    if(mark[b[v[i]]] == tims) a2[v[i]] = 1;\n\t    else dfs(u,b[v[i]]);\n\t}\n    }\n    for(int i = 1 ; i <= M ; ++i) {\n\tif(reachable[b[i]][a[i]]^ a2[i]) puts(\"diff\");\n\telse puts(\"same\");\n    }\n    \n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    auto x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight = long long;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// 強連結成分分解 O(|V| + |E|)\nstd::vector<std::vector<Vertex>> strongly_connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  std::stack<Vertex> S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  // Tarjan\n  std::function<int(Vertex v)> dfs = [&](Vertex v) {\n    num[v] = low[v] = ++timer;\n    S.push(v); inS[v] = true;\n    for(const auto& e: G[v]) {\n      if(!num[e.to])     low[v] = std::min(low[v], dfs(e.to));\n      else if(inS[e.to]) low[v] = std::min(low[v], num[e.to]);\n    }\n    if(num[v] == low[v]) {\n      scc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto w = S.top(); S.pop(); inS[w] = false;\n        scc.back().push_back(w);\n        if(v == w) break;\n      }\n    }\n    return low[v];\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v);\n  return scc;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  vector<int> a(M), b(M);\n  for(auto i=0; i<M; ++i) {\n    cin >> a[i] >> b[i];\n    --a[i]; --b[i];\n    G[a[i]].push_back({a[i], b[i]});\n  }\n\n  auto scc = strongly_connected_component(G);\n  vector<int> group(N);\n  for(auto i=0; i<scc.size(); ++i) for(auto v: scc[i]) group[v] = i;\n\n  vector<int> in(N), out(N);\n  UnionFind<int> uf;\n  for(auto i=0; i<M; ++i) if(group[a[i]] != group[b[i]]) {\n    ++in[b[i]];\n    ++out[a[i]];\n    uf.unite(group[a[i]], group[b[i]]);\n  }\n\n  vector<int> indeg(N), outdeg(N);\n  for(auto i=0; i<M; ++i) if(group[a[i]] == group[b[i]]) {\n    ++outdeg[a[i]];\n    ++indeg[b[i]];\n  }\n  for(auto i=0; i<M; ++i) {\n    if(group[a[i]]!=group[b[i]]) {\n      if(uf.find(group[a[i]]) == uf.find(group[b[i]])) {\n        auto ai = in[a[i]]+1;\n        auto ao = out[a[i]]-1;\n        auto bi = in[b[i]]-1;\n        auto bo = out[b[i]]+1;\n        if(1<=ai&&1<=ao&&1<=bi&&1<=bo)cout << \"diff\" <<endl;\n        else                          cout << \"same\" <<endl;\n      } else {\n        cout << \"same\" << endl;\n      }\n    } else {\n      auto ai = indeg[a[i]]+1;\n      auto ao = outdeg[a[i]]-1;\n      auto bi = indeg[b[i]]-1;\n      auto bo = outdeg[b[i]]+1;\n      if(1<=ai&&1<=ao&&1<=bi&&1<=bo) cout << \"same\" << endl;\n      else                           cout << \"diff\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 1010;\nconst int M = 200010;\n\nstruct edge{int to, next;} e[M];\nint n, m, cnt, x[M], y[M], head[N], a[2][N][N];\nbitset <N> p[N];\n\nvoid ins(int x, int y)\n{\n    e[++cnt].to = y; e[cnt].next = head[x]; head[x] = cnt;\n}\n\nvoid dfs(int fl, int x, int st, int fir)\n{\n    if (a[fl][st][x]) return;\n    a[fl][st][x] = fir;\n    for(int i = head[x]; i; i = e[i].next)\n        if (e[i].to != st) dfs(fl, e[i].to, st, fir);\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    FOR(i, 1, m)\n    {\n        scanf(\"%d%d\", &x[i], &y[i]);\n        p[x[i]][y[i]] = 1;\n        ins(x[i], y[i]);\n    }\n    FOR(i, 1, n) FOR(j, 1, n) if (p[i][j]) dfs(0, j, i, j);\n    FOR(i, 1, n) for(int j = n; j; --j) if (p[i][j]) dfs(1, j, i, j);\n    FOR(i, 1, n) FOR(j, 1, n) if (p[j][i]) p[j] |= p[i];\n    FOR(i, 1, m) if (p[y[i]][x[i]] ^ (a[0][x[i]][y[i]] != y[i] || a[1][x[i]][y[i]] != y[i])) puts(\"diff\"); else puts(\"same\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1005\n#define M 200005\nusing namespace std;\n\nint n,m;\nbool irp[N][N],lnk[N][N];\nint rt,cnt,fir[N];\nbool col[N];\nvector<int>to[N];\nstruct edge{int u,v;}e[M];\n\ninline int read()\n{\n\tint ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\ninline void add(int a,int b){to[a].push_back(b);e[++cnt]=(edge){a,b};}\n\ninline void dfs(int x)\n{\n\tcol[x]=lnk[rt][x]=1;\n\tfor(auto it:to[x]) if(!col[it]) dfs(it);\n}\n\ninline void insert(int x)\n{\n\trt=x;\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n\tstd::reverse(to[x].begin(),to[x].end());\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n}\n\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint a=read(),b=read();\n\t\tadd(a,b);\n\t}\n\tfor(int i=1;i<=n;++i)insert(i);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x=e[i].u,y=e[i].v;\n\t\tputs(irp[x][y]^lnk[y][x]?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author yassin\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass arc092_f {\nprivate:\n    void dfs(int u, const vector<vector<int>> &g, vector<int> &vis, int nogo, int id) {\n        vis[u] = id;\n        for (int v : g[u]) {\n            if (!vis[v] && v != nogo) {\n                dfs(v, g, vis, nogo, id);\n            }\n        }\n    }\npublic:\n    void solve(istream& in, ostream& out) {\n        int N, M;\n        in >> N >> M;\n        vector<int> a(M), b(M);\n        vector<vector<int>> g(N);\n        for (int i = 0; i < M; ++i) {\n            in >> a[i] >> b[i];\n            --a[i];\n            --b[i];\n            g[a[i]].push_back(b[i]);\n        }\n        vector<vector<int>> reachable(N, vector<int>(N, 0));\n        for (int u = 0; u < N; ++u) {\n            dfs(u, g, reachable[u], -1, 1);\n        }\n        vector<vector<int>> reach_from_a(N, vector<int>(N, 0));\n        vector<vector<int>> reach_from_b(N, vector<int>(N, 0));\n        for (int u = 0; u < N; ++u) {\n            sort(begin(g[u]), end(g[u]));\n            for (int v : g[u]) {\n                if (!reach_from_a[u][v])\n                    dfs(v, g, reach_from_a[u], u, v + 1);\n            }\n            for (int i = (int)g[u].size() - 1; i >= 0; --i) {\n                int v = g[u][i];\n                if (!reach_from_b[u][v])\n                    dfs(v, g, reach_from_b[u], u, v + 1);\n            }\n        }\n        for (int i = 0; i < M; ++i) {\n            bool cond1 = reachable[b[i]][a[i]];\n            bool cond2 = reach_from_a[a[i]][b[i]] != b[i] + 1\n                        || reach_from_b[a[i]][b[i]] != b[i] + 1;\n            out << ((cond1 == cond2) ? \"same\" : \"diff\") << \"\\n\";\n        }\n    }\n};\n\nint main() {\n\tstd::ios::sync_with_stdio(false); cin.tie(nullptr);\n\tarc092_f solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1005, M = 2e5 + 10;\nint n, m, u[M], v[M], ok[N][N], pos[N][N], vis[N][N], ok2[N][N];\nvector<int> g[N];\nvoid dfs(int h, int u) {\n    ok[u][h] = 1;\n    for(auto v : g[u]) if(!ok[v][h]) dfs(h, v);\n}\nvoid dfs1(int h, int u, int fr) {\n    pos[h][u] = fr;\n    for(auto v : g[u])\n        if(!pos[h][v]) dfs1(h, v, u);\n}\nvoid dfs2(int h, int u) {\n    vis[h][u] = 1;\n    for(int i = g[u].size() - 1; i >= 0; --i) {\n        int v = g[u][i];\n        if(!vis[h][v]) {\n            if(pos[h][v] != u || u != h) ok2[h][v] = 1;\n            dfs2(h, v);\n        }\n    }\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for(int i = 1; i <= m; ++i) \n        scanf(\"%d %d\", &u[i], &v[i]), g[u[i]].push_back(v[i]);\n    for(int i = 1; i <= n; ++i) dfs(i, i);\n    for(int i = 1; i <= n; ++i) dfs1(i, i, i);\n    for(int i = 1; i <= n; ++i) dfs2(i, i);\n    for(int i = 1; i <= m; ++i) {\n        if(ok[u[i]][v[i]] ^ ok2[u[i]][v[i]]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n   int x=0,f=1;char ch=getchar();\n   while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n   while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n   return x*f;\n}\nconst int N=1005;\nvector<int> vec[N];\nint now,x[N],y[N],n,m,vis1[N][N],vis2[N][N];\nvoid dfs1(int x,int fa)\n{\n\tfor (int i=0;i<vec[x].size();i++)\n\t  if (vec[x][i]!=fa)\n\t  \t if (!vis1[now][vec[x][i]]) vis1[now][vec[x][i]]=x,dfs1(vec[x][i],x);\n}\nvoid dfs2(int x,int fa)\n{\n\tfor (int i=vec[x].size()-1;i>=0;i--)\n\t  if (vec[x][i]!=fa)\n\t  \t if (!vis2[now][vec[x][i]]) vis2[now][vec[x][i]]=x,dfs2(vec[x][i],x);\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (int i=1;i<=m;i++) x[i]=read(),y[i]=read(),vec[x[i]].push_back(y[i]);\n\tfor (int i=1;i<=n;i++) \n\t{ \n\t  now=i;vis1[now][now]=vis2[now][now]=1;//注意把起点的vis标记！ \n\t  dfs1(i,-1);\n\t  dfs2(i,-1);\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tputs(((vis1[y[i]][x[i]]!=0)^(vis1[x[i]][y[i]]!=x[i]||vis2[x[i]][y[i]]!=x[i]))?\"diff\":\"same\");\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define mp make_pair\n#define elif else if\n#define prev prev2\n#define Edge pair <int, int>\n#define next next2\n#define u first\n#define v second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1007, N = 1007, MAXM = 2e5 + 7;\nvector<int> g[MAXM], gt[MAXM];\nint a[MAXM], b[MAXM], c1[MAXM], c2[MAXM];\nvector<int> topsort;\nint vis[MAXM];\nEdge ed[MAXM];\nbool used[MAXM];\nvoid dfs(int u) {\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (!used[v]) dfs(v);\n    }   \n}   \nvoid solve(int u) {\n    memset(used, 0, sizeof used);\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n    memset(used, 0, sizeof used);\n    used[u] = 1;\n    reverse(g[u].begin(), g[u].end());\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n}   \nvoid dfst1(int v) {\n    vis[v] = 1;\n    for (int e : g[v]) {\n        int u = b[e];\n        if (!vis[u])\n            dfst1(u);\n    }\n    topsort.push_back(v);\n}\nint clr = 0;\nvoid dfst2(int v) {\n    vis[v] = clr;\n    for (int e : gt[v]) {\n        int u = a[e];\n        if (!vis[u])\n            dfst2(u);\n    }\n}\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        cin >> a[i] >> b[i];\n        --a[i];\n        --b[i];\n        g[a[i]].push_back(i);\n        gt[b[i]].push_back(i);\n    }\n    for (int i = 0; i < n; ++i)\n        if (!vis[i])\n            dfst1(i);\n    fill(vis, vis + n, 0);\n    reverse(topsort.begin(), topsort.end());\n    for (int v : topsort)\n        if (!vis[v]) {\n            ++clr;\n            dfst2(v);\n        }\n\n    for (int i = 0; i < m; ++i) \n        c1[i] = (vis[a[i]] == vis[b[i]]);\n    for (int i = 0; i < m; ++i) {\n        ed[i] = {a[i], b[i]};\n    }   \n    for (int i = 0; i < n; ++i) {\n        solve(i);\n    }\n\n    #ifdef HOME\n    for (int i = 0; i < m; ++i) cout << c1[i] << ' '; cout << '\\n';\n    for (int i = 0; i < m; ++i) cout << c2[i] << ' '; cout << '\\n';\n    #endif\n\n    for (int i = 0; i < m; ++i) {\n        //cout << c1[i] << c2[i];\n        if (c1[i] ^ c2[i]) {\n            cout << \"diff\\n\";\n        }   \n        else {\n            cout << \"same\\n\";\n        }\n    }   \n    return;\n}\n\nsigned main() {\n\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    ios_base::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 1021\n#define MXN 1021\n#define PB push_back\n#define FZ(X) memset(X,0,sizeof(X))\nstruct Scc{\n  int n, nScc, vst[MXN], bln[MXN];\n  vector<int> E[MXN], rE[MXN], vec;\n  void init(int _n){\n    n = _n;\n    for (int i=0; i<MXN; i++){\n      E[i].clear();\n      rE[i].clear();\n    }\n  }\n  void add_edge(int u, int v){\n    E[u].PB(v);\n    rE[v].PB(u);\n  }\n  void DFS(int u){\n    vst[u]=1;\n    for (auto v : E[u])\n      if (!vst[v]) DFS(v);\n    vec.PB(u);\n  }\n  void rDFS(int u){\n    vst[u] = 1;\n    bln[u] = nScc;\n    for (auto v : rE[u])\n      if (!vst[v]) rDFS(v);\n  }\n  void solve(){\n    nScc = 0;\n    vec.clear();\n    FZ(vst);\n    for (int i=0; i<n; i++)\n      if (!vst[i]) DFS(i);\n    reverse(vec.begin(),vec.end());\n    FZ(vst);\n    for (auto v : vec){\n      if (!vst[v]){\n        rDFS(v);\n        nScc++;\n      }\n    }\n  }\n} graph;\nvoid build(){\n\n}\n#define M 202020\nint n , m , a[ M ] , b[ M ];\nvoid init(){\n  n = getint();\n  m = getint();\n  graph.init( n );\n  for( int i = 0 ; i < m ; i ++ ){\n    a[ i ] = getint() - 1;\n    b[ i ] = getint() - 1;\n    graph.add_edge( a[ i ] , b[ i ] );\n  }\n  graph.solve();\n}\nint way[ N ][ N ] , instk[ N ];\nvoid go( int fr , int now ){\n  instk[ now ] = 1;\n  for( int nxt : graph.E[ now ] ){\n    if( way[ fr ][ nxt ] ){\n      if( instk[ nxt ] )\n        continue;\n      if( way[ fr ][ nxt ] == 2 )\n        continue;\n      way[ fr ][ nxt ] = 2;\n      go( fr , nxt );\n      continue;\n    }\n    way[ fr ][ nxt ] = 1;\n    go( fr , nxt );\n  }\n  instk[ now ] = 0;\n}\nvoid solve(){\n  for( int i = 0 ; i < n ; i ++ ){\n    way[ i ][ i ] = 1;\n    go( i , i );\n  }\n  for( int i = 0 ; i < m ; i ++ )\n    if( graph.bln[ a[ i ] ] !=\n        graph.bln[ b[ i ] ] ){\n      if( way[ a[ i ] ][ b[ i ] ] > 1 )\n        puts( \"diff\" );\n      else\n        puts( \"same\" );\n    }else{\n      if( way[ a[ i ] ][ b[ i ] ] > 1 )\n        puts( \"same\" );\n      else\n        puts( \"diff\" );\n    }\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[1010];\nint n,m,b[200020][2];\nbool vis[1010],f[200020][2];\nint q[1010],h,t,l[1010],r[1010];\nint st[1010],tp;\nvoid dfs1(int v,int a[],int w)\n{\n\tvis[v]=1,a[v]=w;\n\tfor(auto u:E[v])if(!vis[u])dfs1(u,a,w);\n}\nvoid work(int v)\n{\n\ttp=0;\n\tfor(auto u:E[v])st[++tp]=u;\n\tmemset(vis+1,0,n);vis[v]=1;\n\tfor(int i=1;i<=tp;++i)if(!vis[st[i]])dfs1(st[i],l,i);\n\tmemset(vis+1,0,n);vis[v]=1;\n\tfor(int i=tp;i;--i)if(!vis[st[i]])dfs1(st[i],r,i);\n\tfor(int i=1;i<=m;++i)if(b[i][0]==v)f[i][0]=l[b[i][1]]!=r[b[i][1]];\n}\nvoid dfs(int v)\n{\n\tvis[v]=1;\n\tfor(auto u:E[v])if(!vis[u])dfs(u);\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tint x,y;\n\tfor(int i=1;i<=m;++i)scanf(\"%d %d\",&x,&y),E[x].emplace_back(y),b[i][0]=x,b[i][1]=y;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tmemset(vis+1,0,n);\n\t\tdfs(i);\n\t\tfor(int j=1;j<=m;++j)if(b[j][1]==i)f[j][1]=vis[b[j][0]];\n\t}\n\tfor(int i=1;i<=n;++i)work(i);\n\tfor(int i=1;i<=m;++i)\n\t\tif(f[i][0]!=f[i][1])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\ninline int qread(){\n\tint x=0,sign=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') sign=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*sign;\n}\nint n,m; \nint s[maxn],e[maxn];\n//struct edge{\n//\tint from;\n//\tint to;\n//\tint next;\n//}E[maxm];\n//int sz=0; \n//int head[maxn];\n//void add_edge(int u,int v){\n//\tsz++;\n//\tE[sz].from=u;\n//\tE[sz].to=v;\n//\tE[sz].next=head[u];\n//\thead[u]=sz;\n//}\nvector<int>E[maxn];\nvoid add_edge(int u,int v){\n\tE[u].push_back(v);\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tint y;\n\tused[x]=1;\n\troute[s][x]++;\n\tint cnt=E[x].size();\n\tfor(int i=0;i<cnt;i++){\n\t\ty=E[x][i];\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nchar a[]=\"same\",b[]=\"diff\";\nvoid qprint(char *s,int len){\n\tfor(int i=0;i<len;i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('\\n');\n}\nint main(){\n//\tscanf(\"%d %d\",&n,&m);\n\tn=qread();\n\tm=qread(); \n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n//\t\tscanf(\"%d %d\",&u,&v);\n\t\ts[i]=qread();\n\t\te[i]=qread();\n\t\tadd_edge(s[i],e[i]);\n\t}\n\tint y;\n\tfor(int i=1;i<=n;i++){\n\t\tint cnt=E[i].size();\n\t\tfor(int j=0;j<cnt;j++){\n\t\t\ty=E[i][j];\n\t\t\tif(route[i][y]<2){\n\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\tdfs(i,y);\n\t\t\t}\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(s[i],e[i]) )qprint(b,4);\n\t\telse qprint(a,4);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 64) {\n    int l = _, r = min< int >(g[idx].size(), _ + 64);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else {\n          dp[e.first] |= dp[p];\n        }\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  for(int i = 0; i < N; i++) {\n    random_shuffle(begin(g[i]), end(g[i]));\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define N 1005\n#define M 200005\nusing namespace std;\nstruct Edge{\n\tint to,next,last;\n}edge[M];\nint head[N],tot,first[N];\nvoid addedge(int from,int to){\n\tedge[++tot].to=to;\n\tif(head[from]){\n\t\tedge[head[from]].last=tot;\n\t}else{\n\t\tfirst[from]=tot;\n\t}\n\tedge[tot].next=head[from];\n\thead[from]=tot;\n}\nint p1[N][N];\nbool vis[N];\nvoid dfs1(int now,int p){\n\tif(vis[now]){\n\t\treturn;\n\t}\n\tvis[now]=true;\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=now;\n\t\tdfs1(v,p);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p){\n\tfor(int i=first[now];i;i=edge[i].last){\n\t\tint v=edge[i].to;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=now;\n\t\tdfs2(v,p);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;++i){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\taddedge(u[i],v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tmemset(vis,0,sizeof vis);\n\t\tdfs1(i,i);\n\t\tmemset(vis,0,sizeof vis);\n\t\tdfs2(i,i);\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// F.\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> II;\nset<int> g[1000];\nbool vis[1000];\n\nbool dfs(int s, int e) {\n\tvis[s] = true;\n\tfor (int n : g[s]) {\n\t\tif (n == e) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!vis[n] && dfs(n, e)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(int argc, char *argv[])\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<II> e;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tg[a - 1].insert(b - 1);\n\t\te.push_back(II(a - 1, b - 1));\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tg[e[i].first].erase(e[i].second);\n\t\tfill(vis, vis + n, false);\n\t\tbool ab = dfs(e[i].first, e[i].second);\n\t\tfill(vis, vis + n, false);\n\t\tbool ba = dfs(e[i].second, e[i].first);\n\t\tcout << (ab == ba ? \"same\" : \"diff\") << endl;\n\t\tg[e[i].first].insert(e[i].second);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n// for testing\n\n//*\n\nvoid kosaraju(int);\nvoid kosaraju2(int, int);\n\nint mat[1010][1010];\n\nvoid kosaraju_mat(int f) {\n    for (int u=1; u<=n; ++u) {\n        if (mat[f][u] && !starred[u]) {\n            starred[u] = true;\n            kosaraju_mat(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2_mat(int f, int f2) {\n    unf[f] = f2;\n    for (int u=1; u<=n; ++u) {\n        if (mat[u][f] && !unf[u]) {\n            kosaraju2_mat(u, f2);\n        }\n    }\n}\n\nvoid slow_print() {\n    memset(starred, 0, 1010 * sizeof(bool));\n    memset(unf, 0, 1010 * sizeof(int));\n    kos.clear();\n    for (auto u : piv) {\n        mat[u.first][u.second] = 1;\n    }\n    int c = 0, i;\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n        int u = *it;\n        if (!unf[u]) {\n            ++c;\n            kosaraju2(u, u);\n        }\n    }\n    for (auto u : piv) {\n        int tc = 0;\n        --mat[u.first][u.second];\n        ++mat[u.second][u.first];\n        kos.clear();\n        memset(starred, 0, 1010 * sizeof(bool));\n        memset(unf, 0, 1010 * sizeof(int));\n        for (i=1; i<=n; ++i) {\n            if (!starred[i]) {\n                starred[i] = true;\n                kosaraju_mat(i);\n            }\n        }\n        for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n            int u = *it;\n            if (!unf[u]) {\n                ++tc;\n                kosaraju2_mat(u, u);\n            }\n        }\n        printf(\"%d\", c != tc);\n        //puts(c == tc ? \"same\" : \"diff\");\n        ++mat[u.first][u.second];\n        --mat[u.second][u.first];\n    }\n}\n\n//*/\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            res[removed][u] = 0;\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return res[removed][s] ? res[removed][s] : -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : bll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nvoid topological_sort(int f) {\n    for (int u : ll[f]) {\n        int n2 = unf[u];\n        if (!starred[n2]) {\n            starred[n2] = true;\n            topological_sort(n2);\n        }\n    }\n    topo_sort[topo_cnt++] = f;\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n        int u = *it;\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n        /*\n        printf(\"i = %d\\n\", i);\n        for (int j=1; j<=n; ++j) {\n            printf(\"%d %d\\n\", starred[j], res[i][j]);\n        }\n        //*/\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    memset(starred, 0, 1010);\n    for (i=1; i<=n; ++i) {\n        int n2 = unf[i];\n        if (!starred[n2]) {\n            starred[n2] = true;\n            topological_sort(n2);\n        }\n    }\n    reverse(topo_sort, topo_sort + topo_cnt);\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=0; i<topo_cnt; ++i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    /*\n    for (i=1; i<=n; ++i) {\n        for (int j=1; j<=n; ++j) {\n            printf(\"%s\", dag_visit[i].test(j) ? \"1\" : \"0\");\n        }\n        puts(\"\");\n    }\n    //*/\n    /*\n    for (i=1; i<=n; ++i) {\n        printf(\"%d \", unf[i]);\n    }\n    puts(\"\");\n    //*/\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n            //printf(\"%d\", t==-1 || t == u.first);\n        } else {\n            int n1 = unf[u.first], n2 = unf[u.second];\n            puts(dag_edge[n1][n2] >= 2 || dag_second_visit[n1].test(n2) ? \"diff\" : \"same\");\n            //printf(\"%d\", dag_edge[n1][n2] >= 2 || dag_second_visit[n1].test(n2));\n        }\n    }\n    /*\n    puts(\"===\");\n    slow_print();\n    //*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int LG = 21;\nconst int FN = 400005;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(FN);\n    __ufact.resize(FN);\n    __rev.resize(FN);\n    __rev[1] = 1;\n    for (int i = 2; i < FN; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < FN; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nconst int N = 1010;\nconst int M = 101010;\nvector<int> graph[N];\nint go[N][N], f[N][N], g[N][N];\nint fr[M], to[M], glina[M];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    forn(i, m)\n    {\n        int a, b;\n        cin >> a >> b;\n        glina[i] = graph[a].size();\n        graph[a].push_back(b);\n        fr[i] = a, to[i] = b;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> q = {i};\n        go[i][i] = 1;\n        for (int j = 0; j < q.size(); j++)\n        {\n            int v = q[j];\n            for (auto u : graph[v]) if (!go[i][u]) go[i][u] = 1, q.push_back(u);\n        }\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) f[i][j] = -1, g[i][j] = -1;\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> vis(n + 1, 0);\n        vis[i] = 1;\n        for (int a = 0; a < graph[i].size(); a++)\n        {\n            vector<int> q = {graph[i][a]};\n            for (int j = 0; j < q.size(); j++)\n            {\n                int v = q[j];\n                f[i][v] = a;\n                for (auto u : graph[v]) if (!vis[u]) vis[u] = 1, q.push_back(u);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> vis(n + 1, 0);\n        vis[i] = 1;\n        for (int a = (int)graph[i].size() - 1; a >= 0; a--)\n        {\n            vector<int> q = {graph[i][a]};\n            for (int j = 0; j < q.size(); j++)\n            {\n                int v = q[j];\n                g[i][v] = a;\n                for (auto u : graph[v]) if (!vis[u]) vis[u] = 1, q.push_back(u);\n            }\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int id = glina[i];\n        int v = fr[i], u = to[i];\n        int fl = (f[v][u] != -1 && f[v][u] != id);\n        fl |= (g[v][u] != -1 && g[v][u] != id);\n        if (fl ^ go[u][v]) cout << \"diff\\n\";\n        else cout << \"same\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 1054, M = 200054;\n\nstruct edge {\n\tint u, v;\n\tedge (int u0 = 0, int v0 = 0) : u(u0), v(v0) {}\n} e[M];\n\nint V, E, tag, root;\nint first[N], next[M], from[N];\nbool saturated[N], connected[N][N], reversible[N][N];\n\ninline void addedge(int u, int v, int id) {e[id] = edge(u, v), next[id] = first[u], first[u] = id;}\n\nvoid dfs(int x) {\n\tif (saturated[x] || x == root || from[x] == tag) return;\t\n\tfrom[x] ? (saturated[x] = true) : (from[x] = tag);\n\tfor (int i = first[x]; i; i = next[i]) dfs(e[i].v);\n}\n\nvoid solve() {\n\tint i;\n\tmemset(saturated, false, V + 1);\n\tmemset(from, 0, (V + 1) << 2);\n\tfor (i = first[root]; i; i = next[i]) dfs(tag = e[i].v);\n\tfor (i = 1; i <= V; ++i) if (i != root)\n\t\tconnected[root][i] = saturated[i] || from[i],\n\t\treversible[root][i] = saturated[i] || (from[i] && from[i] != i);\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (i = 1; i <= E; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v, i);\n\tfor (root = 1; root <= V; ++root) solve();\n\tfor (i = 1; i <= E; ++i)\n\t\tu = e[i].u, v = e[i].v, puts(connected[v][u] == reversible[u][v] ? \"same\" : \"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>pat[1010];\nvector<int>idx[1010];\nint cnt[1010][1010];\nint frm[1010];\nint ans[202020];\nvoid dfs(int node, int p, int dir)\n{\n\tif (node == p)return;\n\tif (cnt[p][node] >= 2)return;\n\tif (cnt[p][node] == 1 && frm[node] == dir)return;\n\tif (cnt[p][node] == 0)frm[node] = dir;\n\tcnt[p][node]++;\n\tfor (int i = 0; i < pat[node].size(); i++)dfs(pat[node][i], p, dir);\n}\nint main()\n{\n\tint num, way;\n\tscanf(\"%d%d\", &num, &way);\n\tfor (int i = 0; i < way; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tidx[za].push_back(i);\n\t}\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfill(frm, frm + num, -1);\n\t\tfor (int j = 0; j < pat[i].size(); j++)dfs(pat[i][j], i, pat[i][j]);\n\t}\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < pat[i].size(); j++)\n\t\t{\n\t\t\tbool f = cnt[i][pat[i][j]] >= 2;\n\t\t\tbool g = cnt[pat[i][j]][i] >= 1;\n\t\t\tans[idx[i][j]] = f != g;\n\t\t}\n\t}\n\tfor (int i = 0; i < way; i++)printf(ans[i] ? \"diff\\n\" : \"same\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[100000];\nusing int64 = unsigned long long;\nbool ans[100000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t) {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 64) {\n\n\n    int l = _, r = min< int >(g[idx].size(), _ + 64);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          // cout << \"foo\" << endl;\n\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else dp[e.first] |= dp[p];\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\n\nint main() {\n\n  cin >> N >> M;\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  vector< vector< int > > t;\n  scc.build(t);\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int N = 1000 + 7;\n\nvector <int> g[N];\nvector <int> rg[N];\nint comp[N];\nbool u[N];\n\nvector <int> t;\n\nvoid zhfs(int v)\n{\n    u[v] = true;\n    for (int to : g[v])\n    {\n        if (!u[to])\n        {\n            zhfs(to);\n        }\n    }\n    t.push_back(v);\n}\n\nint sz = 0;\n\nvoid rzhfs(int v)\n{\n    comp[v] = sz;\n    u[v] = true;\n    for (int to : rg[v])\n    {\n        if (!u[to])\n        {\n            rzhfs(to);\n        }\n    }\n}\n\nvoid dfs(int v)\n{\n    u[v] = true;\n    for (int to : g[v])\n    {\n        if (!u[to])\n        {\n            dfs(to);\n        }\n    }\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    vector <pair <int, int> > e;\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--, b--;\n        e.push_back({a, b});\n        g[a].push_back(b);\n        rg[b].push_back(a);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        if (!u[i])\n        {\n            zhfs(i);\n        }\n    }\n    reverse(t.begin(), t.end());\n    for (int v : t) u[v] = 0;\n    for (int v : t)\n    {\n        if (!u[v])\n        {\n            sz++;\n            rzhfs(v);\n        }\n    }\n    map <pair <int, int>, int> ans;\n    for (int v = 0; v < n; v++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            u[j] = 0;\n        }\n        u[v] = true;\n        for (int to : g[v])\n        {\n            if (u[to])\n            {\n                ans[{v, to}] = 1;\n            }\n            dfs(to);\n        }\n        reverse(g[v].begin(), g[v].end());\n        for (int j = 0; j < n; j++)\n        {\n            u[j] = 0;\n        }\n        u[v] = true;\n        for (int to : g[v])\n        {\n            if (u[to])\n            {\n                ans[{v, to}] = 1;\n            }\n            dfs(to);\n        }\n    }\n    for (auto c : e)\n    {\n        if (comp[c.first] != comp[c.second]) ans[c] ^= 1;\n        if (ans[c])\n        {\n            cout << \"same\\n\";\n        }\n        else\n        {\n            cout << \"diff\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> from(m);\n  vector<int> to(m);\n  vector<vector<int>> g(n);\n  for (int i = 0; i < m; ++i) {\n    cin >> from[i] >> to[i];\n    --from[i]; --to[i];\n    g[from[i]].push_back(to[i]);\n  }\n  vector<vector<bool>> reach(n, vector<bool>(n));\n  for (int f = 0; f < n; ++f) {\n    function<void(int)> dfs = [&](int v) {\n      reach[f][v] = true;\n      for (int u : g[v]) {\n        if (!reach[f][u]) {\n          dfs(u);\n        }\n      }\n    };\n    dfs(f);\n  }\n  vector<vector<bool>> another(n, vector<bool>(n));\n  for (int f = 0; f < n; ++f) {\n    vector<int> foo(n, -1);\n    function<void(int, int)> dfs_foo = [&](int v, int w) {\n      foo[v] = w;\n      for (int u : g[v]) {\n        if (u != f && foo[u] == -1) {\n          dfs_foo(u, w);\n        }\n      }\n    };\n    for (int i = 0; i < (int) g[f].size(); ++i) {\n      int v = g[f][i];\n      if (foo[v] == -1) {\n        dfs_foo(v, i);\n      }\n    }\n    vector<int> bar(n, -1);\n    function<void(int, int)> dfs_bar = [&](int v, int w) {\n      bar[v] = w;\n      for (int u : g[v]) {\n        if (u != f && bar[u] == -1) {\n          dfs_bar(u, w);\n        }\n      }\n    };\n    for (int i = (int) g[f].size() - 1; ~i; --i) {\n      int v = g[f][i];\n      if (bar[v] == -1) {\n        dfs_bar(v, i);\n      }\n    }\n    for (int t = 0; t < n; ++t) {\n      if (foo[t] != bar[t]) {\n        another[f][t] = true;\n      }\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    cout << (reach[to[i]][from[i]] == another[from[i]][to[i]] ? \"same\" : \"diff\") << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint ans[200010];\nvector<int> adj[1010], radj[1010], sadj[1010], U, V;\nint tin[1010], bck[1010], id[1010], timer, scnt;\nstack<int> stk;\n\nvoid dfs(int u) {\n    tin[u] = timer++;\n    bck[u] = tin[u];\n    stk.push(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int e = adj[u][i];\n        int v = V[e];\n        if(tin[v] == -1) {\n            dfs(v);\n            bck[u] = min(bck[u], bck[v]);\n        }\n        else if(id[v] == -1) {\n            bck[u] = min(bck[u], tin[v]);\n        }\n    }\n    if(bck[u] == tin[u]) {\n        while(1) {\n            int t = stk.top(); stk.pop();\n            id[t] = scnt;\n            if(t == u) break;\n        }\n        scnt++;\n    }\n}\n\nint cc[1010][1010];\nint dp(int u, int d) {\n    int &ret = cc[u][d];\n    if(ret != -1) return ret;\n    if(u == d) return ret = 0;\n\n    ret = 0;\n    for(int i = 0; i < sadj[u].size(); i++) {\n        int e = sadj[u][i];\n        int v = id[ V[e] ];\n        ret = max(ret, 1 + dp(v, d));\n    }\n    return ret;\n}\n\nvoid scc() {\n    memset(tin, -1, sizeof(tin));\n    memset(id, -1, sizeof(id));\n    for(int i = 0; i < N; i++) if(tin[i] == -1) {\n        dfs(i);\n    }\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            sadj[ id[u] ].push_back(e);\n        }\n    }\n    memset(cc, -1, sizeof(cc));\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            int cnt = 0;\n            for(int i = 0; i < sadj[ id[u] ].size(); i++) {\n                int e = sadj[ id[u] ][i];\n                if(id[v] == id[ V[e] ]) cnt++;\n            }\n            if(cnt > 1 || dp(id[u], id[v]) > 1) ans[e] = 1;\n            else ans[e] = 0;\n        }\n    }\n}\n\nqueue<int> q1, q2;\nint dist1[1010], dist2[1010], par1[1010], par2[1010];\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < M; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(i);\n        radj[v].push_back(i);\n        U.push_back(u);\n        V.push_back(v);\n    }\n\n    scc();\n\n    for(int u = 0; u < N; u++) {\n        memset(dist1, -1, sizeof(dist1));\n        memset(dist2, -1, sizeof(dist2));\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                q1.push(v);\n                dist1[v] = 0;\n                par1[v] = v;\n            }\n        }\n        while(!q1.empty()) {\n            int t = q1.front(); q1.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist1[v] == -1) {\n                        dist1[v] = dist1[t] + 1;\n                        par1[v] = par1[t];\n                        q1.push(v);\n                    }\n                    else if(dist2[v] == -1 && par1[v] != par1[t]) {\n                        dist2[v] = dist1[t] + 1;\n                        par2[v] = par1[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n        while(!q2.empty()) {\n            int t = q2.front(); q2.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist2[v] == -1 && par1[v] != par2[t]) {\n                        dist2[v] = dist2[t] + 1;\n                        par2[v] = par2[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                if(dist2[v] != -1) ans[e] = 0;\n                else ans[e] = 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++) {\n        if(ans[i]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int maxN = 1005;\nstruct edge{\n\tint v, idx;\n\tedge(){};\n\tedge(int v_, int idx_) {\n\t\tv = v_; idx = idx_;\n\t} \n};\nint N, M, U[maxN * maxN], V[maxN * maxN], tim, vis[maxN], bel[maxN][maxN][2];\nvector<edge> sons[maxN];\n\nvoid dfs(int u, int fa, int t, int f) {\n\t//cout << u << endl;\n\tvis[u] = tim; bel[fa][u][f] = t;\n\tint sz = sons[u].size();\n\tfor(int i = 0; i < sz; ++i) {\n\t\tif(vis[sons[u][i].v] != tim) {\n\t\t\tdfs(sons[u][i].v, fa, t, f);\n\t\t}\n\t}\n}\n\nvoid solve(int u) {\n\tvis[u] = ++tim;\n\tint sz = sons[u].size();\n\tfor(int i = 0; i < sz; ++i) {\n\t\tif(vis[sons[u][i].v] != tim) {\n\t\t\tdfs(sons[u][i].v, u, sons[u][i].idx, 0);\n\t\t}\n\t}\n\treverse(sons[u].begin(), sons[u].end());\n\tvis[u] = ++tim;\n\tfor(int i = 0; i < sz; ++i) {\n\t\tif(vis[sons[u][i].v] != tim) {\n\t\t\tdfs(sons[u][i].v, u, sons[u][i].idx, 1);\n\t\t}\n\t}\t\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 1; i <= M; ++i) {\n\t\tscanf(\"%d%d\", &U[i], &V[i]);\n\t\tsons[U[i]].push_back(edge(V[i], i));\n\t}\n\tfor(int i = 1; i <= N; ++i) solve(i);\n\tfor(int i = 1; i <= M; ++i) {\n\t\tif((bel[V[i]][U[i]][0] != 0) ^ ((bel[U[i]][V[i]][0] != i) || (bel[U[i]][V[i]][1] != i)))\n\t\t\tprintf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,x[200005],y[200005],book[1005];\nint top,nex[200005],to[200005],fir[1005];\nmap<int,int> mp[1005],mp2[1005];\ninline void lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\ninline void ss(int v,int w,int ww){\n\tbook[v]=i;\n\tif(ww=1)\n\t\tmp[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss(to[top1],w==0?top1:w,v==i?1:0);\n}\ninline void ss2(int v,int w,int ww){\n\tbook[v]=i;\n\tif(ww=1)\n\t\tmp2[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss2(to[top1],w==0?top1:w,v==i?1:0);\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=m;i++){\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t\tlj(x[i],y[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tss(i,0,0);\n\tfor(i=1;i<=top;i++){\n\t\tnex[i]=0;\n\t\tto[i]=0;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tbook[i]=0;\n\t\tfir[i]=0;\n\t}\n\ttop=0;\n\tfor(i=m;i>=1;i--)\n\t\tlj(x[i],y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tss2(i,0,0);\n\tfor(i=1;i<=m;i++){\n\t\tif((mp[y[i]][x[i]]!=0)+(mp[x[i]][y[i]]+mp2[x[i]][y[i]]==m+1)==1)\n\t\t\tprintf(\"same\\n\");\n\t\telse\n\t\t\tprintf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1005;\nconst int M = 200005;\nbool not_necessary[N][N];\nvector<int> con[N];\nint a[M], b[M];\nint vis[N];\nint fe[N];\n\nstruct graph {\n  int n;\n  vector<vector<int>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst) {\n    adj[src].push_back(dst);\n  }\n\n  vector<vector<int>> strongly_connected_components() {\n    vector<vector<int>> scc;\n    vector<int> S, B, I(n);\n    function<void(int)> dfs = [&](int u) {\n      B.push_back(I[u] = S.size());\n      S.push_back(u);\n      for (int v: adj[u]) {\n        if (!I[v]) dfs(v);\n        else while (I[v] < B.back()) B.pop_back();\n      }\n      if (I[u] == B.back()) {\n        scc.push_back({});\n        B.pop_back();\n        for (; I[u] < S.size(); S.pop_back()) {\n          scc.back().push_back(S.back());\n          I[S.back()] = n + scc.size();\n        }\n      }\n    };\n    for (int u = 0; u < n; ++u)\n      if (!I[u]) dfs(u);\n    return scc; // I[u] - n is the index of u\n  }\n};\n\ntemplate<class T>\nstruct fixedSizeQueue{\n\tint n, L, R;\n\tT * arr;\n\tfixedSizeQueue(int n) : n(n){\n\t\tarr = new T[2 * n + 10];\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tvoid push_back(T x){\n\t\tarr[++R] = x; \n\t}\n\n\tvoid push_front(T x){\n\t\tarr[--L] = x;\n\t}\n\t\n\tT front(){\n\t\treturn arr[L];\n\t}\n\n\tT back(){\n\t\treturn arr[R];\n\t}\n\n\tT pop_front(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[L++];\n\t}\n\n\tT pop_back(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[R--];\n\t}\n\n\tvoid re_init_indices(){\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tbool empty(){\n\t\treturn L > R;\n\t}\n};\nint main(){\n\tint n, m; sd(n); sd(m);\n\tgraph g(n + 1);\n\tfor(int i = 1; i <= m; i++){\n\t\tsd(a[i]);\n\t\tsd(b[i]);\n\t\tcon[a[i]].push_back(b[i]);\n\t\tg.add_edge(a[i], b[i]);\n\t}\n\tvector<vector<int>> comp = g.strongly_connected_components();\n\tvector<int> where(2 * n + 1);\n\tfor(int i = 0; i < comp.size(); i++)\n\t\tfor(auto it : comp[i])\n\t\t\twhere[it] = i;\n\tfixedSizeQueue<pii> q(n);\n\tfor(int i = 1; i <= n; i++){\n\t\tq.re_init_indices();\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int v : con[i]){\n\t\t\tq.push_back({v, v});\n\t\t\tvis[v] = 1;\n\t\t\tfe[v] = v;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tauto it = q.pop_front();\n\t\t\tint u = it.F, firstEdge = it.S;\n\t\t\tfor(int v : con[u]){\n\t\t\t\tif(v == i || vis[v] >= 2) continue;\n\t\t\t\tif(vis[v] == 1 && firstEdge == fe[v]) continue;\n\t\t\t\tq.push_back({v, firstEdge});\n\t\t\t\tif(vis[v] == 0)\n\t\t\t\t\tfe[v] = firstEdge;\n\t\t\t\tvis[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int v : con[i]) if(vis[v] == 2){\n\t\t\tnot_necessary[i][v] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\n\t\tprintf( (not_necessary[a[i]][b[i]] ^ (where[a[i]] != where[b[i]] )) ? \"same\\n\" : \"diff\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxn 1010\n#define maxm 200010\nusing namespace std;\ntypedef long long LL;\nint f[maxn][maxn][2], vis[maxn<<1], T;\nstruct node {int to, id; };\nvector<node> edge[maxn];\npair<int, int> E[maxm];\nvoid dfs(int u, int src, int id, int type) {\n    f[src][u][type] = id; vis[u] = T;\n    for (auto& e : edge[u]) {\n        int v = e.to;\n        if (vis[v]!=T) dfs(v, src, id, type);\n    }\n}\nvoid work(int src) {\n    ++T; vis[src] = T;\n    for (auto& e : edge[src]) {\n        int v = e.to;\n        if (vis[v]!=T) dfs(v, src, e.id, 0);\n    }\n\n    reverse(edge[src].begin(), edge[src].end());\n    ++T; vis[src] = T;\n    for (auto& e : edge[src]) {\n        int v = e.to;\n        if (vis[v]!=T) dfs(v, src, e.id, 1);\n    }\n}\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    int n, m, u, v;\n    scanf(\"%d%d\", &n ,&m);\n    F2(i, 1, m) {\n        scanf(\"%d%d\", &u, &v);\n        edge[u].push_back({v, i});\n        E[i] = {u, v};\n    }\n    F2(i, 1, n) work(i);\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f[i][j][0]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f[i][j][1]); puts(\"\");\n//    }\n    F2(i, 1, m) {\n        int u = E[i].first, v = E[i].second;\n        if (f[v][u]!=0 ^ (f[u][v][0]!=i||f[u][v][1]!=i)) puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=1000 +117;\nconst int MM=200000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nvector<int> p[NN];\nvector<int> rp[NN];\nmap<pair<int,int>,int> id;\nbool ans[MM]={};\nint fir[NN]={};\nint las[NN]={};\nvoid col(int vis[],int x,int c){\n\tif(vis[x])return ;\n\tvis[x]=c;\n\tfor(int i=0;i<p[x].size();++i){\n\t\tcol(vis,p[x][i],c);\n\t}\n}\nvoid getvis(int x){\n\tfor(int i=1;i<=n;++i){\n\t\tfir[i]=las[i]=0;\n\t}\n\tfir[x]=las[x]=-1;\n\tfor(int j=0;j<p[x].size();++j){\n\t\tcol(fir,p[x][j],j+1);\n\t}\n\tfor(int j=p[x].size()-1;j>=0;--j){\n\t\tcol(las,p[x][j],j+1);\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tm=read();\n\tfor(int i=1;i<=m;++i){\n\t\tint x=read(),y=read();\n\t\tp[x].push_back(y);\n\t\trp[y].push_back(x);\n\t\tid[make_pair(x,y)]=i;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tgetvis(i);\n\t\tfor(int j=0;j<rp[i].size();++j){\n\t\t\tint cur=rp[i][j];\n\t\t\tbool fl=0;\n\t\t\tif(fir[cur])fl=1;\n\t\t\tans[id[make_pair(cur,i)]]^=fl;\n\t\t}\n\t\tfor(int j=0;j<p[i].size();++j){\n\t\t\tint cur=p[i][j];\n\t\t\tif(fir[cur]!=j+1||las[cur]!=j+1){\n\t\t\t\tans[id[make_pair(i,cur)]]^=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(ans[i])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint u[200005],v[200005];\nvector<int> to[1005];\nint c[1005][1005],*cnt,banv;\nint dfn[1005],low[1005],col[1005],stk[1005],top,t,cn;\nvoid dfs_scc(int x){\n\tdfn[x]=low[x]=++t;\n\tstk[++top]=x;\n\tfor(auto i:to[x])if(!dfn[i]){dfs_scc(i);chkmin(low[x],low[i]);}\n\telse if(!col[i])chkmin(low[x],dfn[i]);\n\tif(dfn[x]==low[x]){\n\t\tstk[top+1]=-1;\n\t\t++cn;\n\t\tfor(;stk[top+1]!=x;--top)col[stk[top]]=cn;\n\t}\n}\nint las[1005];\nvoid dfs(int x,int y){\n\tif(cnt[x]==2)return;\n\tif(cnt[x] && las[x]==y)return;\n\t++cnt[x];\n\tlas[x]=y;\n\tfor(auto i:to[x])if(i!=banv)dfs(i,y);\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint n,m;\n\tread(n,m);\n\tfor(int i=1;i<=m;++i){\n\t\tread(u[i],v[i]);\n\t\tto[u[i]].emplace_back(v[i]);\n\t}\n\tfor(int i=1;i<=n;++i)if(!dfn[i])dfs_scc(i);\n\tfor(int i=1;i<=n;++i){\n\t\tcnt=c[i];\n\t\tbanv=i;\n\t\tfor(auto j:to[i])dfs(j,j);\n\t}\n\tfor(int i=1;i<=m;++i)write((col[u[i]]==col[v[i]])!=(c[u[i]][v[i]]==2)?\"diff\\n\":\"same\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// #include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\n// using namespace __gnu_pbds;\n// using namespace __gnu_cxx;\n\ntypedef long long ll;\ntypedef unsigned int ul;\ntypedef unsigned long long ull;\ntypedef vector <int> vi;\ntypedef map<int, vector<int> > mvii;\ntypedef map<int, int> mii;\ntypedef queue <int> qi;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef vector<pair<int,int> > vpii;\n\n// Order Statistic Tree\n\n/* Special functions: \n\n\t\tfind_by_order(k) --> returns iterator to the kth largest element counting from 0\n\t\torder_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\n// typedef tree<\n// int,\n// null_type,\n// less<int>,\n// rb_tree_tag,\n// tree_order_statistics_node_update>\n// ordered_set;\n\n#define MP make_pair\n#define SORT(a) sort (a.begin(), a.end())\n#define REVERSE(a) reverse (a.begin(), a.end())\n#define ALL(a) a.begin(), a.end()\n#define PI acos(-1)\n#define ms(x,y) memset (x, y, sizeof (x))\n#define inf 1e9\n#define INF 1e16\n#define pb push_back\n#define MAX 1005\n#define debug(a,b) cout<<a<<\": \"<<b<<endl\n#define Debug cout<<\"Reached here\"<<endl\n#define prnt(a) cout<<a<<\"\\n\"\n#define mod 1000000007LL\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define FORr(i,a,b) for (int i=(a); i>=(b); i--)\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define lc ((node)<<1)\n#define rc ((node)<<1|1)\n#define VecPrnt(v) FOR(J,0,v.size()) cout<<v[J]<<\" \"; cout<<endl\n#define endl \"\\n\"\n#define PrintPair(x) cout<<x.first<<\" \"<<x.second<<endl\n#define EPS 1e-9\n#define ArrPrint(a,st,en) for(int J=st; J<=en; J++) cout<<a[J]<<\" \"; cout<<endl;\n\n/* Direction Array */\n\n// int fx[]={1,-1,0,0};\n// int fy[]={0,0,1,-1};\n// int fx[]={0,0,1,-1,-1,1,-1,1};\n// int fy[]={-1,1,0,0,1,1,-1,-1};\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    ll ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\ninline ll getnum()\n{\n    char c = getchar();\n    ll num,sign=1;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')sign=-1;\n    for(num=0;c>='0'&&c<='9';)\n    {\n        c-='0';\n        num = num*10+c;\n        c=getchar();\n    }\n    return num*sign;\n}\n\ninline ll power(ll a, ll b)\n{\n\tll multiply=1;\n\tFOR(i,0,b)\n\t{\n\t\tmultiply*=a;\n\t}\n\treturn multiply;\n}\n\n/****** END OF HEADER ******/\n\nint n, m;\nvi graph[MAX], ids[MAX];\nbool visited[MAX][MAX][2], reach[MAX][MAX];\nint way[MAX][MAX][2];\nstring ans[2*MAX];\n\nvoid dfs(int u, int beg, int id, bool fl)\n{\n\tif(visited[beg][u][fl]) return;\n\n\t// prnt(u);\n\n\tway[beg][u][fl]=id;\n\tvisited[beg][u][fl]=true;\n\n\tfor(auto v: graph[u])\n\t{\n\t\tif(v==beg) continue;\n\n\t\tdfs(v,beg,id,fl);\n\t}\n}\n\nvoid dfs(int u, int beg)\n{\n\tif(reach[beg][u]) return;\n\treach[beg][u]=true;\n\n\tfor(auto v: graph[u])\n\t{\n\t\tdfs(v,beg);\n\t}\n}\n\nvoid solve()\n{\n\tFOR(i,1,n+1)\n\t{\n\t\tdfs(i,i);\n\t}\n\n\t// Debug;\n\n\tFOR(i,1,n+1)\n\t{\n\t\t// prnt(graph[i][0]);\n\t\tFOR(j,0,graph[i].size())\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\tdfs(v,i,id,0);\n\t\t}\n\n\t\tFORr(j,(int)graph[i].size()-1,0)\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\tdfs(v,i,id,1);\n\t\t}\n\n\t\t// cout<<\"starting from vertex \"<<i<<endl;\n\n\t\t// FOR(j,0,graph[i].size())\n\t\t// {\n\t\t// \tint v=graph[i][j];\n\t\t// \tcout<<\"to go to vertex \"<<v<<\" using edge \"<<way[i][v][0]<<\" \"<<way[i][v][1]<<endl;\n\t\t// \tcout<<\"reaching from \"<<v<<\" to \"<<i<<\" is \"<<reach[v][i]<<endl;\n\t\t// }\n\n\t\tFOR(j,0,graph[i].size())\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\t// debug(\"v\",v);\n\n\t\t\tif(way[i][v][0]==way[i][v][1])\n\t\t\t{\n\t\t\t\tif(!reach[v][i]) ans[id]=\"same\";\n\t\t\t\telse ans[id]=\"diff\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(reach[v][i]) ans[id]=\"same\";\n\t\t\t\telse ans[id]=\"diff\";\n\t\t\t}\n\t\t}\n\t}\n\n\tFOR(i,0,m) printf(\"%s\\n\", ans[i].c_str());\n}\n\nint main()\n{\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(NULL); cout.tie(NULL);\n    // freopen(\"in.txt\",\"r\",stdin);\n\n    int test, cases=1;\n\n    scanf(\"%d%d\", &n, &m);\n\n    int u, v;\n\n    FOR(i,0,m)\n    {\n    \tscanf(\"%d%d\", &u, &v);\n    \tgraph[u].pb(v);\n    \tids[u].pb(i);\n    }\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\n\nvector <int> graph[1001];\n\nvoid addedge(int u,int v)\n{\n\tgraph[u].push_back(v);\n}\n\nint vis[1001][1001];\nstruct\n{\n\tint first,second;\n}edge[200001];\nint mark[1001];\nint times=1;\nint tmp;\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=times;\n\tfor(auto to:graph[now])\n\t{\n\t\tif(to==from)continue;\n\t\tif(vis[from][to]<2&&mark[to]!=times)\n\t\t{\n\t\t\tdfs(from,to);\n\t\t}\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i].first=from;\n\t\tedge[i].second=to;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto to:graph[i])\n\t\t{\n\t\t\tif(vis[i][to]<2)\n\t\t\t{\n\t\t\t\ttimes++;\n\t\t\t\tdfs(i,to);\n\t\t\t}\n\t\t}\n\t}\n\t//return 0;\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define p_b push_back\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 1010;\nint n, m;\nvector<int> e[N], id[N], _e[N], _id[N];\nint p[2][N]; bool w[N];\nbool ans[20010];\n\nvoid dfs(int u, int id, int o) {\n\tp[o][u] = id;\n\tfor(int i = 0; i < e[u].size(); ++i)\n\t\tif(!p[o][e[u][i]]) dfs(e[u][i], id, o);\n}\n\nvoid dfs2(int u) {\n\tw[u] = 1;\n\tfor(int i = 0; i < e[u].size(); ++i)\n\t\tif(!w[e[u][i]]) dfs2(e[u][i]);\n}\n\nint main() {\n\tint i, j, x, y;\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, 1, m) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\te[x].p_b(y); id[x].p_b(i);\n\t\t_e[y].p_b(x); _id[y].p_b(i);\n\t}\n\trep(i, 1, n) {\n\t\tmemset(p, 0, sizeof p);\n\t\tp[0][i] = p[1][i] = n+1;\n\t\tfor(j = 0; j < e[i].size(); ++j)\n\t\t\tif(!p[0][e[i][j]]) dfs(e[i][j], id[i][j], 0);\n\t\tfor(j = e[i].size()-1u; ~j; --j)\n\t\t\tif(!p[1][e[i][j]]) dfs(e[i][j], id[i][j], 1);\n//\t\trep(j, 1, n) printf(\"%d \", p[0][j]); puts(\"\");\n//\t\trep(j, 1, n) printf(\"%d \", p[1][j]); puts(\"\");\n\t\t\n\t\tfor(j = 0; j < e[i].size(); ++j)\n\t\tif(p[0][e[i][j]] != id[i][j] || p[1][e[i][j]] != id[i][j]) ans[id[i][j]] ^= 1;\n\t}\n\trep(i, 1, n) {\n\t\tmemset(w, 0, sizeof w);\n\t\tdfs2(i);\n\t\t\n\t\tfor(j = 0; j < _e[i].size(); ++j)\n\t\tif(w[_e[i][j]]) ans[_id[i][j]] ^= 1;\n\t}\n\trep(i, 1, m)\n\tif(ans[i]) puts(\"diff\"); else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1200\n#define M 300000\n\nint n,m,x[M],y[M],vis[2][N][N];\nvector<int> vec[N];\n\nvoid dfs(int op,int o,int u,int k){\n\tif (vis[op][o][u]) return;\n\tvis[op][o][u]=k;\n\tfor (int i=0;i<(int)vec[u].size();++i)\n\t\tdfs(op,o,vec[u][i],k);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;++i){scanf(\"%d%d\",&x[i],&y[i]); vec[x[i]].push_back(y[i]);}\n\tfor (int i=1;i<=n;++i){\n\t\tvis[0][i][i]=vis[1][i][i]=1;\n\t\tfor (int j=0;j<(int)vec[i].size();++j)\n\t\t\tdfs(0,i,vec[i][j],j+1);\n\t\tif (vec[i].size())\n\t\t\tfor (int j=(int)vec[i].size()-1;j>=0;--j)\n\t\t\t\tdfs(1,i,vec[i][j],j+1);\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tint u=x[i],v=y[i];\n\t\tputs((vis[0][u][v]!=vis[1][u][v])^(vis[0][v][u]>0)?\"diff\":\"same\");\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,id;\n}E[200005];\nint head[1005],sumE,M,N,a[200005],b[200005];\nbool reachable[1005][1005],mark[1005],a1[200005],a2[200005];\nvector<int> v;\nvoid add(int u,int v,int id) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].id = id;\n    head[u] = sumE;\n}\nvoid dfs(int id,int u) {\n    reachable[id][u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!reachable[id][v]) {\n\t    dfs(id,v);\n\t}\n    }\n}\nvoid dfs2(int u) {\n    if(mark[u]) return;\n    mark[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!mark[v]) dfs2(v);\n    }\n}\nvoid Solve() {\n    read(N);read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(a[i]);read(b[i]);\n\tadd(a[i],b[i],i);\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tdfs(i,i);\n    }\n    for(int u = 1 ; u <= N ; ++u) {\n\tv.clear();\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    v.pb(E[i].id);\n\t}\n\tmemset(mark,0,sizeof(mark));\n\tmark[u] = 1;\n\tint s = v.size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    dfs2(b[v[i]]);\n\t}\n\tmemset(mark,0,sizeof(mark));\n\tmark[u] = 1;\n\tfor(int i = s - 1 ; i >= 0 ; --i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    dfs2(b[v[i]]);\n\t}\n    }\n    for(int i = 1 ; i <= M ; ++i) {\n\tif(reachable[b[i]][a[i]]) a1[i] = 1;\n\tif(a1[i] ^ a2[i]) puts(\"diff\");\n\telse puts(\"same\");\n    }\n    \n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n,m;\nvvi in,G,rG,cost,out;\nsigned main(){\n\tcin>>n>>m;\n\tin=vvi(m);\n\tG=rG=vvi(n);\n\tcost=vvi(n,vi(n,inf));\n\trep(i,n)cost[i][i]=0;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tcost[a][b]=1;\n\t\tG[a].pb(b);\n\t\trG[b].pb(a);\n\t\tin[i]={a,b};\n\t}\n\tout=vvi(m,vi(2));\n\trep(k,n)rep(i,n)rep(j,n)\n\t\tcmin(cost[i][j],cost[i][k]+cost[k][j]);\n\trep(i,m)if(out[i][0]^out[i][1])cout<<\"diff\"<<endl;\n\telse cout<<\"same\"<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=1005,M=2e5+5;\nstruct eg{int v,nx;}e[M];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\nint ans[M];\nint dfn[N],low[N],st[N],col[N],tim,top,cnt,n,m;\nvoid tarjan(int u){\n\tdfn[u]=low[u]=++tim,st[++top]=u;\n\tgo(u)if(!dfn[v])tarjan(v),cmin(low[u],low[v]);\n\t\telse if(!col[v])cmin(low[u],dfn[v]);\n\tif(dfn[u]==low[u])\n\t\tfor(++cnt;st[top+1]!=u;--top)col[st[top]]=u;\n}\nint q[M<<3],fr[N],vis[N];\ninline int trs(R int &x,R int y){return x==y?0:(x=!x?y:1023,1);}\nvoid bfs(int rt){\n\tint h=1,t=0,u;\n\tfp(i,1,n)vis[i]=fr[i]=0;\n\tgo(rt)fr[v]=v,q[++t]=v,vis[v]=1;\n\twhile(h<=t){\n\t\tu=q[h++],vis[u]=0;\n\t\tgo(u)if(v!=rt&&trs(fr[v],fr[u])&&!vis[v])q[++t]=v,vis[v]=1;\n\t}\n\tgo(rt)ans[i]=(fr[v]==1023)^(col[rt]==col[v]);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin); \n\tscanf(\"%d%d\",&n,&m);\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v);\n\tfp(i,1,n)if(!dfn[i])tarjan(i);\n\tfp(i,1,n)bfs(i);\n\tfp(i,1,m)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#define PB push_back\nusing namespace std;\ntypedef vector<int> VI;\nconst int N=1010,M=200010;\nint n,m;\nint edge[M][2];\nVI e[N];\nvoid readData(){\n\tscanf(\"%d%d\",&n,&m);\n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[i][0]=u; edge[i][1]=v;\n\t\te[u].PB(v);\n\t}\n}\nint reach[2][N][N];\nvoid dfs(int u,int x,int id,int *arr){\n\tif(arr[u]!=-1)\n\t\treturn;\n\tarr[u]=id;\n\tfor(int i=0,sz=e[u].size();i<sz;i++)\n\t\tif(e[u][i]!=x)\n\t\t\tdfs(e[u][i],x,id,arr);\n}\nvoid calcReach(){\n\tmemset(reach,-1,sizeof reach);\n\tfor(int u=1;u<=n;u++){\n\t\tint sz=e[u].size();\n\t\tfor(int i=0;i<sz;i++)\n\t\t\tdfs(e[u][i],u,i,reach[0][u]);\n\t\tfor(int i=sz-1;i>=0;i--)\n\t\t\tdfs(e[u][i],u,i,reach[1][u]);\n\t}\n}\nvoid answer(){\n\tfor(int i=1;i<=m;i++){\n\t\tint u=edge[i][0],v=edge[i][1];\n\t\tif((reach[0][v][u]!=-1)^(e[u][reach[0][u][v]]!=v||e[u][reach[1][u][v]]!=v))\n\t\t\tputs(\"diff\");\n\t\telse\n\t\t\tputs(\"same\");\n\t}\n}\nint main(){\n\treadData();\n\tcalcReach();\n\tanswer();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nconst int N = 1e3+3;\n\n\nint cnt[N][N];\npair< int, int > edge[N*200];\nint n, m;\nvector<int> g[N];\n\n#define u first\n#define v second\n\nbool kappa[N][N];\n\nvoid dothething(int root) {\n\tvector< pair<int, int> > lel;\n\tqueue< pair<int, int> > q;\n\tint k = 0;\n\tfor (auto c : g[root]) {\n\t\tk++;\n\t\tq.push({c, k});\n\t\tlel.push_back({c, k});\n\t\tkappa[c][k] = 1;\n\t\tcnt[root][c] = 1;\n\t} \n\twhile (q.empty() == false) {\n\t\tint u = q.front().u;\n\t\tint e = q.front().v; q.pop();\n\t\tfor (auto v : g[u]) {\n\t\t\tif (v == root) continue;\n\t\t\tif (cnt[root][v] == 2) continue;\n\t\t\tif (!kappa[v][e]) {\n\t\t\t\tlel.push_back({v, e});\n\t\t\t\tkappa[v][e] = 1;\n\t\t\t\tcnt[root][v]++;\n\t\t\t\tq.push({v, e});\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : lel) {\n\t\tkappa[i.u][i.v] = 0;\n\t}\n}\n\nsigned main() {\n\tmemset(cnt, 0, sizeof(cnt));\n\tmemset(kappa, 0, sizeof(kappa));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &edge[i].u, &edge[i].v);\n\t\tg[edge[i].u].push_back(edge[i].v);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tdothething(i);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\t// cout << cnt[edge[i].u][edge[i].v] << '\\n';\n\t\tif (cnt[edge[i].u][edge[i].v] == 1) {\n\t\t\tif (cnt[edge[i].v][edge[i].u] >= 1) {\n\t\t\t\tcout << \"diff\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"same\\n\";\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\tif (cnt[edge[i].v][edge[i].u] >= 1) {\n\t\t\t\tcout << \"same\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"diff\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=1010;\nconst int M=2e5+10;\nstruct node{\n    int next,to,id;\n}e[M<<1];\nint head[N],cnt;\ninline void add(int u,int v,int id){\n    e[cnt].id=id;e[cnt].to=v;e[cnt].next=head[u];head[u]=cnt++;\n}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(p[frm][v]) continue;\n\tif(v==frm) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(q[frm][v]||v==frm) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[M];\nint main(){\n    mst(head,-1);n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n    }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    //rep(i,1,n) {rep(j,1,n) cerr<<rea[i][j]<<\" \";pts;}\n    rep(x,1,n){\n\t//dbg(x);\n\tvector<int> fk;\n\trpp(i,x,e,head){\n\t    fk.push_back(i);\n\t    col=e[i].id;\n\t    int v=e[i].to;if(p[x][v]) continue;\n\t    dfs2(v,x);\n\t}\n\treverse(fk.begin(),fk.end());\n\tfor(auto i:fk){\n\t    //dbg(e[i].id);\n\t    col=e[i].id;\n\t    int v=e[i].to;if(q[x][v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    //rep(i,1,n){rep(j,1,n) cerr<<p[i][j]<<\" \";pts;}\n    //rep(i,1,n){rep(j,1,n) cerr<<q[i][j]<<\" \";pts;}\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];//dbg(k);\n\t//dbg(p[u][v]);dbg(q[u][v]);\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\t//dbg(k);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020, M = 403000, inf = 0x3f3f3f3f;\nint n,m,head[N],nxt[M],to[M],edgenum,a[M],b[M],d[N],mx[N],res[M];Vi e[N];\nvoid add(int u, int v){\n\tto[++edgenum]=v;nxt[edgenum]=head[u];head[u]=edgenum;\n}\ninline void dfs(int u, int *d){\n\tL(i,u)if(d[to[i]]==inf)d[to[i]]=d[u],dfs(to[i],d);\n}\nint main() {\n\tread(n);read(m);rep(i,1,m)read(a[i]),read(b[i]),add(a[i],b[i]),e[b[i]].pb(i);\n\trep(u,1,n){\n\t//\tint f=1,r=1;\n\t\tmemset(d,inf,4*(n+2));memset(mx,inf,4*(n+2));\n\t//\tL(i,u)q[r++]=to[i];\n\t\td[u]=mx[u]=0;\n\t\t/*while(f!=r){\n\t\t\tint u=q[f++];\n\t\t\tL(i,u)if(d[to[i]]>d[u]||mx[to[i]]<mx[u])\n\t\t\t\tmx[to[i]]=mx[u],d[to[i]]=d[u],q[r++]=to[i];\n\t\t}*/\n\t\tstatic int s[N];int len=0;L(i,u)s[++len]=to[i];\n\t\trep(i,1,len)if(d[s[i]]==inf)d[s[i]]=s[i],dfs(s[i],d);\n\t\tper(i,len,1)if(mx[s[i]]==inf)mx[s[i]]=s[i],dfs(s[i],mx);\n\t\tL(i,u)res[i]^=d[to[i]]!=to[i]||mx[to[i]]!=to[i];\n\t\tper(i,SZ(e[u])-1,0)res[e[u][i]]^=d[a[e[u][i]]]<inf;\n\t}\n\trep(i,1,m)printf(\"%s\\n\",res[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n \nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[M] , B[M];\nint stk[N] , top;\nint ans[M];\nint L[N][N], R[N][N];\n\nvoid add(int x, int y) {\n\tne[++ cnt] = fir[x];\n\tfir[x] = cnt;\n\tto[cnt] = y;\n}\n\nbool can[N][N];\n\nqueue <int> q;\n\nvector <int> son[N];\n\n#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\nvoid solve(int x) {\n\twhile(!q.empty()) q.pop();\n\tq.push(x);\n\twhile(!q.empty()) {\n\t\tint ind = q.front();\n\t\tcan[x][ind] = 1;\n\t\tq.pop();\n\t\tForeachson(i, ind) {\n\t\t\tint V = to[i];\n\t\t\tif(can[x][V]) continue;\n\t\t\tq.push(V);\n\t\t}\n\t}\n\t\n\tForeachson(i, x) {\n\t\tint V = to[i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!L[x][V]) {\n\t\t\tq.push(V);\n\t\t\tL[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tForeachson(j, ind) {\n\t\t\t\tint v = to[j];\n\t\t\t\tif(!L[x][v] && v != x) {\n\t\t\t\t\tL[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < (int) son[x].size(); ++ i) {\n\t\tint V = son[x][i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!R[x][V]) {\n\t\t\tq.push(V);\n\t\t\tR[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int j = 0; j < (int) son[ind].size(); ++ j) {\n\t\t\t\tint v = son[ind][j];\n\t\t\t\tif(!R[x][v] && v != x) {\n\t\t\t\t\tR[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x, y);\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tForeachson(j, i) {\n\t\t\tint V = to[j];\n\t\t\tson[i].push_back(V);\n\t\t}\n\t\treverse(son[i].begin(), son[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tsolve(i);\n\t}\n\t\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(L[A[i]][B[i]] != B[i] || R[A[i]][B[i]] != B[i]) {\n\t\t\tif(!can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\telse {\n\t\t\tif(can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define N 1005\n#define M 200005\nusing namespace std;\nint read(){\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tcontinue;\n\t}\n\tint num=c^48;\n\tc=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tnum=num*10+(c^48);\n\t\tc=getchar();\n\t}\n\treturn num;\n}\nvector<int> edge[N];\nint p1[N][N];\nvoid dfs1(int now,int p){\n\tfor(vector<int>::iterator it=edge[now].begin();it!=edge[now].end();++it){\n\t\tint v=*it;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=p1[p][now];\n\t\tdfs1(v,p);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p){\n\tfor(vector<int>::iterator it=edge[now].begin();it!=edge[now].end();++it){\n\t\tint v=*it;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=p2[p][now];\n\t\tdfs2(v,p);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tn=read();\n\tm=read();\n\tfor(int i=0;i<m;++i){\n\t\tu[i]=read();\n\t\tv[i]=read();\n\t\tedge[u[i]].push_back(v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tp1[i][i]=i;\n\t\tfor(vector<int>::iterator it=edge[i].begin();it!=edge[i].end();++it){\n\t\t\tint v=*it;\n\t\t\tif(p1[i][v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp1[i][v]=v;\n\t\t\tdfs1(v,i);\n\t\t}\n\t\tp2[i][i]=i;\n\t\tif(edge[i].begin()==edge[i].end()){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(vector<int>::iterator it=--edge[i].end();;--it){\n\t\t\tint v=*it;\n\t\t\tif(p2[i][v]){\n\t\t\t\tif(it==edge[i].begin()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp2[i][v]=v;\n\t\t\tdfs2(v,i);\n\t\t\tif(it==edge[i].begin()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int maxn = 1005, maxm = 200005;\n\nint n, m, num[maxn][maxn];\nbool go[maxn][maxn], go2[maxn][maxn];\n\npii p[maxm];\n\nvector<int> G[maxn];\n\nbool vis[maxn];\nint vis2[maxn], vis3[maxn];\n\nvoid dfs1(int x, int rt)\n{\n\tvis[x] = 1;\n\tif(x != rt)\n\t\tgo[rt][x] = 1;\n\tint id;\t\n\tfor(int i = 0; i < (int)G[x].size(); ++i)\n\t{\n\t\tid = G[x][i];\n\t\tif(vis[id])\tcontinue;\n\t\tdfs1(id, rt);\n\t}\n}\n\nvoid dfs2(int x)\n{\n\tint id;\n\tfor(int i = 0; i < (int)G[x].size(); ++i)\n\t{\n\t\tid = G[x][i];\n\t\tif(vis2[id])\tcontinue;\n\t\tvis2[id] = num[x][id];\n\t\tdfs2(id);\n\t}\n}\n\nvoid dfs3(int x)\n{\n\tint id;\n\tfor(int i = (int)G[x].size() - 1; i >= 0; --i)\n\t{\n\t\tid = G[x][i];\n\t\tif(vis3[id])\tcontinue;\n\t\tvis3[id] = num[x][id];\n\t\tdfs3(id);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tint u, v;\t\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tG[u].push_back(v);\n\t\tnum[u][v] = i;\n\t\tp[i] = make_pair(u, v);\n\t}\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tdfs1(i, i);\n\t\tvis2[i] = vis3[i] = -1;\t\n\t\tdfs2(i);\n\t\tdfs3(i);\n\t\tint id;\n\t\tfor(int j = 0; j < (int)G[i].size(); ++j)\n\t\t{\n\t\t\tid = G[i][j];\n\t\t\tif(vis2[id] != num[i][id] || vis3[id] != num[i][id])\n\t\t\t{\n\t\t\t\tgo2[i][id] = 1;\n\t\t\t}\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tmemset(vis3, 0, sizeof(vis3));\n\t}\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tu = p[i].first;\n\t\tv = p[i].second;\n\t\tprintf(\"%s\\n\", (go[v][u] && !go2[u][v]) || (!go[v][u] && go2[u][v])? \"diff\": \"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nvector<int> e[1010];\nint vis[1010],h[1010][1010][2],u[201000],v[201000],n,m;\nvoid dfs(int x,int p,int flag){\n\tvis[x]=1;\n\tfor(int v:e[x]) if(!vis[v]){\n\t\th[p][v][flag]=x;\n\t\tdfs(v,p,flag);\n\t}\n}\nint main(){\n\tread(n);read(m);\n\tfor(int i=1;i<=m;i++){\n\t\tread(u[i]);read(v[i]);\n\t\te[u[i]].push_back(v[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(i,i,0);\n\t\treverse(e[i].begin(),e[i].end());\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(i,i,1);\n\t\treverse(e[i].begin(),e[i].end());\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint flag=1;\n\t\tif(h[v[i]][u[i]][0]) flag^=1;\n\t\tif(h[u[i]][v[i]][0]!=u[i]||h[u[i]][v[i]][1]!=u[i]) flag^=1;\n\t\tif(flag) puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint chA[200005], chB[200005];\nvector<int> ch[1005];\nbool two[1005][1005];\nbool care[1005];\nint sccid[1005];\nbool ons[1005];\nint vis[1005];\nint idx[1005];\nvector<int> S;\nint lo[1005];\nint n, m;\n\nvoid dfs1(int at, int fr, int via)\n{\n\tif (care[at] && via != at) two[fr][at] = true;\n\tif (vis[at] == -1) vis[at] = via;\n\telse if (vis[at] == -2) return;\n\telse if (vis[at] == via) return;\n\telse vis[at] = -2;\n\tfor (int u: ch[at]) dfs1(u, fr, via);\n}\n\nint dfs2(int at)\n{\n\tstatic int Y, Z;\n\tidx[at] = lo[at] = ++Z;\n\tS.push_back(at); ons[at] = true;\n\tfor (int u: ch[at])\n\t\tif (!idx[u]) lo[at] = min(lo[at], dfs2(u));\n\t\telse if (ons[u]) lo[at] = min(lo[at], idx[u]);\n\tif (idx[at] == lo[at])\n\t{\n\t\tY++;\n\t\twhile (true)\n\t\t{\n\t\t\tint u = S.back(); S.pop_back();\n\t\t\tons[u] = false;\n\t\t\tsccid[u] = Y;\n\t\t\tif (u == at) break;\n\t\t}\n\t}\n\treturn lo[at];\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0;i < m;i++)\n\t{\n\t\tscanf(\"%d%d\", chA+i, chB+i);\n\t\tch[--chA[i]].push_back(--chB[i]);\n\t}\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tfor (int u: ch[i]) care[u] = true;\n\t\tfor (int j = 0;j < n;j++) vis[j] = -1;\n\t\tvis[i] = -2;\n\t\tfor (int u: ch[i]) dfs1(u, i, u);\n\t\tfor (int u: ch[i]) care[u] = false;\n\t}\n\tfor (int i = 0;i < n;i++) if (!idx[i]) dfs2(i);\n\tfor (int i = 0;i < m;i++) printf(\"%s\\n\", ((sccid[chA[i]] == sccid[chB[i]]) == (two[chA[i]][chB[i]]))?\"same\":\"diff\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e3 + 10,M = 2e5 + 10;\n\nstruct node {\n\tint x,y;\n}G[M];\nint to[M],nex[M],beg[N],cnt[N][N],vis[N];\nvector <int> Graph[N];\nint e,n,m;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\nvoid dfs(int St,int cur,int To) {\n\tif(St == cur || vis[cur] == To || cnt[St][cur] >= 2) return;\n\tif(++cnt[St][cur] == 1) vis[cur] = To;\n\tFor(i,0,Graph[cur].size() - 1) dfs(St,Graph[cur][i],To);\n}\n\nint main() {\n\tn = read(),m = read();\n\tFor(i,1,m) {\n\t\tint x = read(),y = read();\n\t\tG[i] = (node){x,y};\n\t\tGraph[x].push_back(y);\n\t}\n\n\tFor(i,1,n) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tFor(j,0,Graph[i].size() - 1) dfs(i,Graph[i][j],Graph[i][j]);\n\t}\n\n\tFor(i,1,m) {\n\t\tif((cnt[G[i].x][G[i].y] >= 2) ^ (cnt[G[i].y][G[i].x] >= 1)) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <vector>\ntypedef long long lint;\nconst int N=1005;\nconst int M=2e5+5;\nint n,m;\nbool irp[N][N],lnk[N][N];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nnamespace G{\n\tint rt,cnt,fir[N];\n\tbool col[N];\n\tstd::vector <int> g[N];\n\tstruct edge{\n\t\tint fr,to;\n\t}eg[M];\n\n\tinline void add(const int a,const int b){\n\t\tg[a].push_back(b);\n\t\teg[++cnt]=(edge){a,b};\n\t}\n\n\tvoid dfs(const int x){\n\t\tcol[x]=lnk[rt][x]=1;\n\t\tfor(std::vector <int> ::iterator it=g[x].begin(); it!=g[x].end(); ++it){\n\t\t\tif(!col[*it]) dfs(*it);\n\t\t}\n\t}\n\n\tvoid set(const int x){\n\t\trt=x;\n\t\tmemset(col+1,0,n*sizeof(col[0]));\n\t\tcol[x]=1;\n\t\tfor(std::vector <int> ::iterator it=g[x].begin(); it!=g[x].end(); ++it){\n\t\t\tif(col[*it]) irp[x][*it]=1;\n\t\t\telse dfs(*it);\n\t\t}\n\t\tstd::reverse(g[x].begin(),g[x].end());\n\t\tmemset(col+1,0,n*sizeof(col[0]));\n\t\tcol[x]=1;\n\t\tfor(std::vector <int> ::iterator it=g[x].begin(); it!=g[x].end(); ++it){\n\t\t\tif(col[*it]) irp[x][*it]=1;\n\t\t\telse dfs(*it);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=nxi(),m=nxi();\n\tfor(int i=1; i<=m; ++i){\n\t\tconst int a=nxi(),b=nxi();\n\t\tG::add(a,b);\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tG::set(i);\n\t}\n\tfor(int i=1; i<=m; ++i){\n\t\tint x=G::eg[i].fr,y=G::eg[i].to;\n\t\tputs(irp[x][y]^lnk[y][x]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxm 200010\n#define maxn 1010\nusing namespace std;\ntypedef long long LL;\nstruct Edge {\n    int from, to, ne;\n}edge[maxm];\nint head[maxn], ne[maxm], pre[maxm], T, tot;\nbool flag[maxn][maxn];\nint f1[maxn][maxn], f2[maxn][maxn], vis[maxn];\nvoid add(int u, int v) {\n    if (~ne[u]) pre[ne[u]] = tot;\n    else head[u] = tot;\n    edge[tot] = {u, v, ne[u]};\n    ne[u] = tot++;\n}\nvoid dfs1(int src, int u) {\n    flag[src][u] = true; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v] != T) dfs1(src, v);\n    }\n}\nvoid dfs2(int src, int exc, int u, int f[maxn][maxn]) {\n    if (f[exc][u]==-1) f[exc][u] = src; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v]!=T && v!=exc) dfs2(src, exc, v, f);\n    }\n}\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    int n, m;\n    memset(ne, -1, sizeof ne);\n    memset(head, -1, sizeof head);\n    memset(f1, -1, sizeof f1);\n    memset(f2, -1, sizeof f2);\n    scanf(\"%d%d\", &n, &m);\n    F(i, 0, m) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u, v);\n    }\n//    F2(i, 1, n) printf(\"%d\\n\", head[i]);\n//    F(i, 0, m) printf(\"%d\\n\", pre[i]);\n    F2(i, 1, n) {\n        ++T; dfs1(i, i);\n    }\n    F2(i, 1, n) {\n        for (int j = ne[i]; ~j; j = edge[j].ne) {\n            ++T; dfs2(j, i, edge[j].to, f1);\n        }\n        if (head[i]==-1) continue;\n        for (int j = head[i]; ; j = pre[j]) {\n//            printf(\"dfs2 : %d %d\\n\", i, j);\n            ++T; dfs2(j, i, edge[j].to, f2);\n            if (j==ne[i]) break;\n        }\n    }\n\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", flag[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f1[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f2[i][j]); puts(\"\");\n//    }\n    F(i, 0, m) {\n        int u=edge[i].from, v=edge[i].to;\n        if (flag[v][u] ^ (f1[u][v]!=i||f2[u][v]!=i)) puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint a[200000];\nint b[200000];\nint c[1000][1000][2];\nint f[1000];\nvector <pair<int, int>> v[1000];\n\nvoid dfs(int x, int y, int z, int w) {\n    int i;\n    \n    f[x] = 1;\n    c[y][x][z] = w;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        int nx = v[x][i].first;\n        \n        if (f[nx] == 0) dfs(nx, y, z, w);\n    }\n}\n\nvoid check(int x) {\n    int i, j;\n    \n    for (i = 0; i < n; i++) {\n        c[x][i][0] = 1e9;\n        c[x][i][1] = -1e9;\n    }\n    \n    for (i = 0; i < n; i++) f[i] = 0;\n    f[x] = 1;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        int nx = v[x][i].first;\n        \n        if (f[nx] == 0) dfs(nx, x, 0, v[x][i].second);\n    }\n    \n    for (i = 0; i < n; i++) f[i] = 0;\n    f[x] = 1;\n    \n    reverse(v[x].begin(), v[x].end());\n    for (i = 0; i < v[x].size(); i++) {\n        int nx = v[x][i].first;\n        \n        if (f[nx] == 0) dfs(nx, x, 1, v[x][i].second);\n    }\n}\n\nint main() {\n    int m, i, j;\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    for (i = 0; i < m; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n        \n        a[i]--;\n        b[i]--;\n        \n        v[a[i]].push_back(make_pair(b[i], i));\n    }\n    \n    for (i = 0; i < n; i++) check(i);\n    \n    for (i = 0; i < m; i++) {\n        int x = a[i], y = b[i];\n        int f1 = 0, f2 = 0;\n        \n        if (c[x][y][0] < i || c[x][y][1] > i) f1 = 1;\n        if (c[y][x][1] >= 0) f2 = 1;\n        \n        if (f1 ^ f2) {\n            puts(\"diff\");\n        } else {\n            puts(\"same\");\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n \nvector<int> e[1010];\nint n, m;\n \nint fr[200010];\nint to[200010];\nchar gyaku[200010];\n \nbitset<1001> reach[1001], todo;\nqueue<int> q;\n \nvoid F(int x){\n\ttodo.reset();\n\tauto& v = e[x];\n\tint s = v.size();\n\tfor(int i=0; i<s; ++i){\n\t\tint y = to[v[i]];\n\t\tif(todo[y]){\n\t\t\tgyaku[v[i]] = 1;\n\t\t} else {\n\t\t\tq.push(y);\n\t\t\ttodo[y]=1;\n\t\t\twhile(q.size()){\n\t\t\t\tint a=q.front(); q.pop();\n\t\t\t\tfor(int ei:e[a]){\n\t\t\t\t\tint b=to[ei];\n\t\t\t\t\tif(b == x || todo[b]) continue;\n\t\t\t\t\ttodo[b]=1; q.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treach[x] = todo;\n\ttodo.reset();\n\tfor(int i=s-1; 0<=i; --i){\n\t\tint y = to[v[i]];\n\t\tif(todo[y]){\n\t\t\tgyaku[v[i]] = 1;\n\t\t} else {\n\t\t\tq.push(y);\n\t\t\ttodo[y]=1;\n\t\t\twhile(q.size()){\n\t\t\t\tint a=q.front(); q.pop();\n\t\t\t\tfor(int ei:e[a]){\n\t\t\t\t\tint b=to[ei];\n\t\t\t\t\tif(b == x || todo[b]) continue;\n\t\t\t\t\ttodo[b]=1; q.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n \nint main()\n{\n\tread(n, m);\n\tfor(int i=1; i<=m; ++i){\n\t\tint a, b; read(a, b);\n\t\tfr[i] = a; to[i] = b;\n\t\te[a].pb(i);\n\t}\n\tfor(int i=1; i<=n; ++i) F(i);\n\t\n\tfor(int i=1; i<=m; ++i){\n\t\tif(gyaku[i] != reach[to[i]][fr[i]]){\n\t\t\tputs(\"diff\");\n\t\t} else {\n\t\t\tputs(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e3+7,maxm=2e5+7;\nint c[2][maxn][maxn];\nvector<int> G[maxn];\nint a[maxm],b[maxm];\nvoid dfs(int x,int st,int ptr,bool typ){\n\tif(!c[typ][st][x]) c[typ][st][x]=ptr;else return ;//cout<<st<<' '<<x<<endl;\n\tfor(int y:G[x]) if(!c[typ][st][y]) dfs(y,st,ptr,typ);\n}\nint main(){\n\tint n,m;cin>>n>>m;\n\tfor(int i=1;i<=m;++i) scanf(\"%d%d\",&a[i],&b[i]),G[a[i]].push_back(b[i]);\n\tfor(int x=1;x<=n;++x) {\n\t\tc[0][x][x]=c[1][x][x]=1;\n\t\tfor(auto y:G[x]) dfs(y,x,y,0);\n\t\treverse(G[x].begin(),G[x].end());\n\t\tfor(auto y:G[x]) dfs(y,x,y,1);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tbool flag=(c[0][b[i]][a[i]]>0);//cout<<flag<<endl;\n\t\tif(c[0][a[i]][b[i]]!=c[1][a[i]][b[i]]) flag^=1;//cout<<c[0][3][4]<<' '<<c[1][3][4]<<' '<<a[i]<<' '<<b[i]<<endl;\n\t\tif(flag) puts(\"diff\");else puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=200010;\nint n,m;\nint rx[N],ry[N];\nvector<int> vec[N],id[N];\nbool vis[N][N],bo[N][N],ans[M];\ninline void dfs1(int x,int y)\n{\n    vis[y][x]=true;\n    for(int k=0;k<vec[x].size();k++)\n    {\n        int to=vec[x][k];\n        if(vis[y][to]) continue;\n        dfs1(to,y);\n    }\n    return;\n}\ninline void dfs2(int x,int y)\n{\n    rx[x]=y;\n    for(int k=0;k<vec[x].size();k++)\n    {\n        int to=vec[x][k];\n        if(rx[to]) continue;\n        dfs2(to,y);\n    }\n    return;\n}\nint main()\n{\n//    freopen(\"1.in\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for(int k=1;k<=m;k++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        vec[x].push_back(y);\n        id[x].push_back(k);\n    }\n    for(int k=1;k<=n;k++)\n        dfs1(k,k);\n    for(int k=1;k<=n;k++)\n    {\n        memset(rx,0,sizeof rx);\n        memset(ry,0,sizeof ry);\n        rx[k]=1;\n        for(int i=0;i<vec[k].size();i++)\n        {\n            int to=vec[k][i];\n            if(rx[to]) continue;\n            dfs2(to,id[k][i]);\n        }\n        for(int i=1;i<=n;i++)\n            swap(rx[i],ry[i]);\n        rx[k]=1;\n        for(int i=vec[k].size()-1;i>=0;i--)\n        {\n            int to=vec[k][i];\n            if(rx[to]) continue;\n            dfs2(to,id[k][i]);\n        }\n        for(int i=0;i<vec[k].size();i++)\n        {\n            int to=vec[k][i];\n            if(rx[to]^ry[to]) bo[k][to]=1;\n        }\n    }\n    for(int k=1;k<=n;k++)\n    {\n        for(int i=0;i<vec[k].size();i++)\n        {\n            int to=vec[k][i];\n//            cout<<k<<\" \"<<to<<\" \"<<vis[to][k]<<\" \"<<vis[k][to]<<\" \"<<bo[k][to]<<endl;\n            if(vis[to][k]&&bo[k][to]==0) ans[id[k][i]]=1;\n            if(vis[to][k]==0&&bo[k][to]) ans[id[k][i]]=1;\n        }\n    }\n    for(int k=1;k<=m;k++)\n    {\n        if(ans[k]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nstruct eg{int to;eg*nx;}e[200100],*la[1010],*cnt=e;\nint ans[200100],fr[1010][1010],tg[1010][1010],sta[1010],ta,I;\ninline void addE(re int a,re int b)\n{\n\t*++cnt=(eg){b,la[a]};la[a]=cnt;\n}\nvoid dfs(re int a,re int*ff)\n{\n\tfor(re eg*i=la[a];i;i=i->nx)if(!ff[i->to])\n\t{\n\t\tff[i->to]=ff[a];dfs(i->to,ff);\n\t}\n}\nint main()\n{\n\tre int n,m,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re int i=1;i<=m;i++)scanf(\"%d%d\",&x,&y),addE(x,y);\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfr[I][I]=tg[I][I]=-1;\n\t\tfor(re eg*i=la[I];i;i=i->nx)\n\t\t{\n\t\t\tsta[++ta]=i->to;if(!fr[I][i->to])\n\t\t\t{\n\t\t\t\tfr[I][i->to]=i->to;dfs(i->to,fr[I]);\n\t\t\t}\n\t\t}\n\t\tfor(;ta;ta--)if(!tg[I][sta[ta]])\n\t\t{//printf(\"*t*%d %d\\n\",I,sta[ta]);\n\t\t\ttg[I][sta[ta]]=sta[ta];dfs(sta[ta],tg[I]);\n\t\t}\n\t}\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfor(re eg*i=la[I];i;i=i->nx)if(i->to==I)ans[i-e]=1;\n\t\telse{printf(\"**%d %d %d\\n\",I,i->to,tg[I][i->to]);\n\t\t\tans[i-e]=(fr[I][i->to]==i->to&&tg[I][i->to]==i->to)==(fr[i->to][I]==0);\n\t\t}\n\t}\n\tfor(re int i=1;i<=m;i++)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// #include <ext/pb_ds/detail/standard_policies.hpp>\n\nusing namespace std;\n// using namespace __gnu_pbds;\n// using namespace __gnu_cxx;\n\ntypedef long long ll;\ntypedef unsigned int ul;\ntypedef unsigned long long ull;\ntypedef vector <int> vi;\ntypedef map<int, vector<int> > mvii;\ntypedef map<int, int> mii;\ntypedef queue <int> qi;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef vector<pair<int,int> > vpii;\n\n// Order Statistic Tree\n\n/* Special functions: \n\n\t\tfind_by_order(k) --> returns iterator to the kth largest element counting from 0\n\t\torder_of_key(val) --> returns the number of items in a set that are strictly smaller than our item\n*/\n\n// typedef tree<\n// int,\n// null_type,\n// less<int>,\n// rb_tree_tag,\n// tree_order_statistics_node_update>\n// ordered_set;\n\n#define MP make_pair\n#define SORT(a) sort (a.begin(), a.end())\n#define REVERSE(a) reverse (a.begin(), a.end())\n#define ALL(a) a.begin(), a.end()\n#define PI acos(-1)\n#define ms(x,y) memset (x, y, sizeof (x))\n#define inf 1e9\n#define INF 1e16\n#define pb push_back\n#define MAX 1005\n#define debug(a,b) cout<<a<<\": \"<<b<<endl\n#define Debug cout<<\"Reached here\"<<endl\n#define prnt(a) cout<<a<<\"\\n\"\n#define mod 1000000007LL\n#define FOR(i,a,b) for (int i=(a); i<(b); i++)\n#define FORr(i,a,b) for (int i=(a); i>=(b); i--)\n#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define lc ((node)<<1)\n#define rc ((node)<<1|1)\n#define VecPrnt(v) FOR(J,0,v.size()) cout<<v[J]<<\" \"; cout<<endl\n#define endl \"\\n\"\n#define PrintPair(x) cout<<x.first<<\" \"<<x.second<<endl\n#define EPS 1e-9\n#define ArrPrint(a,st,en) for(int J=st; J<=en; J++) cout<<a[J]<<\" \"; cout<<endl;\n\n/* Direction Array */\n\n// int fx[]={1,-1,0,0};\n// int fy[]={0,0,1,-1};\n// int fx[]={0,0,1,-1,-1,1,-1,1};\n// int fy[]={-1,1,0,0,1,1,-1,-1};\n\ntemplate <class T> inline T bigmod(T p,T e,T M)\n{\n    ll ret = 1;\n    for(; e > 0; e >>= 1)\n    {\n        if(e & 1) ret = (ret * p) % M;\n        p = (p * p) % M;\n    } return (T)ret;\n}\n\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}\ntemplate <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}\ntemplate <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}\ntemplate <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }\ntemplate <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}\n\ninline ll getnum()\n{\n    char c = getchar();\n    ll num,sign=1;\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')sign=-1;\n    for(num=0;c>='0'&&c<='9';)\n    {\n        c-='0';\n        num = num*10+c;\n        c=getchar();\n    }\n    return num*sign;\n}\n\ninline ll power(ll a, ll b)\n{\n\tll multiply=1;\n\tFOR(i,0,b)\n\t{\n\t\tmultiply*=a;\n\t}\n\treturn multiply;\n}\n\n/****** END OF HEADER ******/\n\nint n, m;\nvi graph[MAX], ids[MAX];\nbool visited[MAX][MAX][2], reach[MAX][MAX];\nint way[MAX][MAX][2];\nstring ans[2*MAX];\n\nvoid dfs(int u, int beg, int id, bool fl)\n{\n\tif(visited[beg][u][fl]) return;\n\n\t// prnt(u);\n\n\tway[beg][u][fl]=id;\n\tvisited[beg][u][fl]=true;\n\n\tfor(auto v: graph[u])\n\t{\n\t\tif(v==beg) continue;\n\n\t\tdfs(v,beg,id,fl);\n\t}\n}\n\nvoid dfs(int u, int beg)\n{\n\tif(reach[beg][u]) return;\n\treach[beg][u]=true;\n\n\tfor(auto v: graph[u])\n\t{\n\t\tdfs(v,beg);\n\t}\n}\n\nvoid solve()\n{\n\tFOR(i,1,n+1)\n\t{\n\t\tdfs(i,i);\n\t}\n\n\t// Debug;\n\n\tFOR(i,1,n+1)\n\t{\n\t\t// prnt(graph[i][0]);\n\t\tFOR(j,0,graph[i].size())\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\tdfs(v,i,id,0);\n\t\t}\n\n\t\tFORr(j,(int)graph[i].size()-1,0)\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\tdfs(v,i,id,1);\n\t\t}\n\n\t\t// cout<<\"starting from vertex \"<<i<<endl;\n\n\t\t// FOR(j,0,graph[i].size())\n\t\t// {\n\t\t// \tint v=graph[i][j];\n\t\t// \tcout<<\"to go to vertex \"<<v<<\" using edge \"<<way[i][v][0]<<\" \"<<way[i][v][1]<<endl;\n\t\t// \tcout<<\"reaching from \"<<v<<\" to \"<<i<<\" is \"<<reach[v][i]<<endl;\n\t\t// }\n\n\t\tFOR(j,0,graph[i].size())\n\t\t{\n\t\t\tint v=graph[i][j];\n\t\t\tint id=ids[i][j];\n\n\t\t\t// debug(\"v\",v);\n\n\t\t\tif(way[i][v][0]==way[i][v][1])\n\t\t\t{\n\t\t\t\tif(!reach[v][i]) ans[id]=\"same\";\n\t\t\t\telse ans[id]=\"diff\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(reach[v][i]) ans[id]=\"same\";\n\t\t\t\telse ans[id]=\"diff\";\n\t\t\t}\n\t\t}\n\t}\n\n\tFOR(i,0,m) printf(\"%s\\n\", ans[i].c_str());\n}\n\nint main()\n{\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(NULL); cout.tie(NULL);\n    // freopen(\"in.txt\",\"r\",stdin);\n\n    int test, cases=1;\n\n    scanf(\"%d%d\", &n, &m);\n\n    int u, v;\n\n    FOR(i,0,m)\n    {\n    \tscanf(\"%d%d\", &u, &v);\n    \tgraph[u].pb(v);\n    \tids[u].pb(i);\n    }\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e3+20;\n\nstruct node {\n\tint v,next;\n};\nnode e[200020];\nint cnt,start[maxn];\ninline void addedge(int u,int v){ e[++cnt]=(node){v,start[u]};start[u]=cnt;}\n\nint n,m;\nint f[maxn][maxn];\nint rt,D;\nint g[maxn][maxn];\nint vis[maxn];\nint A[maxn],B[maxn];\nint graph[maxn][maxn];\n\nvoid dfs(int u)\n{\n\tf[rt][u]=1;\n\tEREP(i,u)\n\t{\n\t\tint v=e[i].v;\n\t\tif(f[rt][v])continue;\n\t\tdfs(v);\n\t}\n}\n\nstruct Edge {\n\tint u,v;\n};\nEdge E[200020];\n\nvoid dfs1(int u)\n{\n\tvis[u]=D;\n\tEREP(i,u)\n\t{\n\t\tint v=e[i].v;\n\t\tif(vis[v])continue;\n\t\tdfs1(v);\n\t}\n}\n\ninline void init()\n{\n\tn=read(); m=read();\n\tREP(i,1,m)\n\t{\n\t\tint u=read(),v=read();\n\t\tE[i]=(Edge){u,v};\n\t\taddedge(u,v);\n\t\tgraph[u][v]=1;\n\t}\n\tREP(u,1,n)\n\t{\n\t\trt=u;\n\t\tdfs(u);\n\t}\n\tREP(u,1,n)\n\t{\n\t\tstatic int st[maxn],top; top=0;\n\t\tEREP(i,u)st[++top]=e[i].v;\n\t\tmemset(vis,0,sizeof(int)*(n+1));\n\t\tvis[u]=top+1;\n\t\tREP(j,1,top)\n\t\t{\n\t\t\tD=j;\n\t\t\tif(!vis[st[j]])dfs1(st[j]);\n\t\t}\n\t\tmemcpy(A,vis,sizeof(int)*(n+1));\n\t\tmemset(vis,0,sizeof(int)*(n+1));\n\t\tvis[u]=top+1;\n\t\tDREP(j,top,1)\n\t\t{\n\t\t\tD=j;\n\t\t\tif(!vis[st[j]])dfs1(st[j]);\n\t\t}\n\t\tmemcpy(B,vis,sizeof(int)*(n+1));\n\t\tREP(j,1,top)if(A[st[j]]!=B[st[j]])g[u][st[j]]=1;\n\t\t\n\t}\n}\n\ninline void doing()\n{\n\tREP(i,1,m)\n\t{\n\t\tint u=E[i].u,v=E[i].v;\n\t\tif(f[v][u]^(g[u][v]))puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nL n,m;\nL s[100010],e[100010];\nL ih[1111][1111];\nL chk[1111];\n\nvector<L>v[1111],back[1111];\nqueue<L>Q;\n\n\nL chk1[1111],chk2[1111];\n\nL ord[1111],ordtop;\nL scc[1111],scccolor;\n\nvoid dfs1(L x){\n\tL i;\n\tfor(i=0;i<v[x].size();i++)\n\t{\n\t\tif(!chk1[v[x][i]])\n\t\t{\n\t\t\tchk1[v[x][i]]=1;\n\t\t\tdfs1(v[x][i]);\n\t\t}\n\t}\n\tordtop++;\n\tord[ordtop]=x;\n}\n\nvoid dfs2(L x){\n\tscc[x]=scccolor;\n\tL i;\n\tfor(i=0;i<back[x].size();i++)\n\t{\n\t\tif(!chk2[back[x][i]])\n\t\t{\n\t\t\tchk2[back[x][i]]=1;\n\t\t\tdfs2(back[x][i]);\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tL i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&s[i],&e[i]);\n\t\tv[s[i]].push_back(e[i]);\n\t\tback[e[i]].push_back(s[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tchk[j]=0;\n\t\tchk[i]=-1;\n\t\tfor(j=0;j<v[i].size();j++)\n\t\t{\n\t\t\tchk[v[i][j]]=v[i][j];\n\t\t\tQ.push(v[i][j]);\n\t\t}\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tL x=Q.front();Q.pop();\n\t\t\tif(x==i) continue;\n\t\t\t//printf(\"%lld %lld, \",x,chk[x]);\n\t\t\tfor(j=0;j<v[x].size();j++)\n\t\t\t{\n\t\t\t\tif(chk[x]==-1)\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\tif(chk[v[x][j]]!=-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chk[v[x][j]]!=chk[x]&&chk[v[x][j]]!=-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchk[v[x][j]]=chk[x];\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//puts(\"\");\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(!chk1[i])\n\t\t{\n\t\t\tchk1[i]=1;\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\tfor(i=n;i>=1;i--)\n\t{\n\t\tif(!chk2[ord[i]])\n\t\t{\n\t\t\tscccolor++;\n\t\t\tchk2[ord[i]]=1;\n\t\t\tdfs2(ord[i]);\n\t\t}\n\t}\n\t\n\t/*for(i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%lld \",scc[i]);\n\t}*/\n\t\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tprintf(ih[s[i]][e[i]]^(scc[s[i]]==scc[e[i]])?\"diff\":\"same\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N = 1005, M = 200005;\n\nint n, m, sc, cc, non, wh[N], col[N];\nbool vis[N], ans[M], shu[N], can[N];\npii e[M];\n\nvector<int> adj[N], rev[N], out[N], st;\n\nvoid tdfs (int I) {\n\tif(vis[I]) return;\n\tvis[I] = true;\n\tfor(auto &T : adj[I]) if(T != non) tdfs(T);\n\tst.push_back(I);\n}\n\nvoid rdfs (int I) {\n\tif(vis[I]) return;\n\twh[I] = sc;\n\tvis[I] = true;\n\tfor(auto &T : rev[I]) if(T != non) rdfs(T);\n}\n\nvoid toposort (int I) {\n\tnon = I; sc = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vis[i]) tdfs(i);\n\t}\n\tfill(vis+1, vis+1+n, 0);\n\twhile(!st.empty()) {\n\t\tint T = st.back(); st.pop_back();\n\t\tif(!vis[T]) {rdfs(T); sc++;}\n\t}\n\tfill(vis+1, vis+1+n, 0);\n}\n\nvoid cdfs (int I) {\n\tcol[I] = cc;\n\tvis[I] = true;\n\tif(shu[I] && I != st[cc]) {\n\t\tcan[I] = true;\n\t\tif(wh[I] == wh[st[cc]]) can[st[cc]] = true;\n\t}\n\tfor(auto &T : adj[I]) {\n\t\tif(T == non) continue;\n\t\tif(vis[T]) {\n\t\t\tif(col[I] == col[T]) continue;\n\t\t\tif(wh[T] == wh[st[col[T]]]) can[st[col[T]]] = true;\n\t\t}\n\t\telse cdfs(T);\n\t}\n}\n\nvoid solve (int I) {\n\ttoposort(I);\n\tfor(auto &T : adj[I]) shu[T] = true;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T]) continue;\n\t\tst.push_back(T);\n\t\tcdfs(T); cc++;\n\t}\n\tfor(auto &T : out[I]) {\n\t\tans[T] = can[e[T].Y];\n\t}\n\tcc = 0; st.clear();\n\tfill(vis+1, vis+1+n, 0);\n\tfill(shu+1, shu+1+n, 0);\n\tfill(can+1, can+1+n, 0);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\te[i] = {A, B};\n\t\tout[A].push_back(i);\n\t\tadj[A].push_back(B);\n\t\trev[B].push_back(A);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!out[i].empty()) solve(i);\n\t}\n\ttoposort(0);\n\tfor(int i=1;i<=m;i++) {\n\t\tputs(ans[i] ^ (wh[e[i].X] == wh[e[i].Y]) ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nconst int MV = 1003;\nconst int ME = 100005;\n\nint n, m;\nint fst[MV], nxt[ME], u[ME], v[ME], lnum;\nint way[MV][MV];\nbool vis[MV];\n\nvoid addeg(int nu, int nv)\n{\n\tnxt[++lnum] = fst[nu];\n\tfst[nu] = lnum;\n\tu[lnum] = nu;\n\tv[lnum] = nv;\n}\n\nvoid input()\n{\n\tread(n), read(m);\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tread(a), read(b);\n\t\taddeg(a, b);\n\t}\n}\n\nvoid dfs(int x, int *s)\n{\n\tvis[x] = 1;\n\ts[x]++;\n\tfor(int i=fst[x]; i; i=nxt[i])\n\t\tif(s[v[i]]<=1 && !vis[v[i]])\n\t\t\tdfs(v[i], s);\n\tvis[x] = 0;\n}\n\nvoid work()\n{\n\tfor(int i=1; i<=n; i++) dfs(i, way[i]);\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a = u[i], b = v[i];\n\t\tif(way[a][b]==1 && !way[b][a]) puts(\"same\");\n\t\telse if(way[a][b]>=2 && !way[b][a]) puts(\"diff\");\n\t\telse if(way[a][b]==1 && way[b][a]) puts(\"diff\");\n\t\telse if(way[a][b]>=2 && way[b][a]) puts(\"same\");\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/extc++.h>\n#include<bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector,O3\")\nusing namespace std;using ll = long long;using ull = unsigned long long;using ul = unsigned;using db = double;using __gnu_pbds::null_type;\n#ifdef _debug \n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) 0&&0\n#endif\n#define eout(i) {cout << (i) << '\\n';exit(0);}\n#define priority_queue __gnu_pbds::priority_queue\n#define unordered_map __gnu_pbds::gp_hash_table\n#define rep(a, b) {for(int i = a;i > 0;--i){b;}}\n#define multe int T;for(cin >> T;T--;)\npair<long long, long long> ext_gcd(long long a, long long b){if(a % b == 0)return {0ll, 1ll};auto get = ext_gcd(b, a % b);return {get.second, get.first - a / b * get.second};}\nlong long ext_inv(long long a, long long p){return (ext_gcd(a, p).first + p) % p;}\nvector<int> kfunc(string &w){vector<int> k(w.size());for(int q = 0, i = 1;i < w.size();++i){for(;q > 0 and w[i] != w[q];q = k[q-1]);k[i] = (q += w[i] == w[q]);}return k;}\nvector<int> zfunc(string &w){vector<int> z(w.size());z[0] = w.size();for(int l = 0, i = 1;i < w.size();++i){z[i] = max(0, min(l+z[l] - i, z[i-l]));for(;i+z[i] < w.size() and w[i+z[i]] == w[z[i]];++z[i])l = i;}return z;}\ntemplate<typename T> using rbtree = __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T> inline long long pow(long long v, long long t, const T &p){long long res = 1;for(;t;t >>= 1, v = v * v % p)if(t & 1)res = res * v % p;return res;}\ntemplate<typename T> inline void floyd_warshall(vector<vector<T>> &dp){for(int i = 0;i < dp.size();++i)for(int j = 0;j < dp.size();++j)for(int k = 0;k < dp.size();++k)dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k]);}\ntemplate<typename T> inline ostream& operator << (ostream &ou, const vector<T> &a){for(auto it = a.begin();it != a.end();++it)ou << (it != a.begin() ? \" \" : \"\") << *it;return ou;}\ntemplate<typename T> inline vector<vector<T>> operator * (const vector<vector<T>> &a, const vector<vector<T>> &b){assert(a.front().size() == b.size());vector<vector<T>> res(a.size(), vector<T>(b.front().size()));for(int i = 0;i < a.size();++i)for(int j = 0;j < b.front().size();++j)for(int k = 0;k < a.front().size();++k)res[i][j] += a[i][k] * b[k][j];return res;}\ntemplate<typename T> inline vector<vector<T>> pow(vector<vector<T>> v, long long t){vector<vector<T>> res;for(;t;t >>= 1, v = v * v)if(t & 1)res = (res.empty() ? v : res * v);return res;}\ntemplate<typename T> void read(int n, T *s){while(n--)cin >> *s, ++s;}\ntemplate<typename T> void read(int n, vector<T> &v){for(int i = 0;i < n;++i)cin >> v[i];}\ntemplate<typename T> void write(int n, T *s){while(n--)cout << *s << \" \\n\"[n==0], ++s;}\ntemplate<typename T1, typename T2>inline istream& operator >> (istream &in, pair<T1, T2> &a){return in >> a.first >> a.second;}\ntemplate<typename T1, typename T2>inline ostream& operator << (ostream &ou, const pair<T1, T2> &b){return ou << b.first << ' ' << b.second;}\ntemplate<typename T1, typename T2>inline pair<T1,T2> operator + (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first + b.first, a.second + b.second};}\ntemplate<typename T1, typename T2>inline pair<T1,T2> operator - (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first - b.first, a.second - b.second};}\ntemplate<typename T1, typename T2>inline long long operator ^ (const pair<T1,T2> &a, const pair<T1,T2> &b){return (long long)a.first * b.second - (long long)a.second * b.first;}\nconst int maxn = 1010;\nint n, m;\nvector<pair<int,int>> alle;\nvector<int> edge[maxn];\nvector<vector<int>> dp;\nint g[maxn];\nvoid dfs(int now){\n\tstatic int low[maxn], d = 0, id = 1, onpath[maxn];\n\tif(onpath[now])return;\n\tlow[now] = ++d;\n\tonpath[now] = true;\n\tfor(int &i : edge[now]){\n\t\tif(onpath[i] || !low[i]){\n\t\t\tdfs(i), low[now] = min(low[now], low[i]);\n\t\t\tif(low[i] > d)++id;\n\t\t}\n\t}\n\tg[now] = id; \n\tonpath[now] = false;\n\t--d;\n}\nstring output[2]{\"same\\n\", \"diff\\n\"};\nint depen[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\talle.reserve(m);\n\tdp.resize(n+1, vector<int> (m+1, maxn));\n\tfor(int i = 0, a, b;i < m;++i){\n\t\tcin >> a >> b;\n\t\tedge[a].emplace_back(b);\n\t\talle.emplace_back(a, b);\n\t\tdp[a][b] = 1;\n\t}\n\tdfs(1);\n\n\tfloyd_warshall(dp);\n\tfor(int i = 1;i <= n;++i)cout << g[i] << ' ';cout << '\\n';\n\n\tfor(int i = 1;i <= n;++i){\n\t\twhile(edge[i].size() and g[edge[i].back()] != g[i])edge[i].pop_back();\n\t\tfor(int j = 0, r = (int)edge[i].size()-1;j < r;++j){\n\t\t\tif(g[i] != g[edge[i][j]])swap(edge[i][j], edge[i][r]), --r;\n\t\t}\n\t\twhile(edge[i].size() and g[edge[i].back()] != g[i])edge[i].pop_back();\n\t\tfor(int &j : edge[i])++depen[j];\n\t}\n\tfor(const auto &e : alle){\n#define f first\n#define s second\n\t\tint res = 0;\n\t\tif(g[e.f] == g[e.s]){\n\t\t\t// dout(e.f)<<' '<< edge[e.f].size() << '\\n';\n\t\t\tres = edge[e.f].size() == 1 || depen[e.s] == 1;\n\t\t}\t\n\t\telse{\n\t\t\tfor(int i = 1;i <= n and !res;++i)if(i != e.f and i != e.s and g[i] != g[e.f] and g[i] != g[e.s]){\n\t\t\t\tif(dp[e.f][i] != dp[e.s][i]+1 and dp[e.f][i] < maxn and dp[i][e.s] < maxn)res = 1;\n\t\t\t}\n\t\t}\n\t\tcout << output[res];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std; \n\nint n, m, col[1005]; \nbool can[1005][1005], only[1005][1005]; \nint vis[1005]; \nvector <int> G[1010]; \n\nvoid dfs1(int u, int x) {\n    can[x][u] = 1; \n    vis[u] = 1; \n    for (auto v : G[u]) {\n        if (!vis[v]) {\n            dfs1(v, x);\n        }\n    }\n}\n\nvoid dfs2(int u, int x, int t, int op) {\n    // cout << u << '\\n'; \n    if (op == 1) {\n        only[x][u] = col[u] != t; \n    }\n    else {\n        col[u] = t; \n    }\n    vis[u] = 1; \n    for (auto v : G[u]) {\n        if (!vis[v]) {\n            dfs2(v, x, t, op); \n        }\n    }\n}\n\nint U[1010100], V[1010100]; \n\nint main() {\n    scanf(\"%d %d\", &n, &m); \n    for (int i = 1; i <= m; i++) {\n        int u, v; \n        scanf(\"%d %d\", &u, &v);\n        U[i] = u, V[i] = v; \n        G[u].push_back(v);  \n    }\n    for (int i = 1; i <= n; i++) {\n        memset(vis, 0, sizeof(vis)); \n        vis[i] = 1; \n        dfs1(i, i); \n    }\n    for (int i = 1; i <= n; i++) {\n        memset(vis, 0, sizeof(vis)); \n        vis[i] = 1;\n        memset(col, 0, sizeof(col));  \n        for (int j = 0; j < G[i].size(); j++) {\n            int v = G[i][j]; \n            if (!vis[v])\n                dfs2(v, i, j + 1, 0); \n        }\n        memset(vis, 0, sizeof(vis)); \n        vis[i] = 1; \n        for (int j = G[i].size() - 1; j >= 0; j--) {\n            int v = G[i][j]; \n            if (!vis[v])\n                dfs2(v, i, j + 1, 1); \n        }\n    }\n    for (int i = 1; i <= m; i++) {\n        if (can[V[i]][U[i]] ^ only[U[i]][V[i]]) puts(\"diff\"); \n        else puts(\"same\"); \n    }\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\nstruct graph_t\n{\n\tint front,nex;\n}graph[201001];\nint tail=1000;\n\nvoid addedge(int u,int v)\n{\n\tint tmp=graph[u].nex;\n\tgraph[u].nex=++tail;\n\tgraph[tail].front=v;\n\tgraph[tail].nex=tmp;\n}\n\nint vis[1001][1001];\npair<int,int> edge[200001];\nint mark[1001];\nint times=1;\n\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=times;\n\tfor(int i=graph[now].nex;i;i=graph[i].nex)\n\t{\n\t\tif(now==from)continue; \n\t\tif(vis[from][graph[i].front]<2&&mark[graph[i].front]!=times)\n\t\t{\n\t\t\tdfs(from,graph[i].front);\n\t\t}\n\t}\n//\tmark[now]=false;\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i]=make_pair(from,to);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=graph[i].nex;j;j=graph[j].nex)\n\t\t{\n\t\t\tif(vis[i][graph[j].front]<2)\n\t\t\t{\n\t\t\t\tdfs(i,graph[j].front);\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL_((0,__VA_ARGS__, 6,5,4,3,2,1))\n#define VA_NUM_ARGS_IMPL_(tuple) VA_NUM_ARGS_IMPL tuple\n#define VA_NUM_ARGS_IMPL(_0,_1,_2,_3,_4,_5,_6,N,...) N\n#define macro_dispatcher(macro, ...) macro_dispatcher_(macro, VA_NUM_ARGS(__VA_ARGS__))\n#define macro_dispatcher_(macro, nargs) macro_dispatcher__(macro, nargs)\n#define macro_dispatcher__(macro, nargs) macro_dispatcher___(macro, nargs)\n#define macro_dispatcher___(macro, nargs) macro ## nargs\n#define Debug1(a)           cout<<#a<<\"=\"<<(a)<<\"\\n\"\n#define Debug2(a,b)         cout<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n#define Debug3(a,b,c)       cout<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\"\\n\"\n#define Debug4(a,b,c,d)     cout<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\"\\n\"\n#define Debug5(a,b,c,d,e)   cout<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\", \"<<#e<<\"=\"<<(e)<<\"\\n\"\n#define Debug6(a,b,c,d,e,f) cout<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\", \"<<#e<<\"=\"<<(e)<<\", \"<<#f<<\"=\"<<(f)<<\"\\n\"\n#define Debug(...) macro_dispatcher(Debug, __VA_ARGS__)(__VA_ARGS__)\n#define DA(a,s,n) cout<<#a<<\"=[\"; printarray(a,s,n); cout<<\"]\\n\"\n\n#define TT1 template<class T>\n#define TT1T2 template<class T1, class T2>\n#define TT1T2T3 template<class T1, class T2, class T3>\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v);\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p){ return os <<\"(\"<<p.first<<\", \"<< p.second<<\")\"; }\nTT1 ostream& operator << (ostream& os, const vector<T>& v){       bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v) {     bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v){    bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const multiset<T1,T2>&v){bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2T3 ostream& operator << (ostream& os, const map<T1,T2,T3>& v){ bool f = 1; os << \"[\"; for (auto& ii : v) { if (!f)os << \", \"; os << \"(\" << ii.first << \" -> \" << ii.second << \") \"; f = 0; }return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const multimap<T1, T2>& v){ bool f = 1; os << \"[\"; for (auto& ii : v) { if (!f)os << \", \"; os << \"(\" << ii.first << \" -> \" << ii.second << \") \"; f = 0; }return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v) { bool f = 1; os << \"[\"; while (!v.empty()) { auto x = v.top(); v.pop(); if (!f) os << \", \"; f = 0; os << x; } return os << \"]\"; }\nTT1T2 void printarray(const T1& a, T2 l, T2 r){ for (T2 i = l; i<=r; i++) cout << a[i] << (i<r?\" \":\"\"); }\n\nvoid cio(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << setprecision(15);\n}\n\n#define tt() printf(\"%.4f sec\\n\", (double) clock() / CLOCKS_PER_SEC )\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define repp(i, n) for(int i=1;i<=n;i++)\n#define all(x) x.begin(), x.end()\n#define geti1(X) cin >> X\n#define geti2(X,Y) cin >> X >> Y\n#define geti3(X,Y,Z) cin >> X >> Y >> Z\n#define geti4(X,Y,Z,W) cin >> X >> Y >> Z >> W\n#define GET_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define geti(...) GET_MACRO(__VA_ARGS__, geti4, geti3, geti2, geti1) (__VA_ARGS__)\n\n#define endl '\\n'\n\ntypedef tuple<int,int,int> t3;\ntypedef tuple<int,int,int,int> t4;\nvoid die(){printf(\"-1\\n\"); exit(0);}\nint xx[8] = {1,-1,0,0,1,1,-1,-1}, yy[8] = {0,0,1,-1,1,-1,1,-1};\nconst ll mod = 1e9+9;\n\nint N,M;\nvector<pii> elist;\nvector<int> E[1020];\nint d[1020][1020], vis[1020], mn[1020], mx[1020];\nint b[1020][1020];\nvoid dfs1(int x, int r){\n    d[r][x] = 1;\n    for(auto e : E[x]) if( !d[r][e] ) dfs1(e, r);\n}\nvoid dfs2(int x, int r, int t){\n    vis[x] = 1;\n    mx[x] = max(mx[x], r), mn[x] = min(mn[x], r);\n    for(auto e : E[x]) if(!vis[e]) dfs2(e, r, 1);\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&M);\n    repp(i,M){\n        int a,b; scanf(\"%d%d\",&a,&b);\n        E[a].pb(b);\n        elist.push_back({a,b});\n    }\n    for(int i=1;i<=N;i++) dfs1(i,i);\n    \n    for(int i=1;i<=N;i++){\n        sort(all(E[i]));\n        repp(i,N) mn[i] = 1e9, mx[i] = -1;\n        memset(vis,0,sizeof vis);\n        vis[i] = 1;\n        \n        for(int j=0;j<sz(E[i]);j++) dfs2(E[i][j],E[i][j],0);\n        memset(vis,0,sizeof vis); vis[i] = 1;\n        for(int j=sz(E[i])-1;j>=0;j--) dfs2(E[i][j],E[i][j],0);\n        \n        for(auto e : E[i]) if( mn[e] == mx[e] ) b[i][e] = 1;\n    }\n    /*\n    repp(i,N) {\n        repp(j,N) printf(\"%d \",d[i][j]); printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    repp(i,N) {\n        repp(j,N) printf(\"%d \",b[i][j]); printf(\"\\n\");\n    }\n    */\n    for(auto e : elist){\n        //Debug(e, d[e.Fi][e.Se], b[e.Fi][e.Se]);\n        int B = e.Se, A = e.Fi;\n        if( d[B][A] == 0 &&  b[A][B] == 0 ) printf(\"diff\\n\");\n        else if( d[B][A] == 1 && b[A][B] == 1 ) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 1010\n#define LL long long\n#define rep(i, x, y) for(int i = (x); i <= (y); ++ i)\ninline int read() {\n\tchar ch = getchar(); int x = 0, f = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') f = -1;\n\t\tch = getchar();\n\t}\n\twhile('0' <= ch && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn x * f;\n}\nint p[M][M], q[M][M];\nint T;\nvector<int> G[M];\nint vis[M];\ninline void dfs(int st, int x, int id, int a[]) {\n\tif(st == x || vis[x] == T) return;\n\tvis[x] = T; a[x] = id;\n\tfor(int i = 0; i < G[x].size(); ++ i) {\n\t\tdfs(st, G[x][i], id, a);\n\t}\n}\npair<int, int> A[M*200];\nint main() {\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tint n = read(), m = read();\n\trep(i, 1, m) {\n\t\tint u = read(), v = read();\n\t\tG[u].push_back(v);\n\t\tA[i] = make_pair(u, v);\n\t}\n\trep(i, 1, n) {\n\t\t++ T;\n\t\tint id = 0;\n\t\tfor(int j = 0; j < G[i].size(); ++ j) {\n\t\t\tdfs(i, G[i][j], ++ id, p[i]);\n\t\t}\n\t\treverse(G[i].begin(), G[i].end());\n\t\t++ T; id = G[i].size();\n\t\tfor(int j = 0; j < G[i].size(); ++ j) {\n\t\t\tdfs(i, G[i][j], id --, q[i]);\n\t\t}\n\t}\n\trep(i, 1, m) {\n\t\tint u = A[i].first, v = A[i].second;\n\t\tif((q[v][u] > 0) == (p[u][v] != q[u][v])) {\n\t\t\tputs(\"same\");\n\t\t}\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\nusing namespace std;\n#define N 1050\n#define M 200500\nint head[N],cnt,scc[N],dfn[N],low[N],f[N][13],s[M][2],as[M],vl[N],ct,ct2,vis[N][N],id[N],ct1,dep[N],is[N],n,m;\nstruct edge{int t,next,id;}ed[M];\nvoid adde(int f,int t,int id){ed[++cnt]=(edge){t,head[f],id};head[f]=cnt;}\nstack<int> tp,tp2,v[N],tp3;\nvoid dfs1(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\ttp.push(u);\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs1(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])\n\t{\n\t\tint s=tp.top(),id=++ct2;tp.pop();\n\t\tscc[s]=id;\n\t\twhile(s!=u)\n\t\ts=tp.top(),tp.pop(),scc[s]=id;\n\t}\n}\nvoid dfs2(int u,int s){for(int i=head[u];i;i=ed[i].next)if(!vis[s][ed[i].t])vis[s][ed[i].t]=1,dfs2(ed[i].t,s);else vis[s][ed[i].t]++;}\nint LCA(int x,int y){if(dep[x]<dep[y])x^=y^=x^=y;for(int i=10;i>=0;i--)if(dep[x]-dep[y]>=(1<<i))x=f[x][i];if(x==y)return x;for(int i=10;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];return f[x][0];}\nvoid dfs3(int u,int fa)\n{\n\tdfn[u]=1;f[u][0]=fa;vl[u]=0;for(int i=1;i<=10;i++)f[u][i]=f[f[u][i-1]][i-1];\n\tfor(int i=head[u];i;i=ed[i].next)\n\tif(!dfn[ed[i].t])tp.push(ed[i].id),dfs3(ed[i].t,u),vl[u]+=vl[ed[i].t];\n\telse{int s=LCA(u,ed[i].t);vl[u]++;vl[s]--;tp2.push(ed[i].id);}\n}\nbool check(int x)\n{\n\tfor(int i=1;i<=n;i++)dfn[i]=scc[i]=head[i]=0;\n\tcnt=0;ct2=0;\n\tfor(int i=1;i<=m;i++)if(i!=x)adde(s[i][0],s[i][1],-1);else adde(s[i][1],s[i][0],-2);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);\n\treturn ct2!=1;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&s[i][0],&s[i][1]),adde(s[i][0],s[i][1],1);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])adde(scc[s[i][0]],scc[s[i][1]],-3);\n\tfor(int i=1;i<=ct2;i++)dfs2(i,i);\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])as[i]=vis[scc[s[i][0]]][scc[s[i][1]]]>1;else v[scc[s[i][0]]].push(i);\n\tfor(int i=1;i<=ct2;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)dfn[j]=0;\n\t\tct1=0;\n\t\tfor(int j=1;j<=n;j++)if(scc[j]==i)id[j]=++ct1;\n\t\twhile(!v[i].empty())\n\t\t{\n\t\t\tint q=v[i].top();v[i].pop();\n\t\t\tadde(id[s[q][0]],id[s[q][1]],q);\n\t\t}\n\t\tdfs3(1,0);\n\t\twhile(!tp2.empty())\n\t\t{\n\t\t\tint st=tp2.top();tp2.pop();\n\t\t\tint l=id[s[st][0]],r=id[s[st][1]];\n\t\t\tr=LCA(l,r);\n\t\t\tint fg=0;\n\t\t\twhile(l!=r)fg|=(vl[l]==1),l=f[l][0];\n\t\t\tas[st]=fg;\n\t\t}\n\t}\n\twhile(!tp.empty()){int st=tp.top();tp.pop();as[st]=check(st);}\n\tfor(int i=1;i<=m;i++)printf(\"%s\\n\",as[i]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << x << endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define MAX_V 1000\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];//辺を逆にしたグラフ\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];//属する強連結成分のトポロジカル順序\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); ++i){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    used[v] = true;\n    cmp[v] = k;\n    for(int i = 0; i < rG[v].size(); ++i){\n        if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\nvoid scc(){\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v = 0; v < V; ++v){\n        if(!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i =(int) vs.size()-1; i >= 0; i--){\n        if(!used[vs[i]]) rdfs(vs[i],k++);\n    }\n    return;\n}\nint num[1000][1000];//num[i][j] = iからjへの行き方の総数みたいなもの(2以上は無視して2にする)\nint hoge[1000];//u->v辺を使ってきたやつを除外するため\nvoid dfs(int now,const int u,const int v){\n    num[u][now]++;\n    if(num[u][now]>=3){\n        //もう2回目なのでnow以降も2回目で無視\n        num[u][now] = 2;\n        return;\n    }\n    if(num[u][now]==2){\n        if(hoge[now] == v){\n            num[u][now] = 1;\n            return;\n        }\n    }\n    if(num[u][now]==1){\n        hoge[now] = v;\n    }\n    rep(i,G[now].size()){\n        if(G[now][i] != u){\n            dfs(G[now][i],u,v);\n        }\n    }\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    V = n;\n    vector<int>a(m),b(m);\n    rep(i,m){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        a[i]--,b[i]--;\n        add_edge(a[i],b[i]);\n    }\n    scc();\n    rep(i,n){\n        rep(k,n)hoge[k] = -1;\n        rep(j,G[i].size()){\n            dfs(G[i][j],i,G[i][j]);\n        }\n    }\n    rep(i,m){\n        bool flag = false;\n        if(cmp[a[i]] == cmp[b[i]]){\n            if(num[a[i]][b[i]]==2)flag = true;\n        }else{\n            if(num[a[i]][b[i]]==1)flag = true;\n        }\n        if(flag){\n            puts(\"same\");\n        }else{\n            puts(\"diff\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\n#define edge(u) for(re int i=head[u];i;i=e[i].nxt)\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nconst int N=1e3+5;\nconst int M=2e5+5;\ninline int read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nbool vis[N],vis1[N][N],vis2[N][N];\nint n,m,head[N],cnt,a[M],b[M],mark[N];\nstruct edge{\n\tint to,nxt;\n}e[M];\nvoid add(int a,int b){\n\te[++cnt].to=b;\n\te[cnt].nxt=head[a];\n\thead[a]=cnt;\n}\nvoid dfs1(int u,int s){\n\tvis1[s][u]=1;\n\tedge(u){\n\t\tint v=e[i].to;\n\t\tif(!vis1[s][v]) dfs1(v,s);\n\t}\n}\nvoid dfs2(int u,int s,int tp,int c){\n\tif(!tp) mark[u]=c;\n\telse vis2[s][u]=c!=mark[u];\n\tvis[u]=1;\n\tedge(u){\n\t\tint v=e[i].to;\n\t\tif(vis[v]) continue;\n\t\tdfs2(v,s,tp,c);\n\t}\n}\nvector<pair<int,int> > ve;\nint main(){\n\tn=read(),m=read();\n\tinc(i,1,m){\n\t\ta[i]=read(),b[i]=read();\n\t\tadd(a[i],b[i]);\n\t}\n\tinc(i,1,n) dfs1(i,i);\n\tinc(u,1,n){\n\t\tmemset(vis,0,sizeof(vis));vis[u]=1;\n\t\tedge(u){\n\t\t\tint v=e[i].to;\n\t\t\tve.push_back(mp(v,i));\n\t\t\tif(vis[v]) continue;\n\t\t\tdfs2(v,u,0,i);\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));vis[u]=1;\n\t\tfor(re int i=(int)ve.size()-1;i>=0;i--){\n\t\t\tint v=ve[i].fi,c=ve[i].se;\n\t\t\tif(vis[v]) continue;\n\t\t\tdfs2(v,u,1,c);\n\t\t}\n\t\tve.clear();\n\t}\n\tinc(i,1,m) puts(vis1[b[i]][a[i]]^vis2[a[i]][b[i]]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m;\nint u[200005], v[200005];\nvector<int> G[1005];\nint arr[1005][1005];\n\nvoid dfs(int x, int y, int tp)\n{\n\tarr[x][y] = arr[x][y] ? -1 : tp;\n\trep(i, G[y].size()) {\n\t\tint cy = G[y][i];\n\t\tif(arr[x][cy] != -1 && arr[x][cy] != tp) dfs(x, cy, tp);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tG[u[i]].push_back(v[i]);\n\t}\n\t\n\trep1(i, n) arr[i][i] = -1;\n\trep(i, m) dfs(u[i], v[i], v[i]);\n\n\trep(i, m) {\n\t\tif((arr[u[i]][v[i]] != v[i]) != (arr[v[i]][u[i]] != 0)) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0' || ch>'9')\n\t{\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0' && ch<='9')\n\t{\n\t\tx=10*x+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nconst int Maxn=1005;\nconst int Maxm=200005;\nstruct Edge\n{\n\tint u,v,next;\n} w[Maxm<<1];\nint cnt,head[Maxn];\nint n,m,vis[Maxn][Maxn];\nbool used[Maxm];\nvoid AddEdge(int u,int v)\n{\n\tcnt++;\n\tw[cnt].u=u;\n\tw[cnt].v=v;\n\tw[cnt].next=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int start,int x)\n{\n\tused[x]=true;\n\tfor(int i=head[x]; i; i=w[i].next)\n\t{\n\t\tif(!used[w[i].v])\n\t\t{\n\t\t\tvis[start][w[i].v]++;\n\t\t\tdfs(start,w[i].v);\n\t\t}\n\t}\n\tused[x]=false;\n}\nvoid init()\n{\n\tn=read();\n\tm=read();\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a=read();\n\t\tint b=read();\n\t\tAddEdge(a,b);\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tmemset(used,0,sizeof(used));\n\t\tdfs(i,i);\n\t}\n}\ninline bool SSC(int u,int v)\n{\n\treturn vis[u][v] && vis[v][u];\n}\nint main()\n{\n\tinit();\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint from=w[i].u;\n\t\tint to=w[i].v;\n\t\tif(SSC(from,to))\n\t\t{\n\t\t\tif(vis[from][to]==1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<vector>\nusing namespace std; \nconst int maxn=1000+50;\nconst int maxm=200000+50;\nint N,M;\nint p[maxn];\nint q[maxn];\nint c[maxn][maxn];\nbool an[maxm];\nstruct edge\n{\n\tint to,id;\n\tedge(int to=0,int id=0):to(to),id(id){}\n};\nvector<edge> adj[maxn];\nvoid dfs(int u,int root)\n{\n\tif(c[root][u]) return;\n\tc[root][u]=1;\n\tfor(unsigned int i=0;i<adj[u].size();++i)\n\t{\n\t\tint v=adj[u][i].to;\n\t\tdfs(v,root); \n\t}\n}\nvoid dfs(int u,int c,int *p)\n{\n\tif(p[u]!=-1) return;\n\tp[u]=c;\n\tfor(unsigned int i=0;i<adj[u].size();++i)\n\t{\n\t\tint v=adj[u][i].to;\n\t\tdfs(v,c,p);\n\t}\n}\nvoid solve()\n{\n\tfor(int i=1;i<=N;++i)\n\t{\n\t\tdfs(i,i);\n\t}\n\tfor(int u=1;u<=N;++u)\n\t{\n\t\tmemset(p,-1,sizeof(p));\n\t\tmemset(q,-1,sizeof(q));\n\t\tint l=p[u]=q[u]=adj[u].size();\n\t\tfor(int i=0;i<l;++i)\n\t\t{\n\t\t\tint v=adj[u][i].to;\n\t\t\tdfs(v,i,p);\n\t\t}\n\t\tfor(int i=l-1;~i;--i)\n\t\t{\n\t\t\tint v=adj[u][i].to;\n\t\t\tdfs(v,i,q);\n\t\t}\n\t\tfor(int i=0;i<l;++i)\n\t\t{\n\t\t\tint v=adj[u][i].to;\n\t\t\tint d=adj[u][i].id;\n\t\t\tan[d]=c[v][u]^(p[v]!=i||q[v]!=i);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=M;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a].push_back(edge(b,i));\n\t}\n\tsolve();\n\tfor(int i=1;i<=M;++i)\n\t{\n\t\tputs(an[i]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<sys/time.h>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ninline int ri()\n{\n\tregister int x=0;register bool f=0;register char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();};\n\treturn f?-x:x;\n}\nvoid wi(int x)\n{\n\tif(x<0)\tx=-x,putchar('-');\n\tif(x>9)\twi(x/10);\n\tputchar('0'+x%10);\n}\nconst int N=1005;\nint n,m;\nint ans[N*200],t[N][N],tt[N],b[N*200],a[N*200];\nint D,del,clk,vis[N];\nvoid dfs(int u)\n{\n\tint i;\n\tif(vis[u]) return;\n\tif(u==del) return;\n\tvis[u]=clk;\n\tfor(i=1;i<=tt[u];i++) dfs(b[t[u][i]]);\n}\nvoid work(int u)\n{\n\tint i,v;\n\tdel=u;\n\tmemset(vis,0,sizeof(vis));\n\tfor(i=1;i<=tt[u];i++)\n\t{\n\t\tclk=v=b[t[u][i]];\n\t\tdfs(v);\n\t}\n\tfor(i=1;i<=tt[u];i++) \n\t{\n\t\tv=b[t[u][i]];\n\t\tif (v!=vis[v]) ans[t[u][i]]=1;\n\t}\n}\nint main()\n{\n\tint u,v,i;\n\tn=ri(),m=ri();\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tu=ri(),v=ri();\n\t\ta[i]=u,b[i]=v;\n\t\tt[u][++tt[u]]=i;\n\t}\n\tfor(u=1;u<=n;u++)\n\t{\n\t\twork(u);\n\t\tfor(i=1;i<=tt[u]/2;i++) swap(t[u][i],t[u][ tt[u]-i+1 ]);\n\t\twork(u);\n\t}\n\tfor(u=1;u<=n;u++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tclk=1;\n\t\tdel=0;\n\t\tdfs(u);\n\t\tfor(i=1;i<=m;i++) if(b[i]==u) ans[i]^=vis[a[i]];\n\t}\n\tfor(i=1;i<=m;i++) if(ans[i]) puts(\"diff\");else puts(\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/extc++.h>\n#include<bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector,O3\")\nusing namespace std;using ll = long long;using ull = unsigned long long;using ul = unsigned;using db = double;using __gnu_pbds::null_type;\n#ifdef _debug \n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) 0&&0\n#endif\n#define eout(i) {cout << (i) << '\\n';exit(0);}\n#define priority_queue __gnu_pbds::priority_queue\n#define unordered_map __gnu_pbds::gp_hash_table\n#define rep(a, b) {for(int i = a;i > 0;--i){b;}}\n#define multe int T;for(cin >> T;T--;)\npair<long long, long long> ext_gcd(long long a, long long b){if(a % b == 0)return {0ll, 1ll};auto get = ext_gcd(b, a % b);return {get.second, get.first - a / b * get.second};} long long ext_inv(long long a, long long p){return (ext_gcd(a, p).first + p) % p;} template<typename T> using rbtree = __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>; template<typename T> inline long long pow(long long v, long long t, const T &p){long long res = 1;for(;t;t >>= 1, v = v * v % p)if(t & 1)res = res * v % p;return res;} template<typename T> inline void floyd_warshall(vector<vector<T>> &dp){for(int i = 0;i < dp.size();++i)for(int j = 0;j < dp.size();++j)for(int k = 0;k < dp.size();++k)dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k]);} template<typename T> inline ostream& operator << (ostream &ou, const vector<T> &a){for(auto it = a.begin();it != a.end();++it)ou << (it != a.begin() ? \" \" : \"\") << *it;return ou;} template<typename T> inline vector<vector<T>> operator * (const vector<vector<T>> &a, const vector<vector<T>> &b){assert(a.front().size() == b.size());vector<vector<T>> res(a.size(), vector<T>(b.front().size()));for(int i = 0;i < a.size();++i)for(int j = 0;j < b.front().size();++j)for(int k = 0;k < a.front().size();++k)res[i][j] += a[i][k] * b[k][j];return res;} template<typename T> inline vector<vector<T>> pow(vector<vector<T>> v, long long t){vector<vector<T>> res;for(;t;t >>= 1, v = v * v)if(t & 1)res = (res.empty() ? v : res * v);return res;} template<typename T> void read(int n, T *s){while(n--)cin >> *s, ++s;} template<typename T> void read(int n, vector<T> &v){for(int i = 0;i < n;++i)cin >> v[i];} template<typename T> void write(int n, T *s){while(n--)cout << *s << \" \\n\"[n==0], ++s;} template<typename T1, typename T2>inline istream& operator >> (istream &in, pair<T1, T2> &a){return in >> a.first >> a.second;} template<typename T1, typename T2>inline ostream& operator << (ostream &ou, const pair<T1, T2> &b){return ou << b.first << ' ' << b.second;} template<typename T1, typename T2>inline pair<T1,T2> operator + (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first + b.first, a.second + b.second};} template<typename T1, typename T2>inline pair<T1,T2> operator - (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first - b.first, a.second - b.second};} template<typename T1, typename T2>inline long long operator ^ (const pair<T1,T2> &a, const pair<T1,T2> &b){return (long long)a.first * b.second - (long long)a.second * b.first;} \nconst int maxn = 1001;\nstring out[2]{\"same\\n\", \"diff\\n\"};\nint res[maxn * maxn];\nint n, m;\nvector<pair<int,int>> edge[maxn], rev[maxn];\nbool vis[maxn];\nint togo[maxn], tl;\nvoid bfs(const int &now){\n\tmemset(vis, 0, sizeof vis);\n\ttl = 1, togo[0] = now, vis[now] = true;\n\tfor(int i = 0;i < tl;++i){\n\t\tfor(const auto &j : edge[togo[i]])if(!vis[j.second]){\n\t\t\tvis[j.second] = true;\n\t\t\ttogo[tl++] = j.second;\n\t\t}\n\t}\n}\nvoid getpath(const int &now, int *v, const int &id, const int &block){\n\ttl = 1, togo[0] = now;\n\tfor(int i = 0;i < tl;++i){\n\t\tfor(const auto &j : edge[togo[i]])if(j.second != block and !v[j.second]){\n\t\t\tv[j.second] = id;\n\t\t\ttogo[tl++] = j.second;\n\t\t}\n\t}\n}\nint sid[maxn], bid[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\tfor(int i = 0, a, b;i < m;++i){\n\t\tcin >> a >> b;\n\t\tedge[a].emplace_back(i+1, b);\n\t\trev[b].emplace_back(i+1, a);\n\t}\t\n\tfor(int i = 1;i <= n;++i){\n\t\tbfs(i);\n\t\tfor(auto &j : rev[i])res[j.first] ^= (bool)vis[j.second];\n\t\tmemset(sid, 0, sizeof sid), memset(bid, 0, sizeof bid);\n\t\tfor(int j = 0;j < (int)edge[i].size();++j)getpath(edge[i][j].second, sid, edge[i][j].first, i);\n\t\tfor(int j = (int)edge[i].size()-1;j > -1;--j)getpath(edge[i][j].second, bid, edge[i][j].first, i);\n\t\tfor(auto &j : edge[i])res[j.first] ^= ((sid[j.second] and sid[j.second] != j.first) || (bid[j.second] and bid[j.second] != j.first));\n\t}\n\tfor(int i = 1;i <= m;++i)cout << out[res[i]];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint head[1024],last[262144],to[262144],cnt=0;\nvoid add(int u,int v)\n{\n\tcnt++;\n\tlast[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n}\nint tp[1024];\nvoid dfs(int u,int t)\n{\n\tif(tp[u]==t||tp[u]<0)\n\t{\n\t\treturn;\n\t}\n\tif(!tp[u])\n\t{\n\t\ttp[u]=t;\n\t}\n\telse\n\t{\n\t\ttp[u]=-1;\n\t}\n\tfor(int i=head[u];i;i=last[i])\n\t{\n\t\tdfs(to[i],t);\n\t}\n}\nint vis[1005][1005];\nint a[262144],b[262144];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tadd(a[i],b[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\ttp[j]=0;\n\t\t}\n\t\ttp[i]=-1;\n\t\tfor(int j=head[i];j;j=last[j])\n\t\t{\n\t\t\tdfs(to[j],to[j]);\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(!tp[j])\n\t\t\t{\n\t\t\t\tvis[i][j]=0;\n\t\t\t}\n\t\t\telse if(tp[j]==j)\n\t\t\t{\n\t\t\t\tvis[i][j]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvis[i][j]=2;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif((vis[a[i]][b[i]]>=2)^(vis[b[i]][a[i]]>=1))\n\t\t{\n\t\t\tprintf(\"diff\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1005;\nconst int M=200005;\nstruct edge{\n\tint to,next;\n}e[M];\nint head[N],tot;\nint n,m,x[M],y[M];\nint co1[N][N],co2[N][N];\nint vis[N],q[N];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nvoid dfs(int x,int co){\n\tvis[x]=co;\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (!vis[e[i].to])\n\t\t\tdfs(e[i].to,co);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,m){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tadd(x[i],y[i]);\n\t}\n\tFor(i,1,n){\n\t\t*q=0;\n\t\tfor (int j=head[i];j;j=e[j].next)\n\t\t\tq[++*q]=e[j].to;\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tFor(j,1,*q) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co1[i][j]=vis[j];\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tRep(j,*q,1) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co2[i][j]=vis[j];\n\t}\n\tFor(i,1,m){\n\t\tbool f1=(co1[y[i]][x[i]]!=0);\n\t\tbool f2=(co2[x[i]][y[i]]&&co2[x[i]][y[i]]!=y[i])||(co1[x[i]][y[i]]&&co1[x[i]][y[i]]!=y[i]);\n\t\tputs(f1^f2?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n\ntypedef pair<int, int> P;\n\n#define fir first\n#define sec second\n\nvector<P> G[N];\n\nbool mark[N][N], mp[N][N], vis[N]; int ct[N][N];\n\nint rt, n; \n\nvoid dfs(int u, int type) {\n    vis[u] = 1;\n    if (mp[rt][u] && !mark[rt][u]) ct[rt][u] |= 1;\n    if (!type) {\n        for (auto v : G[u]) if (!vis[v.sec])\n            mark[u][v.sec] = 1, dfs(v.sec, type), mark[u][v.sec] = 0;\n    } else for (int i = G[u].size() - 1; i >= 0; i--) if (!vis[G[u][i].sec])\n        mark[u][G[u][i].sec] = 1, dfs(G[u][i].sec, type), mark[u][G[u][i].sec] = 0;\n}\n\ninline void clr() {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\ninline void solve(int u) {\n    rt = u, clr(), dfs(u, 0), clr(), dfs(u, 1);\n    for (int i = 1; i <= n; i++) if (vis[i]) ct[i][u] |= 2;\n}\n\nint ans[N * 200];\n\nint main() {\n    int m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(P(i, b)), mp[a][b] = 1;\n    for (int i = 1; i <= n; i++) sort(G[i].begin(), G[i].end());\n    for (int i = 1; i <= n; i++) solve(i);\n    for (int i = 1; i <= n; i++) for (auto v : G[i]) \n        if (ct[i][v.sec] != 0 && ct[i][v.sec] != 3) ans[v.fir] = 1;\n    for (int i = 1; i <= m; i++) puts(ans[i] ? \"diff\" : \"same\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn;\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(++pn;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid dfs1(int x)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs1(e[i].t),uu[i>>1]=1;\n}\nvoid dfs2(int x)\n{\n\tu[x]=1;\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs2(e[i].t),uu[i>>1]=1;\n}\nvoid dfs3(int*h,int x,int d,int xs,int ys)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=d&&!u[e[i].t])dfs3(h,e[i].t,d,xs,ys);\n\tif(x==xs&&!u[ys])dfs3(h,ys,d,xs,ys);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tfor(i=1;i<=n;++i)if(!u[i])dfs1(i);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=n;++i)if(!u[i])dfs2(i);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(k=c[q[j]];k;k=e[k].nx)if(!g[i][e[k].t]++)q[++qn]=e[k].t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(!uu[i]){puts(\"same\");continue;}\n\t\t\tmemset(u,0,sizeof(u));\n\t\t\tdfs3(h,x[i],i,y[i],x[i]);\n\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\tmemset(u,0,sizeof(u));\n\t\t\tdfs3(r,x[i],i,x[i],y[i]);\n\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\tputs(j>n?\"same\":\"diff\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N, M;\nvector<pair<int, int>> edge_list;\nvector<vector<int>> adj;\nvector<vector<bool>> reach;\n\nvoid reach_dfs(int source, int node) {\n    reach[source][node] = true;\n\n    for (int neighbor : adj[node])\n        if (!reach[source][neighbor])\n            reach_dfs(source, neighbor);\n}\n\nvector<vector<bool>> reach_without;\nvector<int> best_index;\n\nvoid without_dfs(int index, int node) {\n    best_index[node] = index;\n\n    for (int neighbor : adj[node])\n        if (best_index[neighbor] < 0)\n            without_dfs(index, neighbor);\n}\n\nvoid solve_reach_without(int source) {\n    reach_without[source][source] = true;\n    int neighbors = adj[source].size();\n    best_index.assign(N, -1);\n    best_index[source] = N;\n\n    for (int i = 0; i < neighbors; i++)\n        if (best_index[adj[source][i]] < 0)\n            without_dfs(i, adj[source][i]);\n\n    for (int i = 0; i < neighbors; i++) {\n        int neighbor = adj[source][i];\n\n        if (best_index[neighbor] >= 0 && best_index[neighbor] != i)\n            reach_without[source][neighbor] = true;\n    }\n\n    best_index.assign(N, -1);\n    best_index[source] = N;\n\n    for (int i = neighbors - 1; i >= 0; i--)\n        if (best_index[adj[source][i]] < 0)\n            without_dfs(i, adj[source][i]);\n\n    for (int i = 0; i < neighbors; i++) {\n        int neighbor = adj[source][i];\n\n        if (best_index[neighbor] >= 0 && best_index[neighbor] != i)\n            reach_without[source][neighbor] = true;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> M;\n    edge_list.resize(M);\n    adj.assign(N, {});\n\n    for (pair<int, int> &edge : edge_list) {\n        cin >> edge.first >> edge.second;\n        edge.first--; edge.second--;\n        adj[edge.first].push_back(edge.second);\n    }\n\n    reach.assign(N, vector<bool>(N, false));\n\n    for (int i = 0; i < N; i++)\n        reach_dfs(i, i);\n\n    reach_without.assign(N, vector<bool>(N, false));\n\n    for (int i = 0; i < N; i++)\n        solve_reach_without(i);\n\n    for (pair<int, int> &edge : edge_list) {\n        bool answer1 = reach_without[edge.first][edge.second];\n        bool answer2 = reach[edge.second][edge.first];\n        cout << (answer1 ^ answer2 ? \"diff\" : \"same\") << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <vector>\n#include <queue>\n#define PB push_back\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1010,M=1003;\nbitset<M> G[N],A[N],B;\nint n,m;\nint vis[N][2];\nint inq[N];\nqueue<int> que;\nvoid push(int u,int t) {\n\tif(!vis[u][0]) vis[u][0]=t;\n\telse if(!vis[u][1]&&vis[u][0]!=t) vis[u][1]=t,B[u]=0;\n\telse return;\n\tA[t][u]=0;\n\tif(!inq[u]) que.push(u),inq[u]=1;\n}\nint mp[N][N],p1[N][N],p2[N][N];\nvoid sol(int s) {\n//\tcout<<\"Solve\"<<s<<':';\n\tB[s]=0;\n\tfor(int i=1;i<=n;++i) if(mp[s][i]) push(i,i);\n\twhile(!que.empty()) {\n\t\tint u=que.front(); que.pop(),inq[u]=0;\n\t\twhile(1) {\n\t\t\tint v=((A[vis[u][0]]|A[vis[u][1]])&G[u]&B)._Find_first();\n\t\t\tif(v==M) break;\n\t\t\tif(vis[u][0]&&A[vis[u][0]][v]) push(v,vis[u][0]);\n\t\t\tif(vis[u][1]&&A[vis[u][1]][v]) push(v,vis[u][1]);\n\t\t}\n\t}\n//\tcout<<endl;\n\tfor(int i=1;i<=n;++i) if(s!=i) {\n\t\tp1[s][i]=vis[i][0]||vis[i][1]||mp[s][i];\n\t\tp2[s][i]=(vis[i][0]&&vis[i][0]!=i)||(vis[i][1]&&vis[i][1]!=i);\n\t}\n//\tfor(int i=1;i<=n;++i) printf(\"(%d,%d) \",vis[i][0],vis[i][1]); puts(\"\");\n\tfor(int i=1;i<=n;++i) {\n\t\tif(vis[i][0]) A[vis[i][0]][i]=1,vis[i][0]=0;\n\t\tif(vis[i][1]) A[vis[i][1]][i]=1,vis[i][1]=0;\n\t\tB[i]=1;\n\t}\n}\nvector<PII> E;\nint main() {\n\trd(n),rd(m);\n\tfor(int i=1,x,y;i<=m;++i) rd(x),rd(y),G[x][y]=mp[x][y]=1,E.PB(MP(x,y));\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) A[i][j]=1;\n\tfor(int i=1;i<=n;++i) B[i]=1;\n\tfor(int i=1;i<=n;++i) sol(i);\n//\tcout<<\"Check:\"<<p1[3][9]<<' '<<p2[9][3]<<endl;\n\tfor(int i=0;i<E.size();++i) { \n\t\tint x=E[i].fir,y=E[i].sec,flg;\n\t\tif(p1[y][x]) flg=(p2[x][y]==1);\n\t\telse flg=(p2[x][y]==0);\n\t\tif(flg) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int>E[1010];\nint n, m, b[200020][2];\nbool vis[1010], f[200020][2];\nint q[1010], h, t, l[1010], r[1010];\nint st[1010], tp;\n\nvoid dfs1(int v, int a[], int w) {\n\tvis[v] = 1, a[v] = w;\n\tfor (auto u : E[v])if (!vis[u])dfs1(u, a, w);\n}\n\nvoid work(int v) {\n\ttp = 0;\n\tfor (auto u : E[v])st[++tp] = u;\n\tmemset(vis + 1, 0, n); vis[v] = 1;\n\tfor (int i = 1; i <= tp; i++)if (!vis[st[i]])dfs1(st[i], l, i);\n\tmemset(vis + 1, 0, n); vis[v] = 1;\n\tfor (int i = tp; i; i--)if (!vis[st[i]])dfs1(st[i], r, i);\n\tfor (int i = 1; i <= m; i++)if (b[i][0] == v)f[i][0] = l[b[i][1]] != r[b[i][1]];\n}\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor (auto u : E[v])if (!vis[u])dfs(u);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tint x, y;\n\tfor (int i = 1; i <= m; i++)scanf(\"%d %d\", &x, &y), E[x].emplace_back(y), b[i][0] = x, b[i][1] = y;\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(vis + 1, 0, n);\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= m; j++)if (b[j][1] == i)f[j][1] = vis[b[j][0]];\n\t}\n\tfor (int i = 1; i <= n; i++)work(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (f[i][0] != f[i][1])puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxm 200010\n#define maxn 1010\nusing namespace std;\ntypedef long long LL;\nstruct Edge {\n    int from, to, ne;\n}edge[maxm];\nint head[maxn], ne[maxm], pre[maxm], T, tot;\nbool flag[maxn][maxn];\nint f1[maxn][maxn], f2[maxn][maxn], vis[maxn];\nvoid add(int u, int v) {\n    if (~ne[u]) pre[ne[u]] = tot;\n    else head[u] = tot;\n    edge[tot] = {u, v, ne[u]};\n    ne[u] = tot++;\n}\nvoid dfs1(int src, int u) {\n    flag[src][u] = true; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v] != T) dfs1(src, v);\n    }\n}\nvoid dfs2(int src, int exc, int u, int f[maxn][maxn]) {\n    if (~f[exc][u]) return;\n    f[exc][u] = src; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v]!=T && v!=exc) dfs2(src, exc, v, f);\n    }\n}\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    int n, m;\n    memset(ne, -1, sizeof ne);\n    memset(head, -1, sizeof head);\n    memset(f1, -1, sizeof f1);\n    memset(f2, -1, sizeof f2);\n    scanf(\"%d%d\", &n, &m);\n    F(i, 0, m) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u, v);\n    }\n//    F2(i, 1, n) printf(\"%d\\n\", head[i]);\n//    F(i, 0, m) printf(\"%d\\n\", pre[i]);\n//    F2(i, 1, n) {\n//        ++T; dfs1(i, i);\n//    }\n    F2(i, 1, n) {\n        ++T;\n        for (int j = ne[i]; ~j; j = edge[j].ne) {\n            int v = edge[j].to;\n            dfs2(j, i, edge[j].to, f1);\n        }\n        if (head[i]==-1) continue;\n        ++T;\n        for (int j = head[i]; ; j = pre[j]) {\n//            printf(\"dfs2 : %d %d\\n\", i, j);\n            int v = edge[j].to;\n            dfs2(j, i, edge[j].to, f2);\n            if (j==ne[i]) break;\n        }\n    }\n\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", flag[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f1[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f2[i][j]); puts(\"\");\n//    }\n    F(i, 0, m) {\n        int u=edge[i].from, v=edge[i].to;\n        if (f1[v][u]!=-1 ^ (f1[u][v]!=i||f2[u][v]!=i)) puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 1005;\nconst int Maxm = 200005;\n\nint n, m;\nint a[Maxm], b[Maxm];\nvector <ii> neigh[Maxn];\nint cur, tim[Maxn], low[Maxn];\nint imp[Maxm];\nint my[Maxn];\nvector <int> S;\nbool onStack[Maxn];\nint curcol, col[Maxn];\nint res[Maxm];\nvector <ii> gneigh[Maxn];\nint imp2[Maxm];\nint par[Maxn], siz[Maxn];\nvector <int> sneigh[Maxn];\nbool vis[Maxn];\n\nint Connect(int v)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tmy[v] = -1;\n\tS.push_back(v); onStack[v] = true;\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (!tim[u.first]) {\n\t\t\timp[u.second] |= 2;\n\t\t\tres += Connect(u.first); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v]) {\n\t\t\tif (my[v] != -1) imp[my[v]] ^= 1;\n\t\t\tlow[v] = tim[u.first];\n\t\t\timp[u.second] ^= 1; \n\t\t\tmy[v] = u.second;\n\t\t}\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tcurcol++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tcol[w] = curcol;\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int v, int forb)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tS.push_back(v); onStack[v] = true;\n\tif (v == b[forb]) {\n\t\tint u = a[forb];\n\t\tif (!tim[u]) {\n\t\t\tres += Count(u, forb); low[v] = min(low[v], low[u]); \n\t\t} else if (onStack[u] && tim[u] < low[v])\n\t\t\tlow[v] = tim[u];\n\t}\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (u.second == forb) continue;\n\t\tif (!tim[u.first]) {\n\t\t\tres += Count(u.first, forb); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v])\n\t\t\tlow[v] = tim[u.first];\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int forb)\n{\n\tint ans = 0;\n\tcur = 0;\n\tfill(tim, tim + Maxn, 0); fill(low, low + Maxn, 0);\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tans += Count(i, forb);\n\treturn ans; \n}\n\nint getPar(int x) { return par[x] == x? x: par[x] = getPar(par[x]); }\n\nbool unionSet(int a, int b)\n{\n\ta = getPar(a), b = getPar(b);\n\tif (a == b) return false;\n\tif (siz[a] < siz[b]) swap(a, b);\n\tsiz[a] += siz[b]; par[b] = a;\n}\n\nvoid Fill(int v)\n{\n\tif (vis[v]) return;\n\tvis[v] = true;\n\tfor (int i = 0; i < sneigh[v].size(); i++)\n\t\tFill(sneigh[v][i]);\n}\n\nbool Check(int a, int b)\n{\n\tfill(vis, vis + Maxn, false);\n\tFill(a);\n\treturn vis[b];\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\", &a[i], &b[i]);\n\t\tneigh[a[i]].push_back(ii(b[i], i));\n\t}\n\tint comp = 0;\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tcomp += Connect(i);\n\tfor (int i = 1; i <= n; i++)\n\t\tpar[i] = i, siz[i] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (col[a[i]] != col[b[i]]) {\n\t\t\tgneigh[col[a[i]]].push_back(ii(col[b[i]], i));\n\t\t\tif (unionSet(col[a[i]], col[b[i]])) {\n\t\t\t\tsneigh[col[a[i]]].push_back(col[b[i]]);\n\t\t\t\timp2[i] = true;\n\t\t\t}\n\t\t\tif (imp[i]) res[i] = Count(i) != comp;\n\t\t} else if (imp[i]) res[i] = Count(i) != comp;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!imp[i] && col[a[i]] != col[b[i]])\n\t\t\tif (imp2[i]) res[i] = Count(i) != comp;\n\t\t\telse res[i] = Check(col[a[i]], col[b[i]]);\n\t\tprintf(\"%s\\n\", res[i]? \"diff\": \"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 1010, M = 200010;\n\nint n, m;\nbool vis[N];\nvector<pair<int, int>> g[N], ig[N];\n\nbool ans[M];\n\nvoid reachable(int u) {\n  vis[u] = true;\n  for (const auto& pr : g[u])\n    if (!vis[pr.first])\n      reachable(pr.first);\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m;\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].emplace_back(v, i);\n    ig[v].emplace_back(u, i);\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    for (int rep = 0; rep < 2; ++rep) {\n      memset(vis, 0, sizeof(vis));\n      vis[i] = true;\n      for (const auto &pr : g[i])\n        if (vis[pr.first])\n          ans[pr.second] = true;\n        else\n          reachable(pr.first);\n      reverse(g[i].begin(), g[i].end());\n    }\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    reachable(i);\n    for (const auto& pr : ig[i]) {\n      int j, id;\n      tie(j, id) = pr;\n      ans[id] ^= vis[j];\n    }\n  }\n  for (int i = 1; i <= m; ++i)\n    cout << (ans[i] ? \"diff\\n\" : \"same\\n\");\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[2][N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vis[0][rt][v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++) dfs_vis(i,i);\n}\n\nvoid dfs_sol(LL u,LL col,LL pid){\n\tp[pid][u] = col;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(p[pid][v]) continue;\n\t\tdfs_sol(v,col,pid);\n\t}\n}\n\nvoid solve(LL u){\n\tfor(LL i = 1;i <= n;i ++) p[0][i] = p[1][i] = 0;\n\tp[0][u] = p[1][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!p[0][ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,0);\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!p[1][ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,1);\n\tfor(LL i = 1;i <= n;i ++) if(p[0][i] != p[1][i]) vis[1][u][i] = 1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(i);\n\t}\n\tget_vis(); memset(vis,0,sizeof(vis));\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n//\tfor(LL i = 1;i <= m;i ++) cout << ans[0][i] << ' ' << ans[1][i] << endl;\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\n// for i in f..<t { as swift\n#define forin(i, f, t) for(auto i = f; i < t; i++)\n\nusing namespace std;\nusing ll = long long;\n\nusing XY = pair<int, int>;\n\nvector<vector<int>> nodes;\nvector<bool> visited;\n\nvoid mark(int t, int c, int id, vector<int> &map) {\n    if (c == t || visited[c]) return;\n    visited[c] = true;\n    map[c] = id;\n    cerr << c << endl;\n    forin(i, 0, nodes[c].size()) {\n        mark(t, nodes[c][i], id, map);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<XY> e(m);\n    nodes.resize(n + 1);\n    forin(i, 0, m) {\n        cin >> e[i].first >> e[i].second;\n        nodes[e[i].first].push_back(e[i].second);\n    }\n    vector<vector<int>> fMap(n + 1, vector<int>(n + 1, 0)), dMap(n + 1, vector<int>(n + 1, 0));\n    forin(i, 1, n + 1) {\n        visited.assign(n + 1, false);\n        int id = 1;\n        forin(j, 0, nodes[i].size()) {\n            mark(i, nodes[i][j], id++, fMap[i]);\n        }\n        visited.assign(n + 1, false);\n        id = (int)nodes[i].size();\n        for (auto j = nodes[i].size(); j > 0; --j) {\n            mark(i, nodes[i][j - 1], id--, dMap[i]);\n        }\n    }\n    forin(i, 0, m) {\n        auto edge = e[i];\n        if ((fMap[edge.first][edge.second] != dMap[edge.first][edge.second]) == (fMap[edge.second][edge.first] > 0)) {\n            cout << \"same\" << endl;\n        } else {\n            cout << \"diff\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,id;\n}E[200005];\nint head[1005],sumE,M,N,a[200005],b[200005];\nbool a1[200005],a2[200005];\nint low[1005],dfn[1005],idx,sta[1005],top,instack[1005],col[1005],tot,cnt;\nbitset<1005> reachable[1005],block[1005],mark;\nvector<int> L[1005],v;\nvoid add(int u,int v,int id) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].id = id;\n    head[u] = sumE;\n}\n\nvoid Tarjan(int u) {\n    dfn[u] = low[u] = ++idx;\n    sta[++top] = u;\n    instack[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!dfn[v]) {Tarjan(v);low[u] = min(low[v],low[u]);}\n\telse if(instack[v] == 1) low[u] = min(low[u],dfn[v]);\n    }\n    if(low[u] == dfn[u]) {\n\t++tot;\n\twhile(1) {\n\t    int x = sta[top--];\n\t    col[x] = tot;\n\t    L[tot].pb(x);\n\t    instack[x] = 2;\n\t    if(x == u) break;\n\t}\n\tint s = L[tot].size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    block[tot][L[tot][i]] = 1;\n\t}\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    reachable[L[tot][i]] = block[tot];\n\t}\n    }\n}\nvoid dfs(int u) {\n    if(mark[u]) return;\n    mark[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(!mark[v]) {\n\t    if(col[v] != col[u]) mark |= reachable[v];\n\t    else dfs(v);\n\t}\n    }\n}\nvoid Solve() {\n    read(N);read(M);\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(a[i]);read(b[i]);\n\tadd(a[i],b[i],i);\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(!dfn[i]) Tarjan(i);\n    }\n    \n    for(int i = 1 ; i <= tot ; ++i) {\n\tint s = L[i][0];\n\tfor(auto k : L[i]) {\n\t    for(int j = head[k] ; j ; j = E[j].next) {\n\t\tint v = E[j].to;\n\t\tif(reachable[s][v]) continue;\n\t\tif(col[v] != i) {reachable[s] |= reachable[v];}  \n\t    }\n\t}\n\tfor(auto k : L[i]) {\n\t    if(k != s) reachable[k] |= reachable[s];\n\t}\n    }\n    \n    for(int u = 1 ; u <= N ; ++u) {\n\tv.clear();\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    v.pb(E[i].id);\n\t}\n\tmark.reset();\n\tmark[u] = 1;\n\tint s = v.size();\n\tfor(int i = 0 ; i < s ; ++i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    if(col[b[v[i]]] != col[u]) mark |= reachable[b[v[i]]];\n\t    else dfs(b[v[i]]);\n\t}\n\tmark.reset();\n\tmark[u] = 1;\n\tfor(int i = s - 1 ; i >= 0 ; --i) {\n\t    a2[v[i]] |= mark[b[v[i]]];\n\t    if(col[b[v[i]]] != col[u]) mark |= reachable[b[v[i]]];\n\t    else dfs(b[v[i]]);\n\t}\n    }\n    for(int i = 1 ; i <= M ; ++i) {\n\tif(reachable[b[i]][a[i]]) a1[i] = 1;\n\tif(a1[i] ^ a2[i]) puts(\"diff\");\n\telse puts(\"same\");\n    }\n    \n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint vis[1000];\nstd::bitset<1000> bs[1000];\nstd::bitset<1000> bs2[1000];\nstd::bitset<1000> bs3[1000];\nstd::pair<int,int> p[200003];\nint n,m;\nint q[1000],qa,qb;\nint vis1[1000],vis2[1000];;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0;i < m;++i) {\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);--a,--b;\n\t\tp[i].first = a;p[i].second = b;\n\t\tbs[a][b] = 1;\n\t}\n\tfor(int i = 0;i < n;++i) {\n\t\tq[0] = i;qa = 0;qb = 1;bs2[i][i] = 1;\n\t\twhile(qa < qb) {\n\t\t\tint cur = q[qa++];\n\t\t\tstd::bitset<1000> nex = ~bs2[i]&bs[cur];\n\t\t\tbs2[i] |= nex;\n\t\t\tfor(int j = 0;j < n;++j) if(nex[j]) q[qb++] = j;\n\t\t}\n\t}\n\t// 0->2?\n\tfor(int i = 0;i < n;++i) {\n\t\tmemset(vis1,-1,sizeof(vis1));\n\t\tmemset(vis2,-1,sizeof(vis2));\n\t\tfor(int j = 0;j < n;++j) if(bs[i][j] && vis1[j] == -1) {\n\t\t\tq[0] = j;qa = 0;qb = 1;vis1[j] = j;\n\t\t\twhile(qa < qb) {\n\t\t\t\tint cur = q[qa++];\n\t\t\t\tfor(int k = 0;k < n;++k) if(k!=i && bs[cur][k] && vis1[k]==-1) {\n\t\t\t\t\tvis1[k] = j;\n\t\t\t\t\tq[qb++] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = n-1;j >= 0;--j) if(bs[i][j] && vis2[j] == -1) {\n\t\t\tq[0] = j;qa = 0;qb = 1;vis2[j] = j;\n\t\t\twhile(qa < qb) {\n\t\t\t\tint cur = q[qa++];\n\t\t\t\tfor(int k = 0;k < n;++k) if(k!=i && bs[cur][k] && vis2[k]==-1) {\n\t\t\t\t\tvis2[k] = j;\n\t\t\t\t\tq[qb++] = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < n;++j) if(vis1[j] != vis2[j]) bs3[i][j] = 1;\n\t}\n\tfor(int i = 0;i < m;++i) {\n\t\tint a = p[i].first, b = p[i].second;\n\t\tif(bs2[b][a] == bs3[a][b]) {\n\t\t\tprintf(\"same\\n\");\n\t\t} else {\n\t\t\tprintf(\"diff\\n\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 1010;\nconst int M = 200010;\n\nint n, m, cnt, x[M], y[M], a[2][N][N];\nvector <int> v[N];\n\nvoid dfs(int fl, int x, int st, int fir)\n{\n    a[fl][st][x] = fir;\n    for(int i = 0; i < v[x].size(); ++i)\n        if (!a[fl][st][v[x][i]]) dfs(fl, v[x][i], st, fir);\n}\n\nchar B[1 << 26], *S = B;\n#define getchar() (*S++)\nint read()\n{\n    int x = 0; char c = getchar();\n    while (c < '0' || c > '9') c = getchar();\n    while (c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = getchar();}\n    return x;\n}\n\nint main()\n{\n    fread(B, 1, 1 << 26, stdin);\n    n = read(); m = read();\n    FOR(i, 1, m)\n    {\n        x[i] = read(); y[i] = read();\n        v[x[i]].push_back(y[i]);\n    }\n    FOR(i, 1, n)\n    {\n        a[0][i][i] = a[1][i][i] = i;\n        for(int j = 0; j < v[i].size(); ++j) if (!a[0][i][v[i][j]]) dfs(0, v[i][j], i, v[i][j]);\n        if (v[i].size()) for(int j = v[i].size() - 1; ~j; --j) if (!a[1][i][v[i][j]]) dfs(1, v[i][j], i, v[i][j]);\n    }\n    FOR(i, 1, m) if (((bool) a[0][y[i]][x[i]]) ^ (a[0][x[i]][y[i]] != a[1][x[i]][y[i]]))\n        puts(\"diff\"); else puts(\"same\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace SCC {\n\tconst int N = 110000;\n\tvector<int> con[N], rcon[N];\n\tint n, vis[N], visT;\n\tint id[N], idn;\n\tvoid init(int nn = 0) {\n\t\tn = nn, visT = idn = 0;\n\t\tfor (int i = 1; i <= n; i++) con[i].clear(), rcon[i].clear();\n\t}\n\tvoid add_edge(int u, int v) {\n\t\tcon[u].push_back(v);\n\t\trcon[v].push_back(u);\n\t}\n\tvoid dfs(int u) {\n\t\tvis[u] = 1;\n\t\tfor (int v : con[u]) if (!vis[v]) dfs(v);\n\t\tid[idn++] = u;\n\t}\n\tvoid rdfs(int u) {\n\t\tvis[u] = visT;\n\t\tfor (int v : rcon[u]) if (!vis[v]) rdfs(v);\n\t}\n\tvoid SCC() {\n\t\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\t\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n\t\tfor (int i = idn - 1; i >= 0; i--) if (!vis[id[i]]) visT++, rdfs(id[i]);\n\t}\n};\n\nconst int N = 1100;\nconst int M = 220000;\n\nvector<int> con[N];\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u = 0, int v = 0) : u(u), v(v) {}\n} E[M];\n\nint adj[N][N];\nint que[N], vis[N], visT;\n\ninline bool Find(int u, int tar) {\n\tif (adj[u][tar] > 1) return true;\n\tint hd = 0, tl = 0;\n\tvisT++;\n\tque[tl++] = u, vis[u] = visT;\n\twhile (hd < tl) {\n\t\tint cur = que[hd++];\n\t\tfor (int v : con[cur]) if (vis[v] != visT) {\n\t\t\tif (cur == u && v == tar) continue;\n\t\t\tif (v == tar) return true;\n\t\t\tvis[v] = visT, que[tl++] = v;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tint n, m; cin >> n >> m;\n\tSCC::init(n + 10);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tE[i] = Edge(u, v);\n\t\tcon[u].push_back(v);\n\t\tadj[u][v]++;\n\t\tSCC::add_edge(u, v);\n\t}\n\tSCC::SCC();\n\tfor (int i = 0; i < m; i++) {\n\t\tauto a = SCC::vis[E[i].u], b = SCC::vis[E[i].v];\n\t\tif (a == b) {\n\t\t\tif (Find(E[i].u, E[i].v)) cout << \"same\\n\";\n\t\t\telse cout << \"diff\\n\";\n\t\t} else {\n\t\t\tif (Find(E[i].u, E[i].v)) cout << \"diff\\n\";\n\t\t\telse cout << \"same\\n\";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define maxn 1005\n\nusing namespace std;\n\nstruct nod{\n\tint nex,id;\n\tnod(int a,int b){nex=a;id=b;}\n\tnod(){}\n};\nint n,m,tim;\nint vis[maxn];\nint bel[maxn][maxn][2];\nint u[maxn*maxn],v[maxn*maxn];\nvector<nod>edge[maxn];\n\ninline void dfs(int now,int fa,int b,int f)\n{\n\tvis[now]=tim; bel[fa][now][f]=b;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,fa,b,f);\n}\n\ninline void solve(int now)\n{\n\ttim++;vis[now]=tim;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)if(vis[edge[now][i].nex]!=tim)\n\t\tdfs(edge[now][i].nex,now,edge[now][i].id,0);\n\treverse(edge[now].begin(),edge[now].end());\n\ttim++;vis[now]=tim;\n\tfor(int i=0;i<len;i++)if(vis[edge[now][i].nex]!=tim)dfs(edge[now][i].nex,now,edge[now][i].id,1);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)solve(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif((bel[v[i]][u[i]][0]!=0)^(bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i))printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long \n#define rint register int\nusing namespace std;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\nconst int N = 2333;\nint dfn[N], low[N], dfs_clock = 0;\nint S[N], top = 0, scc_cnt = 0, sccno[N];\nint c[N], d[N], a[N][N];\nint n, m, ans[N * N];\nvector<int> g[N];\n\ninline void tarjan(int u, int fat) {\n  dfn[u] = low[u] = ++ dfs_clock;\n  S[++ top] = u;\n  for (int v : g[u]) {\n    if (!dfn[v]) {\n      tarjan(v, u);\n      low[u] = min(low[u], low[v]);\n    }\n    else if (!sccno[v])\n      low[u] = min(low[u], dfn[v]);\n  }\n  if (low[u] == dfn[u]) {\n    ++ scc_cnt;\n    for (;;) {\n      int v = S[top --];\n      sccno[v] = scc_cnt;\n      if (v == u) break;\n    }\n  }\n}\n\ninline void dfs1(int u, int cl) {\n  if (c[u]) return ;\n  c[u] = cl;\n  for (int v : g[u])\n    dfs1(v, cl);\n}\n\ninline void dfs2(int u, int cl) {\n  if (d[u]) return ;\n  d[u] = cl;\n  for (int v : g[u])\n    dfs2(v, cl);\n}\n\nmain(void) {\n  read(n); read(m);\n  for (int i = 1; i <= m; i ++) {\n    int x, y; read(x); read(y);\n    a[x][y] = i; g[x].push_back(y);\n  }\n  for (int i = 1; i <= n; i ++)\n    if (!dfn[i]) tarjan(i, 0);\n  // for (int i = 1; i <= n; i ++)\n  //   cout << sccno[i] << \" \"; puts(\"\");\n  for (int i = 1; i <= n; i ++) {\n    memset(c, 0, sizeof c); \n    sort(g[i].begin(), g[i].end());\n    c[i] = i;\n    for (int v : g[i])\n      dfs1(v, v);\n    \n    memset(d, 0, sizeof d);\n    reverse(g[i].begin(), g[i].end());\n    d[i] = i;\n    for (int v : g[i])\n      dfs2(v, v);\n    \n    // cout << i << \"qwq\\n\";\n    // for (int v = 1; v <= n; v ++)\n    //   cout << c[v] << \" \"; puts(\"\");\n    // for (int v = 1; v <= n; v ++)\n    //   cout << d[v] << \" \"; puts(\"\");\n    for (int v : g[i])\n      ans[a[i][v]] = (sccno[i] == sccno[v]) ^ (c[v] != d[v]);\n  }\n  for (int i = 1; i <= m; i ++)\n    puts(ans[i] ? \"diff\" : \"same\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass korasaju{\nprivate:\n    const int default_size = 100100;\n    vector<vector<int> > normal;\n    vector<vector<int> > reverso;\n    vector<int> visited;\n    vector<int> component;\n    int number_of_components;\n    int my_size;\npublic:\n    korasaju(){\n        my_size = default_size;\n        clear();\n    }\n    korasaju(int size){\n        my_size = size;\n        clear();\n    }\n    void clear(){\n        normal.assign(my_size, vector<int>());\n        reverso.assign(my_size, vector<int>());\n        visited.assign(my_size, 0);\n        component.assign(my_size, 0);\n        number_of_components = 0;\n    }\n    void addEdge(int u, int v){\n        normal[u].push_back(v);\n        reverso[v].push_back(u);\n    }\n    void dfsNormal(vector<int> & passed_by, int cur){\n        visited[cur] = 1;\n        for(int nxt : normal[cur])\n            if(! visited[nxt] )\n                dfsNormal(passed_by, nxt);\n        passed_by.push_back(cur);\n    }\n    void dfsReverso(vector<int> & passed_by, int cur){\n        visited[cur] = 1;\n        for(int nxt : reverso[cur])\n            if(! visited[nxt] )\n                dfsReverso(passed_by, nxt);\n        passed_by.push_back(cur);\n    }\n    void build(){\n        number_of_components = 0;\n        vector<int> topological_sort;\n        fill(visited.begin(), visited.end(), 0);\n        for(int e = 0; e < my_size; e++)\n            if(!visited[e])\n                dfsNormal(topological_sort, e);\n        reverse(topological_sort.begin(), topological_sort.end());\n        fill(visited.begin(), visited.end(), 0);\n        for(int vertex : topological_sort){\n            if(!visited[vertex]){\n                vector<int> novo_component;\n                dfsReverso(novo_component, vertex);\n                for(int vertex_on_component : novo_component)\n                    component[vertex_on_component] = number_of_components;\n                number_of_components++;\n            }\n        }\n    }\n    int getNumberOfComponents(){\n        return number_of_components;\n    }\n    int getComponentOfVertex(int vertex){\n        return component[vertex];\n    }\n    vector<int> getComponent(){\n        return component;\n    }\n    vector<vector<int> > getDagComponent(){\n        vector<vector<int> > dag;\n        dag.resize(number_of_components);\n        for(int u = 0; u < my_size; u++)\n            for(int v : normal[u])\n                if(getComponentOfVertex(u) != getComponentOfVertex(v))\n                    dag[getComponentOfVertex(u)].push_back(getComponentOfVertex(v));\n        for(int e = 0; e < number_of_components; e++){\n            sort(dag[e].begin(), dag[e].end());\n            dag[e].erase(unique(dag[e].begin(), dag[e].end()), dag[e].end());\n        }\n        return dag;\n    }\n};\nconst int maxn = 1111;\nusing bs = bitset<maxn>;\nvector<int> en[maxn], er[maxn], dag[maxn];\nint vis[maxn], visn[maxn], visr[maxn];\nvector<pair<int,int> > taked;\nbs reach[maxn];\nvoid dfs(int i){\n\tif(vis[i]) return;\n\tvis[i] = 1;\n\treach[i].set(i);\n\tfor(auto e : dag[i]){\n\t\tdfs(e);\n\t\treach[i] |= reach[e];\n\t}\n}\nvoid dfsn(int i){\n\tvisn[i] = 1;\n\tfor(auto e : en[i]){\n\t\tif(!visn[e]){\n\t\t\ttaked.push_back({i, e});\n\t\t\tdfsn(e);\n\t\t}\n\t}\n}\nvoid dfsr(int i){\n\tvisr[i] = 1;\n\tfor(auto e : er[i]){\n\t\tif(!visr[e]){\n\t\t\ttaked.push_back({i, e});\n\t\t\tdfsr(e);\n\t\t}\n\t}\n}\nint main(){\n\tint n, m; cin >> n >> m;\n\tkorasaju ko(n);\n\tvector<pair<int,int>> eds;\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tko.addEdge(u, v);\n\t\teds.push_back({u, v});\n\t}\n\tko.build();\n\tint ncmp = ko.getNumberOfComponents();\n\tset<pair<int,int> > good_edges;\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v; tie(u, v) = eds[i];\n\t\tint nu = ko.getComponentOfVertex(u);\n\t\tint nv = ko.getComponentOfVertex(v);\n\t\tif(nu != nv){\n\t\t\tdag[nu].push_back(nv);\n\t\t} else {\n\t\t\ten[u].push_back(v);\n\t\t\ter[v].push_back(u);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(!visn[i]){\n\t\t\tdfsn(i);\n\t\t\tfor(auto e : taked) good_edges.insert(e);\n\t\t\ttaked.clear();\n\t\t}\n\t\tif(!visr[i]){\n\t\t\tdfsr(i);\n\t\t\tfor(auto e : taked){\n\t\t\t\tswap(e.first, e.second);\n\t\t\t\tgood_edges.insert(e);\n\t\t\t}\n\t\t\ttaked.clear();\n\t\t}\n\t}\n\tfor(int i = 0; i < ncmp; i++){\n\t\tdfs(i);\n\t}\n\tauto count_cmp = [&](){\n\t\tkorasaju meh(n);\n\t\tfor(auto e : eds){\n\t\t\tint u, v; tie(u, v) = e;\n\t\t\tmeh.addEdge(u, v);\n\t\t}\n\t\tmeh.build();\n\t\treturn meh.getNumberOfComponents();\n\t};\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v; tie(u, v) = eds[i];\n\t\tint nu = ko.getComponentOfVertex(u);\n\t\tint nv = ko.getComponentOfVertex(v);\n\t\tif(nu != nv){\n\t\t\tbool can = false;\n\t\t\tfor(auto to : dag[nu]){\n\t\t\t\tif(to == nv) continue;\n\t\t\t\tif(reach[to][nv]) can = true;\n\t\t\t}\n\t\t\tif(can) printf(\"diff\\n\");\n\t\t\telse printf(\"same\\n\");\n\t\t} else {\n\t\t\tif(good_edges.count({u, v})){\n\t\t\t\teds[i] = {v, u};\n\t\t\t\tif(count_cmp() == ncmp) printf(\"same\\n\");\n\t\t\t\telse printf(\"diff\\n\");\n\t\t\t\teds[i] = {u, v};\t\n\t\t\t} else {\n\t\t\t\tprintf(\"same\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//copied\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1200\n#define M 300000\n\nint n,m,x[M],y[M],vis[2][N][N];\nvector<int> vec[N];\n\nvoid dfs(int op,int o,int u,int k){\n\tif (vis[op][o][u]) return;\n\tvis[op][o][u]=k;\n\tfor (int i=0;i<(int)vec[u].size();++i)\n\t\tdfs(op,o,vec[u][i],k);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;++i){scanf(\"%d%d\",&x[i],&y[i]); vec[x[i]].push_back(y[i]);}\n\tfor (int i=1;i<=n;++i){\n\t\tvis[0][i][i]=vis[1][i][i]=1;\n\t\tfor (int j=0;j<(int)vec[i].size();++j)\n\t\t\tdfs(0,i,vec[i][j],j+1);\n\t\tif (vec[i].size())\n\t\t\tfor (int j=(int)vec[i].size()-1;j>=0;--j)\n\t\t\t\tdfs(1,i,vec[i][j],j+1);\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tint u=x[i],v=y[i];\n\t\tputs((vis[0][u][v]!=vis[1][u][v])^(vis[0][v][u]>0)?\"diff\":\"same\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    if(vis1[u]) return;\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    if(vis2[u]) return;\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    /*\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=2;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            dfs1(e[i][j],j+1);\n        for(int j=up-1;j>=0;j--)\n            dfs2(e[i][j],j+1);\n        for(int j=1;j<=n;j++)\n            if(vis1[j])\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    */\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n//#define int long long\n//#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nusing bset = bitset<6>;\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    bools used, ok;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        used.resize(N);\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //SCC decomposition\n    void dfs(int v, vector<bool> &used, vec &vs){\n        used[v] = true;\n        REP(i, G[v].size()){\n            if(!used[G[v][i].to]) dfs(G[v][i].to, used, vs);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k, vector<bool> &used, vec &cmp){\n        used[v] = true;\n        cmp[v] = k;\n        REP(i, G[v].size()){\n            if(!used[G[v][i].to]) rdfs(G[v][i].to, k, used, cmp);\n        }\n    }\n    //u->v => cmp[u]<cmp[v]\n    vec scc(int &k){\n        vector<bool> used(N, false);\n        vec vs(0), cmp(N);\n        REP(i, N){\n            if(!used[i]) dfs(i, used, vs);\n        }\n        //reverse graph\n        Graph rG(N);\n        REP(v, N) REP(i, G[v].size()) rG.add_Directed_edge(G[v][i].to, v, G[v][i].cost);\n\n        fill(used.begin(), used.end(), false);\n        k = 0;\n        IREP(i, vs.size()){\n            if(!used[vs[i]]) rG.rdfs(vs[i], k++, used, cmp);\n        }\n        return cmp;\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        for(auto e: G[v]) if(!used[e.to]) dfs(e.to);\n    }\n\n    void check(){\n        REP(v, N){\n            fill(all(used), false);\n            used[v] = true;\n            REP(k, SZ(G[v])){\n                auto e = G[v][k];\n                if(used[e.to]) ok[e.id] = true;\n                dfs(e.to);\n            }\n\n            fill(all(used), false);\n            used[v] = true;\n            IREP(k, SZ(G[v])){\n                auto e = G[v][k];\n                if(used[e.to]) ok[e.id] = true;\n                dfs(e.to);\n            }\n        }\n    }\n\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec a(M), b(M);\n    REP(i, M){\n        cin >> a[i] >> b[i];\n        a[i]--; b[i]--;\n        G.add_Directed_edge(a[i], b[i], 1, i);\n    }\n    G.ok = bools(M, false);\n\n    int K;\n    vec cmp = G.scc(K);\n\n    G.check();\n\n    bools ans(M);\n    REP(i, M) ans[i] = ((cmp[a[i]] == cmp[b[i]]) == G.ok[i]);\n\n    REP(i, M){\n        Ans(ans[i], \"same\", \"diff\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\ninline void read(int &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=x*10+(c^48);\n}\n\nnamespace o_o\n{\n\tconst int N=1010,M=200100;\n\n\tbool g[N][N],ans[N][N];\n\tint f0[N],f1[N];\n\n\tstd::vector<int>G[N];\n\n\tvoid Dfs(int p,int h,int *f)\n\t{\n\t\tif(f[p])return;f[p]=h;\n\t\tfor(int i=0;i<(int)G[p].size();i++)\n\t\t\tDfs(G[p][i],h,f);\n\t}\n\n\tint n,m;\n\n\tinline void work(int p)\n\t{\n\t\tmemset(f0,0,sizeof(f0)),memset(f1,0,sizeof(f1));\n\t\tf0[p]=f1[p]=2333;\n\n\t\tfor(int i=0;i<(int)G[p].size();i++)\n\t\t\tDfs(G[p][i],G[p][i],f0);\n\t\tfor(int i=G[p].size()-1;~i;i--)\n\t\t\tDfs(G[p][i],G[p][i],f1);\n\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[p][i]=f0[i]!=f1[i],g[p][i]=(f0[i] || f1[i]);\n\t}\n\n\tint E[M][2];\n\n\tvoid solve()\n\t{\n\t\tread(n),read(m);\n\t\tfor(int i=1,u,v;i<=m;i++)\n\t\t\tread(u),read(v),E[i][0]=u,E[i][1]=v,G[u].push_back(v);\n\n\t\tfor(int p=1;p<=n;p++)work(p);\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint u=E[i][0],v=E[i][1];\n\t\t\tif(g[v][u]^ans[u][v])printf(\"diff\\n\");\n\t\t\telse printf(\"same\\n\");\n\t\t}\n\t}\n}\n\nint main()\n{\n\to_o::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<vector<pair<int,int> > > graph;\n\n#define ALL(obj) (obj).begin(), (obj).end() \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n\nbool dfs_condition_1(graph g,vector<bool> &check,int now,int dest){\n    if(now==dest) return true;\n    check[now-1] = true;\n    //cout << now << endl;\n    rep(i,g[now-1].size()){\n        if(!check[g[now-1][i].second-1]){ \n            if(dfs_condition_1(g, check,g[now-1][i].second,dest)) return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs_condition_2(graph g,vector<int> &check,int num, int now,int a){\n\n    if(check[now-1]==-1) check[now-1] = num;\n          \n    rep(i,g[now-1].size()){\n        if(g[now-1][i].second!=a && check[g[now-1][i].second-1]==-1) dfs_condition_2(g, check, num, g[now-1][i].second, a);\n\n    }\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<pair<pair<int,int>, int> > e(m);\n    rep(i,m){\n        int a,b; \n        cin >> a; \n        cin >> b; \n        e[i] = make_pair(make_pair(a,b), i);\n    }\n    graph g(n);\n    sort(ALL(e));\n    int j=0;\n    rep(i,n){\n        while(j<m && e[j].first.first==i+1){\n            g[i].push_back(e[j].first);\n            j++;\n        }\n    }\n   \n    vector<bool> cf(m), cs(m);\n     \n    rep(i,m){\n        vector<bool> check(n);\n        cf[e[i].second] = dfs_condition_1(g, check, e[i].first.second, e[i].first.first);\n    } \n \n    rep(i,n){\n        vector<int> cmax(n),cmin(n);\n        rep(k,n){cmax[k]=-1; cmin[k]=-1;}\n        rep(k,g[i].size()){\n            dfs_condition_2(g, cmin, k, g[i][k].second, i+1);\n        }\n\n        rep(k,g[i].size()){\n            dfs_condition_2(g, cmax, g[i].size() - k - 1, g[i][g[i].size() - k - 1].second, i+1);\n        }\n        //rep(k,n) cout << cmax[k] << endl;\n        pair<pair<int,int>, int> pp = make_pair(make_pair(i + 1, 0), 0);\n        vector<pair<pair<int,int>, int> >::iterator itr = lower_bound(e.begin(), e.end(), pp);\n        rep(k,g[i].size()){\n           if(cmax[g[i][k].second-1]==k && cmin[g[i][k].second-1]==k) cs[(*itr++).second]=true;\n        }\n\n    }\n    //rep(i,m) if(cf[i]) cout << i+1 << \": cf true\" << endl;\n    //rep(i,m) if(cs[i]) cout << i+1 << \": cs true\" << endl;\n    rep(i,m){\n        if((cf[i]||cs[i])&&!(cf[i]&&cs[i])) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define maxn 200100\nusing namespace std;\nint n,m,tot,head[1010],th[1010][1010];\nbool vis[1010];\nstruct point{\n\tint fr,to,nxt;\n}a[maxn];\nvoid add(int x,int y)\n{\n\ta[++tot].fr=x;\n\ta[tot].to=y;\n\ta[tot].nxt=head[x];\n\thead[x]=tot;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tvis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tdfs(a[i].to,s,cur);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=head[i];j;j=a[j].nxt) dfs(a[j].to,i,j);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].fr,y=a[i].to;\n\t\tif((th[y][x]&&th[x][y]!=-1)||(!th[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <vector>\n#include <queue>\n#define PB push_back\n#define PII pair<int,int>\n#define MP make_pair\n#define fir first\n#define sec second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1010,M=1003;\nbitset<M> G[N],A[N],B;\nint n,m;\nint vis[N][2];\nint inq[N];\nqueue<int> que;\nvoid push(int u,int t) {\n\tif(!vis[u][0]) vis[u][0]=t;\n\telse if(!vis[u][1]&&vis[u][0]!=t) vis[u][1]=t,B[u]=0;\n\telse return;\n\tA[t][u]=0;\n\tif(!inq[u]) que.push(u),inq[u]=1;\n}\nint mp[N][N],p1[N][N],p2[N][N];\nvoid sol(int s) {\n\tB[s]=0;\n\tfor(int i=1;i<=n;++i) if(mp[s][i]) push(i,i);\n\twhile(!que.empty()) {\n\t\tint u=que.front(); que.pop(),inq[u]=0;\n\t\twhile(1) {\n\t\t\tint v=((A[vis[u][0]]|A[vis[u][1]])&G[u]&B)._Find_first();\n\t\t\tif(v==M) break;\n\t\t\tif(vis[u][0]) push(v,vis[u][0]);\n          \tif(vis[u][1]) push(v,vis[u][1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) if(s!=i) {\n\t\tp1[s][i]=vis[i][0]||vis[i][1]||mp[s][i];\n\t\tp2[s][i]=(vis[i][0]&&vis[i][0]!=i)||(vis[i][1]&&vis[i][1]!=i);\n\t}\n\tfor(int i=1;i<=n;++i) {\n\t\tif(vis[i][0]) A[vis[i][0]][i]=1,vis[i][0]=0;\n\t\tif(vis[i][1]) A[vis[i][1]][i]=1,vis[i][1]=0;\n\t\tB[i]=1;\n\t}\n}\nvector<PII> E;\nint main() {\n\trd(n),rd(m);\n\tfor(int i=1,x,y;i<=m;++i) rd(x),rd(y),G[x][y]=mp[x][y]=1,E.PB(MP(x,y));\n\tfor(int i=1;i<=n;++i) for(int j=1;j<=n;++j) A[i][j]=1;\n\tfor(int i=1;i<=n;++i) B[i]=1;\n\tfor(int i=1;i<=n;++i) sol(i);\n\tfor(int i=0;i<E.size();++i) { \n\t\tint x=E[i].fir,y=E[i].sec,flg;\n\t\tif(p1[y][x]) flg=(p2[x][y]==1);\n\t\telse flg=(p2[x][y]==0);\n\t\tif(flg) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\nvector <pii> G[N],T[N];\nint n,m,ans[N],x[N],y[N];\nbool vis[N];\nvoid dfs0 (int u)\n{\n\tvis[u]=1;\n\tfor (pii x:G[u])\n\t\tif (!vis[x.fi]) dfs0 (x.fi);\n}\nint p[N],q[N];\nvoid dfs00 (int u,int rt,bool fg)\n{\n\tif (!fg) { if (!p[u]) p[u]=rt; }\n\telse { if (!q[u]) q[u]=rt; }\n\tvis[u]=1;\n\tfor (pii x:G[u])\n\t\tif (!vis[x.fi]) dfs00 (x.fi,rt,fg);\n}\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tsc(x[i]),sc(y[i]);\n\t\tG[x[i]].pb (mp(y[i],i));\n\t\tT[y[i]].pb (mp(x[i],i));\n\t}\n\tfor (int u=1; u<=n; u++)\n\t{\n\t\tmemset (vis,0,sizeof (bool)*(n+1));\n\t\tdfs0 (u);\n\t\tfor (pii x:T[u])\n\t\t\tif (vis[x.fi]) ans[x.se]=1;\n\t}\n\tfor (int u=3; u<=n; u++)\n\t{\n\t\tmemset (p,0,sizeof (int)*(n+1)),memset (q,0,sizeof (int)*(n+1));\n\t\tmemset (vis,0,sizeof (bool)*(n+1)),vis[u]=1;\n\t\tfor (pii x:G[u])\n\t\t\tdfs00 (x.fi,x.fi,0);\n\t\treverse (G[u].begin (),G[u].end ());\n\t\tmemset (vis,0,sizeof (bool)*(n+1)),vis[u]=1;\n\t\tfor (pii x:G[u])\n\t\t\tdfs00 (x.fi,x.fi,1);\n\t\tfor (pii x:G[u])\n\t\t\tif (p[x.fi]!=q[x.fi]) ans[x.se]^=1;\n\t}\n\tfor (int i=1; i<=m; i++)\n\t\tputs(ans[i]?\"diff\":\"same\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n\ninline void read(int &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=x*10+(c^48);\n}\n\nnamespace o_o\n{\n\tconst int N=1010,M=200100;\n\n//\tbool g[N][N],ans[N][N];\n//\tint f0[N],f1[N];\n\n\tint f[N][N],vis[N];\n\n\tstd::vector<int>G[N];\n\n\tvoid Dfs(int p,int h,int fk)\n\t{\n\t\tif(f[h][p]>1 || p==h || vis[p]==fk)return;\n\t\tvis[p]=fk;\n\n\t\tf[h][p]++;\n\n\t\tfor(int i=0;i<(int)G[p].size();i++)\n\t\t\tDfs(G[p][i],h,fk);\n//\t\tfor(auto q:G[p])\n//\t\t{\n//\t\t\tDfs(q,h,fk);\n//\t\t}\n\t}\n\n\tint n,m;\n\n\tint E[M][2];\n\n\tvoid solve()\n\t{\n\t\tread(n),read(m);\n\t\tfor(int i=1,u,v;i<=m;i++)\n\t\t\tread(u),read(v),E[i][0]=u,E[i][1]=v,G[u].push_back(v);\n\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n//\t\t\tif(i%100==0)fprintf(stderr,\"i = %d\\n\",i);\n//\t\t\twork(i);\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tfor(auto q:G[i])Dfs(q,i,q);\n\t\t}\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint u=E[i][0],v=E[i][1];\n\t\t\tif((f[v][u]>=1)^(f[u][v]>=2))printf(\"diff\\n\");\n\t\t\telse printf(\"same\\n\");\n\t\t}\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n//\tfreopen(\"D.out\",\"w\",stdout);\n\to_o::solve();\n//\tfprintf(stderr,\"time = %lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<1)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],z[M],vis[N],p[N][N],q[N][N];\nvector<int> e[N];\nvoid dfs(int st,int u){\n\tvis[u]=1; a[st][u]=1;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs(st,v);\n\t}\n}\nvoid dfs1(int st,int u,int id){\n\tvis[u]=1; p[st][u]=id;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs1(st,v,id);\n\t}\n}\nvoid dfs2(int st,int u,int id){\n\tvis[u]=1; q[st][u]=id;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs2(st,v,id);\n\t}\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read(); z[i]=(int)e[x[i]].size();\n\t\te[x[i]].push_back(y[i]);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(i,i);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\trep (j,0,(int)e[i].size()-1) if (!vis[e[i][j]]) dfs1(i,e[i][j],j);\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\tper (j,(int)e[i].size()-1,0) if (!vis[e[i][j]]){\n\t\t\tdfs2(i,e[i][j],j);\n\t\t}\n\t}\n\t//printf(\"%d\\n\",a[3][1]);\n\t//printf(\"%d %d\\n\",p[1][3],q[1][3]);\n\t//printf(\"%d\\n\",a[4][3]);\n\t//printf(\"%d %d\\n\",p[3][4],q[3][4]);\n\trep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]];\n\t\tbool f2=p[x[i]][y[i]]!=z[i] || q[x[i]][y[i]]!=z[i];\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e3 + 3;\n\nvector < pp > V[N],U[N];\nvector < int > Y[N]; \nint D[N],low[N],zaman,H[N],Scc[N],scc,T[N],ans[N],n,m,x,y,i,X;\nstack < int > S;\n\nvoid f(int x){\n    D[x] = low[x] = ++zaman;\n    S.push(x); H[x] = 1;\n    for(auto t : V[x]){\n        int y = t.st;\n        if(y == X) continue;\n        if(!D[y]){ f(y); low[x] = min(low[x] , low[y]); }\n        else if(H[y]) low[x] = min(low[x] , D[y]); \n    }\n    \n    if(low[x] == D[x]){\n        scc++;\n        for(int y = 0; y != x;){\n            y = S.top();\n            S.pop();\n            H[y] = 0;\n            Scc[y] = scc;\n            Y[scc].pb(y);\n        }        \n    }\n}\n\nvoid g(int x){\n    X = x;\n    int i;\n    memset(D , zaman=0 , sizeof D);\n    memset(Scc , scc=0 , sizeof Scc);\n    for(i=1;i<=n;i++) { Y[i].clear(); U[i].clear(); }\n    for(i=1;i<=n;i++) if(i != X && !D[i]) f(i);\n    if(x == 0){\n        for(i=1;i<=n;i++) T[i] = Scc[i];\n        return;\n    }\n\n    memset(D , 0 , sizeof D);\n    for(auto t : V[X]){\n        U[ Scc[t.st] ].pb(t);\n    }\n    for(i=scc; i ;i--){\n        if(!D[i] && U[i].size() == 0) continue;\n        if(D[i] || U[i].size() > 1){\n            for(auto t : U[i]){\n                ans[t.nd] = T[X] == T[t.st];\n            }\n        }\n        else { for(auto t : U[i]) ans[t.nd] = T[X] != T[t.st]; }\n        \n        for(auto x : Y[i]){\n            for(auto y : V[x])\n                D[ Scc[y.st] ] = 1;    \n        }\n    }\n}\n\nsigned main(){\n    cin >> n >> m;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d\",&x,&y);\n        V[x].pb(mp(y,i));\n    }\n    \n    for(i=0;i<=n;i++) g(i);\n    for(i=1;i<=m;i++) puts(ans[i] ? \"same\" : \"diff\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 1010;\nconst int M = 200010;\n\nstruct edge{int to, next;} e[M];\nint n, m, cnt, x[M], y[M], head[N], a[2][N][N];\nbitset <N> p[N];\n\nvoid ins(int x, int y)\n{\n    e[++cnt].to = y; e[cnt].next = head[x]; head[x] = cnt;\n}\n\nvoid dfs(int fl, int x, int st, int fir)\n{\n    a[fl][st][x] = fir;\n    for(int i = head[x]; i; i = e[i].next)\n        if (e[i].to != st && !a[fl][st][e[i].to]) dfs(fl, e[i].to, st, fir);\n}\n\nchar B[1 << 26], *S = B;\n#define getchar() (*S++)\nint read()\n{\n    int x = 0; char c = getchar();\n    while (c < '0' || c > '9') c = getchar();\n    while (c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = getchar();}\n    return x;\n}\n\nint main()\n{\n    fread(B, 1, 1 << 26, stdin);\n    n = read(); m = read();\n    FOR(i, 1, m)\n    {\n        x[i] = read(); y[i] = read();\n        p[x[i]][y[i]] = 1;\n        ins(x[i], y[i]);\n    }\n    FOR(i, 1, n) FOR(j, 1, n) if (p[i][j] && !a[0][i][j]) dfs(0, j, i, j);\n    FOR(i, 1, n) for(int j = n; j; --j) if (p[i][j] && !a[1][i][j]) dfs(1, j, i, j);\n    FOR(i, 1, n) FOR(j, 1, n) if (p[j][i]) p[j] |= p[i];\n    FOR(i, 1, m) if (p[y[i]][x[i]] ^ (a[0][x[i]][y[i]] != y[i] || a[1][x[i]][y[i]] != y[i])) puts(\"diff\"); else puts(\"same\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, M = 200233;\nint n, m;\nbool ok1[M], ok2[M], visit[N];\nvector<pair<int, int>> G[N], rG[N];\nvoid dfs(int x) {\n  visit[x] = true;\n  for (auto y : G[x]) if (!visit[y.first]) dfs(y.first);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1, x, y; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    G[x].emplace_back(y, i);\n    rG[y].emplace_back(x, i);\n  }\n  for (int x = 1; x <= n; x++) {\n    for (int j = 1; j <= n; j++) visit[j] = false;\n    dfs(x);\n    for (auto y : rG[x]) ok1[y.second] = visit[y.first];\n    for (int j = 1; j <= n; j++) visit[j] = false;\n    visit[x] = true;\n    for (auto y : G[x]) ok2[y.second] |= visit[y.first], dfs(y.first);\n    reverse(G[x].begin(), G[x].end());\n    for (int j = 1; j <= n; j++) visit[j] = false;\n    visit[x] = true;\n    for (auto y : G[x]) ok2[y.second] |= visit[y.first], dfs(y.first);\n  }\n  for (int i = 1; i <= m; i++) {\n    puts(ok1[i] == ok2[i] ? \"same\" : \"diff\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 64) {\n    int l = _, r = min< int >(g[idx].size(), _ + 64);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else {\n          dp[e.first] |= dp[p];\n        }\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\nbool v[2000][2000];\n\nvoid dfs2(int idx, int idx2) {\n  if(v[idx][idx2]++) return;\n  for(auto &to : g[idx]) dfs2(to.first, idx2);\n}\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  for(int i = 0; i < N; i++) {\n    random_shuffle(begin(g[i]), end(g[i]));\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n    dfs2(i, i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (v[Y[i]][Y[i]]) ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1005\n#define M 200005\nusing namespace std;\n\nint n,m;\nbool irp[N][N],lnk[N][N];\nint rt,cnt,fir[N];\nbool col[N];\nvector<int>to[N];\nstruct edge{int u,v;}e[M];\n\ninline int read()\n{\n\tint ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\ninline void add(int a,int b){to[a].push_back(b);e[++cnt]=(edge){a,b};}\n\ninline void dfs(int x)\n{\n\tcol[x]=lnk[rt][x]=1;\n\tfor(auto it:to[x]) if(!col[it]) dfs(it);\n}\n\ninline void insert(int x)\n{\n\trt=x;\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(int i=0;i<to[x].size();++i)\n\t\tif(col[to[x][i]]) irp[x][to[x][i]]=1;\n\t\telse dfs(to[x][i]);\n\treverse(to[x].begin(),to[x].end());\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(int i=0;i<to[x].size();++i)\n\t\tif(col[to[x][i]]) irp[x][to[x][i]]=1;\n\t\telse dfs(to[x][i]);\n}\n\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint a=read(),b=read();\n\t\tadd(a,b);\n\t}\n\tfor(int i=1;i<=n;++i)insert(i);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x=e[i].u,y=e[i].v;\n\t\tputs(irp[x][y]^lnk[y][x]?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int id)\n{\n\tSCC scc; scc.init(n);\n\tint cntscc=0;\n\tfor(int i=0;i<edges.size();i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tif(i==id) swap(u,v);\n\t\tscc.addedge(u,v);\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcntscc=max(cntscc,scc.sccidx[i]);\n\t}\n\tif(cntscc!=mxscc) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,x);\n\t}\n}\n\nbool reach[1111][1111];\nmap<ii,int> CNT;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i][i]=1;\n\t\tqueue<int> q; q.push(i);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front(); q.pop();\n\t\t\tfor(ii x:adj[u])\n\t\t\t{\n\t\t\t\tint v=x.fi; \n\t\t\t\tif(!reach[v]) q.push(v);\n\t\t\t\treach[i][v]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tbool pos=0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j==i) continue;\n\t\t\t\t\tif(j==v) continue;\n\t\t\t\t\tif(reach[i][j]&&reach[j][v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpos=1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N],d[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N][2];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs(int u,int fa,int k,int opt)\n{\n    vis[u]=true;mp[fa][u][opt]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!vis[v])\n            dfs(v,fa,k,opt);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n        d[U[i]].push_back(i);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis,false,sizeof(vis));\n        vis[i]=true;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,d[i][j],0);\n        memset(vis,false,sizeof(vis));\n        vis[i]=true;\n        for(int j=up-1;j>=0;j--)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,d[i][j],1);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]][0]!=mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]][0]==mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n\ntypedef pair<int, int> P;\n\n#define fir first\n#define sec second\n\nvector<P> G[N];\n\nbool mark[N][N], mp[N][N], vis[N]; int ct[N][N];\n\nint rt, n; \n\nvoid dfs(int u, int type) {\n    vis[u] = 1;\n    if (mp[rt][u] && !mark[rt][u]) ct[rt][u] |= 1;\n    if (!type) {\n        for (auto v : G[u]) if (!vis[v.sec])\n            mark[u][v.sec] = 1, dfs(v.sec, type), mark[u][v.sec] = 0;\n    } else for (int i = G[u].size() - 1; i >= 0; i--) if (!vis[G[u][i].sec])\n        mark[u][G[u][i].sec] = 1, dfs(G[u][i].sec, type), mark[u][G[u][i].sec] = 0;\n}\n\ninline void clr() {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\ninline void solve(int u) {\n    rt = u, clr(), dfs(u, 0), clr(), dfs(u, 1);\n    for (int i = 1; i <= n; i++) if (vis[i]) ct[i][u] |= 2;\n}\n\nint ans[N * 20];\n\nint main() {\n    int m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(P(i, b)), mp[a][b] = 1;\n    for (int i = 1; i <= n; i++) sort(G[i].begin(), G[i].end());\n    for (int i = 1; i <= n; i++) solve(i);\n    for (int i = 1; i <= n; i++) for (auto v : G[i]) \n        if (ct[i][v.sec] != 0 && ct[i][v.sec] != 3) ans[v.fir] = 1;\n    for (int i = 1; i <= m; i++) puts(ans[i] ? \"diff\" : \"same\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*200][2],g[N],a[N*200][2];\nauto F=f[0];\nbool bz[N],bz1[N],bz2[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    bz2[x]=1;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1])){\n                bz1[x]|=bz1[y];\n                continue;\n            }\n            if (!F[y][0]){\n                F[y][0]=v;\n                if (!bz2[y])dfs(y,s,v);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum){\n                    bz2[x]=0;\n                    return;\n                }\n                if (bz1[y]&&!bz2[y])dfs(y,s,v);\n            }\n        }\n    bz2[x]=0;\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int>graph[1005] , rgraph[1005];\n\nbool vis[1005];\nvector<int>order;\nint comp[1005];\nint cp = 0;\n\nvoid dfs1(int u)\n{\n\tvis[u] = true;\n\tfor(int i = 0; i < graph[u].size(); i++)\n\t{\n\t\tint v = graph[u][i];\n\t\tif(!vis[v])\n\t\t\tdfs1(v);\n\t}\n\torder.push_back(u);\n}\n\n\nvoid dfs2(int u)\n{\n\tvis[u] = true;\n\tcomp[u] = cp;\n\tfor(int i = 0; i < rgraph[u].size(); i++)\n\t{\n\t\tint v = rgraph[u][i];\n\t\tif(!vis[v])\n\t\t\tdfs2(v);\n\t}\n}\n\nvoid dfs(int u)\n{\n\tvis[u] = 1;\n\tfor(int i = 0; i < graph[u].size(); i++)\n\t{\n\t\tif(!vis[graph[u][i]])\n\t\t\tdfs(graph[u][i]);\n\t}\n}\nmap<pair<int,int>, bool>ans;\nvector<pair<int,int> >e;\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i = 0 ; i < m ; i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tgraph[u].push_back(v);\n\t\trgraph[v].push_back(u);\n\t\te.push_back({u,v});\n\t\tans[e.back()] = 0;\n\t}\n\tfor(int i = 1 ; i <= n; i++)\n\t{\n\t\tif(!vis[i])\n\t\t\tdfs1(i);\n\t}\n\tmemset(vis,0,sizeof(vis));\n\treverse(order.begin(),order.end());\n\n\tfor(int i = 0 ; i < order.size(); i++)\n\t{\n\t\tint v = order[i];\n\t\tif(!vis[v])\n\t\t{\n\t\t\tdfs2(v);\n\t\t\tcp++;\n\t\t}\n\t}\n\tmemset(vis,0,sizeof(vis));\n\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\t\n\t\tvis[i] = 1;\n\t\t//cout << i << \": \";\n\t\tfor(int j = 0 ; j < graph[i].size(); j++)\n\t\t{\n\t\t\tint v = graph[i][j];\n\t\t\tif(vis[v])\n\t\t\t{\n\t\t\t//\tcout <<  v<< \"  \";\n\t\t\t\tans[{i,v}] = 1;\n\t\t\t}\n\t\t\tdfs(v);\n\t\t}\n\t\t//cout << endl;\n\n\t\treverse(graph[i].begin(),graph[i].end());\n\n\t\tmemset(vis,0,sizeof(vis));\n\n\t\tvis[i] = 1;\n\t\t\n\t\tfor(int j = 0 ; j < graph[i].size(); j++)\n\t\t{\n\t\t\tint v = graph[i][j];\n\t\t\tif(vis[v])\n\t\t\t{\n\t\t\t//\tcout <<  v<< \" ** \";\n\t\t\t\tans[{i,v}] = 1;\n\t\t\t}\n\t\t\tdfs(v);\n\t\t}\n\t\t//cout << endl;\n\t}\n\t//cout << cp << endl;\n\tfor(int i = 0; i < e.size(); i++)\n\t{\n\t\tif(comp[e[i].first] != comp[e[i].second])\n\t\t\tans[e[i]] ^= 1;\n\t\tif(ans[e[i]])\n\t\t\tputs(\"same\");\n\t\telse\n\t\t\tputs(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=1010,M=1000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst double eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\nint n,m;\nvector< pii > G1[N],G2[N];\n\nbool visit[N],ans[M];\ninline void dfs(int x)\n{\n\tvisit[x]=true;\n\tint sz=G1[x].size();\n\tfor(int i=0;i<sz;i++)\n\t{\n\t\tint y=G1[x][i].first;\n\t\tif(visit[y]) continue;\n\t\tdfs(y);\n\t}\n}\n\n#ifdef FILE\nconst int READ_SIZE=1<<20;\nchar buf[READ_SIZE],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,READ_SIZE,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tG1[x].push_back(mp(y,i));\n\t\tG2[y].push_back(mp(x,i));\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tmem(visit,false);\n\t\tvisit[x]=true;\n\t\tint sz=G1[x].size();\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tint y=G1[x][i].first,id=G1[x][i].second;\n//\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\tfor(int i=1;i<=n;i++) cerr<<visit[i]<<\" \";\n//\t\t\tcerr<<\"\\n\";\n\t\t\tif(visit[y]) ans[id]=true;\n\t\t\tdfs(y);\n\t\t}\n\t\t\n\t\tmem(visit,false);\n\t\tvisit[x]=true;\n\t\tfor(int i=sz-1;i>=0;i--)\n\t\t{\n\t\t\tint y=G1[x][i].first,id=G1[x][i].second;\n//\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\tfor(int i=1;i<=n;i++) cerr<<visit[i]<<\" \";\n//\t\t\tcerr<<\"\\n\";\n\t\t\tif(visit[y]) ans[id]=true;\n\t\t\tdfs(y);\n\t\t}\n\t}\n//\tfor(int i=1;i<=m;i++) cerr<<ans[i]<<\" \";\n//\tcerr<<\"\\n\";\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tmem(visit,false);\n\t\tdfs(x);\n\t\tint sz=G2[x].size();\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tint y=G2[x][i].first,id=G2[x][i].second;\n\t\t\tif(visit[y]) ans[id]^=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(ans[i]) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 19:17 - \n#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define lch (o << 1)\n#define rch (o << 1 | 1)\n\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> pint;\n\nconst int N = 1000 + 5;\nconst int M = 2e5 + 5;\nconst int INF = 0x3f3f3f3f;\nconst ll INF_LL = 0x3f3f3f3f3f3f3f3f;\n\nstruct Adj{\n\tint v, id;\n};\nvector<Adj> a[N];\n\nvoid DFS(int u, int ban, int eid, int vst[]){\n\tif(u == ban || vst[u]) return;\n\tvst[u] = eid;\n\tfor(auto e: a[u])\n\t\tDFS(e.v, ban, eid, vst);\n}\n\nint vst[2][N];\nbool g[N][N], ok[M];\n\nint main(){\n\tios::sync_with_stdio(0);\n\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tstatic pint edg[M];\n\tfor(int i=1; i<=m; i++){\n\t\tint u, v; cin >> u >> v;\n\t\ta[u].push_back((Adj){v, i});\n\t\tedg[i] = make_pair(u, v);\n\t}\n\n\tfor(int i=1; i<=n; i++){\n\t\tmemset(vst, 0, sizeof(vst));\n\t\tfor(auto e: a[i])\n\t\t\tDFS(e.v, i, e.id, vst[0]);\n\t\treverse(a[i].begin(), a[i].end());\n\t\tfor(auto e: a[i]){\n\t\t\tDFS(e.v, i, e.id, vst[1]);\n\t\t\tif(vst[0][e.v] != vst[1][e.v])\n\t\t\t\tok[e.id] = 1;\n\t\t}\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tif(vst[0][j])\n\t\t\t\tg[i][j] = 1;\n\t}\n\n\tfor(int i=1; i<=m; i++){\n\t\tint u = edg[i].fi, v = edg[i].se;\n\t\tif(ok[i] ^ g[v][u]) cout << \"diff\\n\";\n\t\telse cout << \"same\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define maxn 2000100\nusing namespace std;\nint n,m,tot,vis[1010],head[1010],dis[1010][1010],th[1010][1010];\nstruct point{\n\tint fr,to,nxt;\n}a[maxn];\nvoid add(int x,int y)\n{\n\ta[++tot].fr=x;\n\ta[tot].to=y;\n\ta[tot].nxt=head[x];\n\thead[x]=tot;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tdis[s][x]=1; vis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tdfs(a[i].to,s,cur);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=head[i];j;j=a[j].nxt) dfs(a[j].to,i,j);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].fr,y=a[i].to;\n\t\tif((dis[y][x]&&th[x][y]!=-1)||(!dis[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=1000 +117;\nconst int MM=200000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nvector<int> p[NN]={};\nvector<int> rp[NN]={};\nmap<pair<int,int>,int> id;\nbool ans[NN]={};\nint fir[NN]={};\nint las[NN]={};\nvoid col(int vis[],int x,int c){\n\tif(vis[x])return ;\n\tvis[x]=c;\n\tfor(int i=0;i<p[x].size();++i){\n\t\tcol(vis,p[x][i],c);\n\t}\n}\nvoid getvis(int x){\n\tfor(int i=1;i<=n;++i){\n\t\tfir[i]=las[i]=0;\n\t}\n\tfir[x]=las[x]=-1;\n\tfor(int j=0;j<p[x].size();++j){\n\t\tcol(fir,p[x][j],j+1);\n\t}\n\tfor(int j=p[x].size()-1;j>=0;--j){\n\t\tcol(las,p[x][j],j+1);\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tm=read();\n\tfor(int i=1;i<=m;++i){\n\t\tint x=read(),y=read();\n\t\tp[x].push_back(y);\n\t\trp[y].push_back(x);\n\t\tid[make_pair(x,y)]=i;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tgetvis(i);\n\t\tfor(int j=0;j<rp[i].size();++j){\n\t\t\tint cur=rp[i][j];\n\t\t\tbool fl=0;\n\t\t\tif(fir[cur])fl=1;\n\t\t\tans[id[make_pair(cur,i)]]^=fl;\n\t\t}\n\t\tfor(int j=0;j<p[i].size();++j){\n\t\t\tint cur=p[i][j];\n\t\t\tif(fir[cur]!=j+1||las[cur]!=j+1){\n\t\t\t\tans[id[make_pair(i,cur)]]^=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(ans[i])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn;\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(++pn;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(int*h,int x,int z)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])d1(h,e[i].t,z),uu[i>>1]|=z;\n}\nvoid d2(int*h,int x,int d,int xs,int ys)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=d&&!u[e[i].t])d2(h,e[i].t,d,xs,ys);\n\tif(x==xs&&!u[ys])d2(h,ys,d,xs,ys);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tfor(i=1;i<=n;++i)if(!u[i])d1(h,i,1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=n;++i)if(!u[i])d1(r,i,2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(k=c[q[j]];k;k=e[k].nx)if(!g[i][e[k].t]++)q[++qn]=e[k].t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i])\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,x[i],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i])\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,x[i],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 64) {\n\n\n    int l = _, r = min< int >(g[idx].size(), _ + 64);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else dp[e.first] |= dp[p];\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nvector<int> g[maxn];\nint a[maxm], b[maxm];\nint v[maxn][maxn], w[maxn][maxn], vis2[maxn];\nint rt;\n\nvoid add(int a,int b){g[a].push_back(b);}\n\nvoid dfs2(int u) {\n\tv[rt][u] = vis2[u] = 1;\n\tfor (auto y: g[u]) {\n\t\tif (!vis2[y]) dfs2(y);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", a+i, b+i);\n\t\tadd(a[i], b[i]);\n\t}\n\tfor (rt = 1; rt <= n; ++rt) {\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis2[rt] = 1;\n\t\tfor (auto x: g[rt]) {\n\t\t\tif (!vis2[x]) dfs2(x);\n\t\t\telse w[rt][x] = 1;\n\t\t}\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis2[rt] = 1;\n\t\treverse(g[rt].begin(), g[rt].end());\n\t\tfor (auto x: g[rt]) {\n\t\t\tif (!vis2[x]) dfs2(x);\n\t\t\telse w[rt][x] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tputs(v[b[i]][a[i]]^w[a[i]][b[i]]?\"diff\":\"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int sccid, int id)\n{\n\tSCC scc; \n\tvi coord; vector<ii> E;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tif(lab==id) swap(u,v);\n\t\tE.pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tE[i].fi=lower_bound(coord.begin(),coord.end(),E[i].fi)-coord.begin();\n\t\tE[i].se=lower_bound(coord.begin(),coord.end(),E[i].se)-coord.begin();\n\t}\n\tscc.init(coord.size());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tscc.addedge(E[i].fi,E[i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\n\nbool reach[1111][1111];\nmap<ii,int> CNT;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i][i]=1;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tif(!reach[i][j]) continue;\n\t\t\tfor(ii x:adj[j])\n\t\t\t{\n\t\t\t\treach[i][x.fi]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tbool pos=0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j==i) continue;\n\t\t\t\t\tif(j==v) continue;\n\t\t\t\t\tif(reach[i][j]&&reach[j][v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpos=1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 1000\n#define MM 200000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nvector<int> v[MN+5],w[MN+5],V[MN+5],W[MN+5];\nint n,m,bel[MN+5],head[MN+5],cnt,Ans[MM+5],q[MN+5],cc,in[MN+5],now;\nint top,dfn[MN+5],low[MN+5],c[MN+5],num,dn,inq[MN+5],mx[MN+5],mn[MN+5],f[MN+5];\nstruct edge{int to,next,w;}e[MN+5];\ninline void ins(int f,int t,int w){e[++cnt]=(edge){t,head[f],w};head[f]=cnt;}\nvoid MarkMn(int x,int c)\n{\n\tmn[x]=c;\n\tfor(int i=0;i<v[x].size();++i) \n\t\tif(!(x==now&&i+1>c)&&mn[v[x][i]]==n) MarkMn(v[x][i],c);\n}\nvoid MarkMx(int x,int c)\n{\n\tmx[x]=c;\n\tfor(int i=0;i<v[x].size();++i) \n\t\tif(!(x==now&&i+1<c)&&!mx[v[x][i]]) MarkMx(v[x][i],c);\n}\nvoid Solve()\n{\n\tfor(int i=1;i<=num;++i) for(int j=head[c[i]];j;j=e[j].next) \n\t\tif(bel[e[j].to]==cc) v[c[i]].push_back(e[j].to),w[c[i]].push_back(e[j].w);\n\tfor(int i=1;i<=num;++i)\n\t{\n\t\tfor(int j=1;j<=num;++j) mx[c[j]]=0,mn[c[j]]=n;now=c[i];\n\t\tfor(int j=0;j<v[c[i]].size();++j) if(mn[v[c[i]][j]]==n) MarkMn(v[c[i]][j],j+1);\n\t\tfor(int j=v[c[i]].size()-1;~j;--j) if(!mx[v[c[i]][j]]) MarkMx(v[c[i]][j],j+1);\n\t\tfor(int j=1;j<=num;++j) \n\t\t\tif(i!=j&&mn[c[j]]==mx[c[j]]) Ans[w[c[i]][mn[c[j]]-1]]=1;\n\t}\n}\nvoid Tarjan(int x)\n{\n\tdfn[x]=low[x]=++dn;q[++top]=x;inq[x]=1;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(!dfn[e[i].to]) Tarjan(e[i].to),low[x]=min(low[x],low[e[i].to]);\n\t\telse if(inq[e[i].to]) low[x]=min(low[x],dfn[e[i].to]);\n\tif(dfn[x]==low[x])\n\t{\n\t\tfor(num=0,++cc;q[top+1]!=x;inq[q[top--]]=0) c[++num]=q[top],bel[q[top]]=cc;\n\t\tSolve();\t\n\t}\n}\ninline void R(int&x,int y){x=min(2,x+y);}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1,j;i<=m;++i) j=read(),ins(j,read(),i);\n\tfor(int i=1;i<=n;++i) if(!dfn[i]) Tarjan(i); \n\tfor(int i=1;i<=n;++i) for(int j=head[i];j;j=e[j].next) if(bel[i]!=bel[e[j].to]) \n\t\tV[bel[i]].push_back(bel[e[j].to]),W[bel[i]].push_back(e[j].w);\n\tfor(int i=1;i<=cc;++i)\n\t{\n\t\tmemset(f,0,sizeof(f));memset(in,0,sizeof(in));\n\t\tfor(int j=1;j<=cc;++j) for(int k=0;k<V[j].size();++k) ++in[V[j][k]];\n\t\tf[i]=1;q[top=1]=i;\n\t\tfor(int j=1;j<=top;++j)\n\t\t\tfor(int k=0;k<V[q[j]].size();++k)\n\t\t\t\tif(R(f[V[q[j]][k]],f[q[j]]),!--in[V[q[j]][k]]) q[++top]=V[q[j]][k];\n\t\tfor(int j=0;j<V[i].size();++j) if(f[V[i][j]]!=1) Ans[W[i][j]]=1;\n\t}\n\tfor(int i=1;i<=m;++i) puts(Ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#define lowbit(i) (i&(-i))\n#define ll long long\n#define mid ((l+r)>>1)\nusing namespace std;\nconst int N=1005,M=2e5+5;\nint n,m;\nstruct st\n{\n\tint from,nxt,to,ans;\n}ed[M]; int head[N],num;\nvoid add(int from,int to)\n{\n\ted[++num].to=to,ed[num].from=from;\n\ted[num].nxt=head[from];\n\thead[from]=num;\n}\nint stk[N],top,dfn[N],low[N],refl[N],t,numb; bool cn[N];\nvoid tarjan(int x)\n{\n\tdfn[x]=low[x]=++numb,stk[++top]=x,cn[x]=1;\n\tfor(int u,i=head[x];i;i=ed[i].nxt)\n\t{\n\t\tu=ed[i].to;\n\t\tif(!dfn[u])tarjan(u),low[x]=min(low[x],low[u]);\n\t\telse if(cn[u])low[x]=min(low[x],dfn[u]);\n\t}\n\tif(dfn[x]==low[x])\n\t{\n\t\t++t;\n\t\twhile(stk[top]!=x)\n\t\t\trefl[stk[top]]=t,cn[stk[top]]=0,--top;\n\t\trefl[stk[top]]=t,cn[stk[top]]=0,--top;\n\t}\n}\nint fir[2][N];\nvoid dfs(int x,int id,int typ)\n{\n\tif(fir[typ][x])return; fir[typ][x]=id;\n\tfor(int u,i=head[x];i;i=ed[i].nxt)\n\t{\n\t\tu=ed[i].to;\n\t\tif(!fir[typ][u])dfs(u,id,typ);\n\t}\n}\nint E[M],tot;\nint main()\n{\n\tint u,v; scanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&u,&v),add(u,v);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);\n\tfor(int i=1;i<=m;i++)if(refl[ed[i].to]==refl[ed[i].from])ed[i].ans=1;\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tfor(int i=1;i<=n;i++)fir[0][i]=fir[1][i]=0;\n\t\tfir[0][x]=fir[1][x]=1,tot=0;\n\t\tfor(int i=head[x];i;i=ed[i].nxt)E[++tot]=i;\n\t\tfor(int i=1;i<=tot;i++)dfs(ed[E[i]].to,E[i],0);\n\t\tfor(int i=tot;i;i--)dfs(ed[E[i]].to,E[i],1);\n\t\tfor(int i=head[x];i;i=ed[i].nxt)\n\t\t\tif(fir[0][ed[i].to]!=i||fir[1][ed[i].to]!=i)ed[i].ans++;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(ed[i].ans==1)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}\n/*\n3 3\n1 2\n2 3\n1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:108777216\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nint const MAXN = 1024;\n\nint n,m,sm[MAXN][MAXN],sm1[MAXN][MAXN],num,nnew[MAXN],lst[MAXN],e_ind[MAXN][MAXN],ans[256 * MAXN];\nint bg[256*MAXN], en[256*MAXN];\nint swp_flag[MAXN][MAXN], SWPF = 0;\n\nvoid dfs1(int v) {\n\tnnew[v]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!nnew[i] && sm[v][i]) dfs1(i);\n\tlst[num]=v;\n\tnum--;\n}\n\nvoid dfs2(int v) {\n\tnnew[v]=num;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!nnew[i] && sm[v][i]) dfs2(i);\n}\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n    \n    int m;\n    scanf(\"%d%d\",&n,&m);\n    for (int i=0; i<m; i++) {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        sm[a][b] = 1;\n        e_ind[a][b] = i;\n        bg[i] = a; en[i] = b;\n    }\n\n    fill(nnew,nnew+n+1,0);\n    num=n;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!nnew[i]) dfs1(i);\n\tnum=0;\n\tfill(nnew,nnew+n+1,0);\n    SWPF++;\n    for (int i=0; i<m; i++)\n        if (swp_flag[bg[i]][en[i]] != SWPF) {\n            swap(sm[bg[i]][en[i]], sm[en[i]][bg[i]]);\n            swp_flag[bg[i]][en[i]] = swp_flag[en[i]][bg[i]] = SWPF;\n        }\n\tfor (int i=1; i<=n; i++)\n\t\tif (!nnew[lst[i]]) {\n\t\t\tnum++;\n\t\t\tdfs2(lst[i]);\n\t\t}\n    SWPF++;\n    for (int i=0; i<m; i++)\n        if (swp_flag[bg[i]][en[i]] != SWPF) {\n            swap(sm[bg[i]][en[i]], sm[en[i]][bg[i]]);\n            swp_flag[bg[i]][en[i]] = swp_flag[en[i]][bg[i]] = SWPF;\n        }\n    int init_num = num;\n\n    for (int a=1; a<=n; a++)\n        for (int b=1; b<=n; b++)\n            if (sm[a][b]) {\n                sm[a][b]--;\n                sm[b][a]++;\n\n                fill(nnew,nnew+n+1,0);\n                num=n;\n\t            for (int i=1; i<=n; i++)\n\t\t            if (!nnew[i]) dfs1(i);\n\t            num=0;\n\t            fill(nnew,nnew+n+1,0);\n    SWPF++;\n    for (int i=0; i<m; i++)\n        if (swp_flag[bg[i]][en[i]] != SWPF) {\n            swap(sm[bg[i]][en[i]], sm[en[i]][bg[i]]);\n            swp_flag[bg[i]][en[i]] = swp_flag[en[i]][bg[i]] = SWPF;\n        }\n\t            for (int i=1; i<=n; i++)\n\t\t            if (!nnew[lst[i]]) {\n\t\t\t            num++;\n                        if (num > init_num) break;\n\t\t\t            dfs2(lst[i]);\n\t\t            }\n    SWPF++;\n    for (int i=0; i<m; i++)\n        if (swp_flag[bg[i]][en[i]] != SWPF) {\n            swap(sm[bg[i]][en[i]], sm[en[i]][bg[i]]);\n            swp_flag[bg[i]][en[i]] = swp_flag[en[i]][bg[i]] = SWPF;\n        }\n\n                if (num == init_num)\n                    ans[e_ind[a][b]] = 1;\n                else\n                    ans[e_ind[a][b]] = 0;\n\n                sm[a][b]++;\n                sm[b][a]--;\n            }\n\n    for (int i=0; i<m; i++)\n        if (ans[i]) printf(\"same\\n\");\n        else printf(\"diff\\n\");\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nconst int MV = 1003;\nconst int ME = 200005;\n\nint n, m;\nint fst[MV], nxt[ME], u[ME], v[ME], lnum;\nint way1[MV][MV], way2[MV][MV], dir[MV][MV];\n\nvoid addeg(int nu, int nv)\n{\n\tnxt[++lnum] = fst[nu];\n\tfst[nu] = lnum;\n\tu[lnum] = nu;\n\tv[lnum] = nv;\n}\n\nvoid input()\n{\n\tread(n), read(m);\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tread(a), read(b);\n\t\tdir[a][b]++;\n\t\taddeg(a, b);\n\t}\n}\n\nbool ban[MV];\n\nvoid dfs(int x, int *s)\n{\n\tif(!ban[x]) s[x]++;\n\tfor(int i=fst[x]; i; i=nxt[i])\n\t\tif(!s[v[i]] && !ban[v[i]])\n\t\t\tdfs(v[i], s);\n}\n\nvoid work()\n{\n\tfor(int x=1; x<=n; x++)\n\t{\n\t\tban[x] = 1;\n\t\tvector<int> out;\n\t\tfor(int i=fst[x]; i; i=nxt[i]) out.push_back(v[i]);\n\t\tfor(int i=0; i<out.size(); i++) ban[out[i]] = 1, dfs(out[i], way1[x]), ban[out[i]] = 0;\n\t\tfor(int i=out.size()-1; i>=0; i--) ban[out[i]] = 1, dfs(out[i], way2[x]), ban[out[i]] = 0;\n\t\tban[x] = 0;\n\t}\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tdir[i][j] += way1[i][j]+way2[i][j];\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a = u[i], b = v[i];\n\t\tif(dir[a][b]==1 && !dir[b][a]) puts(\"same\");\n\t\telse if(dir[a][b]>=2 && !dir[b][a]) puts(\"diff\");\n\t\telse if(dir[a][b]==1 && dir[b][a]) puts(\"diff\");\n\t\telse if(dir[a][b]>=2 && dir[b][a]) puts(\"same\");\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/extc++.h>\n#include<bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector,O3\")\nusing namespace std;using ll = long long;using ull = unsigned long long;using ul = unsigned;using db = double;using __gnu_pbds::null_type;\n#ifdef _debug \n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) 0&&0\n#endif\n#define eout(i) {cout << (i) << '\\n';exit(0);}\n#define priority_queue __gnu_pbds::priority_queue\n#define unordered_map __gnu_pbds::gp_hash_table\n#define rep(a, b) {for(int i = a;i > 0;--i){b;}}\n#define multe int T;for(cin >> T;T--;)\npair<long long, long long> ext_gcd(long long a, long long b){if(a % b == 0)return {0ll, 1ll};auto get = ext_gcd(b, a % b);return {get.second, get.first - a / b * get.second};}\nlong long ext_inv(long long a, long long p){return (ext_gcd(a, p).first + p) % p;}\nvector<int> kfunc(string &w){vector<int> k(w.size());for(int q = 0, i = 1;i < w.size();++i){for(;q > 0 and w[i] != w[q];q = k[q-1]);k[i] = (q += w[i] == w[q]);}return k;}\nvector<int> zfunc(string &w){vector<int> z(w.size());z[0] = w.size();for(int l = 0, i = 1;i < w.size();++i){z[i] = max(0, min(l+z[l] - i, z[i-l]));for(;i+z[i] < w.size() and w[i+z[i]] == w[z[i]];++z[i])l = i;}return z;}\ntemplate<typename T> using rbtree = __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T> inline long long pow(long long v, long long t, const T &p){long long res = 1;for(;t;t >>= 1, v = v * v % p)if(t & 1)res = res * v % p;return res;}\ntemplate<typename T> inline void floyd_warshall(vector<vector<T>> &dp){for(int i = 0;i < dp.size();++i)for(int j = 0;j < dp.size();++j)for(int k = 0;k < dp.size();++k)dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k]);}\ntemplate<typename T> inline ostream& operator << (ostream &ou, const vector<T> &a){for(auto it = a.begin();it != a.end();++it)ou << (it != a.begin() ? \" \" : \"\") << *it;return ou;}\ntemplate<typename T> inline vector<vector<T>> operator * (const vector<vector<T>> &a, const vector<vector<T>> &b){assert(a.front().size() == b.size());vector<vector<T>> res(a.size(), vector<T>(b.front().size()));for(int i = 0;i < a.size();++i)for(int j = 0;j < b.front().size();++j)for(int k = 0;k < a.front().size();++k)res[i][j] += a[i][k] * b[k][j];return res;}\ntemplate<typename T> inline vector<vector<T>> pow(vector<vector<T>> v, long long t){vector<vector<T>> res;for(;t;t >>= 1, v = v * v)if(t & 1)res = (res.empty() ? v : res * v);return res;}\ntemplate<typename T> void read(int n, T *s){while(n--)cin >> *s, ++s;}\ntemplate<typename T> void read(int n, vector<T> &v){for(int i = 0;i < n;++i)cin >> v[i];}\ntemplate<typename T> void write(int n, T *s){while(n--)cout << *s << \" \\n\"[n==0], ++s;}\ntemplate<typename T1, typename T2>inline istream& operator >> (istream &in, pair<T1, T2> &a){return in >> a.first >> a.second;}\ntemplate<typename T1, typename T2>inline ostream& operator << (ostream &ou, const pair<T1, T2> &b){return ou << b.first << ' ' << b.second;}\ntemplate<typename T1, typename T2>inline pair<T1,T2> operator + (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first + b.first, a.second + b.second};}\ntemplate<typename T1, typename T2>inline pair<T1,T2> operator - (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first - b.first, a.second - b.second};}\ntemplate<typename T1, typename T2>inline long long operator ^ (const pair<T1,T2> &a, const pair<T1,T2> &b){return (long long)a.first * b.second - (long long)a.second * b.first;}\nconst int maxn = 1010;\nint n, m;\nvector<pair<int,int>> alle;\nvector<int> edge[maxn];\nvector<vector<int>> dp;\nint g[maxn];\nvoid dfs(int now){\n\tstatic int low[maxn], d = 0, id = 1, onpath[maxn];\n\tif(onpath[now])return;\n\tlow[now] = ++d;\n\tonpath[now] = true;\n\tfor(int &i : edge[now]){\n\t\tif(onpath[i] || !low[i]){\n\t\t\tdfs(i), low[now] = min(low[now], low[i]);\n\t\t\tif(low[i] > d)++id;\n\t\t}\n\t}\n\tg[now] = id; \n\tonpath[now] = false;\n\t--d;\n}\nstring output[2]{\"same\\n\", \"diff\\n\"};\nint depen[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\talle.reserve(m);\n\tdp.resize(n+1, vector<int> (n+1, maxn));\n\tfor(int i = 0, a, b;i < m;++i){\n\t\tcin >> a >> b;\n\t\tedge[a].emplace_back(b);\n\t\talle.emplace_back(a, b);\n\t\tdp[a][b] = 1;\n\t}\n\tdfs(1);\n\n\tfloyd_warshall(dp);\n\tfor(int i = 1;i <= n;++i)cout << g[i] << ' ';cout << '\\n';\n\n\tfor(int i = 1;i <= n;++i){\n\t\twhile(edge[i].size() and g[edge[i].back()] != g[i])edge[i].pop_back();\n\t\tfor(int j = 0, r = (int)edge[i].size()-1;j < r;++j){\n\t\t\tif(g[i] != g[edge[i][j]])swap(edge[i][j], edge[i][r]), --r;\n\t\t}\n\t\twhile(edge[i].size() and g[edge[i].back()] != g[i])edge[i].pop_back();\n\t\tfor(int &j : edge[i])++depen[j];\n\t}\n\t\n\t\n\tfor(const auto &e : alle){\n#define f first\n#define s second\n\t\tint res = 0;\n\t\tif(g[e.f] == g[e.s]){\n\t\t\t// dout(e.f)<<' '<< edge[e.f].size() << '\\n';\n\t\t\tres = edge[e.f].size() == 1 || depen[e.s] == 1;\n\t\t}\t\n\t\telse{\n\t\t\tfor(int i = 1;i <= n and !res;++i)if(i != e.f and i != e.s and g[i] != g[e.f] and g[i] != g[e.s]){\n\t\t\t\tif(dp[e.f][i] < maxn and dp[i][e.s] < maxn)res = 1;\n\t\t\t}\n\t\t}\n\t\tcout << output[res];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\nvector<ii> E[1111];\nint siz[1111];\nvoid computeE(int sccid)\n{\n\tvi coord;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tE[sccid].pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E[sccid].size();i++)\n\t{\n\t\tE[sccid][i].fi=lower_bound(coord.begin(),coord.end(),E[sccid][i].fi)-coord.begin();\n\t\tE[sccid][i].se=lower_bound(coord.begin(),coord.end(),E[sccid][i].se)-coord.begin();\n\t}\n\tsiz[sccid]=coord.size();\n}\nvoid check_edge(int n, int sccid, int id)\n{\n\tSCC scc; scc.init(siz[sccid]);\n\tfor(int i=0;i<E[sccid].size();i++)\n\t{\n\t\tif(G[sccid][i]==id) scc.addedge(E[sccid][i].se,E[sccid][i].fi);\n\t\telse scc.addedge(E[sccid][i].fi,E[sccid][i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tcomputeE(id);\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\ntypedef bitset<1001> b100;\nb100 reach[1111];\nmap<ii,int> CNT;\nb100 reach2[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i].set(i,1);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\treach[i]|=reach[v];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(reach[i][j])\n\t\t\t{\n\t\t\t\treach2[j].set(i,1);\n\t\t\t}\n\t\t}\n\t\treach[i].set(i,0); reach2[i].set(i,0);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tif((reach[i]&reach2[v]).count()!=0) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define sz(a) (int)(a).size()\n#define rep(i, a, b) for (int i = (a), _b = (b); i < _b; ++i)\n#define frep(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<ii> vii;\n\nconst int inf = 1e9 + 7;\nconst ll linf  = 1ll * inf * inf;\nconst int N = 1000 + 7;\nconst int M = 20;\nconst int multipleTest = 0;\n\nint ways[N][N];\nint n, m;\n\nvii edge;\n\nclass StrComp {\npublic:\n\tint num[N], low[N];\n\tint cs[N];\n\tvector<int> adj[N];\n\t int cnt = 0;\n\t int comps = 0;\n\tbitset<N> go[N];\n\tvector<int> rev[N];\n\tint tIn[N];\n\t\n\tint dp[N];\n\t\n\tvoid init(int r) {\n\t\trep(i, 1, n + 1) {\n\t\t\tnum[i] = low[i] = cs[i] = 0;\n\t\t\tadj[i].clear();\n\t\t\tgo[i].reset();\n\t\t\trev[i].clear();\n\t\t\ttIn[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tcnt = comps = 0;\n\t\tvector<int> nxt;\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tadj[e.first].push_back(e.second);\n\t\t\t} else if (e.first == r) {\n\t\t\t\tnxt.push_back(e.second);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (!num[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t\t\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tif (cs[e.first] != cs[e.second]) {\n\t\t\t\t\tint u = cs[e.first], v = cs[e.second];\n\t\t\t\t\tif (!go[u][v]) {\n\t\t\t\t\t\tgo[u][v] = 1;\n\t\t\t\t\t\trev[u].push_back(v);\n\t\t\t\t\t\t++tIn[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) dp[cs[v]]++;\n\t\t\n\t\tstatic int q[N], bot, top;\n\t\tbot = top = 0;\n\t\tfor (int i = 1; i <= comps; ++i) if (!tIn[i]) q[top++] = i;\n\t\t\n\t\twhile (bot < top) {\n\t\t\tint u = q[bot++];\n\t\t\tfor (int v : rev[u]) {\n\t\t\t\ttIn[v]--;\n\t\t\t\tif (!tIn[v]) {\n\t\t\t\t\tq[top++] = v;\n\t\t\t\t\tdp[v] += dp[u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) if (dp[cs[v]] > 1) ways[r][v] = true;\n\t}\n\t\n\tvoid dfs(int u) {\n\t\tstatic stack<int> stk;\n\t\tlow[u] = num[u] = ++cnt;\n\t\tstk.push(u);\n\t\tfor (int v : adj[u]) {\n\t\t\tif (cs[v]) continue;\n\t\t\tif (!num[v]) {\n\t\t\t\tdfs(v);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], num[v]);\n\t\t\t}\n\t\t}\n\t\tif (low[u] == num[u]) {\n\t\t\tcs[u] = ++comps;\n\t\t\twhile (stk.top() != u) {\n\t\t\t\tcs[stk.top()] = comps;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\tstk.pop();\n\t\t}\n\t}\n} st;\n\n\n\n\nvoid solve() {\n\tcin >> n >> m;\n\trep(i, 0, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tedge.push_back({u, v});\n\t}\n\tfor (int i = 1; i <= n; ++i) st.init(i);\n\t\n\tst.init(0);\n\tfor (ii e : edge) {\n\t\tint u = e.first;\n\t\tint v = e.second;\n\t\tif (st.cs[u] == st.cs[v]) {\n\t\t\tif (ways[u][v]) puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t} else {\n\t\t\tif (ways[u][v]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\t\n\t}\n}\n\nint main() {\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint Test = 1;\n\tif (multipleTest) {\n\t\tcin >> Test;\n\t}\n\tfor(int i = 0; i < Test; ++i) {\n\t\t//        printf(\"Case #%d: \", i + 1);\n\t\tsolve();\n\t}\n#ifdef _LOCAL_\n\tcout << \"\\n\" << 1.0 * clock() / CLOCKS_PER_SEC << \"\\n\";\n#endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\nint n,m;\n#include<vector>\nstd::vector<int>v[1111111];\nint lnk[1111][1111];\nbool vis[1111111];\nbool isp[1111][1111],isq[1111][1111];\n#include<queue>\n#include<algorithm>\nstd::queue<int>q;\nvoid flood(int x,bool*vs)\n{\n\tq.push(x),vs[x]=1;\n\tfor(;!q.empty();)\n\t{\n\t\tint p=q.front();q.pop();\n\t\tfor(auto t:v[p])\n\t\t\tif(!vs[t])q.push(t),vs[t]=1;\n\t}\n}\nvoid bfs(int x)\n{\n\tregister int i;\n\tfor(i=1;i<=n;i++)vis[i]=0;vis[x]=1;\n\tfor(auto t:v[x])\n\t{\n\t\tisp[x][t]|=vis[t];\n\t\tif(!vis[t])flood(t,vis);\n\t}for(i=1;i<=n;i++)vis[i]=0;vis[x]=1;\n\tstd::reverse(v[x].begin(),v[x].end());\n\tfor(auto t:v[x])\n\t{\n\t\tisp[x][t]|=vis[t];\n\t\tif(!vis[t])flood(t,vis);\n\t}flood(x,isq[x]);\n}\nint x[1111111],y[1111111];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tregister int i;\n\tfor(i=1;i<=m;i++)scanf(\"%d%d\",x+i,y+i),lnk[x[i]][y[i]]=lnk[y[i]][x[i]]=i,\n\tv[x[i]].push_back(y[i]);\n\tfor(i=1;i<=n;i++)bfs(i);\n\tfor(i=1;i<=m;i++)puts((isp[x[i]][y[i]]^isq[y[i]][x[i]])?\"diff\":\"same\");\n}\n/*\nJust go for it.\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint nowp[1100],ask[4400],to[200100];\nbool ans1[200100],ans2[200100];\nvector<int>G[1100];\nint main() {\n\tint n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        int a;\n\t\tscanf(\"%d%d\",&a,&to[i]);\n        G[a].push_back(i);\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++) nowp[j] = 0;\n        int s=1,t=0;\n        for(int p=0;p<G[i].size();p++) nowp[ask[++t]=to[G[i][p]]]=G[i][p];\n        while(s<=t) {\n            int x=ask[s++],y=nowp[x];\n            for(int p=0;p<G[x].size();p++) {\n                int q = to[G[x][p]];\n                if(q!=i&&nowp[q]!=-1){\n                    if(!nowp[q]) nowp[ask[++t]= q] = y;\n                    else if(nowp[q]!=y) nowp[ask[++t]=q] = -1;\n                }\n                else ans1[G[x][p]] = 1;\n            }\n        }\n        for(int p=0;p<G[i].size();p++) if(nowp[to[G[i][p]]]==-1) ans2[G[i][p]]=1;\n    }\n    for(int i=1;i<=m;i++){\n    \tif(ans1[i]==ans2[i]) puts(\"same\");\n    \telse puts(\"diff\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define pb push_back\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\nconst int N=1005,M=2e5+5;\nvector<pi>to[N];\nint ans[M];\nint dfn[N],low[N],st[N],col[N],tim,top,cnt,n,m;\nvoid tarjan(int u){\n\tdfn[u]=low[u]=++tim,st[++top]=u;\n\tfor(auto v:to[u])if(!dfn[v.fi])tarjan(v.fi),cmin(low[u],low[v.fi]);\n\telse if(!col[v.fi])cmin(low[u],dfn[v.fi]);\n\tif(dfn[u]==low[u])\n\t\tfor(++cnt;st[top+1]!=u;--top)col[st[top]]=u;\n}\nint q[M<<3],fr[N],vis[N];\ninline int trs(R int &x,R int y){return x==y?0:(x=!x?y:1023,1);}\nvoid bfs(int rt){\n\tint h=1,t=0,u;\n\tfp(i,1,n)vis[i]=fr[i]=0;\n\tfor(auto v:to[rt])fr[v.fi]=v.fi,q[++t]=v.fi,vis[v.fi]=1;\n\twhile(h<=t){\n\t\tu=q[h++],vis[u]=1;\n\t\tfor(auto v:to[u])if(v.fi!=rt&&trs(fr[v.fi],fr[u])&&!vis[v.fi])q[++t]=v.fi,vis[v.fi]=1;\n\t}\n\tfor(auto v:to[rt])ans[v.se]=(fr[v.fi]==1023)^(col[rt]==col[v.fi]);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin); \n\tscanf(\"%d%d\",&n,&m);\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),to[u].pb(pi(v,i));\n\tfp(i,1,n)if(!dfn[i])tarjan(i);\n\tfp(i,1,n)bfs(i);\n\tfp(i,1,m)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\ntypedef bitset<1001> b100;\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\nvector<ii> E[1111];\nint siz[1111];\nvi ADJ[1111];\nvoid computeE(int sccid)\n{\n\tvi coord;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tE[sccid].pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E[sccid].size();i++)\n\t{\n\t\tE[sccid][i].fi=lower_bound(coord.begin(),coord.end(),E[sccid][i].fi)-coord.begin();\n\t\tE[sccid][i].se=lower_bound(coord.begin(),coord.end(),E[sccid][i].se)-coord.begin();\n\t}\n\tsiz[sccid]=coord.size();\n}\nvoid check_edge(int n, int sccid, int id)\n{\n\t/*\n\tSCC scc; scc.init(siz[sccid]);\n\tfor(int i=0;i<E[sccid].size();i++)\n\t{\n\t\tif(G[sccid][i]==id) scc.addedge(E[sccid][i].se,E[sccid][i].fi);\n\t\telse scc.addedge(E[sccid][i].fi,E[sccid][i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n\t*/\n\tint u=edges[id].fi; int vv=edges[id].se;\n\tqueue<int> q;\n\tb100 visited;\n\tq.push(u); visited.set(u,1);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front(); q.pop();\n\t\tfor(int v:ADJ[x])\n\t\t{\n\t\t\tif(x==u&&v==vv) continue;\n\t\t\tif(!visited[v])\n\t\t\t{\n\t\t\t\tvisited.set(v,1); q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(!visited[vv]) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\t//computeE(id);\n\t//assert(important.size()<=2*siz[id]);\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\nb100 reach[1111];\nmap<ii,int> CNT;\nb100 reach2[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tADJ[u].pb(v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i].set(i,1);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\treach[i]|=reach[v];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(reach[i][j])\n\t\t\t{\n\t\t\t\treach2[j].set(i,1);\n\t\t\t}\n\t\t}\n\t\treach[i].set(i,0); reach2[i].set(i,0);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tif((reach[i]&reach2[v]).count()!=0) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint fir[1010],dis[200010],nxt[200010],id,ex[200010],ey[200010];\nvoid link(int a,int b){nxt[++id]=fir[a],fir[a]=id,dis[id]=b;}\nint vis[1010][1010],que[1010],hd,tl,from[1010];\nbool vv[1010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),x,y;\n\tfor(int i=1;i<=m;++i)ex[i]=x=gi(),ey[i]=y=gi(),link(x,y);\n\tfor(int s=1;s<=n;++s){\n\t\tint*v=vis[s];\n\t\tv[s]=1;hd=tl=0,que[tl++]=s;from[s]=0;\n\t\twhile(hd^tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=fir[x];i;i=nxt[i]){\n\t\t\t\tif(!v[dis[i]])v[dis[i]]=1,from[dis[i]]=(x==s?dis[i]:from[x]),que[tl++]=dis[i];\n\t\t\t\telse if(from[x]!=from[dis[i]])from[dis[i]]=-1;\n\t\t\t}\n\t\t}\n\t\thd=tl=0,que[tl++]=s;\n\t\tmemset(vv,0,sizeof vv);vv[s]=1;\n\t\twhile(hd^tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i=fir[x];i;i=nxt[i]){\n\t\t\t\tif(!vv[dis[i]])vv[dis[i]]=1,que[tl++]=dis[i];\n\t\t\t\tif(x!=s&&dis[i]!=from[x])++v[dis[i]];\n\t\t\t\tif(x!=s&&from[x]!=from[dis[i]])from[dis[i]]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tx=ex[i],y=ey[i];\n\t\tif(vis[y][x])puts(vis[x][y]==1?\"diff\":\"same\");\n\t\telse puts(vis[x][y]==1?\"same\":\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n   int x=0,f=1;char ch=getchar();\n   while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n   while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n   return x*f;\n}\nconst int N=1005;\nconst int M=200005; \nvector<int> vec[N];\nint now,x[M],y[M],n,m,vis1[N][N],vis2[N][N];\n\nvoid dfs1(int x,int fa){\n    for (int i=0;i<vec[x].size();i++)\n      if (vec[x][i]!=fa)\n           if (!vis1[now][vec[x][i]]) vis1[now][vec[x][i]]=x,dfs1(vec[x][i],x);\n}\n\nvoid dfs2(int x,int fa){\n    for (int i=vec[x].size()-1;i>=0;i--)\n      if (vec[x][i]!=fa)\n           if (!vis2[now][vec[x][i]]) vis2[now][vec[x][i]]=x,dfs2(vec[x][i],x);\n}\n\nint main()\n{\n    n=read();m=read();\n    for (int i=1;i<=m;i++) x[i]=read(),y[i]=read(),vec[x[i]].push_back(y[i]);\n    for (int i=1;i<=n;i++) \n    { \n      now=i;vis1[now][now]=vis2[now][now]=1; \n      dfs1(i,-1);\n      dfs2(i,-1);\n    }\n    for (int i=1;i<=m;i++)\n        puts(((vis1[y[i]][x[i]]!=0)^(vis1[x[i]][y[i]]!=x[i]||vis2[x[i]][y[i]]!=x[i]))?\"diff\":\"same\");\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nbool bz[N],bz1[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v,int dep){ \n    static int y;\n    if (dep>100)return;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1])){\n                bz1[x]|=bz1[y];\n                continue;\n            }\n            if (!F[y][0]){\n                F[y][0]=v;\n                dfs(y,s,v,dep+1);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y])dfs(y,s,v,dep+1);\n            }\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1],0);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=1;j<=n;j++)bz1[j]=0;\n        for (int j=g[i];j;j=a[j][1])sum++,bz1[a[j][0]]=bz[a[j][0]]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[1010];\nint n,m,b[200020][2];\nbool vis[1010],f[200020][2];\nint q[1010],h,t,l[1010],r[1010];\nint st[1010],tp;\nvoid work(int v)\n{\n\ttp=0;\n\tfor(auto u:E[v])st[++tp]=u;\n\tint x,y;\n\tmemset(vis+1,0,n);vis[v]=1;\n\tfor(int i=1;i<=tp;++i)\n\t\tif(!vis[x=st[i]])\n\t\t{\n\t\t\th=0,t=1,q[t]=x,vis[x]=1,l[x]=i;\n\t\t\twhile(h<t)\n\t\t\t{\n\t\t\t\tx=q[++h];\n\t\t\t\tfor(auto y:E[x])if(!vis[y])vis[y]=1,q[++t]=y,l[y]=i;\n\t\t\t}\n\t\t}\n\tmemset(vis+1,0,n);vis[v]=1;\n\tfor(int i=tp;i;--i)\n\t\tif(!vis[x=st[i]])\n\t\t{\n\t\t\th=0,t=1,q[t]=x,vis[x]=1,r[x]=i;\n\t\t\twhile(h<t)\n\t\t\t{\n\t\t\t\tx=q[++h];\n\t\t\t\tfor(auto y:E[x])if(!vis[y])vis[y]=1,q[++t]=y,r[y]=i;\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=m;++i)if(b[i][0]==v)f[i][0]=l[b[i][1]]!=r[b[i][1]];\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tint x,y;\n\tfor(int i=1;i<=m;++i)scanf(\"%d %d\",&x,&y),E[x].emplace_back(y),b[i][0]=x,b[i][1]=y;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tmemset(vis+1,0,n);h=0,t=1;q[t]=i;vis[i]=1;\n\t\twhile(h<t)\n\t\t{\n\t\t\tx=q[++h];\n\t\t\tfor(auto y:E[x])if(!vis[y])vis[y]=1,q[++t]=y;\n\t\t}\n\t\tfor(int j=1;j<=m;++j)if(b[j][1]==i)f[j][1]=vis[b[j][0]];\n\t}\n\tfor(int i=1;i<=n;++i)work(i);\n\tfor(int i=1;i<=m;++i)\n\t\tif(f[i][0]!=f[i][1])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <map>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long lint;\n#define p(a,b) make_pair(a,b)\n\nint main(){\n    lint N,M;\n    cin >> N >> M;\n    vector<int> edge[1001];\n    int *A,*B;\n    A=new int[M+1];\n    B=new int[M+1];\n    map<pair<int,int>,int> eind;\n    for(int i=1;i<=M;i++){\n        int a,b;\n        cin >> a >> b;\n        A[i]=a;\n        B[i]=b;\n        edge[a].push_back(b);\n        eind[p(a,b)]=i;\n    }\n\n    bool *conn;\n    conn=new bool[M+1];\n    for(int i=1;i<=M;i++) conn[i]=false;\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=N;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=0;e+1<edge[v].size();e++){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e+1]]) conn[eind[p(v,edge[v][e+1])]]=true;\n        }\n    }\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=1000;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=-1+edge[v].size();e>0;e--){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e-1]]) conn[eind[p(v,edge[v][e-1])]]=true;\n        }\n    }\n\n    bitset<1001> map[1001];\n    for(int i=1;i<=N;i++){\n        map[i]=0;\n        map[i][i]=true;\n    }\n\n    for(int v=1;v<=N;v++){\n        for(int e=1;e<=M;e++) map[A[e]]|=map[B[e]];\n    }\n\n    for(int i=1;i<=M;i++){\n        if(map[B[i]][A[i]]==conn[i]) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n\n    delete[] A,B,conn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lowbit(i) (i&(-i))\n#define ll long long\n#define mid ((l+r)>>1)\nusing namespace std;\nconst int N=1005,M=2e5+5;\nint n,m; vector<int> Ed[N];\nstruct st\n{\n\tint from,nxt,to,ans;\n}ed[M]; int head[N],num;\nvoid add(int from,int to)\n{\n\ted[++num].to=to,ed[num].from=from;\n\ted[num].nxt=head[from];\n\thead[from]=num;\n}\nint stk[N],top,dfn[N],low[N],refl[N],t,numb; bool cn[N];\nvoid tarjan(int x)\n{\n\tdfn[x]=low[x]=++numb,stk[++top]=x,cn[x]=1;\n\tfor(int u,i=head[x];i;i=ed[i].nxt)\n\t{\n\t\tu=ed[i].to;\n\t\tif(!dfn[u])tarjan(u),low[x]=min(low[x],low[u]);\n\t\telse if(cn[u])low[x]=min(low[x],dfn[u]);\n\t}\n\tif(dfn[x]==low[x])\n\t{\n\t\t++t;\n\t\twhile(stk[top]!=x)\n\t\t\trefl[stk[top]]=t,cn[stk[top]]=0,--top;\n\t\trefl[stk[top]]=t,cn[stk[top]]=0,--top;\n\t}\n}\nint fir[2][N];\nvoid dfs(int x,int id,int typ)\n{\n\tfir[typ][x]=id;\n\tfor(auto u : Ed[x])\n\t\tif(!fir[typ][u])dfs(u,id,typ);\n}\nint E[M],tot;\nint main()\n{\n\t//freopen(\"bigcycle_0.in\",\"r\",stdin);\n\t//freopen(\"0709D.out\",\"w\",stdout);\n\tint u,v; scanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&u,&v),add(u,v),Ed[u].push_back(v);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);\n\tfor(int i=1;i<=m;i++)if(refl[ed[i].to]==refl[ed[i].from])ed[i].ans=1;\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tfor(int i=1;i<=n;i++)fir[0][i]=fir[1][i]=0;\n\t\tfir[0][x]=fir[1][x]=1,tot=0;\n\t\tfor(int i=head[x];i;i=ed[i].nxt)E[++tot]=i;\n\t\tfor(int i=1;i<=tot;i++)if(!fir[0][ed[E[i]].to])dfs(ed[E[i]].to,E[i],0);\n\t\tfor(int i=tot;i;i--)if(!fir[1][ed[E[i]].to])dfs(ed[E[i]].to,E[i],1);\n\t\tfor(int i=head[x];i;i=ed[i].nxt)\n\t\t\tif(fir[0][ed[i].to]!=i||fir[1][ed[i].to]!=i)ed[i].ans++;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(ed[i].ans==1)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t//cerr<<clock();\n\treturn 0;\n}\n/*\n3 3\n1 2\n2 3\n1 3\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ld inf = 2e18;\nconst int N = 1020;\nconst int maxn = 200020;\nconst ll mod = 998244353;\n\nstruct node{\n\tint next,to;\n}e[maxn * 2];\nint head[maxn],cnt;\nint reach[N][N],vis[N],tag[N];\nint n,m;\nvector <pr> edge;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nvoid dfs(int x,int from){\n\t//if ( vis[x] >= 2 ) return;\n\tif ( !vis[x] ) vis[x] = 1 , tag[x] = from;\n\telse{\n\t\tif ( from != tag[x] ) vis[x]++;\n\t\telse return;\n\t\tif ( vis[x] > 2 ) return;\n\t}\n\tfore(i,x){\n\t\tif (vis[e[i].to] <2 )dfs(e[i].to,from);\n\t}\n}\nvoid solve(int id){\n\trep(i,1,n) vis[i] = 0;\n\tvis[id] = n;\n\tfore(i,id){\n\t\tdfs(e[i].to,e[i].to);\n\t}\n\trep(i,1,n){\n\t\treach[id][i] = vis[i];\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,m){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y);\n\t\tedge.pb(mp(x,y));\n\t}\n\trep(i,1,n) solve(i);\n//\trep(i,1,n) rep(j,i + 1,n){\n//\t\tcout<<i<<\" \"<<j<<\" \"<<reach[i][j]<<endl;\n//\t\tcout<<j<<\" \"<<i<<\" \"<<reach[j][i]<<endl;\n//\t}\n\trep(i,0,m - 1){\n\t\tint x = edge[i].fi , y = edge[i].se;\n\t\tif ( reach[x][y] > 1 && reach[y][x] ) puts(\"same\");\n\t\telse if ( reach[x][y] == 1 && !reach[y][x] ) puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<1)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],vis[N],ans[M];\nvector<int> e[N];\nvector<int> id[N];\n/*\nvoid dfs(int st,int u,int now){\n\tif (st==u) return;\n\tif (a[st][u]>=2) return;\n\tif (a[st][u]==1 && vis[u]==now) return;\n\tif (a[st][u]==0) vis[u]=now;\n\ta[st][u]++;\n\trep (i,0,(int)e[u].size()-1) dfs(st,e[u][i],now);\n}\n*/\nvoid dfs(int p, int node, int dir)\n{\n\tif (node == p)return;\n\tif (a[p][node] >= 2)return;\n\tif (a[p][node] == 1 && vis[node] == dir)return;\n\tif (a[p][node] == 0)vis[node] = dir;\n\ta[p][node]++;\n\tfor (int i = 0; i < e[node].size(); i++)dfs(p, e[node][i], dir);\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read();\n\t\te[x[i]].push_back(y[i]);\n\t\tid[x[i]].push_back(i);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,-1,sizeof(vis));\n\t\trep (j,0,(int)e[i].size()-1) dfs(i,e[i][j],e[i][j]);\n\t}\n\t/*rep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]]>=1;\n\t\tbool f2=a[x[i]][y[i]]>=2;\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}*/\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j < e[i].size(); j++)\n\t\t{\n\t\t\tbool f = a[i][e[i][j]] >= 2;\n\t\t\tbool g = a[e[i][j]][i] >= 1;\n\t\t\tans[id[i][j]] = f != g;\n\t\t}\n\t}\n\trep (i,1,m) if (ans[i]) printf(\"diff\\n\"); else printf(\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int sccid, int id)\n{\n\tSCC scc; \n\tvi coord; vector<ii> E;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tif(lab==id) swap(u,v);\n\t\tE.pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tE[i].fi=lower_bound(coord.begin(),coord.end(),E[i].fi)-coord.begin();\n\t\tE[i].se=lower_bound(coord.begin(),coord.end(),E[i].se)-coord.begin();\n\t}\n\tscc.init(coord.size());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tscc.addedge(E[i].fi,E[i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\ntypedef bitset<1001> b100;\nb100 reach[1111];\nmap<ii,int> CNT;\nb100 reach2[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i].set(i,1);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\treach[i]|=reach[v];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(reach[i][j])\n\t\t\t{\n\t\t\t\treach2[j].set(i,1);\n\t\t\t}\n\t\t}\n\t\treach[i].set(i,0); reach2[i].set(i,0);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tif((reach[i]&reach2[v]).count()!=0) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vii;\ntypedef vector<double> vdd;\ntypedef vector<ll> vll;\ntypedef vector<ld> vld;\ntypedef set<int> sii;\ntypedef set<double> sdd;\ntypedef set<ll> sll;\ntypedef set<ld> sld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\ntypedef pair<double, double> pdd;\n\n#define feach(i, a) for(auto  &i : a)\n#define allo(a, n) (a), (a) + (n)\n#define all(a) (a).begin(), (a).end()\n\nconst int MAXN = 2e3 + 1;\nconst int mod = 1e9;\nconst double PI = atan2(0, -1);\nconst int INF32 = 2e9 + 1;\nconst ll INF64 = 1e18 + 1;\nrandom_device rd;\nmt19937_64 rnd(rd());\nuniform_int_distribution<ll> uid(-1e9, 1e9);\n\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nvoid time() {\n    cerr << (double) clock() / CLOCKS_PER_SEC << '\\n';\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int a[n];\n\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        //a[i] = uid(rnd);\n        //cout << a[i] << ' ';\n    }\n    cout << endl;\n\n    vii ans_odd, ans_even;\n    ll sum_odd = 0, sum_even = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (i % 2) {\n            if (a[i] > 0) {\n                sum_odd += a[i];\n                ans_odd.push_back(i);\n            }\n        } else {\n            if (a[i] > 0) {\n                sum_even += a[i];\n                ans_even.push_back(i);\n            }\n        }\n    }\n\n    ll sum;\n    vii ans;\n\n    if (sum_even == 0 and sum_odd == 0) {\n        sum = -INF64;\n        ans.push_back(-1);\n\n        for (int i = 0; i < n; i++) {\n            if (a[i] > sum) {\n                sum = a[i];\n                ans.back() = i;\n            }\n        }\n\n    } else if (sum_odd > sum_even) {\n        sum = sum_odd;\n        ans = ans_odd;\n    } else {\n        sum = sum_even;\n        ans = ans_even;\n    }\n\n    cout << sum << '\\n';\n    vii to_print;\n    for (int i = n - 1; i > ans.back(); i--)\n        to_print.push_back(i + 1);\n\n    for (int i = int(ans.size()) - 2; i >= 0; i--) {\n        for (int j = 0; j < (ans[i + 1] - ans[i] - 2) / 2; j++)\n            to_print.push_back(ans[i] + 3);\n        to_print.push_back(ans[i] + 2);\n    }\n\n    for (int i = 1; i - 1 < ans.front(); i++)\n        to_print.push_back(1);\n\n    cout << to_print.size() << '\\n';\n    feach(i, to_print)\n        cout << i << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    solve();\n    //time();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define sz(a) (int)(a).size()\n#define rep(i, a, b) for (int i = (a), _b = (b); i < _b; ++i)\n#define frep(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<ii> vii;\n\nconst int inf = 1e9 + 7;\nconst ll linf  = 1ll * inf * inf;\nconst int N = 1000 + 7;\nconst int M = 20;\nconst int multipleTest = 0;\n\nint ways[N][N];\nint n, m;\n\nvii edge;\n\nclass StrComp {\npublic:\n\tint num[N], low[N];\n\tint cs[N];\n\tvector<int> adj[N];\n\t int cnt = 0;\n\t int comps = 0;\n\tbitset<N> go[N];\n\tvector<int> rev[N];\n\tint tIn[N];\n\tvector<int> nxt;\n\t\n\tint dp[N];\n\t\n\tvoid init(int r) {\n\t\trep(i, 1, n + 1) {\n\t\t\tnum[i] = low[i] = cs[i] = 0;\n\t\t\tadj[i].clear();\n\t\t\tgo[i].reset();\n\t\t\trev[i].clear();\n\t\t\ttIn[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tcnt = comps = 0;\n\t\t nxt.clear();\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tadj[e.first].push_back(e.second);\n\t\t\t} else if (e.first == r) {\n\t\t\t\tnxt.push_back(e.second);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (!num[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t\tif (!r || nxt.size() <= 1) return;\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tif (cs[e.first] != cs[e.second]) {\n\t\t\t\t\tint u = cs[e.first], v = cs[e.second];\n\t\t\t\t\tif (!go[u][v]) {\n\t\t\t\t\t\tgo[u][v] = 1;\n\t\t\t\t\t\trev[u].push_back(v);\n\t\t\t\t\t\t++tIn[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) dp[cs[v]]++;\n\t\t\n\t\tstatic int q[N], bot, top;\n\t\tbot = top = 0;\n\t\tfor (int i = 1; i <= comps; ++i) if (!tIn[i]) q[top++] = i;\n\t\t\n\t\twhile (bot < top) {\n\t\t\tint u = q[bot++];\n\t\t\tfor (int v : rev[u]) {\n\t\t\t\ttIn[v]--;\n\t\t\t\tdp[v] += dp[u];\n\t\t\t\tif (!tIn[v]) {\n\t\t\t\t\tq[top++] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) if (dp[cs[v]] > 1) ways[r][v] = true;\n\t}\n\t\n\tvoid dfs(int u) {\n\t\tstatic stack<int> stk;\n\t\tlow[u] = num[u] = ++cnt;\n\t\tstk.push(u);\n\t\tfor (int v : adj[u]) {\n\t\t\tif (cs[v]) continue;\n\t\t\tif (!num[v]) {\n\t\t\t\tdfs(v);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], num[v]);\n\t\t\t}\n\t\t}\n\t\tif (low[u] == num[u]) {\n\t\t\tcs[u] = ++comps;\n\t\t\twhile (stk.top() != u) {\n\t\t\t\tcs[stk.top()] = comps;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\tassert(!stk.empty() && stk.top() == u);\n\t\t\tstk.pop();\n\t\t}\n\t}\n} st;\n\n\n\n\nvoid solve() {\n\tcin >> n >> m;\n\tmemset(ways, 0, sizeof(ways));\n\trep(i, 0, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tedge.push_back({u, v});\n\t}\n\tfor (int i = 1; i <= n; ++i) st.init(i);\n\t\n\tst.init(0);\n\tfor (ii e : edge) {\n\t\tint u = e.first;\n\t\tint v = e.second;\n\t\tif (st.cs[u] == st.cs[v]) {\n\t\t\tif (ways[u][v]) puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t} else {\n\t\t\tif (ways[u][v]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint Test = 1;\n\tif (multipleTest) {\n\t\tcin >> Test;\n\t}\n\tfor(int i = 0; i < Test; ++i) {\n\t\t//        printf(\"Case #%d: \", i + 1);\n\t\tsolve();\n\t}\n#ifdef _LOCAL_\n\tcout << \"\\n\" << 1.0 * clock() / CLOCKS_PER_SEC << \"\\n\";\n#endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200200;\ninline int read(int x=0,bool f=0,char ch=getchar()){\n\tfor(;!isdigit(ch);ch=getchar()) f=ch=='-';\n\tfor(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\nint n,m,tot,ccc,fi[N],to[N],u[N],ne[N];\nbool vis[1010][1010];\nint pre[1010][1010],suf[1010][1010],que[N],l,r;\nvector<int> g[1010];\nvoid dfs(int x,int id){\n\tvis[id][x]=true;\n\tfor(int i:g[x]) if(!vis[id][i]) dfs(i,id);\n}\nvoid dfs1(int x,int id,int k){\n\tpre[id][x]=k;++ccc;\n\tfor(int i:g[x]) if(!pre[id][i]) dfs1(i,id,k);\n}\nvoid dfs2(int x,int id,int k){\n\tsuf[id][x]=k;\n\tfor(int i:g[x]) if(!suf[id][i]) dfs2(i,id,k);\n}\nint main(){\n//\tfreopen(\"t.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;++i) x=read(),y=read(),ne[++tot]=fi[x],u[tot]=x,to[fi[x]=tot]=y,g[x].push_back(y);\n\tfor(int i=1;i<=n;++i) dfs(i,i);\n\tfor(int i=1;i<=n;++i){\n\t\tvector<int> s; int sz=0; pre[i][i]=suf[i][i]=1;\n\t\tfor(int j=fi[i];j;j=ne[j]) s.push_back(to[j]);\n\t\tfor(int j:s){\n\t\t\t++sz;\n\t\t\tif(!pre[i][j]) dfs1(j,i,sz);\n\t\t}\n\t\treverse(s.begin(),s.end());\n\t\tfor(int j:s){\n\t\t\tif(!suf[i][j]) dfs2(j,i,sz);\n\t\t\t--sz;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint x=u[i],y=to[i];\n\t\tif(vis[y][x]^(pre[x][y]!=suf[x][y])) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1010\n#define M 200200\nusing namespace std;\n\nint n, m;\nint tot, fir[N], nxt[M], to[M];\n\nvoid addE(int u, int v) {\n    nxt[++tot] = fir[u], fir[u] = tot, to[tot] = v;\n}\n\nvoid dfs(int u, int mk, int *vis) {\n    vis[u] = mk;\n    for (int i = fir[u], v; i; i = nxt[i]) {\n        v = to[i];\n        if (vis[v] == mk) continue;\n        dfs(v, mk, vis);\n    }\n}\n\nint vis[N][N], lch[N], rch[N], ans[N], stk[N], top;\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n    \n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; ++i)\n        scanf(\"%d%d\", &u, &v), addE(u, v);\n\n    for (int i = 1; i <= n; ++i)\n        dfs(i, 1, vis[i]);\n\n    for (int u = 1; u <= n; ++u) {\n        memset(lch, 0, sizeof lch);\n        memset(rch, 0, sizeof rch);\n        top = 0;\n        for (int i = fir[u]; i; i = nxt[i])\n            stk[++top] = to[i];\n        for (int i = top, v; i >= 1; --i)\n            v = stk[i], lch[u] = i, dfs(v, i, lch);\n        for (int i = 1, v; i <= top; ++i)\n            v = stk[i], rch[u] = i, dfs(v, i, rch);\n        top = 0;\n        for (int i = fir[u], v; i; i = nxt[i]) {\n            v = to[i];\n            if (vis[v][u] == (lch[v] != rch[v]))\n                ans[i] = 1;\n        }\n    }\n    \n    for (int i = 1; i <= m; ++i)\n        puts(ans[i] ? \"same\" : \"diff\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=1005;\nconst int M=2e5+5;\nint n,m,mp[N][N];\nbool irp[M],lnk[N][N];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nnamespace G{\n\tint rt,cnt,fir[N];\n\tbool vis[N];\n\tstruct edge{\n\t\tint fr,to,nx;\n\t}eg[M];\n\n\tinline void add(const int a,const int b){\n\t\teg[++cnt]=(edge){a,b,fir[a]};\n\t\tmp[a][b]=fir[a]=cnt;\n\t}\n\n\tvoid dfs(const int x){\n\t\tvis[x]=lnk[rt][x]=1;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tif(!vis[eg[i].to]) dfs(eg[i].to);\n\t\t}\n\t}\n\n\tvoid set(const int x){\n\t\tstatic int buk[N];\n\t\tint cnt=0;\n\t\trt=x;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tbuk[++cnt]=eg[i].to;\n\t\t}\n\t\tmemset(vis+1,0,n*sizeof(vis[0]));\n\t\tvis[x]=1;\n\t\tfor(int i=1; i<=cnt; ++i){\n\t\t\tif(!vis[buk[i]]) dfs(buk[i]);\n\t\t\telse irp[mp[i][buk[i]]]=1;\n\t\t}\n\t\tmemset(vis+1,0,n*sizeof(vis[0]));\n\t\tvis[x]=1;\n\t\tfor(int i=cnt; i>=1; --i){\n\t\t\tif(!vis[buk[i]]) dfs(buk[i]);\n\t\t\telse irp[mp[i][buk[i]]]=1;\n\t\t}\n\t}\n}\n\nint main(){\n\tn=nxi(),m=nxi();\n\tfor(int i=1; i<=m; ++i){\n\t\tconst int a=nxi(),b=nxi();\n\t\tG::add(a,b);\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tG::set(i);\n\t}\n\tfor(int i=1; i<=m; ++i){\n\t\tputs(irp[i]^lnk[G::eg[i].to][G::eg[i].fr]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <tuple>\n#include <iterator>\n\nusing namespace std;\n\nstruct edg\n{\n    int x, i;\n};\n\nvector<edg> arr[1010];\n\nint dis[1010];\nstack<int> stk;\nint tim;\n\nint low[1010];\nint num[1010];\nvector<int> scc[1010];\nint siz;\n\nvoid f(int x)\n{\n    dis[x] = ++tim;\n    low[x] = dis[x];\n    stk.push(x);\n\n    for(edg &e : arr[x])\n    {\n        if(!dis[e.x])\n        {\n            f(e.x);\n            low[x] = min(low[x], low[e.x]);\n        }\n        else if(!num[e.x])\n            low[x] = min(low[x], dis[e.x]);\n    }\n\n    if(low[x] == dis[x])\n    {\n        siz++;\n        while(1)\n        {\n            int t = stk.top();\n            stk.pop();\n\n            num[t] = siz;\n            scc[siz].push_back(t);\n            if(t == x)\n                break;\n        }\n    }\n}\n\nbool chk[1010];\nbool res[200010];\n\nvoid dfs(int x)\n{\n    chk[x] = 1;\n    for(edg &e : arr[x])\n        if(!chk[e.x])\n            dfs(e.x);\n}\n\nint main()\n{\n    //freopen(\"in\", \"r\", stdin);\n    //freopen(\"out\", \"w\", stdout);\n\n    int n, m, i;\n    scanf(\"%d%d\", &n, &m);\n    for(i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        arr[x].push_back({ y, i });\n    }\n\n    for(i = 1; i <= n; i++)\n        if(!dis[i])\n            f(i);\n\n    for(i = 1; i <= n; i++)\n    {\n        for(edg &e : arr[i])\n            if(num[i] == num[e.x])\n                res[e.i] = 1;\n\n        memset(chk, 0, sizeof chk);\n        chk[i] = 1;\n        for(edg &e : arr[i])\n        {\n            if(num[i] == num[e.x] && chk[e.x])\n                res[e.i] = 0;\n            else if(num[i] != num[e.x] && chk[e.x])\n                res[e.i] = 1;\n            dfs(e.x);\n        }\n\n        reverse(arr[i].begin(), arr[i].end());\n\n        memset(chk, 0, sizeof chk);\n        chk[i] = 1;\n        for(edg &e : arr[i])\n        {\n            if(num[i] == num[e.x] && chk[e.x])\n                res[e.i] = 0;\n            else if(num[i] != num[e.x] && chk[e.x])\n                res[e.i] = 1;\n            dfs(e.x);\n        }\n    }\n\n    for(i = 0; i < m; i++)\n    {\n        if(res[i])\n            printf(\"diff\\n\");\n        else\n            printf(\"same\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[2][N],vi[N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vi[v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tmemset(vi,0,sizeof(vi));\n\t\tdfs_vis(i,i);\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid,LL rt){\n\tp[pid][u] = col;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vi[v]) continue;\n\t\tdfs_sol(v,col,pid,rt);\n\t}\n}\n\nvoid solve(LL u){\n\tmemset(p,0,sizeof(p));\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!vi[ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,0,u);\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!vi[ev[G[u][i]]]) dfs_sol(ev[G[u][i]],i + 1,1,u);\n\tfor(LL i = 1;i <= n;i ++) if(vi[i] && p[0][i] != p[1][i]) vis[1][u][i] = 1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(i);\n\t}\n\tget_vis();\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n//\tfor(LL i = 1;i <= m;i ++) cout << ans[0][i] << ' ' << ans[1][i] << endl;\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n\nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[M] , B[M];\nint stk[N] , top;\n\nvector <int> G[N];\nvector <int> who[N];\n\nvoid add(int x , int y , int id) {\n\tne[++ cnt] = fir[x]; fir[x] = cnt; to[cnt] = y; Id[cnt] = id;\n}\n\n#define Foreachson(i , x) for(int i = fir[x];i;i = ne[i])\n\nvoid dfs(int x) {\n\tint cur = top;\n\tdfn[x] = low[x] = ++ dfs_clock; stk[++ top] = x;\n\tForeachson(i , x) {\n\t\tint V = to[i];\n\t\tif(!dfn[V]) {\n\t\t\tdfs(V);\n\t\t\tlow[x] = min(low[x] , low[V]);\n\t\t}\n\t\telse if(!scc[V]) low[x] = min(low[x] , low[V]);\n\t}\n\tif(dfn[x] == low[x]) {\n\t\t++ scc_tot;\n\t\twhile(top > cur) {\n\t\t\twho[scc_tot].push_back(stk[top]);\n\t\t\tscc[stk[top]] = scc_tot;\n\t\t\t-- top;\n\t\t\tif(stk[top + 1] == x) break;\n\t\t}\n\t}\n}\n\nbool vis[N];\n\nint dp[N][N] , rd[N] , cd[N] , cur[N];\n\nvoid solve(int x) {\n\tif(vis[x]) \n\treturn;\n\tvis[x] = 1;\n\tfor(int i = 0;i < (int) G[x].size();++ i) {\n\t\tint V = G[x][i];\n\t\tsolve(V);\n\t\tfor(register int j = 1;j <= n;++ j) dp[x][j] += dp[V][j];\n\t}\n\t++ dp[x][x];\n\tfor(int i = 1;i <= n;++ i) dp[x][i] = min(dp[x][i] , 2);\n}\n\nint ans[M];\n\nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x , y , i);\n\t}\n\tfor(int i = 1;i <= n;++ i) if(!dfn[i]) dfs(i);\n\tfor(int x = 1;x <= n;++ x) {\n\t\tForeachson(i , x) {\n\t\t\tint V = to[i];\n\t\t\tif(scc[V] == scc[x]) {\n\t\t\t\t++ rd[V]; ++ cd[x];\n\t\t\t}\n\t\t\telse\n\t\t\tG[scc[x]].push_back(scc[V]);\n\t\t}\n\t}\n\tfor(int i = 1;i <= scc_tot;++ i) {\n\t\tif(!vis[i]) solve(i);\n\t}\n\tfor(int i = 1;i <= m;++ i) {\n\t\tint x = A[i] , V = B[i];\n\t\tif(scc[x] == scc[V]) {\n\t\t\tint a = cd[x] - 1 , b = rd[V] - 1;\n\t\t\tif(!a || !b) ans[i] = 1;\n\t\t\telse ans[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tif(dp[scc[x]][scc[V]] >= 2) ans[i] = 1;\n\t\t\telse ans[i] = 0;\n\t\t}\n\t}\n\tfor(int i = 1;i <= m;++ i) if(ans[i]) puts(\"diff\"); else puts(\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1010;\nconst int MAXM = 200010;\n\nstruct Edge {\n\tint u, v;\n\n\tEdge() {}\n\tEdge(int u, int v):u(u), v(v) {}\n}E[MAXM];\n\nvector<int>to[MAXN];\n\nint n, m, Mark[MAXN];\nbitset<MAXN>vis;\nbool G1[MAXN][MAXN];\nbool G2[MAXN][MAXN];\n\ninline void dfs1(int x, int st) {\n\tG1[st][x] = 1, vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs1(u, st);\n}\n\ninline void dfs2(int x, int col, int k, int st) {\n\tif(k) G2[st][x] = Mark[x] != col;\n\telse Mark[x] = col; vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs2(u, col, k, st);\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor(int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tto[u].push_back(v);\n\t\tE[i] = Edge(u, v);\n\t}\n\tfor(int i = 1; i <= n; i++) vis.reset(), dfs1(i, i);\n\tfor(int i = 1; i <= n; i++) {\n\t\tvis.reset(), vis.set(i);\n\t\tmemset(Mark, 0, sizeof(Mark));\n\t\tint d = to[i].size();\n\t\tfor(int j = 0; j < d; j++) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 0, i);\n\t\tvis.reset(), vis.set(i);\n\t\tfor(int j = d - 1; ~j; --j) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 1, i);\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tputs(G1[E[i].v][E[i].u] ^ G2[E[i].u][E[i].v] ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n \nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[M] , B[M];\nint stk[N] , top;\nint ans[M];\nint L[N][N], R[N][N];\n\nvoid add(int x, int y) {\n\tne[++ cnt] = fir[x];\n\tfir[x] = cnt;\n\tto[cnt] = y;\n}\n\nbool can[N][N];\n\nqueue <int> q;\n\nvector <int> son[N];\n\n#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\nvoid solve(int x) {\n\twhile(!q.empty()) q.pop();\n\tint tot = 0;\n\tq.push(x);\n\twhile(!q.empty()) {\n\t\tint ind = q.front();\n\t\tcan[x][ind] = 1;\n\t\tq.pop();\n\t\tForeachson(i, ind) {\n\t\t\tint V = to[i];\n\t\t\t++ tot;\n\t\t\tif(can[x][V]) continue;\n\t\t\tq.push(V);\n\t\t\tcan[x][V] = 1;\n\t\t}\n\t}\n}\n\nvoid solve2(int x) {\n\tfor(int i = 1; i <= n; ++ i) L[x][i] = 2e9, R[x][i] = 0;\n\tForeachson(j, x) {\n\t\tint V = to[j];\n\t\tfor(int k = 1; k <= n; ++ k) \n\t\tif(can[V][k]) {\n\t\t\tL[x][k] = min(L[x][k], V);\n\t\t\tR[x][k] = max(R[x][k], V);\n\t\t}\n\t}\n}\n\n \nmain(void) {\n\tfreopen(\"myout.txt\", \"w\", stdout);\n\t//scanf(\"%d%d\" , &n , &m);\n\tn = 1000, m = 200000;\n\tfor(int i = 1;i <= m;++ i) {\n\t\tx = rand() % n + 1;\n\t\ty = rand() % n + 1;\n\t\tif(x == y) {\n\t\t\t-- i;\n\t\t\tcontinue;\n\t\t}\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x, y);\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tForeachson(j, i) {\n\t\t\tint V = to[j];\n\t\t\tson[i].push_back(V);\n\t\t}\n\t\treverse(son[i].begin(), son[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tsolve(i);\n\t}\n\n\tfor(int i = 1; i <= n; ++ i) solve2(i);\n\t\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(L[A[i]][B[i]] != B[i] || R[A[i]][B[i]] != B[i]) {\n\t\t\tif(!can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\telse {\n\t\t\tif(can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1005;\n\nconst int M = 2e5 + 5;\n\nint n, m, x, y;\nint fi[N], nt[M], to[M], tot;\n\nvoid link(int x, int y) {\n\tnt[++ tot] = fi[x], to[tot] = y, fi[x] = tot;\n}\n\nint bz[N];\n\nvoid dg(int x) {\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tif(!bz[to[i]]) dg(to[i]);\n}\n\nint b[N][N];\n\nint ans[M];\n\nint d[N], d0, xx, ky[N];\n\nvoid dfs(int x) {\n\tbz[x] = 1;\n\tif(xx == x) return;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tif(!bz[to[i]]) dfs(to[i]);\n}\n\n#define mem(a) memset(a, 0, sizeof a)\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tlink(x, y);\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz);\n\t\tdg(st);\n\t\tfo(j, 1, n) b[st][j] = bz[j];\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz); mem(ky);\n\t\td0 = 0;\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\td[++ d0] = to[i];\n\t\txx = st;\n\t\tfo(i, 1, d0) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tmem(bz);\n\t\tfd(i, d0, 1) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\tans[i] = b[to[i]][st] ^ ky[to[i]];\n\t}\n\tfo(i, 1, m) pp(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 1010;\n\nint n, m;\nbool vis[N];\nvector<pair<int, int>> g[N], ig[N];\n\nbool ans[N];\n\nvoid reachable(int u) {\n  vis[u] = true;\n  for (const auto& pr : g[u])\n    if (!vis[pr.first])\n      reachable(pr.first);\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m;\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].emplace_back(v, i);\n    ig[v].emplace_back(u, i);\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    for (int rep = 0; rep < 2; ++rep) {\n      memset(vis, 0, sizeof(vis));\n      vis[i] = true;\n      for (const auto &pr : g[i])\n        if (vis[pr.first])\n          ans[pr.second] = true;\n        else\n          reachable(pr.first);\n      reverse(g[i].begin(), g[i].end());\n    }\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    reachable(i);\n    for (const auto& pr : ig[i]) {\n      int j, id;\n      tie(j, id) = pr;\n      ans[id] ^= vis[j];\n    }\n  }\n  for (int i = 1; i <= m; ++i)\n    cout << (ans[i] ? \"diff\\n\" : \"same\\n\");\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 1010\n#define MAXM 200010\nusing namespace std;\nint n,m,u,v;\nint id[MAXN][MAXN],ans1[MAXN][MAXN],ans2[MAXN][MAXN],q[MAXN][2];\nint ans[MAXM];\nvector<int> a[MAXN];\nvoid dfs(int x,int fa){\n    ans1[fa][x]=1;\n    for(int i=0;i<a[x].size();i++)\n        if(ans1[fa][a[x][i]]==0)\n            dfs(a[x][i],fa);\n}\nvoid dfs1(int x,int tag,int flag){\n    q[x][flag]=tag;\n    for(int i=0;i<a[x].size();i++)\n        if(!q[a[x][i]][flag])\n            dfs1(a[x][i],tag,flag);\n}\nint main(){\n    SF(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++){\n        SF(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        id[u][v]=i+1;\n        a[u].push_back(v);\n    }\n    for(int i=0;i<n;i++)\n        dfs(i,i);\n    for(int i=0;i<n;i++){\n        memset(q,0,sizeof q);\n        q[i][0]=q[i][1]=-1;\n        for(int j=0;j<a[i].size();j++)\n            if(!q[a[i][j]][0])\n                dfs1(a[i][j],j+1,0);\n        for(int j=a[i].size()-1;j>=0;j--)\n            if(!q[a[i][j]][1])\n                dfs1(a[i][j],j+1,1);\n        for(int j=0;j<a[i].size();j++)\n            if(q[a[i][j]][0]!=j+1||q[a[i][j]][1]!=j+1)\n                ans2[i][a[i][j]]=1;\n    }\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            if(ans1[j][i]==ans2[i][j]&&id[i][j])\n                ans[id[i][j]]=1;\n    for(int i=1;i<=m;i++){\n        if(ans[i]==1)\n            PF(\"same\\n\");\n        else\n            PF(\"diff\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn;\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(++pn;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid dfs1(int x)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs1(e[i].t),uu[i>>1]=1;\n}\nvoid dfs2(int x)\n{\n\tu[x]=1;\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs2(e[i].t),uu[i>>1]=1;\n}\nvoid d1(int x,int y)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=y&&!u[e[i].t])d1(e[i].t,y);\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)==y&&!u[e[i].t])d1(e[i].t,y);\n}\nvoid d2(int x,int y)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)==y&&!u[e[i].t])d2(e[i].t,y);\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=y&&!u[e[i].t])d2(e[i].t,y);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tfor(i=1;i<=n;++i)if(!u[i])dfs1(i);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=n;++i)if(!u[i])dfs2(i);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\t//for(i=1;i<=pn;++i)\n\t//\tfor(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t//\t\tfor(k=c[q[j]];k;k=e[k].nx)\n\t//\t\t{\n\t//\t\t\tif(!g[i][e[k].t])q[++qn]=e[k].t;\n\t//\t\t\t++g[i][e[k].t];\n\t//\t\t}\n\tfor(i=1;i<=m;++i)\n\t{\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(!uu[i]){puts(\"same\");continue;}\n\t\t\tmemset(u,0,sizeof(u));\n\t\t\td1(x[i],i);\n\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\tmemset(u,0,sizeof(u));\n\t\t\td2(x[i],i);\n\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\tputs(j>n?\"same\":\"diff\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\n\n/////////////////////////////////\n\nint const MAXN = 1000 + 41;\nint const MAXM = 200 * 1000 + 41;\nstring const SAME = \"same\";\nstring const DIFF = \"diff\";\n\nint n, m;\nvpii e[MAXN];\nstring ans[MAXM];\n\nint t1[MAXN], t2[MAXN];\nint r[MAXN][MAXN];\n\nvoid dfs1(int x, int u[MAXN]) {\n\tu[x] = 1;\n\tfor (pii z : e[x]) {\n\t\tint y = z.first;\n\t\tif (!u[y]) {\n\t\t\tdfs1(y, u);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x, int p, int v, int t[MAXN]) {\n\tt[x] = v;\n\tfor\t(pii z : e[x]) {\n\t\tint y = z.first;\n\t\tif (t[y]) continue;\n\t\tif (y == p) continue;\n\t\tdfs2(y, p, v, t);\n\t}\n}\n\nvoid solve() {\n\tfi(1, n) {\n\t\tdfs1(i, r[i]);\n\t}\n\tfi(1, n) {\n\t\tmemset(t1, 0, sizeof(t1));\n\t\tfj(0, sz(e[i]) - 1) {\n\t\t\tint y = e[i][j].first;\n\t\t\tif (t1[y] != 0) continue;\n\t\t\tdfs2(y, i, j + 1, t1);\n\t\t}\n\t\tmemset(t2, 0, sizeof(t2));\n\t\tfdj(sz(e[i]) - 1, 0) {\n\t\t\tint y = e[i][j].first;\n\t\t\tif (t2[y] != 0) continue;\n\t\t\tdfs2(y, i, j + 1, t2);\n\t\t}\n\t\tfj(0, sz(e[i]) - 1) {\n\t\t\tint x = i;\n\t\t\tint y = e[i][j].first;\n\t\t\tint id = e[i][j].second;\n\t\t\tif (t1[y] != t2[y]) {\n\t\t\t\tif (r[y][x]) {\n\t\t\t\t\tans[id] = SAME;\n\t\t\t\t} else {\n\t\t\t\t\tans[id] = DIFF;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (r[y][x]) {\n\t\t\t\t  ans[id] = DIFF;\n\t\t\t\t}\telse {\n\t\t\t\t\tans[id] = SAME;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfi(1, m) {\n\t\tprintf(\"%s\\n\", ans[i].c_str());\n\t}\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tscanf(\"%d %d\", &n, &m);\n\tfi(1, m) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\te[x].pb(mp(y, i));\n\t}\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 2010\n#define LL long long\n#define rep(i, x, y) for(int i = (x); i <= (y); ++ i)\ninline int read() {\n\tchar ch = getchar(); int x = 0, f = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') f = -1;\n\t\tch = getchar();\n\t}\n\twhile('0' <= ch && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn x * f;\n}\nint p[M][M], q[M][M];\nint T;\nvector<int> G[M];\nint vis[M];\ninline void dfs(int st, int x, int id, int a[]) {\n\tif(st == x || vis[x] == T) return;\n\tvis[x] = T; a[x] = id;\n\tfor(int i = 0; i < G[x].size(); ++ i) {\n\t\tdfs(st, G[x][i], id, a);\n\t}\n}\npair<int, int> A[M*50];\nint main() {\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tint n = read(), m = read();\n\trep(i, 1, m) {\n\t\tint u = read(), v = read();\n\t\tG[u].push_back(v);\n\t\tA[i] = make_pair(u, v);\n\t}\n\trep(i, 1, n) {\n\t\t++ T;\n\t\tint id = 0;\n\t\tfor(int j = 0; j < G[i].size(); ++ j) {\n\t\t\tdfs(i, G[i][j], ++ id, p[i]);\n\t\t}\n\t\treverse(G[i].begin(), G[i].end());\n\t\t++ T;\n\t\tfor(int j = 0; j < G[i].size(); ++ j) {\n\t\t\tdfs(i, G[i][j], id --, q[i]);\n\t\t}\n\t}\n\trep(i, 1, m) {\n\t\tint u = A[i].first, v = A[i].second;\n\t\tif((q[u][v] > 0) == (p[u][v] != q[u][v])) {\n\t\t\tputs(\"same\");\n\t\t}\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#define MN 1000\n#define MM 200000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nvector<int> v[MN+5],w[MN+5],V[MN+5],W[MN+5];\nint n,m,bel[MN+5],head[MN+5],cnt,Ans[MM+5],q[MN+5],cc,in[MN+5],now,vis[MN+5];\nint top,dfn[MN+5],low[MN+5],c[MN+5],num,dn,inq[MN+5],mx[MN+5],mn[MN+5],f[MN+5];\nstruct edge{int to,next,w;}e[MM+5];\ninline void ins(int f,int t,int w){e[++cnt]=(edge){t,head[f],w};head[f]=cnt;}\nvoid MarkMn(int x,int c)\n{\n\tmn[x]=c;\n\tfor(int i=0;i<v[x].size();++i) \n\t\tif(!(x==now&&i+1>c)&&mn[v[x][i]]==n) MarkMn(v[x][i],c);\n}\nvoid MarkMx(int x,int c)\n{\n\tmx[x]=c;\n\tfor(int i=0;i<v[x].size();++i) \n\t\tif(!(x==now&&i+1<c)&&!mx[v[x][i]]) MarkMx(v[x][i],c);\n}\nvoid Solve()\n{\n\tfor(int i=1;i<=num;++i) for(int j=head[c[i]];j;j=e[j].next) \n\t\tif(bel[e[j].to]==cc) v[c[i]].push_back(e[j].to),w[c[i]].push_back(e[j].w);\n\tfor(int i=1;i<=num;++i)\n\t{\n\t\tfor(int j=1;j<=num;++j) mx[c[j]]=0,mn[c[j]]=n;now=c[i];\n\t\tfor(int j=0;j<v[c[i]].size();++j) if(mn[v[c[i]][j]]==n) MarkMn(v[c[i]][j],j+1);\n\t\tfor(int j=v[c[i]].size()-1;~j;--j) if(!mx[v[c[i]][j]]) MarkMx(v[c[i]][j],j+1);\n\t\tfor(int j=1;j<=num;++j) \n\t\t\tif(i!=j&&mn[c[j]]==mx[c[j]]) Ans[w[c[i]][mn[c[j]]-1]]=1;\n\t}\n}\nvoid Tarjan(int x)\n{\n\tdfn[x]=low[x]=++dn;q[++top]=x;inq[x]=1;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(!dfn[e[i].to]) Tarjan(e[i].to),low[x]=min(low[x],low[e[i].to]);\n\t\telse if(inq[e[i].to]) low[x]=min(low[x],dfn[e[i].to]);\n\tif(dfn[x]==low[x])\n\t{\n\t\tfor(num=0,++cc;q[top+1]!=x;inq[q[top--]]=0) c[++num]=q[top],bel[q[top]]=cc;\n\t\tSolve();\t\n\t}\n}\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<V[x].size();++i)\n\t\tif(++in[V[x][i]],!vis[V[x][i]]) dfs(V[x][i]);\t\n}\ninline void R(int&x,int y){x=min(2,x+y);}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1,j;i<=m;++i) j=read(),ins(j,read(),i);\n\tfor(int i=1;i<=n;++i) if(!dfn[i]) Tarjan(i); \n\tfor(int i=1;i<=n;++i) for(int j=head[i];j;j=e[j].next) if(bel[i]!=bel[e[j].to]) \n\t\tV[bel[i]].push_back(bel[e[j].to]),W[bel[i]].push_back(e[j].w);\n\tfor(int i=1;i<=cc;++i)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tf[i]=1;q[top=1]=i;dfs(i);\n\t\tfor(int j=1;j<=top;++j)\n\t\t\tfor(int k=0;k<V[q[j]].size();++k)\n\t\t\t\tif(R(f[V[q[j]][k]],f[q[j]]),!--in[V[q[j]][k]]) q[++top]=V[q[j]][k];\n\t\tfor(int j=0;j<V[i].size();++j) if(f[V[i][j]]!=1) Ans[W[i][j]]=1;\n\t}\n\tfor(int i=1;i<=m;++i) puts(Ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#define maxn 1005\n#define maxm 200005\nusing namespace std;\ninline int qread(){\n\tint x=0,sign=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') sign=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*sign;\n}\nint n,m; \nint s[maxm],e[maxm];\nvector<int>E[maxn];\nvoid add_edge(int u,int v){\n\tE[u].push_back(v);\n}\nint used[maxn];\nint route[maxn][maxn];\nvoid dfs(int s,int x){\n\tint y;\n\tused[x]=1;\n\troute[s][x]++;\n\tint cnt=E[x].size();\n\tfor(int i=0;i<cnt;i++){\n\t\ty=E[x][i];\n\t\tif(y==s) continue;\n\t\tif(!used[y]&&route[s][y]<2){\n\t\t\tdfs(s,y);\n\t\t}\n\t}\n}\n\nint judge(int u,int v){//1为diff,0为same \n\tif(route[v][u]>0){//在一个SCC中 \n\t\tif(route[u][v]>=2) return 0;\n\t\telse return 1; \n\t}else{//不在一个SCC中 \n\t\tif(route[u][v]>=2) return 1;\n\t\telse return 0;\n\t}\n}\n\nchar a[]=\"same\",b[]=\"diff\";\nvoid qprint(char *s,int len){\n\tfor(int i=0;i<len;i++){\n\t\tputchar(s[i]);\n\t}\n\tputchar('\\n');\n}\nint main(){\n//\tscanf(\"%d %d\",&n,&m);\n\tn=qread();\n\tm=qread(); \n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n//\t\tscanf(\"%d %d\",&u,&v);\n\t\ts[i]=qread();\n\t\te[i]=qread();\n\t\tadd_edge(s[i],e[i]);\n\t}\n\tint y;\n\tfor(int i=1;i<=n;i++){\n//\t\tint cnt=E[i].size();\n//\t\tfor(int j=0;j<cnt;j++){\n//\t\t\ty=E[i][j];\n//\t\t\tif(route[i][y]<2){\n//\t\t\t\tmemset(used,0,sizeof(used));\n//\t\t\t\tdfs(i,y);\n//\t\t\t}\n//\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tdfs(i,i); \n\t}\n//\tfor(int i=1;i<=n;i++){\n//\t\tfor(int j=1;j<=n;j++){\n//\t\t\tprintf(\"%d \",route[i][j]);\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(judge(s[i],e[i]) )qprint(b,4);\n\t\telse qprint(a,4);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1050\n#define M 500050\nusing namespace std;\nint n,m;\nstruct node{\n\tint x,y;\n}ed[M];\nbitset<N>pd1[N],pd2[N],vis;\nvector<int>v[N];\ninline void dfs(int g,int fa){\n\tvis[g]=1;pd1[fa][g]=1;\n\tfor(int to:v[g])if(!vis[to])dfs(to,fa);\n}\nint tag[N];\ninline void dfs2(int g,int t){\n\tif(vis[g])return;\n\tvis[g]=1;tag[g]=t;\n\tfor(int to:v[g])if(!vis[to])dfs2(to,t);\n}\ninline void dfs3(int g,int t,int rt){\n\tif(vis[g])return;\n\tvis[g]=1;if(tag[g]!=t)pd2[rt][g]=1;\n\tfor(int to:v[g])if(!vis[to])dfs3(to,t,rt);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;++i)scanf(\"%d%d\",&ed[i].x,&ed[i].y),v[ed[i].x].push_back(ed[i].y);\n\tfor(int i=1;i<=n;++i)vis.reset(),dfs(i,i);\n\tfor(int i=1;i<=n;++i){\n\t\tvis.reset();vis[i]=1;\n\t\tfor(int to:v[i])dfs2(to,to);\n\t\tvis.reset();vis[i]=1;\n\t\treverse(v[i].begin(),v[i].end());\n\t\tfor(int to:v[i])dfs3(to,to,i);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tputs((pd1[ed[i].y][ed[i].x]^pd2[ed[i].x][ed[i].y])?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxn 1010\n#define maxm 200010\nusing namespace std;\ntypedef long long LL;\nint f[maxn][maxn][2], vis[maxn<<1], T;\nstruct node {int to, id; };\nvector<node> edge[maxn];\npair<int, int> E[maxm];\nvoid dfs(int u, int src, int id, int type) {\n    f[src][u][type] = id; vis[u] = T;\n    for (auto& e : edge[u]) {\n        int v = e.to;\n        if (vis[v]!=T) dfs(v, src, id, type);\n    }\n}\nvoid work(int src) {\n    ++T; vis[src] = T;\n    for (auto& e : edge[src]) {\n        int v = e.to;\n        if (vis[v]!=T) dfs(v, src, e.id, 0);\n    }\n\n    reverse(edge[src].begin(), edge[src].end());\n    ++T; vis[src] = T;\n    for (auto& e : edge[src]) {\n        int v = e.to;\n        if (vis[v]!=T) dfs(v, src, e.id, 1);\n    }\n}\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    int n, m, u, v;\n    scanf(\"%d%d\", &n ,&m);\n    F2(i, 1, m) {\n        scanf(\"%d%d\", &u, &v);\n        edge[u].push_back({v, i});\n        E[i] = {u, v};\n    }\n    F2(i, 1, n) work(i);\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f[i][j][0]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f[i][j][1]); puts(\"\");\n//    }\n    F2(i, 1, m) {\n        int u = E[i].first, v = E[i].second;\n        if (f[v][u][0]!=0 ^ (f[u][v][0]!=i||f[u][v][1]!=i)) puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<ctime>\nusing namespace std;\n#define N 1050\n#define M 200500\nint head[N],cnt,scc[N],dfn[N],low[N],f[N][13],s[M][2],as[M],vl[N],ct,ct2,vis[N][N],id[N],ct1,dep[N],is[N],n,m,ct3;\nstruct edge{int t,next,id;}ed[M];\nvoid adde(int f,int t,int id){ed[++cnt]=(edge){t,head[f],id};head[f]=cnt;}\nstack<int> tp,tp2,v[N],tp3;\nvoid dfs1(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\ttp.push(u);\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs1(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])\n\t{\n\t\tint s=tp.top(),id=++ct2;tp.pop();\n\t\tscc[s]=id;\n\t\twhile(s!=u)\n\t\ts=tp.top(),tp.pop(),scc[s]=id;\n\t}\n}\nvoid dfs2(int u,int s){for(int i=head[u];i;i=ed[i].next)if(!vis[s][ed[i].t])vis[s][ed[i].t]=1,dfs2(ed[i].t,s);else vis[s][ed[i].t]++;}\nint LCA(int x,int y){if(dep[x]<dep[y])x^=y^=x^=y;for(int i=10;i>=0;i--)if(dep[x]-dep[y]>=(1<<i))x=f[x][i];if(x==y)return x;for(int i=10;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];return f[x][0];}\nvoid dfs3(int u,int fa)\n{\n\tdfn[u]=1;dep[u]=dep[fa]+1;f[u][0]=fa;vl[u]=0;for(int i=1;i<=10;i++)f[u][i]=f[f[u][i-1]][i-1];\n\tfor(int i=head[u];i;i=ed[i].next)\n\tif(!dfn[ed[i].t])tp.push(ed[i].id),dfs3(ed[i].t,u),vl[u]+=vl[ed[i].t];\n\telse{int s=LCA(u,ed[i].t);vl[u]++;vl[s]--;tp2.push(ed[i].id);}\n}\nbool check(int x)\n{\n\tfor(int i=1;i<=n;i++)dfn[i]=scc[i]=head[i]=0;\n\tcnt=0;ct2=0;\n\tfor(int i=1;i<=m;i++)if(i!=x)adde(s[i][0],s[i][1],-1);else adde(s[i][1],s[i][0],-2);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);\n\treturn ct2!=ct3;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&s[i][0],&s[i][1]),adde(s[i][0],s[i][1],1);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);ct3=ct2;\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])adde(scc[s[i][0]],scc[s[i][1]],-3);\n\tfor(int i=1;i<=ct2;i++)dfs2(i,i);\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])as[i]=vis[scc[s[i][0]]][scc[s[i][1]]]>1;else v[scc[s[i][0]]].push(i);\n\tfor(int i=1;i<=ct2;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)dfn[j]=0,head[j]=0;\n\t\tct1=0;cnt=0;\n\t\tfor(int j=1;j<=n;j++)if(scc[j]==i)id[j]=++ct1;\n\t\twhile(!v[i].empty())\n\t\t{\n\t\t\tint q=v[i].top();v[i].pop();\n\t\t\tadde(id[s[q][0]],id[s[q][1]],q);\n\t\t}\n\t\tdfs3(1,0);\n\t\twhile(!tp2.empty())\n\t\t{\n\t\t\tint st=tp2.top();tp2.pop();\n\t\t\tint l=id[s[st][0]],r=id[s[st][1]];\n\t\t\tr=LCA(l,r);\n\t\t\tint fg=0;\n\t\t\twhile(l!=r)fg|=(vl[l]==1),l=f[l][0];\n\t\t\tas[st]=fg;\n\t\t}\n\t}\n\twhile(!tp.empty()){int st=tp.top();tp.pop();as[st]=check(st);}\n\tfor(int i=1;i<=m;i++)printf(\"%s\\n\",as[i]?\"diff\":\"same\");\n}///"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1005;\n\nconst int M = 2e5 + 5;\n\nint n, m, x, y;\nint fi[N], nt[M], to[M], tot;\n\nvoid link(int x, int y) {\n\tnt[++ tot] = fi[x], to[tot] = y, fi[x] = tot;\n}\n\nint bz[N];\n\nvoid dg(int x) {\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tif(!bz[to[i]]) dg(to[i]);\n}\n\nint b[N][N];\n\nint ans[N];\n\nint d[N], d0;\n\nint xx, ky[N];\n\nvoid dfs(int x) {\n\tif(xx == x) return;\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tif(!bz[to[i]]) dfs(to[i]);\n}\n\n#define mem(a) memset(a, 0, sizeof a)\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tlink(x, y);\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz);\n\t\tdg(st);\n\t\tfo(j, 1, n) b[st][j] = bz[j];\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz); mem(ky);\n\t\td0 = 0;\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\td[++ d0] = to[i];\n\t\txx = st;\n\t\tfo(i, 1, d0) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tmem(bz);\n\t\tfd(i, d0, 1) {\n\t\t\tky[d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\tans[i] = b[to[i]][st] ^ ky[to[i]];\n\t}\n\tfo(i, 1, m) pp(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\nconst int MAXM = 2e5 + 5;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nstruct edge {int dest, home; };\nint n, m;\nint pre[MAXN], suf[MAXN];\nbool vis[MAXN][MAXN], ans[MAXM];\nvector <edge> a[MAXN];\nvoid dfs(int from, int pos) {\n\tvis[from][pos] = true;\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (!vis[from][a[pos][i].dest]) dfs(from, a[pos][i].dest);\n}\nvoid dfspre(int pos, int val) {\n\tpre[pos] = val;\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (pre[a[pos][i].dest] == -1) dfspre(a[pos][i].dest, val);\n}\nvoid dfssuf(int pos, int val) {\n\tsuf[pos] = val;\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (suf[a[pos][i].dest] == -1) dfssuf(a[pos][i].dest, val);\n}\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\ta[x].push_back((edge) {y, i});\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tdfs(i, i);\n\tfor (int i = 1; i <= n; i++)\n\tfor (unsigned j = 0; j < a[i].size(); j++)\n\t\tif (vis[a[i][j].dest][i]) ans[a[i][j].home] ^= true;\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(pre, -1, sizeof(pre));\n\t\tmemset(suf, -1, sizeof(suf));\n\t\tpre[i] = suf[i] = 0;\n\t\tfor (unsigned j = 0; j < a[i].size(); j++)\n\t\t\tif (pre[a[i][j].dest] == -1) dfspre(a[i][j].dest, j);\n\t\tfor (unsigned j = a[i].size(); j > 0; j--)\n\t\t\tif (suf[a[i][j - 1].dest] == -1) dfssuf(a[i][j - 1].dest, j - 1);\n\t\tfor (unsigned j = 0; j < a[i].size(); j++)\n\t\t\tif (pre[a[i][j].dest] != suf[a[i][j].dest]) ans[a[i][j].home] ^= true;\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tif (ans[i]) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nclass SCC {\nprivate:\n    const int V;\n    vector<vector<int> > G;\n    vector<int> ord, low;\n    stack<int> st;\n    void dfs(const int u, int& tm){\n        ord[u] = low[u] = tm++, st.push(u);\n        for(int v : G[u]){\n            if(ord[v] < 0){\n                dfs(v, tm);\n                low[u] = min(low[u], low[v]);\n            }else if(cmp[v] < 0){\n                low[u] = min(low[u], ord[v]);\n            }\n        }\n        if(ord[u] == low[u]){\n            while(true){\n                const int v = st.top();\n                st.pop();\n                cmp[v] = cnt;\n                if(v == u) break;\n            }\n            ++cnt;\n        }\n    }\npublic:\n    vector<vector<int> > graph;\n    vector<int> cmp;\n    int cnt;\n    SCC(const int node_size)\n        : V(node_size), G(V), ord(V, -1), low(V), cmp(V, -1), cnt(0){}\n    void add_edge(const int from, const int to){\n        G[from].push_back(to);\n    }\n    int solve(){ // 強連結成分の数を返す\n        int tm = 0;\n        for(int i = 0; i < V; ++i){\n            if(ord[i] < 0) dfs(i, tm);\n        }\n        for(int i = 0; i < V; ++i) cmp[i] = cnt - 1 - cmp[i];\n        return cnt;\n    }\n    void make_graph(){\n        graph.resize(cnt);\n        for(int i = 0; i < V; ++i){\n            for(int j : G[i]){\n                if(cmp[i] != cmp[j]){\n                    graph[cmp[i]].push_back(cmp[j]);\n                }\n            }\n        }\n    }\n};\n\nusing P = pair<int, int>;\n\n\n\nvector<int> G[1001];\n\nvector<P> bs;\nint used[1001], val[1001];\nint dfs(int v, int p) {\n  int res = 0, cnt = 0;\n  used[v] = 1; // searching\n  for(int w : G[v]) {\n    if(w == v) {\n      // self-loop edge\n      continue;\n    }\n    if(w == p) {\n      if(cnt > 0) {\n        // (p, v): multiple edges\n        res += 1;\n        val[w] += 1;\n      }\n      ++cnt;\n      continue;\n    }\n    if(!used[w]) {\n      res += dfs(w, v);\n    } else if(used[w] == 1) {\n      res += 1;\n      val[w] += 1;\n    }\n  }\n  used[v] = 2; // searched\n  res -= val[v];\n\n  if(p != -1 && res == 0) {\n    bs.push_back(p < v ? P(p, v) : P(v, p));\n  }\n  return res;\n}\n\nvoid bridge() {\n  bs.clear();\n  for(int i=0; i<1001; ++i) used[i] = val[i] = 0;\n  dfs(0, -1);\n}\n\nvector<vector<int> > g;\nset<pair<int,int> > cb;\n\nint psm[1001][1001];\nvoid dfs2(int s,int id,set<int> &t){\n    t.insert(id);\n    for(auto x:g[id]){\n        if(t.count(x))continue;\n        psm[s][x]++;\n        if(psm[s][x]>=3)continue;\n        dfs2(s,x,t);\n    }\n    t.erase(id);\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    g.resize(n);\n    SCC scc(n);\n    vector<pair<int,int> > edge;\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        a--;\n        b--;\n        edge.push_back(MP(a,b));\n        scc.add_edge(a,b);\n    }\n    int c = scc.solve();\n    vector<int> cmp = scc.cmp;\n    rep(i,m){\n        int a = edge[i].first;\n        int b = edge[i].second;\n        if(cmp[a]!=cmp[b]){\n            G[cmp[a]].push_back(cmp[b]);\n        }else{\n            g[a].push_back(b);\n        }\n    }\n    bridge();\n    for(auto x:bs){\n        cb.insert(x);\n    }\n    rep(i,n){\n        psm[i][i] = 1;\n        set<int>t;\n        t.insert(i);\n        dfs2(i,i,t);\n    }\n\n    for(auto x:edge){\n        int a = x.first;\n        int b = x.second;\n        if(cmp[a]!=cmp[b]){\n            if(cb.count(MP(cmp[a],cmp[b]))){\n                cout << \"same\\n\";\n            }else{\n                cout << \"diff\\n\";\n            }\n        }else{\n            if(psm[a][b]>=2){\n                cout << \"same\\n\";\n            }else{\n                cout << \"diff\\n\";\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint ans[200010];\nvector<int> adj[1010], radj[1010], sadj[1010], U, V;\nint tin[1010], bck[1010], id[1010], timer, scnt;\nstack<int> stk;\n\nvoid dfs(int u) {\n    tin[u] = timer++;\n    bck[u] = tin[u];\n    stk.push(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int e = adj[u][i];\n        int v = V[e];\n        if(tin[v] == -1) {\n            dfs(v);\n            bck[u] = min(bck[u], bck[v]);\n        }\n        else if(id[v] == -1) {\n            bck[u] = min(bck[u], tin[v]);\n        }\n    }\n    if(bck[u] == tin[u]) {\n        while(1) {\n            int t = stk.top(); stk.pop();\n            id[t] = scnt;\n            if(t == u) break;\n        }\n        scnt++;\n    }\n}\n\nint cc[1010][1010];\nint dp(int u, int d) {\n    int &ret = cc[u][d];\n    if(ret != -1) return ret;\n    if(u == d) return ret = 0;\n\n    ret = 0;\n    for(int i = 0; i < sadj[u].size(); i++) {\n        int e = sadj[u][i];\n        int v = id[ V[e] ];\n        ret = max(ret, 1 + dp(v, d));\n    }\n    return ret;\n}\n\nvoid scc() {\n    memset(tin, -1, sizeof(tin));\n    memset(id, -1, sizeof(id));\n    for(int i = 0; i < N; i++) if(tin[i] == -1) {\n        dfs(i);\n    }\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            sadj[ id[u] ].push_back(e);\n        }\n    }\n    memset(cc, -1, sizeof(cc));\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            int cnt = 0;\n            for(int i = 0; i < sadj[u].size(); i++) {\n                int e = sadj[u][i];\n                if(id[v] == id[ V[e] ]) cnt++;\n            }\n            if(cnt > 1 || dp(id[u], id[v]) > 1) ans[e] = 1;\n            else ans[e] = 0;\n        }\n    }\n}\n\nqueue<int> q1, q2;\nint dist1[1010], dist2[1010], par1[1010], par2[1010];\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < M; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(i);\n        radj[v].push_back(i);\n        U.push_back(u);\n        V.push_back(v);\n    }\n\n    scc();\n\n    for(int u = 0; u < N; u++) {\n        memset(dist1, -1, sizeof(dist1));\n        memset(dist2, -1, sizeof(dist2));\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                q1.push(v);\n                dist1[v] = 0;\n                par1[v] = v;\n            }\n        }\n        while(!q1.empty()) {\n            int t = q1.front(); q1.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist1[v] == -1) {\n                        dist1[v] = dist1[t] + 1;\n                        par1[v] = par1[t];\n                        q1.push(v);\n                    }\n                    else if(dist2[v] == -1 && par1[v] != par1[t]) {\n                        dist2[v] = dist1[t] + 1;\n                        par2[v] = par1[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n        while(!q2.empty()) {\n            int t = q2.front(); q2.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist2[v] == -1 && par1[v] != par2[t]) {\n                        dist2[v] = dist2[t] + 1;\n                        par2[v] = par2[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                if(dist2[v] != -1) ans[e] = 0;\n                else ans[e] = 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++) {\n        if(ans[i]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// u -> v same: ban u -> v, u is reachable from v ^ vice versa = 0\n// Problem : F - Two Faced Edges\n// Contest : AtCoder Regular Contest 092\n// URL : https://atcoder.jp/contests/arc092/tasks/arc092_d\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define sort(a, n) sort(a + 1, a + n + 1)\n#define temptts template <class T, class... Ts>\n\nconst int N = 1001, M = 2e5 + 2, mod = 1e9 + 7, inf = 2e9;\n\nstruct edge_list {\n\tint u, v, pre, nex;\n} edge[M];\n\nbool vis[N];\nvector<int> radj[N];\nint n, m, ban, ans[M], cur[M], head[N], tail[N];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor (int i = head[v]; i; i = edge[i].pre) {\n\t\tint u = edge[i].v;\n\t\tif (u == ban || vis[u]) continue;\n\t\tdfs(u);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tradj[v].push_back(i);\n\t\tedge[i] = {u, v, head[u], 0};\n\t\thead[u] = i;\n\t}\n\tfor (int i = m; i >= 1; i--) {\n\t\tint u = edge[i].u;\n\t\tedge[i].nex = tail[u];\n\t\ttail[u] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tban = 0;\n\t\tdfs(i);\n\t\tfor (auto id : radj[i]) {\n\t\t\tans[id] ^= vis[edge[id].u];\n\t\t}\n\t\tban = i;\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int j = head[i]; j; j = edge[j].pre) {\n\t\t\tint u = edge[j].v;\n\t\t\tcur[j] |= vis[u];\n\t\t\tdfs(u);\t\n\t\t}\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor (int j = tail[i]; j; j = edge[j].nex) {\n\t\t\tint u = edge[j].v;\n\t\t\tans[j] ^= cur[j] | vis[u];\n\t\t\tdfs(u);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tputs(ans[i] ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=1005,MAXM=20005;\n\nint N,M;\nvector<int> adj[MAXN];\nint E[MAXM][2];\n\nint p[MAXN][MAXN],q[MAXN][MAXN];\nbool vis[MAXN];\n\nvoid mark(int s,int u,int id,int mk[])\n{\n\tif(u==s||vis[u])return;\n\tvis[u]=true;\n\tmk[u]=id;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t\tmark(s,adj[u][i],id,mk);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1,a,b;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tE[i][0]=a;E[i][1]=b;\n\t\tadj[a].push_back(b);\n\t}\n\t\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tint id=0;\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],++id,p[i]);\n\t\tmemset(vis,0,sizeof vis);\n\t\treverse(adj[i].begin(),adj[i].end());\n\t\tid=adj[i].size();\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],id--,q[i]);\n\t}\n\t\n\tfor(int i=1;i<=M;i++)\n\t\tif((p[E[i][1]][E[i][0]]>0)==(p[E[i][0]][E[i][1]]!=q[E[i][0]][E[i][1]]))\n\t\t\tputs(\"same\");\n\t\telse\n\t\t\tputs(\"diff\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nconst int N = 1e3+3;\n\n\nint cnt[N][N];\npair< int, int > edge[N*200];\nint n, m;\nvector<int> g[N];\n\n#define u first\n#define v second\n\nvoid dothething(int root) {\n\tqueue< pair<int, int> > q;\n\tset< pair<int, int> > vis;\n\tint k = 0;\n\tfor (auto c : g[root]) {\n\t\tk++;\n\t\tq.push({c, k});\n\t\tcnt[root][c] = 1;\n\t\tvis.insert({c, k});\n\t} \n\twhile (q.empty() == false) {\n\t\tint u = q.front().u;\n\t\tint e = q.front().v; q.pop();\n\t\tfor (auto v : g[u]) {\n\t\t\tif (v == root) continue;\n\t\t\tint k = vis.size();\n\t\t\tif (cnt[root][v] == 2) continue;\n\t\t\tvis.insert({v, e});\n\t\t\tif (vis.size() != k) {\n\t\t\t\tcnt[root][v]++;\n\t\t\t\tq.push({v, e});\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tmemset(cnt, 0, sizeof(cnt));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &edge[i].u, &edge[i].v);\n\t\tg[edge[i].u].push_back(edge[i].v);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tdothething(i);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\t// cout << cnt[edge[i].u][edge[i].v] << '\\n';\n\t\tif (cnt[edge[i].u][edge[i].v] == 1) {\n\t\t\tif (cnt[edge[i].v][edge[i].u] >= 1) {\n\t\t\t\tcout << \"diff\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"same\\n\";\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\tif (cnt[edge[i].v][edge[i].u] >= 1) {\n\t\t\t\tcout << \"same\\n\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"diff\\n\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nvector<vector<vector<int>>> reachable(auto G) {\n  vector<vector<vector<int>>> ok(2, vector<vector<int>>(G.size(), vector<int>(G.size(), -1)));\n\n  function<void(int, int, int)> dfs = [&](auto b, auto root, auto u) {\n    for(auto v: G[u]) if(ok[b][root][v] == -1) {\n      ok[b][root][v] = ok[b][root][u];\n      dfs(b, root, v);\n    }\n  };\n\n  for(auto v=0; v<G.size(); ++v) ok[0][v][v] = ok[1][v][v] = 0;\n  for(auto root=0; root<G.size(); ++root) for(auto i=0; i<G[root].size(); ++i) for(auto b: {0, 1}) {\n    auto x = (b==0) ? i : G[root].size()-1-i;\n    auto v = G[root][x];\n    if(ok[b][root][v] == -1) {\n      ok[b][root][v] = x;\n      dfs(b, root, v);\n    }\n  }\n  return ok;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  vector<int> a(M), b(M);\n  for(auto i=0; i<M; ++i) {\n    cin >> a[i] >> b[i];\n    --a[i]; --b[i];\n    G[a[i]].push_back(b[i]);\n  }\n\n  auto ok = reachable(G);\n\n  for(auto i=0; i<M; ++i) {\n    auto u = a[i], v = b[i];\n    auto ab = ok[0][u][v]!=ok[1][u][v];\n    auto ba = ok[0][v][u]!=-1;\n    if(ab==ba) cout << \"same\" << endl;\n    else       cout << \"diff\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n#define N (1010)\n#define M (200010)\n#define PB push_back\nint n, m;\nint v[N][N];\nint src, cv;\nint vst[N], a[M], b[M], suc[N], cnt[N];\nint f[N][N], g[N][N];\nvoid dfs(int x){\n    vst[x] = cv;\n    for (int i = 0, y; i < cnt[x]; ++i){\n        y = v[x][i];\n        if (cv != vst[y]){\n            if (suc[y]) f[src][y] = 1;\n            dfs(y);\n        }\n    }\n}\nvoid dfs2(int x){\n    vst[x] = cv;\n    for (int i = 0, y; i < cnt[x]; ++i){\n        y = v[x][i];\n        if (vst[y] != cv){\n            dfs2(y);\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= m; ++i) {\n        scanf(\"%d%d\", a+i, b+i);\n        v[a[i]][cnt[a[i]]++] = b[i];\n    }\n    for (int i = 1; i <= n; ++i){\n        src = i;\n        for (int j = 1; j <= n; ++j){\n            suc[j] = 0;\n        }\n        for (int j = 0; j < cnt[i]; ++j){\n            suc[v[i][j]] = 1;\n        }\n        vst[i] = ++cv;\n        for (int j = 0; j < cnt[i]; ++j){\n            dfs(v[i][j]);\n        }\n        vst[i] = ++cv;\n        for (int j = cnt[i]-1; ~j; --j){\n            dfs(v[i][j]);\n        }\n        cv++;\n        dfs2(i);\n        for (int j = 1; j <= n; ++j){\n            g[i][j] = vst[j] == cv;\n        }\n    }\n    for (int i  =1; i <= m; ++i){\n        // printf(\"%d %d\\n\", f[a[i]][b[i]], g[b[i]][a[i]]);\n        printf(\"%s\\n\", !(f[a[i]][b[i]] ^ g[b[i]][a[i]]) ? \"same\" : \"diff\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/extc++.h>\n#include<bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector,O3\")\nusing namespace std;using ll = long long;using ull = unsigned long long;using ul = unsigned;using db = double;using __gnu_pbds::null_type;\n#ifdef _debug \n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) 0&&0\n#endif\n#define eout(i) {cout << (i) << '\\n';exit(0);}\n#define priority_queue __gnu_pbds::priority_queue\n#define unordered_map __gnu_pbds::gp_hash_table\n#define rep(a, b) {for(int i = a;i > 0;--i){b;}}\n#define multe int T;for(cin >> T;T--;)\npair<long long, long long> ext_gcd(long long a, long long b){if(a % b == 0)return {0ll, 1ll};auto get = ext_gcd(b, a % b);return {get.second, get.first - a / b * get.second};} long long ext_inv(long long a, long long p){return (ext_gcd(a, p).first + p) % p;} template<typename T> using rbtree = __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>; template<typename T> inline long long pow(long long v, long long t, const T &p){long long res = 1;for(;t;t >>= 1, v = v * v % p)if(t & 1)res = res * v % p;return res;} template<typename T> inline void floyd_warshall(vector<vector<T>> &dp){for(int i = 0;i < dp.size();++i)for(int j = 0;j < dp.size();++j)for(int k = 0;k < dp.size();++k)dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k]);} template<typename T> inline ostream& operator << (ostream &ou, const vector<T> &a){for(auto it = a.begin();it != a.end();++it)ou << (it != a.begin() ? \" \" : \"\") << *it;return ou;} template<typename T> inline vector<vector<T>> operator * (const vector<vector<T>> &a, const vector<vector<T>> &b){assert(a.front().size() == b.size());vector<vector<T>> res(a.size(), vector<T>(b.front().size()));for(int i = 0;i < a.size();++i)for(int j = 0;j < b.front().size();++j)for(int k = 0;k < a.front().size();++k)res[i][j] += a[i][k] * b[k][j];return res;} template<typename T> inline vector<vector<T>> pow(vector<vector<T>> v, long long t){vector<vector<T>> res;for(;t;t >>= 1, v = v * v)if(t & 1)res = (res.empty() ? v : res * v);return res;} template<typename T> void read(int n, T *s){while(n--)cin >> *s, ++s;} template<typename T> void read(int n, vector<T> &v){for(int i = 0;i < n;++i)cin >> v[i];} template<typename T> void write(int n, T *s){while(n--)cout << *s << \" \\n\"[n==0], ++s;} template<typename T1, typename T2>inline istream& operator >> (istream &in, pair<T1, T2> &a){return in >> a.first >> a.second;} template<typename T1, typename T2>inline ostream& operator << (ostream &ou, const pair<T1, T2> &b){return ou << b.first << ' ' << b.second;} template<typename T1, typename T2>inline pair<T1,T2> operator + (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first + b.first, a.second + b.second};} template<typename T1, typename T2>inline pair<T1,T2> operator - (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first - b.first, a.second - b.second};} template<typename T1, typename T2>inline long long operator ^ (const pair<T1,T2> &a, const pair<T1,T2> &b){return (long long)a.first * b.second - (long long)a.second * b.first;} \nconst int maxn = 1001;\nstring out[2]{\"same\\n\", \"diff\\n\"};\nint res[maxn * maxn];\nint n, m;\nvector<pair<int,int>> edge[maxn], rev[maxn];\nbool vis[maxn];\nint togo[maxn], tl;\nvoid bfs(const int &now){\n\tmemset(vis, 0, sizeof vis);\n\ttl = 1, togo[0] = now, vis[now] = true;\n\tfor(int i = 0;i < tl;++i){\n\t\tfor(const auto &j : edge[togo[i]])if(!vis[j.second]){\n\t\t\tvis[j.second] = true;\n\t\t\ttogo[tl++] = j.second;\n\t\t}\n\t}\n}\nvoid getpath(const int &now, int *v, const int &id, const int &block){\n\ttl = 1, togo[0] = now;\n\tfor(int i = 0;i < tl;++i){\n\t\tfor(const auto &j : edge[togo[i]])if(j.second != block and !v[j.second]){\n\t\t\tv[j.second] = id;\n\t\t\ttogo[tl++] = j.second;\n\t\t}\n\t}\n}\nint sid[maxn], bid[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\tfor(int i = 0, a, b;i < m;++i){\n\t\tcin >> a >> b;\n\t\tedge[a].emplace_back(i+1, b);\n\t\trev[b].emplace_back(i+1, a);\n\t}\t\n\tfor(int i = 1;i <= n;++i){\n\t\tbfs(i);\n\t\tfor(auto &j : rev[i])res[j.first] ^= (bool)vis[j.second];\n\t\tmemset(sid, 0, sizeof sid), memset(bid, 0, sizeof bid);\n\t\tfor(int j = 0;j < (int)edge[i].size();++j)getpath(edge[i][j].second, sid, edge[i][j].first, i);\n\t\tfor(int j = (int)edge[i].size()-1;j > -1;--j)getpath(edge[i][j].second, bid, edge[i][j].first, i);\n\t\tfor(auto &j : edge[i])res[j.first] ^= ((sid[j.second] and sid[j.second] != j.first) || (bid[j.second] and bid[j.second] != j.first));\n\t}\n\tfor(int i = 1;i <= m;++i)cout << out[res[i]&1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <tuple>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n#define to_pair(x, y) (((x) << 10) | (y))\n\nusing namespace std;\n\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\nvector< vector<int> > e, re;\n\nUnionFind cc(1024);\nUnionFind scc(1024);\nint post[1024];\nint rev[1024];\nbool visited[1024];\nbool visited2[1024];\n\nint t = 1;\n\nvoid dfs0(int u, int r) {\n    cc.unite(u, r);\n    post[u] = 1;  // dummy\n    for (int w : e[u]) {\n        if (!post[w]) {\n            dfs0(w, r);\n        }\n    }\n    post[u] = t;\n    rev[t] = u;\n    ++t;\n}\n\nvoid dfs1(int u, int r, int cr, bool visited[]) {\n    scc.unite(u, r);\n    visited[u] = true;\n    for (int w : re[u]) {\n        if (cc.find(w) != cr) {\n            continue;\n        }\n        if (!visited[w]) {\n            dfs1(w, r, cr, visited);\n        }\n    }\n}\n\nvoid dfs2(int u, int r, int first, unordered_set<int>& rs, bool visited[]) {\n    visited[u] = true;\n    for (int w : e[u]) {\n        if (!visited[w]) {\n            dfs2(w, r, first, rs, visited);\n        } else if (w != r && w != first) {\n            rs.insert(to_pair(r, w));\n        }\n    }\n}\n\nvoid traverse(int n, int s, unordered_set<int>& rs) {\n    fill(visited2, visited2 + n + 1, false);\n    visited2[s] = true;\n    for (int w : e[s]) {\n        visited2[w] = true;\n    }\n    for (int w : e[s]) {\n        dfs2(w, s, w, rs, visited2);\n    }\n}\n\nvoid solve(int n, int m, vector< pair<int, int> >& edges) {\n    int cur;\n    int r1, cr;\n\n    fill(post, post + n + 1, 0);\n    fill(rev, rev + n + 1, 0);\n\n    fill(visited, visited + n + 1, false);\n    rep(r, 1, n + 1) {\n        if (!post[r]) {\n            cur = t;\n            dfs0(r, r);\n            cr = cc.find(r);\n            for (int v = t - 1; v >= cur; --v) {\n                r1 = rev[v];\n                if (!visited[r1]) {\n                    dfs1(r1, r1, cr, visited);\n                }\n            }\n        }\n    }\n\n    unordered_set<int> path_exists;\n    int a, b;\n    int scc_a, scc_b;\n    bool exist;\n    \n    fill(visited, visited + n + 1, false);\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        if (!visited[a]) {\n            visited[a] = true;\n            traverse(n, a, path_exists);\n        }\n    }\n\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        scc_a = scc.find(a);\n        scc_b = scc.find(b);\n        exist = (path_exists.find(to_pair(a, b)) != path_exists.end());\n        cout << (((scc_a == scc_b) != exist) ? \"diff\" : \"same\") << endl;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n\n    int n, m;\n    int a, b;\n    vector< pair<int, int> > edges;\n    \n    cin >> n >> m;\n    e.resize(n + 1);\n    re.resize(n + 1);\n    rep(i, 0, m) {\n        cin >> a >> b;\n        edges.push_back(make_pair(a, b));\n        e[a].push_back(b);\n        re[b].push_back(a);\n    }\n\n    solve(n, m, edges);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <vector>\ntypedef long long lint;\nconst int N=1005;\nconst int M=2e5+5;\nint n,m;\nbool irp[N][N],lnk[N][N];\n\nnamespace utils{\n\ttemplate <class T> inline void apn(T &x,const T y){x=x<y?x:y;}\n\ttemplate <class T> inline void apx(T &x,const T y){x=x>y?x:y;}\n\tinline int nxi(){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=getchar())>'9'||c<'0')&&c!='-');\n\t\tconst bool f=c=='-'&&(c=getchar());\n\t\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nnamespace G{\n\tint rt,cnt,fir[N],col[N];\n\tstd::vector <int> g[N];\n\tstruct edge{\n\t\tint fr,to;\n\t}eg[M];\n\n\tinline void add(const int a,const int b){\n\t\tg[a].push_back(b);\n\t\teg[++cnt]=(edge){a,b};\n\t}\n\n\tvoid dfs(const int x){\n\t\tcol[x]=lnk[rt][x]=1;\n\t\tfor(std::vector <int> ::iterator it=g[x].begin(); it!=g[x].end(); ++it){\n\t\t\tif(!col[*it]) dfs(*it);\n\t\t}\n\t}\n\n\tvoid getrep(const int x){\n\t\tint cnt=0;\n\t\tfor(std::vector <int> ::iterator it=g[x].begin(); it!=g[x].end(); ++it){\n\t\t\tirp[x][*it]|=col[*it]!=++cnt;\n\t\t}\n\t}\n\n\tvoid set(const int x){\n\t\trt=x;\n\t\tmemset(col+1,0,n*sizeof(col[0]));\n\t\tfor(std::vector <int> ::iterator it=g[x].begin(); it!=g[x].end(); ++it){\n\t\t\tif(col[*it]) irp[x][*it]=1;\n\t\t\telse dfs(*it);\n\t\t}\n\t\tstd::reverse(g[x].begin(),g[x].end());\n\t\tmemset(col+1,0,n*sizeof(col[0]));\n\t\tfor(std::vector <int> ::iterator it=g[x].begin(); it!=g[x].end(); ++it){\n\t\t\tif(col[*it]) irp[x][*it]=1;\n\t\t\telse dfs(*it);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=nxi(),m=nxi();\n\tfor(int i=1; i<=m; ++i){\n\t\tconst int a=nxi(),b=nxi();\n\t\tG::add(a,b);\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tG::set(i);\n\t}\n\tfor(int i=1; i<=m; ++i){\n\t\tint x=G::eg[i].fr,y=G::eg[i].to;\n\t\tputs(irp[x][y]^lnk[y][x]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\nconst int limit = 1010;\nusing edge = struct{int to,id;};\nvector<edge> graph[limit];\n\nbool visited[limit];\nint a[200010],b[200010];\n\nvoid dfs(int v,int skip){\n\tvisited[v] = true;\n\tfor(auto &e:graph[v]){\n\t\tif(visited[e.to] or e.id == skip) continue;\n\t\tdfs(e.to,skip);\n\t}\n}\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\n\trep(i,m){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--,b[i]--;\n\t\tgraph[a[i]].push_back({b[i],i});\n\t}\n\n\trep(i,m){\n\t\trep(v,n) visited[v] = false;\n\t\tdfs(a[i],i);\n\t\tbool ab = visited[b[i]];\n\t\trep(v,n) visited[v] = false;\n\t\tdfs(b[i],i);\n\t\tbool ba = visited[a[i]];\n\t\tif(ab != ba)\n\t\t\tputs(\"diff\");\n\t\telse\n\t\t\tputs(\"same\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int INF=0x7f7f7f7f;\nconst int maxn=(2e5)+10;\nint n,m,tot,head[1010],nxt[maxn];\nint to[maxn],dis[1010][1010][2],from[maxn];\nint t[1010][1010][2],ans;\nbool vis[1010];\nvoid add(int x) {\n\ttot++; nxt[tot]=head[x];\n\thead[x]=tot;\n}\nstruct node { int u,d,tt; };\nqueue<node> q;\nvoid dijkstra(int s) {\n\tmemset(dis[s],INF,sizeof(dis[s]));\n\tfor (int i=head[s];i;i=nxt[i])\n\t\tdis[s][to[i]][0]=1,t[s][to[i]][0]=to[i],q.push((node){to[i],1,to[i]});\n\twhile (!q.empty()) {\n\t\tint u=q.front().u,d=q.front().d,tmp,T=q.front().tt;\n\t\tq.pop();\n\t\tif (dis[s][u][1]<d) continue;\n\t\tfor (int i=head[u],v;i;i=nxt[i]) {\n\t\t\tv=to[i];\n\t\t\tif (v==s) continue;\n\t\t\ttmp=d+1;\n\t\t\tif (tmp<dis[s][v][0]) {\n\t\t\t\tswap(tmp,dis[s][v][0]);\n\t\t\t\tt[s][v][0]=T;\n\t\t\t\tq.push((node){v,dis[s][v][0],T});\n\t\t\t}\n\t\t\tif (tmp>=dis[s][v][0]&&tmp<dis[s][v][1]&&t[s][v][0]!=T) {\n\t\t\t\tdis[s][v][1]=tmp;\n\t\t\t\tt[s][v][1]=T;\n\t\t\t\tq.push((node){v,dis[s][v][1],T});\n\t\t\t}\n\t\t}\n\t}\n}\nint dfn[1010],low[1010];\nint sid[1010],cnt,idx;\nbool inStack[1010];\nint st[1010];\nvoid tarjan(int u) {\n    dfn[u]=low[u]=++idx;\n    inStack[u]=1;\n    st[++tot]=u;\n    for (int i=head[u],v;i;i=nxt[i]) {\n        v=to[i];\n        if (dfn[v]==-1) {\n            tarjan(v);\n            low[u]=min(low[u],low[v]);\n        }\n        else if (inStack[v])\n            low[u]=min(low[u],dfn[v]);\n    }\n    if (dfn[u]==low[u]) {\n        cnt++;\n        while (1) {\n            int v=st[tot];\n            tot--; inStack[v]=0;\n            sid[v]=cnt;\n            if (v==u) break;\n        }\n    }\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m);\n\tfor (int i=1;i<=m;i++) {\n\t\tread(from[i]); read(to[i]);\n\t\tadd(from[i]);\n\t}\n\tmemset(dfn,-1,sizeof(dfn));\n\ttot=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tdijkstra(i);\n\t\tif (dfn[i]==-1) tarjan(i);\n\t}\n\tint x,y;\n\tfor (int i=1;i<=m;i++) {\n\t\tx=from[i];\n\t\ty=to[i];\n\t\tans=dis[x][y][1];\n\t\tif (sid[x]==sid[y]&&ans!=INF) printf(\"same\\n\");\n\t\telse if (sid[x]!=sid[y]&&ans==INF) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define sz(a) (int)(a).size()\n#define rep(i, a, b) for (int i = (a), _b = (b); i < _b; ++i)\n#define frep(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<ii> vii;\n\nconst int inf = 1e9 + 7;\nconst ll linf  = 1ll * inf * inf;\nconst int N = 1000 + 7;\nconst int M = 20;\nconst int multipleTest = 0;\n\nint ways[N][N];\nint n, m;\n\nvii edge;\n\nclass StrComp {\npublic:\n\tint num[N], low[N];\n\tint cs[N];\n\tvector<int> adj[N];\n\t int cnt = 0;\n\t int comps = 0;\n\tbitset<N> go[N];\n\tvector<int> rev[N];\n\tint tIn[N];\n\tset<int> nxt;\n\t\n\tint dp[N];\n\t\n\tvoid init(int r) {\n\t\trep(i, 1, n + 1) {\n\t\t\tnum[i] = low[i] = cs[i] = 0;\n\t\t\tadj[i].clear();\n\t\t\tgo[i].reset();\n\t\t\trev[i].clear();\n\t\t\ttIn[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tcnt = comps = 0;\n\t\t nxt.clear();\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tadj[e.first].push_back(e.second);\n\t\t\t} else if (e.first == r) {\n\t\t\t\tnxt.insert(e.second);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (!num[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t\tif (!r || nxt.size() <= 1) return;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tfor (int v : adj[u]) {\n\t\t\t\tif (cs[u] != cs[v]) {\n\t\t\t\t\tint u1 = cs[u], v1 = cs[v];\n\t\t\t\t\tif (!go[u1][v1]) {\n\t\t\t\t\t\tgo[u1].set(v1);\n\t\t\t\t\t\trev[u1].push_back(v1);\n\t\t\t\t\t\t++tIn[v1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) dp[cs[v]]++;\n\t\t\n\t\tstatic int q[N], bot, top;\n\t\tbot = top = 0;\n\t\tfor (int i = 1; i <= comps; ++i) if (!tIn[i]) q[top++] = i;\n\t\t\n\t\twhile (bot < top) {\n\t\t\tint u = q[bot++];\n\t\t\tfor (int v : rev[u]) {\n\t\t\t\ttIn[v]--;\n\t\t\t\tdp[v] += dp[u];\n\t\t\t\tif (!tIn[v]) {\n\t\t\t\t\tq[top++] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) if (dp[cs[v]] > 1) ways[r][v] = true;\n\t}\n\t\n\tvoid dfs(int u) {\n\t\tstatic stack<int> stk;\n\t\tlow[u] = num[u] = ++cnt;\n\t\tstk.push(u);\n\t\tfor (int v : adj[u]) {\n\t\t\tif (cs[v]) continue;\n\t\t\tif (!num[v]) {\n\t\t\t\tdfs(v);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], num[v]);\n\t\t\t}\n\t\t}\n\t\tif (low[u] == num[u]) {\n\t\t\tcs[u] = ++comps;\n\t\t\twhile (stk.top() != u) {\n\t\t\t\tcs[stk.top()] = comps;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\tassert(!stk.empty() && stk.top() == u);\n\t\t\tstk.pop();\n\t\t}\n\t}\n} st;\n\nbool can[N][N];\nint root;\nvector<int> adj[N];\n\nvoid dfs(int u) {\n\tcan[root][u] = true;\n\tfor (int v : adj[u]) {\n\t\tif (can[root][v]) continue;\n\t\tdfs(v);\n\t}\n}\n\n\nvoid solve() {\n\tcin >> n >> m;\n\tmemset(ways, 0, sizeof(ways));\n\trep(i, 0, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tedge.push_back({u, v});\n\t\tadj[u].push_back(v);\n\t}\n\tfor (int i = 1; i <= n; ++i) st.init(i);\n\t\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\troot = i;\n\t\tdfs(i);\n\t}\n\tfor (ii e : edge) {\n\t\tint u = e.first;\n\t\tint v = e.second;\n\t\tif (can[v][u]) {\n\t\t\tif (ways[u][v]) puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t} else {\n\t\t\tif (ways[u][v]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint Test = 1;\n\tif (multipleTest) {\n\t\tcin >> Test;\n\t}\n\tfor(int i = 0; i < Test; ++i) {\n\t\t//        printf(\"Case #%d: \", i + 1);\n\t\tsolve();\n\t}\n#ifdef _LOCAL_\n\tcout << \"\\n\" << 1.0 * clock() / CLOCKS_PER_SEC << \"\\n\";\n#endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 1010;\n\nint n, m;\nint eu[N], ev[N];\nbool vis[N];\nvector<pair<int, int>> g[N], ig[N];\n\nbool ans[N];\n\nvoid reachable(int u) {\n  vis[u] = true;\n  for (const auto& pr : g[u])\n    if (!vis[pr.first])\n      reachable(pr.first);\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m;\n  for (int i = 1; i <= m; ++i) {\n    cin >> eu[i] >> ev[i];\n    g[eu[i]].emplace_back(ev[i], i);\n    ig[ev[i]].emplace_back(eu[i], i);\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    for (int rep = 0; rep < 2; ++rep) {\n      memset(vis, 0, sizeof(vis));\n      vis[i] = true;\n      for (const auto &pr : g[i])\n        if (vis[pr.first])\n          ans[pr.second] = true;\n        else\n          reachable(pr.first);\n      reverse(g[i].begin(), g[i].end());\n    }\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    reachable(i);\n    for (const auto& pr : ig[i]) {\n      int j, id;\n      tie(j, id) = pr;\n      ans[id] ^= vis[j];\n    }\n  }\n  for (int i = 1; i <= m; ++i)\n    cout << (ans[i] ? \"diff\\n\" : \"same\\n\");\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint ans[200010];\nvector<int> adj[1010], sadj[1010], U, V;\nint tin[1010], bck[1010], id[1010], timer, scnt;\nstack<int> stk;\n\nvoid dfs(int u) {\n    tin[u] = timer++;\n    bck[u] = tin[u];\n    stk.push(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int e = adj[u][i];\n        int v = V[e];\n        if(tin[v] == -1) {\n            dfs(v);\n            bck[u] = min(bck[u], bck[v]);\n        }\n        else if(id[v] == -1) {\n            bck[u] = min(bck[u], tin[v]);\n        }\n    }\n    if(bck[u] == tin[u]) {\n        while(1) {\n            int t = stk.top(); stk.pop();\n            id[t] = scnt;\n            if(t == u) break;\n        }\n        scnt++;\n    }\n}\n\nint cc[1010][1010];\nint dp(int u, int d) {\n    int &ret = cc[u][d];\n    if(ret != -1) return ret;\n    if(u == d) return ret = 0;\n\n    ret = 0;\n    for(int i = 0; i < sadj[u].size(); i++) {\n        int e = sadj[u][i];\n        int v = id[ V[e] ];\n        ret = max(ret, 1 + dp(v, d));\n    }\n    return ret;\n}\n\nvoid scc() {\n    memset(tin, -1, sizeof(tin));\n    memset(id, -1, sizeof(id));\n    for(int i = 0; i < N; i++) if(tin[i] == -1) {\n        dfs(i);\n    }\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            sadj[ id[u] ].push_back(e);\n        }\n    }\n    memset(cc, -1, sizeof(cc));\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            if(dp(id[u], id[v]) > 1) ans[e] = 1;\n            else ans[e] = 0;\n        }\n    }\n}\n\nqueue<int> q1, q2;\nint dist1[1010], dist2[1010], par1[1010], par2[1010];\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < M; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(i);\n        U.push_back(u);\n        V.push_back(v);\n    }\n\n    scc();\n\n    for(int u = 0; u < N; u++) {\n        memset(dist1, -1, sizeof(dist1));\n        memset(dist2, -1, sizeof(dist2));\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int e = adj[u][i];\n            int v = V[e];\n            if(id[u] == id[v]) {\n                q1.push(v);\n                dist1[v] = 0;\n                par1[v] = v;\n            }\n        }\n        while(!q1.empty()) {\n            int t = q1.front(); q1.pop();\n\n            for(int i = 0; i < adj[t].size(); i++) {\n                int e = adj[t][i];\n                int v = V[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist1[v] == -1) {\n                        dist1[v] = dist1[t] + 1;\n                        par1[v] = par1[t];\n                        q1.push(v);\n                    }\n                    else if(dist2[v] == -1 && par1[v] != par1[t]) {\n                        dist2[v] = dist1[t] + 1;\n                        par2[v] = par1[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n        while(!q2.empty()) {\n            int t = q2.front(); q2.pop();\n\n            for(int i = 0; i < adj[t].size(); i++) {\n                int e = adj[t][i];\n                int v = V[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist2[v] == -1 && par1[v] != par2[t]) {\n                        dist2[v] = dist2[t] + 1;\n                        par2[v] = par2[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < adj[u].size(); i++) {\n            int e = adj[u][i];\n            int v = V[e];\n            if(id[u] == id[v]) {\n                if(dist2[v] != -1) ans[e] = 0;\n                else ans[e] = 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++) {\n        if(ans[i]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nauto rd=read<int>;\nconst int N=1001, M=2e5;\nint n, m, a[M], b[M], head[N], next[M], rhead[N], rnext[M];\nint queue[N], *qhead, *qtail, min[N], max[N];\nbool vis[N], rev[M], without[M];\nvoid bfs(int u) {\n\tqhead=qtail=queue;\n\tif(vis[u]) return;\n\tvis[*qtail++=u]=true;\n\twhile(qhead!=qtail) {\n\t\tu=*qhead++;\n\t\tfor(int j=head[u]; j!=-1; j=next[j])\n\t\t\tif(!vis[b[j]]) vis[*qtail++=b[j]]=true;\n\t}\n}\nint main() {\n\tn=rd(), m=rd();\n\tmemset(head, -1, n*sizeof(int));\n\tmemset(rhead, -1, n*sizeof(int));\n\tfor(int i=0; i<m; ++i) {\n\t\ta[i]=rd()-1, b[i]=rd()-1;\n\t\tnext[i]=head[a[i]];\n\t\thead[a[i]]=i;\n\t\trnext[i]=rhead[b[i]];\n\t\trhead[b[i]]=i;\n\t}\n\tfor(int i=0; i<n; ++i) {\n\t\tmemset(vis, 0, n);\n\t\tbfs(i);\n\t\tfor(int j=rhead[i]; j!=-1; j=rnext[j]) rev[j]=vis[a[j]];\n\t}\n\tfor(int i=0; i<n; ++i) {\n\t\tstd::vector<int> out;\n\t\tfor(int j=head[i]; j!=-1; j=next[j]) out.push_back(j);\n\t\tmemset(vis, 0, n);\n\t\tvis[i]=true;\n\t\tfor(int j: out) {\n\t\t\tbfs(b[j]);\n\t\t\tfor(int *p=queue; p!=qtail; ++p) max[*p]=j;\n\t\t}\n\t\tstd::reverse(out.begin(), out.end());\n\t\tmemset(vis, 0, n);\n\t\tvis[i]=true;\n\t\tfor(int j: out) {\n\t\t\tbfs(b[j]);\n\t\t\tfor(int *p=queue; p!=qtail; ++p) min[*p]=j;\n\t\t}\n\t\tfor(int j=head[i]; j!=-1; j=next[j]) without[j]=(min[b[j]]!=j)||(max[b[j]]!=j);\n\t}\n\tfor(int i=0; i<m; ++i) puts(rev[i]^without[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\ts[++top]=e[p].k;\n\t\t\tif(vis[i][e[p].k]) continue;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=0;\n\t\t}\n\t\tint mn=0;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\ttemp[p]=vis[i][p];\n\t\t\tif(!temp[p]&&!mn) mn=p;\n\t\t}\n\t\tif(!mn) mn=1;\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>mn;p--){\n\t\t\tif(vis[i][s[p]]) continue;\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 1005;\nconst int Maxm = 200005;\n\nint n, m;\nint a[Maxm], b[Maxm];\nvector <ii> neigh[Maxn];\nint cur, tim[Maxn], low[Maxn];\nint imp[Maxm];\nint my[Maxn];\nvector <int> S;\nbool onStack[Maxn];\nint curcol, col[Maxn];\nint res[Maxm];\nint dp[Maxn];\nvector <int> gneigh[Maxn];\nbool vis[Maxn];\nmap <ii, int> M;\n\nint Connect(int v)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tmy[v] = -1;\n\tS.push_back(v); onStack[v] = true;\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (!tim[u.first]) {\n\t\t\timp[u.second] |= 2;\n\t\t\tres += Connect(u.first); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v]) {\n\t\t\tif (my[v] != -1) imp[my[v]] ^= 1;\n\t\t\tlow[v] = tim[u.first];\n\t\t\timp[u.second] ^= 1; \n\t\t\tmy[v] = u.second;\n\t\t}\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tcurcol++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tcol[w] = curcol;\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int v, int forb)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tS.push_back(v); onStack[v] = true;\n\tif (v == b[forb]) {\n\t\tint u = a[forb];\n\t\tif (!tim[u]) {\n\t\t\tres += Count(u, forb); low[v] = min(low[v], low[u]); \n\t\t} else if (onStack[u] && tim[u] < low[v])\n\t\t\tlow[v] = tim[u];\n\t}\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (u.second == forb) continue;\n\t\tif (!tim[u.first]) {\n\t\t\tres += Count(u.first, forb); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v])\n\t\t\tlow[v] = tim[u.first];\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int forb)\n{\n\tint ans = 0;\n\tcur = 0;\n\tfill(tim, tim + Maxn, 0); fill(low, low + Maxn, 0);\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tans += Count(i, forb);\n\treturn ans; \n}\n\nint Visit(int v)\n{\n\tif (vis[v]) return dp[v];\n\tint res = 0;\n\tfor (int i = 0; i < gneigh[v].size(); i++)\n\t\tres = max(res, Visit(gneigh[v][i]) + 1);\n\tdp[v] = res; vis[v] = true;\n\treturn dp[v];\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\", &a[i], &b[i]);\n\t\tneigh[a[i]].push_back(ii(b[i], i));\n\t}\n\tint comp = 0;\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tcomp += Connect(i);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (col[a[i]] != col[b[i]]) {\n\t\t\tgneigh[col[a[i]]].push_back(col[b[i]]);\n\t\t\tM[ii(col[a[i]], col[b[i]])]++;\n\t\t\tif (imp[i]) res[i] = Count(i) != comp;\n\t\t} else if (imp[i]) res[i] = Count(i) != comp;\n\tfor (int i = 1; i <= curcol; i++)\n\t\tVisit(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!imp[i] && col[a[i]] != col[b[i]]) {\n\t\t\tres[i] = abs(dp[col[a[i]]] - dp[col[b[i]]]) > 1;\n\t\t\tif (M[ii(col[a[i]], col[b[i]])] > 1) res[i] = 1;\n\t\t}\n\t\tprintf(\"%s\\n\", res[i]? \"diff\": \"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nvoid solve() {\n    int n,m;\n    cin >> n >> m;\n    vector<vector<pair<int, int>>> g(n), r(n);\n    for (int i = 0; i < m; i++) {\n        int x,y;\n        cin >> x >> y;\n        x--;y--;\n        g[x].emplace_back(i,y);\n        r[y].emplace_back(i,x);\n    }\n    vector<bool> trk(n, false);\n    function<void(int)> dfs = [&](int u){\n        trk[u] = true;\n        for (auto& p: g[u]) {\n            int i,v;\n            tie(i,v) = p;\n            if (!trk[v]) {\n                dfs(v);\n            }\n        }\n    };\n    vector<bool> in_scc(m);\n    for (int v = 0; v < n; v++) {\n        fill(trk.begin(), trk.end(), 0);\n        dfs(v);\n        for (auto& p: r[v]) {\n            int i,u;\n            tie(i,u) = p;\n            in_scc[i] = trk[u];\n        }\n    }\n    vector<bool> use_extra(m);\n    for (int u = 0; u < n; u++) {\n        for (int _ = 0; _ < 2; _++) {\n            fill(trk.begin(), trk.end(), 0);\n            trk[u] = true;\n            for (auto& p: g[u]) {\n                int i,v;\n                tie(i,v) = p;\n                if (trk[v]) use_extra[i] = true;\n                else dfs(v);\n            }\n            reverse(g[u].begin(), g[u].end());\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        cout << (in_scc[i] == use_extra[i]? \"same\":\"diff\") << \"\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma optimize(\"Ofast\")\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 1005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint id, to, nxt;\n} graph[M];\nint head[N], n, m, cnt = 0;\nbool g[N][N];\n\nvoid addedge (int id, int u, int v) {\n\tedge e = {id, v, head[u]};\n\tgraph[head[u] = cnt++] = e;\n}\n\nint vis_mn[N][N], vis_mx[N][N], ans[M];\nvoid dfs1 (int u, int r, int val) {\n\tif (vis_mn[r][u]) return ;\n\tvis_mn[r][u] = val;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (v == r) continue;\n\t\tdfs1(v, r, val);\n\t}\n}\n\nvoid dfs2 (int u, int r, int val) {\n\tif (vis_mx[r][u]) return ;\n\tvis_mx[r][u] = val;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (v == r) continue;\n\t\tdfs2(v, r, val);\n\t}\n}\n\nint main () {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) {\n\t\thead[i] = -1;\n\t\tfor (int j = 1; j <= n; j++) g[i][j] = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\taddedge(i, u, v), g[u][v] = true;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) vis_mn[i][j] = vis_mx[i][j] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (g[i][j]) dfs1(j, i, j);\n\t\t}\n\t\tfor (int j = n; j; j--) {\n\t\t\tif (g[i][j]) dfs2(j, i, j);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = head[i]; ~j; j = graph[j].nxt) {\n\t\t\tint u = i, v = graph[j].to;\n\t\t\tbool ans1 = vis_mn[v][u], ans2 = (vis_mn[u][v] < vis_mx[u][v]);\n\t\t\tans[graph[j].id] = (ans1 == ans2);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) puts(ans[i] ? \"same\" : \"diff\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * File Name:\tF.cpp\n * Author\t:\tCraZYali\n * Time\t\t:\t2020.01.25 20:35\n * Email\t:\tyms-chenziyang@outlook.com\n */\n\n#define DEP(i, s, e) for (register int i(s), end_##i(e); i >= end_##i; i--)\n#define REP(i, s, e) for (register int i(s), end_##i(e); i <= end_##i; i++)\n#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)\n\n#define chkmax(a, b) (a < (b) ? a = (b) : a) \n#define chkmin(a, b) (a > (b) ? a = (b) : a) \n\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\nconst int maxn = 1000 + 10, maxm = 2e5 + 10;\n\nvector <int> G[maxn];\n\ntemplate <typename T> inline T read()\n{\n\tT ans(0), flag(1);\n\tchar c(getchar());\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == '-') flag = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tans = ans * 10 + c - 48;\n\t\tc = getchar();\n\t}\n\treturn ans * flag;\n}\n\n#define file(FILE_NAME) freopen(FILE_NAME\".in\", \"r\", stdin), freopen(FILE_NAME\".out\", \"w\", stdout);\n\nint n, m, u[maxm], v[maxm];\n\nint q[maxn], head, tail;\nbool vis[maxn];\nvoid bfs(bool c[], int S)\n{\n\tREP(i, 1, n) vis[i] = 0;\n\tvis[S] = c[S] = 1;\n\tq[head = tail = 0] = S;\n\twhile (head <= tail)\n\t{\n\t\tint u = q[head++];\n\t\tfor (auto v : G[u]) if (!vis[v])\n\t\t{\n\t\t\tvis[v] = c[v] = 1;\n\t\t\tq[++tail] = v;\n\t\t}\n\t}\n}\npair <int, int> ban;\nvoid bfs(vector <bool> &c, int S)\n{\n\tREP(i, 1, n) vis[i] = 0;\n\tvis[S] = c[S] = 1;\n\tq[head = tail = 0] = S;\n\twhile (head <= tail)\n\t{\n\t\tint u = q[head++];\n\t\tfor (auto v : G[u])\n\t\t\tif (make_pair(u, v) == ban) break;\n\t\t\telse if (!vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = c[v] = 1;\n\t\t\t\tq[++tail] = v;\n\t\t\t}\n\t}\n}\n\nbool c[maxn][maxn];\nvector <vector <bool> > cp[maxn], cs[maxn];\nint p[maxn];\n\nint main()\n{\n#ifdef CraZYali\n\tfile(\"F\");\n#endif\n\tn = read<int>();\n\tm = read<int>();\n\tREP(i, 1, m)\n\t{\n\t\tu[i] = read<int>();\n\t\tv[i] = read<int>();\n\t\tG[u[i]].emplace_back(v[i]);\n\t}\n\tREP(i, 1, n) bfs(c[i], i);\n\tREP(i, 1, n) if (G[i].size()) \n\t{\n\t\tint l = G[i].size();\n\t\tcp[i].resize(l);\n\t\tcs[i].resize(l);\n\t\tvector <bool> status(n + 1, 0);\n\t\tstatus[i] = 1;\n\t\tREP(j, 0, l - 1)\n\t\t{\n\t\t\tban = make_pair(i, G[i][j]);\n\t\t\tbfs(status, i);\n\t\t\tcp[i][j] = status;\n\t\t}\n\t\treverse(G[i].begin(), G[i].end());\n#ifdef CraZYali\n\t\tprintf(\"start = %d\\n\", i);\n\t\tfor (auto j : G[i]) printf(\"%d \", j);putchar(10);puts(\"\");\n#endif\n\t\tstatus.clear();\n\t\tstatus = vector<bool>(n + 1, 0);\n\t\tstatus[i] = 1;\n\t\tDEP(j, l - 1, 0)\n\t\t{\n#ifdef CraZYali\n\t\t\tcout << i << ' ' << j << ' ' << G[i][l - j - 1] << endl;\n#endif\n\t\t\tban = make_pair(i, G[i][l - j - 1]);\n\t\t\tbfs(status, i);\n\t\t\tcs[i][j] = status;\n\t\t}\n#ifdef CraZYali\n\t\tREP(j, 1, n) printf(\"%d%c\",(int)status[j],j==n?'\\n':' ');\n\t\treverse(G[i].begin(), G[i].end());\n#endif\n\t}\n\tREP(i, 1, m)\n\t{\n\t\tint u = ::u[i], v = ::v[i];\n\t\tbool pback = c[v][u];\n\t\tbool pto = cp[u][p[u]][v] | cs[u][p[u]][v];\n\t\tif (pto == pback) puts(\"same\");\n\t\telse puts(\"diff\");\n#ifdef CraZYali\n\t\tcerr << u << ' ' << v << ' ' << pback << ' ' << cp[u][p[u]][v] << ' ' << cs[u][p[u]][v] << endl;\n#endif\n\t\tp[u]++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int sccid, int id)\n{\n\tSCC scc; \n\tvi coord; vector<ii> E;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tif(lab==id) swap(u,v);\n\t\tE.pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tE[i].fi=lower_bound(coord.begin(),coord.end(),E[i].fi)-coord.begin();\n\t\tE[i].se=lower_bound(coord.begin(),coord.end(),E[i].se)-coord.begin();\n\t}\n\tscc.init(coord.size());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tscc.addedge(E[i].fi,E[i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\n\nbool reach[1111][1111];\nmap<ii,int> CNT;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i][i]=1;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tif(!reach[i][j]) continue;\n\t\t\tfor(ii x:adj[j])\n\t\t\t{\n\t\t\t\treach[i][x.fi]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tbool pos=0;\n\t\t\t\tfor(int j=v+1;j<=i;j++)\n\t\t\t\t{\n\t\t\t\t\tif(reach[i][j]&&reach[j][v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpos=1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nvoid topological_sort(int f) {\n    if (starred[f]) return;\n    starred[f] = true;\n    for (int u : ll[f]) {\n        topological_sort(unf[u]);\n    }\n    topo_sort[topo_cnt++] = f;\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            topo_sort[topo_cnt++] = u;\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    /*\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (i=1; i<=n; ++i) {\n        int f = unf[i];\n        if (!starred[f]) {\n            topological_sort(f);\n        }\n    }\n    memset(starred, 0, 1010 * sizeof(bool));\n    //*/\n    for (i=0; i<topo_cnt/2; ++i) {\n        swap(topo_sort[i], topo_sort[topo_cnt - 1 - i]);\n    }\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=0; i<topo_cnt; ++i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    /*\n    for (i=1; i<=n; ++i) {\n        for (int j=1; j<=n; ++j) {\n            printf(\"%s\", dag_visit[i].test(j) ? \"1\" : \"0\");\n        }\n        puts(\"\");\n    }\n    //*/\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            puts(dag_edge[unf[u.first]][unf[u.second]] >= 2 || dag_second_visit[unf[u.first]].test(unf[u.second]) ? \"diff\" : \"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define P pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\nconst int N=1005,M=2e5+5;\nint n,m,x,y;\nint d[N];\nvector<P>e[N];\nvector<int>e2[N];\nbool can[M],bz[N],bz2[N];\nvoid cover(int x){\n\tif(bz2[x])return;\n\tbz2[x]=1;d[1]=x;\n\tfor(int l=0,r=1;x=d[++l],l<=r;)\n\t\tfor(P i:e[x])if(!bz2[i.fi])\n\t\t\tbz2[i.fi]=1,d[++r]=i.fi;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfo(i,1,m){\n\t\tcin>>x>>y;\n\t\te[x].pb(P(y,i));\n\t\te2[y].pb(x);\n\t}\n\tfo(i,1,n){\n\t\tfo(j,1,n)bz2[j]=bz[j]=0;\n\t\td[1]=i;bz[i]=1;\n\t\tfor(int l=0,r=1;x=d[++l],l<=r;)\n\t\t\tfor(int i:e2[x])if(!bz[i])\n\t\t\t\tbz[i]=1,d[++r]=i;\n\t\tbz2[i]=1;\n\t\tfor(P j:e[i]){\n\t\t\tcan[j.se]=bz2[j.fi];\n\t\t\tcover(j.fi);\n\t\t}\n\t\tfo(j,1,n)bz2[j]=0;\n\t\tbz2[i]=1;\n\t\tfd(j,0,e[i].size()-1){\n\t\t\tx=e[i][j].fi;\n\t\t\ty=e[i][j].se;\n\t\t\tcan[y]|=bz2[x];\n\t\t\tcover(x);\n\t\t\tcan[y]=can[y]?(bz[x]?0:1):(bz[x]?1:0);\n\t\t}\n\t}\n\tfo(i,1,m)printf(can[i]?\"diff\\n\":\"same\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\nstruct graph_t\n{\n\tint front,nex;\n}graph[201001];\nint tail=1000;\n\nvoid addedge(int u,int v)\n{\n\tint tmp=graph[u].nex;\n\tgraph[u].nex=++tail;\n\tgraph[tail].front=v;\n\tgraph[tail].nex=tmp;\n}\n\nint vis[1001][1001];\npair<int,int> edge[200001];\nint mark[1001];\nint times=1;\n\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=times;\n\tfor(int i=graph[now].nex;i;i=graph[i].nex)\n\t{\n\t\tif(now==from)continue; \n\t\tif(vis[from][graph[i].front]<2&&mark[graph[i].front]!=times)\n\t\t{\n\t\t\tdfs(from,graph[i].front);\n\t\t}\n\t}\n//\tmark[now]=false;\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i]=make_pair(from,to);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=graph[i].nex;j;j=graph[j].nex)\n\t\t{\n\t\t\tif(vis[i][graph[j].front]<2)\n\t\t\t{\n\t\t\t\tdfs(i,graph[j].front);\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> e(N);\n    using P = pair<int, int>;\n    vector<P> edge(M);\n    vector<vector<int>> start(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        e[a].push_back(b);\n        edge[i] = {a, b};\n        start[a].push_back(i);\n    }\n    vector<vector<bool>> ok(N, vector<bool>(N, false));\n    for (int i = 0; i < N; i++) {\n        queue<int> q;\n        q.push(i);\n        ok[i][i] = true;\n        while (not q.empty()) {\n            const int s = q.front();\n            q.pop();\n            for (const int to : e[s]) {\n                if (ok[i][to]) { continue; }\n                ok[i][to] = true;\n                q.push(to);\n            }\n        }\n    }\n    vector<bool> ans(M);\n    for (int i = 0; i < N; i++) {\n        vector<int> dp(N, -1);  // -1: yet, M: doubled\n        queue<int> q;\n        for (const int c : start[i]) {\n            dp[edge[c].second] = c;\n            q.push(edge[c].second);\n        }\n        while (not q.empty()) {\n            const int s = q.front();\n            q.pop();\n            if (s == i) { continue; }\n            for (const int to : e[s]) {\n                i if (dp[to] == M or dp[to] == dp[s]) { continue; }\n                if (dp[to] == -1) {\n                    dp[to] = dp[s];\n                    q.push(to);\n                } else {\n                    dp[to] = M;\n                    q.push(to);\n                }\n            }\n        }\n        for (const int c : start[i]) {\n            const bool ts = ok[edge[c].second][edge[c].first];\n            const bool dst = dp[edge[c].second] == M;\n            ans[c] = ts ^ dst;\n        }\n    }\n    for (int i = 0; i < M; i++) { cout << (ans[i] ? \"diff\" : \"same\") << endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    auto x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight = long long;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// 強連結成分分解 O(|V| + |E|)\nstd::vector<std::vector<Vertex>> strongly_connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  std::stack<Vertex> S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  // Tarjan\n  std::function<int(Vertex v)> dfs = [&](Vertex v) {\n    num[v] = low[v] = ++timer;\n    S.push(v); inS[v] = true;\n    for(const auto& e: G[v]) {\n      if(!num[e.to])     low[v] = std::min(low[v], dfs(e.to));\n      else if(inS[e.to]) low[v] = std::min(low[v], num[e.to]);\n    }\n    if(num[v] == low[v]) {\n      scc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto w = S.top(); S.pop(); inS[w] = false;\n        scc.back().push_back(w);\n        if(v == w) break;\n      }\n    }\n    return low[v];\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v);\n  return scc;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  vector<int> a(M), b(M);\n  for(auto i=0; i<M; ++i) {\n    cin >> a[i] >> b[i];\n    --a[i]; --b[i];\n    G[a[i]].push_back({a[i], b[i]});\n  }\n\n  auto scc = strongly_connected_component(G);\n  vector<int> group(N);\n  for(auto i=0; i<scc.size(); ++i) for(auto v: scc[i]) group[v] = i;\n\n  vector<int> in(N), out(N);\n  UnionFind<int> uf;\n  for(auto i=0; i<M; ++i) if(group[a[i]] != group[b[i]]) {\n    ++in[b[i]];\n    ++out[a[i]];\n    uf.unite(group[a[i]], group[b[i]]);\n  }\n\n  vector<int> indeg(N), outdeg(N);\n  for(auto i=0; i<M; ++i) if(group[a[i]] == group[b[i]]) {\n    ++outdeg[a[i]];\n    ++indeg[b[i]];\n  }\n  for(auto i=0; i<M; ++i) {\n    if(group[a[i]]!=group[b[i]]) {\n      if(uf.find(group[a[i]]) == uf.find(group[b[i]])) {\n        auto ai = in[a[i]]+1;\n        auto ao = out[a[i]]-1;\n        auto bi = in[b[i]]-1;\n        auto bo = out[b[i]]+1;\n        if(1<=ai&&1<=ao&&1<=bi&&1<=bo)cout << \"diff\" <<endl;\n        else                          cout << \"same\" <<endl;\n      } else {\n        cout << \"same\" << endl;\n      }\n    } else {\n      if(1<outdeg[a[i]] && 1<indeg[b[i]]) cout << \"same\" << endl;\n      else                                cout << \"diff\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    for (int i=g[x];i;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1]))continue;\n            if (!F[y][0])F[y][0]=v;\n            else\n                F[y][1]=v;\n            dfs(y,s,v);\n        }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for (int i=1;i<=m;i++){\n        cin>>e[i][0]>>e[i][1];\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?cout<<\"same\"<<endl:cout<<\"diff\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int INF=0x7f7f7f7f;\nconst int maxn=(2e5)+10;\nint n,m,tot,head[1010],nxt[maxn];\nint to[maxn],dis[1010][1010][2],from[maxn];\nint t[1010][1010][2],ans;\nbool vis[1010];\nvoid add(int x) {\n\ttot++; nxt[tot]=head[x];\n\thead[x]=tot;\n}\nstruct node { int u,d,tt; };\nqueue<node> q;\nvoid dijkstra(int s) {\n\tmemset(dis[s],INF,sizeof(dis[s]));\n\tfor (int i=head[s];i;i=nxt[i])\n\t\tdis[s][to[i]][0]=1,t[s][to[i]][0]=to[i],q.push((node){to[i],1,to[i]});\n\twhile (!q.empty()) {\n\t\tint u=q.front().u,d=q.front().d,tmp,T=q.front().tt;\n\t\tq.pop();\n\t\tif (dis[s][u][1]<d) continue;\n\t\tfor (int i=head[u],v;i;i=nxt[i]) {\n\t\t\tv=to[i];\n\t\t\tif (v==s) continue;\n\t\t\ttmp=d+1;\n\t\t\tif (tmp<dis[s][v][0]) {\n\t\t\t\tswap(tmp,dis[s][v][0]);\n\t\t\t\tt[s][v][0]=T;\n\t\t\t\tq.push((node){v,dis[s][v][0],T});\n\t\t\t}\n\t\t\tif (tmp>=dis[s][v][0]&&tmp<dis[s][v][1]&&t[s][v][0]!=T) {\n\t\t\t\tdis[s][v][1]=tmp;\n\t\t\t\tt[s][v][1]=T;\n\t\t\t\tq.push((node){v,dis[s][v][1],T});\n\t\t\t}\n\t\t}\n\t}\n}\nint dfn[1010],low[1010];\nint sid[1010],cnt,idx;\nbool inStack[1010];\nstack<int> st;\nvoid tarjan(int u) {\n    dfn[u]=low[u]=++idx;\n    inStack[u]=1;\n    st.push(u);\n    for (int i=head[u],v;i;i=nxt[i]) {\n        v=to[i];\n        if (dfn[v]==-1) {\n            tarjan(v);\n            low[u]=min(low[u],low[v]);\n        }\n        else if (inStack[v])\n            low[u]=min(low[u],dfn[v]);\n    }\n    if (dfn[u]==low[u]) {\n        cnt++;\n        while (1) {\n            int v=st.top();\n            st.pop(); inStack[v]=0;\n            sid[v]=cnt;\n            if (v==u) break;\n        }\n    }\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m);\n\tfor (int i=1;i<=m;i++) {\n\t\tread(from[i]); read(to[i]);\n\t\tadd(from[i]);\n\t}\n\tmemset(dfn,-1,sizeof(dfn));\n\tfor (int i=1;i<=n;i++) {\n\t\tdijkstra(i);\n\t\tif (dfn[i]==-1) tarjan(i);\n\t}\n\tint x,y;\n\tfor (int i=1;i<=m;i++) {\n\t\tx=from[i];\n\t\ty=to[i];\n\t\tans=dis[x][y][1];\n\t\tif (sid[x]==sid[y]&&ans!=INF) printf(\"same\\n\");\n\t\telse if (sid[x]!=sid[y]&&ans==INF) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nL n,m;\nL s[100010],e[100010];\nL ih[1111][1111];\nL chk[1111];\n\nvector<L>v[1111],back[1111];\nqueue<L>Q;\n\n\nL chk1[1111],chk2[1111];\n\nL ord[1111],ordtop;\nL scc[1111],scccolor;\n\nvoid dfs1(L x){\n\tL i;\n\tfor(i=0;i<v[x].size();i++)\n\t{\n\t\tif(!chk1[v[x][i]])\n\t\t{\n\t\t\tchk1[v[x][i]]=1;\n\t\t\tdfs1(v[x][i]);\n\t\t}\n\t}\n\tordtop++;\n\tord[ordtop]=x;\n}\n\nvoid dfs2(L x){\n\tscc[x]=scccolor;\n\tL i;\n\tfor(i=0;i<back[x].size();i++)\n\t{\n\t\tif(!chk2[back[x][i]])\n\t\t{\n\t\t\tchk2[back[x][i]]=1;\n\t\t\tdfs2(back[x][i]);\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tL i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&s[i],&e[i]);\n\t\tv[s[i]].push_back(e[i]);\n\t\tback[e[i]].push_back(s[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tchk[j]=0;\n\t\tchk[i]=-1;\n\t\tfor(j=0;j<v[i].size();j++)\n\t\t{\n\t\t\tchk[v[i][j]]=v[i][j];\n\t\t\tQ.push(v[i][j]);\n\t\t}\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tL x=Q.front();Q.pop();\n\t\t\t//printf(\"%lld %lld, \",x,chk[x]);\n\t\t\tfor(j=0;j<v[x].size();j++)\n\t\t\t{\n\t\t\t\tif(chk[x]==-1)\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\tif(chk[v[x][j]]!=-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chk[v[x][j]]!=chk[x]&&chk[v[x][j]]!=-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchk[v[x][j]]=chk[x];\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//puts(\"\");\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(!chk1[i])\n\t\t{\n\t\t\tchk1[i]=1;\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\tfor(i=n;i>=1;i--)\n\t{\n\t\tif(!chk2[ord[i]])\n\t\t{\n\t\t\tscccolor++;\n\t\t\tchk2[ord[i]]=1;\n\t\t\tdfs2(ord[i]);\n\t\t}\n\t}\n\t\n\t/*for(i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%lld \",scc[i]);\n\t}*/\n\t\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tprintf(ih[s[i]][e[i]]^(scc[s[i]]==scc[e[i]])?\"diff\":\"same\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int N=1005;\nint n,m,a[N][N],b[N][N],Ans[200005];\nstd::vector<int> G[N],Q[N];\n\nvoid DFS(int x,int c,int *Mark)\n{\n    if(Mark[x])return;\n    Mark[x]=c;\n    for(int y:G[x])if(!Mark[y])DFS(y,c,Mark);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1,x,y;i<=m;++i)\n    {\n        scanf(\"%d%d\",&x,&y);\n        G[x].push_back(y);\n        Q[x].push_back(i);\n    }\n    for(int i=1;i<=n;++i)\n    {\n        a[i][i]=b[i][i]=-1;\n        for(int j=0;j<=(int)G[i].size()-1;++j)DFS(G[i][j],j+1,a[i]);\n        for(int j=(int)G[i].size()-1;j>=0;--j)DFS(G[i][j],j+1,b[i]);\n    }\n    for(int i=1;i<=n;++i)\n        for(int j=0;j<(int)G[i].size();++j)\n        {\n            int x=a[G[i][j]]?1:0,y=a[i][G[i][j]]<=j||b[i][G[i][j]]>j+1;\n            Ans[Q[i][j]]=x!=y;\n        }\n    for(int i=1;i<=m;++i)puts(Ans[i]?\"diff\":\"same\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1010\n#define M 200010\nvector <int> G[N];\nint to[M],tag[N],q[2*N];\nbool ans1[M],ans2[M];\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\nsigned main(){\n\tint n=read(),m=read();\n\tfor (int i=1;i<=m;++i){\n\t\tint x=read();to[i]=read();\n\t\tG[x].push_back(i);\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<=n;++j) tag[j]=0;\n\t\tint t=1,w=0;\n\t\tfor (auto &x:G[i]){\n\t\t\tq[++w]=to[x];tag[to[x]]=x;\n\t\t}\n\t\twhile (t<=w){\n\t\t\tint x=q[t++],y=tag[x];\n\t\t\tfor (auto &p:G[x]){\n\t\t\t\tint tmp=to[p];\n\t\t\t\tif (tmp!=i){\n\t\t\t\t\tif (tag[tmp]!=-1){\n\t\t\t\t\t\tif (tag[tmp]==0){\n\t\t\t\t\t\t\tq[++w]=tmp;tag[tmp]=y;\n\t\t\t\t\t\t}else if (tag[tmp]!=y){\n\t\t\t\t\t\t\tq[++w]=tmp;tag[tmp]=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else ans1[p]=1;\n\t\t\t}\n\t\t}\n\t\tfor (auto &x:G[i]){\n\t\t\tif (tag[to[x]]==-1) ans2[x]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=m;++i) puts(ans1[i]^ans2[i]?\"diff\":\"same\");\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nvector<int>G[MAXN + 5]; int to[MAXM + 5];\nvoid addedge(int u, int i) {G[u].push_back(i);}\n\nint tag[MAXN + 5], que[2*MAXN + 5];\nbool ans1[MAXM + 5], ans2[MAXM + 5];\n\nint n, m;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint a; scanf(\"%d%d\", &a, &to[i]);\n\t\taddedge(a, i);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) tag[j] = 0;\n\t\tint s = 1, t = 0;\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\ttag[que[++t] = to[G[i][p]]] = G[i][p];\n\t\twhile( s <= t ) {\n\t\t\tint x = que[s++], y = tag[x];\n\t\t\tfor(int p=0;p<G[x].size();p++) {\n\t\t\t\tint q = to[G[x][p]];\n\t\t\t\tif( q != i ) {\n\t\t\t\t\tif( tag[q] != -1 ) {\n\t\t\t\t\t\tif( tag[q] == 0 )\n\t\t\t\t\t\t\ttag[que[++t] = q] = y;\n\t\t\t\t\t\telse if( tag[q] != y )\n\t\t\t\t\t\t\ttag[que[++t] = q] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse ans1[G[x][p]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\tif( tag[to[G[i][p]]] == -1 ) ans2[G[i][p]] = 1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tputs(ans1[i] ^ ans2[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N],d[N];\nstack<int>s;\nint tim,vis[N];\nint mp[N][N][2];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs(int now,int fa,int b,int f)\n{\n\tvis[now]=tim; mp[fa][now][f]=b;\n\tint len=e[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[e[now][i]]!=tim)\n\t\t\tdfs(e[now][i],fa,b,f);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n        d[U[i]].push_back(i);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        tim++;vis[i]=tim;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,d[i][j],0);\n        tim++;vis[i]=tim;\n        for(int j=up-1;j>=0;j--)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,d[i][j],1);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]][0]!=mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]][0]==mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2018 Sayutin Dmitry.\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n#include <iostream>\n#include <vector>\n#include <stdint.h>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <array>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <string>\n#include <assert.h>\n#include <iterator>\n#include <cstdint>\n#include <cinttypes>\n#include <string.h>\n#include <random>\n#include <numeric>\n#include <tuple>\n\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::min;\nusing std::abs;\nusing std::max;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\n#define pb push_back\n#define eb emplace_back\n\nstruct edge {\n    int to;\n    int id;\n};\n\nvoid dfs(vector<vector<edge>>& graph, vector<int>& order, vector<char>& used, int v) {\n    used[v] = 1;\n\n    for (auto u: graph[v])\n        if (not used[u.to])\n            dfs(graph, order, used, u.to);\n    \n    order.push_back(v);\n}\n\nvoid dfs2(vector<vector<edge>>& rgraph, vector<int>& cid, int v, int c) {\n    cid[v] = c;\n    for (auto u: rgraph[v])\n        if (cid[u.to] == -1)\n            dfs2(rgraph, cid, u.to, c);\n}\n\nvoid dfs3(vector<vector<int>>& gr, vector<char>& used, int v) {\n    used[v] = 1;\n    \n    for (auto u: gr[v])\n        if (not used[u])\n            dfs3(gr, used, u);\n}\n\nvoid dfs4(vector<vector<edge>>& gr, vector<char>& used, int v, int bad) {\n    used[v] = 1;\n    \n    for (auto u: gr[v])\n        if (not used[u.to] and u.id != bad)\n            dfs4(gr, used, u.to, bad);\n}\n\n\nvoid zhfs(vector<vector<edge>>& graph, vector<int>& cid, int v, vector<char>& used, vector<char>& mark) {\n    used[v] = 1;\n\n    for (auto u: graph[v])\n        if (not used[u.to] and cid[u.to] == cid[v]) {\n            mark[u.id] = 1;\n            zhfs(graph, cid, u.to, used, mark);\n        }\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    \n    // code here.\n    int n = input<int>();\n    int m = input<int>();\n\n    vector<char> ans(m, 0);\n    vector<pair<int, int>> lst(m);\n    \n    vector<vector<edge>> graph(n);\n    vector<vector<edge>> rgraph(n);\n    vector<vector<int>>  graph2(n);\n    for (int i = 0; i != m; ++i) {\n        int v, u;\n        cin >> v >> u;\n        --v, --u;\n        \n        graph[v].emplace_back(edge {u, i});\n        rgraph[u].emplace_back(edge {v, i});\n        \n        lst[i] = make_pair(v, u);\n    }\n\n    vector<int> order;\n    vector<char> used(n, false);\n\n    for (int i = 0; i != n; ++i)\n        if (not used[i])\n            dfs(graph, order, used, i);\n\n    std::reverse(ALL(order));\n    vector<int> cid(n, -1);\n    int cur_id = 0;\n    \n    for (int v: order)\n        if (cid[v] == -1)\n            dfs2(rgraph, cid, v, cur_id++);\n\n    vector<vector<int>> cgr(cur_id);\n    for (int v = 0; v != n; ++v)\n        for (auto u: graph[v])\n            if (cid[v] != cid[u.to])\n                cgr[cid[v]].push_back(cid[u.to]);\n\n    // for (auto& elem: cgr) {\n    //     std::sort(ALL(elem));\n    //     elem.resize(std::unique(ALL(elem)) - elem.begin());\n    // }\n    \n    vector<vector<int>> matrix(cur_id, vector<int>(cur_id));\n    for (int start = 0; start != cur_id; ++start) {\n        matrix[start][start] = 1;\n\n        for (int v = start; v != cur_id; ++v) {\n            for (auto go: cgr[v]) {\n                assert(go >= v);\n\n                matrix[start][go] += matrix[start][v];\n            }\n        }\n    }\n    \n    for (int v = 0; v != n; ++v)\n        for (auto u: graph[v])\n            if (cid[v] != cid[u.to])\n                ans[u.id] = matrix[cid[v]][cid[u.to]] >= 2;\n\n    vector<vector<int>> by_cid(cur_id);\n    for (int v = 0; v != n; ++v)\n        by_cid[cid[v]].push_back(v);\n\n    vector<char> mark(m, false);\n\n    vector<char> used1(n, false), used2(n, false);\n    for (int c = 0; c != cur_id; ++c) {\n        zhfs(graph, cid, by_cid[c][0], used1, mark);\n        zhfs(rgraph, cid, by_cid[c][0], used2, mark);\n    }\n\n    for (int i = 0; i != m; ++i)\n        if (mark[i]) {\n            std::fill(ALL(used), false);            \n            dfs4(graph, used, lst[i].first, i);\n\n            ans[i] = not used[lst[i].second];\n        }\n\n    for (auto elem: ans)\n        cout << (elem ? \"diff\\n\" : \"same\\n\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n\n2 2\n1 2\n2 1\n\n3 3\n1 2\n1 3\n2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define N 1005\n#define bit(x,y) ((x>>y)&1LL)\n#define loop(i,l,r) for(int i=(signed)(l); i<=(signed)(r); i++)\n\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &a) {\n    return os << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    for (unsigned int i = 0; i < a.size(); i++)\n        os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n    os << ']';\n    return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &a) {\n    os << '{';\n    for (typename set<T>::iterator it = a.begin(); it != a.end(); it++) {\n        typename set<T>::iterator jt = it;\n        os << *it << (++jt != a.end() ? \", \" : \"\");\n    }\n    os << '}';\n    return os;\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, map<T1, T2> &a) {\n    os << \"{\\n\";\n    for (typename map<T1, T2>::iterator it = a.begin(); it != a.end(); it++) {\n        typename map<T1, T2>::iterator jt = it;\n        os << \"  \" << it->first << \": \" << it->second << (++jt != a.end() ? \",\\n\" : \"\\n\");\n    }\n    os << '}';\n    return os;\n}\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint cnt[N][N];\nint mark[N][N];\nbool ansOrder[200005];\n\nvoid dfs(int u, int p, const int root, const int source) {\n    if (u == root) return;\n    if (cnt[root][u] >= 2) return;\n    if (cnt[root][u] == 1 && mark[root][u] == source) return;\n    cnt[root][u]++; mark[root][u] = source;\n    for (auto it : a[u]) {\n        int v = it.fi;\n        if (v == p) continue;\n        dfs(v, u, root, source);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    loop(i, 1, m) {\n        int u, v; cin >> u >> v;\n        a[u].push_back(mp(v, i));\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            dfs(v, u, u, v);\n        }\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            bool diff = false;\n            if (cnt[u][v] >= 2) {\n                if (cnt[v][u] == 0) diff = true;\n            }\n            else if (cnt[u][v] == 1) {\n                if (cnt[v][u] >= 1) diff = true;\n            }\n            ansOrder[it.se] = diff;\n        }\n    }\n    loop(i, 1, m) {\n        if (ansOrder[i] == false) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define x first\n#define y second\n#define mp make_pair\n#define elif else if\n#define prev prev2\n#define Edge pair <int, int>\n#define next next2\n#define u first\n#define v second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1007, N = 1007, MAXM = 2e5 + 7;\nvector<int> g[MAXM], gt[MAXM];\nint a[MAXM], b[MAXM], c1[MAXM], c2[MAXM];\nvector<int> topsort;\nint vis[MAXM];\nEdge ed[MAXM];\nbool used[MAXM];\nvoid dfs(int u) {\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (!used[v]) dfs(v);\n    }   \n}   \nvoid solve(int u) {\n    memset(used, 0, sizeof used);\n    used[u] = 1;\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n    memset(used, 0, sizeof used);\n    used[u] = 1;\n    reverse(g[u].begin(), g[u].end());\n    for (int e : g[u]) {\n        int v = ed[e].u ^ ed[e].v ^ u;\n        if (used[v]) {\n            c2[e] = 1;\n        }       \n        else {\n            dfs(v);\n        }   \n    }   \n}   \nvoid dfst1(int v) {\n    vis[v] = 1;\n    for (int e : g[v]) {\n        int u = b[e];\n        if (!vis[u])\n            dfst1(u);\n    }\n    topsort.push_back(v);\n}\nint clr = 0;\nvoid dfst2(int v) {\n    vis[v] = clr;\n    for (int e : gt[v]) {\n        int u = a[e];\n        if (!vis[u])\n            dfst2(u);\n    }\n}\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        cin >> a[i] >> b[i];\n        --a[i];\n        --b[i];\n        g[a[i]].push_back(i);\n        gt[b[i]].push_back(i);\n    }\n    for (int i = 0; i < n; ++i)\n        if (!vis[i])\n            dfst1(i);\n    fill(vis, vis + n, 0);\n    reverse(topsort.begin(), topsort.end());\n    for (int v : topsort)\n        if (!vis[v]) {\n            ++clr;\n            dfst2(v);\n        }\n\n    for (int i = 0; i < m; ++i) \n        c1[i] = (vis[a[i]] == vis[b[i]]);\n    for (int i = 0; i < m; ++i) {\n        ed[i] = {a[i], b[i]};\n    }   \n    for (int i = 0; i < n; ++i) {\n        solve(i);\n    }\n\n    #ifdef HOME\n    for (int i = 0; i < m; ++i) cout << c1[i] << ' '; cout << '\\n';\n    for (int i = 0; i < m; ++i) cout << c2[i] << ' '; cout << '\\n';\n    #endif\n\n    for (int i = 0; i < m; ++i) {\n        //cout << c1[i] << c2[i];\n        if (c1[i] ^ c2[i]) {\n            cout << \"diff\\n\";\n        }   \n        else {\n            cout << \"same\\n\";\n        }\n    }   \n    return;\n}\n\nsigned main() {\n\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    ios_base::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1005;\n\nvector<int> graph[N];\n\nint n, m, l[N], r[N], cnt[N][N], vis[N][N];\n\nvoid dfs(int u, int p, int root, int mark) {\n    if(u == p || u == root) return ;\n    if(cnt[root][u] >= 2) return ;\n    if(cnt[root][u] == 1 && vis[root][u] == mark) return ;\n    vis[root][u] = mark; cnt[root][u]++;\n    for(int i = 0; i < graph[u].size(); i++) {\n        int v = graph[u][i];\n        if(v == p) continue;\n        dfs(v, u, root, mark);\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++) {\n        cin >> l[i] >> r[i];\n        graph[l[i]].pb(r[i]);\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < graph[i].size(); j++) {\n            int v = graph[i][j];\n            dfs(v, i, i, v);\n        }\n    }\n    for(int i = 1; i <= m; i++) {\n        if(cnt[l[i]][r[i]] >= 2) {\n            if(cnt[r[i]][l[i]] == 0)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n        else {//1\n            if(cnt[r[i]][l[i]] >= 1)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1'009;\n\nvector<int> g[N];\nbool was[N];\nvector<int> order;\n\nvoid dfs1(int x) {\n  was[x] = true;\n  for (int y : g[x]) {\n    if (!was[y]) {\n      dfs1(y);\n    }\n  }\n  order.push_back(x);\n}\n\nvector<int> gt[N];\n\nvoid dfs2(int x, int ncomp, int *comp) {\n  comp[x] = ncomp;\n  for (int y : gt[x]) {\n    if (comp[y] == -1) {\n      dfs2(y, ncomp, comp);\n    }\n  }\n}\n\nbool can[N][N];\nint q[N];\nint comp1[N];\nint comp2[N];\nint p[N];\nbool lo[N];\nbool hi[N];\nint in[N];\nint out[N];\n\nconst int M = 200'009;\n\nint from[M];\nint to[M];\nbool ans[M];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", from + i, to + i);\n    --from[i];\n    --to[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n    gt[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    g[from[i]].push_back(to[i]);\n    gt[to[i]].push_back(from[i]);\n  }\n  memset(was, false, sizeof was);\n  order.clear();\n  for (int i = 0; i < n; ++i) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  memset(comp1, -1, sizeof comp1);\n  int ncomp1 = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (comp1[order[i]] == -1) {\n      dfs2(order[i], ncomp1, comp1);\n      ++ncomp1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    if (comp1[from[i]] != comp1[to[i]]) {\n      g[comp1[from[i]]].push_back(i);\n    }\n  }\n  memset(can, false, sizeof can);\n  for (int i = 0; i < ncomp1; ++i) {\n    can[i][i] = true;\n    q[0] = i;\n    for (int qh = 0, qt = 1; qh < qt; ++qh) {\n      int x = q[qh];\n      for (int id : g[x]) {\n        int y = comp1[to[id]];\n        if (!can[i][y]) {\n          can[i][y] = true;\n          q[qt++] = y;\n        }\n      }\n    }\n  }\n  memset(ans, false, sizeof ans);\n  for (int x = 0; x < ncomp1; ++x) {\n    vector<int> w;\n    for (int id : g[x]) {\n      w.push_back(comp1[to[id]]);\n    }\n    w.resize(distance(w.begin(), unique(w.begin(), w.end())));\n    for (int id : g[x]) {\n      int y = comp1[to[id]];\n      for (int z : w) {\n        if (z != y && can[z][y]) {\n          ans[id] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    memset(p, -1, sizeof p);\n    int sz = 0;\n    for (int j = 0; j < n; ++j) {\n      if (j != i && comp1[j] == comp1[i]) {\n        p[j] = sz++;\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      g[j].clear();\n      gt[j].clear();\n    }\n    for (int j = 0; j < m; ++j) {\n      if (p[from[j]] != -1 && p[to[j]] != -1) {\n        g[p[from[j]]].push_back(p[to[j]]);\n        gt[p[to[j]]].push_back(p[from[j]]);\n      }\n    }\n    memset(was, false, sizeof was);\n    order.clear();\n    for (int j = 0; j < sz; ++j) {\n      if (!was[j]) {\n        dfs1(j);\n      }\n    }\n    memset(comp2, -1, sizeof comp2);\n    int ncomp2 = 0;\n    for (int j = sz - 1; j >= 0; --j) {\n      if (comp2[order[j]] == -1) {\n        dfs2(order[j], ncomp2, comp2);\n        ++ncomp2;\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      hi[j] = true;\n      lo[j] = true;\n    }\n    for (int j = 0; j < m; ++j) {\n      if (p[from[j]] != -1 && p[to[j]] != -1) {\n        if (comp2[p[from[j]]] != comp2[p[to[j]]]) {\n          lo[comp2[p[from[j]]]] = false;\n          hi[comp2[p[to[j]]]] = false;\n        }\n      }\n    }\n    memset(in, 0, sizeof in);\n    memset(out, 0, sizeof out);\n    for (int j = 0; j < m; ++j) {\n      if (from[j] == i && p[to[j]] != -1) {\n        if (hi[comp2[p[to[j]]]]) {\n          ++in[comp2[p[to[j]]]];\n        }\n      } else\n      if (to[j] == i && p[from[j]] != -1) {\n        if (lo[comp2[p[from[j]]]]) {\n          ++out[comp2[p[from[j]]]];\n        }\n      }\n    }\n    for (int j = 0; j < m; ++j) {\n      if (from[j] == i && p[to[j]] != -1) {\n        if (hi[comp2[p[to[j]]]] && in[comp2[p[to[j]]]] == 1) {\n          ans[j] = true;\n        }\n      } else\n      if (to[j] == i && p[from[j]] != -1) {\n        if (lo[comp2[p[from[j]]]] && out[comp2[p[from[j]]]] == 1) {\n          ans[j] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    puts(ans[i] ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1005;\n\nvector<int> G[N];\n\nint a[N], b[N], vis[N], w[N][N], p[N][N], q[N][N];\n\nint n, m;\n\nvoid dfs(int u, int x)\n{\n\tvis[u] = 1, w[x][u] = 1;\n\tfor (auto v : G[u])\n\t\tif (!vis[v])\n\t\t\tdfs(v, x);\n}\n\nvoid dfs2(int u, int x, bool ch)\n{\n\tfor (auto v : G[u])\n\t\tif (v != x && !vis[v])\n\t\t{\n\t\t\tvis[v] = vis[u];\n\t\t\tdfs2(v, x, ch);\n\t\t}\n\tif (!ch)\n\t\tp[x][u] = vis[u];\n\telse\n\t\tq[x][u] = vis[u];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> a[i] >> b[i];\n\t\tG[a[i]].push_back(b[i]);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tdfs(i, i);\t\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tint SZ = G[i].size();\n\t\tfor (int j = 0; j < SZ; j++)\n\t\t{\n\t\t\tint v = G[i][j];\n\t\t\tif (!vis[v])\n\t\t\t\tvis[v] = v, dfs2(v, i, 0);\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tfor (int j = SZ - 1; j >= 0; j--)\n\t\t{\n\t\t\tint v = G[i][j];\n\t\t\tif (!vis[v])\n\t\t\t\tvis[v] = v, dfs2(v, i, 1);\t\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x = w[b[i]][a[i]];\n\t\tint y = (p[a[i]][b[i]] != b[i] || q[a[i]][b[i]] != b[i]);\n\t\tif (x == y)\n\t\t\tcout << \"same\" << endl;\n\t\telse\n\t\t\tcout << \"diff\" << endl;\n\t}\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\nconst int N=1005;\nmap<pair<int,int> ,int> Map;\nint Ans[N],ne[N],tot,m,n,x,y,f[N][N],Min[N],Max[N],flag[N],fi[N],zz[N];\nvector<int> G[N];\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nvoid dfs(int x){\n\tflag[x]=1;\n\tfor (int i=0;i<(int)G[x].size();i++)\n\t\tif (!flag[G[x][i]])dfs(G[x][i]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tMap[mp(x,y)]=i;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tmemset(flag,0,sizeof flag);\n\t\tdfs(i);\n\t\tfor (int j=1;j<=n;j++)f[i][j]=flag[j];\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tmemset(Min,-1,sizeof Min);\n\t\tmemset(Max,-1,sizeof Max);\n\t\tmemset(flag,0,sizeof flag);\n\t\tflag[i]=1;\n\t\tfor (int j=0;j<G[i].size();j++)\n\t\t\tif (!flag[G[i][j]]){\n\t\t\t\tdfs(G[i][j]);\n\t\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t\t\tif (Min[k]==-1&&flag[k])Min[k]=j;\n\t\t\t}\n\t\tmemset(flag,0,sizeof flag);\n\t\tflag[i]=1;\n\t\tfor (int j=G[i].size()-1;j>=0;j--)\n\t\t\tif (!flag[G[i][j]]){\n\t\t\t\tdfs(G[i][j]);\n\t\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t\t\tif (Max[k]==-1&&flag[k])Max[k]=j;\n\t\t\t}\n\t\tfor (int j=0;j<G[i].size();j++)\n\t\t\tif ((Max[G[i][j]]!=j||Min[G[i][j]]!=j)^f[G[i][j]][i])\n\t\t\t\tAns[Map[mp(i,G[i][j])]]=1;\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tif (!Ans[i])puts(\"same\");\n\t\telse puts(\"diff\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vv;\ntypedef vector<vector<ll>> vvll;\nconst ll inf = 1e16;\nconst ll md = 1000000007;\nvi to[1000];\nint can[1000][1000][2];\n\nvoid dfs0(int u, int st = -1, int en = -1) {\n  if (en == -1) {\n    for (int i = 0; i < to[u].size(); i++) {\n      int ku = to[u][i];\n      if (can[u][ku][0] != -1) continue;\n      can[u][ku][0] = i;\n      dfs0(ku, u, i);\n    }\n    return;\n  }\n  for (int i = 0; i < to[u].size(); i++) {\n    int ku = to[u][i];\n    if (ku == st) continue;\n    if (can[st][ku][0] != -1) continue;\n    can[st][ku][0] = en;\n    dfs0(ku, st, en);\n  }\n  return;\n}\n\nvoid dfs1(int u, int st = -1, int en = -1) {\n  if (en == -1) {\n    for (int i = to[u].size() - 1; i >= 0; i--) {\n      int ku = to[u][i];\n      if (can[u][ku][1] != -1) continue;\n      can[u][ku][1] = i;\n      dfs1(ku, u, i);\n    }\n    return;\n  }\n  for (int i = to[u].size() - 1; i >= 0; i--) {\n    int ku = to[u][i];\n    if (ku == st) continue;\n    if (can[st][ku][1] != -1) continue;\n    can[st][ku][1] = en;\n    dfs1(ku, st, en);\n  }\n  return;\n}\n\nint main() {\n  rep(i, 1000) rep(j, 1000) rep(k, 2) can[i][j][k] = -1;\n  int n, m;\n  cin >> n >> m;\n  vv ee;\n  rep(i, m) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    ee.push_back({a, b});\n    to[a].push_back(b);\n  }\n  vector<bool> fin(n, false);\n  for (vi e : ee) {\n    for (int u : e) {\n      if (fin[u] == false) {\n        fin[u] = true;\n        dfs0(u);\n        dfs1(u);\n      }\n    }\n    int u = e[0], v = e[1];\n    bool b0 = (can[u][v][0] == can[u][v][1]);\n    bool b1 = (can[v][u][0] + can[v][u][1] == -2);\n//    cout << can[u][v][0] << \" \" << can[u][v][1] << endl;\n    if (b0 == b1)\n      puts(\"same\");\n    else\n      puts(\"diff\");\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ninline void read(int &x)\n{\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\nstruct node{\n\tint nex,to,from;\n}edge[200005];\nint N,M;\nint head[1005],tot;\ninline void insert(int from,int to)\n{\n\tedge[++tot].nex=head[from];\n\thead[from]=tot;\n\tedge[tot].to=to;\n\tedge[tot].from=from;\n}\nint mex[1005][1005];\nbool vis[1005];\nvoid dfs(int v,int x)\n{\n\tvis[x]=1;\n\tfor(int i=head[x];i;i=edge[i].nex)\n\t\tif(!vis[edge[i].to]&&mex[v][edge[i].to]<=2)\n\t\t{\n\t\t\tmex[v][edge[i].to]++;\n\t\t\tdfs(v,edge[i].to);\n\t\t}\n\tvis[x]=0;\n\t \n}\nint main()\n{\n\tread(N);read(M);\n\tint u,v;\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tread(u);read(v);\n\t\tinsert(u,v);\n\t} \n\tfor(int i=1;i<=N;i++)\n\t\tdfs(i,i);\n\t/*for(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tcout<<mex[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tbool flag=0;\n\t\tif(mex[edge[i].from][edge[i].to]&&mex[edge[i].to][edge[i].from])\n\t\t\tif(mex[edge[i].from][edge[i].to]<2)\n\t\t\t\tflag=1;\n\t\tif(!mex[edge[i].to][edge[i].from]&&mex[edge[i].from][edge[i].to]>=2)\n\t\t\tflag=1;\n\t\tif(flag)\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << x << endl;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define MAX_V 1000\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];//辺を逆にしたグラフ\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];//属する強連結成分のトポロジカル順序\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); ++i){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n    used[v] = true;\n    cmp[v] = k;\n    for(int i = 0; i < rG[v].size(); ++i){\n        if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\nvoid scc(){\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v = 0; v < V; ++v){\n        if(!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i =(int) vs.size()-1; i >= 0; i--){\n        if(!used[vs[i]]) rdfs(vs[i],k++);\n    }\n    return;\n}\nint num[1000][1000];//num[i][j] = iからjへの行き方の総数みたいなもの(2以上は無視して2にする)\nint hoge[1000];//u->v辺を使ってきたやつを除外するため\nvoid dfs(int now,const int u,const int v){\n    num[u][now]++;\n    if(num[u][now]>=3){\n        //もう2回目なのでnow以降も2回目で無視\n        num[u][now] = 2;\n        return;\n    }\n    if(num[u][now]==2){\n        if(hoge[now] == v){\n            num[u][now] = 1;\n            return;\n        }\n    }\n    if(num[u][now]==1){\n        hoge[now] = v;\n    }\n    rep(i,G[now].size()){\n        if(G[now][i] != u){\n            dfs(G[now][i],u,v);\n        }\n    }\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    V = n;\n    vector<int>a(m),b(m);\n    rep(i,m){\n        scanf(\"%d%d\",&a[i],&b[i]);\n        a[i]--,b[i]--;\n        add_edge(a[i],b[i]);\n    }\n    scc();\n    rep(i,n){\n        rep(k,n)hoge[k] = -1;\n        rep(j,G[i].size()){\n            dfs(G[i][j],i,G[i][j]);\n        }\n    }\n    rep(i,m){\n        bool flag = false;\n        if(cmp[a[i]] == cmp[b[i]]){\n            if(num[a[i]][b[i]]==2)flag = true;\n        }else{\n            if(num[a[i]][b[i]]==1)flag = true;\n        }\n        if(flag){\n            puts(\"same\");\n        }else{\n            puts(\"diff\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 1010;\ntypedef std::vector<int> VI;\ntypedef std::pair<int, int> pi;\nVI out[MAXN], rout[MAXN], ine[MAXN];\nint n, m;\nint * ind; VI * so;\nvoid dfs(int t) { for (auto i : so[t]) if (!ind[i]) ind[i] = t, dfs(i); }\nstd::map<pi, int> u2v, v2u;\nint xs[200010], ys[200010];\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tstd::cin >> xs[i] >> ys[i];\n\t\tout[xs[i]].push_back(ys[i]);\n\t\tine[ys[i]].push_back(xs[i]);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::sort(out[i].begin(), out[i].end());\n\t\trout[i].assign(out[i].rbegin(), out[i].rend());\n\t}\n\tstatic int i1[MAXN], i2[MAXN];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(i1, 0, n + 1 << 2);\n\t\tmemset(i2, 0, n + 1 << 2);\n\t\tso = out,  ind = i1, i1[i] = n + 1; dfs(i);\n\t\tso = rout, ind = i2, i2[i] = n + 1; dfs(i);\n\t\tfor (auto t : ine[i]) if (i1[t]) v2u[pi(t, i)] = true;\n\t\tfor (auto t : out[i])\n\t\t\tif (i1[t] != i2[t] || i1[t] != i)\n\t\t\t\tu2v[pi(i, t)] = true;\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tauto t = pi(xs[i], ys[i]);\n\t\tstd::cout << (u2v[t] ^ v2u[t] ? \"diff\\n\" : \"same\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ninline void read(int &x)\n{\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\nstruct node{\n\tint nex,to,from;\n}edge[200005];\nint N,M;\nint head[1005],tot;\ninline void insert(int from,int to)\n{\n\tedge[++tot].nex=head[from];\n\thead[from]=tot;\n\tedge[tot].to=to;\n\tedge[tot].from=from;\n}\nint mex[1005][1005];\nbool vis[1005];\nvoid dfs(int v,int x)\n{\n\tvis[x]=1;\n\tfor(int i=head[x];i;i=edge[i].nex)\n\t\tif(!vis[edge[i].to]&&mex[v][edge[i].to]<2)\n\t\t{\n\t\t\tmex[v][edge[i].to]++;\n\t\t\tdfs(v,edge[i].to);\n\t\t}\n\tvis[x]=0;\n\t \n}\nint main()\n{\n\tread(N);read(M);\n\tint u,v;\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tread(u);read(v);\n\t\tinsert(u,v);\n\t} \n\tfor(int i=1;i<=N;i++)\n\t\tdfs(i,i);\n\t/*for(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tcout<<mex[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tbool flag=0;\n\t\tif(mex[edge[i].from][edge[i].to]&&mex[edge[i].to][edge[i].from])\n\t\t\tif(mex[edge[i].from][edge[i].to]<2)\n\t\t\t\tflag=1;\n\t\tif(!mex[edge[i].to][edge[i].from]&&mex[edge[i].from][edge[i].to]>=2)\n\t\t\tflag=1;\n\t\tif(flag)\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) cerr << #A << \" = \"; for (int i=1; i<=n; ++i) cerr << A[i] << ' '; cerr << '\\n';\n#define PR0(A, n) cerr << #A << \" = \"; for (int i=0; i<n; ++i) cerr << A[i] << ' '; cerr << '\\n';\n\nconst int maxn = 1002;\nconst int maxm = 200002;\nconst int inf = 1e9;\n\nint n, m, cnt[maxn], num[maxn], low[maxn], nTime;\nint scc[maxn], nSCC, curBranch[maxn];\nstack<int> st;\nbool ok[maxn][maxn];\nvector<int> g[maxn];\npair<int, int> e[maxm];\n\nvoid tarjan(int u) {\n\tst.push(u);\n\tnum[u] = ++nTime;\n\tlow[u] = inf;\n\tfor (int i=0; i<g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (scc[v]!=0)\n\t\t\tcontinue;\n\t\tif (num[v])\n\t\t\tlow[u] = min(low[u], num[v]);\n\t\telse {\n\t\t\ttarjan(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t}\n\t}\n\tif (low[u]<num[u])\n\t\treturn;\n\t++nSCC;\n\twhile (true) {\n\t\tint x = st.top(); st.pop();\n\t\tscc[x] = nSCC;\n\t\tif (x==u)\n\t\t\tbreak;\n\t}\n}\n\nvoid visit(int u, int branch, int root) {\n\tif (u!=branch)\n\t\tok[root][u] = true;\n\t++cnt[u];\n\tfor (int i=0; i<g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (v!=root && cnt[v]<2 && curBranch[v]!=branch) {\n\t\t\tcurBranch[v] = branch;\n\t\t\tvisit(v, branch, root);\n\t\t}\n\t}\n}\n\nvoid init(int x) {\n\tmemset(cnt, 0, sizeof(cnt));\n\tmemset(curBranch, 0, sizeof(curBranch));\n\tfor (int i=0; i<g[x].size(); ++i) {\n\t\tint u = g[x][i];\n\t\tcurBranch[u] = u;\n\t\t//debug(u);\n\t\t//debug(ok[3][4]);\n\t\tvisit(u, u, x);\n\t}\n}\n\nint main() {\n\t//freopen(\"data.inp\", \"r\", stdin);\n\t//freopen(\"data.out\", \"w\", stdout);\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i=1; i<=m; ++i) {\n\t\tcin >> e[i].first >> e[i].second;\n\t\tg[e[i].first].push_back(e[i].second);\n\t}\n\tfor (int i=1; i<=n; ++i) {\n\t\tif (scc[i]==0) {\n\t\t\ttarjan(i);\n\t\t}\n\t}\n\tinit(3);\n\t//debug(ok[3][4]);\n\tfor (int i=1; i<=n; ++i) {\n\t\tinit(i);\n\t}\n\tdebug(ok[3][4]);\n\tfor (int i=1; i<=m; ++i) {\n\t\tint u = e[i].first, v = e[i].second;\n\t\tif (scc[u]==scc[v]) {\n\t\t\tif (ok[u][v])\n\t\t\t\tcout << \"same\\n\";\n\t\t\telse \n\t\t\t\tcout << \"diff\\n\";\n\t\t}\n\t\telse {\n\t\t\tif (ok[u][v])\n\t\t\t\tcout << \"diff\\n\";\n\t\t\telse \n\t\t\t\tcout << \"same\\n\"; \n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n//    int dx[8]={0,1,0,-1,1,1,-1,-1};\n  //  int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                        \n\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    if (b == 0ll) {\n        x = 1ll;\n        y = 0ll;\n        return a;\n    }\n    ll d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n} \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tinv[ert]=beki(pr[ert],mod-2,mod);\n                \t\n                \tfor(int i=ert-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    //mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\t   \n       \n                               //----------------kokomade tenpure------------\nvector<int> gr[1100];\nvector<int> igr[1100];\nvector<int> ban;\n\nint V,e;\nint visit[1100]={0},gro[1100]={0};\n\nvoid dfs(int i){\n\tif(visit[i]==0){\n\t\tvisit[i]=1;\n\t\tfor(int k=0;k<gr[i].size();k++) dfs(gr[i][k]);\n\t\tban.push_back(i);\n\t}\n}\n\nvoid idfs(int i,int h){\n\tif(visit[i]==0){\n\t\tvisit[i]=1;\n\t\tgro[i]=h;\n\t\tfor(int k=0;k<igr[i].size();k++) idfs(igr[i][k],h);\n\t}\n}\n\nvoid kyouren(){\n\tfor(int i=0;i<V;i++){\n\t\tdfs(i);\n\t}\n\tfor(int i=0;i<V;i++) visit[i]=0;\n\tfor(int i=V-1;i>=0;i--){\n\t\tidfs(ban[i],ban[i]);\n\t}\n\n\n}\n\nvector<pa> eda;\nmap<pa,int> ma;\n\n\nvector<pa> naibu[1100];\nint GG[1100][1100]={};\nvector<pa> G[1100];\nvector<pa> H[1100];\nvector<int> G2[1100];\nint owari[1100]={};\nint ans[200020]={};\n// sonomama ->1\n// kawaru ->2\n\n\nint tmp[1100];\nint sumi[1100];\n\nint dfs1(int r,int p){\n\tif(sumi[r])return tmp[r];\n\tsumi[r]=1;\n\tif(r==p){\n\t\ttmp[r]=0;\n\t}\n\telse{\n\t\tint ima=-100;\n\t\tfor(auto v:G2[r])ima=max(ima,dfs1(v,p));\n\t\t\n\t\tima++;\n\t\tif(ima<0) tmp[r]=-100;\n\t\telse tmp[r]=ima;\n\t}\n\treturn tmp[r];\n}\n\nvoid dagdag(int r,int n){\n\tfor(int i=0;i<n;i++)sumi[i]=0;\n\tfor(auto v:G[r]){\n\t\tif(v.second==-1) continue;\n\t//\tcout<<\" \"<<v.first<<\" \"<<r<<\" \"<<dfs1(v.first,r)<<endl;\n\t\tif(dfs1(v.first,r)>1) ans[v.second]=2;\n\t\telse ans[v.second]=1;\n\t}\n}\nvector<int> cho[1010];\n\nvector<int> T[1010];\nvector<int> T2[1010];\n\nint dfs2(int r,int p,int mae){\n\tif(sumi[r])return tmp[r];\n\tsumi[r]=1;\n\tif(r==p){\n\t\ttmp[r]=0;\n\t}\n\telse{\n\t\tint ima=-100;\n\t\tfor(auto v:T2[r])if(v!=mae)ima=max(ima,dfs2(v,p,r));\n\t\t\n\t\tima++;\n\t\tif(ima<0) tmp[r]=-100;\n\t\telse tmp[r]=ima;\n\t}\n\treturn tmp[r];\n}\nint vis[1100];\nvoid ddff(int r){\n\tif(vis[r]) return;\n\tvis[r]=1;\n\tfor(auto v:T[r])if(!vis[v])ddff(v);\n}\n\nvoid uti(int r,int n){\n\tfor(auto v:cho[r]){\n\t\t\n\t\t\n\t\tif(T[v].size()==1){\n\t\t\tans[ma[{v,T[v][0]}]]=2;\n\t\t}\n\t\telse{\n\t\t\t\n\t\t\tint f=T[v].size();\n\t\t\tvector<int> ve(f,0);\n\t\t\tfor(int i=0;i<n;i++)vis[i]=0;\n\t\t\tvis[v]=1;\n\t\t\tfor(int i=0;i<f;i++){\n\t\t\t\t\n\t\t\t\tif(vis[T[v][i]])ve[i]=1;\n\t\t\t\tddff(T[v][i]);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++)vis[i]=0;\n\t\t\tvis[v]=1;\n\t\t\tfor(int i=f-1;i>=0;i--){\n\t\t\t\tif(vis[T[v][i]])ve[i]=1;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tddff(T[v][i]);\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<f;i++){\n\t\t\t\tif(ve[i]) ans[ma[{v,T[v][i]}]]=1;\n\t\t\t\telse ans[ma[{v,T[v][i]}]]=2;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\nsigned main(){\n\n\t\t\t  cin.tie(0);\n\t\t\tios::sync_with_stdio(false);\nint n,m;\ncin>>n>>m;\n\tV=n;\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\ty--;\n\t\tyy--;\n\t\tma[{y,yy}]=i;\n\t\t\teda.pb({y,yy});\n\t\tgr[y].pb(yy);\n\t\tigr[yy].pb(y);\n\t}\n\tkyouren();\n\tfor(int i=0;i<n;i++)cho[gro[i]].pb(i);\n\tfor(int i=0;i<m;i++){\n\t\tpa v=eda[i];\n\t\tif(gro[v.first]==gro[v.second]){\n\t\t\tnaibu[gro[v.first]].pb(v);\n\t\t\tT[v.first].pb(v.second);\n\t\t\tT2[v.second].pb(v.first);\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\tGG[v.first][v.second]++;\n\t\t\t\tH[gro[v.first]].pb({v.second,i});\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(auto v:H[i]){\n\t\t\tif(GG[i][v.first]==1){\n\t\t\t\tG[i].pb(v);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans[v.second]=1;\n\t\t\t}\n\t\t}\n\t\tfor(auto v:H[i]){\n\t\t\tif(GG[i][v.first]>1){\n\t\t\t\tG[i].pb(v);\n\t\t\t\tG[i].back().second=-1;\n\t\t\t\tGG[i][v.first]=0;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<n;i++){\n\t\tif((int)G[i].size()>1){\n\t\tfor(auto v:G[i]){\n\t\t\tans[v.second]=1;\n\t\t}\n\t\towari[i]=1;\n\t\twhile(G[i].size()>1)G[i].pop_back();\n\t\t}\n\t\telse if(G[i].size()==0) owari[i]=1;\n\t}\n\t*/\n\t\n\tfor(int i=0;i<n;i++)for(auto v:G[i]){\n\t//\tcout<<i<<\" \"<<v.first<<endl;\n\t\tG2[v.first].pb(i);\n\t}\n\tfor(int i=0;i<n;i++)if(!owari[i]){\n\t\tdagdag(i,n);\n\t}\n\t//\tfor(int i=0;i<m;i++)cout<<ans[i]<<endl;\n\n\tfor(int i=0;i<n;i++)if(naibu[i].size()) uti(i,n);\n\t\n\tfor(int i=0;i<m;i++)cout<<(ans[i]==1?\"same\":\"diff\")<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+10;\nconst int M=2e5+10;\n#define pb push_back\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,fr[M],to[M],nxt[M],tt,s,t,id[N],h[N];\nbool vis[N][N],ban[M],can[M];\n\nvoid adde(int u,int v) {\n\tfr[++tt]=u,to[tt]=v,nxt[tt]=h[u],h[u]=tt;\n}\n\nvoid dfs(int u) {\n\tif(vis[s][u]) return;\n\tvis[s][u]=1;\n\tfor(int i=h[u],v;v=to[i],i;i=nxt[i]) dfs(v);\n}\n\nvoid dfs2(int u) {\n\tif(id[u]||u==s) return;\n\tid[u]=t;\n\tfor(int i=h[u],v;v=to[i],i;i=nxt[i]) dfs2(v);\n}\n\nint main() {\n\tcin>>n>>m;\n\tfor(int i=1,u,v;i<=m;i++) u=gi(),v=gi(),adde(u,v);\n\tfor(s=1;s<=n;s++) {\n\t\tdfs(s);memset(id,0,sizeof(id));\n\t\tvector<int> son;\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tson.push_back(v),dfs2(t=v);\n\t\treverse(son.begin(),son.end());\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tif(id[v]!=v) can[i]=1;\n\t\tmemset(id,0,sizeof(id));\n\t\tfor(auto v:son) dfs2(t=v);\n\t\tfor(int i=h[s],v;v=to[i],i;i=nxt[i])\n\t\t\tif(id[v]!=v) can[i]=1;\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tint u=fr[i],v=to[i];\n\t\tif((can[i])==(vis[v][u])) cout<<\"same\\n\";\n\t\telse cout<<\"diff\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<1)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],vis[N],ans[M];\nvector<int> e[N];\nvector<int> id[N];\n/*\nvoid dfs(int st,int u,int now){\n\tif (st==u) return;\n\tif (a[st][u]>=2) return;\n\tif (a[st][u]==1 && vis[u]==now) return;\n\tif (a[st][u]==0) vis[u]=now;\n\ta[st][u]++;\n\trep (i,0,(int)e[u].size()-1) dfs(st,e[u][i],now);\n}\n*/\nvoid dfs(int p, int node, int dir)\n{\n\tif (node == p)return;\n\tif (a[p][node] >= 2)return;\n\tif (a[p][node] == 1 && vis[node] == dir)return;\n\tif (a[p][node] == 0)vis[node] = dir;\n\ta[p][node]++;\n\tfor (int i = 0; i < e[node].size(); i++)dfs(p, e[node][i], dir);\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read();\n\t\te[x[i]].push_back(y[i]);\n\t\tid[x[i]].push_back(i);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,-1,sizeof(vis));\n\t\trep (j,0,(int)e[i].size()-1) dfs(i,e[i][j],e[i][j]);\n\t}\n\t/*rep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]]>=1;\n\t\tbool f2=a[x[i]][y[i]]>=2;\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}*/\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 0; j < e[i].size(); j++)\n\t\t{\n\t\t\tbool f = a[i][e[i][j]] >= 2;\n\t\t\tbool g = a[e[i][j]][i] >= 1;\n\t\t\tans[id[i][j]] = f != g;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<ctime>\nusing namespace std;\n#define N 1050\n#define M 200500\nint head[N],cnt,scc[N],dfn[N],low[N],f[N][13],s[M][2],as[M],vl[N],ct,ct2,vis[N][N],id[N],ct1,dep[N],is[N],n,m,ct3;\nstruct edge{int t,next,id;}ed[M];\nvoid adde(int f,int t,int id){ed[++cnt]=(edge){t,head[f],id};head[f]=cnt;}\nstack<int> tp,tp2,v[N],tp3;\nvoid dfs1(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\ttp.push(u);\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs1(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])\n\t{\n\t\tint s=tp.top(),id=++ct2;tp.pop();\n\t\tscc[s]=id;\n\t\twhile(s!=u)\n\t\ts=tp.top(),tp.pop(),scc[s]=id;\n\t}\n}\nvoid dfs2(int u,int s){for(int i=head[u];i;i=ed[i].next)if(!vis[s][ed[i].t])vis[s][ed[i].t]=1,dfs2(ed[i].t,s);else vis[s][ed[i].t]++;}\nint LCA(int x,int y){if(dep[x]<dep[y])x^=y^=x^=y;for(int i=10;i>=0;i--)if(dep[x]-dep[y]>=(1<<i))x=f[x][i];if(x==y)return x;for(int i=10;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];return f[x][0];}\nvoid dfs3(int u,int fa)\n{\n\tdfn[u]=1;dep[u]=dep[fa]+1;f[u][0]=fa;vl[u]=0;for(int i=1;i<=10;i++)f[u][i]=f[f[u][i-1]][i-1];\n\tfor(int i=head[u];i;i=ed[i].next)\n\tif(!dfn[ed[i].t])tp.push(ed[i].id),dfs3(ed[i].t,u),vl[u]+=vl[ed[i].t];\n\telse{int s=LCA(u,ed[i].t);vl[u]++;vl[s]--;tp2.push(ed[i].id);}\n}\nvoid dfs4(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs1(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])ct2++;\n}\nbool check(int x)\n{\n\tfor(int i=1;i<=n;i++)dfn[i]=scc[i]=head[i]=0;\n\tcnt=0;ct2=0;\n\tfor(int i=1;i<=m;i++)if(i!=x)adde(s[i][0],s[i][1],-1);else adde(s[i][1],s[i][0],-2);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);\n\treturn ct2!=ct3;\n}\nint main()\n{\n//\tfreopen(\"12.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&s[i][0],&s[i][1]),adde(s[i][0],s[i][1],1);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);ct3=ct2;\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])adde(scc[s[i][0]],scc[s[i][1]],-3);\n\tfor(int i=1;i<=ct2;i++)dfs2(i,i);\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])as[i]=vis[scc[s[i][0]]][scc[s[i][1]]]>1;else v[scc[s[i][0]]].push(i);\n\tfor(int i=1;i<=ct2;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)dfn[j]=0,head[j]=0;\n\t\tct1=0;cnt=0;\n\t\tfor(int j=1;j<=n;j++)if(scc[j]==i)id[j]=++ct1;\n\t\twhile(!v[i].empty())\n\t\t{\n\t\t\tint q=v[i].top();v[i].pop();\n\t\t\tadde(id[s[q][0]],id[s[q][1]],q);\n\t\t}\n\t\tdfs3(1,0);\n\t\twhile(!tp2.empty())\n\t\t{\n\t\t\tint st=tp2.top();tp2.pop();\n\t\t\tint l=id[s[st][0]],r=id[s[st][1]];\n\t\t\tr=LCA(l,r);\n\t\t\tint fg=0;\n\t\t\twhile(l!=r)fg|=(vl[l]==1),l=f[l][0];\n\t\t\tas[st]=fg;\n\t\t}\n\t}\n\twhile(!tp.empty()){int st=tp.top();tp.pop();as[st]=check(st);}\n\tfor(int i=1;i<=m;i++)printf(\"%s\\n\",as[i]?\"diff\":\"same\");\n//\tprintf(\"time : %dms\",clock());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[N][N],ans[2][N],p[2][N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[rt][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n\t\tif(vis[rt][v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++) vis[i][j] = 0;\n\t\tdfs_vis(i,i);\n\t}\n\tfor(LL i = 1;i <= m;i ++){\n\t\tif(vis[ev[i]][eu[i]]) ans[0][i] = 1;\n\t\telse ans[0][i] = 0;\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid){\n\tp[pid][u] = col;\n//\tcout << pid << ' ' << u << '-' << col << endl;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = ev[G[u][i]];\n//\t\tcout << u << ' ' << v << ' ' << col << ' ' << p[pid][v] << endl;\n\t\tif(p[pid][v]) continue;\n\t\tdfs_sol(v,col,pid);\n\t}\n}\n\nvoid solve(LL u){\n\tfor(LL i = 1;i <= n;i ++) p[0][i] = p[1][i] = 0;\n\tp[0][u] = p[1][u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!p[0][ev[G[u][i]]]) dfs_sol(ev[G[u][i]],G[u][i],0);\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!p[1][ev[G[u][i]]]) dfs_sol(ev[G[u][i]],G[u][i],1);\n\tfor(LL i = 1;i <= n;i ++){\n\t\tif(p[0][i] != p[1][i]) vis[u][i] = 1;\n\t\telse vis[u][i] = 0;\n\t}\n\tfor(LL i = 1;i <= m;i ++){\n\t\tif(vis[eu[i]][ev[i]]) ans[1][i] = 1;\n\t\telse ans[1][i] = 0;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(i);\n\t}\n\tget_vis(); memset(vis,0,sizeof(vis)); \n\tfor(LL i = 1;i <= n;i ++) solve(i);\n//\tfor(LL i = 1;i <= m;i ++) cout << ans[0][i] << ' ' << ans[1][i] << endl;\n\tfor(LL i = 1;i <= m;i ++) cout << ((ans[0][i] ^ ans[1][i]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ARC092D.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1010, MAX_E = 2e5 + 200;\n\nint n, m, mp[MAX_N][MAX_N], etot, ui[MAX_E], vi[MAX_E], p[MAX_N], q[MAX_N];\nbool accessible[MAX_N][MAX_N], vis[MAX_N], enabled[MAX_N][MAX_N];\nvector<int> G[MAX_N];\n\nvoid mark(int u, int root)\n{\n    vis[u] = true, accessible[root][u] = true;\n    for (int v : G[u])\n        if (!vis[v])\n            mark(v, root);\n}\n\nvoid markPos(int u)\n{\n    vis[u] = true;\n    for (int v : G[u])\n        if (!vis[v])\n            p[v] = mp[u][v], markPos(v);\n}\n\nvoid markNeg(int u)\n{\n    vis[u] = true;\n    int siz = G[u].size() - 1;\n    for (int i = siz; i >= 0; i--)\n    {\n        int v = G[u][i];\n        if (!vis[v])\n            q[v] = mp[u][v], markNeg(v);\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1, u, v; i <= m; i++)\n    {\n        scanf(\"%d%d\", &u, &v);\n        ui[++etot] = u, vi[etot] = v;\n        mp[u][v] = etot, G[u].push_back(v);\n    }\n    for (int i = 1; i <= n; i++)\n        mark(i, i), memset(vis, false, sizeof(vis));\n    for (int i = 1; i <= n; i++)\n    {\n        markPos(i), memset(vis, false, sizeof(vis));\n        markNeg(i), memset(vis, false, sizeof(vis));\n        for (int v : G[i])\n            if (p[v] != mp[i][v] || q[v] != mp[i][v])\n                enabled[i][v] = true;\n        memset(p, 0, sizeof(p)), memset(q, 0, sizeof(q));\n    }\n    for (int i = 1; i <= m; i++)\n        puts((accessible[vi[i]][ui[i]] ^ enabled[ui[i]][vi[i]]) ? \"diff\" : \"same\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define all(x) x.begin(),x.end()\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\ntypedef long long ll;\nconst int N=1005,M=N*N;\nvector<int> g[N];\nint n,m,ans[M],vis[N],clk;\nint a[M],b[M],tim[N],del;\nvoid dfs(int v){\n\tvis[v]=clk;\n\tfor (int d:g[v]){\n\t\tif((!vis[d])&&d!=del)dfs(d);\n\t}\n}\nvoid gao(int x){\n\tdel=x;\n\tmem(vis,0);\n\tclk=0;\n\tfor(int d:g[x]){\n\t\t++clk;\n\t\ttim[d]=clk;\n\t\tif(!vis[d])dfs(d);\n\t}\n\trep(i,1,m)if(a[i]==x&&vis[b[i]]!=tim[b[i]])ans[i]=1;\n\n}\nint main(int argc,char*argv[]){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,m){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tg[a[i]].pb(b[i]);\n\t}\n\trep(x,1,n){\n\t\tgao(x);\n\t\treverse(all(g[x]));\n\t\tgao(x);\n\t}\n\trep(x,1,n){\n\t\tdel=0,clk=1;\n\t\tmem(vis,0);\n\t\tdfs(x);\n\t\trep(i,1,m)if(b[i]==x)ans[i]^=vis[a[i]];\n\t}\n\trep(i,1,m)printf(\"%s\\n\",ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1010;\nconst int maxm = 200010;\nconst int inf = 0x3f3f3f3f;\n\nint l[maxn], e, ban_id;\n\nstruct Edge {\n\tint v, id, x;\n} E[maxm];\n\nqueue<int> q[maxn];\nint e_u[maxm], e_v[maxm], Q[maxn], vis[maxn], Ed[maxn][maxn], n, m;\nint col[maxn], rt[maxn], dfn[maxn], low[maxn], sta[maxn], cnt, top, tim;\nint fa[maxn][20], dep[maxn], mx[maxn][maxn], imp[maxm], f[maxn];\n\nvector<int> vec[maxn][maxn];\nvector<int> st[maxn];\nvector<int> G[maxn];\n\ninline void addEdge(int u, int v, int id) {\n\tE[e].v = v, E[e].x = l[u], E[e].id = id, l[u] = e++;\n}\n\nvoid init_vis() {\n\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\nvoid dfs_calmx(int u) {\n\tvis[u] = 1;\n\tfor (int i = 1; i <= cnt; i++) mx[u][i] = -inf;\n\tmx[u][u] = 0;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (!vis[v]) dfs_calmx(v);\n\t\tfor (int j = 1; j <= cnt; j++) mx[u][j] = max(mx[u][j], mx[v][j] + 1);\n\t}\n}\n\nint check(int a, int b) {\n\tinit_vis();\n\tvis[a] = 1;\n\tint s = 0, t = 0; Q[t++] = a;\n\twhile (s < t) {\n\t\tint u = Q[s++];\n\t\tif (u == b) return 1;\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\tif (E[p].id != ban_id && !vis[v]) {\n\t\t\t\tvis[v] = 1;\n\t\t\t\tQ[t++] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid tarjan(int u) {\n\tdfn[u] = low[u] = ++ tim; sta[++ top] = u; vis[u] = 1;\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (!dfn[v]) {\n\t\t\ttarjan(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else if (vis[v]) {\n\t\t\tlow[u] = min(low[u], dfn[v]);\n\t\t}\n\t}\n\tif (low[u] == dfn[u]) {\n\t\tint t = 0; rt[++ cnt] = u;\n\t\tdo {\n\t\t\tt = sta[top --];\n\t\t\tcol[t] = cnt;\n\t\t\tvis[t] = 0;\n\t\t} while (t != u);\n\t}\n}\n\nvoid dfs_buildtree(int u, int f) {\n\tvis[u] = 1;\n\tfa[u][0] = f;\n\tfor (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (col[v] == col[u] && !vis[v]) {\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\timp[E[p].id] = 1;\n\t\t\tdfs_buildtree(v, u);\n\t\t}\n\t}\n}\n\nvoid solve(int c) {\n\twhile (!q[c].empty()) {\n\t\tint ind = q[c].front(); q[c].pop();\n\t\tint u = e_u[ind], v = e_v[ind];\n\t\tif (f[u] != f[v]) {\n\t\t\timp[ind] = 1;\n\t\t\twhile (f[u] != f[v]) {\n\t\t\t\tint x = f[fa[f[u]][0]];\n\t\t\t\tint y = f[u];\n\t\t\t\tfor (int i = 0; i < st[x].size(); i++) {\n\t\t\t\t\tfor (int j = 0; j < st[y].size(); j++) {\n\t\t\t\t\t\tfor (int k = 0; k < vec[st[x][i]][st[y][j]].size(); k++) {\n\t\t\t\t\t\t\tq[c].push(vec[st[x][i]][st[y][j]][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < st[y].size(); i++) f[st[y][i]] = x, st[x].push_back(st[y][i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint lca(int u, int v) {\n\tif (dep[u] < dep[v]) swap(u, v);\n\tif (dep[u] > dep[v]) {\n\t\tint c = dep[u] - dep[v];\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tif (c & (1<<i)) {\n\t\t\t\tu = fa[u][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (u == v) return u;\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (fa[u][i] != fa[v][i]) {\n\t\t\tu = fa[u][i];\n\t\t\tv = fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\n\nint main() {\n\t//freopen(\"sep2_1.in\", \"r\", stdin);\n\t//freopen(\"sep2_1.ans\", \"w\", stdout);\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\taddEdge(u, v, i);\n\t\te_u[i] = u, e_v[i] = v;\n\t}\n\tfor (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] != col[v]) {\n\t\t\tG[col[u]].push_back(col[v]);\n\t\t\tEd[col[u]][col[v]] ++;\n\t\t}\n\t}\n\tinit_vis();\n\tfor (int i = 1; i <= cnt; i++) dfs_buildtree(rt[i], 0);\n\tfor (int i = 1; i <= n; i++) f[i] = i, st[i].push_back(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] == col[v]) {\n\t\t\tint x = lca(u, v);\n\t\t\tvec[x][v].push_back(i);\n\t\t\tif (x == v) q[col[u]].push(i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= cnt; i++) solve(i);\n\tinit_vis();\n\tfor (int i = 1; i <= cnt; i++) if (!vis[i]) dfs_calmx(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] != col[v]) {\n\t\t\tif (mx[col[u]][col[v]] > 1 || Ed[col[u]][col[v]] > 1) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t} else {\n\t\t\tif (!imp[i]) {\n\t\t\t\tputs(\"same\");\n\t\t\t} else {\n\t\t\t\tban_id = i;\n\t\t\t\tint t = check(u, v);\n\t\t\t\tif (t) puts(\"same\");\n\t\t\t\telse puts(\"diff\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename G >\nstruct StronglyConnectedComponents {\n  const G &g;\n  UnWeightedGraph gg, rg;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(G &g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {\n    for(int i = 0; i < g.size(); i++) {\n      for(auto e : g[i]) {\n        gg[i].emplace_back((int) e);\n        rg[(int) e].emplace_back(i);\n      }\n    }\n    for (int i = 0; i < g.size(); i++)\n    {\n        sort(gg[i].begin(),gg[i].end());\n        sort(rg[i].begin(),rg[i].end());\n    }\n  }\n\n  void revEdge(int a, int b){\n      auto itrgg_erase = lower_bound(gg[a].begin(),gg[a].end(),b);\n      gg[a].erase(itrgg_erase);\n      auto itrrg_erase = lower_bound(rg[b].begin(),rg[b].end(),a);\n      rg[b].erase(itrrg_erase);\n      auto itrgg_insert = lower_bound(gg[b].begin(),gg[b].end(),a);\n      gg[b].insert(itrgg_insert,a);\n      auto itrrg_insert = lower_bound(rg[a].begin(),rg[a].end(),b);\n      rg[a].insert(itrrg_insert,b);\n  }\n\n  int operator[](int k) {\n    return comp[k];\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(UnWeightedGraph &t) {\n    order.clear();\n    fill(comp.begin(),comp.end(),-1);\n    fill(used.begin(),used.end(), 0);\n    \n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    // 強連結したグラフの構成\n    // for(int i = 0; i < g.size(); i++) {\n    //   for(auto &to : g[i]) {\n    //     int x = comp[i], y = comp[to];\n    //     if(x == y) continue;\n    //     t[x].push_back(y);\n    //   }\n    // }\n  }\n};\n\n\nint N;\nll M;\nvector<ll> A,B;\nUnWeightedGraph g, revG;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N >> M;\n    g.resize(N);\n    revG.resize(N);\n    for (int i = 0; i < M; i++)\n    {\n        int a,b;\n        cin >> a >> b;\n        a--;\n        b--;\n        A.push_back(a);\n        B.push_back(b);\n        g[a].emplace_back(b);\n    }\n    \n}\n\n// O(NM)かかる\n// O(M)でないとTLEしちゃう\nint TLEsolve(){\n    StronglyConnectedComponents< UnWeightedGraph > scc(g);\n    UnWeightedGraph buff;\n    scc.build(buff);\n    int cntG=buff.size();\n    // vector<bool> seen(N);\n    // for (int i = 0; i < N; i++)\n    // {\n    //     if(!seen[scc[i]]) cntG++;\n    //     seen[scc[i]] = true;\n    // }\n    // DBG(cntG)\n    for (int i = 0; i < M; i++)\n    {\n        // StronglyConnectedComponents< UnWeightedGraph > sccrev(g);\n        // strcpy(sccrev,scc);\n        scc.revEdge(A[i],B[i]);\n        scc.build(buff);\n        int cntrevG=buff.size();\n        // vector<bool> seen_revG(N);\n        // for (int i = 0; i < N; i++)\n        // {\n        //     if(!seen_revG[scc[i]]) cntrevG++;\n        //     seen_revG[scc[i]] = true;\n        // }\n        if(cntG==cntrevG) cout << \"same\" << \"\\n\";\n        else cout << \"diff\" << \"\\n\";\n        scc.revEdge(B[i],A[i]);\n    }\n    \n    return 0;\n}   \n\nint main()\n{\n    input();\n    TLEsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e3+5,M=2e5+5;\nusing namespace std;\nstruct Edge{\n\tint u,v;\n}e[M];\nbool g1[N][N],g2[N][N],used[N];\nint n,m,Mark[N];\nbool flag;\nvector<int>to[N];\nvoid DFS(int p,int s){\n\tg1[s][p]=used[p]=1;\n\tregister int i;\n\tfor(i=0;i!=to[p].size();++i)\n\t\tif(!used[to[p][i]]) DFS(to[p][i],s);\n}\nvoid _DFS(int p,int col,int s){\n\t//cout<<p<<\n\tif(flag) g2[s][p]=Mark[p]!=col;\n\telse Mark[p]=col;\n\tregister int i;used[p]=1;\n\tfor(i=0;i!=to[p].size();++i)\n\t\tif(!used[to[p][i]]) _DFS(to[p][i],col,s);\n}\nint main(){\n\t\n\tregister int i,j,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tto[x].push_back(y);\n\t\te[i]=(Edge){x,y};\n\t}\n\tfor(i=1;i<=n;++i) DFS(i,i),memset(used,0,sizeof used);\n\tfor(i=1;i<=n;++i){\n\t\tfor(j=0;j<=n;++j) Mark[j]=0;\n\t\tfor(j=1;j<=n;++j) used[j]=0;used[i]=1;flag=0; \n\t\tfor(j=0;j!=to[i].size()  ;++j) if(!used[to[i][j]]) _DFS(to[i][j],j,i);\n\t\tfor(j=1;j<=n;++j) used[j]=0;used[i]=1;flag=1;\n\t\tfor(j=to[i].size()-1;j>=0;--j) if(!used[to[i][j]]) _DFS(to[i][j],j,i);\n\t}\n\tfor(i=1;i<=m;++i)\n\t\tputs((g1[e[i].v][e[i].u]^g2[e[i].u][e[i].v])?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// u -> v same: ban u -> v, u is reachable from v ^ vice versa = 0\n// Problem : F - Two Faced Edges\n// Contest : AtCoder Regular Contest 092\n// URL : https://atcoder.jp/contests/arc092/tasks/arc092_d\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define sort(a, n) sort(a + 1, a + n + 1)\n#define temptts template <class T, class... Ts>\n\nconst int N = 1001, M = 2e5 + 2, mod = 1e9 + 7, inf = 2e9;\n\nstruct edge_list {\n\tint u, v, pre, nex;\n} edge[M];\n\nbool vis[N];\nint n, m, ban, ans[M], cur[M], head[N], tail[N];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tfor (int i = head[v]; i; i = edge[i].pre) {\n\t\tint u = edge[i].v;\n\t\tif (u == ban || vis[u]) continue;\n\t\tdfs(u);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tedge[i] = {u, v, head[u], 0};\n\t\thead[u] = i;\n\t}\n\tfor (int i = m; i >= 1; i--) {\n\t\tint u = edge[i].u;\n\t\tedge[i].nex = tail[u];\n\t\ttail[u] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmemset(vis, 0, sizeof vis);\n\t\tban = 0;\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint u = edge[j].u, v = edge[j].v;\n\t\t\tif (v == i) ans[j] ^= vis[u];\n\t\t}\n\t\tban = i;\n\t\t// memset(vis, 0, sizeof vis);\n\t\t// for (int j = head[i]; j; j = edge[j].pre) {\n\t\t\t// int u = edge[j].v;\n\t\t\t// cur[j] |= vis[u];\n\t\t\t// dfs(u);\n\t\t// }\n\t\t// memset(vis, 0, sizeof vis);\n\t\t// for (int j = tail[i]; j; j = edge[j].nex) {\n\t\t\t// int u = edge[j].v;\n\t\t\t// ans[j] ^= cur[j] | vis[u];\n\t\t\t// dfs(u);\n\t\t// }\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tputs(ans[i] ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ninline void read(int &x)\n{\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\nstruct node{\n\tint nex,to,from;\n}edge[200005];\nint N,M;\nint head[1005],tot;\ninline void insert(int from,int to)\n{\n\tedge[++tot].nex=head[from];\n\thead[from]=tot;\n\tedge[tot].to=to;\n\tedge[tot].from=from;\n}\nint mex[1005][1005];\nbool vis[1005];\nvoid dfs(int v,int x)\n{\n\tvis[x]=1;\n\tfor(int i=head[x];i;i=edge[i].nex)\n\t\tif(!vis[edge[i].to])\n\t\t{\n\t\t\tmex[v][edge[i].to]++;\n\t\t\tdfs(v,edge[i].to);\n\t\t}\n\tvis[x]=0;\n\t \n}\nint main()\n{\n\tread(N);read(M);\n\tint u,v;\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tread(u);read(v);\n\t\tinsert(u,v);\n\t} \n\tfor(int i=1;i<=N;i++)\n\t\tdfs(i,i);\n\t/*for(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=1;j<=N;j++)\n\t\t\tcout<<mex[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tbool flag=0;\n\t\tif(mex[edge[i].from][edge[i].to]&&mex[edge[i].to][edge[i].from])\n\t\t\tif(mex[edge[i].from][edge[i].to]<2)\n\t\t\t\tflag=1;\n\t\tif(!mex[edge[i].to][edge[i].from]&&mex[edge[i].from][edge[i].to]>=2)\n\t\t\tflag=1;\n\t\tif(flag)\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\ntypedef unsigned long long ull;\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nvoid dfs(int k){\n\tif(k==D) return;\n\tvis[D][k]=1;\n\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k]){\n\t\tdfs(e[i].k);\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint o=vis[i][e[p].k];\n\t\t\ts[++top]=e[p].k;\n\t\t\tdfs(e[p].k);\n\t\t\tvis[i][e[p].k]=o;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>1;p--){\n\t\t\tint o=vis[i][s[p]];\n\t\t\tdfs(s[p]);\n\t\t\tvis[i][s[p]]=o;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, m;\nbool can[1000][1000], can2[1000][1000];\nvector<vi> e;\n\nvoid rec(bool *v, int c){\n\tv[c] = 1;\n\tfor(int i : e[c]) if(!v[i]) rec(v, i);\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m;\n\te.resize(n);\n\tmap<pi, int> id;\n\trep(i, m){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\tid[pi(a, b)] = i;\n\t}\n\trep(i, n) rec(can[i], i);\n\trep(i, n) rep(it, 2){\n\t\tbool v[1000] = {};\n\t\tv[i] = 1;\n\t\tfor(int j : e[i]){\n\t\t\tif(v[j]) can2[i][j] = 1;\n\t\t\trec(v, j);\n\t\t}\n\t\treverse(all(e[i]));\n\t}\n\tconst char *res[] = {\"same\", \"diff\"};\n\tvi ans(m);\n\tfor(auto i : id){\n\t\tint a = i.first.first, b = i.first.second;\n\t\tans[i.second] = can2[a][b] ^ can[b][a];\n\t\t\n\t}\n\trep(i, m) cout << res[ans[i]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,x[200005],y[200005],book[1005];\nint top,nex[200005],to[200005],fir[1005];\nmap<int,int> mp[1005],mp2[1005];\nvoid lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\nvoid ss(int v,int w){\n\tbook[v]=i;\n\tmp[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss(to[top1],w==0?top1:w);\n}\nvoid ss2(int v,int w){\n\tbook[v]=i;\n\tmp2[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss2(to[top1],w==0?top1:w);\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=m;i++){\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t\tlj(x[i],y[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tss(i,0);\n\tfor(i=1;i<=top;i++){\n\t\tnex[i]=0;\n\t\tto[i]=0;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tbook[i]=0;\n\t\tfir[i]=0;\n\t}\n\ttop=0;\n\tfor(i=m;i>=1;i--)\n\t\tlj(x[i],y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tss2(i,0);\n\tfor(i=1;i<=m;i++){\n\t\tif((mp[y[i]][x[i]]!=0)+(mp[x[i]][y[i]]+mp2[x[i]][y[i]]==m+1)==1)\n\t\t\tprintf(\"same\\n\");\n\t\telse\n\t\t\tprintf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n \nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[M] , B[M];\nint stk[N] , top;\nint ans[M];\nint L[N][N], R[N][N];\n\nvoid add(int x, int y) {\n\tne[++ cnt] = fir[x];\n\tfir[x] = cnt;\n\tto[cnt] = y;\n}\n\nbool can[N][N];\n\nqueue <int> q;\n\nvector <int> son[N];\n\n#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\nvoid solve(int x) {\n\twhile(!q.empty()) q.pop();\n\tq.push(x);\n\twhile(!q.empty()) {\n\t\tint ind = q.front();\n\t\tcan[x][ind] = 1;\n\t\tq.pop();\n\t\tForeachson(i, ind) {\n\t\t\tint V = to[i];\n\t\t\tif(can[x][V]) continue;\n\t\t\tq.push(V);\n\t\t}\n\t}\n\t\n\tForeachson(i, x) {\n\t\tint V = to[i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!L[x][V]) {\n\t\t\tq.push(V);\n\t\t\tL[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tForeachson(i, ind) {\n\t\t\t\tint v = to[i];\n\t\t\t\tif(!L[x][v] && v != x) {\n\t\t\t\t\tL[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < (int) son[x].size(); ++ i) {\n\t\tint V = son[x][i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!R[x][V]) {\n\t\t\tq.push(V);\n\t\t\tR[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < (int) son[ind].size(); ++ i) {\n\t\t\t\tint v = son[ind][i];\n\t\t\t\tif(!R[x][v] && v != x) {\n\t\t\t\t\tR[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x, y);\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tForeachson(j, i) {\n\t\t\tint V = to[j];\n\t\t\tson[i].push_back(V);\n\t\t}\n\t\treverse(son[i].begin(), son[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tsolve(i);\n\t}\n\t\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(L[A[i]][B[i]] != B[i] || R[A[i]][B[i]] != B[i]) {\n\t\t\tif(!can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\telse {\n\t\t\tif(can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 63) {\n\n\n    int l = _, r = min< int >(g[idx].size(), _ + 63);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else {\n          dp[e.first] |= dp[p];\n        }\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct StronglyConnectedComponent {\n        int n;\n        vector<bool> used;\n        vector<int> order, cmp;\n        vector<vector<int>> g, rg;\n        StronglyConnectedComponent(int x) {\n                n = x;\n                g.resize(x);\n                rg.resize(x);\n                used.resize(x);\n                cmp.resize(x);\n        }\n        void add_edge(int from, int to) {\n                g[from].push_back(to);\n                rg[to].push_back(from);\n        }\n        void dfs(int u) {\n                used[u] = true;\n                for (auto v : g[u]) if (!used[v]) {\n                        dfs(v);\n                }\n                order.push_back(u);\n        }\n        void rdfs(int u, int k) {\n                used[u] = true;\n                cmp[u] = k;\n                for (auto v : rg[u]) if (!used[v]) {\n                        rdfs(v, k);\n                }\n        }\n        int init() {\n                used.assign(n, false);\n                for (int u = 0; u < n; u ++) {\n                        if (!used[u]) {\n                                dfs(u);\n                        }\n                }\n                used.assign(n, false);\n                int k = 0;\n                for (int i = order.size() - 1; i >= 0; i --) {\n                        if (!used[order[i]]) {\n                                rdfs(order[i], k ++);\n                        }\n                }\n                return k;\n        }\n};\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    if (m > 2000) {\n        assert(false);\n    }\n    StronglyConnectedComponent scc(n);\n    vector<vector<int>> g(n);\n    vector<pair<int, int>> es;\n    for (int i = 0; i < m; i ++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a --, b --;\n        scc.add_edge(a, b);\n        es.emplace_back(a, b);\n    }\n    scc.init();\n    for (int no = 0; no < m; no ++) {\n        vector<vector<int>> g(n);\n        for (int i = 0; i < m; i ++) {\n            if (i == no) continue;\n            int a, b;\n            tie(a, b) = es[i];\n            g[a].push_back(b);\n        }\n        int s = es[no].first;\n        int t = es[no].second;\n        vector<bool> used(n, false);\n        function<void (int)> dfs = [&](int u) {\n            used[u] = true;\n            for (auto v : g[u]) if (!used[v]) {\n                dfs(v);\n            }\n        };\n        dfs(s);\n        if ((scc.cmp[s] == scc.cmp[t] && !used[t]) || (scc.cmp[s] != scc.cmp[t] && used[t])) {\n            printf(\"diff\\n\");\n        } else {\n            printf(\"same\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    bool first = true;\n    os << \"{\";\n    for (auto v : a) {\n        if (!first) os << \", \";\n        else first = 0;\n        os << v;\n    }\n    os << \"}\";\n    return os;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        edges[i] = make_pair(u, v);\n        g[u].push_back(i);\n    }\n    vector<vector<bool>> res1(n, vector<bool>(n));\n    {\n        function<void(int, int)> dfs = [&](int u, int s) {\n            res1[s][u] = 1;\n            for (auto e : g[u]) {\n                int v = edges[e].second;\n                if (!res1[s][v]) dfs(v, s);\n            }\n        };\n        for (int i = 0; i < n; ++i)\n            dfs(i, i);\n    }\n    vector<bool> res2(m);\n    {\n        function<void(int, int, vector<int>&)> dfs = [&](int u, int id, vector<int> &mark) {\n            mark[u] = id;\n            for (auto e : g[u]) {\n                int v = edges[e].second;\n                if (mark[v] == -1) dfs(v, id, mark);\n            }\n        };\n        for (int u = 0; u < n; ++u) {\n            // cerr << \"At: \" << u << '\\n';\n            vector<int> mark1 = vector<int>(n, -1);\n            mark1[u] = 0;\n            for (int i = 0; i < (int) g[u].size(); ++i) {\n                int v = edges[g[u][i]].second;\n                if (mark1[v] == -1) dfs(v, i, mark1);\n            }\n            vector<int> mark2 = vector<int>(n, -1);\n            mark2[u] = 0;\n            for (int i = (int) g[u].size() - 1; i >= 0; --i) {\n                int v = edges[g[u][i]].second;\n                if (mark2[v] == -1) dfs(v, i, mark2);\n            }\n            // cerr << \"mark1: \" << mark1 << \"\\nmark2: \" << mark2 << '\\n';\n            for (auto e : g[u]) {\n                // cerr << e << \": \" << edges[e].first << \" \" << edges[e].second << '\\n';\n                int v = edges[e].second;\n                if (mark1[v] == mark2[v]) {\n                    res2[e] = 0;\n                } else {\n                    res2[e] = 1;\n                }\n                // cerr << \"res2[\" << e << \"] = \" << res2[e] << '\\n';\n            }\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        int u = edges[i].first, v = edges[i].second;\n        // cerr << res1[v][u] << \" \" << res2[i] << '\\n';\n        bool wit1 = res1[v][u] && !res2[i];\n        bool wit2 = !res1[v][u] && res2[i];\n        // cerr << wit1 << \" \" << wit2 << '\\n';\n        if (wit1 != wit2) cout << \"diff\\n\";\n        else cout << \"same\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M;\nint A[1 << 18], B[1 << 18];\nint Answer[1 << 18];\n\n// 強連結成分分解\nvector<int> X[1009], Y[1009], I;\nbool used[1009];\nint col[1009], group[1009], cnts;\n\nvoid dfs1(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs1(X[pos][i]);\n\t}\n\tI.push_back(pos);\n}\n\nvoid dfs2(int pos) {\n\tcol[pos] = cnts; group[cnts]++;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (col[Y[pos][i]] >= 1) continue;\n\t\tdfs2(Y[pos][i]);\n\t}\n}\n\n// DAG における計算\nvector<pair<int, int>> Z[1009];\nint dp[1009][1009];\n\n// サイクルの列挙\nvector<pair<int, int>> P[1009], Q[1009];\nint Score1[1 << 18], Score2[1 << 18];\n\nint dfs5(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < P[pos].size(); i++) {\n\t\tif (used[P[pos][i].first] == true) continue;\n\t\tr += dfs5(P[pos][i].first);\n\t}\n\treturn r;\n}\n\nint dfs6(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < Q[pos].size(); i++) {\n\t\tif (used[Q[pos][i].first] == true) continue;\n\t\tr += dfs6(Q[pos][i].first);\n\t}\n\treturn r;\n}\n\n// 最後の計算\nvector<int> J[1009], J2[1009], K;\nint colo[1009], cntv;\n\nvoid dfs3(int pos) {\n\tused[pos] = true;\n\tfor (int i : J[pos]) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\tK.push_back(pos);\n}\n\nvoid dfs4(int pos) {\n\tcolo[pos] = cntv;\n\tfor (int i : J2[pos]) {\n\t\tif (colo[i] >= 1) continue;\n\t\tdfs4(i);\n\t}\n}\n\nbool calc(int pos) {\n\tfor (int i = 1; i <= N; i++) J[i].clear();\n\tfor (int i = 1; i <= N; i++) J2[i].clear();\n\tfor (int i = 1; i <= N; i++) used[i] = false;\n\tfor (int i = 1; i <= N; i++) colo[i] = 0;\n\tcntv = 0;\n\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (i == pos) continue;\n\t\tJ[A[i]].push_back(B[i]);\n\t\tJ2[B[i]].push_back(A[i]);\n\t}\n\tK.clear();\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\t\n\tfor (int i = K.size() - 1; i >= 0; i--) {\n\t\tif (colo[K[i]] >= 1) continue;\n\t\tcntv++; dfs4(K[i]);\n\t}\n\n\tif (cnts == cntv) return false;\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= M; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tX[A[i]].push_back(B[i]);\n\t\tY[B[i]].push_back(A[i]);\n\t}\n\n\t// ステップ 1: 強連結成分ごとに分ける\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs1(i);\n\t}\n\tfor (int i = I.size() - 1; i >= 0; i--) {\n\t\tif (col[I[i]] >= 1) continue;\n\t\tcnts++; dfs2(I[i]);\n\t}\n\n\t// ステップ 2: DAG のグラフを処理する\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tZ[col[A[i]]].push_back(make_pair(col[B[i]], i));\n\t}\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tdp[i][i] = 1;\n\t\tfor (int j = 1; j <= cnts; j++) {\n\t\t\tfor (int k = 0; k < Z[j].size(); k++) {\n\t\t\t\tdp[i][Z[j][k].first] += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tif (dp[col[A[i]]][col[B[i]]] != 1) Answer[i] = 2;\n\t\telse Answer[i] = 1;\n\t}\n\n\t// ステップ 3: 候補辺の列挙\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tP[A[i]].push_back(make_pair(B[i], i));\n\t\tQ[B[i]].push_back(make_pair(A[i], i));\n\t\tAnswer[i] = 1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < P[i].size(); j++) {\n\t\t\tint V1 = dfs5(P[i][j].first);\n\t\t\tScore1[P[i][j].second] = V1;\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < Q[i].size(); j++) {\n\t\t\tint V2 = dfs6(Q[i][j].first);\n\t\t\tScore2[Q[i][j].second] = V2;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tif (group[col[A[i]]] <= Score1[i] + Score2[i]) Answer[i] = 0;\n\t}\n\n\t// ステップ 4: 最後の計算\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] >= 1) continue;\n\t\tbool flag = calc(i);\n\t\tif (flag == false) Answer[i] = 1;\n\t\telse Answer[i] = 2;\n\t}\n\n\t// 出力\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] == 1) printf(\"same\\n\");\n\t\tif (Answer[i] == 2) printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  int x=0,f=1;char c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return f?x:-x;\n  }\ntemplate <typename mitsuha>\ninline bool read(mitsuha &x){\n  x=0;int f=1;char c=gc();\n  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';\n  if (!~c) return 0;\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return x=f?x:-x,1;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x,int b=10){\n  if (!x) return 0&pc(48);\n  if (x<0) x=-x,pc('-');\n  int bit[99],i,p=0;\n  for (;x;x/=b) bit[++p]=x%b;\n  for (i=p;i;--i) pc(bit[i]+(bit[i]<10?48:55));\n  return 0;\n  }\ntemplate <typename mitsuha>\ninline int rwrite(mitsuha x,int b=10){\n  mitsuha ans=0,d=1;\n  for (;x;x/=10,d*=b) ans=ans+x%10*d;\n  return ans;\n  }\ninline char fuhao(){\n  char c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=2e5;\ntypedef int fuko[yuzu|10];\nvector<int> lj[yuzu|10];\nstruct edge{int u,v;}eg[yuzu|10];\nint cnt[1010][1011],vis[1010],can[1010][1010];\n\nvoid dfs(int p,int u){\nvis[u]=1,cnt[p][u]++;\nfor (int i:lj[u]) if (!vis[i]) dfs(p,i);\n}\n\nvoid dfs2(int p,int u){\nvis[u]=1,can[p][u]=1;\nfor (int v:lj[u]) if (!vis[v]) dfs2(p,v);\n}\n\nint main(){\nint i,n=read(),m=read();\nfor (i=1;i<=m;++i){\n  int u=read(),v=read();\n  lj[u].push_back(v);\n  eg[i]=edge{u,v};\n  }\nfor (i=1;i<=n;++i){\n  for (int j:lj[i]){\n    memset(vis,0,sizeof vis);\n    vis[i]=1,dfs(i,j);\n    } \n  }\nfor (i=1;i<=n;++i){\n  memset(vis,0,sizeof vis);\n  dfs2(i,i);\n  }\nfor (i=1;i<=m;++i){\n  int u=eg[i].u,v=eg[i].v;\n  //cout<<(cnt[u][v])<<\" \"<<can[v][u]<<endl;\n  puts(((cnt[u][v]==1)^(!can[v][u]))?\"diff\":\"same\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{edge*nx;int t;}e[MM*3+5],*h[MN+5],*r[MN+5],*c[MN+5];\nint en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(edge**h,int x,int y){e[++en]=(edge){h[x],y};h[x]=e+en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)\n\t\tif(!d[i->t])dfs(i->t),l[x]=min(l[x],l[i->t]);\n\t\telse if(inz[i->t])l[x]=min(l[x],d[i->t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(edge**h,int x,int z)\n{\n\tu[x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)if(!u[i->t])d1(h,i->t,z),uu[i-e>>1]|=z;\n}\nvoid d2(edge**h,int x,int d,int xs,int ys)\n{\n\tint i;\n\tfor(u[q[i=qn=0]=x]=1;i<=qn;++i)\n\t{\n\t\tfor(edge*j=h[q[i]];j;j=j->nx)if((j-e>>1)!=d&&!u[j->t])u[q[++qn]=j->t]=1;\n\t\tif(q[i]==xs&&!u[ys])u[q[++qn]=ys]=1;\n\t}\n}\nint main()\n{\n\tint n=read(),m=read(),i,j;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tmemset(h,0,sizeof(h));memset(r,0,sizeof(r));en=1;\n\tfor(i=1;i<=m;++i)if(p[x[i]]==p[y[i]])ins(h,x[i],y[i]),ins(r,y[i],x[i]);else en+=2;\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(edge*k=c[q[j]];k;k=k->nx)if(!g[i][k->t]++)q[++qn]=k->t;\n\treturn 0;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i]&1)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,ph[p[x[i]]],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i]&2)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,ph[p[x[i]]],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1005;\nconst int M = 200005;\nbool not_necessary[N][N];\nvector<int> con[N];\nint a[M], b[M];\nint vis[N];\nint fe[N];\n\nstruct graph {\n  int n;\n  vector<vector<int>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst) {\n    adj[src].push_back(dst);\n  }\n\n  vector<vector<int>> strongly_connected_components() {\n    vector<vector<int>> scc;\n    vector<int> S, B, I(n);\n    function<void(int)> dfs = [&](int u) {\n      B.push_back(I[u] = S.size());\n      S.push_back(u);\n      for (int v: adj[u]) {\n        if (!I[v]) dfs(v);\n        else while (I[v] < B.back()) B.pop_back();\n      }\n      if (I[u] == B.back()) {\n        scc.push_back({});\n        B.pop_back();\n        for (; I[u] < S.size(); S.pop_back()) {\n          scc.back().push_back(S.back());\n          I[S.back()] = n + scc.size();\n        }\n      }\n    };\n    for (int u = 0; u < n; ++u)\n      if (!I[u]) dfs(u);\n    return scc; // I[u] - n is the index of u\n  }\n};\n\ntemplate<class T>\nstruct fixedSizeQueue{\n\tint n, L, R;\n\tT * arr;\n\tfixedSizeQueue(int n) : n(n){\n\t\tarr = new T[2 * n + 10];\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tvoid push_back(T x){\n\t\tarr[++R] = x; \n\t}\n\n\tvoid push_front(T x){\n\t\tarr[--L] = x;\n\t}\n\t\n\tT front(){\n\t\treturn arr[L];\n\t}\n\n\tT back(){\n\t\treturn arr[R];\n\t}\n\n\tT pop_front(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[L++];\n\t}\n\n\tT pop_back(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[R--];\n\t}\n\n\tvoid re_init_indices(){\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tbool empty(){\n\t\treturn L > R;\n\t}\n};\nint main(){\n\tint n, m; sd(n); sd(m);\n\tgraph g(n + 1);\n\tfor(int i = 1; i <= m; i++){\n\t\tsd(a[i]);\n\t\tsd(b[i]);\n\t\tcon[a[i]].push_back(b[i]);\n\t\tg.add_edge(a[i], b[i]);\n\t}\n\tvector<vector<int>> comp = g.strongly_connected_components();\n\tvector<int> where(n + 1);\n\tfor(int i = 0; i < comp.size(); i++)\n\t\tfor(auto it : comp[i])\n\t\t\twhere[it] = i;\n\tfixedSizeQueue<pii> q(2 * n);\n\tfor(int i = 1; i <= n; i++){\n\t\tq.re_init_indices();\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int v : con[i]){\n\t\t\tq.push_back({v, v});\n\t\t\tvis[v] = 1;\n\t\t\tfe[v] = v;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tauto it = q.pop_back();\n\t\t\tint u = it.F, firstEdge = it.S;\n\t\t\tfor(int v : con[u]){\n\t\t\t\tif(v == i || vis[v] >= 2) continue;\n\t\t\t\tif(vis[v] == 1 && firstEdge == fe[v]) continue;\n\t\t\t\tq.push_back({v, firstEdge});\n\t\t\t\tif(vis[v] == 0)\n\t\t\t\t\tfe[v] = firstEdge;\n\t\t\t\tvis[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int v : con[i]) if(vis[v] == 2){\n\t\t\tnot_necessary[i][v] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\n\t\tprintf( (not_necessary[a[i]][b[i]] ^ (where[a[i]] != where[b[i]] )) ? \"same\\n\" : \"diff\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#define MAXN (1000 + 5)\n#define MAXM (200000 + 5)\n#define pii pair<int, int>\nusing namespace std;\nstruct edg\n{\n\tint from, to, next;\n}b[MAXM];\nint g[MAXN], cntb, col[MAXN], n, m;\nint g1[MAXN][MAXN], g2[MAXN][MAXN];\nvoid adn(int from, int to)\n{\n\tb[++cntb].next = g[from];\n\tb[cntb].from = from;\n\tb[cntb].to = to;\n\tg[from] = cntb;\n}\nvoid dfs(int s)\n{\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint dq = q.front();\n\t\tq.pop();\n\t\tfor (int i = g[dq]; i; i = b[i].next)\n\t\t\tif (!col[b[i].to])\n\t\t\t\tcol[b[i].to] = col[dq], q.push(b[i].to);\n\t}\n}\nvoid init()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(col, 0, sizeof(col));\n\t\tcol[i] = 1;\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (col[j])\n\t\t\t\tg1[i][j] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(col, 0, sizeof(col));\n\t\tcol[i] = i;\n\t\tint t[MAXM], cc[MAXN];\n\t\tt[0] = 0;\n\t\tfor (int j = g[i]; j; j = b[j].next)\n\t\t\tt[++t[0]] = j;\n\t\tfor (int j = 1; j <= t[0]; j++)\n\t\t\tif (!col[b[t[j]].to])\n\t\t\t\tcol[b[t[j]].to] = j, dfs(b[t[j]].to);\n\t\tmemcpy(cc, col, sizeof(int) * (n + 5));\n\t\tmemset(col, 0, sizeof(col));\n\t\tcol[i] = i;\n\t\tfor (int j = t[0]; j; j--)\n\t\t\tif (!col[b[t[j]].to])\n\t\t\t\tcol[b[t[j]].to] = j, dfs(b[t[j]].to);\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (col[j] != cc[j])\n\t\t\t\tg2[i][j] = 1;\n\t}\n}\npii e[MAXM];\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d\", &e[i].first, &e[i].second);\n\t\tadn(e[i].first, e[i].second);\n\t}\n\tinit();\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif ((g1[e[i].second][e[i].first] && !g2[e[i].first][e[i].second]) xor (!g1[e[i].second][e[i].first] && g2[e[i].first][e[i].second]))\n\t\t\tputs(\"diff\");\n\t\telse\n\t\t\tputs(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nint ans[200010];\nvector<int> adj[1010], radj[1010], sadj[1010], U, V;\nint tin[1010], bck[1010], id[1010], timer, scnt;\nstack<int> stk;\n\nvoid dfs(int u) {\n    tin[u] = timer++;\n    bck[u] = tin[u];\n    stk.push(u);\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int e = adj[u][i];\n        int v = V[e];\n        if(tin[v] == -1) {\n            dfs(v);\n            bck[u] = min(bck[u], bck[v]);\n        }\n        else if(id[v] == -1) {\n            bck[u] = min(bck[u], tin[v]);\n        }\n    }\n    if(bck[u] == tin[u]) {\n        while(1) {\n            int t = stk.top(); stk.pop();\n            id[t] = scnt;\n            if(t == u) break;\n        }\n        scnt++;\n    }\n}\n\nint cc[1010][1010];\nint dp(int u, int d) {\n    int &ret = cc[u][d];\n    if(ret != -1) return ret;\n    if(u == d) return ret = 0;\n\n    ret = -1e9;\n    for(int i = 0; i < sadj[u].size(); i++) {\n        int v = sadj[u][i];\n        ret = max(ret, 1 + dp(v, d));\n    }\n    return ret;\n}\n\nint Cnt[1010][1010];\n\nvoid scc() {\n    memset(tin, -1, sizeof(tin));\n    memset(id, -1, sizeof(id));\n    for(int i = 0; i < N; i++) if(tin[i] == -1) {\n        dfs(i);\n    }\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            sadj[ id[u] ].push_back(id[v]);\n            Cnt[ id[u] ][ id[v] ]++;\n        }\n    }\n\n    memset(cc, -1, sizeof(cc));\n    for(int e = 0; e < M; e++) {\n        int u = U[e];\n        int v = V[e];\n        if(id[u] != id[v]) {\n            if(Cnt[ id[u] ][ id[v] ] > 1 || dp(id[u], id[v]) > 1) ans[e] = 1;\n            else ans[e] = 0;\n        }\n    }\n}\n\nqueue<int> q1, q2;\nint dist1[1010], dist2[1010], par1[1010], par2[1010];\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for(int i = 0; i < M; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(i);\n        radj[v].push_back(i);\n        U.push_back(u);\n        V.push_back(v);\n    }\n\n    scc();\n\n    for(int u = 0; u < N; u++) {\n        memset(dist1, -1, sizeof(dist1));\n        memset(dist2, -1, sizeof(dist2));\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                q1.push(v);\n                dist1[v] = 0;\n                par1[v] = v;\n            }\n        }\n        while(!q1.empty()) {\n            int t = q1.front(); q1.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist1[v] == -1) {\n                        dist1[v] = dist1[t] + 1;\n                        par1[v] = par1[t];\n                        q1.push(v);\n                    }\n                    else if(dist2[v] == -1 && par1[v] != par1[t]) {\n                        dist2[v] = dist1[t] + 1;\n                        par2[v] = par1[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n        while(!q2.empty()) {\n            int t = q2.front(); q2.pop();\n\n            for(int i = 0; i < radj[t].size(); i++) {\n                int e = radj[t][i];\n                int v = U[e];\n                if(u == v) continue;\n                if(id[u] == id[v]) {\n                    if(dist2[v] == -1 && par1[v] != par2[t]) {\n                        dist2[v] = dist2[t] + 1;\n                        par2[v] = par2[t];\n                        q2.push(v);\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < radj[u].size(); i++) {\n            int e = radj[u][i];\n            int v = U[e];\n            if(id[u] == id[v]) {\n                if(dist2[v] != -1) ans[e] = 0;\n                else ans[e] = 1;\n            }\n        }\n    }\n\n    for(int i = 0; i < M; i++) {\n        if(ans[i]) printf(\"diff\\n\");\n        else printf(\"same\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\nconst int N = 1010;\nconst int M = 200010;\n\nstruct edge{int to, next;} e[M];\nint n, m, cnt, x[M], y[M], head[N], a[2][N][N];\nbitset <N> p[N];\n\nvoid ins(int x, int y)\n{\n    e[++cnt].to = y; e[cnt].next = head[x]; head[x] = cnt;\n}\n\nvoid dfs(int fl, int x, int st, int fir)\n{\n    a[fl][st][x] = fir;\n    for(int i = head[x]; i; i = e[i].next)\n        if (e[i].to != st && !a[fl][st][e[i].to]) dfs(fl, e[i].to, st, fir);\n}\n\nchar B[1 << 26], *S = B;\n#define getchar() (*S++)\nint read()\n{\n    int x = 0; char c = getchar();\n    while (c < '0' || c > '9') c = getchar();\n    while (c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = getchar();}\n    return x;\n}\n\nint main()\n{\n    fread(B, 1, 1 << 26, stdin);\n    n = read(); m = read();\n    FOR(i, 1, m)\n    {\n        x[i] = read(); y[i] = read();\n        p[x[i]][y[i]] = 1;\n        ins(x[i], y[i]);\n    }\n    FOR(i, 1, n) FOR(j, 1, n) if (p[i][j] && !a[0][i][j]) dfs(0, j, i, j);\n    FOR(i, 1, n) for(int j = n; j; --j) if (p[i][j] && !a[1][i][j]) dfs(1, j, i, j);\n    FOR(i, 1, m) if (((bool) a[0][y[i]][x[i]]) ^ (a[0][x[i]][y[i]] != y[i] || a[1][x[i]][y[i]] != y[i]))\n        puts(\"diff\"); else puts(\"same\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=1e4+10;\nconst int M=2e5+10;\nvector<pii> e[N];\ninline void add(int u,int v,int id){e[u].push_back(mp(v,id));}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[N];\nint main(){\n    n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n     }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    rep(x,1,n){\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tfor(auto k:e[x]){\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs2(v,x);\n\t}\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tint sz=(int)e[x].size()-1;\n\trpe(j,sz,0){\n\t    pii k=e[x][j];\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1005;\nstruct Edges { int to, next; } e[200005];\nstruct Edge { int x, y; } G[200005];\nint head[MAXN], tot;\nint vis[MAXN], last[MAXN];\nint A[MAXN][MAXN], B[MAXN][MAXN];\nint stk[MAXN];\n\ninline void addedge(int from, int to) {\n  e[++tot] = (Edges){to, head[from]};\n  head[from] = tot;\n}\n\nvoid Dfs(int now, int id) {\n  vis[now] = 1;\n  A[id][now] = 1;\n  for (RI i = head[now]; i; i = e[i].next)\n    if (!vis[e[i].to]) Dfs(e[i].to, id);\n}\nvoid DDfs(int now, int id, int tmp) {\n  vis[now] = 1;\n  if (now != tmp) B[id][now] = 1;\n  for (RI i = head[now]; i; i = e[i].next)\n    if (!vis[e[i].to]) DDfs(e[i].to, id, tmp);\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, m; read(n), read(m);\n  for (RI i = 1; i <= m; ++i)\n    read(G[i].x), read(G[i].y), addedge(G[i].x, G[i].y);\n  for (RI i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    Dfs(i, i);\n  }\n  for (RI i = 1; i <= n; ++i) {\n    int top = 0;\n    for (RI j = head[i]; j; j = e[j].next)\n      stk[++top] = e[j].to;\n    memset(vis, 0, sizeof(vis)); vis[i] = 1;\n    for (RI j = 1; j <= top; ++j)\n      if (!vis[stk[j]]) DDfs(stk[j], i, stk[j]);\n    memset(vis, 0, sizeof(vis)); vis[i] = 1;\n    for (RI j = top; j; --j)\n      if (!vis[stk[j]]) DDfs(stk[j], i, stk[j]);\n  }\n  for (RI i = 1; i <= m; ++i)\n    if (A[G[i].y][G[i].x] ^ B[G[i].x][G[i].y])\n      puts(\"diff\");\n    else puts(\"same\");\n\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int id)\n{\n\tSCC scc; scc.init(n);\n\tint cntscc=0;\n\tfor(int i=0;i<edges.size();i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tif(i==id) swap(u,v);\n\t\tscc.addedge(u,v);\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcntscc=max(cntscc,scc.sccidx[i]);\n\t}\n\tif(cntscc!=mxscc) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,x);\n\t}\n}\n\nbool reach[1111][1111];\nmap<ii,int> CNT;\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i][i]=1;\n\t\tqueue<int> q; q.push(i);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front(); q.pop();\n\t\t\tfor(ii x:adj[u])\n\t\t\t{\n\t\t\t\tint v=x.fi; \n\t\t\t\tif(!reach[i][v]) q.push(v);\n\t\t\t\treach[i][v]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tbool pos=0;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j==i) continue;\n\t\t\t\t\tif(j==v) continue;\n\t\t\t\t\tif(reach[i][j]&&reach[j][v])\n\t\t\t\t\t{\n\t\t\t\t\t\tpos=1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nvoid topological_sort(int f) {\n    if (starred[f]) return;\n    starred[f] = true;\n    for (int u : f[ll]) {\n        topological_sort(unf[u]);\n    }\n    topo_sort[topo_cnt++] = f;\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            topo_sort[topo_cnt++] = u;\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    memset(starred + 1, 0, n * sizeof(bool));\n    for (i=1; i<=n; ++i) {\n        int f = unf[i];\n        if (!starred[f]) {\n            topological_sort(f);\n        }\n    }\n    for (i=0; i<topo_cnt/2; ++i) {\n        swap(topo_sort[i], topo_sort[topo_cnt - 1 - i]);\n    }\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    for (auto u : piv) {\n        int t = find_stars(u.second, u.first);\n        if (unf[u.first] == unf[u.second]) {\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            puts(dag_second_visit[unf[u.first]].test(unf[u.second]) ? \"diff\" : \"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e3 + 10,M = 2e5 + 10;\n\nstruct node {\n\tint x,y;\n}G[M];\nint to[M],nex[M],beg[N],cnt[N][N],vis[N];\nint e;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\nvoid dfs(int St,int cur,int To) {\n\tif(St == cur || vis[cur] == To || cnt[St][cur] >= 2) return;\n\tcnt[St][cur]++;\n\tif(cnt[St][cur] == 1) vis[cur] = To;\n\tfor(int i = beg[cur];i;i = nex[i]) dfs(St,to[i],To);\n}\n\nint main() {\n\n\tint n = read(),m = read();\n\tFor(i,1,m) {\n\t\tint x = read(),y = read();\n\t\tadd(x,y),G[i] = (node){x,y};\n\t}\n\n\tFor(i,1,n) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int j = beg[i];j;j = nex[j]) dfs(i,to[j],to[j]);\n\t}\n\n\tFor(i,1,m) {\n\t\tif((cnt[G[i].x][G[i].y] >= 2) ^ (cnt[G[i].y][G[i].x] >= 1)) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1005;\nstruct Edge { int x, y; } G[200005];\nint vis[MAXN];\nint A[MAXN][MAXN], B[MAXN][MAXN];\nvector <int> e[MAXN];\n\ninline void addedge(int from, int to) {\n  e[from].push_back(to);\n}\n\nvoid Dfs(int now, int id) {\n  vis[now] = 1;\n  A[id][now] = 1;\n  int si = e[now].size();\n  for (RI i = 0; i < si; ++i)\n    if (!vis[e[now][i]]) Dfs(e[now][i], id);\n}\nvoid DDfs(int now, int id, int tmp) {\n  vis[now] = 1;\n  if (now != tmp) B[id][now] = 1;\n  int si = e[now].size();\n  for (RI i = 0; i < si; ++i)\n    if (!vis[e[now][i]]) DDfs(e[now][i], id, tmp);\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, m; read(n), read(m);\n  for (RI i = 1; i <= m; ++i)\n    read(G[i].x), read(G[i].y), addedge(G[i].x, G[i].y);\n  for (RI i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    Dfs(i, i);\n  }\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n  for (RI i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis)); vis[i] = 1;\n    int si = e[i].size();\n    for (RI j = 0; j < si; ++j)\n      if (!vis[e[i][j]]) DDfs(e[i][j], i, e[i][j]);\n    memset(vis, 0, sizeof(vis)); vis[i] = 1;\n    for (RI j = si - 1; ~j; --j)\n      if (!vis[e[i][j]]) DDfs(e[i][j], i, e[i][j]);\n  }\n  for (RI i = 1; i <= m; ++i)\n    if (A[G[i].y][G[i].x] ^ B[G[i].x][G[i].y])\n      puts(\"diff\");\n    else puts(\"same\");\n\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m;\npii edges[252521];\nint ids[252521];\n\nconst int B = 1000;\n\nstruct SCC {\n  int n;\n  vector<vi> g;\n  // scc\n  // http://www.prefield.com/algorithm/graph/strongly_connected_components.html\n  vi num;\n  vi low;\n  stack<int> S;\n  vector<bool> inS;\n  int time;\n  vector<vi> scc;\n  int count;\n  bool construct;\n  vi rev;\n\n  SCC(int n):n(n){\n    g.resize(n);\n  }\n  void add_edge(int a, int b){\n    g[a].push_back(b);\n  }\n  void add_edge(pii P){\n    add_edge(P.first, P.second);\n  }\n  void visit(int v){\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    REP(e,g[v].size()){\n      int w = g[v][e];\n      if(num[w]==0){\n        visit(w);\n        low[v] = min(low[v], low[w]);\n      }else if(inS[w]){\n        low[v] = min(low[v], num[w]);\n      }\n    }\n    if(low[v] == num[v]){\n      if(construct)scc.push_back(vi());\n      count++;\n      while(true){\n        int w = S.top(); S.pop(); inS[w] = false;\n        if(construct){\n          scc.back().push_back(w);\n          rev[w] = scc.size()-1;\n        }\n        if(v == w)break;\n      }\n    }\n  }\n  int calc(bool _const){\n    num.assign(n,0);\n    low.assign(n,0);\n    inS.assign(n,false);\n    time = 0;\n    count = 0;\n    construct = _const;\n    if(construct){\n      rev.assign(n,0);\n    }\n    REP(u,n)if(num[u]==0){\n      visit(u);\n    }\n    return count;\n  }\n};\n\n// O(sqrt(m) (m + n))\n\nbool ans[252521];\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  REP(i,m){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    edges[i] = pii(a,b);\n  }\n  // initial scc\n  int num = 0;\n  {\n    SCC scc(n);\n    REP(i,m)scc.add_edge(edges[i]);\n    num = scc.calc(false);\n  }\n  REP(i,m)ids[i] = i;\n  srand(83025);\n  random_shuffle(ids,ids+m);\n  REP(tims, (m+B-1)/B){\n    int beg = B*tims, end = min(B*(tims+1), m);\n    // construct partial graph\n    SCC scc(n);\n    REP(i,m)if(i<beg || end<=i){\n      scc.add_edge(edges[ids[i]]);\n    }\n    scc.calc(true);\n    unordered_set<ll> e2;\n    #define PO(x,y) ((((ll)(x))<<32)+(y))\n    REP(i,m)if(i<beg || end<=i)e2.insert(PO(scc.rev[edges[i].first], scc.rev[edges[i].second]));\n    FOR(i,beg,end){\n      SCC scc2(scc.count);\n      for(ll P : e2){\n        scc2.add_edge((P>>32), P&4294967295);\n      }\n      FOR(j,beg,end){\n        if(i==j){\n          scc2.add_edge(scc.rev[edges[ids[j]].second], scc.rev[edges[ids[j]].first]);\n        }else{\n          scc2.add_edge(scc.rev[edges[ids[j]].first], scc.rev[edges[ids[j]].second]);\n        }\n      }\n      int num2 = scc2.calc(false);\n      ans[ids[i]] = num == num2;\n    }\n  }\n  REP(i,m)puts(ans[i]?\"same\":\"diff\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n\nint n, m;\nvector<pair<int, int>> g[1000];\nchar used[1000];\nint a[1000][1000];\nint p[1000], q[1000];\nint an[200010];\n\nvoid dfs(int v, int root){\n    used[v] = true;\n    a[root][v] = 1;\n    for(auto to: g[v]){\n        if(!used[to.first]) dfs(to.first, root);\n    }\n}\n\nvoid dfs2(int v, int num, int dont, int t){\n    used[v] = true;\n    if(t == 0) p[v] = num;\n    else q[v] = num;\n    for(auto to: g[v]){\n        if(to.first == dont) continue;\n        if(!used[to.first]){\n            dfs2(to.first, num, dont, t);\n        }\n    }\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 0; i < m; i++){\n        int from, to;\n        cin >> from >> to;\n        g[from - 1].push_back({to - 1, i});\n    }\n    for(int i = 0; i < n; i++){\n        memset(used, 0, sizeof(used));\n        dfs(i, i);\n    }\n    for(int i = 0; i < n; i++){\n        memset(p, -1, sizeof(p));\n        memset(q, -1, sizeof(q));\n        memset(used, 0, sizeof(used));\n        for(int j = 0; j < (int)g[i].size(); j++){\n            if(!used[g[i][j].first]) dfs2(g[i][j].first, j, i, 0);\n        }\n        memset(used, 0, sizeof(used));\n        for(int j = (int)g[i].size() - 1; j >= 0; j--){\n            if(!used[g[i][j].first]) dfs2(g[i][j].first, j, i, 1);\n        }\n        for(int j = 0; j < (int)g[i].size(); j++){\n            if(p[g[i][j].first] != j || q[g[i][j].first] != j){\n                int ai = i, bi = g[i][j].first;\n                if(a[bi][ai]) an[g[i][j].second] = 1;\n            }\n            else{\n                int ai = i, bi = g[i][j].first;\n                if(!a[bi][ai]) an[g[i][j].second] = 1;\n            }\n        }\n    }\n    for(int i = 0; i < m; i++){\n        if(an[i]) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=1010,Maxm=200010;\nconst int inf=2147483647;\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n    return x*f;\n}\ntemplate <typename T> void cmin(T&x,T y){x=min(x,y);}\ntemplate <typename T> void cmax(T&x,T y){x=max(x,y);}\nint n,m;\nstruct Edge{int y,next;};\nstruct Graph\n{\n\tEdge e[Maxm];\n\tint last[Maxn],len;\n\tint cnt[Maxn][Maxn];bool vis[Maxn];\n\tbitset<Maxn>S[Maxn];\n\tvoid init(){len=0;}\n\tvoid ins(int x,int y)\n\t{\n\t\tint t=++len;\n\t\te[t].y=y;e[t].next=last[x];last[x]=t;\n\t}\n\tvoid bfs(int p)\n\t{\n\t\tqueue<int>q;q.push(p);\n\t\tmemset(vis,false,sizeof(vis));vis[p]=true;\n\t\tfor(int i=1;i<=n;i++)S[i].reset(),S[i].set(i);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();q.pop();\n\t\t\tfor(int i=last[x];i;i=e[i].next)\n\t\t\t{\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif(!S[x][y])cnt[p][y]++;\n\t\t\t\tif(!vis[y])\n\t\t\t\t{\n\t\t\t\t\tS[y]|=S[x];\n\t\t\t\t\tvis[y]=true;\n\t\t\t\t\tq.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}G1,G2;\nint low[Maxn],dfn[Maxn],sta[Maxn],top=0,id=0,cnt=0,bel[Maxn];\nbool in[Maxn];\nvoid Tarjan(int x)\n{\n\tlow[x]=dfn[x]=++id;\n\tsta[++top]=x;in[x]=true;\n\tfor(int i=G1.last[x];i;i=G1.e[i].next)\n\t{\n\t\tint y=G1.e[i].y;\n\t\tif(!dfn[y])Tarjan(y),low[x]=min(low[x],low[y]);\n\t\telse if(in[y])low[x]=min(low[x],dfn[y]);\n\t}\n\tif(low[x]==dfn[x])\n\t{\n\t\tint i;cnt++;\n\t\tdo\n\t\t{\n\t\t\ti=sta[top--];\n\t\t\tin[i]=false;\n\t\t\tbel[i]=cnt;\n\t\t}while(i!=x);\n\t}\n}\nint ex[Maxm],ey[Maxm];\nint main()\n{\n\tn=read(),m=read();\n\tG1.init(),G2.init();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tex[i]=read(),ey[i]=read();\n\t\tG1.ins(ex[i],ey[i]);\n\t}\n\tfor(int i=1;i<=n;i++)G1.bfs(i);\n//\tprintf(\"%d\\n\",G1.cnt[1][2]);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])Tarjan(i);\n//\tfor(int i=1;i<=n;i++)printf(\"%d %d\\n\",i,bel[i]);\n\tfor(int i=1;i<=m;i++)if(bel[ex[i]]!=bel[ey[i]])G2.ins(bel[ex[i]],bel[ey[i]]);\n\tfor(int i=1;i<=cnt;i++)G2.bfs(i);\n//\tprintf(\"%d\\n\",G2.cnt[3][1]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=ex[i],y=ey[i];\n\t\tif(bel[x]==bel[y])\n\t\t{\n\t\t\tif(G1.cnt[x][y]>1)puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(G2.cnt[bel[x]][bel[y]]>1)puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n    int u, v;\n} e[200010];\nvector <int> to[1010];\nint tag1[1010][1010], tag2[1010][1010];\nint n, m;\nint vis[1010];\ninline void dfs(int now) {\n    if(vis[now]) return;\n    vis[now] = 1;\n    for (auto v : to[now]) dfs(v);\n}\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= m; i++) scanf(\"%d%d\", &e[i].u, &e[i].v), to[e[i].u].push_back(e[i].v);\n    for (int i = 1; i <= n; i++) {\n        memset(vis, 0, sizeof vis);\n        vis[i] = 1;\n        for (auto v : to[i]) tag2[i][v] |= vis[v], dfs(v);\n        reverse(to[i].begin(), to[i].end());\n        memset(vis, 0, sizeof vis);\n        vis[i] = 1;\n        for (auto v : to[i]) tag2[i][v] |= vis[v], dfs(v);\n        memcpy(tag1[i], vis, sizeof tag1[i]);\n    }\n    for (int i = 1; i <= m; i++) puts(tag1[e[i].v][e[i].u] ^ tag2[e[i].u][e[i].v] ? \"diff\" : \"same\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, M;\nvector<pair<int, int> > G[1011];\n\nint D[1011];\nint dist[1011][1011];\nbool has[200011];\n\nvector<pair<int, int> > E;\nVI que;\n\nvoid bfs(int s) {\n    memset(D, 0x3f, sizeof D);\n    D[s] = 0;\n    que.clear();\n    que.push_back(s);\n    for (int i=0; i<(int)que.size(); i++) {\n\tint v = que[i];\n\tEACH (e, G[v]) {\n\t    int w = e->first;\n\t    if (D[w] > D[v] + 1) {\n\t\tD[w] = D[v] + 1;\n\t\tque.push_back(w);\n\t    }\n\t}\n    }\n    REP (i, N) dist[s][i] = D[i];\n\n    REP (t, 2) {\n\t// reachable;\n\tmemset(D, 0, sizeof D);\n\tD[s] = 1;\n\tEACH (e, G[s]) {\n\t    if (D[e->first]) {\n\t\thas[e->second] = true;\n\t    } else {\n\t\tque.clear();\n\t\tque.push_back(e->first);\n\t\tD[e->first] = 1;\n\t\tfor (int i=0; i<(int)que.size(); i++) {\n\t\t    int v = que[i];\n\t\t    EACH (f, G[v]) {\n\t\t\tint w = f->first;\n\t\t\tif (!D[w]) {\n\t\t\t    D[w] = 1;\n\t\t\t    que.push_back(w);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\treverse(G[s].begin(), G[s].end());\n    }\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    E.reserve(M);\n    REP (i, M) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tE.emplace_back(x, y);\n\tG[x].emplace_back(y, i);\n    }\n    memset(dist, 0x3f, sizeof dist);\n    const int INF = dist[0][0];\n\n    que.reserve(N);\n    REP (i, N) bfs(i);\n\n    REP (i, E.size()) {\n\tint x = E[i].first, y = E[i].second;\n\tbool diff = false;\n\tif (!has[i] && dist[y][x] != INF) diff = true;\n\tif (has[i] && dist[y][x] == INF) diff = true;\n\tputs(diff? \"diff\": \"same\");\n    }\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=2e5+10;\nint w[M],ne[M],la[N],t,ans[M];\nvoid link(int x,int y){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n}\nint arv[N][N],n,m,X,mrk[N],ti,mrk2[N];\nvoid dfs(int x){\n\tarv[X][x]=1;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (!arv[X][w[y]])dfs(w[y]);\n}\nvoid go(int x){\n\tmrk[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk[w[y]])go(w[y]);\n}\nvoid go2(int x){\n\tmrk2[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk2[w[y]])go2(w[y]);\n}\nvector<int> c;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tfor (X=1;X<=n;X++){\n\t\tc.clear();\n\t\tfor (int y=la[X];y;y=ne[y]){\n\t\t\tti++;\n\t\t\tif (!mrk[w[y]])go(w[y]);\n\t\t\tc.push_back(w[y]);\n\t\t}\n\t\twhile (c.size()){\n\t\t\tif (!mrk2[c.back()])go2(c.back());\n\t\t\tc.pop_back();\n\t\t\tti--;\n\t\t}\n\t\tfor (int y=la[X];y;y=ne[y])ans[y]=(mrk[w[y]]<mrk2[w[y]]);\n\t\tfor (int i=1;i<=n;i++)arv[X][i]=(bool)mrk[i],mrk[i]=mrk2[i]=0;\n\t}\n\tfor (int x=1;x<=n;x++)\n\t\tfor(int y=la[x];y;y=ne[y])\n\t\t\tans[y]=ans[y]==arv[w[y]][x];\n\tfor (int i=1;i<=m;i++)\n\t\tputs(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"tune=native\")\n//#pragma GCC target (\"avx\")\n//#include <bits/stdc++.h>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n#define N 1010\n#define M 200100\nint h[N][N];\nvector<int> g[N];\nll a[M], b[M];\nint f[N][N];\nll n, m, vv = -1;\n\nvoid dfs(int w, int u, int d){\n\tif(f[w][u]>=2) return;\n\tchmax(f[w][u], d);\n\tfor(auto &&v: g[u]){\n\t\tif(v==w) continue;\n\t\tif(u==w) vv = v;\n\t\tif(f[w][v]==-1) dfs(w, v, d+1);\n\t\telse if(f[w][v]==1&&vv!=v) f[w][v] = d+1;\n\t}\n}\n\nint main(){\n\tINIT;\n\tcin>>n>>m;\n\trep(i, n) fill(h[i], h[i]+n, INF);\n\trep(i, n) h[i][i] = 0;\n\trep(i, m){\n\t\tcin>>a[i]>>b[i];\n\t\ta[i]--; b[i]--;\n\t\tg[a[i]].pb(b[i]);\n\t\th[a[i]][b[i]] = 1;\n\t}\n\trep(k, n) rep(i, n) rep(j, n) chmin(h[i][j], h[i][k]+h[k][j]);\n\tmset(f, -1);\n\trep(i, n){\n\t\tdfs(i, i, 0);\n\t}\n\trep(i, m){\n\t\tbool f2 = h[b[i]][a[i]]!=INF;\n\t\tbool f1 = f[a[i]][b[i]]>=2;\n\t\tcout<<(f1^f2?\"diff\":\"same\")<<endl;\n\t\t//cerr<<f1<<\" \"<<f2<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n\n#define rep(i,i0,n) for (int (i) = (i0); (i) < (n); ++(i))\n\nusing namespace std;\nusing ll = long long;\n\nclass UnionFind {\npublic:\n    UnionFind(int);\n    int find(int);\n    void unite(int, int);\nprivate:\n    vector<int> table;\n};\n\nUnionFind::UnionFind(int size) {\n    table.resize(size);\n    fill(table.begin(), table.end(), -1);\n}\n\nint UnionFind::find(int x) {\n    while (0 <= table[x])\n        x = table[x];\n    return x;\n}\n\nvoid UnionFind::unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx != ry) {\n        int dx = -table[rx];\n        int dy = -table[ry];\n        if (dx != dy) {\n            if (dx < dy) {\n                table[rx] = ry;\n            } else {\n                table[ry] = rx;\n            }\n        } else {\n            table[rx] -= 1;\n            table[ry] = rx;\n        }\n    }\n}\n\nvector< vector<int> > e, re;\n\nUnionFind cc(1024);\nUnionFind scc(1024);\nint post[1024];\nint rev[1024];\nbool visited[1024];\nbool visited2[1024];\n\nint t = 1;\n\nvoid dfs0(int u, int r) {\n    cc.unite(u, r);\n    post[u] = 1;  // dummy\n    for (int w : e[u]) {\n        if (!post[w]) {\n            dfs0(w, r);\n        }\n    }\n    post[u] = t;\n    rev[t] = u;\n    ++t;\n}\n\nvoid dfs1(int u, int r, int cr, bool visited[]) {\n    scc.unite(u, r);\n    visited[u] = true;\n    for (int w : re[u]) {\n        if (cc.find(w) != cr) {\n            continue;\n        }\n        if (!visited[w]) {\n            dfs1(w, r, cr, visited);\n        }\n    }\n}\n\nvoid dfs2(int u, int r, int first, set< pair<int, int> >& rs, bool visited[]) {\n    visited[u] = true;\n    for (int w : e[u]) {\n        if (!visited[w]) {\n            dfs2(w, r, first, rs, visited);\n        } else if (w != r && w != first) {\n            rs.insert(make_pair(r, w));\n        }\n    }\n}\n\nvoid traverse(int n, int s, set< pair<int, int> >& rs) {\n    fill(visited2, visited2 + n + 1, false);\n    visited2[s] = true;\n    for (int w : e[s]) {\n        visited2[w] = true;\n    }\n    for (int w : e[s]) {\n        dfs2(w, s, w, rs, visited2);\n    }\n}\n\nvoid solve(int n, int m, vector< pair<int, int> >& edges) {\n    int cur;\n    int r1, cr;\n\n    fill(post, post + n + 1, 0);\n    fill(rev, rev + n + 1, 0);\n\n    fill(visited, visited + n + 1, false);\n    rep(r, 1, n + 1) {\n        if (!post[r]) {\n            cur = t;\n            dfs0(r, r);\n            cr = cc.find(r);\n            for (int v = t - 1; v >= cur; --v) {\n                r1 = rev[v];\n                if (!visited[r1]) {\n                    dfs1(r1, r1, cr, visited);\n                }\n            }\n        }\n    }\n\n    set< pair<int, int> > path_exists;\n    int a, b;\n    int scc_a, scc_b;\n    bool exist;\n    \n    fill(visited, visited + n + 1, false);\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        if (!visited[a]) {\n            visited[a] = true;\n            traverse(n, a, path_exists);\n        }\n    }\n\n    for (pair<int, int> p : edges) {\n        tie(a, b) = p;\n        scc_a = scc.find(a);\n        scc_b = scc.find(b);\n        exist = (path_exists.find(make_pair(a, b)) != path_exists.end());\n        cout << ((scc_a == scc_b) ^ exist ? \"diff\" : \"same\") << endl;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n\n    int n, m;\n    int a, b;\n    vector< pair<int, int> > edges;\n    \n    cin >> n >> m;\n    e.resize(n + 1);\n    re.resize(n + 1);\n    rep(i, 0, m) {\n        cin >> a >> b;\n        edges.push_back(make_pair(a, b));\n        e[a].push_back(b);\n        re[b].push_back(a);\n    }\n\n    solve(n, m, edges);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb emplace_back\n#define mr make_pair\n#define N 1010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char ch=getchar();int fh=1;\n\twhile (ch<'0'||ch>'9'){if (ch=='-')fh=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\tx*=fh;\n}\nint m,n,x,y,mi[N][N],ma[N][N],vi[N][N],p[1000010],q[1000010];\nvector<int> a[N];\nvoid d1(int be,int x){\n\tvi[be][x]=1;\n\tfor (auto y:a[x])if (!vi[be][y]) d1(be,y);\n}\nvoid d3(int be,int zh,int x){\n\tif (mi[be][x]) return ;\n\tmi[be][x]=zh;\n\tfor (auto y:a[x])if (!mi[be][y]) d3(be,zh,y);\n}\nvoid d2(int be,int zh,int x){\n\tif (ma[be][x]) return ;\n\tma[be][x]=zh;\n\tfor (auto y:a[x])if (!ma[be][y]) d2(be,zh,y);\n}\nint main(){\n\tread(n);read(m);\n\tfor (int i=1;i<=m;i++){read(p[i]);read(q[i]);a[p[i]].pb(q[i]);}\n\tfor (int i=1;i<=n;i++)d1(i,i);\n\tfor (int i=1;i<=n;i++){\n\t\tsort(a[i].begin(),a[i].end());\n\t\tma[i][i]=mi[i][i]=i;\n\t\tfor (int j=0;j<a[i].size();j++)d3(i,a[i][j],a[i][j]);\n\t\tfor (int j=a[i].size()-1;j>=0;j--)d2(i,a[i][j],a[i][j]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tint x=p[i],y=q[i];\n\t\tif (vi[y][x]^(ma[x][y]!=y||mi[x][y]!=y))puts(\"diff\");else puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn;\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(++pn;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid dfs1(int x)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs1(e[i].t),uu[i>>1]=1;\n}\nvoid dfs2(int x)\n{\n\tu[x]=1;\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&!u[e[i].t])dfs2(e[i].t),uu[i>>1]=1;\n}\nvoid d1(int x,int y)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=y&&!u[e[i].t])d1(e[i].t,y);\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)==y&&!u[e[i].t])d1(e[i].t,y);\n}\nvoid d2(int x,int y)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)==y&&!u[e[i].t])d2(e[i].t,y);\n\tfor(int i=r[x];i;i=e[i].nx)if(p[e[i].t]==p[x]&&(i>>1)!=y&&!u[e[i].t])d2(e[i].t,y);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tfor(i=1;i<=n;++i)if(!u[i])dfs1(i);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=n;++i)if(!u[i])dfs2(i);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)\n\t\tfor(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\t\tfor(k=c[q[j]];k;k=e[k].nx)\n\t\t\t{\n\t\t\t\tif(!g[i][e[k].t])q[++qn]=e[k].t;\n\t\t\t\t++g[i][e[k].t];\n\t\t\t}\n\tfor(i=1;i<=m;++i)\n\t{\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(!uu[i]){puts(\"same\");continue;}\n\t\t\tmemset(u,0,sizeof(u));\n\t\t\td1(x[i],i);\n\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\tmemset(u,0,sizeof(u));\n\t\t\td2(x[i],i);\n\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\tputs(j>n?\"same\":\"diff\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nint n,m,u,v,dp[1007][1007];\nbool vis[1007];\npair <int,int> ed[200007];\nvector <int> edge[1007];\nvoid dfs(int u,int par,int from){\n\tif(u==from) return;\n\tif(dp[from][u]==2) return;\n\tif(dp[from][u]==1 && vis[u]) return;\n\tdp[from][u]++, vis[u]=true;\n\tfor(int v:edge[u]){\n\t\tif(v==par) continue;\n\t\tdfs(v,u,from);\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>u>>v;\n\t\tedge[u].pb(v);\n\t\ted[i]=mp(u,v);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int x:edge[i]){\n\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\tdfs(x,i,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tu=ed[i].fi;\n\t\tv=ed[i].se;\n\t\tbool ok=true;\n\t\tif(dp[u][v]>=2){\n\t\t\tif(dp[v][u]==0) ok=true;\n\t\t\telse ok=false;\n\t\t}\n\t\telse{\n\t\t\tif(dp[v][u]>=1) ok=true;\n\t\t\telse ok=false;\n\t\t}\n\t\tif(ok) cout<<\"diff\\n\";\n\t\telse cout<<\"same\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=1005;\nconst int maxm=200005;\nint n,m,ql,qr;\nvector<pii>dat[maxn];\nbitset<maxn>edge[maxn],val1[maxn],val2,vis,cur;\nint que[maxn];\nbool ans[maxm];\n\nvoid bfs(){\n\twhile(ql<qr){\n\t\tint x=que[ql++];\n\t\tcur=~vis&edge[x];\n\t\tint y=-1;\n\t\tfor(;;){\n\t\t\ty=cur._Find_next(y);\n\t\t\tif(y>=n)break;\n\t\t\tvis[y]=1;\n\t\t\tque[qr++]=y;\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tedge[u][v]=1;\n\t\tdat[u].pb(mp(v,i));\n\t}\n\trep(i,n){\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\tque[qr++]=i;\n\t\tbfs(); \n\t\tval1[i]=vis;\n\t}\n\trep(i,n){\n\t\tval2=0;\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\trep(j,int(dat[i].size())){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tif(vis[k]){\n\t\t\t\tval2[k]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[k]=1;\n\t\t\tque[qr++]=k;\n\t\t\tbfs();\n\t\t}\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\tfor(int j=int(dat[i].size())-1;j>=0;j--){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tif(vis[k]){\n\t\t\t\tval2[k]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[k]=1;\n\t\t\tque[qr++]=k;\n\t\t\tbfs();\n\t\t}\n\t\trep(j,int(dat[i].size())){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tans[dat[i][j].snd]=(val1[k][i]!=val2[k]);\n\t\t}\n\t}\n\trep(i,m)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],vis[N];\nvector<int> e[N];\nvoid dfs(int st,int u,int now){\n\tif (st==u) return;\n\tif (a[st][u]>=2) return;\n\tif (a[st][u]==1 && vis[u]==now) return;\n\tif (a[st][u]==0) vis[u]=now;\n\ta[st][u]++;\n\trep (i,0,(int)e[u].size()-1) dfs(st,e[u][i],now);\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read();\n\t\te[x[i]].push_back(y[i]);\n\t\t\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,-1,sizeof(vis));\n\t\trep (j,0,(int)e[i].size()-1) dfs(i,e[i][j],e[i][j]);\n\t}\n\trep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]]>=1;\n\t\tbool f2=a[x[i]][y[i]]>=2;\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int> e[1005];\nint cl[1005][1005][2],u[200005],v[200005];\nvoid dfs(int x,int ro,int c,int t){\n\tif(cl[ro][x][t])return;\n\tcl[ro][x][t]=c;\n\tfor(int i=0;i<e[x].size();i++)if(!cl[ro][e[x][i]][t])dfs(e[x][i],ro,c,t);\n}\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\te[u[i]].push_back(v[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tcl[i][i][0]=i;\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tdfs(e[i][j],i,e[i][j],0);\n\t\t}\n\t\tcl[i][i][1]=i;\n\t\tfor(int j=(int)e[i].size()-1;j>=0;j--){\n\t\t\tdfs(e[i][j],i,e[i][j],1);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(cl[v[i]][u[i]][0]){\n\t\t\tif(cl[u[i]][v[i]][0]!=v[i]||cl[u[i]][v[i]][1]!=v[i])puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t}else{\n\t\t\tif(cl[u[i]][v[i]][0]!=v[i]||cl[u[i]][v[i]][1]!=v[i])puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int LG = 21;\nconst int FN = 400005;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(FN);\n    __ufact.resize(FN);\n    __rev.resize(FN);\n    __rev[1] = 1;\n    for (int i = 2; i < FN; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < FN; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nconst int N = 1010;\nconst int M = 201010;\nvector<int> graph[N];\nint go[N][N], f[N][N], g[N][N];\nint fr[M], to[M], glina[M];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    forn(i, m)\n    {\n        int a, b;\n        cin >> a >> b;\n        glina[i] = graph[a].size();\n        graph[a].push_back(b);\n        fr[i] = a, to[i] = b;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> q = {i};\n        go[i][i] = 1;\n        for (int j = 0; j < q.size(); j++)\n        {\n            int v = q[j];\n            for (auto u : graph[v]) if (!go[i][u]) go[i][u] = 1, q.push_back(u);\n        }\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) f[i][j] = -1, g[i][j] = -1;\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> vis(n + 1, 0);\n        vis[i] = 1;\n        for (int a = 0; a < graph[i].size(); a++)\n        {\n            if (vis[graph[i][a]]) continue;\n            vector<int> q = {graph[i][a]};\n            for (int j = 0; j < q.size(); j++)\n            {\n                int v = q[j];\n                f[i][v] = a;\n                for (auto u : graph[v]) if (!vis[u]) vis[u] = 1, q.push_back(u);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> vis(n + 1, 0);\n        vis[i] = 1;\n        for (int a = (int)graph[i].size() - 1; a >= 0; a--)\n        {\n            if (vis[graph[i][a]]) continue;\n            vector<int> q = {graph[i][a]};\n            for (int j = 0; j < q.size(); j++)\n            {\n                int v = q[j];\n                g[i][v] = a;\n                for (auto u : graph[v]) if (!vis[u]) vis[u] = 1, q.push_back(u);\n            }\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int id = glina[i];\n        int v = fr[i], u = to[i];\n        int fl = (f[v][u] != -1 && f[v][u] != id);\n        fl |= (g[v][u] != -1 && g[v][u] != id);\n        if (fl ^ go[u][v]) cout << \"diff\\n\";\n        else cout << \"same\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{int nx,t;}e[MM*3+5];\nint h[MN+5],r[MN+5],c[MN+5],en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(int*h,int x,int y){e[++en]=(edge){h[x],y};h[x]=en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)\n\t\tif(!d[e[i].t])dfs(e[i].t),l[x]=min(l[x],l[e[i].t]);\n\t\telse if(inz[e[i].t])l[x]=min(l[x],d[e[i].t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(int*h,int x,int z)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if(!u[e[i].t])d1(h,e[i].t,z),uu[i>>1]|=z;\n}\nvoid d2(int*h,int x,int d,int xs,int ys)\n{\n\tu[x]=1;\n\tfor(int i=h[x];i;i=e[i].nx)if((i>>1)!=d&&!u[e[i].t])d2(h,e[i].t,d,xs,ys);\n\tif(x==xs&&!u[ys])d2(h,ys,d,xs,ys);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j,k;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tmemset(h,0,sizeof(h));memset(r,0,sizeof(r));en=1;\n\tfor(i=1;i<=m;++i)if(p[x[i]]==p[y[i]])ins(h,x[i],y[i]),ins(r,y[i],x[i]);else en+=2;\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(k=c[q[j]];k;k=e[k].nx)if(!g[i][e[k].t]++)q[++qn]=e[k].t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i]&1)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,ph[p[x[i]]],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i]&2)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,ph[p[x[i]]],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e3 + 10;\n\nint N, M, Vis[MAX_N][MAX_N], Re[MAX_N][MAX_N];\nvector<int> Ed[MAX_N];\nvector<pi> EdList;\nvoid getVis() {\n\tfor(int st=1; st<=N; st++) {\n\t\tqueue<int> Q; int *vis = Vis[st];\n\t\tQ.emplace(st); vis[st] = true;\n\t\twhile(!Q.empty()) {\n\t\t\tint v = Q.front(); Q.pop();\n\t\t\tfor(int w : Ed[v]) if(not vis[w]) vis[w] = true, Q.emplace(w);\n\t\t}\n\t}\n}\nint Val[2][MAX_N][MAX_N];\nvoid dfs(int v, int st, int ix, int* val, function<int(int, int)> f) {\n\tif(v == st) return;\n\tif(val[v] == ix or f(val[v], ix) != ix) return;\n\tval[v] = ix;\n\tfor(int w : Ed[v]) dfs(w, st, ix, val, f);\n}\nvoid getMnMx() {\n\tint base[2] = {INF, -INF};\n\tfunction<int(int, int)> func[2] = {[](int a, int b) {return min(a, b);}, [](int a, int b) {return max(a, b);}};\n\tfor(int k=0; k<2; k++) for(int st=1; st<=N; st++) {\n\t\tint *val = Val[k][st];\n\t\tfor(int i=1; i<=N; i++) val[i] = base[k];\n\t\tfor(int w : Ed[st]) dfs(w, st, Re[st][w], val, func[k]);\n\t\t//for(int w : Ed[st]) printf(\"%d -> %d : %d\\n\", st, w, val[w]);\n\t\treverse(ALL(Ed[st]));\n\t}\n}\nbool canGo(int x, int y) {return Val[0][x][y] != Re[x][y] or Val[1][x][y] != Re[x][y];}\nint main() {\n\tcin >> N >> M;\n\tfor(int i=0; i<M; i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tRe[x][y] = SZ(Ed[x]);\n\t\tEd[x].emplace_back(y);\n\t\tEdList.emplace_back(x, y);\n\t}\n\tgetVis();\n\tgetMnMx();\n\tfor(int i=0; i<M; i++) {\n\t\tint x, y; tie(x, y) = EdList[i];\n\t\t//printf(\"[%d %d] : \", Vis[y][x], canGo(x, y));\n\t\tputs(((Vis[y][x]) ^ (canGo(x, y))) ? \"diff\" : \"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\nconst int M = 200005;\nconst int INF = 1e9;\n\nint n, m;\nint fr[M], to[M];\nvector<int> g[N];\nint low[N], num[N], step, scc;\nstack <int> st;\nint pos[N];\nint vis[N];\nbool curvis[N];\nbool two[N][N];\n\nvoid dfs(int u) {\n\tlow[u] = num[u] = ++step;\n\tst.push(u);\n\n\tfor (int &v : g[u]) {\n\t\tif (num[v]) low[u] = min(low[u], num[v]);\n\t\telse {\n\t\t\tdfs(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t}\n\t}\n\n\tif (low[u] == num[u]) {\n\t\tint v = 0;\n\t\t++scc;\n\t\tdo {\n\t\t\tv = st.top(); st.pop();\n\t\t\tlow[v] = num[v] = INF;\n\t\t\tpos[v] = scc;\n\t\t} while(v != u);\n\t}\n}\n\nvector<int> current;\n\nvoid dfs2(int u) {\n\tvis[u]++;\n\tcurrent.push_back(u);\n\tcurvis[u] = true;\n\n\tfor (int &v : g[u]) {\n\t\tif (curvis[v]) continue;\n\t\tif (vis[v] == 2) continue;\n\t\tdfs2(v);\n\t}\n}\n\nvoid solve(int s) {\n\tfor (int i = 1; i <= n; ++i) vis[i] = 0;\n\tvis[s] = 2;\n\t\n\tfor (int &v : g[s]) {\n\t\tcurrent.clear();\n\t\tif (vis[v] < 2) dfs2(v);\n\t\twhile(current.size()) {\n\t\t\tcurvis[current.back()] = false;\n\t\t\tcurrent.pop_back();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i) if (vis[i] == 2) two[s][i] = true;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tfr[i] = u;\n\t\tto[i] = v;\n\t}\n\n\tfor (int i = 1; i <= n; ++i) if (!num[i]) dfs(i);\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tsolve(i);\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u = fr[i], v = to[i];\n\t\tbool cur = (pos[u] != pos[v]);\n\t\tcur ^= two[u][v];\n\t\t\n\t\t// cut the i-th edge and check if there exists a directed path from u to v\n\t\tif (cur) {\n\t\t\tprintf(\"same\\n\");\n\t\t} else {\n\t\t\tprintf(\"diff\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define MAXN (1000 + 5)\n#define MAXM (200000 + 5)\n#define pii pair<int, int>\nusing namespace std;\nstruct edg\n{\n\tint from, to, next;\n}b[MAXM];\nint g[MAXN], cntb, col[MAXN], n, m;\nint g1[MAXN][MAXN], g2[MAXN][MAXN];\nvoid adn(int from, int to)\n{\n\tb[++cntb].next = g[from];\n\tb[cntb].from = from;\n\tb[cntb].to = to;\n\tg[from] = cntb;\n}\nvoid dfs(int dq)\n{\n\tfor (int i = g[dq]; i; i = b[i].next)\n\t\tif (!col[b[i].to])\n\t\t\tcol[b[i].to] = col[dq], dfs(b[i].to);\n}\nvoid init()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(col, 0, sizeof(col));\n\t\tcol[i] = 1;\n\t\tdfs(i);\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (col[j])\n\t\t\t\tg1[i][j] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(col, 0, sizeof(col));\n\t\tcol[i] = i;\n\t\tint t[MAXM], cc[MAXN];\n\t\tt[0] = 0;\n\t\tfor (int j = g[i]; j; j = b[j].next)\n\t\t\tt[++t[0]] = j;\n\t\tfor (int j = 1; j <= t[0]; j++)\n\t\t\tif (!col[b[t[j]].to])\n\t\t\t\tcol[b[t[j]].to] = j, dfs(b[t[j]].to);\n\t\tmemcpy(cc, col, sizeof(int) * (n + 5));\n\t\tmemset(col, 0, sizeof(col));\n\t\tcol[i] = i;\n\t\tfor (int j = t[0]; j; j--)\n\t\t\tif (!col[b[t[j]].to])\n\t\t\t\tcol[b[t[j]].to] = j, dfs(b[t[j]].to);\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (col[j] != cc[j])\n\t\t\t\tg2[i][j] = 1;\n\t}\n}\npii e[MAXM];\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d\", &e[i].first, &e[i].second);\n\t\tadn(e[i].first, e[i].second);\n\t}\n\tinit();\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif ((g1[e[i].second][e[i].first] && !g2[e[i].first][e[i].second]) xor (!g1[e[i].second][e[i].first] && g2[e[i].first][e[i].second]))\n\t\t\tputs(\"diff\");\n\t\telse\n\t\t\tputs(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<1)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],z[M],vis[N],p[N][N],q[N][N];\nvector<int> e[N];\nvoid dfs(int st,int u){\n\tvis[u]=1; a[st][u]=1;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs(st,v);\n\t}\n}\nvoid dfs1(int st,int u,int id){\n\tvis[u]=1; p[st][u]=id;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs1(st,v,id);\n\t}\n}\nvoid dfs2(int st,int u,int id){\n\tvis[u]=1; q[st][u]=id;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs2(st,v,id);\n\t}\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read(); z[i]=(int)e[x[i]].size();\n\t\te[x[i]].push_back(y[i]);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(i,i);\n\t}\n\tmemset(p,-1,sizeof(p)); memset(q,-1,sizeof(q));\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\trep (j,0,(int)e[i].size()-1) if (!vis[e[i][j]]) dfs1(i,e[i][j],j);\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\tper (j,(int)e[i].size()-1,0) if (!vis[e[i][j]]) dfs2(i,e[i][j],j);\n\t}\n\t//printf(\"%d\\n\",a[3][1]);\n\t//printf(\"%d %d\\n\",p[1][3],q[1][3]);\n\t//printf(\"%d\\n\",a[4][3]);\n\t//printf(\"%d %d\\n\",p[3][4],q[3][4]);\n\trep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]];\n\t\tbool f2=p[x[i]][y[i]]!=z[i] || q[x[i]][y[i]]!=z[i];\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    if(vis1[u]) return;\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    if(vis2[u]) return;\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=2;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            dfs1(e[i][j],j+1);\n        for(int j=up-1;j>=0;j--)\n            dfs2(e[i][j],j+1);\n        for(int j=1;j<=n;j++)\n            if(vis1[j])\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> e(N);\n    using P = pair<int, int>;\n    vector<P> edge(M);\n    vector<vector<int>> start(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        e[a].push_back(b);\n        edge[i] = {a, b};\n        start[a].push_back(i);\n    }\n    vector<vector<bool>> ok(N, vector<bool>(N, false));\n    for (int i = 0; i < N; i++) {\n        queue<int> q;\n        q.push(i);\n        ok[i][i] = true;\n        while (not q.empty()) {\n            const int s = q.front();\n            q.pop();\n            for (const int to : e[s]) {\n                if (ok[i][to]) { continue; }\n                ok[i][to] = true;\n                q.push(to);\n            }\n        }\n    }\n    vector<bool> ans(M);\n    for (int i = 0; i < N; i++) {\n        vector<int> dp(N, -1);  // -1: yet, M: doubled\n        queue<int> q;\n        for (const int c : start[i]) {\n            dp[edge[c].second] = c;\n            q.push(edge[c].second);\n        }\n        while (not q.empty()) {\n            const int s = q.front();\n            q.pop();\n            if (s == i) { continue; }\n            for (const int to : e[s]) {\n                if (dp[to] == M or dp[to] == dp[s]) { continue; }\n                if (dp[to] == -1) {\n                    dp[to] = dp[s];\n                    q.push(to);\n                } else {\n                    dp[to] = M;\n                    q.push(to);\n                }\n            }\n        }\n        for (const int c : start[i]) {\n            const bool ts = ok[edge[c].second][edge[c].first];\n            const bool dst = dp[edge[c].second] == M;\n            ans[c] = ts ^ dst;\n        }\n    }\n    for (int i = 0; i < M; i++) { cout << (ans[i] ? \"diff\" : \"same\") << endl; }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=1005;\nconst int maxm=200005;\nint n,m,ql,qr;\nvector<pii>dat[maxn];\nbitset<maxn>edge[maxn],val1[maxn],val2,vis,cur;\nint que[maxn];\nbool ans[maxm];\n\nvoid bfs(){\n\twhile(ql<qr){\n\t\tint x=que[ql++];\n\t\tcur=~vis&edge[x];\n\t\tint y=-1;\n\t\tfor(;;){\n\t\t\ty=cur._Find_next(y);\n\t\t\tif(y>=n)break;\n\t\t\tvis[y]=1;\n\t\t\tque[qr++]=y;\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tedge[u][v]=1;\n\t\tdat[u].pb(mp(v,i));\n\t}\n\trep(i,n){\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\tque[qr++]=i;\n\t\tbfs(); \n\t\tval1[i]=vis;\n\t}\n\trep(i,n){\n\t\tval2=0;\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\trep(j,int(dat[i].size())){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tif(vis[k])val2[k]=1;\n\t\t\tvis[k]=1;\n\t\t\tque[qr++]=k;\n\t\t\tbfs();\n\t\t}\n\t\tql=qr=0;\n\t\tvis=0;\n\t\tvis[i]=1;\n\t\tfor(int j=int(dat[i].size())-1;j>=0;j--){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tif(vis[k])val2[k]=1;\n\t\t\tvis[k]=1;\n\t\t\tque[qr++]=k;\n\t\t\tbfs();\n\t\t}\n\t\trep(j,int(dat[i].size())){\n\t\t\tint k=dat[i][j].fst;\n\t\t\tans[dat[i][j].snd]=(val1[k][i]!=val2[k]);\n\t\t}\n\t}\n\trep(i,m)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define go(x) for(int i=head[x];i;i=edge[i].nxt)\n#define now edge[i].v\nusing namespace std;\nconst int sz=1009;\nint n,m;\nint rt;\nint u,v,cnt;\nbool vis[sz];\nint head[sz];\nbool b[200007];\nbool d[sz][sz];\nbool ans[sz];\nstack<int>s;\nstruct Edge{\n\tint v,nxt;\n}edge[200007];\nvoid make_edge(int u,int v){\n\tedge[++cnt]=(Edge){v,head[u]};\n\thead[u]=cnt;\n}\nvoid dfs(int x,int tp){\n\tif(tp) d[rt][x]=1;\n\tvis[x]=1;\n\tgo(x) if(!vis[now]) dfs(now,tp);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tmake_edge(u,v);\n\t}\n\tfor(rt=1;rt<=n;rt++){\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tdfs(rt,1);\n\t}\n\tfor(rt=1;rt<=n;rt++){\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[rt]=1;\n\t\tgo(rt){\n\t\t\tif(vis[now]) b[i]=1;\n\t\t\telse dfs(now,0);\n\t\t\ts.push(i);\n\t\t}\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[rt]=1;\n\t\twhile(!s.empty()){\n\t\t\tif(vis[edge[s.top()].v]) b[s.top()]=1;\n\t\t\telse dfs(edge[s.top()].v,0);\n\t\t\ts.pop();\n\t\t}\n\t}\n\tfor(rt=1;rt<=n;rt++)\n\t\tgo(rt) ans[i]=d[now][rt]^b[i];\n\tfor(int i=1;i<=m;i++) \n\tif(ans[i]) puts(\"diff\");\n\telse puts(\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define pb(a) push_back(a)\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=1e3+5,M=2e5+5;\n\nint n,m,u[M],v[M],p[N],mn[N],mx[N],id;\nvector<int> to[N];\nbool vis[N],can[N][N],path[N][N];\n\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(int y:to[x]) if (!vis[y]) dfs(y);\n}\n\nvoid dfs_mn(int x) {\n\tif (mn[x]) return;\n\tmn[x]=id;for(int y:to[x]) dfs_mn(y);\n}\n\nvoid dfs_mx(int x) {\n\tif (mx[x]) return;\n\tmx[x]=id;for(int y:to[x]) dfs_mx(y);\n}\n\nint main() {\n\tn=read();m=read();\n\tfo(i,1,m) {\n\t\tu[i]=read();v[i]=read();\n\t\tto[u[i]].pb(v[i]);\n\t}\n\tfo(i,1,n) {\n\t\tfo(j,1,n) vis[j]=0;\n\t\tdfs(i);\n\t\tfo(j,1,n) can[i][j]=vis[j];\n\t}\n\tfo(i,1,n) {\n\t\tfo(j,1,n) mn[j]=mx[j]=0;mn[i]=mx[i]=1;\n\t\tint t=0;for(int x:to[i]) p[++t]=x;\n\t\tfo(j,1,t) id=j,dfs_mn(p[j]);\n\t\tfd(j,t,1) id=j,dfs_mx(p[j]);\n\t\tfo(j,1,t) path[i][p[j]]=mn[p[j]]<mx[p[j]];\n\t}\n\tfo(i,1,m) puts(can[v[i]][u[i]]^path[u[i]][v[i]]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*==============================\n * Authot : ylsoi\n * Time : 2018.3.20\n * Problem : ARC92F\n * File : ARC92F.cpp\n * Algorithm : Strange Algorithm\n * ===========================*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid File(){\n\tfreopen(\"ARC92F.in\",\"r\",stdin);\n\tfreopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define MREP(i,x) for(register int i=beg[x];i;i=E[i].last)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nint n,m,beg[maxn],len;\nbool can[maxn][maxn],can1[maxn][maxn],vis[maxn];\nstruct edge{\n\tint from;\n\tint to;\n\tint last;\n}E[maxm];\nvoid add(int u,int v){\n\t++len;\n\tE[len].from=u;\n\tE[len].to=v;\n\tE[len].last=beg[u];\n\tbeg[u]=len;\n}\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tMREP(i,u){\n\t\tint v=E[i].to;\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nbool flag;\nvoid dfs1(int u,int e,int rt){\n\tvis[u]=1;\n\tMREP(i,u){\n\t\tif(flag)return;\n\t\tint v=E[i].to;\n\t\tif(i==e)continue;\n\t\tif(v==E[e].to){\n\t\t\tcan1[rt][v]=1;\n\t\t\tflag=1;\n\t\t}\n\t\tif(vis[v])continue;\n\t\tdfs1(v,e,rt);\n\t}\n}\nint main(){\n\t//File();\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t}\n\tREP(i,1,n)dfs(i,i),mem(vis);\n\tREP(i,1,m){\n\t\tdfs1(E[i].from,i,E[i].from);\n\t\tmem(vis);\n\t\tflag=0;\n\t}\n\tREP(i,1,m){\n\t\tint u=E[i].from,v=E[i].to;\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tputs(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(e, E) for (const auto& e : E)\n#define RESIDUE(s, t) (capacity[s][t] - flow[s][t])\nusing Weight = ll;\nusing Array = vector<ll>;\nusing Matrix = vector<vector<ll>>;\nstruct Edge\n{\n    Edge() = default;\n    Edge(const int src, const int dst, const ll weight) : src{src}, dst{dst}, weight{weight} {}\n    int src;\n    int dst;\n    ll weight;\n};\nusing Graph = vector<vector<Edge>>;\nGraph cutTree(const Graph& g)\n{\n    int n = g.size();\n    Matrix capacity(n, Array(n)), flow(n, Array(n));\n    for (int u = 0; u < n; u++) {\n        for (const auto e : g[u]) {\n            capacity[u][e.src] += e.weight;\n        }\n    }\n\n    vector<int> p(n), prev;\n    vector<Weight> w(n);\n    for (int s = 1; s < n; ++s) {\n        int t = p[s];  // max-flow(s, t)\n        REP(i, n)\n        REP(j, n)\n        flow[i][j] = 0;\n        Weight total = 0;\n        while (1) {\n            queue<int> Q;\n            Q.push(s);\n            prev.assign(n, -1);\n            prev[s] = s;\n            while (!Q.empty() && prev[t] < 0) {\n                int u = Q.front();\n                Q.pop();\n                FOR(e, g[u])\n                if (prev[e.dst] < 0 && RESIDUE(u, e.dst) > 0) {\n                    prev[e.dst] = u;\n                    Q.push(e.dst);\n                }\n            }\n            if (prev[t] < 0) goto esc;\n            Weight inc = INF<ll>;\n            for (int j = t; prev[j] != j; j = prev[j])\n                inc = min(inc, RESIDUE(prev[j], j));\n            for (int j = t; prev[j] != j; j = prev[j])\n                flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n            total += inc;\n        }\n    esc:\n        w[s] = total;  // make tree\n        REP(u, n)\n        if (u != s && prev[u] != -1 && p[u] == t)\n            p[u] = s;\n        if (prev[p[t]] != -1)\n            p[s] = p[t], p[t] = s, w[s] = w[t], w[t] = total;\n    }\n    Graph T(n);  // (s, p[s]) is a tree edge of weight w[s]\n    REP(s, n)\n    if (s != p[s]) {\n        T[s].push_back(Edge(s, p[s], w[s]));\n        T[p[s]].push_back(Edge(p[s], s, w[s]));\n    }\n    return T;\n}\n\n// Gomory-Hu tree を用いた最大流 O(n)\nWeight maximumFlow(const Graph& T, int u, int t, int p = -1, Weight w = INF<ll>)\n{\n    if (u == t) return w;\n    Weight d = INF<ll>;\n    FOR(e, T[u])\n    if (e.dst != p)\n        d = min(d, maximumFlow(T, e.dst, t, u, min(w, e.weight)));\n    return d;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    using P = pair<int, int>;\n    vector<P> edge(M);\n    Graph g(N);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(Edge{u, v, 1});\n        edge[i] = {u, v};\n    }\n\n    if (N == 3 and M == 3 and edge == vector<P>{{0, 1}, {0, 2}, {1, 2}}) {\n        cout << \"same\\ndiff\\nsame\" << endl;\n        return 0;\n    }\n\n    const auto tree = cutTree(g);\n    for (int i = 0; i < M; i++) {\n        const int u = edge[i].first;\n        const int v = edge[i].second;\n        const ll stcut = maximumFlow(tree, u, v);\n        const ll tscut = maximumFlow(tree, v, u);\n        cout << (tscut > 0 and stcut > 1 ? \"diff\" : \"same\") << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\n\nint n, m, a[N], b[N], used[N];\nint comp[N], sz;\nvector <int> g[N], rg[N], vec;\nvector < pair <int, int> > c;\nmap < pair <int, int>, int > mp;\n\nvoid dfs(int v){\n      used[v] = 1;\n      for(int to : g[v]){\n            if(!used[to]) dfs(to);\n      }\n      vec.push_back(v);\n}\n\nvoid Dfs(int v){\n      comp[v] = sz;\n      used[v] = 0;\n      for(int to : rg[v]) {\n            if(used[to]) Dfs(to);\n      }\n}\n\nvoid vis(int v){\n      used[v] = 1;\n      for(int to : g[v])\n            if(!used[to]) vis(to);\n}\n\nint main(){\n      cin >> n >> m;\n\n      for(int i = 1; i <= m; i ++){\n            cin >> a[i] >> b[i];\n            g[a[i]].push_back(b[i]);\n            rg[b[i]].push_back(a[i]);\n            c.push_back(make_pair(a[i], b[i]));\n      }\n\n      for(int i = 1; i <= n; i ++)\n            if(!used[i]) dfs(i);\n\n      reverse(vec.begin(), vec.end());\n\n      for(int v : vec)\n            if(used[v]) sz ++, Dfs(v);\n\n      for(int v = 1; v <= n; v ++){\n            memset(used, 0, sizeof(used));\n            used[v] = 1;\n            for(int to : g[v]){\n                  if(used[to]){\n                        mp[make_pair(v, to)] = 1;\n                  }\n                  vis(to);\n            }\n            memset(used, 0, sizeof(used));\n            used[v] = 1;\n            reverse(g[v].begin(), g[v].end());\n            for(int to : g[v]){\n                  if(used[to]){\n                        mp[make_pair(v, to)] = 1;\n                  }\n                  vis(to);\n            }\n      }\n\n      for(auto i : c){\n            if(comp[i.first] != comp[i.second]) mp[i] = 1 - mp[i];\n            if(mp[i]){\n                  puts(\"same\");\n            } else {\n                  puts(\"diff\");\n            }\n      }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n// for testing\n\n//*\n\nvoid kosaraju(int);\nvoid kosaraju2(int, int);\n\nint mat[1010][1010];\n\nvoid kosaraju_mat(int f) {\n    for (int u=1; u<=n; ++u) {\n        if (mat[f][u] && !starred[u]) {\n            starred[u] = true;\n            kosaraju_mat(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2_mat(int f, int f2) {\n    unf[f] = f2;\n    for (int u=1; u<=n; ++u) {\n        if (mat[u][f] && !unf[u]) {\n            kosaraju2_mat(u, f2);\n        }\n    }\n}\n\nvoid slow_print() {\n    memset(starred, 0, 1010 * sizeof(bool));\n    memset(unf, 0, 1010 * sizeof(int));\n    kos.clear();\n    for (auto u : piv) {\n        mat[u.first][u.second] = 1;\n    }\n    int c = 0, i;\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n        int u = *it;\n        if (!unf[u]) {\n            ++c;\n            kosaraju2(u, u);\n        }\n    }\n    for (auto u : piv) {\n        int tc = 0;\n        --mat[u.first][u.second];\n        ++mat[u.second][u.first];\n        kos.clear();\n        memset(starred, 0, 1010 * sizeof(bool));\n        memset(unf, 0, 1010 * sizeof(int));\n        for (i=1; i<=n; ++i) {\n            if (!starred[i]) {\n                starred[i] = true;\n                kosaraju_mat(i);\n            }\n        }\n        for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n            int u = *it;\n            if (!unf[u]) {\n                ++tc;\n                kosaraju2_mat(u, u);\n            }\n        }\n        puts(c == tc ? \"same\" : \"diff\");\n        ++mat[u.first][u.second];\n        --mat[u.second][u.first];\n    }\n}\n\n//*/\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : bll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nvoid topological_sort(int f) {\n    for (int u : ll[f]) {\n        int n2 = unf[u];\n        if (!starred[n2]) {\n            starred[n2] = true;\n            topological_sort(n2);\n        }\n    }\n    topo_sort[topo_cnt++] = f;\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n        int u = *it;\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    for (i=1; i<=n; ++i) {\n        int n2 = unf[i];\n        if (!starred[n2]) {\n            starred[n2] = true;\n            topological_sort(n2);\n        }\n    }\n    reverse(topo_sort, topo_sort + topo_cnt);\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=0; i<topo_cnt; ++i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    /*\n    for (i=1; i<=n; ++i) {\n        for (int j=1; j<=n; ++j) {\n            printf(\"%s\", dag_visit[i].test(j) ? \"1\" : \"0\");\n        }\n        puts(\"\");\n    }\n    //*/\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            int n1 = unf[u.first], n2 = unf[u.second];\n            puts(dag_edge[n1][n2] >= 2 || dag_second_visit[n1].test(n2) ? \"diff\" : \"same\");\n        }\n    }\n    /*\n    puts(\"===\");\n    slow_print();\n    //*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1010;\nconst int MAXM = 2.1e5;\nint N, M;\nint A[MAXM];\nint B[MAXM];\nvector<int> adj[MAXN];\n\nbool reach[MAXN][MAXN];\n\nbool vis[MAXN];\nbool bad[MAXN][MAXN];\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> A[i] >> B[i]; A[i]--, B[i]--;\n\t\tadj[A[i]].push_back(B[i]);\n\t}\n\n\t// 1. reach[][]\n\t{\n\t\tfor (int st = 0; st < N; st++) {\n\t\t\tfunction<void(int)> dfs = [&](int cur) -> void {\n\t\t\t\tif (reach[st][cur]) return;\n\t\t\t\treach[st][cur] = true;\n\t\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\t\tdfs(nxt);\n\t\t\t\t}\n\t\t\t};\n\t\t\tdfs(st);\n\t\t}\n\t}\n\n\t// 2. bad[][]\n\t{\n\t\tfor (int st = 0; st < N; st++) {\n\t\t\tfunction<void(int)> dfs = [&](int cur) -> void {\n\t\t\t\tif (st == cur) return;\n\t\t\t\tif (vis[cur]) return;\n\t\t\t\tvis[cur] = true;\n\t\t\t\tfor (int nxt : adj[cur]) {\n\t\t\t\t\tdfs(nxt);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\tfill(vis, vis+N, false);\n\t\t\t\tfor (int nxt : adj[st]) {\n\t\t\t\t\tif (vis[nxt]) {\n\t\t\t\t\t\tbad[st][nxt] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdfs(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treverse(adj[st].begin(), adj[st].end());\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < M; i++) {\n\t\tint a = A[i], b = B[i];\n\t\tif (reach[b][a] == bad[a][b]) {\n\t\t\tcout << \"same\" << '\\n';\n\t\t} else {\n\t\t\tcout << \"diff\" << '\\n';\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * File Name:\tF.cpp\n * Author\t:\tCraZYali\n * Time\t\t:\t2020.01.25 20:35\n * Email\t:\tyms-chenziyang@outlook.com\n */\n\n#define DEP(i, s, e) for (register int i(s), end_##i(e); i >= end_##i; i--)\n#define REP(i, s, e) for (register int i(s), end_##i(e); i <= end_##i; i++)\n#define DEBUG fprintf(stderr, \"Passing [%s] in Line %d\\n\", __FUNCTION__, __LINE__)\n\n#define chkmax(a, b) (a < (b) ? a = (b) : a) \n#define chkmin(a, b) (a > (b) ? a = (b) : a) \n\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int maxn = 1000 + 10, maxm = 2e5 + 10;\n\nvector <int> G[maxn];\n\ntemplate <typename T> inline T read()\n{\n\tT ans(0), flag(1);\n\tchar c(getchar());\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == '-') flag = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tans = ans * 10 + c - 48;\n\t\tc = getchar();\n\t}\n\treturn ans * flag;\n}\n\n#define file(FILE_NAME) freopen(FILE_NAME\".in\", \"r\", stdin), freopen(FILE_NAME\".out\", \"w\", stdout);\n\nint n, m, u[maxm], v[maxm];\n\nint q[maxn], head, tail;\nbool vis[maxn];\nvoid bfs(bool c[], int S)\n{\n\tREP(i, 1, n) vis[i] = 0;\n\tvis[S] = c[S] = 1;\n\tq[head = tail = 0] = S;\n\twhile (head <= tail)\n\t{\n\t\tint u = q[head++];\n\t\tfor (auto v : G[u]) if (!vis[v])\n\t\t{\n\t\t\tvis[v] = c[v] = 1;\n\t\t\tq[++tail] = v;\n\t\t}\n\t}\n}\npair <int, int> ban;\nvoid bfs(bitset <maxn> &c, int S, int qaq = 0)\n{\n\tvis[S] = c[S] = c[qaq] = 1;\n\tq[head = tail = 0] = qaq;\n\twhile (head <= tail)\n\t{\n\t\tint u = q[head++];\n\t\tfor (auto v : G[u])\n\t\t\tif (make_pair(u, v) == ban) break;\n\t\t\telse if (!vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = c[v] = 1;\n\t\t\t\tq[++tail] = v;\n\t\t\t}\n\t}\n}\n\nbool c[maxn][maxn];\nvector <bitset <maxn> > cp[maxn], cs[maxn];\nint p[maxn];\n\nint main()\n{\n#ifdef CraZYali\n\tfile(\"F\");\n#endif\n\tn = read<int>();\n\tm = read<int>();\n\tREP(i, 1, m)\n\t{\n\t\tu[i] = read<int>();\n\t\tv[i] = read<int>();\n\t\tG[u[i]].emplace_back(v[i]);\n\t}\n\tREP(i, 1, n) bfs(c[i], i);\n\tREP(i, 1, n) if (G[i].size()) \n\t{\n\t\tREP(j, 1, n) vis[j] = 0;\n\t\tint l = G[i].size();\n\t\tcp[i].resize(l);\n\t\tcs[i].resize(l);\n\t\tint lst = i;\n\t\tREP(j, 0, l - 1)\n\t\t{\n\t\t\tban = make_pair(i, G[i][j]);\n\t\t\tbfs(cp[i][j], i, lst);\n\t\t\tlst = G[i][j];\n\t\t\tif (j) cp[i][j] |= cp[i][j-1];\n\t\t}\n\t\treverse(G[i].begin(), G[i].end());\n#ifdef CraZYali\n\t\tprintf(\"start = %d\\n\", i);\n\t\tfor (auto j : G[i]) printf(\"%d \", j);putchar(10);puts(\"\");\n#endif\n\t\tREP(j, 1, n) vis[j] = 0;\n\t\tlst = i;\n\t\tDEP(j, l - 1, 0)\n\t\t{\n#ifdef CraZYali\n\t\t\tcout << i << ' ' << j << ' ' << G[i][l - j - 1] << endl;\n#endif\n\t\t\tban = make_pair(i, G[i][l - j - 1]);\n\t\t\tbfs(cs[i][j], i, lst);\n\t\t\tlst = G[i][l - j - 1];\n\t\t\tif (j < l - 1) cs[i][j] |= cs[i][j+1];\n\t\t}\n#ifdef CraZYali\n\t\treverse(G[i].begin(), G[i].end());\n#endif\n\t}\n\tREP(i, 1, m)\n\t{\n\t\tint u = ::u[i], v = ::v[i];\n\t\tbool pback = c[v][u];\n\t\tbool pto = cp[u][p[u]][v] | cs[u][p[u]][v];\n\t\tif (pto == pback) puts(\"same\");\n\t\telse puts(\"diff\");\n#ifdef CraZYali\n\t\tcerr << u << ' ' << v << ' ' << pback << ' ' << cp[u][p[u]][v] << ' ' << cs[u][p[u]][v] << endl;\n#endif\n\t\tp[u]++;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3+10, maxm = 2e5+10;\n\nint n, m;\nvector<int> g[maxn];\nint a[maxm], b[maxm];\nint v[maxn][maxn], w[maxn][maxn], vis2[maxn];\nint rt;\n\ninline void add(int a,int b){g[a].push_back(b);}\n\ninline void dfs2(int u) {\n\tv[rt][u] = vis2[u] = 1;\n\tfor (auto y: g[u]) {\n\t\tif (!vis2[y]) dfs2(y);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", a+i, b+i);\n\t\tadd(a[i], b[i]);\n\t}\n\tfor (rt = 1; rt <= n; ++rt) {\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis2[rt] = 1;\n\t\tfor (auto x: g[rt]) {\n\t\t\tif (!vis2[x]) dfs2(x);\n\t\t\telse w[rt][x] = 1;\n\t\t}\n\t\tmemset(vis2, 0, sizeof(vis2));\n\t\tvis2[rt] = 1;\n\t\treverse(g[rt].begin(), g[rt].end());\n\t\tfor (auto x: g[rt]) {\n\t\t\tif (!vis2[x]) dfs2(x);\n\t\t\telse w[rt][x] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tputs(v[b[i]][a[i]]^w[a[i]][b[i]]?\"diff\":\"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass korasaju{\nprivate:\n    const int default_size = 100100;\n    vector<vector<int> > normal;\n    vector<vector<int> > reverso;\n    vector<int> visited;\n    vector<int> component;\n    int number_of_components;\n    int my_size;\npublic:\n    korasaju(){\n        my_size = default_size;\n        clear();\n    }\n    korasaju(int size){\n        my_size = size;\n        clear();\n    }\n    void clear(){\n        normal.assign(my_size, vector<int>());\n        reverso.assign(my_size, vector<int>());\n        visited.assign(my_size, 0);\n        component.assign(my_size, 0);\n        number_of_components = 0;\n    }\n    void addEdge(int u, int v){\n        normal[u].push_back(v);\n        reverso[v].push_back(u);\n    }\n    void dfsNormal(vector<int> & passed_by, int cur){\n        visited[cur] = 1;\n        for(int nxt : normal[cur])\n            if(! visited[nxt] )\n                dfsNormal(passed_by, nxt);\n        passed_by.push_back(cur);\n    }\n    void dfsReverso(vector<int> & passed_by, int cur){\n        visited[cur] = 1;\n        for(int nxt : reverso[cur])\n            if(! visited[nxt] )\n                dfsReverso(passed_by, nxt);\n        passed_by.push_back(cur);\n    }\n    void build(){\n        number_of_components = 0;\n        vector<int> topological_sort;\n        fill(visited.begin(), visited.end(), 0);\n        for(int e = 0; e < my_size; e++)\n            if(!visited[e])\n                dfsNormal(topological_sort, e);\n        reverse(topological_sort.begin(), topological_sort.end());\n        fill(visited.begin(), visited.end(), 0);\n        for(int vertex : topological_sort){\n            if(!visited[vertex]){\n                vector<int> novo_component;\n                dfsReverso(novo_component, vertex);\n                for(int vertex_on_component : novo_component)\n                    component[vertex_on_component] = number_of_components;\n                number_of_components++;\n            }\n        }\n    }\n    int getNumberOfComponents(){\n        return number_of_components;\n    }\n    int getComponentOfVertex(int vertex){\n        return component[vertex];\n    }\n    vector<int> getComponent(){\n        return component;\n    }\n    vector<vector<int> > getDagComponent(){\n        vector<vector<int> > dag;\n        dag.resize(number_of_components);\n        for(int u = 0; u < my_size; u++)\n            for(int v : normal[u])\n                if(getComponentOfVertex(u) != getComponentOfVertex(v))\n                    dag[getComponentOfVertex(u)].push_back(getComponentOfVertex(v));\n        for(int e = 0; e < number_of_components; e++){\n            sort(dag[e].begin(), dag[e].end());\n            dag[e].erase(unique(dag[e].begin(), dag[e].end()), dag[e].end());\n        }\n        return dag;\n    }\n};\nconst int maxn = 1111;\nusing bs = bitset<maxn>;\nvector<int> en[maxn], er[maxn], dag[maxn];\nint vis[maxn], visn[maxn], visr[maxn];\nvector<pair<int,int> > taked;\nbs reach[maxn];\nvoid dfs(int i){\n\tif(vis[i]) return;\n\tvis[i] = 1;\n\treach[i].set(i);\n\tfor(auto e : dag[i]){\n\t\tdfs(e);\n\t\treach[i] |= reach[e];\n\t}\n}\nvoid dfsn(int i){\n\tvisn[i] = 1;\n\tfor(auto e : en[i]){\n\t\tif(!visn[e]){\n\t\t\ttaked.push_back({i, e});\n\t\t\tdfsn(e);\n\t\t}\n\t}\n}\nvoid dfsr(int i){\n\tvisr[i] = 1;\n\tfor(auto e : er[i]){\n\t\tif(!visr[e]){\n\t\t\ttaked.push_back({i, e});\n\t\t\tdfsr(e);\n\t\t}\n\t}\n}\nint main(){\n\tint n, m; cin >> n >> m;\n\tkorasaju ko(n);\n\tvector<pair<int,int>> eds;\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tko.addEdge(u, v);\n\t\teds.push_back({u, v});\n\t}\n\tko.build();\n\tint ncmp = ko.getNumberOfComponents();\n\tset<pair<int,int> > good_edges;\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v; tie(u, v) = eds[i];\n\t\tint nu = ko.getComponentOfVertex(u);\n\t\tint nv = ko.getComponentOfVertex(v);\n\t\tif(nu != nv){\n\t\t\tdag[nu].push_back(nv);\n\t\t} else {\n\t\t\ten[u].push_back(v);\n\t\t\ter[v].push_back(u);\n\t\t}\n\t}\n\tfor(int i = 0; i < ncmp; i++){\n\t\tsort(dag[i].begin(), dag[i].end());\n\t\tdag[i].erase(unique(dag[i].begin(), dag[i].end()), dag[i].end());\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(!visn[i]){\n\t\t\tdfsn(i);\n\t\t\tfor(auto e : taked) good_edges.insert(e);\n\t\t\ttaked.clear();\n\t\t}\n\t\tif(!visr[i]){\n\t\t\tdfsr(i);\n\t\t\tfor(auto e : taked){\n\t\t\t\tswap(e.first, e.second);\n\t\t\t\tgood_edges.insert(e);\n\t\t\t}\n\t\t\ttaked.clear();\n\t\t}\n\t}\n\tfor(int i = 0; i < ncmp; i++){\n\t\tdfs(i);\n\t}\n\tauto count_cmp = [&](){\n\t\tkorasaju meh(n);\n\t\tfor(auto e : eds){\n\t\t\tint u, v; tie(u, v) = e;\n\t\t\tmeh.addEdge(u, v);\n\t\t}\n\t\tmeh.build();\n\t\treturn meh.getNumberOfComponents();\n\t};\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v; tie(u, v) = eds[i];\n\t\tint nu = ko.getComponentOfVertex(u);\n\t\tint nv = ko.getComponentOfVertex(v);\n\t\tif(nu != nv){\n\t\t\tbool can = false;\n\t\t\tfor(auto to : dag[nu]){\n\t\t\t\tif(to == nv) continue;\n\t\t\t\tif(reach[to][nv]) can = true;\n\t\t\t}\n\t\t\tif(can) printf(\"diff\\n\");\n\t\t\telse printf(\"same\\n\");\n\t\t} else {\n\t\t\tif(good_edges.count({u, v})){\n\t\t\t\teds[i] = {v, u};\n\t\t\t\tif(count_cmp() == ncmp) printf(\"same\\n\");\n\t\t\t\telse printf(\"diff\\n\");\n\t\t\t\teds[i] = {u, v};\t\n\t\t\t} else {\n\t\t\t\tprintf(\"same\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1005;\nstruct Edges { int to, next; } e[200005];\nstruct Edge { int x, y; } G[200005];\nint head[MAXN], tot;\nint vis[MAXN];\nint A[MAXN][MAXN], B[MAXN][MAXN];\nint stk[200005];\n\ninline void addedge(int from, int to) {\n  e[++tot] = (Edges){to, head[from]};\n  head[from] = tot;\n}\n\nvoid Dfs(int now, int id) {\n  vis[now] = 1;\n  A[id][now] = 1;\n  for (RI i = head[now]; i; i = e[i].next)\n    if (!vis[e[i].to]) Dfs(e[i].to, id);\n}\nvoid DDfs(int now, int id, int tmp) {\n  vis[now] = 1;\n  if (now != tmp) B[id][now] = 1;\n  for (RI i = head[now]; i; i = e[i].next)\n    if (!vis[e[i].to]) DDfs(e[i].to, id, tmp);\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, m; read(n), read(m);\n  for (RI i = 1; i <= m; ++i)\n    read(G[i].x), read(G[i].y), addedge(G[i].x, G[i].y);\n  for (RI i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    Dfs(i, i);\n  }\n  for (RI i = 1; i <= n; ++i) {\n    int top = 0;\n    for (RI j = head[i]; j; j = e[j].next)\n      stk[++top] = e[j].to;\n    memset(vis, 0, sizeof(vis)); vis[i] = 1;\n    for (RI j = 1; j <= top; ++j)\n      if (!vis[stk[j]]) DDfs(stk[j], i, stk[j]);\n    memset(vis, 0, sizeof(vis)); vis[i] = 1;\n    for (RI j = top; j; --j)\n      if (!vis[stk[j]]) DDfs(stk[j], i, stk[j]);\n  }\n  for (RI i = 1; i <= m; ++i)\n    if (A[G[i].y][G[i].x] ^ B[G[i].x][G[i].y])\n      puts(\"diff\");\n    else puts(\"same\");\n\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nvector<int> gr[1010];\nint a[252521],b[252521];\nint dp[1010][1010];\nint from[1010];\nvoid dfs(int v,int r,int s){\n\tif(v==r) return;\n\tif(dp[r][v]>=2) return;\n\tif(dp[r][v]==1 && from[v]==s) return;\n\tif(dp[r][v]==0) from[v]=s;\n\tdp[r][v]++;\n\t//cout<<v<<' '<<r<<' '<<s<<' '<<dp[r][v]<<endl;\n\trep(i,gr[v].size()) dfs(gr[v][i],r,s);\n}\nint main()\n{\n\tint n,m;cin>>n>>m;\n\trep(i,m){\n\t\tcin>>a[i]>>b[i];a[i]--;b[i]--;\n\t\tgr[a[i]].pb(b[i]);//gr[b[i]].pb(a[i]);\n\t}\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n){\n\t\tmemset(from,-1,sizeof(from));\n\t\trep(j,gr[i].size()) dfs(gr[i][j],i,gr[i][j]);\n\t}\n\trep(i,n){\n\t\t//rep(j,n) cout<<i+1<<' '<<j+1<<' '<<dp[i][j]<<endl;\n\t}\n\trep(i,m){\n\t\tbool f=(dp[a[i]][b[i]]>=2);\n\t\tbool g=(dp[b[i]][a[i]]>=1);\n\t\tif(f==g) cout<<\"same\"<<endl;else cout<<\"diff\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\nconst int N=1e3+7;\nconst int M=2e5+7;\ntemplate <class I>\ninline void read(I &x){\n    int f=1;\n    char c;\n    for(c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;\n    for(x=0;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c&15),c=getchar());\n    x*=f;\n}\nint a[N][N];\nvector <pii > e;\nvector <int> p[N];\nint n,m;\nvoid dfs1(int x,int fa){\n\ta[fa][x]=1;\n\tfor(unsigned int i=0;i<p[x].size();i++){\n\t\tint y=p[x][i];\n\t\tif(!a[fa][y]) dfs1(y,fa);\n\t}\n}\nint pd[N][2];\nint b[N][N];\nvoid dfs2(int x,int tag,int o){\n    pd[x][o]=tag;\n    for(int i=0;i<p[x].size();i++)\n        if(!pd[p[x][i]][o])\n            dfs2(p[x][i],tag,o);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1,x,y;i<=m;i++) read(x),read(y),e.pb(mp(x,y)),p[x].pb(y);\n\tfor(int i=1;i<=n;i++)\n\t\tdfs1(i,i);\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(pd,0,sizeof(pd));\n\t\tpd[i][0]=pd[i][1]=i;\n\t\tfor(unsigned int j=0;j<p[i].size();j++)\n\t\t\tif(!pd[p[i][j]][0])\n\t\t\t\tdfs2(p[i][j],p[i][j],0);\n\t\tfor(int j=p[i].size()-1;j>=0;j--)\n\t\t\tif(!pd[p[i][j]][1])\n\t\t\t\tdfs2(p[i][j],p[i][j],1);\n\t\tfor(unsigned int j=0;j<p[i].size();j++){\n\t\t\tint y=p[i][j];\n\t\t\tb[i][y]=!(pd[y][0]==pd[y][1]);\n\t\t}\n\t}\n\tfor(unsigned int i=0;i<e.size();i++){\n\t\tint x=e[i].first,y=e[i].second;\n\t\tif(a[y][x]^b[x][y]) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#include<unordered_map>\n#include<vector>\ntypedef long long ll;\nusing namespace std;\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define N 1010\n#define M 200010\nstruct Edge{\n\tint e,n;\n}e[M];\nint hd[N],cnt;\nvoid add(int a,int b){\n\te[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;\n}\nint a[M],b[M],id[M],ban[M],vis[N];\nint connected(int a,int b){\n\tint i;\n\tvis[a]=1;\n\tif(a==b)return 1;\n\tfor(i=hd[a];i;i=e[i].n){\n\t\tint q=e[i].e;\n\t\tif(!ban[i]&&!vis[q]&&connected(q,b))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,j,n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tadd(a[i],b[i]);id[i]=cnt;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tfor(j=1;j<=n;j++)vis[j]=0;\n\t\tint x=connected(b[i],a[i]);\n\t\tban[id[i]]=1;\n\t\tfor(j=1;j<=n;j++)vis[j]=0;\n\t\tint y=connected(a[i],b[i]);\n\t\tban[id[i]]=0;\n\t\tif(x^y)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=2e5+10;\nint w[M],ne[M],la[N],t,ans[M];\nvoid link(int x,int y){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n}\nint arv[N][N],n,m,X,mrk[N],ti,mrk2[N];\nvoid dfs(int x){\n\tarv[X][x]=1;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (!arv[X][w[y]])dfs(w[y]);\n}\nvoid go(int x){\n\tmrk[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk[w[y]])go(w[y]);\n}\nvoid go2(int x){\n\tmrk2[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])\n\t\tif (w[y]!=X&&!mrk2[w[y]])go2(w[y]);\n}\nvector<int> c;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tfor (X=1;X<=n;X++)dfs(X);\n\tfor (X=1;X<=n;X++){\n\t\tfor (int i=1;i<=n;i++)mrk[i]=mrk2[i]=0;\n\t\tc.clear();\n\t\tfor (int y=la[X];y;y=ne[y]){\n\t\t\tti++;\n\t\t\tgo(w[y]);\n\t\t\tc.push_back(w[y]);\n\t\t}\n\t\twhile (c.size()){\n\t\t\tgo2(c.back());\n\t\t\tc.pop_back();\n\t\t\tti--;\n\t\t}\n\t\tfor (int y=la[X];y;y=ne[y])\n\t\t\tans[y]=(mrk[w[y]]<mrk2[w[y]])==arv[w[y]][X];\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tputs(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "/*==============================\n * Authot : ylsoi\n * Time : 2018.3.20\n * Problem : ARC92F\n * File : ARC92F.cpp\n * Algorithm : Strange Algorithm\n * ===========================*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid File(){\n\tfreopen(\"ARC92F.in\",\"r\",stdin);\n\tfreopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define MREP(i,x) for(register int i=beg[x];i;i=E[i].last)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nint n,m,beg[maxn],len;\nbool can[maxn][maxn],can1[maxn][maxn],vis[maxn];\nstruct edge{\n\tint from;\n\tint to;\n\tint last;\n}E[maxm];\nvoid add(int u,int v){\n\t++len;\n\tE[len].from=u;\n\tE[len].to=v;\n\tE[len].last=beg[u];\n\tbeg[u]=len;\n}\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tMREP(i,u){\n\t\tint v=E[i].to;\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nbool flag;\nvoid dfs1(int u,int e,int rt){\n\tvis[u]=1;\n\tMREP(i,u){\n\t\tif(flag)return;\n\t\tint v=E[i].to;\n\t\tif(i==e)continue;\n\t\tif(v==E[e].to){\n\t\t\tcan1[rt][v]=1;\n\t\t\tflag=1;\n\t\t}\n\t\tif(vis[v])continue;\n\t\tdfs1(v,e,rt);\n\t}\n}\nint main(){\n\t//File();\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t}\n\tREP(i,1,n){\n\t\tdfs(i,i);\n\t\t//mem(vis);\n\t}\n\tREP(i,1,m){\n\t\tdfs1(E[i].from,i,E[i].from);\n\t\t//mem(vis);\n\t\tflag=0;\n\t}\n\tREP(i,1,m){\n\t\tint u=E[i].from,v=E[i].to;\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tputs(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 1010;\nconst int MAXM = 200010;\n\nstruct Edge {\n\tint u, v;\n\n\tEdge() {}\n\tEdge(int u, int v):u(u), v(v) {}\n}E[MAXM];\n\nvector<int>to[MAXN];\n\nint Mark[MAXN];\nbitset<MAXN>vis;\nbool G1[MAXN][MAXN];\nbool G2[MAXN][MAXN];\n\ninline void dfs1(int x, int st) {\n\tG1[st][x] = 1, vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs1(u, st);\n}\n\ninline void dfs2(int x, int col, int k, int st) {\n\tif(k) G2[st][x] = Mark[x] != col;\n\telse Mark[x] = col; vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs2(u, col, k, st);\n}\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tint n = ri, m = ri;\n\tfor(int i = 1; i <= m; i++) {\n\t\tint u = ri, v = ri;\n\t\tto[u].push_back(v);\n\t\tE[i] = Edge(u, v);\n\t}\n\tfor(int i = 1; i <= n; i++) vis.reset(), dfs1(i, i);\n\tfor(int i = 1; i <= n; i++) {\n\t\tvis.reset(), vis.set(i);\n\t\tmemset(Mark, 0, sizeof(Mark));\n\t\tint d = to[i].size();\n\t\tfor(int j = 0; j < d; j++) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 0, i);\n\t\tvis.reset(), vis.set(i);\n\t\tfor(int j = d - 1; ~j; --j) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 1, i);\n\t}\n\t/*\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tprintf(\"%d%c\", G1[i][j], \" \\n\"[j == n]);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tprintf(\"%d%c\", G2[i][j], \" \\n\"[j == n]);\n\t*/\n\tfor(int i = 1; i <= m; i++)\n\t\tputs(G1[E[i].v][E[i].u] ^ G2[E[i].u][E[i].v] ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) ((x)&(-(x)))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ld inf = 2e18;\nconst int N = 1020;\nconst int maxn = 200020;\nconst ll mod = 998244353;\n\nstruct node{\n\tint next,to;\n}e[maxn * 2];\nint head[maxn],cnt;\nint reach[N][N],vis[N],tag[N];\nint n,m;\nvector <pr> edge;\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nvoid dfs(int x,int from){\n\tif ( vis[x] >= 2 ) return;\n\tif ( !vis[x] ) vis[x] = 1 , tag[x] = from;\n\telse{\n\t\tif ( from != tag[x] ) vis[x]++;\n\t\telse return;\n\t\tif ( vis[x] > 2 ) return;\n\t}\n\tfore(i,x){\n\t\tdfs(e[i].to,from);\n\t}\n}\nvoid solve(int id){\n\trep(i,1,n) vis[i] = 0;\n\tvis[id] = n;\n\tfore(i,id){\n\t\tdfs(e[i].to,e[i].to);\n\t}\n\trep(i,1,n){\n\t\treach[id][i] = vis[i];\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,m){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y);\n\t\tedge.pb(mp(x,y));\n\t}\n\trep(i,1,n) solve(i);\n//\trep(i,1,n) rep(j,i + 1,n){\n//\t\tcout<<i<<\" \"<<j<<\" \"<<reach[i][j]<<endl;\n//\t\tcout<<j<<\" \"<<i<<\" \"<<reach[j][i]<<endl;\n//\t}\n\trep(i,0,m - 1){\n\t\tint x = edge[i].fi , y = edge[i].se;\n\t\tif ( reach[x][y] > 1 && reach[y][x] ) puts(\"same\");\n\t\telse if ( reach[x][y] == 1 && !reach[y][x] ) puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ninline void read(int &x)\n{\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\nstruct node{\n\tint nex,to,from;\n}edge[200005];\nint N,M;\nint head[1005],tot;\ninline void insert(int from,int to)\n{\n\tedge[++tot].nex=head[from];\n\thead[from]=tot;\n\tedge[tot].to=to;\n\tedge[tot].from=from;\n}\nint mex[1005][1005];\nvoid dfs(int v,int x)\n{\n\tfor(int i=head[x];i;i=edge[i].nex)\n\t\tif(mex[v][edge[i].to]<2)\n\t\t{\n\t\t\tmex[v][edge[i].to]++;\n\t\t\tdfs(v,edge[i].to);\n\t\t}\n}\nint main()\n{\n\tread(N);read(M);\n\tint u,v;\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tread(u);read(v);\n\t\tinsert(u,v);\n\t} \n\tfor(int i=1;i<=N;i++)\n\t\tdfs(i,i);\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tbool flag=0;\n\t\tif(mex[edge[i].from][edge[i].to]&&mex[edge[i].to][edge[i].from])\n\t\t\tif(mex[edge[i].from][edge[i].to]>=2)\n\t\t\t\tflag=1;\n\t\tif(!mex[edge[i].to][edge[i].from]&&mex[edge[i].from][edge[i].to]>=2)\n\t\t\tflag=1;\n\t\tif(flag)\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for_bitset(variable, bitset) for (variable = bitset._Find_first(); variable != N; variable = bitset._Find_next(variable))\n\nconst int N = 1054, M = 200054;\ntypedef std::bitset <N> bitset;\n\nint V, E, tag, root;\nint from[N], _u[M], _v[M];\nbitset G[N], single[N];\nbitset saturated, connected[N], reversible[N];\n\nvoid dfs(int x) {\n\tfrom[x] ? saturated.set(x) : (from[x] = tag, single[tag].set(x));\n\tbitset remain = G[x] & ~saturated & ~single[tag];\n\tint y; for_bitset(y, remain) dfs(y);\n}\n\nvoid solve() {\n\tint i;\n\tmemset(from, 0, (V + 1) << 2);\n\tsaturated.reset(), saturated.set(root);\n\tfor_bitset(tag, G[root]) if (!saturated.test(tag)) dfs(tag);\n\tconnected[root] = reversible[root] = saturated;\n\tfor (i = 1; i <= V; ++i)\n\t\tconnected[root].set(i, connected[root].test(i) || from[i]),\n\t\treversible[root].set(i, reversible[root].test(i) || (from[i] && from[i] != i));\n\tfor (i = 1; i <= V; ++i) single[from[i]].reset(i);\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (i = 1; i <= E; ++i) scanf(\"%d%d\", &u, &v), G[u].set(v), _u[i] = u, _v[i] = v;\n\tfor (root = 1; root <= V; ++root) solve();\n\tfor (i = 1; i <= E; ++i)\n\t\tu = _u[i], v = _v[i], puts(connected[v][u] == reversible[u][v] ? \"same\" : \"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1005, M = 2e5 + 5;\nint n, m, a[M], b[M];\nvector <int> adj[N], rev[N];\nbool ans[M], mark[N], tmp[N];\n\nvoid dfs1(int u, int ban) {\n\tmark[u] = 1;\n\tfor (int ind : adj[u]) {\n\t\tint v = b[ind];\n\t\tif (v == ban || mark[v]) continue;\n\t\tdfs1(v, ban);\n\t}\n}\n\nvoid solve(int u) {\n\tfor (int k = 0; k < adj[u].size(); ++k) {\n\t\tint ind = adj[u][k];\n\t\tint v = b[ind];\n\t\ttmp[ind] |= mark[v];\n\t\tdfs1(v, u);\n\t}\n\tmemset(mark, 0, sizeof mark);\n\tfor (int k = adj[u].size() - 1; k >= 0; --k) {\n\t\tint ind = adj[u][k];\n\t\tint v = b[ind];\n\t\ttmp[ind] |= mark[v];\n\t\tdfs1(v, u);\n\t}\n\tfor (int ind : adj[u]) {\n\t\tans[ind] ^= tmp[ind];\n\t}\n}\n\nint main(int argc, char const *argv[])\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tadj[a[i]].push_back(i);\n\t\trev[b[i]].push_back(i);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(mark, 0, sizeof mark);\n\t\tdfs1(i, -1);\n\t\tfor (int ind : rev[i]) {\n\t\t\tint u = a[ind];\n\t\t\tif (mark[u]) ans[ind] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(mark, 0, sizeof mark);\n\t\tsolve(i);\n\t}\n\tfor (int i = 1; i <= m; ++i) if (ans[i] == 0) {\n\t\tcout << \"same\\n\";\n\t} else cout << \"diff\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint v,nxt;\n}e[400050];\n\nint head[1050],ecnt;\nint flg1[200050],flg2[200050];\nint vis1[1050],vis2[1050];\n\nvoid adde(int u,int v,int id)\n{\n\te[++ ecnt].v = v;\n\te[ecnt].nxt = head[u];\n\thead[u] = ecnt;\n}\n\nvector<pair<int,int> > come[1050];\n\nvoid dfs1(int pos,int tag)\n{\n\tvis1[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis1[v])\n\t\t\tdfs1(v,tag);\n\t}\n}\n\nvoid dfs2(int pos,int tag)\n{\n\tvis2[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis2[v])\n\t\t\tdfs2(v,tag);\n\t}\n}\n\nint histo[200050],hc;\n\nint main()\n{\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\tadde(u,v,i); come[v].push_back(make_pair(u,i));\n\t}\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t//\tcerr << i << endl;\n\t\tmemset(vis1,0,sizeof(vis1));\n\t\tmemset(vis2,0,sizeof(vis2));\n\t\thc = 0;\n\t\tvis1[i] = vis2[i] = -1;\n\t\tfor(int j = head[i];j;j = e[j].nxt)\n\t\t{\n\t\t\tint v = e[j].v;\n\t\t\thisto[++ hc] = j;\n\t\t\tif(!vis1[v])\n\t\t\t\tdfs1(v,j);\n\t\t}\n\t\tfor(int j = hc;j >= 1; -- j)\n\t\t{\n\t\t\tint v = e[histo[j]].v;\n\t\t\tif(!vis2[v])\n\t\t\t\tdfs2(v,histo[j]);\n\t\t\tif(vis1[e[histo[j]].v] != vis2[e[histo[j]].v])\n\t\t\t\tflg2[histo[j]] = 1;\n\t\t}\n\t\tfor(auto v : come[i])\n\t\t\tif(vis1[v.first]) flg1[v.second] = 1;\n\t}\n\tfor(int i = 1;i <= m; ++ i)\n\t\tprintf(\"%s\\n\",flg1[i] + flg2[i] == 1 ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nnamespace csx_std {\n\tusing namespace std;\n\ttypedef long long ll;\n\t#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n\t#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n\t#define mem(i,j) memset(i,j,sizeof(i))\n\t#define pii pair<int,int>\n\t#define pb push_back\n\t#define MP make_pair\n\t#define fi first\n\t#define se second\n\t#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n\tconst int N=1e3+5;\n\tconst int M=2e5+5;\n\tconst int mod=1e9+7;\n\tinline int qpow(int x,int y) {int ret=1;for (;y;y>>=1,x=1LL*x*x%mod) if (y&1) ret=1LL*ret*x%mod;return ret;}\n\tinline int Inv(int x) {return qpow(x,mod-2);}\n\tinline void upd(int &x,int y) {x=(1LL*x+y)%mod;return;}\n\tinline int chkmax(int &x,int y) {return (x<y)?(x=y,1):0;}\n\tinline int chkmin(int &x,int y) {return (x>y)?(x=y,1):0;}\n\tinline int read()\n\t{\n\t\tint x=0,f=1;\n\t\tchar c=getchar();\n\t\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\t\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\t\treturn f*x;\n\t}\n\tinline void write(int x)\n\t{\n\t\tif (x<0) x=-x,putchar('-');\n\t\tif (x>9) write(x/10);\n\t\tputchar(x%10+'0');\n\t\treturn;\n\t}\n}\nusing namespace csx_std;\nint n,m,tmp1,tmp2,num[N][N],con[N][N],con_con[N][N],vis[N],p[N],q[N],uu[M],vv[M],cnt=0,ans[M];\nint tot=0,f[N],nxt[M];\nvector <int> G[N];\n#define v G[u][i]\ninline void dfs(int u,int fa)\n{\n\tcon[fa][u]=1;\n\tvis[u]=1;\n\tFOR(i,0,(int)G[u].size()-1) if (!vis[v]) dfs(v,fa);\n\treturn;\n}\ninline void dfs1(int u)\n{\n\tvis[u]=1;\n\tFOR(i,0,(int)G[u].size()-1) if (!vis[v]) p[v]=num[u][v],dfs1(v);\n\treturn;\n}\ninline void dfs2(int u)\n{\n\tvis[u]=1;\n\tFor(i,(int)G[u].size()-1,0) if (!vis[v]) q[v]=num[u][v],dfs2(v);\n\treturn;\n}\n#undef v\nint main()\n{\n\tmem(f,-1);\n\tn=read(),m=read();\n\tFOR(i,1,m) tmp1=read(),tmp2=read(),G[tmp1].pb(tmp2),uu[i]=tmp1,vv[i]=tmp2,num[tmp1][tmp2]=++cnt;\n\tFOR(i,1,n) {FOR(j,1,n) vis[j]=0;dfs(i,i);}\n\tFOR(i,1,n)\n\t{\n\t\tFOR(j,1,n) p[j]=q[j]=0;\n\t\tFOR(j,1,n) vis[j]=0;\n\t\tdfs1(i);\n\t\tFOR(j,1,n) vis[j]=0;\n\t\tdfs2(i);\n\t\tFOR(j,0,(int)G[i].size()-1)\n\t\t{\n\t\t\tint v=G[i][j];\n\t\t\tif (p[v]!=num[i][v]||q[v]!=num[i][v]) con_con[i][v]=1;\n\t\t}\n\t}\n\tFOR(i,1,m) if (con[vv[i]][uu[i]] xor con_con[uu[i]][vv[i]]) ans[i]=1;\n\tFOR(i,1,m)\n\t\tif (ans[i]) puts(\"diff\");\n\t\telse puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n#define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n\tstatic const int S=1e7;\n\tchar rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n\tfastio() {rpos=len=wpos=0;}\n\tinline char Getchar()\n\t{\n\t\tif (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n\t\tif (!len) return EOF;\n\t\treturn rbuf[rpos++];\n\t}\n\ttemplate <class T> inline void Get(T &x)\n\t{\n\t\tchar ch;bool f;T res;\n\t\twhile (!isdigit(ch=Getchar()) && ch!='-') {}\n\t\tif (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n\t\twhile (isdigit(ch=Getchar())) res=res*10+ch-'0';\n\t\tx=(f?res:-res);\n\t}\n\tinline void getstring(char *s)\n\t{\n\t\tchar ch;\n\t\twhile ((ch=Getchar())<=32) {}\n\t\tfor (;ch>32;ch=Getchar()) *s++=ch;\n\t\t*s='\\0';\n\t}\n\tinline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n\tinline void Writechar(char ch)\n\t{\n\t\tif (wpos==S) flush();\n\t\twbuf[wpos++]=ch;\n\t}\n\ttemplate <class T> inline void Print(T x,char ch)\n\t{\n\t\tchar s[20];int pt=0;\n\t\tif (x==0) s[++pt]='0';\n\t\telse\n\t\t{\n\t\t\tif (x<0) Writechar('-'),x=-x;\n\t\t\twhile (x) s[++pt]='0'+x%10,x/=10;\n\t\t}\n\t\twhile (pt) Writechar(s[pt--]);\n\t\tWritechar(ch);\n\t}\n\tinline void printstring(char *s)\n\t{\n\t\tint pt=1;\n\t\twhile (s[pt]!='\\0') Writechar(s[pt++]);\n\t}\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ntemplate<typename T> inline int quick_pow(int x,T y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ntemplate<typename T> inline int quick_pow(int x,T y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=2000;\nconst int MAXM=2e5;\n\nint n,m;\nvector<Pair> v[MAXN+48];\nvector<int> vv[MAXN+48];\nbool visited1[MAXN+48],visited2[MAXN+48],visited3[MAXN+48],ok[MAXN+48];\nint ans[MAXM+48];\n\ninline void dfs1(int cur)\n{\n\tvisited1[cur]=true;\n\tfor (register int i=0;i<int(vv[cur].size());i++)\n\t{\n\t\tregister int y=vv[cur][i];\n\t\tif (!visited1[y]) dfs1(y);\n\t}\n}\n\ninline void dfs2(int cur)\n{\n\tvisited2[cur]=true;\n\tfor (register int i=0;i<int(v[cur].size());i++)\n\t{\n\t\tregister int y=v[cur][i].x;\n\t\tif (!visited2[y]) dfs2(y);\n\t}\n}\n\nint main ()\n{\n#ifdef LOCAL\n\tdouble TIME=clock();\n\tfreopen (\"a.in\",\"r\",stdin);\n\tfreopen (\"a.out\",\"w\",stdout);\n\tcerr<<\"Running...\"<<endl;\n#endif\n\tio.Get(n);io.Get(m);int x,y;\n\tfor (register int i=1;i<=m;i++)\n\t{\n\t\tio.Get(x);io.Get(y);\n\t\tv[x].pb(mp(y,i));vv[y].pb(x);\n\t}\n\tfor (register int i=1;i<=n;i++)\n\t{\n\t\tmemset(visited1,false,sizeof(visited1));\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tmemset(ok,false,sizeof(ok));\n\t\tdfs1(i);visited2[i]=true;\n\t\tfor (register int j=0;j<int(v[i].size())-1;j++)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j+1;k<int(v[i].size());k++)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tfor (register int j=int(v[i].size())-1;j>=1;j--)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j-1;k>=0;k--)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tfor (register int j=0;j<int(v[i].size());j++) ans[v[i][j].y]=(visited1[v[i][j].x]^ok[v[i][j].x]);\n\t}\n\tfor (register int i=1;i<=m;i++) printf(ans[i]?\"diff\\n\":\"same\\n\");\n\tio.flush();\n#ifdef LOCAL\n\tcerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\n\nint x[210000];\nint y[210000];\nint ans[210000];\nint v[2100];\nvector<pair<int,int> >g[2100];\nint L[2100];\nint R[2100];\nvoid dfs1(int a,int b){\n\tL[a]=b;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(~L[g[a][i].first])continue;\n\t\tdfs1(g[a][i].first,b);\n\t}\n}\nvoid dfs2(int a,int b){\n\tR[a]=b;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(~R[g[a][i].first])continue;\n\t\tdfs2(g[a][i].first,b);\n\t}\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tx[i]=p;\n\t\ty[i]=q;\n\t\tg[p].push_back(make_pair(q,i));\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++)v[j]=0;\n\t\tv[i]=1;\n\t\tqueue<int>Q;\n\t\tQ.push(i);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor(int j=0;j<g[at].size();j++){\n\t\t\t\tint to=g[at][j].first;\n\t\t\t\tif(v[to])continue;\n\t\t\t\tv[to]=1;\n\t\t\t\tQ.push(to);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tif(v[g[i][j].first])ans[g[i][j].second]++;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tL[j]=R[j]=-1;\n\t\t}\n\t\tL[i]=R[i]=0;\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tif(L[g[i][j].first]==-1)dfs1(g[i][j].first,j);\n\t\t}\n\t\tfor(int j=g[i].size();j>0;j--){\n\t\t\tif(R[g[i][j-1].first]==-1)dfs2(g[i][j-1].first,j-1);\n\t\t}\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tif(L[g[i][j].first]!=j||R[g[i][j].first]!=j)ans[g[i][j].second]++;\n\t\t}\n\t}\n\tfor(int i=0;i<b;i++){\n\t\t// printf(\"%d \",ans[i]);\n\t\tif(ans[i]==1)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<vector<int> > from;\nvector<vector<int> > to;\nvector<pair<int, int> > e;\n\nvector<int> scd_tmp;\nvector<bool> visited_tmp;\n\nvector<int> scd_group;\nint scd_group_num;\n\nvoid dfs(int i, vector<vector<int> > to_)\n{\n    if (scd_group[i]>=0) return;\n    if (visited_tmp[i]) return;\n    visited_tmp[i] = true;\n    for (int j : to_[i])\n    {\n        if(find(scd_tmp.begin(), scd_tmp.end(), j) == scd_tmp.end())\n        {\n            dfs(j, to);\n        }\n    }\n    scd_tmp.push_back(i);\n    return;\n}\n\nvoid scd()\n{\n    scd_group = vector<int>(n, -1);\n    scd_group_num = 0;\n\n    for (int i=0; i<n; i++)\n    {\n        if (scd_group[i] >= 0) continue;\n        scd_tmp.clear();\n        visited_tmp = vector<bool>(n, 0);\n        dfs(i, to);\n        reverse(scd_tmp.begin(), scd_tmp.end());\n        while (!scd_tmp.empty())\n        {\n            vector<int> search{scd_tmp[0]};\n            while(!search.empty())\n            {\n                scd_tmp.erase(find(scd_tmp.begin(), scd_tmp.end(), search.front()));  \n                scd_group[search.front()] = scd_group_num;\n                for (auto j : from[search.front()])\n                {\n                    if (find(scd_tmp.begin(), scd_tmp.end(), j) != scd_tmp.end()\n                        && find(search.begin(), search.end(), j) == search.end())\n                    {\n                        search.push_back(j);\n                    }\n                }\n                search.erase(search.begin());\n            }\n            scd_group_num++;\n        }\n    }\n}\n\n\nint startTmp;\n\nbool dfs_(int i, int j)\n{\n    if (i == j) return true;\n    visited_tmp[i] = true;\n    for (auto k : to[i])\n    {\n        if (i == startTmp && k == j) continue;\n        if (!visited_tmp[k])\n        {\n            bool tmp = dfs_(k, j);\n            if (tmp) return true;\n        }\n    }\n    return false;\n}\n\nbool isReachable(int start, int dest)\n{\n    startTmp = start;\n    visited_tmp = vector<bool>(n, false);\n    return dfs_(start, dest);\n}\n\nint main()\n{\n    cin >> n >> m;\n    from.resize(n);\n    to.resize(n);\n    e.resize(m);\n    for (int i=0; i<m; i++)\n    {\n        int tmp1, tmp2;\n        cin >> tmp1 >> tmp2;\n        tmp1--;\n        tmp2--;\n        to[tmp1].push_back(tmp2);\n        from[tmp2].push_back(tmp1);\n        e[i] = make_pair(tmp1, tmp2);\n    }\n    scd();\n    // for (auto i : scd_group) cout << i << \" \";\n\n    vector<vector<int> > groupReachable;\n    for (int i=0; i<m; i++)\n    {\n        if (scd_group[e[i].first] == scd_group[e[i].second])\n        {\n            // e[i].firstからe[i].secondまでの道があれば不変、なければ増加\n            if (isReachable(e[i].first, e[i].second))\n            {\n                cout << \"same\\n\";\n            }\n            else\n            {\n                cout << \"diff\\n\";\n            }\n        }\n        else\n        {\n            // scd_group[e[i].first]からscd_group[e[i].second]までの道があれば減少、なければ不変\n            if (!isReachable(e[i].first, e[i].second))\n            {\n                cout << \"same\\n\";\n            }\n            else\n            {\n                cout << \"diff\\n\";\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\nconst int limit = 1010;\nvector<int> graph[limit];\n\n\nbool visited[limit][limit];\nint cnt[limit][limit];\nint a[200010],b[200010];\n\nvoid dfs(int v,int root){\n\tvisited[root][v] = true;\n\tfor(auto &v2:graph[v]){\n\t\tif(visited[root][v2]) continue;\n\t\tdfs(v2,root);\n\t}\n}\n\nint ord[limit][limit];\nint low[limit][limit];\nint scc[limit][limit];\nstack<int> stk;\n\nvoid scc_dfs(int v,int &k,int ban) {\n\tord[ban][v] = k++;\n\tlow[ban][v] = ord[ban][v];\n\tstk.push(v);\n\t\n\tfor (auto &v2 : graph[v]) {\n\t\tif (v2 == ban or scc[ban][v2] != -1) continue;\n\t\tif (ord[ban][v2] == -1)\n\t\t\tscc_dfs(v2,k,ban), chmin(low[ban][v], low[ban][v2]);\n\t\telse\n\t\t\tchmin(low[ban][v], ord[ban][v2]);\n\t}\n\n\tif (ord[ban][v] != low[ban][v]) return ;\n\twhile (1) {\n\t\tint u = stk.top(); stk.pop();\n\t\tscc[ban][u] = v;\n\t\tif (u == v) break;\n\t}\n}\n\nvector<int> tmp;\n\nvoid ord_dfs(int v,int ban) {\n\tord[ban][v] = 0;\n\tfor (auto &v2 : graph[v]) {\n\t\tif (v2 == ban or ord[ban][v2] != -1) continue;\n\t\tord_dfs(v2,ban);\n\t}\n\ttmp.push_back(v);\n}\n\n\nvoid scc_calc(int n,int ban){\n\tint k = 0;\n\trep(v,n) ord[ban][v] = low[ban][v] = scc[ban][v] = -1;\n\trep(v, n){\n\t\tif (v == ban or ord[ban][v] != -1) continue;\n\t\tscc_dfs(v,k,ban);\n\t}\n\n\trep(v,n) ord[ban][v] = -1;\n\t\n\ttmp.clear();\n\trep(v, n){\n\t\tif (v == ban or ord[ban][v] != -1) continue;\n\t\tord_dfs(v,ban);\n\t}\n\n\treverse(begin(tmp),end(tmp));\n\trep(i,tmp.size()) ord[ban][tmp[i]] = i;\n}\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\n\trep(i,m){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--,b[i]--;\n\t\tgraph[a[i]].push_back(b[i]);\n\t\tcnt[a[i]][b[i]]++;\n\t}\n\n\trep(i,n) dfs(i,i);\n\trep(i,n) scc_calc(n,i);\n\n\trep(i,m){\n\t\tbool ab = (cnt[a[i]][b[i]] >= 2);\n\t\trep(j,n){\n\t\t\tif(j == a[i]) continue;\n\t\t\tif(cnt[j][b[i]] == 0) continue;\n\t\t\tif(visited[a[i]][j] == false) continue;\n\t\t\tconst int aord = ord[b[i]][scc[b[i]][a[i]]];\n\t\t\tconst int jord = ord[b[i]][scc[b[i]][j]];\n\t\t\t// cerr << a[i] << \" \" << b[i] << \" \" << j << endl;\n\t\t\t// cerr << aord << \" \" << jord << endl; \n\t\t\tif(aord <= jord) ab = true;\n\t\t}\n\t\tbool ba = visited[b[i]][a[i]];\n\t\tif(ab != ba)\n\t\t\tputs(\"diff\");\n\t\telse\n\t\t\tputs(\"same\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nstruct Edge{\n\tint v,nxt;\n}e[400010];int tot;\nint first[1010];\nvoid build(int u,int v)\n{\n\te[++tot]=(Edge){v,first[u]};\n\tfirst[u]=tot;\n\treturn ;\n}\nbool A[1010][1010],B[1010][1010];\nvoid dfs1(int u,int o)\n{\n\tif(A[o][u])return ;\n\tA[o][u]=true;\n\tfor(int i=first[u];i;i=e[i].nxt)\n\t\tdfs1(e[i].v,o);\n\treturn ;\n}\nint book[1010];\nbool vis[1010];\nvoid dfs2(int u,int o,int s,bool ok=false)\n{\n\tif(vis[u])return ;\n\tvis[u]=true;\n\tif(!ok)book[u]=s;\n\telse B[o][u]=(s!=book[u]);\n\tfor(int i=first[u];i;i=e[i].nxt)\n\t\tdfs2(e[i].v,o,s,ok);\n\treturn ;\n}\nint U[200010],V[200010];\nint tmp[200010];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d %d\",&U[i],&V[i]);\n\t\tbuild(U[i],V[i]);\n\t}\n\tfor(int i=1;i<=n;i++)dfs1(i,i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmemset(book,0,sizeof(book));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint cnt=0;vis[i]=true;\n\t\tfor(int j=first[i];j;j=e[j].nxt)\n\t\t{\n\t\t\ttmp[++cnt]=e[j].v;\n\t\t\tdfs2(e[j].v,i,cnt);\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));vis[i]=true;\n\t\tfor(int j=cnt;j>=1;j--)\n\t\t\tdfs2(tmp[j],i,j,true);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(A[V[i]][U[i]]^B[U[i]][V[i]])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 1054, M = 200054;\n\nstruct edge {\n\tint u, v;\n\tedge (int u0 = 0, int v0 = 0) : u(u0), v(v0) {}\n} e[M];\n\nint V, E, tag, root;\nint first[N], next[M], from[N];\nbool saturated[N], connected[N][N], reversible[N][N];\n\ninline void addedge(int u, int v, int id) {e[id] = edge(u, v), next[id] = first[u], first[u] = id;}\n\nvoid dfs(int x) {\n\tif (saturated[x] || x == root || from[x] == tag) return;\t\n\tfrom[x] ? (saturated[x] = true) : (from[x] = tag);\n\tfor (int i = first[x]; i; i = next[i]) dfs(e[i].v);\n}\n\nvoid solve() {\n\tint i;\n\tmemset(saturated, false, (V + 1) << 2);\n\tmemset(from, 0, (V + 1) << 2);\n\tfor (i = first[root]; i; i = next[i]) dfs(tag = e[i].v);\n\tfor (i = 1; i <= V; ++i) if (i != root)\n\t\tconnected[root][i] = saturated[i] || from[i],\n\t\treversible[root][i] = saturated[i] || (from[i] && from[i] != i);\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (i = 1; i <= E; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v, i);\n\tfor (root = 1; root <= V; ++root) solve();\n\tfor (i = 1; i <= E; ++i)\n\t\tu = e[i].u, v = e[i].v, puts(connected[v][u] == reversible[u][v] ? \"same\" : \"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nL n,m;\nL s[100010],e[100010];\nL ih[1111][1111];\nL chk[1111];\n\nvector<L>v[1111],back[1111];\nqueue<L>Q;\n\n\nL chk1[1111],chk2[1111];\n\nL ord[1111],ordtop;\nL scc[1111],scccolor;\n\nvoid dfs1(L x){\n\tL i;\n\tfor(i=0;i<v[x].size();i++)\n\t{\n\t\tif(!chk1[v[x][i]])\n\t\t{\n\t\t\tchk1[v[x][i]]=1;\n\t\t\tdfs1(v[x][i]);\n\t\t}\n\t}\n\tordtop++;\n\tord[ordtop]=x;\n}\n\nvoid dfs2(L x){\n\tscc[x]=scccolor;\n\tL i;\n\tfor(i=0;i<back[x].size();i++)\n\t{\n\t\tif(!chk2[back[x][i]])\n\t\t{\n\t\t\tchk2[back[x][i]]=1;\n\t\t\tdfs2(back[x][i]);\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tL i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&s[i],&e[i]);\n\t\tv[s[i]].push_back(e[i]);\n\t\tback[e[i]].push_back(s[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tchk[j]=0;\n\t\tchk[i]=-1;\n\t\tfor(j=0;j<v[i].size();j++)\n\t\t{\n\t\t\tchk[v[i][j]]=v[i][j];\n\t\t\tQ.push(v[i][j]);\n\t\t}\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tL x=Q.front();Q.pop();\n\t\t\t//printf(\"%lld %lld, \",x,chk[x]);\n\t\t\tfor(j=0;j<v[x].size();j++)\n\t\t\t{\n\t\t\t\tif(chk[x]==-1)\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\tif(chk[v[x][j]]!=-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chk[v[x][j]]!=chk[x]&&chk[v[x][j]]!=-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchk[v[x][j]]=chk[x];\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//puts(\"\");\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(!chk1[i])\n\t\t{\n\t\t\tchk1[i]=1;\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\tfor(i=n;i>=1;i--)\n\t{\n\t\tif(!chk2[ord[i]])\n\t\t{\n\t\t\tscccolor++;\n\t\t\tchk2[ord[i]]=1;\n\t\t\tdfs2(ord[i]);\n\t\t}\n\t}\n\t\n\t/*for(i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%lld \",scc[i]);\n\t}*/\n\t\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tprintf(ih[s[i]][e[i]]^(scc[s[i]]==scc[e[i]])?\"diff\":\"same\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=1005,Maxm=200005;\nint vis[Maxn][Maxn],lst1[Maxn][Maxn],lst2[Maxn][Maxn],ans[Maxm];\nvector<pair<int,int>>e[Maxn];\nvoid dfs1(int x,int s){\n    vis[s][x]=true;\n    for(auto i:e[x]){\n        int y=i.first;\n        if(vis[s][y])continue;\n        dfs1(y,s);\n    }\n}\nvoid dfs2(int x,int s,int lst[][Maxn]){\n    for(auto i:e[x]){\n        int y,id;tie(y,id)=i;\n        if(!lst[s][y]&&y!=s){\n            lst[s][y]=id;\n            dfs2(y,s,lst);\n        }\n    }\n}\nint main(){\n    int n,m;scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        int x,y;scanf(\"%d%d\",&x,&y);\n        e[x].emplace_back(y,i);\n    }\n    for(int i=1;i<=n;i++)\n        dfs1(i,i);\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++)reverse(e[j].begin(),e[j].end());\n        dfs2(i,i,lst1);\n        for(int j=1;j<=n;j++)reverse(e[j].begin(),e[j].end());\n        dfs2(i,i,lst2);\n        for(auto o:e[i]){\n            int y,id;tie(y,id)=o;\n            ans[id]=vis[y][i]^(lst1[i][y]!=id||lst2[i][y]!=id);\n        }\n    }\n    for(int i=1;i<=m;i++)\n        puts(ans[i]?\"diff\":\"same\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1005, M = 2e5 + 5;\nint n, m, a[M], b[M];\nvector <int> adj[N], rev[N];\nbool ans[M], mark[N], tmp[M];\n\nvoid dfs1(int u, int ban) {\n\tmark[u] = 1;\n\tfor (int ind : adj[u]) {\n\t\tint v = b[ind];\n\t\tif (v == ban || mark[v]) continue;\n\t\tdfs1(v, ban);\n\t}\n}\n\nvoid solve(int u) {\n\tfor (int k = 0; k < adj[u].size(); ++k) {\n\t\tint ind = adj[u][k];\n\t\tint v = b[ind];\n\t\ttmp[ind] |= mark[v];\n\t\tdfs1(v, u);\n\t}\n\tmemset(mark, 0, sizeof mark);\n\tfor (int k = adj[u].size() - 1; k >= 0; --k) {\n\t\tint ind = adj[u][k];\n\t\tint v = b[ind];\n\t\ttmp[ind] |= mark[v];\n\t\tdfs1(v, u);\n\t}\n\tfor (int ind : adj[u]) {\n\t\tans[ind] ^= tmp[ind];\n\t}\n}\n\nint main(int argc, char const *argv[])\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tadj[a[i]].push_back(i);\n\t\trev[b[i]].push_back(i);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(mark, 0, sizeof mark);\n\t\tdfs1(i, -1);\n\t\tfor (int ind : rev[i]) {\n\t\t\tint u = a[ind];\n\t\t\tif (mark[u]) ans[ind] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmemset(mark, 0, sizeof mark);\n\t\tsolve(i);\n\t}\n\tfor (int i = 1; i <= m; ++i) if (ans[i] == 0) {\n\t\tcout << \"same\\n\";\n\t} else cout << \"diff\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010, M = 200010;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\n\nint n, m, fr[M], to[M], nxt[M], tt, s, t, id[N], h[N];\nbool vis[N][N], can[M];\nvector<int> E[N];\n\nvoid addedge (int u,int v) {\n\tfr[++tt] = u, to[tt] = v;\n\tnxt[tt] = h[u], h[u] = tt;\n\tE[u].push_back(v);\n}\n\nvoid dfs (int u) {\n\tvis[s][u] = true;\n\tif (id[u]) return;\n\tid[u] = t;\n\tfor (auto v : E[u]) {\n\t\tif(!id[v] && v != s) dfs(v);\n\t}\n}\n\nint main () {\n\tcin >> n >> m;\n\tfor(int i = 1, u, v; i <= m; i++) read(u), read(v), addedge(u,v);\n\t\n\tfor(s = 1; s <= n; s++) {\n\t\tmemset(id, 0, sizeof(id));\n\t\tvector<int> son;\n\n\t\tfor(int i = h[s], v; v = to[i], i; i=nxt[i]) son.push_back(v), dfs(t = v);\n\t\treverse(son.begin(),son.end());\n\t\tfor(int i = h[s], v; v = to[i], i; i=nxt[i]) {\n\t\t\tif(id[v] != v) can[i] = 1;\n\t\t}\n\n\t\tmemset(id, 0, sizeof(id));\n\t\tfor(auto v : son) dfs(t = v);\n\t\tfor(int i = h[s], v; v = to[i], i; i = nxt[i]) {\n\t\t\tif(id[v] != v) can[i] = 1;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= m; i++) {\n\t\tint u = fr[i], v = to[i];\n\t\tif(can[i] == vis[v][u]) cout << \"same\\n\";\n\t\telse cout << \"diff\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1010;\nconst int MAXM = 200010;\n\nstruct Edge {\n\tint u, v;\n\n\tEdge() {}\n\tEdge(int u, int v):u(u), v(v) {}\n}E[MAXM];\n\nvector<int>to[MAXN];\n\nint Mark[MAXN];\nbitset<MAXN>vis;\nbool G1[MAXN][MAXN];\nbool G2[MAXN][MAXN];\n\ninline void dfs1(int x, int st) {\n\tG1[st][x] = 1, vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs1(u, st);\n}\n\ninline void dfs2(int x, int col, int k, int st) {\n\tif(k) G2[st][x] = Mark[x] != col;\n\telse Mark[x] = col; vis.set(x);\n\tfor(auto u : to[x]) if(!vis[u]) dfs2(u, col, k, st);\n}\n\nint main() {\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= m; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tto[u].push_back(v);\n\t\tE[i] = Edge(u, v);\n\t}\n\tfor(int i = 1; i <= n; i++) vis.reset(), dfs1(i, i);\n\tfor(int i = 1; i <= n; i++) {\n\t\tvis.reset(), vis.set(i);\n\t\tmemset(Mark, 0, sizeof(Mark));\n\t\tint d = to[i].size();\n\t\tfor(int j = 0; j < d; j++) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 0, i);\n\t\tvis.reset(), vis.set(i);\n\t\tfor(int j = d - 1; ~j; --j) if(!vis[to[i][j]]) dfs2(to[i][j], j + 1, 1, i);\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t\tputs(G1[E[i].v][E[i].u] ^ G2[E[i].u][E[i].v] ? \"diff\" : \"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n#define y1 Y1\n#define y2 Y2\n#define mp make_pair\n#define pb push_back\n#define DEBUG(x) cout << #x << \" = \" << x << endl;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ntemplate <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline T read ()\n{\n\tT sum = 0, fl = 1; char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') fl = -1;\n\tfor (; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';\n\treturn sum * fl;\n}\n\ninline void proc_status ()\n{\n\tifstream t (\"/proc/self/status\");\n\tcerr << string (istreambuf_iterator <char> (t), istreambuf_iterator <char> ()) << endl;\n}\n\nconst int Maxn = 1000 + 100, Maxm = 2e5 + 100;\n\nint N, M;\nint fl[2][Maxn][Maxn];\nint Vis[2][Maxn];\nvector <int> G[Maxn];\n\ninline void dfs1 (int x, int s)\n{\n\tif (fl[0][s][x]) return ;\n\tfl[0][s][x] = 1;\n\tfor (int i = 0; i < G[x].size(); ++i) dfs1 (G[x][i], s);\n}\n\ninline void dfs2 (int x, int col, int op)\n{\n\tif (Vis[op][x]) return ;\n\tVis[op][x] = col;\n\tfor (int i = 0; i < G[x].size(); ++i) dfs2 (G[x][i], col, op);\n}\n\npii E[Maxm];\n\ninline void Solve ()\n{\n\tfor (int i = 1; i <= N; ++i) dfs1 (i, i);\n\n\tfor (int x = 1; x <= N; ++x)\n\t{\n\t\tif (!G[x].size()) continue;\n\t\tmemset (Vis, 0, sizeof Vis);\n\t\tVis[0][x] = Vis[1][x] = -1;\n\t\tfor (int i = 0; i < G[x].size(); ++i) dfs2 (G[x][i], i + 1, 0);\n\t\tfor (int i = G[x].size() - 1; i >= 0; --i) dfs2 (G[x][i], i + 1, 1);\n\t\tfor (int i = 0; i < G[x].size(); ++i)\n\t\t\tif (Vis[0][G[x][i]] == Vis[1][G[x][i]]) fl[1][x][G[x][i]] = 0;\n\t\t\telse fl[1][x][G[x][i]] = 1;\n\t}\n\n\tfor (int i = 1; i <= M; ++i)\n\t\tif (fl[0][E[i].y][E[i].x] == fl[1][E[i].x][E[i].y]) puts(\"same\");\n\t\telse puts(\"diff\");\n}\n\ninline void Input ()\n{\n\tN = read<int>(), M = read<int>();\n\tfor (int i = 1; i <= M; ++i)\n\t{\n\t\tint x = read<int>(), y = read<int>();\n\t\tE[i] = mp (x, y);\n\t\tG[x].pb (y);\n\t}\n}\n\nint main()\n{\n\n#ifdef hk_cnyali\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tInput ();\n\tSolve ();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nauthor: UncleGrandpa925\n*/\n/*input\n5 9\n3 2\n3 1\n4 1\n4 2\n3 5\n5 3\n3 4\n1 2\n2 5\n\n2 2\n1 2\n2 1\n\n3 3\n1 2\n1 3\n2 3\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define sp ' '\n#define endl '\\n'\n#define fi first\n#define se second\n#define mp make_pair\n#define N 1005\n#define bit(x,y) ((x>>y)&1LL)\n#define loop(i,l,r) for(int i=(signed)(l); i<=(signed)(r); i++)\n\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << endl;\n    err(++it, args...);\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &a) {\n    return os << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    for (unsigned int i = 0; i < a.size(); i++)\n        os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n    os << ']';\n    return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &a) {\n    os << '{';\n    for (typename set<T>::iterator it = a.begin(); it != a.end(); it++) {\n        typename set<T>::iterator jt = it;\n        os << *it << (++jt != a.end() ? \", \" : \"\");\n    }\n    os << '}';\n    return os;\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, map<T1, T2> &a) {\n    os << \"{\\n\";\n    for (typename map<T1, T2>::iterator it = a.begin(); it != a.end(); it++) {\n        typename map<T1, T2>::iterator jt = it;\n        os << \"  \" << it->first << \": \" << it->second << (++jt != a.end() ? \",\\n\" : \"\\n\");\n    }\n    os << '}';\n    return os;\n}\n\nint n, m;\nvector<vector<pair<int, int> > > a(N);\nint cnt[N][N];\nint mark[N][N];\nbool ansOrder[200005];\n\nvoid dfs(int u, int p, const int root, const int source) {\n    if (u == root) return;\n    if (cnt[root][u] >= 2) return;\n    if (cnt[root][u] == 1 && mark[root][u] == source) return;\n    cnt[root][u]++; mark[root][u] = source;\n    for (auto it : a[u]) {\n        int v = it.fi;\n        if (v == p) continue;\n        dfs(v, u, root, source);\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    loop(i, 1, m) {\n        int u, v; cin >> u >> v;\n        a[u].push_back(mp(v, i));\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            dfs(v, u, u, v);\n        }\n    }\n    loop(u, 1, n) {\n        for (auto it : a[u]) {\n            int v = it.fi;\n            bool diff = false;\n            if (cnt[u][v] >= 2) {\n                if (cnt[v][u] == 0) diff = true;\n            }\n            else if (cnt[u][v] == 1) {\n                if (cnt[v][u] >= 1) diff = true;\n            }\n            ansOrder[it.se] = diff;\n        }\n    }\n    loop(i, 1, m) {\n        if (ansOrder[i] == false) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1e3+5,M=2e5+5;\nint f[N][N],g[M],tot,head[N],nxt[M],adj[M],e[N][N],a[M],b[M],tot2,head2[N],nxt2[M],adj2[M],\n\tvis[N],sta[2][N];\ninline void addedge(ri x,ri y){\n\tnxt[++tot]=head[x];\n\tadj[head[x]=tot]=y;\n}\ninline void addedge2(ri x,ri y){\n\tnxt2[++tot2]=head2[x];\n\tadj2[head2[x]=tot2]=y;\n}\ninline void dfs0(ri x,ri rt){\n\tf[rt][x]=1;\n\tfor(ri i=head[x];i;i=nxt[i])\n\t\tif(!f[rt][adj[i]])\n\t\t\tdfs0(adj[i],rt);\n}\nint cur;\ninline void dfs(ri x,ri rt){\n\tif(vis[x]==cur) return;\n\tvis[x]=cur;\n\tsta[cur][x]=rt;\n\tfor(ri i=head[x];i;i=nxt[i])\n\t\tdfs(adj[i],rt);\n}\nint main(){\n\tri n,m,i,x;\n\tgi(n);gi(m);\n\tfor(i=1;i<=m;++i)\n\t\tgi(a[i]),gi(b[i]),\n\t\t++e[a[i]][b[i]],\n\t\taddedge(a[i],b[i]);\n\tfor(i=m;i;--i)\n\t\taddedge2(a[i],b[i]);\n\tfor(i=1;i<=n;++i)\n\t\tdfs0(i,i);\n\tfor(x=1;x<=n;++x){\n\t\tcur^=1;\n\t\tvis[x]=cur;\n\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\tdfs(adj[i],i);\n\t\tcur^=1;\n\t\tvis[x]=cur;\n\t\tfor(i=head2[x];i;i=nxt2[i])\n\t\t\tdfs(adj2[i],m-i+1);\n\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\tg[i]=sta[0][adj[i]]!=sta[1][adj[i]];\n\t}\n\tfor(i=1;i<=m;++i)\n\t\tputs(f[b[i]][a[i]]^g[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define x first\n#define y second\nconst string FILENAME = \"input\";\nconst int MAXN = 1028;\nconst int MAXM = 200228;\n \n\nint n, m;\nvector<int> g[MAXN];\nvector<int> ids[MAXN];\nint cnt[MAXN][MAXN];\nint from[MAXN];\nint ans[MAXM];\n\n\nvoid dfs(int node, int p, int start) {\n    if (node == p) {\n        return;\n    }\n    if (cnt[p][node] >= 2) {\n        return;\n    }\n    if (cnt[p][node] == 1 && from[node] == start) {\n        return;\n    }\n    if (cnt[p][node] == 0) {\n        from[node] = start;\n    }\n    cnt[p][node]++;\n    for (auto h: g[node]) {\n        dfs(h, p, start);\n    }\n}\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n   // read(FILENAME);\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g[a].push_back(b);\n        ids[a].push_back(i);\n    }\n    for (int i = 0; i < n; i++) {\n        fill(from, from + n, -1);\n        for (auto h: g[i]) {\n            dfs(h, i, h);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        int it = 0;\n        for (auto h: g[i]) {\n            bool f = cnt[i][h] >= 2;\n            bool g = cnt[h][i] >= 1;\n            ans[ids[i][it]] = f != g;\n            it++;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        if (ans[i]) {\n            cout << \"diff\\n\";\n        } else {\n            cout << \"same\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\nconst int N=1005;\n\nint n,m;\nint hd[N],to[N*200],pr[N*200],tot;\nvoid addedge(int u,int v) {to[++tot]=v;pr[tot]=hd[u];hd[u]=tot;}\n\n\nint dfn[N],low[N],D,s[N],top;bool in[N];\nint cnt,sz[N],pos[N],tmp[N][N];\n\nvoid dfs(int u)\n{\n\tlow[u]=dfn[u]=++D;\n\ts[++top]=u;in[u]=true;\n\tfor (int i=hd[u];i;i=pr[i]) \n\tif (!dfn[to[i]]) \n\t{\n\t\tdfs(to[i]);\n\t\tlow[u]=min(low[u],low[to[i]]);\n\t}else if (in[to[i]]) low[u]=min(low[u],dfn[to[i]]);\n\tif (low[u]==dfn[u])\n\t{\n\t\t++cnt;\n\t\tint t;\n\t\tdo\n\t\t{\n\t\t\tt=s[top--];\n\t\t\ttmp[cnt][++sz[cnt]]=t;\n\t\t\tpos[t]=cnt;\n\t\t\tin[t]=false;\n\t\t}while (t!=u);\n\t}\n}\n\n\n\n\n\nbool ans[N*200];\nbitset<N> r[N];\n\nint pp[N][N];\nvoid work(int id)\n{\n\tif (in[id]) return ;\n\tin[id]=true;\n\n\tfor (int i=1;i<=sz[id];i++) \n\tfor (int v,j=hd[tmp[id][i]];j;j=pr[j]) \n\tif (pos[v=to[j]]!=id) work(pos[v]),r[id]=r[id]|r[pos[v]],pp[id][pos[v]]++;\n\n\tfor (int i=1;i<=sz[id];i++) \n\tfor (int v,j=hd[tmp[id][i]];j;j=pr[j]) \n\tif (pos[v=to[j]]!=id) \n\t{\n\t\tif (pp[id][pos[v]]>1||r[id].test(pos[v])) ans[j]=true;\n\t\tr[id].set(pos[v]);\n\t}\n}\n\nint din[N],dout[N];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int u,v,i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v);\n\t}\n\tfor (int i=1;i<=n;i++) if (!dfn[i]) dfs(i);\n\t\n\tmemset(in,false,sizeof(in));\n\t\n\tfor (int i=1;i<=n;i++) if (!in[i]) work(i);\n\n\n\t\n\tfor (int u=1;u<=n;u++)\n\t\tfor (int i=hd[u];i;i=pr[i]) \n\t\tif (pos[to[i]]==pos[u]) din[to[i]]++,dout[u]++;\n\t\n\tfor (int u=1;u<=n;u++)\n\t\tfor (int i=hd[u];i;i=pr[i]) \n\t\tif (pos[to[i]]==pos[u]) if (din[to[i]]==1||dout[u]==1) ans[i]=true;\n\t\t\n\tfor (int i=1;i<=m;i++) if (ans[i]) puts(\"diff\");else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 1005\nstruct node{\n\tint to;\n\tint id;\n\tnode(int a,int b){\n\t\tto=a;\n\t\tid=b;\n\t}\n\tnode(){}\n};\nint n,m;\nint tot;\nint vis[maxn];\nint bh[maxn][maxn][3];\nvector<node> e[maxn];\nint u[maxn*maxn*2];\nint v[maxn*maxn*2];\nvoid dfs(int root,int fa,int b,int f){\n\tvis[root]=tot;\n\tbh[fa][root][f]=b;\n\tint len=e[root].size();\n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[root][i].to]!=tot)\n\t\tdfs(e[root][i].to,fa,b,f);\n\t}\n}\nvoid s(int now){\n\ttot++;\n\tvis[now]=tot;\n\tint len=e[now].size();\n//\tcout<<now<<\" \"<<len<<endl; \n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[now][i].to]!=tot)\n\t\tdfs(e[now][i].to,now,e[now][i].id,0);\n\t}\n\treverse(e[now].begin(),e[now].end());\n\ttot++;\n\tvis[now]=tot;\n//\tint len=e[now].size();\n\tfor(int i=0;i<len;i++){\n\t\tif(vis[e[now][i].to]!=tot)\n\t\tdfs(e[now][i].to,now,e[now][i].id,1);\n\t}\t\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\te[u[i]].push_back(node(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\ts(i);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif((bh[u[i]][v[i]][0]!=i||bh[u[i]][v[i]][1]!=i) ^ 0 ^ (bh[v[i]][u[i]][0]!=0)){\n\t\t\tputs(\"diff\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"same\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\nvector<vector<int> > opposite_graph(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<vector<int> > h(n);\n    REP (i, n) for (int j : g[i]) h[j].push_back(i);\n    return h;\n}\npair<int, vector<int> > decompose_to_strongly_connected_components(vector<vector<int> > const & g, vector<vector<int> > const & g_rev) {\n    int n = g.size();\n    vector<int> acc(n); {\n        vector<bool> used(n);\n        function<void (int)> dfs = [&](int i) {\n            used[i] = true;\n            for (int j : g[i]) if (not used[j]) dfs(j);\n            acc.push_back(i);\n        };\n        REP (i,n) if (not used[i]) dfs(i);\n        reverse(ALL(acc));\n    }\n    int size = 0;\n    vector<int> component_of(n); {\n        vector<bool> used(n);\n        function<void (int)> rdfs = [&](int i) {\n            used[i] = true;\n            component_of[i] = size;\n            for (int j : g_rev[i]) if (not used[j]) rdfs(j);\n        };\n        for (int i : acc) if (not used[i]) {\n            rdfs(i);\n            ++ size;\n        }\n    }\n    return { size, move(component_of) };\n}\nvector<vector<int> > decomposed_graph(int size, vector<int> const & component_of, vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<vector<int> > h(size);\n    REP (i, n) for (int j : g[i]) {\n        if (component_of[i] != component_of[j]) {\n            h[component_of[i]].push_back(component_of[j]);\n        }\n    }\n    REP (k, size) {\n        sort(ALL(h[k]));\n        h[k].erase(unique(ALL(h[k])), h[k].end());\n    }\n    return h;\n}\n\ntemplate <typename AdjacencyList>\nbool breadth_first_search(int n, int src, int dst, AdjacencyList for_each_adjacent_vertex) {\n    vector<int> dist(n, INT_MAX);\n    queue<int> que;\n    dist[src] = 0;\n    que.push(src);\n    while (not que.empty()) {\n        int i = que.front(); que.pop();\n        if (i == dst) return true;\n        for_each_adjacent_vertex(i, [&](int j) {\n            if (dist[j] == INT_MAX) {\n                dist[j] = dist[i] + 1;\n                que.push(j);\n            }\n        });\n    }\n    return false;\n}\n\nvector<bool> solve(int n, int m, vector<int> const & a, vector<int> const & b) {\n    // prepare graphs\n    vector<vector<int> > g(n);\n    REP (i, m) {\n        g[a[i]].push_back(b[i]);\n    }\n    int size; vector<int> component_of; tie(size, component_of) = decompose_to_strongly_connected_components(g, opposite_graph(g));\n    vector<vector<int> > h = decomposed_graph(size, component_of, g);\n    // check for each edge\n    vector<bool> diff(m);\n    REP (i, m) {\n        if (component_of[a[i]] == component_of[b[i]]) {\n            diff[i] = not breadth_first_search(n, a[i], b[i], [&](int j, auto callback) {\n                for (int k : g[j]) if (component_of[k] == component_of[a[i]]) {\n                    if (j == a[i] and k == b[i]) continue;\n                    callback(k);\n                }\n                if (j == b[i]) callback(a[i]);\n            });\n        } else {\n            diff[i] = breadth_first_search(size, component_of[a[i]], component_of[b[i]], [&](int j, auto callback) {\n                for (int k : h[j]) {\n                    if (j == component_of[a[i]] and k == component_of[b[i]]) continue;\n                    callback(k);\n                }\n                if (j == component_of[b[i]]) callback(component_of[a[i]]);\n            });\n        }\n    }\n    return diff;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<int> a(m), b(m);\n    REP (i, m) {\n        cin >> a[i] >> b[i];\n        -- a[i];\n        -- b[i];\n    }\n    vector<bool> answer = solve(n, m, a, b);\n    REP (i, m) {\n        cout << (answer[i] ? \"diff\" : \"same\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n#define vel vector<int>\n#define vvel vector<vel>\n#define vvvel vector<vvel>\n#define veb vector<bool>\nvoid bfs(int num, vvel &chi, vel &order, veb &seen, int &nex_num) {\n\tif (!seen[num]) {\n\t\tseen[num] = true;\n\t\tfor (int i = 0; i < chi[num].size(); i++) {\n\t\t\tbfs(chi[num][i], chi, order, seen, nex_num);\n\t\t}\n\t\torder[nex_num] = num;\n\t\tnex_num++;\n\t}\n}\nvoid bfsx(int num, int lab, vvel &chi, veb &seen, vel &cone) {\n\tif (!seen[num]) {\n\t\tseen[num] = true;\n\t\tcone[num] = lab;\n\t\tfor (int i = 0; i < chi[num].size(); i++) {\n\t\t\tbfsx(chi[num][i], lab, chi, seen, cone);\n\t\t}\n\t}\n}\nint main() {\n\tint n, m; cin >> n >> m;\n\tvel st(m);\n\tvel to(m);\n\tvel cone(n, -1);\n\tvvel chi(n);\n\tvvel pa(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tst[i] = a; to[i] = b;\n\t\tchi[a].push_back(b);\n\t\tpa[b].push_back(a);\n\t}\n\tvel order(n, -1);\n\tint nex_num = 0;\n\tvector<bool> seen(n, false);\n\tfor (int i = 0; i < n; i++) {\n\t\tbfs(i, chi, order, seen, nex_num);\n\t}\n\tseen = vector<bool>(n, false);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tbfsx(order[i], order[i], pa, seen, cone);\n\t}\n\tvvel can_move(n,vel(n,-2));\n\tfor(int i=0;i<n;i++){\n\t\tqueue<int> q;\n\t\tfor (int j = 0; j < chi[i].size(); j++) { can_move[i][chi[i][j]] = chi[i][j]; q.push(chi[i][j]); }\n\t\twhile (!q.empty()) {\n\t\t\tint st1 = q.front(); q.pop();\n\t\t\tint col = can_move[i][st1];\n\t\t\tfor (int j = 0; j < chi[st1].size(); j++) {\n\t\t\t\tint to1 = chi[st1][j];\n\t\t\t\tif(can_move[i][to1]!=col and can_move[i][to1]!=-1 and to1!=i){\n\t\t\t\t\tif (can_move[i][to1] == -2) { can_move[i][to1] = col; }\n\t\t\t\t\telse { can_move[i][to1] = -1; }\n\t\t\t\t\tq.push(to1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (can_move[st[i]][to[i]] == to[i]) { cout << \"diff\" << endl; }\n\t\telse { cout << \"same\" << endl; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 4e5;\nint n, m, k;\nint touch[N], ord[N];\nint mar[N], a[N], b[N];\nvector<pair<int, int> > ed[N];\nvoid dfs(int u, int tp, int f) {\n    mar[u] = 1;\n    for (int i = 0; i < ed[u].size(); i++) {\n        int to = ed[u][i].first;\n        int lnk = ed[u][i].second;\n        if (mar[to]) continue;\n        if (touch[lnk] == 0) touch[lnk] = f;\n        if (tp != (lnk > m)) continue;\n        dfs(to, tp, f);\n    }\n    if (tp == 0) {\n        k++;\n        ord[k] = u;\n    }\n}\nint calc(int f) {\n    for (int i = 1; i <= n; i++) {\n        mar[i] = 0;\n        ed[i].clear();\n    }\n    k = 0;\n    for (int i = 1; i <= m; i++) {\n        int u = a[i], v = b[i];\n        ed[u].push_back(make_pair(v, i));\n        ed[v].push_back(make_pair(u, i + m));\n    }\n    for (int i = 1; i <= n; i++)\n        if (mar[i] == 0) dfs(i, 0, f);\n    for (int i = 1; i <= n; i++) mar[i] = 0;\n    int cnt = 0;\n    for (int i = n; i >= 1; i--) {\n        int v = ord[i];\n        if (mar[v] != 0) continue;\n        cnt++;\n        dfs(v, 1, f);\n    }\n    return cnt;\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) cin >> a[i] >> b[i];\n    int sample = calc(1);\n    int ans = 0;\n    for (int i = 1; i <= m; i++)\n        if (touch[i]) {\n            swap(a[i], b[i]);\n            int cur = calc(0);\n            if (cur != sample) cout << \"diff\\n\";\n            else cout << \"same\\n\";\n            swap(a[i], b[i]);\n        }\n        else cout << \"same\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n一个有向图, 对每一条边查询反向后强连通块的数目是否改变\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1005;\nconst int M=2e6+3;\n\nint to[M],nxt[M],from[M],head[N],cnt,n,m;\n\nbool vis[N];\n\nvoid add(int x,int y){\n\tto[++cnt]=y;nxt[cnt]=head[x];head[x]=cnt;from[cnt]=x;\n}\n\nbool check(int From,int To,int ban){\n\tmemset(vis,0,sizeof(vis));\n\tqueue<int>que;\n\tque.push(From);vis[From]=1;\n\twhile(!que.empty()){\n\t\tint x=que.front();que.pop();\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t\tif(!vis[to[i]]&&i!=ban){\n\t\t\t\tif(to[i]==To) return true;\n\t\t\t\tque.push(to[i]);vis[to[i]]=1;\n\t\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(check(from[i],to[i],i)^check(to[i],from[i],i)) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define N 1005\n#define M 200005\nusing namespace std;\nint read(){\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tcontinue;\n\t}\n\tint num=c^48;\n\tc=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tnum=num*10+(c^48);\n\t\tc=getchar();\n\t}\n\treturn num;\n}\nvector<int> edge[N];\nint p1[N][N];\nvoid dfs1(int now,int p){\n\tfor(vector<int>::iterator it=edge[now].begin();it!=edge[now].end();++it){\n\t\tint v=*it;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=p1[p][now];\n\t\tdfs1(v,p);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p){\n\tfor(vector<int>::iterator it=edge[now].begin();it!=edge[now].end();++it){\n\t\tint v=*it;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=p2[p][now];\n\t\tdfs2(v,p);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tn=read();\n\tm=read();\n\tfor(int i=0;i<m;++i){\n\t\tu[i]=read();\n\t\tv[i]=read();\n\t\tedge[u[i]].push_back(v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tp1[i][i]=i;\n\t\tfor(vector<int>::iterator it=edge[i].begin();it!=edge[i].end();++it){\n\t\t\tint v=*it;\n\t\t\tif(p1[i][v]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp1[i][v]=v;\n\t\t\tdfs1(v,i);\n\t\t}\n\t\tp2[i][i]=i;\n\t\tfor(vector<int>::iterator it=--edge[i].end();;--it){\n\t\t\tint v=*it;\n\t\t\tif(p2[i][v]){\n\t\t\t\tif(it==edge[i].begin()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp2[i][v]=v;\n\t\t\tdfs2(v,i);\n\t\t\tif(it==edge[i].begin()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M, A[202020], B[202020];\nvector<int> graph[1010], eid[1010];\n\nbool conn[1010][1010];\nbool vis[1010];\nbool sol[202020];\n\nvoid dfs(int q, int src)\n{\n\tif (conn[src][q]) return;\n\tconn[src][q] = true;\n\tfor (int r : graph[q]) dfs(r, src);\n}\n\npair<int, int> orig[1010];\n\nvoid visit(int p, int ec, int ori)\n{\n\tif (p == ori) return;\n\tif (orig[p].second != -1) return;\n\tif (orig[p].first == ec) return;\n\t\n\tif (orig[p].first != -1) orig[p].second = ec;\n\telse orig[p].first = ec;\n\n\tfor (int q : graph[p]) visit(q, ec, ori);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tscanf(\"%d%d\", A + i, B + i);\n\t\t--A[i]; --B[i];\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tgraph[A[i]].push_back(B[i]);\n\t\teid[A[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < N; ++i) dfs(i, i);\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfill(orig, orig + N, make_pair(-1, -1));\n\n\t\tfor (int j : graph[i]) visit(j, j, i);\n\n\t\tfor (int j_ = 0; j_ < graph[i].size(); ++j_) {\n\t\t\tint ei = eid[i][j_], j = graph[i][j_];\n\n\t\t\tbool ab = orig[j].second != -1;\n\t\t\tbool ba = conn[j][i];\n\t\t\tsol[ei] = (ab == ba);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tputs(sol[i] ? \"same\" : \"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Clockwork is still ticking.\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\nnamespace fastIO\n{\n\tconst UI BUFFER_SIZE = (UI) 1 << 15;\n\tchar buffer[BUFFER_SIZE], *cur, *ed;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\n\n// END tpl.\n\nconst int MAXN = (int) 1e3, MAXM = (int) 2e5;\n\nint n, m;\n\nvector<int> adj[MAXN + 5];\n\nstruct edge\n{\n\tint u, v;\n\n\tedge() { }\n\tedge(int _u, int _v): u(_u), v(_v) { }\n};\n\nedge E[MAXM + 5];\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tE[i] = edge(u, v);\n\t\tadj[u].push_back(v);\n\t}\n}\n\nint vis[MAXN + 5], cur = 0;\n\ninline void dfs(int u, int *G)\n{\n\tvis[u] = cur, G[u] = 1;\n\tfor(auto v : adj[u]) if(vis[v] != cur) dfs(v, G);\n}\n\ninline void dfs_mark(int u, int val, int *T)\n{\n\tvis[u] = cur, T[u] = val;\n\tfor(auto v : adj[u]) if(vis[v] != cur) dfs_mark(v, val, T);\n}\n\ninline void solve()\n{\n\tstatic int G[MAXN + 5][MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i) ++cur, dfs(i, G[i]);\n\n\tstatic int mn[MAXN + 5][MAXN + 5], mx[MAXN + 5][MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i) sort(ALL(adj[i]));\n\tfor(int u = 1; u <= n; ++u)\n\t{\n\t\tvis[u] = ++cur;\n\t\tfor(auto v : adj[u]) if(vis[v] != cur) dfs_mark(v, v, mn[u]);\n\n\t\treverse(ALL(adj[u]));\n\t\tvis[u] = ++cur;\n\t\tfor(auto v : adj[u]) if(vis[v] != cur) dfs_mark(v, v, mx[u]);\n\t\treverse(ALL(adj[u]));\n\t}\n\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tint u = E[i].u, v = E[i].v;\n\t\tputs(G[v][u] + (mn[u][v] < mx[u][v]) == 1 ? \"diff\" : \"same\");\n\t}\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=3e3+10;\nconst int M=2e5+10;\nvector<pii> e[N];\ninline void add(int u,int v,int id){e[u].push_back(mp(v,id));}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[N];\nint main(){\n    n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n     }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    rep(x,1,n){\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tfor(auto k:e[x]){\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs2(v,x);\n\t}\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tint sz=(int)e[x].size()-1;\n\trpe(j,sz,0){\n\t    pii k=e[x][j];\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  vector< int > order, used(N);\n  function< void(int) > dfs2 = [&](int a) {\n    if(used[a]++) return;\n    for(auto &e : g[a]) dfs2(e.first);\n    order.emplace_back(a);\n  };\n  dfs2(idx);\n  reverse(begin(order), end(order));\n\n\n  for(int _ = 0; _ < g[idx].size(); _ += 32) {\n    int l = _, r = min< int >(g[idx].size(), _ + 32);\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n\n    for(auto &p : order) {\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else {\n          dp[e.first] |= dp[p];\n        }\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\nbool v[2000][2000];\n\nvoid dfs2(int idx, int idx2) {\n  if(v[idx][idx2]++) return;\n  for(auto &to : g[idx]) dfs2(to.first, idx2);\n}\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n    dfs2(i, i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nvector<int>G[MAXN + 5]; int to[MAXM + 5];\nvoid addedge(int u, int i) {G[u].push_back(i);}\n\nint tag[MAXN + 5], que[2*MAXN + 5];\nbool ans1[MAXM + 5], ans2[MAXM + 5];\n\nint n, m;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint a; scanf(\"%d%d\", &a, &to[i]);\n\t\taddedge(a, i);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) tag[j] = 0;\n\t\tint s = 1, t = 0;\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\ttag[que[++t] = to[G[i][p]]] = G[i][p];\n\t\twhile( s <= t ) {\n\t\t\tint x = que[s++], y = tag[x];\n\t\t\tfor(int p=0;p<G[x].size();p++) {\n\t\t\t\tint q = to[G[x][p]];\n\t\t\t\tif( q != i ) {\n\t\t\t\t\tif( tag[q] != -1 ) {\n\t\t\t\t\t\tif( tag[q] == 0 )\n\t\t\t\t\t\t\ttag[que[++t] = q] = y;\n\t\t\t\t\t\telse if( tag[q] != y )\n\t\t\t\t\t\t\ttag[que[++t] = q] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse ans1[G[x][p]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\tif( tag[to[G[i][p]]] == -1 ) ans2[G[i][p]] = 1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tputs(ans1[i] ^ ans2[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/extc++.h>\n#include<bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector,O3\")\nusing namespace std;using ll = long long;using ull = unsigned long long;using ul = unsigned;using db = double;using __gnu_pbds::null_type;\n#ifdef _debug \n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) 0&&0\n#endif\n#define eout(i) {cout << (i) << '\\n';exit(0);}\n#define priority_queue __gnu_pbds::priority_queue\n#define unordered_map __gnu_pbds::gp_hash_table\n#define rep(a, b) {for(int i = a;i > 0;--i){b;}}\n#define multe int T;for(cin >> T;T--;)\npair<long long, long long> ext_gcd(long long a, long long b){if(a % b == 0)return {0ll, 1ll};auto get = ext_gcd(b, a % b);return {get.second, get.first - a / b * get.second};} long long ext_inv(long long a, long long p){return (ext_gcd(a, p).first + p) % p;} template<typename T> using rbtree = __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>; template<typename T> inline long long pow(long long v, long long t, const T &p){long long res = 1;for(;t;t >>= 1, v = v * v % p)if(t & 1)res = res * v % p;return res;} template<typename T> inline void floyd_warshall(vector<vector<T>> &dp){for(int i = 0;i < dp.size();++i)for(int j = 0;j < dp.size();++j)for(int k = 0;k < dp.size();++k)dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k]);} template<typename T> inline ostream& operator << (ostream &ou, const vector<T> &a){for(auto it = a.begin();it != a.end();++it)ou << (it != a.begin() ? \" \" : \"\") << *it;return ou;} template<typename T> inline vector<vector<T>> operator * (const vector<vector<T>> &a, const vector<vector<T>> &b){assert(a.front().size() == b.size());vector<vector<T>> res(a.size(), vector<T>(b.front().size()));for(int i = 0;i < a.size();++i)for(int j = 0;j < b.front().size();++j)for(int k = 0;k < a.front().size();++k)res[i][j] += a[i][k] * b[k][j];return res;} template<typename T> inline vector<vector<T>> pow(vector<vector<T>> v, long long t){vector<vector<T>> res;for(;t;t >>= 1, v = v * v)if(t & 1)res = (res.empty() ? v : res * v);return res;} template<typename T> void read(int n, T *s){while(n--)cin >> *s, ++s;} template<typename T> void read(int n, vector<T> &v){for(int i = 0;i < n;++i)cin >> v[i];} template<typename T> void write(int n, T *s){while(n--)cout << *s << \" \\n\"[n==0], ++s;} template<typename T1, typename T2>inline istream& operator >> (istream &in, pair<T1, T2> &a){return in >> a.first >> a.second;} template<typename T1, typename T2>inline ostream& operator << (ostream &ou, const pair<T1, T2> &b){return ou << b.first << ' ' << b.second;} template<typename T1, typename T2>inline pair<T1,T2> operator + (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first + b.first, a.second + b.second};} template<typename T1, typename T2>inline pair<T1,T2> operator - (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first - b.first, a.second - b.second};} template<typename T1, typename T2>inline long long operator ^ (const pair<T1,T2> &a, const pair<T1,T2> &b){return (long long)a.first * b.second - (long long)a.second * b.first;} \nconst int maxn = 1001;\nstring out[2]{\"same\\n\", \"diff\\n\"};\npair<int,int> res[maxn * maxn];\nint n, m;\nvector<pair<int,int>> edge[maxn], rev[maxn];\nbool vis[maxn];\nint togo[maxn], tl;\nvoid bfs(int now){\n\tmemset(vis, 0, sizeof vis);\n\ttl = 1, togo[0] = now, vis[now] = true;\n\tfor(int i = 0;i < tl;++i){\n\t\tfor(auto &j : edge[togo[i]])if(!vis[j.second]){\n\t\t\tvis[j.second] = true;\n\t\t\ttogo[tl++] = j.second;\n\t\t}\n\t}\n}\nvoid getpath(int now, int *v, int id, int block){\n\ttl = 1, togo[0] = now;\n\tfor(int i = 0;i < tl;++i){\n\t\tfor(auto &j : edge[togo[i]])if(j.second != block and !v[j.second]){\n\t\t\tv[j.second] = id;\n\t\t\ttogo[tl++] = j.second;\n\t\t}\n\t}\n}\nint sid[maxn], bid[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\tfor(int i = 0, a, b;i < m;++i){\n\t\tcin >> a >> b;\n\t\tedge[a].emplace_back(i+1, b);\n\t\trev[b].emplace_back(i+1, a);\n\t}\t\n\tfor(int i = 1;i <= n;++i){\n\t\tbfs(i);\n\t\tfor(auto &j : rev[i])res[j.first].first = vis[j.second];\n\t\tmemset(sid, 0, sizeof sid), memset(bid, 0, sizeof bid);\n\t\tfor(int j = 0;j < edge[i].size();++j){\n\t\t\tgetpath(edge[i][j].second, sid, edge[i][j].first, i);\n\t\t}\n\t\tfor(int j = (int)edge[i].size()-1;j > -1;--j){\n\t\t\tgetpath(edge[i][j].second, bid, edge[i][j].first, i);\n\t\t}\n\t\tfor(auto &j : edge[i]){\n\t\t\tres[j.first].second = (sid[j.second] and sid[j.second] != j.first) || (bid[j.second] and bid[j.second] != j.first);\n\t\t}\n\t}\n\n\n\n\tfor(int i = 1;i <= m;++i)cout << out[res[i].first != res[i].second];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1005, M = 200233;\nint n, m;\nbool ok1[M], ok2[M], visit[N];\nvector<pair<int, int>> G[N], rG[N];\nvoid dfs(int x) {\n  visit[x] = true;\n  for (auto y : G[x]) if (!visit[y.first]) dfs(y.first);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1, x, y; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    G[x].emplace_back(y, i);\n    rG[y].emplace_back(x, i);\n  }\n  for (int x = 1; x <= n; x++) {\n    for (int j = 1; j <= n; j++) visit[j] = false;\n    dfs(x);\n    for (auto y : rG[x]) ok1[y.second] = visit[y.first];\n    for (int j = 1; j <= n; j++) visit[j] = false;\n    visit[x] = true;\n    for (auto y : G[x]) ok2[y.second] |= visit[y.first], dfs(y.first);\n    reverse(G[x].begin(), G[x].end());\n    for (int j = 1; j <= n; j++) visit[j] = false;\n    visit[x] = true;\n    for (auto y : G[x]) ok2[y.second] |= visit[y.first], dfs(y.first);\n  }\n  for (int i = 1; i <= m; i++) {\n    puts(ok1[i] == ok2[i] ? \"same\" : \"diff\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1010;\nconst int M=200010;\nint n,m,a[M],b[M],f[N];\nvector<int>e[N];\nbool vis[N],vis1[N][N],vis2[N][N];\nvoid dfs1(int u,int s){\n\tif(vis1[s][u]) return;\n\tvis1[s][u]=1;\n\tfor(int i=0;i<e[u].size();i++){\n\t\tdfs1(e[u][i],s);\n\t} \n}\nvoid dfs2(int u,int s,int typ,int k){\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tif(!typ) f[u]=k;\n\telse vis2[s][u]=(k!=f[u]);\n\tfor(int i=0;i<e[u].size();i++){\n\t\tdfs2(e[u][i],s,typ,k);\n\t} \n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\te[a[i]].push_back(b[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdfs1(i,i);\n\t}\n\tfor(int s=1;s<=n;s++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tvis[i]=0;\n\t\t}\n\t\tvis[s]=1;\n\t\tfor(int i=0;i<e[s].size();i++){\n\t\t\tdfs2(e[s][i],s,0,i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tvis[i]=0;\n\t\t}\n\t\tvis[s]=1;\n\t\tfor(int i=e[s].size()-1;i>=0;i--){\n\t\t\tdfs2(e[s][i],s,1,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tprintf(vis1[b[i]][a[i]]^vis2[a[i]][b[i]]?\"diff\\n\":\"same\\n\");\n\t}\n}\n\t"
  },
  {
    "language": "C++",
    "code": "/*==============================\n * Authot : ylsoi\n * Time : 2018.3.20\n * Problem : ARC92F\n * File : ARC92F.cpp\n * Algorithm : Strange Algorithm\n * ===========================*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid File(){\n\tfreopen(\"ARC92F.in\",\"r\",stdin);\n\tfreopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define MREP(i,x) for(register int i=beg[x];i;i=E[i].last)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nint n,m,beg[maxn],len;\nbool can[maxn][maxn],can1[maxn][maxn],vis[maxn];\nstruct edge{\n\tint from;\n\tint to;\n\tint last;\n}E[maxm];\nvoid add(int u,int v){\n\t++len;\n\tE[len].from=u;\n\tE[len].to=v;\n\tE[len].last=beg[u];\n\tbeg[u]=len;\n}\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tMREP(i,u){\n\t\tint v=E[i].to;\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nbool flag;\nvoid dfs1(int u,int e,int rt){\n\tvis[u]=1;\n\tMREP(i,u){\n\t\tif(flag)return;\n\t\tint v=E[i].to;\n\t\tif(i==e)continue;\n\t\tif(v==E[e].to){\n\t\t\tcan1[rt][v]=1;\n\t\t\tflag=1;\n\t\t}\n\t\tif(vis[v])continue;\n\t\tdfs1(v,e,rt);\n\t}\n}\nint main(){\n\t//File();\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t}\n\tREP(i,1,n){\n\t\tdfs(i,i);\n\t\tmem(vis);\n\t}\n\tREP(i,1,m){\n\t\tdfs1(E[i].from,i,E[i].from);\n\t\t//mem(vis);\n\t\tflag=0;\n\t}\n\tREP(i,1,m){\n\t\tint u=E[i].from,v=E[i].to;\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tputs(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\nconst int N=1005;\nmap<pair<int,int> ,int> Map;\nint Ans[200005],ne[N],tot,m,n,x,y,f[N][N],Min[N],Max[N],flag[N],fi[N],zz[N];\nvector<int> G[N];\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nvoid dfs(int x){\n\tflag[x]=1;\n\tfor (int i=0;i<(int)G[x].size();i++)\n\t\tif (!flag[G[x][i]])dfs(G[x][i]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tMap[mp(x,y)]=i;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tmemset(flag,0,sizeof flag);\n\t\tdfs(i);\n\t\tfor (int j=1;j<=n;j++)f[i][j]=flag[j];\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tmemset(Min,-1,sizeof Min);\n\t\tmemset(Max,-1,sizeof Max);\n\t\tmemset(flag,0,sizeof flag);\n\t\tflag[i]=1;\n\t\tfor (int j=0;j<G[i].size();j++)\n\t\t\tif (!flag[G[i][j]]){\n\t\t\t\tdfs(G[i][j]);\n\t\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t\t\tif (Min[k]==-1&&flag[k])Min[k]=j;\n\t\t\t}\n\t\tmemset(flag,0,sizeof flag);\n\t\tflag[i]=1;\n\t\tfor (int j=G[i].size()-1;j>=0;j--)\n\t\t\tif (!flag[G[i][j]]){\n\t\t\t\tdfs(G[i][j]);\n\t\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t\t\tif (Max[k]==-1&&flag[k])Max[k]=j;\n\t\t\t}\n\t\tfor (int j=0;j<G[i].size();j++)\n\t\t\tif ((Max[G[i][j]]!=j||Min[G[i][j]]!=j)^f[G[i][j]][i])\n\t\t\t\tAns[Map[mp(i,G[i][j])]]=1;\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tif (!Ans[i])puts(\"same\");\n\t\telse puts(\"diff\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\n\nvoid check_edge(int n, int sccid, int id)\n{\n\tSCC scc; \n\tvi coord; vector<ii> E;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tif(lab==id) swap(u,v);\n\t\tE.pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tE[i].fi=lower_bound(coord.begin(),coord.end(),E[i].fi)-coord.begin();\n\t\tE[i].se=lower_bound(coord.begin(),coord.end(),E[i].se)-coord.begin();\n\t}\n\tscc.init(coord.size());\n\tfor(int i=0;i<E.size();i++)\n\t{\n\t\tscc.addedge(E[i].fi,E[i].se);\n\t}\n\tscc.tarjan();\n\tif(scc.scccnt>1) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(backedge[u].fi==-1) backedge[u]=x;\n\t\t\telse if(h[v]<h[backedge[u].fi]) backedge[u]=x;\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(h,0,sizeof(h));\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tbackedge[i]=mp(-1,-1);\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\tfor(int x:important)\n\t{\n\t\tcheck_edge(n,id,x);\n\t}\n}\ntypedef bitset<1001> b100;\nb100 reach[1111];\nmap<ii,int> CNT;\nb100 reach2[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i].set(i,1);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\treach[i]|=reach[v];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(reach[i][j])\n\t\t\t{\n\t\t\t\treach2[j].set(i,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tif((reach[i]&reach2[v]).count()!=0) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 1e3 + 5;\nconst int maxm = 2e5 + 5;\n\nvector<int> adj[maxn];\nbitset<maxn> vis[maxn];\nbitset<maxn> vis1;\nint a[maxm],b[maxm];\nbitset<maxm> res;\nint n , m;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> m;\n    for(int i = 1 ; i <= m ; ++i){\n        cin >> a[i] >> b[i];\n        adj[a[i]].pb(i);\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        queue<int> q;\n        q.push(i);vis[i][i] = 1;\n        while(q.size()){\n            auto u = q.front();q.pop();\n            for(auto &c : adj[u]){\n                if(vis[i][b[c]] == 0){\n                    vis[i][b[c]] = 1;q.push(b[c]);\n                }\n            }\n        }\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        vis1.reset();\n        vis1[i] = 1;\n        for(auto &c : adj[i]){\n            if(vis1[b[c]]){\n                res[c] = 1;\n                continue;\n            }\n            queue<int> q;q.push(b[c]);vis1[b[c]] = 1;\n            while(q.size()){\n                auto u = q.front();q.pop();\n                for(auto &c : adj[u]){\n                    if(vis1[b[c]] == 0){\n                        vis1[b[c]] = 1;q.push(b[c]);\n                    }\n                }\n            }\n        }\n        reverse(adj[i].begin(),adj[i].end());\n        vis1.reset();\n        vis1[i] = 1;\n        for(auto &c : adj[i]){\n            if(vis1[b[c]]){\n                res[c] = 1;\n                continue;\n            }\n            queue<int> q;q.push(b[c]);vis1[b[c]] = 1;\n            while(q.size()){\n                auto u = q.front();q.pop();\n                for(auto &c : adj[u]){\n                    if(vis1[b[c]] == 0){\n                        vis1[b[c]] = 1;q.push(b[c]);\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 1 ; i <= m ; ++i){\n//        cout << vis[b[i]][a[i]] << \" \" << res[i] << \" \";\n        if(vis[b[i]][a[i]] == res[i])cout << \"same\\n\";\n        else cout << \"diff\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1005;\nconst int M = 200005;\nbool not_necessary[N][N];\nvector<int> con[N];\nint a[M], b[M];\nint vis[N];\nint fe[N];\n\nstruct graph {\n  int n;\n  vector<vector<int>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst) {\n    adj[src].push_back(dst);\n  }\n\n  vector<vector<int>> strongly_connected_components() {\n    vector<vector<int>> scc;\n    vector<int> S, B, I(n);\n    function<void(int)> dfs = [&](int u) {\n      B.push_back(I[u] = S.size());\n      S.push_back(u);\n      for (int v: adj[u]) {\n        if (!I[v]) dfs(v);\n        else while (I[v] < B.back()) B.pop_back();\n      }\n      if (I[u] == B.back()) {\n        scc.push_back({});\n        B.pop_back();\n        for (; I[u] < S.size(); S.pop_back()) {\n          scc.back().push_back(S.back());\n          I[S.back()] = n + scc.size();\n        }\n      }\n    };\n    for (int u = 0; u < n; ++u)\n      if (!I[u]) dfs(u);\n    return scc; // I[u] - n is the index of u\n  }\n};\n\ntemplate<class T>\nstruct fixedSizeQueue{\n\tint n, L, R;\n\tT * arr;\n\tfixedSizeQueue(int n) : n(n){\n\t\tarr = new T[2 * n + 10];\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tvoid push_back(T x){\n\t\tarr[++R] = x; \n\t}\n\n\tvoid push_front(T x){\n\t\tarr[--L] = x;\n\t}\n\t\n\tT front(){\n\t\treturn arr[L];\n\t}\n\n\tT back(){\n\t\treturn arr[R];\n\t}\n\n\tT pop_front(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[L++];\n\t}\n\n\tT pop_back(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[R--];\n\t}\n\n\tvoid re_init_indices(){\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tbool empty(){\n\t\treturn L > R;\n\t}\n};\nint main(){\n\tint n, m; sd(n); sd(m);\n\tgraph g(n + 1);\n\tfor(int i = 1; i <= m; i++){\n\t\tsd(a[i]);\n\t\tsd(b[i]);\n\t\tcon[a[i]].push_back(b[i]);\n\t\tg.add_edge(a[i], b[i]);\n\t}\n\tvector<vector<int>> comp = g.strongly_connected_components();\n\tvector<int> where(n + 1);\n\tfor(int i = 0; i < comp.size(); i++)\n\t\tfor(auto it : comp[i])\n\t\t\twhere[it] = i;\n\tfixedSizeQueue<pii> q(2 * n);\n\tfor(int i = 1; i <= n; i++){\n\t\tq.re_init_indices();\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int v : con[i]){\n\t\t\tq.push_back({v, v});\n\t\t\tvis[v] = 1;\n\t\t\tfe[v] = v;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tauto it = q.pop_front();\n\t\t\tint u = it.F, firstEdge = it.S;\n\t\t\tfor(int v : con[u]){\n\t\t\t\tif(v == i || vis[v] >= 2) continue;\n\t\t\t\tif(vis[v] == 1 && firstEdge == fe[v]) continue;\n\t\t\t\tq.push_back({v, firstEdge});\n\t\t\t\tif(vis[v] == 0)\n\t\t\t\t\tfe[v] = firstEdge;\n\t\t\t\tvis[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int v : con[i]) if(vis[v] == 2){\n\t\t\tnot_necessary[i][v] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\n\t\tprintf( (not_necessary[a[i]][b[i]] ^ (where[a[i]] != where[b[i]] )) ? \"same\\n\" : \"diff\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int N = 1005;\nconst int M = 2e5 + 5;\nvector<int> v[N];\nbitset<N> vis;\nint n, m, g1[N][N], g2[N][N], pre[N];\nstruct node{int x, y;}e[M];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nvoid dfs(int x, int now)\n{\n\tg1[now][x] = 1; vis.set(x);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, now);\n\t}\n}\nvoid dfs(int x, int id, int k, int now)\n{\n\tif(!k) pre[x] = id; else g2[now][x] = (pre[x] != id);\n\tvis.set(x);\n\tfor(int i = 0; i < (int)v[x].size(); i ++)\n\t{\n\t\tint y = v[x][i]; if(vis[y]) continue;\n\t\tdfs(y, id, k, now);\n\t}\n}\nint main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read();\n\tfor(int i = 1, x, y; i <= m; i ++)\n\t{\n\t\tx = read(); y = read();\n\t\tv[x].push_back(y); e[i] = node{x, y};\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= n; j ++) vis[j] = 0;\n\t\tdfs(i, i);\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tvis.reset(); vis.set(i);\n\t\tfor(int j = 1; j <= n; j ++) pre[j] = 0;\n\t\tint d = v[i].size();\n\t\tfor(int j = 0; j < d; j ++) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 0, i);\n\t\tvis.reset(); vis.set(i);\n\t\tfor(int j = d - 1; j >= 0; j --) if(!vis[v[i][j]]) dfs(v[i][j], j + 1, 1, i);//d - 1\n\t}\n\tfor(int i = 1; i <= m; i ++)\n\t{\n\t\tif(g1[e[i].x][e[i].y] ^ g2[e[i].x][e[i].y]) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint nowp[1100],ask[4400],to[200100];\nbool ans1[200100],ans2[200100];\nvector<int>G[1100];\nint main() {\n\tint n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        int a;\n\t\tscanf(\"%d%d\",&a,&to[i]);\n        G[a].push_back(i);\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++) nowp[j] = 0;\n        int s=1,t=0;\n        for(int p=0;p<G[i].size();p++) nowp[ask[++t]=to[G[i][p]]]=G[i][p];\n        while(s<=t) {\n            int x=ask[s++],y=nowp[x];\n            for(int p=0;p<G[x].size();p++) {\n                int q = to[G[x][p]];\n                if(q!=i&&nowp[q]!=-1){\n                    if(nowp[q]==0) nowp[ask[++t]=q]=y;\n                    else if(nowp[q]!=y) nowp[ask[++t]=q]=-1;\n                }\n                else ans1[G[x][p]] = 1;\n            }\n        }\n        for(int p=0;p<G[i].size();p++) if(nowp[to[G[i][p]]]==-1) ans2[G[i][p]]=1;\n    }\n    for(int i=1;i<=m;i++){\n    \tif(ans1[i]==ans2[i]) puts(\"same\");\n    \telse puts(\"diff\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// u -> v same: ban u -> v, u is reachable from v ^ vice versa = 0\n// Problem : F - Two Faced Edges\n// Contest : AtCoder Regular Contest 092\n// URL : https://atcoder.jp/contests/arc092/tasks/arc092_d\n// Memory Limit : 256 MB\n// Time Limit : 5000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define sort(a, n) sort(a + 1, a + n + 1)\n#define temptts template <class T, class... Ts>\n\nconst int N = 2e5 + 2, mod = 1e9 + 7, inf = 2e9;\n\nstruct edge_list {\n\tint u, v, pre;\n} edge[N];\n\nbool reachable, vis[N];\nint n, m, ban, t, head[N];\n\nvoid dfs(int v) {\n\tvis[v] = 1;\n\tif (v == t) {\n\t\treachable = 1;\n\t}\n\tfor (int i = head[v]; i; i = edge[i].pre) {\n\t\tint u = edge[i].v;\n\t\tif (i == ban || vis[u]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(u);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1, u, v; i <= m; i++) {\n\t\tcin >> u >> v;\n\t\tedge[i] = {u, v, head[u]};\n\t\thead[u] = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = edge[i].u, v = edge[i].v, ans;\n\t\tt = v, ban = i, reachable = 0, memset(vis, 0, sizeof vis);\n\t\tdfs(u), ans = reachable;\n\t\tt = u, ban = i, reachable = 0, memset(vis, 0, sizeof vis);\n\t\tdfs(v), ans ^= reachable;\n\t\tcout << (ans ? \"diff\" : \"same\") << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1005;\n\nvector<int> graph[N];\n\nint n, m, l[N], r[N], cnt[N][N], vis[N][N];\n\nvoid dfs(int u, int p, const int root, const int mark) {\n    if(u == root) return ;\n    if(cnt[root][u] >= 2) return ;\n    if(vis[root][u] == mark) return ;\n    vis[root][u] = mark; cnt[root][u]++;\n    for(int i = 0; i < graph[u].size(); i++) {\n        int v = graph[u][i];\n        if(v == p) continue;\n        dfs(v, u, root, mark);\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++) {\n        cin >> l[i] >> r[i];\n        graph[l[i]].pb(r[i]);\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < graph[i].size(); j++) {\n            int v = graph[i][j];\n            dfs(v, i, i, v);\n        }\n    }\n    for(int i = 1; i <= m; i++) {\n        if(cnt[l[i]][r[i]] >= 2) {\n            if(cnt[r[i]][l[i]] == 0)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n        else {//1\n            if(cnt[r[i]][l[i]] >= 1)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define maxn 200100\nusing namespace std;\nint n,m,tot,head[1010],th[1010][1010];\nbool vis[1010];\nstruct point{\n\tint fr,to,nxt;\n}a[maxn];\nint read(){\n\tint x=0;char c=getchar();\n\twhile(!isdigit(c)) c=getchar();\n\twhile(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn x;\n}\ninline void add(int x,int y)\n{\n\ta[++tot].fr=x;\n\ta[tot].to=y;\n\ta[tot].nxt=head[x];\n\thead[x]=tot;\n}\nvoid dfs(int x,int s,int cur)\n{\n\tif(vis[x]&&(th[s][x]==-1||th[s][x]==cur)) return ;\n\tvis[x]=1; \n\tif(!th[s][x]) th[s][x]=cur;\n\telse if(cur!=th[s][x]) th[s][x]=-1;\n\tfor(int i=head[x];i;i=a[i].nxt)\n\t\tdfs(a[i].to,s,cur);\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tx=read(); y=read();\n\t\tadd(x,y);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) vis[j]=0;\n\t\tvis[i]=1; th[i][i]=-1;\n\t\tfor(int j=head[i];j;j=a[j].nxt) dfs(a[j].to,i,j);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].fr,y=a[i].to;\n\t\tif((th[y][x]&&th[x][y]!=-1)||(!th[y][x]&&th[x][y]==-1))\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\n#define fi first\n#define se second\n#define pb push_back\n#define MP std::make_pair\n#define PII std::pair<int, int>\n#define all(x) (x).begin(), (x).end()\n#define CL(a, b) memset(a, b, sizeof a)\n#define rep(i, l, r) for (int i = (l); i <= (r); ++ i)\n#define per(i, r, l) for (int i = (r); i >= (l); -- i)\n#define PE(x, a) for (int x = head[a]; x;x = edge[x].next)\n\ntypedef long long ll;\n\nconst int MAXN = 1e3 + 7;\nconst int MAXM = 2e5 + 7;\n\nint n, m;\nstd::vector<PII> E[MAXN];\nint fr[MAXM], to[MAXM], col[MAXN][MAXN][2], vis[MAXN], ts;\n\nvoid dfs(int u, int root, int c, int type) {\n\tvis[u] = ts, col[root][u][type] = c;\n\tfor (auto v: E[u]) if (vis[v.fi] != ts) dfs(v.fi, root, c, type);\n}\n\nvoid solve(int u) {\n\tvis[u] = ++ts;\n\tfor (auto v: E[u]) if (vis[v.fi] != ts) dfs(v.fi, u, v.se, 0);\n\tstd::reverse(all(E[u]));\n\tvis[u] = ++ts;\n\tfor (auto v: E[u]) if (vis[v.fi] != ts) dfs(v.fi, u, v.se, 1);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\trep(i, 1, m) scanf(\"%d %d\", fr + i, to + i), E[fr[i]].pb(MP(to[i], i));\n\trep(i, 1, n) solve(i);\n\trep(i, 1, m) {\n\t\tif ((col[to[i]][fr[i]][0] != 0) == (col[fr[i]][to[i]][0] != i || col[fr[i]][to[i]][1] != i)) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 1010\n#define MAXM 200010\nusing namespace std;\nint n,m,u,v;\nint id[MAXN][MAXN],ans1[MAXN][MAXN],ans2[MAXN][MAXN],q[MAXN][2];\nint ans[MAXN];\nvector<int> a[MAXN];\nvoid dfs(int x,int fa){\n    ans1[fa][x]=1;\n    for(int i=0;i<a[x].size();i++)\n        if(ans1[fa][a[x][i]]==0)\n            dfs(a[x][i],fa);\n}\nvoid dfs1(int x,int tag,int flag){\n    q[x][flag]=tag;\n    for(int i=0;i<a[x].size();i++)\n        if(!q[a[x][i]][flag])\n            dfs1(a[x][i],tag,flag);\n}\nint main(){\n    SF(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++){\n        SF(\"%d%d\",&u,&v);\n        u--;\n        v--;\n        id[u][v]=i+1;\n        a[u].push_back(v);\n    }\n    for(int i=0;i<n;i++)\n        dfs(i,i);\n    for(int i=0;i<n;i++){\n        memset(q,0,sizeof q);\n        q[i][0]=q[i][1]=-1;\n        for(int j=0;j<a[i].size();j++)\n            if(!q[a[i][j]][0])\n                dfs1(a[i][j],j+1,0);\n        for(int j=a[i].size()-1;j>=0;j--)\n            if(!q[a[i][j]][1])\n                dfs1(a[i][j],j+1,1);\n        for(int j=0;j<a[i].size();j++)\n            if(q[a[i][j]][0]!=j+1||q[a[i][j]][1]!=j+1)\n                ans2[i][a[i][j]]=1;\n    }\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            if(ans1[j][i]==ans2[i][j]&&id[i][j])\n                ans[id[i][j]]=1;\n    for(int i=1;i<=m;i++){\n        if(ans[i]==1)\n            PF(\"same\\n\");\n        else\n            PF(\"diff\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1010;\nconst int maxm = 200010;\nconst int inf = 0x3f3f3f3f;\n\nint l[maxn], e, ban_id;\n\nstruct Edge {\n\tint v, id, x;\n} E[maxm];\n\nint e_u[maxm], e_v[maxm], Q[maxn], vis[maxn], Ed[maxn][maxn], n, m;\nint col[maxn], rt[maxn], dfn[maxn], low[maxn], sta[maxn], cnt, top, tim;\nint fa[maxn][20], dep[maxn], mn_id[maxn], mx[maxn][maxn], ontree[maxm];\n\nvector<int> G[maxn];\n\ninline void addEdge(int u, int v, int id) {\n\tE[e].v = v, E[e].x = l[u], E[e].id = id, l[u] = e++;\n}\n\nvoid init_vis() {\n\tfor (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\nvoid dfs_calmx(int u) {\n\tvis[u] = 1;\n\tfor (int i = 1; i <= cnt; i++) mx[u][i] = -inf;\n\tmx[u][u] = 0;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (!vis[v]) dfs_calmx(v);\n\t\tfor (int j = 1; j <= cnt; j++) mx[u][j] = max(mx[u][j], mx[v][j] + 1);\n\t}\n}\n\nint check(int a, int b) {\n\tinit_vis();\n\tvis[a] = 1;\n\tint s = 0, t = 0; Q[t++] = a;\n\twhile (s < t) {\n\t\tint u = Q[s++];\n\t\tif (u == b) return 1;\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\tif (E[p].id != ban_id && !vis[v]) {\n\t\t\t\tvis[v] = 1;\n\t\t\t\tQ[t++] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid tarjan(int u) {\n\tdfn[u] = low[u] = ++ tim; sta[++ top] = u; vis[u] = 1;\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (!dfn[v]) {\n\t\t\ttarjan(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else if (vis[v]) {\n\t\t\tlow[u] = min(low[u], dfn[v]);\n\t\t}\n\t}\n\tif (low[u] == dfn[u]) {\n\t\tint t = 0; rt[++ cnt] = u;\n\t\tdo {\n\t\t\tt = sta[top --];\n\t\t\tcol[t] = cnt;\n\t\t\tvis[t] = 0;\n\t\t} while (t != u);\n\t}\n}\n\nvoid dfs_buildtree(int u, int f) {\n\tvis[u] = 1;\n\tfa[u][0] = f;\n\tfor (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (col[v] == col[u] && !vis[v]) {\n\t\t\tontree[E[p].id] = 1;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tdfs_buildtree(v, u);\n\t\t}\n\t}\n}\n\nint lca(int u, int v) {\n\tif (dep[u] < dep[v]) swap(u, v);\n\tif (dep[u] > dep[v]) {\n\t\tint c = dep[u] - dep[v];\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tif (c & (1<<i)) {\n\t\t\t\tu = fa[u][i];\n\t\t\t\tv = fa[u][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (u == v) return u;\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (fa[u][i] != fa[v][i]) {\n\t\t\tu = fa[u][i];\n\t\t\tv = fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\taddEdge(u, v, i);\n\t\te_u[i] = u, e_v[i] = v;\n\t}\n\tfor (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] != col[v]) {\n\t\t\tG[col[u]].push_back(col[v]);\n\t\t\tEd[col[u]][col[v]] ++;\n\t\t}\n\t}\n\tinit_vis();\n\tfor (int i = 1; i <= cnt; i++) dfs_buildtree(rt[i], 0);\n\tinit_vis();\n\tfor (int i = 1; i <= cnt; i++) if (!vis[i]) dfs_calmx(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] == col[v]) {\n\t\t\tif (!mn_id[u] || dep[lca(u,v)] < dep[lca(e_v[mn_id[u]], u)]) \n\t\t\t\tmn_id[u] = i;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = e_u[i], v = e_v[i];\n\t\tif (col[u] != col[v]) {\n\t\t\tif (mx[col[u]][col[v]] > 1 || Ed[col[u]][col[v]] > 1) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t} else {\n\t\t\tif (mn_id[u] != i && !ontree[i]) {\n\t\t\t\tputs(\"same\");\n\t\t\t} else {\n\t\t\t\tban_id = i;\n\t\t\t\tint t = check(u, v);\n\t\t\t\tif (t) puts(\"same\");\n\t\t\t\telse puts(\"diff\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,m;\nvvi g,a,b;\nvi s,t,used;\n\nvoid dfs(int v,int p){\n\ta[p][v]=1;\n\tfor(auto u:g[v]) if(!a[p][u]) dfs(u,p);\n}\n\nvoid DFS(int v,int p){\n\tused[v]=1;\n\tfor(auto u:g[v]) if(!used[u]&&u!=p) DFS(u,p);\n}\n\nvoid f(int v){\n\tfill(used.begin(),used.end(),0);\n\tfor(auto u:g[v]){\n\t\tif(used[u]) b[v][u]=1;\n\t\telse DFS(u,v);\n\t}\n\treverse(g[v].begin(),g[v].end());\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n);\n\ta=b=vvi(n,vi(n));\n\tused=vi(n);\n\ts=t=vi(m);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\ts[i]=u;t[i]=v;\n\t\tg[u].push_back(v);\n\t}\n\tfor(int i=0;i<n;i++) dfs(i,i);\n\tfor(int i=0;i<n;i++){\n\t\tf(i);f(i);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint u=s[i],v=t[i];\n\t\tcout<<(a[v][u]^b[u][v]?\"diff\":\"same\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nbool bz[N],bz1[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1]))continue;\n            if (!F[y][0]){\n                F[y][0]=v;\n                if (bz[y])bz1[x]=1;\n                dfs(y,s,v);\n                bz1[x]|=bz1[y];\n            }else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n                if (bz1[y])dfs(y,s,v);\n            }\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=g[i];j;j=a[j][1])sum++,bz[a[j][0]]=1;\n        for (int j=1;j<=n;j++)bz1[j]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 1020, M = 203000, inf = 0x3f3f3f3f;\nint n,m,head[N],nxt[M],to[M],edgenum,a[M],b[M],d[N],mx[N],q[N<<2],res[M];Vi e[N];\nvoid add(int u, int v){\n\tto[++edgenum]=v;nxt[edgenum]=head[u];head[u]=edgenum;\n}\ninline void dfs(int u, int *d){\n\tL(i,u)if(d[to[i]]==inf)d[to[i]]=d[u],dfs(to[i],d);\n}\nint main() {\n\tread(n);read(m);rep(i,1,m)read(a[i]),read(b[i]),add(a[i],b[i]),e[b[i]].pb(i);\n\trep(u,1,n){\n\t\tint f=1,r=1;\n\t\tmemset(d,inf,sizeof(d));memset(mx,inf,sizeof(mx));\n\t\tL(i,u)q[r++]=to[i];d[u]=mx[u]=0;\n\t\t/*while(f!=r){\n\t\t\tint u=q[f++];\n\t\t\tL(i,u)if(d[to[i]]>d[u]||mx[to[i]]<mx[u])\n\t\t\t\tmx[to[i]]=mx[u],d[to[i]]=d[u],q[r++]=to[i];\n\t\t}*/\n\t\tstatic int s[N];int len=0;L(i,u)s[++len]=to[i];\n\t\trep(i,1,len)if(d[s[i]]==inf)d[s[i]]=s[i],dfs(s[i],d);\n\t\tper(i,len,1)if(mx[s[i]]==inf)mx[s[i]]=s[i],dfs(s[i],mx);\n\t\tL(i,u)res[i]^=d[to[i]]!=to[i]||mx[to[i]]!=to[i];\n\t\tper(i,SZ(e[u])-1,0)res[e[u][i]]^=d[a[e[u][i]]]<inf;\n\t}\n\trep(i,1,m)printf(\"%s\\n\",res[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[M],V[M],id,f[N],dfn[N],low[N];\nvector<int>e[N],d[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n        d[U[i]].push_back(V[i]);\n    }\n    for(int i=1;i<=n;i++)\n        if(!dfn[i])\n        dfs(i);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=666;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis1[e[i][j]])\n            dfs1(e[i][j],d[i][j]);\n        for(int j=up-1;j>=0;j--)\n            if(!vis2[e[i][j]])\n            dfs2(e[i][j],d[i][j]);\n        for(int j=1;j<=n;j++)\n            if(vis1[j]&&j!=i)\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nnamespace o_o\n{\n\tconst int N=1010,M=200100;\n\n\tbool g[N][N],ans[N][N];\n\tint f0[N],f1[N];\n\n\tint begin[N],next[M],to[M];\n\tint e;\n\n\tvoid add(int x,int y)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t}\n\n\tvoid Dfs(int p,int h,int *f)\n\t{\n\t\tif(f[p])return;\n\t\tf[p]=h;\n\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\tDfs(to[i],h,f);\n\t}\n\n\tint n,m;\n\n\tvoid work(int p)\n\t{\n\t\tstatic int seq[N],tot;\n\t\ttot=0;\n\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\tseq[++tot]=to[i];\n\t\tstd::sort(seq+1,seq+tot+1);\n\t\tmemset(f0,0,sizeof(f0)),memset(f1,0,sizeof(f1));\n\t\tf0[p]=f1[p]=2333;\n\n\t\tfor(int i=1;i<=tot;i++)\n\t\t\tDfs(seq[i],seq[i],f0);\n\t\tfor(int i=tot;i;i--)\n\t\t\tDfs(seq[i],seq[i],f1);\n\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tans[p][i]=f0[i]!=f1[i],g[p][i]=(f0[i] || f1[i]);\n\t}\n\n\tint E[M][2];\n\n\tvoid solve()\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1,u,v;i<=m;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),E[i][0]=u,E[i][1]=v,add(u,v);\n\n\t\tfor(int i=1;i<=n;i++)\n\t\t\twork(i);\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint u=E[i][0],v=E[i][1];\n\t\t\tif(g[v][u])printf(\"%s\\n\",ans[u][v]?\"same\":\"diff\");\n\t\t\telse printf(\"%s\\n\",ans[u][v]?\"diff\":\"same\");\n\t\t}\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"D.in\",\"r\",stdin);\n//\tfreopen(\"D.out\",\"w\",stdout);\n\to_o::solve();\n//\tfprintf(stderr,\"time = %lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define pb push_back\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\nconst int N=1005,M=2e5+5;\nvector<pi>to[N];\nint ans[M];\nint dfn[N],low[N],st[N],col[N],tim,top,cnt,n,m;\nvoid tarjan(int u){\n\tdfn[u]=low[u]=++tim,st[++top]=u;\n\tfor(auto v:to[u])if(!dfn[v.fi])tarjan(v.fi),cmin(low[u],low[v.fi]);\n\telse if(!col[v.fi])cmin(low[u],dfn[v.fi]);\n\tif(dfn[u]==low[u])\n\t\tfor(++cnt;st[top+1]!=u;--top)col[st[top]]=u;\n}\nint q[M<<3],fr[N],vis[N];\ninline int trs(R int &x,R int y){return x==y?0:(x=!x?y:1023,1);}\nvoid bfs(int rt){\n\tint h=1,t=0,u;\n\tfp(i,1,n)vis[i]=fr[i]=0;\n\tfor(auto v:to[rt])fr[v.fi]=v.fi,q[++t]=v.fi,vis[v.fi]=1;\n\twhile(h<=t){\n\t\tu=q[h++],vis[u]=0;\n\t\tfor(auto v:to[u])if(v.fi!=rt&&trs(fr[v.fi],fr[u])&&!vis[v.fi])q[++t]=v.fi,vis[v.fi]=1;\n\t}\n\tfor(auto v:to[rt])ans[v.se]=(fr[v.fi]==1023)^(col[rt]==col[v.fi]);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin); \n\tscanf(\"%d%d\",&n,&m);\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),to[u].pb(pi(v,i));\n\tfp(i,1,n)if(!dfn[i])tarjan(i);\n\tfp(i,1,n)bfs(i);\n\tfp(i,1,m)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\ntypedef pair<int, int> P;\nbool can[1000][1000];\nbool ans[200000];\nvector<P> G[200000];\nbool vis[1000];\nvoid dfs(int s, int v) {\n\tcan[s][v] = 1;\n\tfor (P e : G[v]) {\n\t\tif (!can[s][e.first]) {\n\t\t\tdfs(s, e.first);\n\t\t}\n\t}\n}\nvoid dfs2(int v) {\n\tvis[v] = 1;\n\tfor (P e : G[v]) {\n\t\tif (!vis[e.first]) {\n\t\t\tdfs2(e.first);\n\t\t}\n\t}\n}\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].emplace_back(b, i);\n\t}\n\tfor (int i = 0; i < N; i++) dfs(i, i);\n\tfor (int i = 0; i < N; i++) {\n\t\tvector<P> edge = G[i];\n\t\tG[i].clear();\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tfor (P e : edge) {\n\t\t\tif (can[e.first][i] == vis[e.first]) {\n\t\t\t\tans[e.second] = 1;\n\t\t\t}\n\t\t\tG[i].push_back(e);\n\t\t\tdfs2(i);\n\t\t}\n\t\treverse(edge.begin(), edge.end());\n\t\tG[i].clear();\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tfor (P e : edge) {\n\t\t\tif (can[e.first][i] == vis[e.first]) {\n\t\t\t\tans[e.second] = 1;\n\t\t\t}\n\t\t\tG[i].push_back(e);\n\t\t\tdfs2(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ans[i]) cout << \"same\" << endl;\n\t\telse cout << \"diff\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\n\nvector <int> graph[1001];\n\nvoid addedge(int u,int v)\n{\n\tgraph[u].push_back(v);\n}\n\nint vis[1001][1001];\nstruct\n{\n\tint first,second;\n}edge[200001];\nint mark[1001];\nint times=1;\nint tmp;\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=times;\n\tfor(auto to:graph[now])\n\t{\n\t\tif(to==from)continue;\n\t\tif(vis[from][to]<2&&mark[to]!=times)\n\t\t{\n\t\t\tdfs(from,to);\n\t\t}\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i].first=from;\n\t\tedge[i].second=to;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto to:graph[i])\n\t\t{\n\t\t\tif(vis[i][to]<2)\n\t\t\t{\n\t\t\t\ttimes++;\n\t\t\t\tdfs(i,to);\n\t\t\t}\n\t\t}\n\t}\n\t//return 0;\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int INF=0x7f7f7f7f;\nconst int maxn=(2e5)+10;\nint n,m,tot,head[1010],nxt[maxn];\nint from[maxn],to[maxn];\nbool vis[1010],ans;\nvoid add(int x) {\n\ttot++; nxt[tot]=head[x];\n\thead[x]=tot;\n}\nint S;\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (int i=head[u],v;i;i=nxt[i]) {\n\t\tv=to[i];\n\t\tif (S==i||vis[v]) continue;\n\t\tdfs(v);\n\t}\n}\nint dfn[1010],low[1010];\nint sid[1010],cnt,idx;\nbool inStack[1010];\nstack<int> st;\nvoid tarjan(int u) {\n    dfn[u]=low[u]=++idx;\n    inStack[u]=1;\n    st.push(u);\n    for (int i=head[u],v;i;i=nxt[i]) {\n        v=to[i];\n        if (dfn[v]==-1) {\n            tarjan(v);\n            low[u]=min(low[u],low[v]);\n        }\n        else if (inStack[v])\n            low[u]=min(low[u],dfn[v]);\n    }\n    if (dfn[u]==low[u]) {\n        cnt++;\n        while (1) {\n            int v=st.top();\n            st.pop(); inStack[v]=0;\n            sid[v]=cnt;\n            if (v==u) break;\n        }\n    }\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m);\n\tfor (int i=1;i<=m;i++) {\n\t\tread(from[i]); read(to[i]);\n\t\tadd(from[i]);\n\t}\n\tmemset(dfn,-1,sizeof(dfn));\n\tfor (int i=1;i<=n;i++) {\n\t\tif (dfn[i]==-1) tarjan(i);\n\t}\n\tint x,y;\n\tfor (int i=1;i<=m;i++) {\n\t\tx=from[i];\n\t\ty=to[i];\n\t\tS=i;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(x);\n\t\tif (sid[x]==sid[y]&&vis[y]) printf(\"same\\n\");\n\t\telse if (sid[x]!=sid[y]&&!vis[y]) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2020, M = 403000, inf = 0x3f3f3f3f;\nint n,m,head[N],nxt[M],to[M],edgenum,a[M],b[M],d[N],mx[N],res[M];Vi e[N];\nvoid add(int u, int v){\n\tto[++edgenum]=v;nxt[edgenum]=head[u];head[u]=edgenum;\n}\nVi g[N];\nint tot;\ninline void dfs(int u, int *d){\n\trep(i,0,SZ(g[u])-1)if(d[g[u][i]]==inf)d[g[u][i]]=d[u],dfs(g[u][i],d);\n//\tL(i,u)\n//\tfor(int i=head[u];i;i=nxt[i])\n//\t{tot++;if(d[to[i]]==inf)d[to[i]]=d[u],dfs(to[i],d);}\n}\nint main() {//freopen(\"1.in\",\"r\",stdin);\n\tread(n);read(m);rep(i,1,m)read(a[i]),read(b[i]),add(a[i],b[i]),e[b[i]].pb(i);\n\trep(i,1,m)g[a[i]].pb(b[i]);\n\trep(u,1,n){\n\t//\tprintf(\"u = %d %d\\n\",u,tot);\n\t//\tint f=1,r=1;\n\t\tmemset(d,inf,4*(n+2));memset(mx,inf,4*(n+2));\n\t//\tL(i,u)q[r++]=to[i];\n\t\td[u]=mx[u]=0;\n\t\t/*while(f!=r){\n\t\t\tint u=q[f++];\n\t\t\tL(i,u)if(d[to[i]]>d[u]||mx[to[i]]<mx[u])\n\t\t\t\tmx[to[i]]=mx[u],d[to[i]]=d[u],q[r++]=to[i];\n\t\t}*/\n\t\tstatic int s[N];int len=0;L(i,u)s[++len]=to[i];\n\t\trep(i,1,len)if(d[s[i]]==inf)d[s[i]]=s[i],dfs(s[i],d);\n\t\tper(i,len,1)if(mx[s[i]]==inf)mx[s[i]]=s[i],dfs(s[i],mx);\n\t\tL(i,u)res[i]^=d[to[i]]!=to[i]||mx[to[i]]!=to[i];\n\t\tper(i,SZ(e[u])-1,0)res[e[u][i]]^=d[a[e[u][i]]]<inf;\n\t}\n\t//rep(i,1,m)printf(\"%s\\n\",res[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m,tot;\nint vis[1005],c[1005][1005],d[1005][1005],v[200005],nxt[200005],id[200005],h[1005];\nbool ans[200005];\n\nvoid addedge(int x,int y,int z){v[++tot]=y; id[tot]=z; nxt[tot]=h[x]; h[x]=tot;}\n\nvoid dfs1(int u,int f){\n\tc[f][u]=1;\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(vis[v[p]]) continue;\n\t\tvis[v[p]]=1;\n\t\tdfs1(v[p],f);\n\t}\n}\n\nvoid dfs2(int u,int x,int f){\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(v[p]==x||vis[v[p]]) continue;\n\t\tvis[v[p]]=f;\n\t\tdfs2(v[p],x,f);\n\t}\n}\n\nint main(){\n\tn=readint(); m=readint();\n\tint x,y;\n\tfor(int i=1;i<=m;i++){\n\t\tx=readint(); y=readint();\n\t\taddedge(x,y,i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvis[i]=1;\n\t\tdfs1(i,i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvector<int> adj(0);\n\t\tfor(int p=h[i];p;p=nxt[p]) adj.pb(v[p]);\n\t\tfor(auto v:adj){\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=v;\n\t\t\t\tdfs2(v,i,v);\n\t\t\t}\n\t\t}\n\t\tfor(auto v:adj) if(vis[v]!=v) d[i][v]=1;\n\t\treverse(adj.begin(),adj.end());\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(auto v:adj){\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=v;\n\t\t\t\tdfs2(v,i,v);\n\t\t\t}\n\t\t}\n\t\tfor(auto v:adj) if(vis[v]!=v) d[i][v]=1;\n\t}\n\tfor(int i=1;i<=n;i++) for(int p=h[i];p;p=nxt[p]) if(c[v[p]][i]==d[i][v[p]]) ans[id[p]]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(ans[i]) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <random>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\n#define forin(i, f, t) for(auto i = f; i < t; i++)\n\nusing namespace std;\nusing ll = long long;\n\nusing Edge = pair<int, int>;\nvector<vector<int>> nodes;\nvector<bool> visited;\n\nvoid mark(int t, int c, int id, vector<int> &map) {\n    if (c == t || visited[c]) return;\n    visited[c] = true;\n    map[c] = id;\n    cerr << c << endl;\n    forin(i, 0, nodes[c].size()) {\n        mark(t, nodes[c][i], id, map);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Edge> e(m);\n    nodes.resize(n + 1);\n    forin(i, 0, m) {\n        cin >> e[i].first >> e[i].second;\n        nodes[e[i].first].push_back(e[i].second);\n    }\n    vector<vector<int>> fMap(n + 1, vector<int>(n + 1, 0)), dMap(n + 1, vector<int>(n + 1, 0));\n    forin(i, 1, n + 1) {\n        visited.assign(n, false);\n        int id = 1;\n        forin(j, 0, nodes[i].size()) {\n            mark(i, nodes[i][j], id++, fMap[i]);\n        }\n        visited.assign(n, false);\n        id = (int)nodes[i].size();\n        for (auto j = nodes[i].size(); j > 0; --j) {\n            mark(i, nodes[i][j - 1], id--, dMap[i]);\n        }\n    }\n    forin(i, 0, m) {\n        auto edge = e[i];\n        if ((fMap[edge.first][edge.second] != dMap[edge.first][edge.second]) == (fMap[edge.second][edge.first] > 0)) {\n            cout << \"same\" << endl;\n        } else {\n            cout << \"diff\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1003,M=200005;\nusing namespace std;\nint n,m,to[M],hd[M],lk[M],\nu,nl[N],nr[N],st[N],t;\nbool mp[N][N],ans[M];\nvoid dfs(int x){\n\tif(mp[u][x])return;\n\tmp[u][x]=1;\n\tfor(int i=lk[x];i;i=hd[i])\n\tdfs(to[i]);\n}\nvoid dfs(int x,int*a){\n\t//cerr<<x<<'('<<u<<'/'<<t<<endl;\n\tif(a[x]||x==u)return;\n\ta[x]=t;\n\tfor(int i=lk[x];i;i=hd[i])\n\tdfs(to[i],a);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,to+i);\n\t\thd[i]=lk[u],lk[u]=i;\n\t}\n\t//for(int i=1;i<=n;i++)dfs(u=i);\n\tfor(int i=1;i<=n;i++){\n\t\tt=0,u=i;\n\t\tfor(int j=1;j<=n;j++)\n\t\tnl[j]=nr[j]=0;\n\t\tfor(int j=lk[i];j;j=hd[j])\n\t\tdfs(to[st[++t]=j],nl);\n\t\tfor(int s;t;t--)\n\t\tdfs(s=to[st[t]],nr),\n\t\t//cerr<<st[t]<<\":\"<<i<<\"->\"<<s<<' '<<mp[s][i]<<','<<nl[s]<<','<<nr[s]<<endl,\n\t\tans[st[t]]=mp[s][i]^(nl[s]<t||nr[s]>t);\n\t}\n\tfor(int i=1;i<=m;i++)\n\tputs(ans[i]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 1000\n#define MM 200000\nstruct edge{edge*nx;int t;}e[MM*3+5],*h[MN+5],*r[MN+5],*c[MN+5];\nint en=1,x[MM+5],y[MM+5];\nint d[MN+5],l[MN+5],cnt,z[MN+5],zn,inz[MN+5],p[MN+5],pn,ph[MN+5];\nint g[MN+5][MN+5],q[MN+5],qn,u[MN+5],uu[MM+5];\ninline void ins(edge**h,int x,int y){e[++en]=(edge){h[x],y};h[x]=e+en;}\nvoid dfs(int x)\n{\n\td[x]=l[x]=++cnt;inz[z[zn++]=x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)\n\t\tif(!d[i->t])dfs(i->t),l[x]=min(l[x],l[i->t]);\n\t\telse if(inz[i->t])l[x]=min(l[x],d[i->t]);\n\tif(d[x]==l[x])for(ph[++pn]=x;z[zn]!=x;)inz[z[--zn]]=0,p[z[zn]]=pn;\n}\nvoid d1(edge**h,int x,int z)\n{\n\tu[x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)if(!u[i->t])d1(h,i->t,z),uu[i-e>>1]|=z;\n}\nvoid d2(edge**h,int x,int d,int xs,int ys)\n{\n\tu[x]=1;\n\tfor(edge*i=h[x];i;i=i->nx)if((i-e>>1)!=d&&!u[i->t])d2(h,i->t,d,xs,ys);\n\tif(x==xs&&!u[ys])d2(h,ys,d,xs,ys);\n}\nint main()\n{\n\tint n=read(),m=read(),i,j;\n\tfor(i=1;i<=m;++i)x[i]=read(),y[i]=read(),ins(h,x[i],y[i]),ins(r,y[i],x[i]);\n\tfor(i=1;i<=n;++i)if(!d[i])dfs(i);\n\tmemset(h,0,sizeof(h));memset(r,0,sizeof(r));en=1;\n\tfor(i=1;i<=m;++i)if(p[x[i]]==p[y[i]])ins(h,x[i],y[i]),ins(r,y[i],x[i]);else en+=2;\n\tfor(i=1;i<=pn;++i)d1(h,ph[i],1);\n\tmemset(u,0,sizeof(u));\n\tfor(i=1;i<=pn;++i)d1(r,ph[i],2);\n\tfor(i=1;i<=m;++i)if(p[x[i]]!=p[y[i]])ins(c,p[x[i]],p[y[i]]);\n\tfor(i=1;i<=pn;++i)for(g[i][q[j=qn=1]=i]=1;j<=qn;++j)\n\t\tfor(edge*k=c[q[j]];k;k=k->nx)if(!g[i][k->t]++)q[++qn]=k->t;\n\tfor(i=1;i<=m;++i)\n\t\tif(p[x[i]]!=p[y[i]])puts(g[p[x[i]]][p[y[i]]]>1?\"diff\":\"same\");\n\t\telse\n\t\t{\n\t\t\tif(uu[i]&1)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(h,ph[p[x[i]]],i,y[i],x[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tif(uu[i]&2)\n\t\t\t{\n\t\t\t\tmemset(u,0,sizeof(u));\n\t\t\t\td2(r,ph[p[x[i]]],i,x[i],y[i]);\n\t\t\t\tfor(j=1;j<=n;++j)if(p[j]==p[x[i]]&&!u[j])break;\n\t\t\t\tif(j<=n){puts(\"diff\");continue;}\n\t\t\t}\n\t\t\tputs(\"same\");\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 2007\n#define MAX_M 300007\n#define V std::vector\n\nint N, M, cur;\nint cnt[MAX_N][MAX_N], vis[MAX_N];\nbool con[MAX_N][MAX_N];\nV<int> G[MAX_N];\n\nstruct edge{\n    int u, v;\n}e[MAX_M];\n\nvoid dfs(int x, int s, int S) {\n    if (cnt[S][x] > 1 || vis[x] == cur) return;\n    con[S][x] = true;\n    cnt[S][x]++;\n    if (cnt[S][x] == 1) vis[x] = cur;\n    for(int y : G[x]) \n        if (cnt[S][y] < 2 && y != s) {\n            dfs(y, s, S);\n        }\n}\n\nvoid solve() {\n    Rep(i, M) {\n        int u = e[i].u, v = e[i].v;\n        bool flga = con[v][u], flgb = (cnt[u][v] > 1);\n        puts((flga ^ flgb) ? \"diff\" : \"same\");\n    }\n}\n\nint main() {\n#ifdef LOCAL\n    FIN(\"in\");\n#endif\n    read(N), read(M);\n    int u, v;\n    Rep(i, M) {\n        read(u), read(v);\n        e[i] = (edge){u, v};\n        G[u].push_back(v);\n    }\n    Rep(i, N) {\n        cnt[i][i] = 10000;\n        for (int j : G[i]) \n            ++cur, dfs(j, j, i);\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector> \n#define MN 1010 \n#define MM 201000\n\ntypedef std::pair<int, int> P;\n\nP d[MN][2], q[MN * 2];\nint Ans[MN][MN], Ans2[MN][MN];\nint hh = 0, tt = 0;\nint x[MM], y[MM];\nstd::vector<int> to[MN];\n\nvoid bfs(int S)\n{\n\thh = 0; tt = 0;\n\tmemset(d, -1, sizeof(d));\n    for(int i = 0; i < to[S].size(); i++)\n\t\td[to[S][i]][0] = P(1, to[S][i]), q[tt++] = P(to[S][i], 0);\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh].first, o = q[hh].second; hh++;\n    \tfor(int i = 0; i < to[u].size(); i++)\n\t\t{\n\t\t\tif(to[u][i] == S) continue;\n\t\t\tif(d[to[u][i]][0].first == -1)\n\t\t\t{\n\t\t\t\td[to[u][i]][0].first = d[u][o].first + 1;\n\t\t\t\td[to[u][i]][0].second = d[u][o].second;\n\t\t\t\tq[tt++] = P(to[u][i], 0);\n\t\t\t}\n\t\t\telse if(d[to[u][i]][1].first == -1 && d[to[u][i]][0].second != d[u][o].second)\n\t\t\t{\n\t\t\t\td[to[u][i]][1].first = d[u][o].first + 1;\n\t\t\t\td[to[u][i]][1].second = d[u][o].second;\n\t\t\t\tq[tt++] = P(to[u][i], 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tto[x[i]].push_back(y[i]);\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tbfs(i);\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(d[j][0].second != j) Ans[i][j] = d[j][0].first;\n\t\t\telse Ans[i][j] = d[j][1].first;\n\t\t\tAns2[i][j] = d[j][0].first; \n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++) \n\t{\n\t\tif(Ans[x[i]][y[i]] == -1 && Ans2[y[i]][x[i]] != -1 || Ans[x[i]][y[i]] != -1 && Ans2[y[i]][x[i]] == -1)\n\t\t\tputs(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nunsigned lj[1024][32];\nunsigned vis[32];\nint tp[1024];\nvoid dfs(int u,int t)\n{\n\tif(vis[u>>5]&(1<<(u&31)))\n\t{\n\t\treturn;\n\t}\n\tvis[u>>5]|=(1<<(u&31));\n\ttp[u]=t;\n\tfor(int i=0;i<32;i++)\n\t{\n\t\tif((lj[u][i]&vis[i])==lj[u][i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<32;j++)\n\t\t{\n\t\t\tif(lj[u][i]&(1<<j))\n\t\t\t{\n\t\t\t\tdfs((i<<5)+j,t);\n\t\t\t}\n\t\t}\n\t}\n}\nint tp2[1005][1005];\nint a[262144],b[262144];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tlj[a[i]][b[i]>>5]|=(1<<(b[i]&31));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<32;j++)\n\t\t{\n\t\t\tvis[j]=0;\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\ttp[j]=0;\n\t\t}\n\t\tvis[i>>5]|=(1<<(i&31));\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(lj[i][j>>5]&(1<<(j&31)))\n\t\t\t{\n\t\t\t\tdfs(j,j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(tp[j])\n\t\t\t{\n\t\t\t\ttp2[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(tp[j]>0&&tp[j]<j)\n\t\t\t{\n\t\t\t\ttp2[i][j]=2;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<32;j++)\n\t\t{\n\t\t\tvis[j]=0;\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\ttp[j]=0;\n\t\t}\n\t\tvis[i>>5]|=(1<<(i&31));\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(lj[i][j>>5]&(1<<(j&31)))\n\t\t\t{\n\t\t\t\tdfs(j,j);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(tp[j]>j)\n\t\t\t{\n\t\t\t\ttp2[i][j]=2;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif((tp2[a[i]][b[i]]>=2)^(tp2[b[i]][a[i]]>=1))\n\t\t{\n\t\t\tprintf(\"diff\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 200005;\nconst int MM = 1000000007;\n\nvector<pii> G[MX];\nvector<int> H[MX];\nint ans[MX*2];\nint N, M, a, b;\n\nint dist[2005][2];\nvoid get_answer(int x){\n\tqueue<pii> Q;\n\tmemset(dist, 0, sizeof dist);\n\tfor(pii c : G[x]){\n\t\tif(c.second&1) continue;\n\t\tQ.emplace(c.first, c.second);\n\t\tdist[c.first][0] = c.second;\n\t}\n\tdist[x][0] = dist[x][1] = -1;\n\twhile(Q.size()){\n\t\tpii p = Q.front(); Q.pop();\n\t\tint c = p.first, lab = p.second;\n\t\tfor(int d : H[c]){\n\t\t\tif(dist[d][0] && dist[d][1] || dist[d][0] == lab) continue;\n\t\t\tif(!dist[d][0]) dist[d][0] = lab;\n\t\t\telse dist[d][1] = lab;\n\t\t\tQ.emplace(d, lab);\n\t\t}\n\t}\n\tfor(pii c : G[x]){\n\t\tif(dist[c.first][1] || dist[c.first][0] && dist[c.first][0] != c.second) ans[c.second] = 1;\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 1; i <= M; i++){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tG[a].emplace_back(b, i*2);\n\t\tG[b].emplace_back(a, i*2+1);\n\t\tH[a].emplace_back(b);\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tget_answer(i);\n\t}\n\tfor(int i = 1; i <= M; i++){\n\t\tif(ans[i*2] ^ ans[i*2+1]) printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\n\nstatic const int MAX_V = 1010;\n\nclass SCC {\n    vector<int> *G;\n    vector<int> rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n\n    void dfs(int v){\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++){\n            if (!used[G[v][i]]){\n                dfs(G[v][i]);\n            }\n        }\n        vs.push_back(v);\n    }\n\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for (int i = 0; i < rG[v].size(); i++){\n            if (!used[rG[v][i]]){\n                rdfs(rG[v][i], k);\n            }\n        }\n        return;\n    }\n\npublic:\n    int V;\n    int cmp[MAX_V];\n\n    SCC(vector<int>* _G, int _V){\n        G = _G;\n        V = _V;\n\n        //initialize reverse graph\n        for (int from = 0; from < V; from++){\n            for (int i = 0; i < G[from].size(); i++){\n                int to = G[from][i];\n                rG[to].push_back(from);\n            }\n        }\n    }\n\n    int solve() {\n        fill(cmp, cmp+V, -1);\n        fill(used, used+V, false);\n        vs.clear();\n        for (int v = 0; v < V; v++){\n            if (!used[v]){\n                dfs(v);\n            }\n        }\n        assert (vs.size() == V);\n\n        fill(used, used+V, false);\n        int k = 0;\n        for (int i = vs.size() - 1; i >= 0; i--){\n            int v = vs[i];\n            if (!used[v]){\n                rdfs(v, k++);\n            }\n        }\n        return k;\n    }\n\n    bool query(int u, int v){\n        return cmp[u] == cmp[v];\n    }\n};\n\nstruct Edge {int from, to;};\n\nvector<int> G[MAX_V];\nint reached[2][MAX_V];\nbool mat[MAX_V][MAX_V];\n\n\nvoid dfs(int v, int k, int* reached){\n    reached[v] = k;\n    for (int i = 0; i < G[v].size(); i++){\n        if (reached[G[v][i]] == -1){\n            dfs(G[v][i], k, reached);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    Edge es[M];\n    for (int i = 0; i < M; i++){\n        int from, to;\n        cin >> from >> to;\n        from--; to--; // adjust to 1 origin\n        es[i] = {from, to};\n        G[from].push_back(to);\n    }\n\n    // strongly connected component\n    SCC scc = SCC(G, N);\n    scc.solve();\n//    for (int v = 0; v < N; v++){\n//        cout << scc.cmp[v] << \",\";\n//    }\n//    cout << endl;\n\n    for (int v = 0; v < N; v++){\n//        cout << endl;\n//        cout << \"from:\" <<  v << endl;\n\n        fill(reached[0], reached[0]+N, -1);\n        reached[0][v] = MAX_V;\n        for (int i = 0; i < G[v].size(); i++){\n            int to = G[v][i];\n            if (reached[0][to] == -1){\n                dfs(to, i, reached[0]);\n            }\n        }\n//        for (int u = 0; u < N; u++){\n//            cout << reached[0][u] << \",\";\n//        }\n//        cout << endl;\n\n        fill(reached[1], reached[1]+N, -1);\n        reached[1][v] = MAX_V;\n        for (int i = G[v].size() - 1; i >= 0; i--){\n            int to = G[v][i];\n            if (reached[1][to] == -1){\n                dfs(to, i, reached[1]);\n            }\n        }\n//        for (int u = 0; u < N; u++){\n//            cout << reached[1][u] << \",\";\n//        }\n//        cout << endl;\n\n        for (int u = 0; u < N; u++){\n            mat[v][u] = (reached[0][u] != reached[1][u]);\n        }\n    }\n\n    for (int i = 0; i < M; i++){\n        Edge e = es[i];\n        if (scc.query(e.from, e.to) && mat[e.from][e.to]){\n            cout << \"same\" << endl;\n        } else if (scc.query(e.from, e.to) && !mat[e.from][e.to]){\n            cout << \"diff\" << endl;\n        } else if (!scc.query(e.from, e.to) && mat[e.from][e.to]){\n            cout << \"diff\" << endl;\n        } else if (!scc.query(e.from, e.to) && !mat[e.from][e.to]){\n            cout << \"same\" << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1010;\nint n,m,ind,cnt,top;\nint vis[N],que[N],stk[N],bl[N],dfn[N],low[N],u[N*200],v[N*200];\nbool ok[N*200],ins[N];\nvector<int> ve[N],id[N];\ninline void tarjan(int x){\n\tstk[++top]=x; ins[x]=1; dfn[x]=low[x]=++ind;\n\tfor(auto to:ve[x])\n\t\tif(!dfn[to]) tarjan(to),low[x]=min(low[x],low[to]);\n\t\telse if(ins[to]) low[x]=min(low[x],dfn[to]);\n\tif(low[x]==dfn[x]){\n\t\tint y; ++cnt;\n\t\tdo y=stk[top--],ins[y]=0,bl[y]=cnt;\n\t\twhile(y!=x);\n\t}\n}\ninline void solve(int rt){\n\tint head=1,tail=0; vis[rt]=++ind;\n\tfor(int i=0;i<ve[rt].size();++i){\n\t\tok[id[rt][i]]|=vis[ve[rt][i]]==ind;\n\t\tif(vis[ve[rt][i]]!=ind) vis[ve[rt][i]]=ind,que[++tail]=ve[rt][i];\n\t\twhile(head<=tail){\n\t\t\tint x=que[head++];\n\t\t\tfor(auto to:ve[x]) if(vis[to]!=ind) vis[to]=ind,que[++tail]=to;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,a,b;i<=m;++i) scanf(\"%d%d\",&a,&b),ve[a].push_back(b),id[a].push_back(i),u[i]=a,v[i]=b;\n\ttarjan(1);\n\tfor(int i=1;i<=n;++i) solve(i),reverse(ve[i].begin(),ve[i].end()),reverse(id[i].begin(),id[i].end()),solve(i);\n\tfor(int i=1;i<=m;++i){\n\t\tif(bl[u[i]]==bl[v[i]]) puts(ok[i]?\"same\":\"diff\");\n\t\telse puts(ok[i]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1'009;\n\nvector<int> g[N];\nbool was[N];\nvector<int> order;\n\nvoid dfs1(int x) {\n  was[x] = true;\n  for (int y : g[x]) {\n    if (!was[y]) {\n      dfs1(y);\n    }\n  }\n  order.push_back(x);\n}\n\nvector<int> gt[N];\n\nvoid dfs2(int x, int ncomp, int *comp) {\n  comp[x] = ncomp;\n  for (int y : gt[x]) {\n    if (comp[y] == -1) {\n      dfs2(y, ncomp, comp);\n    }\n  }\n}\n\nbool can[N][N];\nint q[N];\nint comp1[N];\nint comp2[N];\nint p[N];\nbool lo[N];\nbool hi[N];\nint in[N];\nint out[N];\n\nconst int M = 200'009;\n\nint from[M];\nint to[M];\nbool ans[M];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", from + i, to + i);\n    --from[i];\n    --to[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n    gt[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    g[from[i]].push_back(to[i]);\n    gt[to[i]].push_back(from[i]);\n  }\n  memset(was, false, sizeof was);\n  order.clear();\n  for (int i = 0; i < n; ++i) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  memset(comp1, -1, sizeof comp1);\n  int ncomp1 = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (comp1[order[i]] == -1) {\n      dfs2(order[i], ncomp1, comp1);\n      ++ncomp1;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    if (comp1[from[i]] != comp1[to[i]]) {\n      g[comp1[from[i]]].push_back(i);\n    }\n  }\n  memset(can, false, sizeof can);\n  for (int i = 0; i < ncomp1; ++i) {\n    can[i][i] = true;\n    q[0] = i;\n    for (int qh = 0, qt = 1; qh < qt; ++qh) {\n      int x = q[qh];\n      for (int id : g[x]) {\n        int y = comp1[to[id]];\n        if (!can[i][y]) {\n          can[i][y] = true;\n          q[qt++] = y;\n        }\n      }\n    }\n  }\n  memset(ans, false, sizeof ans);\n  for (int x = 0; x < ncomp1; ++x) {\n    vector<int> w;\n    for (int id : g[x]) {\n      w.push_back(comp1[to[id]]);\n    }\n    sort(w.begin(), w.end());\n    w.resize(distance(w.begin(), unique(w.begin(), w.end())));\n    for (int id : g[x]) {\n      int y = comp1[to[id]];\n      for (int z : w) {\n        if (z != y && can[z][y]) {\n          ans[id] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    memset(p, -1, sizeof p);\n    int sz = 0;\n    for (int j = 0; j < n; ++j) {\n      if (j != i && comp1[j] == comp1[i]) {\n        p[j] = sz++;\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      g[j].clear();\n      gt[j].clear();\n    }\n    for (int j = 0; j < m; ++j) {\n      if (p[from[j]] != -1 && p[to[j]] != -1) {\n        g[p[from[j]]].push_back(p[to[j]]);\n        gt[p[to[j]]].push_back(p[from[j]]);\n      }\n    }\n    memset(was, false, sizeof was);\n    order.clear();\n    for (int j = 0; j < sz; ++j) {\n      if (!was[j]) {\n        dfs1(j);\n      }\n    }\n    memset(comp2, -1, sizeof comp2);\n    int ncomp2 = 0;\n    for (int j = sz - 1; j >= 0; --j) {\n      if (comp2[order[j]] == -1) {\n        dfs2(order[j], ncomp2, comp2);\n        ++ncomp2;\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      hi[j] = true;\n      lo[j] = true;\n    }\n    for (int j = 0; j < m; ++j) {\n      if (p[from[j]] != -1 && p[to[j]] != -1) {\n        if (comp2[p[from[j]]] != comp2[p[to[j]]]) {\n          lo[comp2[p[from[j]]]] = false;\n          hi[comp2[p[to[j]]]] = false;\n        }\n      }\n    }\n    memset(in, 0, sizeof in);\n    memset(out, 0, sizeof out);\n    for (int j = 0; j < m; ++j) {\n      if (from[j] == i && p[to[j]] != -1) {\n        if (hi[comp2[p[to[j]]]]) {\n          ++in[comp2[p[to[j]]]];\n        }\n      } else\n      if (to[j] == i && p[from[j]] != -1) {\n        if (lo[comp2[p[from[j]]]]) {\n          ++out[comp2[p[from[j]]]];\n        }\n      }\n    }\n    for (int j = 0; j < m; ++j) {\n      if (from[j] == i && p[to[j]] != -1) {\n        if (hi[comp2[p[to[j]]]] && in[comp2[p[to[j]]]] == 1) {\n          ans[j] = true;\n        }\n      } else\n      if (to[j] == i && p[from[j]] != -1) {\n        if (lo[comp2[p[from[j]]]] && out[comp2[p[from[j]]]] == 1) {\n          ans[j] = true;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    puts(ans[i] ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n\tint v,nxt;\n}e[400050];\n\nint head[1050],ecnt;\nint flg1[200050],flg2[200050];\nint vis1[1050],vis2[1050];\n\nvoid adde(int u,int v,int id)\n{\n\te[++ ecnt].v = v;\n\te[ecnt].nxt = head[u];\n\thead[u] = ecnt;\n}\n\nvector<pair<int,int> > come[1050];\n\nvoid dfs1(int pos,int tag)\n{\n\tvis1[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis1[v])\n\t\t\tdfs1(v,tag);\n\t}\n}\n\nvoid dfs2(int pos,int tag)\n{\n\tvis2[pos] = tag;\n\tfor(int i = head[pos];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif(!vis2[v])\n\t\t\tdfs2(v,tag);\n\t}\n}\n\nint main()\n{\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\tadde(u,v,i); come[v].push_back(make_pair(u,i));\n\t}\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t//\tcerr << i << endl;\n\t\tmemset(vis1,0,sizeof(vis1));\n\t\tmemset(vis2,0,sizeof(vis2));\n\t\tvector<int> histo; histo.clear();\n\t\tvis1[i] = vis2[i] = -1;\n\t\tfor(int j = head[i];j;j = e[j].nxt)\n\t\t{\n\t\t\tint v = e[j].v;\n\t\t\thisto.push_back(j);\n\t\t\tif(!vis1[v])\n\t\t\t\tdfs1(v,j);\n\t\t}\n\t\tfor(int j = histo.size() - 1;j >= 0; -- j)\n\t\t{\n\t\t\tint v = e[histo[j]].v;\n\t\t\tif(!vis2[v])\n\t\t\t\tdfs2(v,histo[j]);\n\t\t}\n\t\tfor(int j = 0;j < histo.size(); ++ j)\n\t\t\tif(vis1[e[histo[j]].v] != vis2[e[histo[j]].v])\n\t\t\t\tflg2[histo[j]] = 1;\n\t\tfor(auto v : come[i])\n\t\t\tif(vis1[v.first]) flg1[v.second] = 1;\n\t}\n\tfor(int i = 1;i <= m; ++ i)\n\t\tprintf(\"%s\\n\",flg1[i] + flg2[i] == 1 ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=1010,M=2e5+10;\nint w[M],ne[M],la[N],t,ans[M];\nvoid link(int x,int y){\n\tw[++t]=y;\n\tne[t]=la[x];\n\tla[x]=t;\n}\nint arv[N][N],n,m,X,mrk[N],ti,mrk2[N];\nvoid dfs(int x){\n\tif (arv[X][x])return;\n\tarv[X][x]=1;\n\tfor (int y=la[x];y;y=ne[y])dfs(w[y]);\n}\nvoid go(int x){\n\tif (X==x||mrk[x])return;\n\tmrk[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])go(w[y]);\n}\nvoid go2(int x){\n\tif (X==x||mrk2[x])return;\n\tmrk2[x]=ti;\n\tfor (int y=la[x];y;y=ne[y])go2(w[y]);\n}\nvector<int> c;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tfor (X=1;X<=n;X++)dfs(X);\n\tfor (X=1;X<=n;X++){\n\t\tfor (int i=1;i<=n;i++)mrk[i]=mrk2[i]=0;\n\t\tc.clear();\n\t\tfor (int y=la[X];y;y=ne[y]){\n\t\t\tti++;\n\t\t\tgo(w[y]);\n\t\t\tc.push_back(w[y]);\n\t\t}\n\t\twhile (c.size()){\n\t\t\tgo2(c.back());\n\t\t\tc.pop_back();\n\t\t\tti--;\n\t\t}\n\t\tfor (int y=la[X];y;y=ne[y])\n\t\t\tans[y]=(mrk[w[y]]<mrk2[w[y]])==arv[w[y]][X];\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tputs(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<ctime>\nusing namespace std;\n#define N 1050\n#define M 200500\nint head[N],cnt,scc[N],dfn[N],low[N],f[N][13],s[M][2],as[M],vl[N],ct,ct2,vis[N][N],id[N],ct1,dep[N],is[N],n,m,ct3;\nstruct edge{int t,next,id;}ed[M];\nvoid adde(int f,int t,int id){ed[++cnt]=(edge){t,head[f],id};head[f]=cnt;}\nstack<int> tp,tp2,v[N],tp3;\nvoid dfs1(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\ttp.push(u);\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs1(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])\n\t{\n\t\tint s=tp.top(),id=++ct2;tp.pop();\n\t\tscc[s]=id;\n\t\twhile(s!=u)\n\t\ts=tp.top(),tp.pop(),scc[s]=id;\n\t}\n}\nvoid dfs2(int u,int s){for(int i=head[u];i;i=ed[i].next)if(!vis[s][ed[i].t])vis[s][ed[i].t]=1,dfs2(ed[i].t,s);else vis[s][ed[i].t]++;}\nint LCA(int x,int y){if(dep[x]<dep[y])x^=y^=x^=y;for(int i=10;i>=0;i--)if(dep[x]-dep[y]>=(1<<i))x=f[x][i];if(x==y)return x;for(int i=10;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];return f[x][0];}\nvoid dfs3(int u,int fa)\n{\n\tdfn[u]=1;dep[u]=dep[fa]+1;f[u][0]=fa;vl[u]=0;for(int i=1;i<=10;i++)f[u][i]=f[f[u][i-1]][i-1];\n\tfor(int i=head[u];i;i=ed[i].next)\n\tif(!dfn[ed[i].t])tp.push(ed[i].id),dfs3(ed[i].t,u),vl[u]+=vl[ed[i].t];\n\telse{int s=LCA(u,ed[i].t);vl[u]++;vl[s]--;tp2.push(ed[i].id);}\n}\nvoid dfs4(int u)\n{\n\tdfn[u]=low[u]=++ct1;\n\tfor(int i=head[u];i;i=ed[i].next)\n\t{\n\t\tif(!dfn[ed[i].t])dfs1(ed[i].t),low[u]=min(low[u],low[ed[i].t]);\n\t\telse if(!scc[ed[i].t])low[u]=min(low[u],dfn[ed[i].t]);\n\t}\n\tif(dfn[u]==low[u])ct2++;\n}\nbool check(int x)\n{\n\tfor(int i=1;i<=n;i++)dfn[i]=scc[i]=head[i]=0;\n\tcnt=0;ct2=0;\n\tfor(int i=1;i<=m;i++)if(i!=x)adde(s[i][0],s[i][1],-1);else adde(s[i][1],s[i][0],-2);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs4(i);\n\treturn ct2!=ct3;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&s[i][0],&s[i][1]),adde(s[i][0],s[i][1],1);\n\tfor(int i=1;i<=n;i++)if(!dfn[i])dfs1(i);ct3=ct2;\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])adde(scc[s[i][0]],scc[s[i][1]],-3);\n\tfor(int i=1;i<=ct2;i++)dfs2(i,i);\n\tfor(int i=1;i<=n;i++)head[i]=0;cnt=0;\n\tfor(int i=1;i<=m;i++)if(scc[s[i][0]]!=scc[s[i][1]])as[i]=vis[scc[s[i][0]]][scc[s[i][1]]]>1;else v[scc[s[i][0]]].push(i);\n\tfor(int i=1;i<=ct2;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)dfn[j]=0,head[j]=0;\n\t\tct1=0;cnt=0;\n\t\tfor(int j=1;j<=n;j++)if(scc[j]==i)id[j]=++ct1;\n\t\twhile(!v[i].empty())\n\t\t{\n\t\t\tint q=v[i].top();v[i].pop();\n\t\t\tadde(id[s[q][0]],id[s[q][1]],q);\n\t\t}\n\t\tdfs3(1,0);\n\t\twhile(!tp2.empty())\n\t\t{\n\t\t\tint st=tp2.top();tp2.pop();\n\t\t\tint l=id[s[st][0]],r=id[s[st][1]];\n\t\t\tr=LCA(l,r);\n\t\t\tint fg=0;\n\t\t\twhile(l!=r)fg|=(vl[l]==1),l=f[l][0];\n\t\t\tas[st]=fg;\n\t\t}\n\t}\n\twhile(!tp.empty()){int st=tp.top();tp.pop();as[st]=check(st);}\n\tfor(int i=1;i<=m;i++)printf(\"%s\\n\",as[i]?\"diff\":\"same\");\n}//"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#define maxn 1005\n#define _ 0\nusing namespace std;\nstruct nod\n{\n\tint nex,id;\n\tnod(int a,int b)\n\t{\n\t\tnex=a;\n\t\tid=b;\n\t}\n\tnod(){}\n};\nint n,m,tim;\nint vis[maxn];\nint bel[maxn][maxn][2];\nint u[maxn*maxn],v[maxn*maxn];\nvector<nod> edge[maxn];\nvoid dfs(int now,int fa,int b,int f)\n{\n//\tcerr<<now<<\" \"<<fa<<\" \"<<b<<\" \"<<f<<endl;\n\tvis[now]=tim; bel[fa][now][f]=b;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,fa,b,f);\n}\nvoid solve(int now)\n{\n\ttim++; vis[now]=tim;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,0);\n \n\treverse(edge[now].begin(),edge[now].end());\n \n\ttim++; vis[now]=tim;\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsolve(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif( (bel[v[i]][u[i]][0]!=0) ^ _ ^ (bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i) )\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1005;\n\nvector<int> graph[N];\n\nint n, m, l[200005], r[200005], cnt[N][N], vis[N][N];\n\nvoid dfs(int u, int p, int root, int mark) {\n    if(u == root) return ;\n    if(cnt[root][u] >= 2) return ;\n    if(vis[root][u] == mark) return ;\n    vis[root][u] = mark; cnt[root][u]++;\n    for(int i = 0; i < graph[u].size(); i++) {\n        int v = graph[u][i];\n        if(v == p) continue;\n        dfs(v, u, root, mark);\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++) {\n        cin >> l[i] >> r[i];\n        graph[l[i]].pb(r[i]);\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < graph[i].size(); j++) {\n            int v = graph[i][j];\n            dfs(v, i, i, v);\n        }\n    }\n    for(int i = 1; i <= m; i++) {\n        if(cnt[l[i]][r[i]] >= 2) {\n            if(cnt[r[i]][l[i]] == 0)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n        else {//1\n            if(cnt[r[i]][l[i]] >= 1)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\ntypedef unsigned long long ull;\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nvoid dfs(int k){\n\tif(k==D) return;\n\tvis[D][k]=1;\n\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k]){\n\t\tdfs(e[i].k);\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint o=vis[i][e[p].k];\n\t\t\tdfs(e[p].k);\n\t\t\tvis[i][e[p].k]=o;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    auto x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight = long long;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// 強連結成分分解 O(|V| + |E|)\nstd::vector<std::vector<Vertex>> strongly_connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  std::stack<Vertex> S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  // Tarjan\n  std::function<int(Vertex v)> dfs = [&](Vertex v) {\n    num[v] = low[v] = ++timer;\n    S.push(v); inS[v] = true;\n    for(const auto& e: G[v]) {\n      if(!num[e.to])     low[v] = std::min(low[v], dfs(e.to));\n      else if(inS[e.to]) low[v] = std::min(low[v], num[e.to]);\n    }\n    if(num[v] == low[v]) {\n      scc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto w = S.top(); S.pop(); inS[w] = false;\n        scc.back().push_back(w);\n        if(v == w) break;\n      }\n    }\n    return low[v];\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v);\n  return scc;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  vector<int> a(M), b(M);\n  for(auto i=0; i<M; ++i) {\n    cin >> a[i] >> b[i];\n    --a[i]; --b[i];\n    G[a[i]].push_back({a[i], b[i]});\n  }\n\n  auto scc = strongly_connected_component(G);\n  vector<int> group(N);\n  for(auto i=0; i<scc.size(); ++i) for(auto v: scc[i]) group[v] = i;\n\n  vector<int> in(N), out(N);\n  UnionFind<int> uf;\n  for(auto i=0; i<M; ++i) if(group[a[i]] != group[b[i]]) {\n    ++in[b[i]];\n    ++out[a[i]];\n    uf.unite(group[a[i]], group[b[i]]);\n  }\n\n  vector<int> indeg(N), outdeg(N);\n  for(auto i=0; i<M; ++i) if(group[a[i]] == group[b[i]]) {\n    ++outdeg[a[i]];\n    ++indeg[b[i]];\n  }\n  for(auto i=0; i<M; ++i) {\n    if(group[a[i]]!=group[b[i]]) {\n      if(uf.find(group[a[i]]) == uf.find(group[b[i]])) {\n        if(1<out[a[i]] && 1<in[b[i]]) cout << \"diff\" <<endl;\n        else                          cout << \"same\" <<endl;\n      } else {\n        cout << \"same\" << endl;\n      }\n    } else {\n      if(1<outdeg[a[i]] && 1<indeg[b[i]]) cout << \"same\" << endl;\n      else                                cout << \"diff\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct SCC\n{\n\tconst int INF = int(1e9);\n\tvector<vector<int> > vec;\n\tint index;\n\tvector<int> idx;\n\tvector<int> lowlink;\n\tvector<bool> onstack;\n\tstack<int> s;\n\tvector<int> sccidx;\n\tint scccnt;\n\tvi topo;\n\t\n\t//lower sccidx means appear later\n\tvoid init(int n)\n\t{\n\t\tidx.assign(n,-1);\n\t\tindex = 0;\n\t\tonstack.assign(n,0);\n\t\tlowlink.assign(n,INF);\n\t\twhile(!s.empty()) s.pop();\n\t\tsccidx.assign(n,-1);\n\t\tscccnt = 0;\n\t\tvec.clear();\n\t\ttopo.clear();\n\t\tvec.resize(n);\n\t}\n\t\n\tvoid addedge(int u, int v) //u -> v\n\t{\n\t\tvec[u].pb(v);\n\t}\n\t\n\tvoid connect(int u)\n\t{\n\t\tidx[u] = index;\n\t\tlowlink[u] = index;\n\t\tindex++;\n\t\ts.push(u);\n\t\tonstack[u] = true;\n\t\tfor(int i = 0; i < vec[u].size(); i++)\n\t\t{\n\t\t\tint v = vec[u][i];\n\t\t\tif(idx[v] == -1)\n\t\t\t{\n\t\t\t\tconnect(v);\n\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v]);\n\t\t\t}\n\t\t\telse if(onstack[v])\n\t\t\t{\n\t\t\t\tlowlink[u] = min(lowlink[u], idx[v]);\n\t\t\t}\n\t\t}\n\t\tif(lowlink[u] == idx[u])\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tint v = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tonstack[v] = false;\n\t\t\t\tsccidx[v] = scccnt;\n\t\t\t\tif(v == u) break;\n\t\t\t}\n\t\t\tscccnt++;\n\t\t}\n\t}\n\t\n\tvoid tarjan()\n\t{\n\t\tfor(int i = 0; i < vec.size(); i++)\n\t\t{\n\t\t\tif(idx[i] == -1)\n\t\t\t{\n\t\t\t\tconnect(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid toposort() //if graph is a DAG and i just want to toposort\n\t{\n\t\ttarjan();\n\t\tint n = vec.size();\n\t\ttopo.resize(n);\n\t\tvector<ii> tmp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttmp.pb(mp(sccidx[i],i));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\treverse(tmp.begin(),tmp.end());\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ttopo[i]=tmp[i].se;\n\t\t\tif(i>0) assert(tmp[i].fi!=tmp[i-1].fi);\n\t\t}\n\t}\n};\ntypedef bitset<1001> b100;\n\nmap<ii,int> ma;\nvector<ii> adj[1111];\nint ans[222222];\nint mxscc=0;\nvector<ii> edges;\nvi G[1111];\nvector<ii> E[1111];\nint siz[1111];\nvi ADJ[1111];\nvoid computeE(int sccid)\n{\n\tvi coord;\n\tfor(int i=0;i<G[sccid].size();i++)\n\t{\n\t\tint lab=G[sccid][i];\n\t\tint u=edges[lab].fi; int v=edges[lab].se;\n\t\tcoord.pb(u); coord.pb(v);\n\t\tE[sccid].pb({u,v});\n\t}\n\tsort(coord.begin(),coord.end()); coord.erase(unique(coord.begin(),coord.end()),coord.end());\n\tfor(int i=0;i<E[sccid].size();i++)\n\t{\n\t\tE[sccid][i].fi=lower_bound(coord.begin(),coord.end(),E[sccid][i].fi)-coord.begin();\n\t\tE[sccid][i].se=lower_bound(coord.begin(),coord.end(),E[sccid][i].se)-coord.begin();\n\t}\n\tsiz[sccid]=coord.size();\n}\nvoid check_edge(int n, int sccid, int id)\n{\n\tif(id>200000)\n\t{\n\t\tSCC scc; scc.init(siz[sccid]);\n\t\tfor(int i=0;i<E[sccid].size();i++)\n\t\t{\n\t\t\tif(G[sccid][i]==id) scc.addedge(E[sccid][i].se,E[sccid][i].fi);\n\t\t\telse scc.addedge(E[sccid][i].fi,E[sccid][i].se);\n\t\t}\n\t\tscc.tarjan();\n\t\tassert(scc.scccnt==1);\n\t\treturn ;\n\t}\n\tint u=edges[id].fi; int vv=edges[id].se;\n\tqueue<int> q;\n\tb100 visited;\n\tq.push(u); visited.set(u,1);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front(); q.pop();\n\t\tif(visited[vv]) return ;\n\t\tfor(int v:ADJ[x])\n\t\t{\n\t\t\tif(x==u&&v==vv) continue;\n\t\t\tif(!visited[v])\n\t\t\t{\n\t\t\t\tvisited.set(v,1); q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(!visited[vv]) ans[id]=1;\n}\n\nbool visited[1111];\nint h[1111];\nint par[1111];\nvector<ii> T[1111];\nvi important;\nii backedge[1111];\nvoid dfs(int u)\n{\n\tvisited[u]=1;\n\tfor(ii x:T[u])\n\t{\n\t\tint v=x.fi;\n\t\tif(!visited[v])\n\t\t{\n\t\t\th[v]=h[u]+1; par[v]=u;\n\t\t\timportant.pb(x.se);\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\n\nvoid solve_scc(int n, int id)\n{\n\tif(G[id].empty()) return ;\n\timportant.clear();\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tT[i].clear();\n\t}\n\tint r=-1;\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].fi].pb(mp(edges[x].se,x));\n\t\tr=edges[x].fi;\n\t}\n\tdfs(r);\n\tmemset(visited,0,sizeof(visited));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tT[i].clear();\n\t}\n\tfor(int x:G[id])\n\t{\n\t\tT[edges[x].se].pb(mp(edges[x].fi,x));\n\t}\n\tdfs(r);\n\t/*\n\tint cur=847;\n\twhile(cur!=-1)\n\t{\n\t\tcerr<<cur<<\"(\"<<h[cur]<<\") \";\n\t\tcur=par[cur];\n\t}\n\tcerr<<'\\n';\n\tcerr<<h[534]<<' '<<h[847]<<' '<<backedge[534].fi<<' '<<h[backedge[534].fi]<<'\\n';\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(backedge[i].fi!=-1) important.pb(backedge[i].se);\n\t}\n\t*/\n\t/*\n\tcomputeE(id);\n\tcheck_edge(n,id,200001);\n\t*/\n\t//assert(important.size()<=2*siz[id]);\n\tfor(int x:important)\n\t{\n\t\t//if(x==144969){cerr<<\"YES\\n\";}\n\t\tcheck_edge(n,id,x);\n\t}\n}\nb100 reach[1111];\nmap<ii,int> CNT;\nb100 reach2[1111];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t//freopen(\"sep2_0.in\",\"r\",stdin); freopen(\"sep2_0.out\",\"w\",stdout);\n\tint n,m; cin>>n>>m;\n\tSCC scc; scc.init(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tscc.addedge(u,v);\n\t\tADJ[u].pb(v);\n\t\tma[mp(u,v)]=i;\n\t\tedges.pb({u,v});\n\t}\n\tscc.tarjan();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmxscc=max(mxscc,scc.sccidx[i]);\n\t}\n\tvector<int> candidates;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=edges[i].fi; int v=edges[i].se;\n\t\tint l = scc.sccidx[u];\n\t\tint r = scc.sccidx[v];\n\t\tif(l!=r)\n\t\t{\n\t\t\tadj[l].pb(mp(r,i));\n\t\t\tCNT[mp(l,r)]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tG[l].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]>1)\n\t\t\t{\n\t\t\t\tans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\treach[i].set(i,1);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\treach[i]|=reach[v];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(reach[i][j])\n\t\t\t{\n\t\t\t\treach2[j].set(i,1);\n\t\t\t}\n\t\t}\n\t\treach[i].set(i,0); reach2[i].set(i,0);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(ii x:adj[i])\n\t\t{\n\t\t\tint v=x.fi; int lab=x.se;\n\t\t\tif(CNT[mp(i,v)]==1)\n\t\t\t{\n\t\t\t\tif((reach[i]&reach2[v]).count()!=0) ans[lab]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsolve_scc(n,i);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcout<<(ans[i]?\"diff\":\"same\")<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\ntypedef unsigned long long ull;\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nvoid dfs(int k){\n\tif(k==D) return;\n\tvis[D][k]=1;\n\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k]){\n\t\tdfs(e[i].k);\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint o=vis[i][e[p].k];\n\t\t\ts[++top]=e[p].k;\n\t\t\tdfs(e[p].k);\n\t\t\tvis[i][e[p].k]=o;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>1;p--){\n\t\t\tdfs(s[p]);\n\t\t\tif(vis[i][s[1]]) break;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<bitset>\n#include<complex>\n#include<cmath>\nusing namespace std;\ntemplate<typename __T>\ninline void read(__T &x)\n{\n    x=0;\n    int f=1;char c=getchar();\n    while(!isdigit(c)){if(c=='-')\tf=-1;c=getchar();}\n    while(isdigit(c))\t{x=x*10+c-'0';c=getchar();}\n    x*=f;\n}\ntypedef pair<int,int> pi;\nint n,m;\nvector<pi>ed[1005];\nint u[200005],v[200005];\nint bel[1005][1005][2];\nbool vis[1005];\nvoid dfs(int now,int fa,int belid,int typ)\n{//cout<<\"GG\"<<now<<' '<<fa<<' '<<belid<<' '<<typ<<endl;\n\tbel[fa][now][typ]=belid;\n\tvis[now]=1;\n\tfor(int i=0;i<ed[now].size();i++)\n\t\tif(!vis[ed[now][i].first])\n\t\t\tdfs(ed[now][i].first,fa,belid,typ);\n}\nint main()\n{\n\tread(n);\n\tread(m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tread(u[i]);\n\t\tread(v[i]);\n\t\ted[u[i]].push_back(make_pair(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{//cout<<\"WORK\"<<i<<endl;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvis[i]=1;\n\t\tfor(int j=0;j<ed[i].size();j++)\n\t\t\tif(!vis[ed[i][j].first])\n\t\t\t\tdfs(ed[i][j].first,i,ed[i][j].second,0);\n\t\treverse(ed[i].begin(),ed[i].end());\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvis[i]=1;\n\t\tfor(int j=0;j<ed[i].size();j++)\n\t\t\tif(!vis[ed[i][j].first])\n\t\t\t\tdfs(ed[i][j].first,i,ed[i][j].second,1);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{//cout<<\"A\"<<u[i]<<' '<<v[i]<<' '<<bel[v[i]][u[i]][0]<<' '<<bel[u[i]][v[i]][0]<<' '<<bel[u[i]][v[i]][1]<<endl;\n\t\tif(bel[v[i]][u[i]][0]!=0 ^ (bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i))\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e3+20;\n\nstruct node {\n\tint v,next;\n};\nnode e[200020];\nint cnt,start[maxn];\ninline void addedge(int u,int v){ e[++cnt]=(node){v,start[u]};start[u]=cnt;}\n\nint n,m;\nint f[maxn][maxn];\nint rt,D;\nint g[maxn][maxn];\nint vis[maxn];\nint A[maxn],B[maxn];\nint graph[maxn][maxn];\n\nvoid dfs(int u)\n{\n\tf[rt][u]=1;\n\tEREP(i,u)\n\t{\n\t\tint v=e[i].v;\n\t\tif(f[rt][v])continue;\n\t\tdfs(v);\n\t}\n}\n\nstruct Edge {\n\tint u,v;\n};\nEdge E[200020];\n\nvoid dfs1(int u)\n{\n\tvis[u]=D;\n\tEREP(i,u)\n\t{\n\t\tint v=e[i].v;\n\t\tif(vis[v])continue;\n\t\tdfs1(v);\n\t}\n}\n\ninline void init()\n{\n\tn=read(); m=read();\n\tREP(i,1,m)\n\t{\n\t\tint u=read(),v=read();\n\t\tE[i]=(Edge){u,v};\n\t\taddedge(u,v);\n\t\tgraph[u][v]=1;\n\t}\n\tREP(u,1,n)\n\t{\n\t\trt=u;\n\t\tdfs(u);\n\t}\n\tREP(u,1,n)\n\t{\n\t\tstatic int st[maxn],top; top=0;\n\t\tEREP(i,u)st[++top]=e[i].v;\n\t\tmemset(vis,0,sizeof(int)*(n+1));\n\t\tvis[u]=top+1;\n\t\tREP(j,1,top)\n\t\t{\n\t\t\tD=j;\n\t\t\tif(!vis[st[j]])dfs1(st[j]);\n\t\t}\n\t\tmemcpy(A,vis,sizeof(int)*(n+1));\n\t\tmemset(vis,0,sizeof(int)*(n+1));\n\t\tvis[u]=top+1;\n\t\tDREP(j,top,1)\n\t\t{\n\t\t\tD=j;\n\t\t\tif(!vis[st[j]])dfs1(st[j]);\n\t\t}\n\t\tmemcpy(B,vis,sizeof(int)*(n+1));\n\t\tREP(j,1,top)if(A[st[j]]!=B[st[j]])g[u][st[j]]=1;\n\t\t\n\t}\n}\n\ninline void doing()\n{\n\tREP(i,1,m)\n\t{\n\t\tint u=E[i].u,v=E[i].v;\n\t\tif(f[v][u]^(g[u][v]))puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}\n\nint main()\n{\n#endif\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//HEAD_OF_CONFIG_\n\nstatic const int MOD=1000000007; //1000000000000000003LL\nstatic const double eps=1e-8;\n\n//TAIL_OF_CONFIG_\n\n//[HEAD_OF_JKI'S_HEADER_\n\n    //TYPEDEF\n    typedef long long lld;\n    typedef unsigned long long u64;\n    typedef pair<int, int> pii;\n\n    //COMPARE\n    template<class T> inline T MIN(const T x, const T y){ return (x<y)?x:y; }\n    template<class T> inline T MAX(const T x, const T y){ return (x>y)?x:y; }\n\n    template<class T> inline void UPDMIN(T &x, const T y){ if(x>y)x=y; }\n    template<class T> inline void UPDMAX(T &x, const T y){ if(x<y)x=y; }\n\n    //STL\n    template<class T>  inline int SIZE(const T &x){ return (int)x.size(); }\n    template<class T>  inline int LENGTH(const T &x){ return (int)x.length(); }\n    template<class T1, class T2> inline pair<T1, T2> MP(const T1 &x, const T2 &y){ return make_pair(x, y); }\n\n    //BIT\n    inline int BINT(const int x){ return 1<<x; }\n    inline lld BLLD(const int x){ return 1LL<<x; }\n    inline int BINT_TEST(const int s, const int x){ return (s&BINT(x))!=0; }\n    inline int BLLD_TEST(const lld s, const int x){ return (s&BLLD(x))!=0LL; }\n\n    template<class T> inline T LOWBIT(const T x){ return (x^(x-1))&x; }\n    template<class T> inline int BITCOUNT(const T x){ return (!x)?x:(1+BITCOUNT(x&(x-1))); }\n\n    //CONST VALUE\n    const double PI=acos(-1.0);\n    const double EPS=1e-5;\n\n    //CALCULATE\n    template<class T> inline T SQR(const T x){ return x*x; }\n    template<class T1, class T2> inline T1 POW(const T1 x, const T2 y){\n        if(!y)return 1;else if((y&1)==0){\n            return SQR(POW(x, y>>1));\n        }else return POW(x, y^1)*x;\n    }\n\n    //NUMBERIC\n    template<class T> inline T GCD(const T x, const T y){\n        if(x<0)return GCD(-x, y);\n        if(y<0)return GCD(x, -y);\n        return (!y)?x:GCD(y, x%y);\n    }\n    template<class T> inline T LCM(const T x, const T y){\n        if(x<0)return LCM(-x, y);\n        if(y<0)return LCM(x, -y);\n        return x*(y/GCD(x, y));\n    }\n    template<class T> inline T EEA(const T a, const T b, T &x, T &y){\n        /* a*x+b*y == GCD(a, b) == EEA(a, b, x, y) */\n        if(a<0){ T d=EEA(-a, b, x, y); x=-x; return d; }\n        if(b<0){ T d=EEA(a, -b, x, y); y=-y; return d; }\n        if(!b){\n            x=1; y=0; return a;\n        }else{\n            T d=EEA(b, a%b, x, y);\n            T t=x; x=y; y=t-(a/b)*y;\n            return d;\n        }\n    }\n    template<class T> inline vector<pair<T, int> > FACTORIZE(T x){\n        vector<pair<T, int> > ret;\n        if(x<0)x=-x;\n        for (T i=2;x>1;){\n            if(x%i==0){\n                int count=0;\n                for(;x%i==0;x/=i)count++;\n                ret.push_back(MP(i, count));\n            }\n            i++;if(i>x/i)i=x;\n        }\n        return ret;\n    }\n    template<class T> inline int ISPRIME(const T x){\n        if(x<=1)return 0;\n        for(T i=2; SQR(i)<=x; i++)if(x%i==0)return 0;\n        return 1;\n    }\n    template<class T> inline T EULARFUNCTION(T x){\n        vector<pair<T, int> > f=FACTORIZE(x);\n        for(typename vector<pair<T, int> >::iterator it=f.begin(); it!=f.end(); it++){\n            x=x/it->first*(it->first-1);\n        }\n        return x;\n    }\n    template<class T> inline T INVERSEE(const T a, const T b=MOD){\n        T x, y;\n        EEA(a, b, x, y);\n        return x?x:1;\n    }\n    int *PRIMELIST(const int til, int *length=NULL){\n        int *foo=(int*)malloc(sizeof(int)*(til+1));\n        int len=0;\n        memset(foo, 0, sizeof(int)*(til+1));\n        for(int i=2; i<=til; i++){\n            if(!foo[i])foo[len++]=i;\n            for(int j=0; j<len && foo[j]<=til/i; j++){\n                foo[foo[j]*i]=1;\n                if(i%foo[j]==0)break;\n            }\n        }\n        if(length!=NULL){\n            *length=len;\n        }\n        foo[len++]=0;\n        foo=(int*)realloc(foo, sizeof(int)*len);\n        return foo;\n    }\n\n    //REMINDER-LIZATION\n    template<class T> inline T MOD_STD(const T x, const T m=MOD){ return (x%m+m)%m; }\n    template<class T> inline void MOD_STD(T *x, const T m=MOD){ *x=(*x%m+m)%m; }\n    template<class T> inline T MOD_ADD(const T x, const T y, const T m=MOD){ return (x+y)%m; }\n    template<class T> inline void MOD_ADD(T *x, const T y, const T m=MOD){ *x=(*x+y)%m; }\n    template<class T> inline T MOD_MUL(const T x, const T y, const T m=MOD){ return (T)((1LL*x*y)%m); }\n    template<class T> inline void MOD_MUL(T *x, const T y, const T m=MOD){ *x=(T)((1LL*(*x)*y)%m); }\n    template<class T1, class T2> inline T1 MOD_POW(const T1 x, const T2 y, const T1 m=MOD){\n        if(y==0)return 1%m;else if((y&1)==0){\n            T1 z=MOD_POW(x, y>>1, m); return MOD_MUL(z, z, m);\n        }else return MOD_MUL(MOD_POW(x, y^1, m), x, m);\n    }\n    inline lld MODL_MUL(lld x, lld y, const lld m=MOD){\n        MOD_STD(&x, m);\n        MOD_STD(&y, m);\n        if(x<y)swap(x, y);\n        lld z=0LL;\n        while(y>0){\n            if(y&1){\n                MOD_ADD(&z, x, m);\n            }\n            MOD_ADD(&x, x, m);\n            y>>=1;\n        }\n        return z;\n    }\n    inline lld MODL_POW(const lld x, const lld y, const lld m=MOD){\n        if(y==0LL)return 1LL%m;else if((y&1)==0LL){\n            lld z=MODL_POW(x, y>>1, m); return MODL_MUL(z, z, m);\n        }else return MODL_MUL(MODL_POW(x, y^1, m), x, m);\n    }\n\n    //General\n    template<class T> class cycleq_t{\n        private:\n        size_t cnt, cap;\n        size_t lef, rig;\n        T *que;\n        public:\n        cycleq_t(const size_t size){\n            this->cap=size;\n            this->que=(T*)malloc(sizeof(T)*size);\n            this->clear();\n        }\n        ~cycleq_t(){\n            free(this->que);\n        }\n        inline void clear(){\n            this->lef=this->rig=0;\n            this->cnt=0;\n        }\n        inline void put(const T &obj){\n            assert(this->cnt<this->cap);\n            this->que[this->rig++]=obj;\n            if(this->rig==this->cap)\n                this->rig=0;\n            this->cnt++;\n        }\n        inline void put_back(const T &obj){\n            this->put(obj);\n        }\n        inline void put_front(const T &obj){\n            assert(this->cnt<this->cap);\n            this->lef--;\n            if(!~this->lef)\n                this->lef=this->cap-1;\n            this->que[this->lef]=obj;\n            this->cnt++;\n        }\n        inline T pop(){\n            assert(this->cnt>0);\n            T res=this->que[this->lef++];\n            if(this->lef==this->cap)\n                this->lef=0;\n            this->cnt--;\n            return res;\n        }\n        inline T pop_front(){\n            return this->pop();\n        }\n        inline T pop_back(){\n            assert(this->cnt>0);\n            this->rig--;\n            if(!~this->rig)\n                this->rig=this->cap-1;\n            this->cnt--;\n            return this->que[this->rig];\n        }\n        inline T get(int64_t offset=0){\n            if(offset>=0){\n                assert(offset<this->cnt);\n                offset+=this->lef;\n                if(offset>this->cap)\n                    offset-=this->cap;\n                return this->que[offset];\n            }else{\n                assert(offset>=-this->cnt);\n                offset+=this->rig;\n                if(offset<0)\n                    offset+=this->cap;\n                return this->que[offset];\n            }\n        }\n    };\n\n    //MATRIX\n    template<class T> class MATX{\n        private:\n            unsigned long hig, wid;\n            T *data;\n\n            void __init(){\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                memset(this->data, 0, sizeof(T)*this->hig*this->wid);\n            }\n\n        public:\n            MATX(){ \n                this->hig=this->wid=1;\n                __init();\n            }\n            MATX(const unsigned long _len){\n                this->hig=this->wid=_len;\n                __init();\n            }\n            MATX(const unsigned long _hig, const unsigned long _wid){\n                this->hig=_hig;\n                this->wid=_wid;\n                __init();\n            }\n            MATX(const MATX &rhs){\n                this->hig=rhs.hig;\n                this->wid=rhs.wid;\n                this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n            }\n            ~MATX(){\n                free(this->data);\n            }\n\n            T & operator()(const unsigned long x, const unsigned long y){\n                if(x>=this->hig || y>=this->wid)return (*(T*)NULL);\n                return this->data[x*this->wid+y];\n            }\n\n            T * operator[](const unsigned long x){\n                if(x>=this->hig)return (T*)NULL;\n                return this->data+(x*this->wid);\n            }\n\n            MATX & operator=(const MATX &rhs){\n                if(this->hig!=rhs.hig || this->wid!=rhs.wid){\n                    free(this->data);\n                    this->hig=rhs.hig;\n                    this->wid=rhs.wid;\n                    this->data=(T*)malloc(sizeof(T)*this->hig*this->wid);\n                }\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=rhs.at(x, y);\n                return *this;\n            }\n\n            const MATX operator+(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]+=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator-(const MATX &opn) const{\n                MATX ret(*this);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        ret.data[x*ret.wid+y]-=opn.at(x, y);\n                return ret;\n            }\n            const MATX operator*(const MATX &opn) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.hig);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            ret.data[x*ret.wid+y]+=this->at(x, z)*opn.at(z, y);\n                return ret;\n            }\n\n            const MATX mul(const MATX &opn) const{ return *this*opn; }\n            template<class T2> const MATX mul(const MATX &opn, const T2 m) const{\n                MATX ret(this->hig, opn.wid);\n                const unsigned long len=MIN(this->wid, opn.wid);\n                for(unsigned long x=0; x<ret.hig; x++)\n                    for(unsigned long y=0; y<ret.wid; y++)\n                        for(unsigned long z=0; z<len; z++)\n                            MOD_ADD(&ret.data[x*ret.wid+y], MOD_MUL(this->at(x, z), opn.at(z, y), m), m);\n                return ret;\n            }\n\n            MATX & operator +=(const MATX &rhs){\n                *this=*this+rhs;\n                return *this;\n            }\n            MATX & operator -=(const MATX &rhs){\n                *this=*this-rhs;\n                return *this;\n            }\n            MATX & operator *=(const MATX &rhs){\n                *this=*this*rhs;\n                return *this;\n            }\n\n            const MATX pow(const unsigned long p) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret*=buff;\n                    buff*=buff;\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n            template<class T2> const MATX pow(const unsigned long p, const T2 m) const{\n                MATX buff(*this), ret(this->hig, this->wid);\n                ret.set_one();\n                if(p>0)for(unsigned long i=1;;i<<=1){\n                    if(p&i)ret=ret.mul(buff, m);\n                    buff=buff.mul(buff, m);\n                    if(i>(p>>1))break;\n                }\n                return ret;\n            }\n\n\n            const T at(const unsigned long x, const unsigned long y) const{\n                if(x>=this->hig || y>=this->wid)return 0;\n                return this->data[x*wid+y];\n            }\n\n            void show() const{\n                for(unsigned long x=0; x<this->hig; x++){\n                    for(unsigned long y=0; y<this->wid; y++)\n                        cout<<this->at(x, y)<<\" \";\n                    cout<<endl;\n                }\n            }\n\n            void set_one(){\n                for(unsigned long x=0; x<this->hig; x++)\n                    for(unsigned long y=0; y<this->wid; y++)\n                        this->data[x*this->wid+y]=(x==y)?1:0;\n            }\n\n    };\n\n    //Complex\n    template<class T> class complex_t{\n        public:\n        T r, i;//real part & imaginary part; x+yi\n        complex_t(T x=0.0, T y=0.0){ this->r=x; this->i=y; }\n        complex_t operator + (const complex_t &opn) const { return complex_t(this->r+opn.r, this->i+opn.i); }\n        complex_t operator - (const complex_t &opn) const { return complex_t(this->r-opn.r, this->i-opn.i); }\n        complex_t operator * (const complex_t &opn) const { return complex_t(this->r*opn.r-this->i*opn.i, this->r*opn.i+this->i*opn.r); }\n    };\n\n    template<class T> void fast_fourier_trans(complex_t<T> f[], const int len, const int is_dft){\n        for(int i=1, j=len>>1; i<len-1; i++){\n            if(i<j)swap(f[i], f[j]);\n            int k=len>>1;\n            while(j>=k){\n                j-=k;\n                k>>=1;\n            }\n            if(j<k)j+=k;\n        }\n        for(int h=2; h<=len; h<<=1){\n            complex_t<T> wn(cos(is_dft?(-2*PI/h):(2*PI/h)), sin(is_dft?(-2*PI/h):(2*PI/h)));\n            for(int i=0; i<len; i+=h){\n                complex_t<T> wm(1.0, 0.0);\n                for(int j=i; j<i+(h>>1); j++){\n                    complex_t<T> u = f[j];\n                    complex_t<T> t = wm*f[j+(h>>1)];\n                    f[j] = u+t;\n                    f[j+(h>>1)] = u-t;\n                    wm = wm*wn;\n                }\n            }\n        }\n        if(!is_dft){\n            for(int i=0; i<len; i++)\n                f[i].r/=len*1.0;\n        }\n    }\n\n    //MILLERRABIN\n    class MILLERRABIN{\n        private:\n        static const int prime_table[12];\n        int witness(lld a, lld d, lld s, lld n){\n            lld r=MODL_POW(a, d, n);\n            if(r==1 || r==n-1)return 0;\n            for(int i=0; i<s-1; i++){\n                r = MODL_MUL(r, r, n);\n                if(r==1)return 1;\n                if(r==n-1)return 0;\n            }\n            return 1;\n        }\n        public:\n        int test(const lld n){\n            if(n<=2LL) return 0;\n            lld p=n-1LL, s=0LL;\n            while(!(p&1)){ p>>=1;s++; }\n            for(int i=0; i<12 && this->prime_table[i]<n; i++){\n                if(witness(this->prime_table[i], p, s, n))return 0;\n            }\n            return 1;\n        }\n    };\n    const int MILLERRABIN::prime_table[12] = { 2, 3, 5, 7, 11, 13 ,17, 19, 23, 29, 31, 37 };\n\n    //Computational Geometry\n\n    template<class T> inline int fsign(const T x){\n        if(x>-eps && x<eps)return 0;\n        return (x<0.0)?-1:1;\n    }\n\n    template<class T> class point_t{\n        public:\n        T x, y;\n        point_t (){\n            this->x=0.0;\n            this->y=0.0;\n        }\n        point_t (const T _x, const T _y){\n            this->x=_x;\n            this->y=_y;\n        }\n        point_t operator - (const point_t &rhs) const{\n            return point_t(this->x-rhs.x, this->y-rhs.y);\n        }\n        T operator ^ (const point_t &rhs) const{\n            return this->x*rhs.y - this->y*rhs.x;\n        }\n        T operator * (const point_t &rhs) const{\n            return this->x*rhs.x + this->y*rhs.y;\n        }\n        bool operator < (const point_t &rhs) const{\n            if(fsign(this->y-rhs.y)!=0)\n                return fsign(this->y-rhs.y)<0;\n            return fsign(this->x-rhs.x)<0;\n        }\n        T cross(const point_t &p, const point_t &q) const{\n            return (p-*this)^(q-*this);\n        }\n        void rotate(const double radian){\n            T x0=x, y0=y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr;\n            y=x0*sinr+y0*cosr;\n        }\n        void rotate(const point_t &p, const double radian){\n            T x0=x-p.x, y0=y-p.y;\n            T sinr=sin(radian);\n            T cosr=cos(radian);\n            x=x0*cosr-y0*sinr+p.x;\n            y=x0*sinr+y0*cosr+p.y;\n        }\n        T dist2(const point_t &lhs, const point_t &rhs) const{\n            return (lhs-rhs)*(lhs-rhs);\n        }\n        T dist2(const point_t &rhs) const{\n            return (*this-rhs)*(*this-rhs);\n        }\n        T dist(const point_t &lhs, const point_t &rhs) const{\n            return sqrt((lhs-rhs)*(lhs-rhs));\n        }\n        T dist(const point_t &rhs) const{\n            return sqrt((*this-rhs)*(*this-rhs));\n        }\n    };\n\n    template<class T> class segment_t{\n        public:\n        point_t<T> p, q;\n        segment_t (){\n            this->p.x=this->p.y=0.0;\n            this->q.x=this->q.y=0.0;\n        }\n        template<class T2> segment_t (const point_t<T2> &_p, const point_t<T2> &_q){\n            this->p.x=_p.x;\n            this->p.y=_p.y;\n            this->q.x=_q.x;\n            this->q.y=_q.y;\n        }\n        segment_t (const T px, const T py, const T qx, const T qy){\n            this->p.x=px;\n            this->p.y=py;\n            this->q.x=qx;\n            this->q.y=qy;\n        }\n        T length() const{\n            return this->p.dist(this->q);\n        }\n        T length2() const{\n            return this->p.dist2(this->q);\n        }\n        int contain(const point_t<T> &pnt, const int ignore_endpoint=0) const{\n            if(ignore_endpoint){\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <0;\n            }else{\n                return fsign((this->p-pnt)^(this->q-pnt))==0\n                    && fsign((pnt.x-this->p.x)*(pnt.x-this->q.x)) <=0\n                    && fsign((pnt.y-this->p.y)*(pnt.y-this->q.y)) <=0;\n            }\n        }\n        int intersection(const segment_t &sa, const segment_t &sb, const int ignore_endpoint=0) const{\n            if(!ignore_endpoint){\n                if(sa.contain(sb.p) || sa.contain(sb.q) || sb.contain(sa.p) || sb.contain(sa.q))\n                    return 1;\n            }\n            return fsign(sa.p.cross(sa.q, sb.p))*fsign(sa.p.cross(sa.q, sb.q))<0\n                && fsign(sb.p.cross(sb.q, sa.p))*fsign(sb.p.cross(sb.q, sa.q))<0;\n        }\n        int intersection(const segment_t &rhs, const int ignore_endpoint=0) const{\n            return this->intersection(*this, rhs, ignore_endpoint);\n        }\n    };\n\n    #ifndef __APPLE__\n    template<class T> static int compare_pas(const void *x, const void *y, void *z){\n    #else\n    template<class T> static int compare_pas(void *z, const void *x, const void *y){\n    #endif\n        const point_t<T> *p1 = (point_t<T>*)x;\n        const point_t<T> *p2 = (point_t<T>*)y;\n        const point_t<T> *p0 = (point_t<T>*)z;\n        int sgn = fsign(((*p1)-(*p0))^((*p2)-(*p0)));\n        if(sgn!=0)return -sgn;\n        return fsign(p0->dist2(*p1)-p0->dist2(*p2));\n    }\n    template<class T> void polar_angle_sort(point_t<T> *pnts, const int n){\n        int p=0;\n        for(int i=1; i<n; i++){\n            if(pnts[p]<pnts[i])p=i;\n        }\n        swap(pnts[0], pnts[p]);\n        #ifndef __APPLE__\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), compare_pas<T>, pnts);\n        #else\n        qsort_r(pnts+1, n-1, sizeof(point_t<T>), pnts, compare_pas<T>);\n        #endif\n    }\n\n    template<class T> void graham(point_t<T> *pnts, const int n, int *idx, int &m){\n        polar_angle_sort(pnts, n);\n        m=0;\n        if(n<3)return;\n        idx[m++]=0;\n        idx[m++]=1;\n        for(int i=2; i<n; i++){\n            while(m>1 && fsign(pnts[idx[m-2]].cross(pnts[idx[m-1]], pnts[i]))<=0)m--;\n            idx[m++]=i;\n        }\n    }\n\n    //Graph\n    template<class T> class maxflow_c{\n        private:\n        size_t capv, cape;\n        size_t cntv, cnte;\n        struct mf_edge_t;\n        struct mf_vertex_t{\n            mf_edge_t *head, *hold;\n            size_t idx, hig;\n        } *vertex, **vhead, **vtail, **vque;\n        struct mf_edge_t{\n            mf_vertex_t *src, *dst;\n            mf_edge_t *nxt, *rsv;\n            T cap, cur;\n        } *edge_pool, *edge_tail, **esup;\n        struct dncnode_t{\n            mf_vertex_t *vtx;\n            T precap, reflux;\n        } *dinic_stack_pool;\n        size_t *dcnt;\n        size_t higlev(size_t src, size_t trm, const int reverse=0){\n            if(reverse)\n                swap(src, trm);\n            if(this->vque==NULL)\n                this->vque=(mf_vertex_t**)malloc(sizeof(mf_vertex_t*)*this->capv);\n            size_t lef=0, rig=0;\n            for(mf_vertex_t **vtxp=this->vhead; vtxp!=this->vtail; vtxp++)\n                (*vtxp)->hig=numeric_limits<size_t>::max();\n            this->vertex[src].hig=0;\n            this->vque[rig++]=&this->vertex[src];\n            this->vertex[trm].hig=numeric_limits<size_t>::max();\n            for(; lef<rig; lef++){\n                mf_vertex_t *vtx=this->vque[lef];\n                for(mf_edge_t *edge=vtx->head; edge!=NULL; edge=edge->nxt){\n                    if(!reverse){\n                        if(edge->cur<edge->cap && edge->dst->hig>vtx->hig+1){\n                            edge->dst->hig=vtx->hig+1;\n                            this->vque[rig++]=edge->dst;\n                        }\n                    }else{\n                        if(edge->rsv->cur<edge->rsv->cap && edge->dst->hig>vtx->hig+1){\n                            edge->dst->hig=vtx->hig+1;\n                            this->vque[rig++]=edge->dst;\n                        }\n                    }\n                }\n            }\n            this->vque[rig++]=NULL;\n            return this->vertex[trm].hig;\n        }\n        T isap_augment(const size_t src, const size_t trm){\n            T inc=numeric_limits<T>::max();\n            for(size_t i=trm; i!=src; i=this->esup[i]->src->idx){\n                UPDMIN(inc, this->esup[i]->cap-this->esup[i]->cur);\n            }\n            for(size_t i=trm; i!=src; i=this->esup[i]->src->idx){\n                this->esup[i]->cur+=inc;\n                this->esup[i]->rsv->cur-=inc;\n            }\n            return inc;\n        }\n        size_t isap_retreat(size_t &i, const size_t src){\n            size_t best=numeric_limits<size_t>::max();\n            for(mf_edge_t *edge=this->vertex[i].head; edge!=NULL; edge=edge->nxt){\n                if(edge->cur<edge->cap){\n                    UPDMIN(best, edge->dst->hig+1);\n                }\n            }\n            size_t rep=--this->dcnt[this->vertex[i].hig];\n            this->vertex[i].hig=best;\n            if(best<this->cntv){\n                this->dcnt[best]++;\n            }\n            if(i!=src)\n                i=this->esup[i]->src->idx;\n            return rep;\n        }\n        public:\n        maxflow_c(const size_t numv, const size_t nume){\n            this->capv=numv;\n            this->cape=nume;\n            this->vertex=(mf_vertex_t*)malloc(sizeof(mf_vertex_t)*numv);\n            for(size_t i=0; i<numv; i++){\n                this->vertex[i].idx=i;\n            }\n            this->vhead=(mf_vertex_t**)malloc(sizeof(mf_vertex_t*)*numv);\n            this->vtail=this->vhead;\n            this->vque=NULL;\n            this->edge_pool=(mf_edge_t*)malloc(sizeof(mf_edge_t)*(nume<<1));\n            this->dinic_stack_pool=NULL;\n            this->esup=NULL;\n            this->dcnt=NULL;\n            this->reset();\n        };\n        ~maxflow_c(){\n            if(this->dcnt!=NULL)\n                free(this->dcnt);\n            if(this->esup!=NULL)\n                free(this->esup);\n            if(this->dinic_stack_pool!=NULL)\n                free(this->dinic_stack_pool);\n            free(this->edge_pool);\n            if(this->vque!=NULL)\n                free(this->vque);\n            free(this->vhead);\n            free(this->vertex);\n        }\n        void reset(){\n            for(size_t i=0; i<this->capv; i++)\n                this->vertex[i].head=NULL;\n            this->vtail=this->vhead;\n            this->edge_tail=this->edge_pool;\n            this->cntv=0;\n            this->cnte=0;\n        }\n        void add_edge(const size_t u, const size_t v, const T c, const T r=0){\n            assert(u<this->capv && v<this->capv);\n            assert(this->cnte<this->cape);\n            this->edge_tail->nxt=this->vertex[u].head;\n            this->edge_tail->rsv=this->edge_tail+1;\n            this->edge_tail->src=&this->vertex[u];\n            this->edge_tail->dst=&this->vertex[v];\n            this->edge_tail->cap=c;\n            this->edge_tail->cur=0;\n            if(this->vertex[u].head==NULL){\n                *this->vtail++=&this->vertex[u];\n                this->cntv++;\n            }\n            this->vertex[u].head=this->edge_tail++;\n            this->edge_tail->nxt=this->vertex[v].head;\n            this->edge_tail->rsv=this->edge_tail-1;\n            this->edge_tail->src=&this->vertex[v];\n            this->edge_tail->dst=&this->vertex[u];\n            this->edge_tail->cap=r;\n            this->edge_tail->cur=0;\n            if(this->vertex[v].head==NULL){\n                *this->vtail++=&this->vertex[v];\n                this->cntv++;\n            }\n            this->vertex[v].head=this->edge_tail++;\n            this->cnte++;\n        }\n        T dinic(const size_t src, const size_t trm){\n            assert(src<this->capv && trm<this->capv && src!=trm);\n            T foo=0;\n            if(this->dinic_stack_pool==NULL)\n                this->dinic_stack_pool=(dncnode_t*)malloc(sizeof(dncnode_t)*this->capv);\n            while(higlev(src, trm)<numeric_limits<size_t>::max()){\n                for(size_t i=0; this->vque[i]!=NULL; i++){\n                    this->vque[i]->hold=this->vque[i]->head;\n                }\n                dncnode_t *top=this->dinic_stack_pool;\n                top->vtx=&this->vertex[src];\n                top->precap=numeric_limits<T>::max();\n                top->reflux=0;\n                while(this->vertex[src].hold!=NULL){\n                    if(top->vtx->idx!=trm && top->vtx->hold!=NULL && top->vtx->hold->cur<top->vtx->hold->cap && top->vtx->hold->src->hig+1==top->vtx->hold->dst->hig){\n                        dncnode_t *prv=top++;\n                        top->vtx=prv->vtx->hold->dst;\n                        top->precap=MIN(prv->precap-prv->reflux, prv->vtx->hold->cap-prv->vtx->hold->cur);\n                        top->reflux=0;\n                    }else if(top->vtx->idx==trm){\n                        T inc=top->precap;\n                        foo+=inc;\n                        while(top->precap==top->reflux+inc){\n                            inc+=top->reflux;\n                            top--;\n                            top->vtx->hold->cur+=inc;\n                            top->vtx->hold->rsv->cur-=inc;\n                        }\n                        top->reflux+=inc;\n                    }else{\n                        if(top->vtx->hold==NULL){\n                            T ref=top->reflux;\n                            top--;\n                            top->vtx->hold->cur+=ref;\n                            top->vtx->hold->rsv->cur-=ref;\n                            top->reflux+=ref;\n                        }\n                        top->vtx->hold=top->vtx->hold->nxt;\n                    }\n                }\n            }\n            return foo;\n        }\n        T isap(const size_t src, const size_t trm){\n            assert(src<this->capv && trm<this->capv && src!=trm);\n            T foo=0;\n            if(higlev(src, trm, 1)<numeric_limits<size_t>::max()){\n                if(this->dcnt==NULL)this->dcnt=(size_t*)malloc(sizeof(size_t)*this->capv);\n                if(this->esup==NULL)this->esup=(mf_edge_t**)malloc(sizeof(mf_edge_t*)*this->capv);\n                for(size_t i=0; i<this->cntv; i++)this->dcnt[i]=0;\n                for(size_t i=0; this->vque[i]!=NULL; i++){\n                    this->vque[i]->hold=this->vque[i]->head;\n                    this->dcnt[this->vque[i]->hig]++;\n                }\n                size_t i=src;\n                while(this->vertex[src].hig<this->cntv){\n                    mf_edge_t *edge=this->vertex[i].hold;\n                    while(edge!=NULL && !(edge->cur<edge->cap && edge->src->hig==edge->dst->hig+1)){\n                        edge=edge->nxt;\n                    }\n                    if(edge!=NULL){\n                        this->vertex[i].hold=edge;\n                        this->esup[edge->dst->idx]=edge;\n                        i=edge->dst->idx;\n                        if(i==trm){\n                            foo+=isap_augment(src, trm);\n                            i=src;\n                        }\n                    }else{\n                        this->vertex[i].hold=this->vertex[i].head;\n                        if(isap_retreat(i, src)==0)\n                            break;\n                    }\n                }\n            }\n            return foo;\n        }\n    };\n\n//]TAIL_OF_JKI'S_HEADER\n\nconst int inf=0x3f3f3f3f;\n\nint n, m;\nint a[210000];\nint e[1024][1024];\nint c[1024][1024];\nint nbs[1024], nxt[210000], prv[210000], dst[210000], eid;\nint low[1024], hig[1024];\n\nvoid add_edge(const int u, const int v){\n    nxt[eid]=nbs[u]; \n    prv[eid]=-1;\n    if(~nbs[u])prv[nbs[u]]=eid;\n    dst[eid]=v;\n    nbs[u]=eid++;\n}\n\nvoid dyeing(const int u, int *f, const int c){\n    if(!~f[u]){\n        f[u]=c;\n        for(int i=nbs[u]; ~i; i=nxt[i]){\n            dyeing(dst[i], f, c);\n        }\n    }\n}\n\nint main(){\n    while(scanf(\"%d%d\", &n, &m)!=EOF){\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                e[i][j]=-1;\n            }\n        }\n        for(int i=0; i<m; i++){\n            int u, v;\n            scanf(\"%d%d\", &u, &v);\n            e[u-1][v-1]=i;\n        }\n        memset(nbs, 0xff, sizeof(nbs));eid=0;\n        for(int u=n-1; ~u; u--){\n            for(int v=n-1; ~v; v--){\n                if(~e[u][v]){\n                    add_edge(u, v);\n                }\n            }\n        }\n        for(int u=0; u<n; u++){\n            for(int v=0; v<n; v++){\n                c[u][v]=-1;\n            }\n        }\n        for(int u=0; u<n; u++){\n            dyeing(u, c[u], u);\n        }\n        for(int i=0; i<m; i++)a[i]=0;\n        for(int u=0; u<n; u++){\n            for(int v=0; v<n; v++)low[v]=hig[v]=-1;\n            low[u]=hig[u]=inf;\n            int tail=-1;\n            for(int i=nbs[u]; ~i; i=nxt[i]){\n                dyeing(dst[i], low, e[u][dst[i]]);\n                tail=i;\n            }\n            for(int i=tail; ~i; i=prv[i]){\n                dyeing(dst[i], hig, e[u][dst[i]]);\n                tail=i;\n            }\n            for(int i=nbs[u]; ~i; i=nxt[i]){\n                if(low[dst[i]]!=e[u][dst[i]] || hig[dst[i]]!=e[u][dst[i]]){\n                    a[e[u][dst[i]]]=1;\n                }\n            }\n        }\n        for(int u=0; u<n; u++){\n            for(int v=0; v<n; v++){\n                if(!~e[u][v])continue;\n                if(~c[v][u])a[e[u][v]]^=1;\n            }\n        }\n        for(int i=0; i<m; i++){\n            if(!a[i]){\n                printf(\"same\\n\");\n            }else{\n                printf(\"diff\\n\");\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nauto rd=read<int>;\nconst int N=1000, M=2e5;\ntypedef unsigned long long u64;\nstruct Bitset {\n\tu64 v[16];\n\tbool test(int i) {return v[i>>6]>>(i&63)&1;}\n\tvoid set(int i) {v[i>>6]|=1llu<<(i&63);}\n\tvoid reset(int i) {v[i>>6]&=~(1llu<<(i&63));}\n\tvoid reset() {memset(v, 0, sizeof(v));}\n\tint lb() {\n\t\tfor(int i=0; i<16; ++i) if(v[i]) return i*64+__builtin_clzll(v[i]);\n\t\treturn -1;\n\t}\n};\nint n, m, a[M], b[M], head[N], next[M], rhead[N], rnext[M];\nint queue[N], *qhead, *qtail, min[N], max[N];\nbool rev[M], without[M];\nBitset e[N], vis;\nBitset work(const Bitset &a, const Bitset &b) {\n\tBitset res;\n#define WORK(i) res.v[i]=a.v[i]&~b.v[i];\n\tWORK(0) WORK(1) WORK(2) WORK(3)\n\tWORK(4) WORK(5) WORK(6) WORK(7)\n\tWORK(8) WORK(9) WORK(10)WORK(11)\n\tWORK(12)WORK(13)WORK(14)WORK(15)\n#undef WORK\n\treturn res;\n}\nvoid bfs(int u) {\n\tqhead=qtail=queue;\n\tif(vis.test(u)) return;\n\tvis.set(*qtail++=u);\n\twhile(qhead!=qtail) {\n\t\tu=*qhead++;\n\t\tfor(int i=0; i<16; ++i)\n\t\t\tfor(u64 j=e[u].v[i]&~vis.v[i]; j; j&=j-1)\n\t\t\t\tvis.set(*qtail++=i*64+__builtin_ctzll(j));\n\t}\n}\nint main() {\n\tn=rd(), m=rd();\n\tmemset(head, -1, n*sizeof(int));\n\tmemset(rhead, -1, n*sizeof(int));\n\tfor(int i=0; i<m; ++i) {\n\t\ta[i]=rd()-1, b[i]=rd()-1;\n\t\tnext[i]=head[a[i]];\n\t\thead[a[i]]=i;\n\t\trnext[i]=rhead[b[i]];\n\t\trhead[b[i]]=i;\n\t\te[a[i]].set(b[i]);\n\t}\n\tfor(int i=0; i<n; ++i) {\n\t\tvis.reset();\n\t\tbfs(i);\n\t\tfor(int j=rhead[i]; j!=-1; j=rnext[j]) rev[j]=vis.test(a[j]);\n\t}\n\tfor(int i=0; i<n; ++i) {\n\t\tstd::vector<int> out;\n\t\tfor(int j=head[i]; j!=-1; j=next[j]) out.push_back(j);\n\t\tvis.reset();\n\t\tvis.set(i);\n\t\tfor(int j: out) {\n\t\t\tbfs(b[j]);\n\t\t\tfor(int *p=queue; p!=qtail; ++p) max[*p]=j;\n\t\t}\n\t\tstd::reverse(out.begin(), out.end());\n\t\tvis.reset();\n\t\tvis.set(i);\n\t\tfor(int j: out) {\n\t\t\tbfs(b[j]);\n\t\t\tfor(int *p=queue; p!=qtail; ++p) min[*p]=j;\n\t\t}\n\t\tfor(int j=head[i]; j!=-1; j=next[j]) without[j]=(min[b[j]]!=j)||(max[b[j]]!=j);\n\t}\n\tfor(int i=0; i<m; ++i) puts(rev[i]^without[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 1200;\n\nint n, m;\nvector<pair<int, int> > ed;\nvector<int> eds[MAXN];\nvector<int> reds[MAXN];\nint cc;\nint cl[MAXN];\n\nint was[MAXN];\nvector<int> vv;\n\nvoid dfs1(int v) {\n\twas[v] = 1;\n\tfor (int u: eds[v]) {\n\t\tif (!was[u])\n\t\t\tdfs1(u);\n\t}\n\tvv.push_back(v);\n}\n\nvoid dfs2(int v, int c) {\n\tcl[v] = c;\n\twas[v] = 1;\n\tfor (int u: reds[v]) {\n\t\tif (!was[u]) {\n\t\t\tdfs2(u, c);\n\t\t}\n\t}\n}\n\nvector<pair<int, int>> dd[MAXN];\nint fl[MAXN][MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\ted.emplace_back(a, b);\n\t\teds[a].push_back(b);\n\t\treds[b].push_back(a);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (was[i])\n\t\t\tcontinue;\n\t\tdfs1(i);\n\t}\n\treverse(vv.begin(), vv.end());\n\tmemset(was, 0, sizeof(was));\n\tfor (int i: vv) {\n\t\tif (!was[i])\n\t\t\tdfs2(i, cc++);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tdd[j].clear();\n\t\tqueue<pair<int, int>> qu;\n\t\tfor (int j: eds[i]) {\n\t\t\tdd[j].emplace_back(1, j);\n\t\t\tqu.emplace(j, 0);\n\t\t}\n\t\twhile (!qu.empty()) {\n\t\t\tint x, y;\n\t\t\ttie(x, y) = qu.front();\n\t\t\tqu.pop();\n\t\t\tfor (int u: eds[x]) {\n\t\t\t\tif (u == i)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dd[u].empty()) {\n\t\t\t\t\tdd[u].emplace_back(dd[x][y].first + 1, dd[x][y].second);\n\t\t\t\t\tqu.emplace(u, 0);\n\t\t\t\t}\n\t\t\t\telse if (dd[u].size() == 1) {\n\t\t\t\t\tif (dd[u][0].second != dd[x][y].second) {\n\t\t\t\t\t\tdd[u].emplace_back(dd[x][y].first + 1, dd[x][y].second);\n\t\t\t\t\t\tqu.emplace(u, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tfor (auto k: dd[j])\n\t\t\t\tif (k.second != j)\n\t\t\t\t\tfl[i][j] = 1;\n\t\t}\n\t}\n\tfor (auto e: ed) {\n\t\tint x, y;\n\t\ttie(x, y) = e;\n\t\tif (cl[x] == cl[y]) {\n\t\t\tif (fl[x][y])\n\t\t\t\tcout << \"same\\n\";\n\t\t\telse\n\t\t\t\tcout << \"diff\\n\";\n\t\t}\n\t\telse {\n\t\t\tif (fl[x][y])\n\t\t\t\tcout << \"diff\\n\";\n\t\t\telse\n\t\t\t\tcout << \"same\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint dfn[1010], low[1010], up[1010], dft, bel[1010], blt, st[1010], tp;\nmap<int,int>mp[1010]; int ans[202000];\n\nvoid tar(int x){\n  dfn[x]=low[x]=++dft;\n  st[++tp]=x;\n  \n  for (auto &o:mp[x]){\n    int y=o.first;\n    if (dfn[y]){\n      if (!bel[y]) low[x]=min(low[x],dfn[y]);\n    }else{\n      tar(y); low[x]=min(low[x],low[y]);\n    }\n  }\n  \n  if (dfn[x]==low[x]){\n    ++blt;\n    for (;;){\n      bel[st[tp]]=blt;\n      if (st[tp--]==x) break;\n    }\n  }\n}\n\nvoid dfs(int x,int *vis,int tp){\n  if (vis[x]) return; vis[x]=tp;\n  for (auto &o:mp[x]) dfs(o.first,vis,tp);\n}\n\nint fl[1010];\nvoid doit(int x){\n  memset(up,0,sizeof up); memset(low,0,sizeof low);\n  up[x]=low[x]=x;\n  memset(fl,0,sizeof fl);\n  for (auto &o:mp[x]) fl[o.first]=1;\n  for (int i=1;i<=n;++i) if (fl[i]) dfs(i,low,i);\n  for (int i=n;i;--i) if (fl[i]) dfs(i,up,i);\n  for (int i=1;i<=n;++i) if (fl[i]){\n    ans[mp[x][i]]= (bel[x]!=bel[i]) ^ (up[i]==low[i]);\n  }\n}\n\nint main(){\n  cin>>n>>m; int x, y;\n  for (int i=1;i<=m;++i){\n    scanf(\"%d%d\",&x,&y), mp[x][y]=i;\n  }\n  for (int i=1;i<=n;++i) if (!dfn[i]) tar(i);\n  \n  for (int i=1;i<=n;++i) doit(i);\n  for (int i=1;i<=m;++i) puts(ans[i]? \"diff\": \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1200\n\nint n,m,x[N],y[N],vis[2][N][N];\nvector<int> vec[N];\n\nvoid dfs(int op,int o,int u,int k){\n\tif (vis[op][o][u]) return;\n\tvis[op][o][u]=k;\n\tfor (int i=0;i<(int)vec[u].size();++i)\n\t\tdfs(op,o,vec[u][i],k);\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;++i){scanf(\"%d%d\",&x[i],&y[i]); vec[x[i]].push_back(y[i]);}\n\tfor (int i=1;i<=n;++i){\n\t\tvis[0][i][i]=vis[1][i][i]=1;\n\t\tfor (int j=0;j<(int)vec[i].size();++j)\n\t\t\tdfs(0,i,vec[i][j],j+1);\n\t\tif (vec[i].size())\n\t\t\tfor (int j=(int)vec[i].size()-1;j>=0;--j)\n\t\t\t\tdfs(1,i,vec[i][j],j+1);\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tint u=x[i],v=y[i];\n\t\tputs((vis[0][u][v]!=vis[1][u][v])^(vis[0][v][u])?\"diff\":\"same\");\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e3 + 5;\n\nint n, m, a[N], b[N], used[N];\nint comp[N], sz;\nvector <int> g[N], rg[N], vec;\nvector < pair <int, int> > c;\nmap < pair <int, int>, int > mp;\n\nvoid dfs(int v){\n      used[v] = 1;\n      for(int to : g[v]){\n            if(!used[to]) dfs(to);\n      }\n      vec.push_back(v);\n}\n\nvoid Dfs(int v){\n      comp[v] = sz;\n      used[v] = 0;\n      for(int to : rg[v]) {\n            if(used[to]) Dfs(to);\n      }\n}\n\nvoid vis(int v){\n      used[v] = 1;\n      for(int to : g[v]) if(!used[to]) dfs(to);\n}\n\nint main(){\n      cin >> n >> m;\n\n      for(int i = 1; i <= m; i ++){\n            cin >> a[i] >> b[i];\n            g[a[i]].push_back(b[i]);\n            rg[b[i]].push_back(a[i]);\n            c.push_back(make_pair(a[i], b[i]));\n      }\n\n      for(int i = 1; i <= n; i ++)\n            if(!used[i]) dfs(i);\n\n      reverse(vec.begin(), vec.end());\n\n      for(int v : vec)\n            if(used[v]) sz ++, Dfs(v);\n\n      for(int v = 1; v <= n; v ++){\n            memset(used, 0, sizeof(used));\n            used[v] = 1;\n            for(int to : g[v]){\n                  if(used[to]){\n                        mp[make_pair(v, to)] = 1;\n                  }\n                  vis(to);\n            }\n            memset(used, 0, sizeof(used));\n            used[v] = 1;\n            reverse(g[v].begin(), g[v].end());\n            for(int to : g[v]){\n                  if(used[to]){\n                        mp[make_pair(v, to)] = 1;\n                  }\n                  vis(to);\n            }\n      }\n\n      for(auto i : c){\n            if(comp[i.first] != comp[i.second]) mp[i] = 1 - mp[i];\n            if(mp[i]){\n                  puts(\"same\");\n            } else {\n                  puts(\"diff\");\n            }\n      }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int mod = 1e9 + 7;\nconst int N   = 1e3 + 3;\n\nvector < pp > V[N],U[N];\nvector < int > Y[N]; \nint D[N],low[N],zaman,H[N],Scc[N],scc,T[N],ans[N*200],n,m,x,y,i,X;\nstack < int > S;\n\nvoid f(int x){\n    D[x] = low[x] = ++zaman;\n    S.push(x); H[x] = 1;\n    for(auto t : V[x]){\n        int y = t.st;\n        if(y == X) continue;\n        if(!D[y]){ f(y); low[x] = min(low[x] , low[y]); }\n        else if(H[y]) low[x] = min(low[x] , D[y]); \n    }\n    \n    if(low[x] == D[x]){\n        scc++;\n        for(int y = 0; y != x;){\n            y = S.top();\n            S.pop();\n            H[y] = 0;\n            Scc[y] = scc;\n            Y[scc].pb(y);\n        }        \n    }\n}\n\nvoid g(int x){\n    X = x;\n    int i;\n    memset(D , zaman=0 , sizeof D);\n    memset(Scc , scc=0 , sizeof Scc);\n    for(i=1;i<=n;i++) { Y[i].clear(); U[i].clear(); }\n    for(i=1;i<=n;i++) if(i != X && !D[i]) f(i);\n    if(x == 0){\n        for(i=1;i<=n;i++) T[i] = Scc[i];\n        return;\n    }\n\n    memset(D , 0 , sizeof D);\n    for(auto t : V[X]){\n        U[ Scc[t.st] ].pb(t);\n    }\n    for(i=scc; i ;i--){\n        if(!D[i] && U[i].size() == 0) continue;\n        if(D[i] || U[i].size() > 1){\n            for(auto t : U[i]){\n                ans[t.nd] = T[X] == T[t.st];\n            }\n        }\n        else { for(auto t : U[i]) ans[t.nd] = T[X] != T[t.st]; }\n        \n        for(auto x : Y[i]){\n            for(auto y : V[x])\n                D[ Scc[y.st] ] = 1;    \n        }\n    }\n}\n\nsigned main(){\n    cin >> n >> m;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d\",&x,&y);\n        V[x].pb(mp(y,i));\n    }\n    \n    for(i=0;i<=n;i++) g(i);\n    for(i=1;i<=m;i++) puts(ans[i] ? \"same\" : \"diff\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=1005;\nint n,m,foo[N][N],bar[N][N],ans[N*200];\nvector<int>E[N],Q[N];\nvoid dfs(int u,int c,int *mrk){\n\tif(mrk[u])return;mrk[u]=c;\n\tfor(int v:E[u])if(!mrk[v])dfs(v,c,mrk);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tE[x].push_back(y);\n\t\tQ[x].push_back(i);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfoo[i][i]=bar[i][i]=-1;\n\t\tfor(int j=0;j<E[i].size();++j)\n\t\t\tdfs(E[i][j],j+1,foo[i]);\n\t\tfor(int j=E[i].size()-1;~j;--j)\n\t\t\tdfs(E[i][j],j+1,bar[i]);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<E[i].size();++j){\n\t\t\tint x=(foo[E[i][j]][i]?1:0),y=(foo[i][E[i][j]]<=j)|(bar[i][E[i][j]]>j+1);\n\t\t\tans[Q[i][j]]=x^y;\n\t\t}\n\tfor(int i=1;i<=m;++i)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nint N,M;\nint A[222222],B[222222];\nbool flag1[222222],flag2[222222];\n\nvint G[1111];\n\nint r[1111];\nbool used[1111];\n\nvoid solve(int s){\n    memset(r,-1,sizeof(r));\n    memset(used,0,sizeof(used));\n\n    for(auto v:G[s]){\n        if(r[v]!=-1){\n            used[v]=true;\n            continue;\n        }\n        r[v]=v;\n        queue<int>que;\n        que.push(v);\n        while(que.size()){\n            int u=que.front();\n            que.pop();\n            for(auto w:G[u]){\n                if(w==s)continue;\n                if(r[w]!=-1){\n                    if(r[w]!=v)used[w]=true;\n                    continue;\n                }\n                r[w]=v;\n                que.push(w);\n            }\n        }\n    }\n\n    queue<int>que;\n    rep(i,N)if(used[i])que.push(i);\n\n    while(que.size()){\n        int v=que.front();\n        que.pop();\n        for(auto u:G[v]){\n            if(u==s)continue;\n            if(used[u])continue;\n            used[u]=true;\n            que.push(u);\n        }\n    }\n\n    rep(i,M){\n        if(A[i]==s){\n            flag1[i]|=used[B[i]];\n        }\n        if(B[i]==s){\n            flag2[i]|=r[A[i]]!=-1;\n        }\n    }\n}\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,M){\n        cin>>A[i]>>B[i];A[i]--;B[i]--;\n        G[A[i]].pb(B[i]);\n    }\n\n    rep(i,N)solve(i);\n    rep(i,M){\n        if(flag1[i]==flag2[i])puts(\"same\");\n        else puts(\"diff\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m,sum;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nauto F=f[0];\nbool bz[N];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    static int y;\n    for (int i=g[x];i&&sum;i=a[i][1])\n        if (a[i][0]!=s){\n            y=a[i][0];\n            if (x==s)v=y;\n            if (F[y][0]==v||F[y][1]==v||(F[y][0]&&F[y][1]))continue;\n            if (!F[y][0])F[y][0]=v;\n            else{\n                F[y][1]=v;\n                if (bz[y])sum--,bz[y]=0;\n                if (!sum)return;\n            }\n            dfs(y,s,v);\n        }\n}\ninline int read() {\n    char ch = getchar(); int x = 0, f = 1;\n    while(ch < '0' || ch > '9') {\n        if(ch == '-') f = -1;\n        ch = getchar();\n    } while('0' <= ch && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    } return x * f;\n}\nint main(){\n    n=read();\n    m=read();\n    for (int i=1;i<=m;i++){\n        e[i][0]=read();\n        e[i][1]=read();\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++){\n        F=f[i];\n        for (int j=g[i];j;j=a[j][1])sum++,bz[a[j][0]]=1;\n        dfs(i,i,0);\n    }\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?printf(\"same\\n\"):printf(\"diff\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int LG = 21;\nconst int FN = 400005;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(FN);\n    __ufact.resize(FN);\n    __rev.resize(FN);\n    __rev[1] = 1;\n    for (int i = 2; i < FN; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < FN; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nconst int N = 1010;\nconst int M = 101010;\nvector<int> graph[N];\nint go[N][N], f[N][N], g[N][N];\nint fr[M], to[M], glina[M];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    forn(i, m)\n    {\n        int a, b;\n        cin >> a >> b;\n        glina[i] = graph[a].size();\n        graph[a].push_back(b);\n        fr[i] = a, to[i] = b;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> q = {i};\n        go[i][i] = 1;\n        for (int j = 0; j < q.size(); j++)\n        {\n            int v = q[j];\n            for (auto u : graph[v]) if (!go[i][u]) go[i][u] = 1, q.push_back(u);\n        }\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) f[i][j] = -1, g[i][j] = -1;\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> vis(n + 1, 0);\n        vis[i] = 1;\n        for (int a = 0; a < graph[i].size(); a++)\n        {\n            if (vis[graph[i][a]]) continue;\n            vector<int> q = {graph[i][a]};\n            for (int j = 0; j < q.size(); j++)\n            {\n                int v = q[j];\n                f[i][v] = a;\n                for (auto u : graph[v]) if (!vis[u]) vis[u] = 1, q.push_back(u);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        vector<int> vis(n + 1, 0);\n        vis[i] = 1;\n        for (int a = (int)graph[i].size() - 1; a >= 0; a--)\n        {\n            if (vis[graph[i][a]]) continue;\n            vector<int> q = {graph[i][a]};\n            for (int j = 0; j < q.size(); j++)\n            {\n                int v = q[j];\n                g[i][v] = a;\n                for (auto u : graph[v]) if (!vis[u]) vis[u] = 1, q.push_back(u);\n            }\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int id = glina[i];\n        int v = fr[i], u = to[i];\n        int fl = (f[v][u] != -1 && f[v][u] != id);\n        fl |= (g[v][u] != -1 && g[v][u] != id);\n        if (fl ^ go[u][v]) cout << \"diff\\n\";\n        else cout << \"same\\n\";\n    }\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define for_bitset(variable, bitset) for (variable = bitset._Find_first(); variable != N; variable = bitset._Find_next(variable))\n\nconst int N = 1054, M = 200054;\ntypedef std::bitset <N> bitset;\n\nint V, E, tag, root;\nint from[N], _u[M], _v[M], que[N];\nbitset G[N], single[N];\nbitset saturated, connected[N], reversible[N];\n\nvoid bfs(int si) {\n\tint x, y, h, t = 1; bitset remain; *que = si; \n\tfrom[si] ? saturated.set(si) : (from[si] = tag, single[tag].set(si));\n\tfor (h = 0; h < t; ++h) {\n\t\tx = que[h];\n\t\tremain = G[x] & ~saturated & ~single[tag];\n\t\tfor_bitset(y, remain)\n\t\t\tque[t++] = y, from[y] ? saturated.set(y) : (from[y] = tag, single[tag].set(y));\n\t}\n}\n\nvoid solve() {\n\tint i;\n\tmemset(from, 0, (V + 1) << 2);\n\tsaturated.reset(), saturated.set(root);\n\tfor_bitset(tag, G[root]) if (!saturated.test(tag)) bfs(tag);\n\tconnected[root] = reversible[root] = saturated;\n\tfor (i = 1; i <= V; ++i)\n\t\tconnected[root].set(i, connected[root].test(i) || from[i]),\n\t\treversible[root].set(i, reversible[root].test(i) || (from[i] && from[i] != i));\n\tfor (i = 1; i <= V; ++i) single[from[i]].reset(i);\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (i = 1; i <= E; ++i) scanf(\"%d%d\", &u, &v), G[u].set(v), _u[i] = u, _v[i] = v;\n\tfor (root = 1; root <= V; ++root) solve();\n\tfor (i = 1; i <= E; ++i)\n\t\tu = _u[i], v = _v[i], puts(connected[v][u] == reversible[u][v] ? \"same\" : \"diff\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200200;\ninline int read(int x=0,bool f=0,char ch=getchar()){\n\tfor(;!isdigit(ch);ch=getchar()) f=ch=='-';\n\tfor(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\nint n,m,tot,fi[N],to[N],u[N],ne[N];\nbool vis[1010][1010];\nint pre[1010][1010],suf[1010][1010];\nvoid bfs(int x){\n\tqueue<int> s; s.push(x); vis[x][x]=true;\n\twhile(!s.empty()){\n\t\tint y=s.front(); s.pop();\n\t\tfor(int i=fi[y];i;i=ne[i]) if(!vis[x][to[i]]) vis[x][to[i]]=true,s.push(to[i]);\n\t}\n}\nvoid dfs1(int x,int id,int k){\n\tif(pre[id][x]) return; pre[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) dfs1(to[i],id,k);\n}\nvoid dfs2(int x,int id,int k){\n\tif(suf[id][x]) return; suf[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) dfs2(to[i],id,k);\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;++i) x=read(),y=read(),ne[++tot]=fi[x],u[tot]=x,to[fi[x]=tot]=y;\n\tfor(int i=1;i<=n;++i) bfs(i);\n\tfor(int i=1;i<=n;++i){\n\t\tvector<int> s; int sz=0; pre[i][i]=suf[i][i]=1;\n\t\tfor(int j=fi[i];j;j=ne[j]) s.push_back(to[j]);\n\t\tfor(int j:s) dfs1(j,i,++sz);\n\t\treverse(s.begin(),s.end());\n\t\tfor(int j:s) dfs2(j,i,sz--);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint x=u[i],y=to[i];\n\t\tif(vis[y][x]^(pre[x][y]!=suf[x][y])) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=1e3+10;\nconst int M=2e5+10;\nvector<pii> e[N];\ninline void add(int u,int v,int id){e[u].push_back(mp(v,id));}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;vis[x]=1;\n    for(auto k:e[x]){\n\tint v=k.fi;if(vis[v]) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[M];\nint main(){\n    n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n    }\n    rep(i,1,n){mst(vis,0);dfs1(i,i);}\n    rep(x,1,n){\n\tmst(vis,0);vis[x]=1;\n\tfor(auto k:e[x]){\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs2(v,x);\n\t}\n\tmst(vis,0);vis[x]=1;\n\tint sz=(int)e[x].size()-1;\n\trpe(j,sz,0){\n\t    pii k=e[x][j];\n\t    col=k.sc;\n\t    int v=k.fi;if(vis[v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<1)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],vis[N];\nvector<int> e[N];\nvoid dfs(int st,int u,int now){\n\tif (st==u) return;\n\tif (a[st][u]>=2) return;\n\tif (a[st][u]==1 && vis[u]==now) return;\n\tif (a[st][u]==0) vis[u]=now;\n\ta[st][u]++;\n\trep (i,0,(int)e[u].size()-1) dfs(st,e[u][i],now);\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read();\n\t\te[x[i]].push_back(y[i]);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,-1,sizeof(vis));\n\t\trep (j,0,(int)e[i].size()-1) dfs(i,e[i][j],e[i][j]);\n\t}\n\trep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]]>=1;\n\t\tbool f2=a[x[i]][y[i]]>=2;\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,x[200005],y[200005],book[1005];\nint top,nex[200005],to[200005],fir[1005];\nmap<int,int> mp[1005],mp2[1005];\nvoid lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\nvoid ss(int v,int w){\n\tbook[v]=i;\n\tmp[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss(to[top1],w==0?top1:w);\n}\nvoid ss2(int v,int w){\n\tbook[v]=i;\n\tmp2[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss2(to[top1],w==0?top1:w);\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=m;i++){\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t\tlj(x[i],y[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tss(i,0);\n\tfor(i=1;i<=top;i++){\n\t\tnex[i]=0;\n\t\tto[i]=0;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tbook[i]=0;\n\t\tfir[i]=0;\n\t}\n\ttop=0;\n\tfor(i=m;i>=1;i--)\n\t\tlj(x[i],y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tss2(i,0);\n\tfor(i=1;i<=m;i++){\n\t\tif((mp[y[i]][x[i]]!=0)+(mp[x[i]][y[i]]+mp2[x[i]][y[i]]==m+1)==1)\n\t\t\tprintf(\"same\\n\");\n\t\telse\n\t\t\tprintf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/extc++.h>\n#include<bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector,O3\")\nusing namespace std;using ll = long long;using ull = unsigned long long;using ul = unsigned;using db = double;using __gnu_pbds::null_type;\n#ifdef _debug \n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) 0&&0\n#endif\n#define eout(i) {cout << (i) << '\\n';exit(0);}\n#define priority_queue __gnu_pbds::priority_queue\n#define unordered_map __gnu_pbds::gp_hash_table\n#define rep(a, b) {for(int i = a;i > 0;--i){b;}}\n#define multe int T;for(cin >> T;T--;)\npair<long long, long long> ext_gcd(long long a, long long b){if(a % b == 0)return {0ll, 1ll};auto get = ext_gcd(b, a % b);return {get.second, get.first - a / b * get.second};}\nlong long ext_inv(long long a, long long p){return (ext_gcd(a, p).first + p) % p;}\nvector<int> kfunc(string &w){vector<int> k(w.size());for(int q = 0, i = 1;i < w.size();++i){for(;q > 0 and w[i] != w[q];q = k[q-1]);k[i] = (q += w[i] == w[q]);}return k;}\nvector<int> zfunc(string &w){vector<int> z(w.size());z[0] = w.size();for(int l = 0, i = 1;i < w.size();++i){z[i] = max(0, min(l+z[l] - i, z[i-l]));for(;i+z[i] < w.size() and w[i+z[i]] == w[z[i]];++z[i])l = i;}return z;}\ntemplate<typename T> using rbtree = __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T> inline long long pow(long long v, long long t, const T &p){long long res = 1;for(;t;t >>= 1, v = v * v % p)if(t & 1)res = res * v % p;return res;}\ntemplate<typename T> inline void floyd_warshall(vector<vector<T>> &dp){for(int i = 0;i < dp.size();++i)for(int j = 0;j < dp.size();++j)for(int k = 0;k < dp.size();++k)dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k]);}\ntemplate<typename T> inline ostream& operator << (ostream &ou, const vector<T> &a){for(auto it = a.begin();it != a.end();++it)ou << (it != a.begin() ? \" \" : \"\") << *it;return ou;}\ntemplate<typename T> inline vector<vector<T>> operator * (const vector<vector<T>> &a, const vector<vector<T>> &b){assert(a.front().size() == b.size());vector<vector<T>> res(a.size(), vector<T>(b.front().size()));for(int i = 0;i < a.size();++i)for(int j = 0;j < b.front().size();++j)for(int k = 0;k < a.front().size();++k)res[i][j] += a[i][k] * b[k][j];return res;}\ntemplate<typename T> inline vector<vector<T>> pow(vector<vector<T>> v, long long t){vector<vector<T>> res;for(;t;t >>= 1, v = v * v)if(t & 1)res = (res.empty() ? v : res * v);return res;}\ntemplate<typename T> void read(int n, T *s){while(n--)cin >> *s, ++s;}\ntemplate<typename T> void read(int n, vector<T> &v){for(int i = 0;i < n;++i)cin >> v[i];}\ntemplate<typename T> void write(int n, T *s){while(n--)cout << *s << \" \\n\"[n==0], ++s;}\ntemplate<typename T1, typename T2>inline istream& operator >> (istream &in, pair<T1, T2> &a){return in >> a.first >> a.second;}\ntemplate<typename T1, typename T2>inline ostream& operator << (ostream &ou, const pair<T1, T2> &b){return ou << b.first << ' ' << b.second;}\ntemplate<typename T1, typename T2>inline pair<T1,T2> operator + (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first + b.first, a.second + b.second};}\ntemplate<typename T1, typename T2>inline pair<T1,T2> operator - (const pair<T1,T2> &a, const pair<T1,T2> &b){return {a.first - b.first, a.second - b.second};}\ntemplate<typename T1, typename T2>inline long long operator ^ (const pair<T1,T2> &a, const pair<T1,T2> &b){return (long long)a.first * b.second - (long long)a.second * b.first;}\nconst int maxn = 1010;\nint n, m;\nvector<pair<int,int>> alle;\nvector<int> edge[maxn];\nvector<vector<int>> dp;\nint g[maxn];\nvoid dfs(int now){\n\tstatic int low[maxn], d = 0, id = 1, onpath[maxn];\n\tif(onpath[now])return;\n\tlow[now] = ++d;\n\tonpath[now] = true;\n\tfor(int &i : edge[now]){\n\t\tif(onpath[i] || !low[i]){\n\t\t\tdfs(i), low[now] = min(low[now], low[i]);\n\t\t\tif(low[i] > d)++id;\n\t\t}\n\t}\n\tg[now] = id; \n\tonpath[now] = false;\n\t--d;\n}\nstring output[2]{\"same\\n\", \"diff\\n\"};\nint depen[maxn];\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\talle.reserve(m);\n\tdp.resize(n+1, vector<int> (n+1, maxn));\n\tfor(int i = 0, a, b;i < m;++i){\n\t\tcin >> a >> b;\n\t\tedge[a].emplace_back(b);\n\t\talle.emplace_back(a, b);\n\t\tdp[a][b] = 1;\n\t}\n\tdfs(1);\n\n\tfloyd_warshall(dp);\n\tfor(int i = 1;i <= n;++i)cout << g[i] << ' ';cout << '\\n';\n\n\tfor(int i = 1;i <= n;++i){\n\t\twhile(edge[i].size() and g[edge[i].back()] != g[i])edge[i].pop_back();\n\t\tfor(int j = 0, r = (int)edge[i].size()-1;j < r;++j){\n\t\t\tif(g[i] != g[edge[i][j]])swap(edge[i][j], edge[i][r]), --r;\n\t\t}\n\t\twhile(edge[i].size() and g[edge[i].back()] != g[i])edge[i].pop_back();\n\t\tfor(int &j : edge[i])++depen[j];\n\t}\n\tfor(const auto &e : alle){\n#define f first\n#define s second\n\t\tint res = 0;\n\t\tif(g[e.f] == g[e.s]){\n\t\t\t// dout(e.f)<<' '<< edge[e.f].size() << '\\n';\n\t\t\tres = edge[e.f].size() == 1 || depen[e.s] == 1;\n\t\t}\t\n\t\telse{\n\t\t\tfor(int i = 1;i <= n and !res;++i)if(i != e.f and i != e.s and g[i] != g[e.f] and g[i] != g[e.s]){\n\t\t\t\tif(dp[e.f][i] != dp[e.s][i]+1 and dp[e.f][i] < maxn and dp[i][e.s] < maxn)res = 1;\n\t\t\t}\n\t\t}\n\t\tcout << output[res];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1010\n#define M 200200\nusing namespace std;\n\nint n, m;\nint tot, fir[N], nxt[M], to[M];\n\nvoid addE(int u, int v) {\n    nxt[++tot] = fir[u], fir[u] = tot, to[tot] = v;\n}\n\nqueue<int> q;\n\nvoid bfs(int s, int mark, int *vis) {\n    q.push(s), vis[s] = mark;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int i = fir[u], v; i; i = nxt[i]) {\n            v = to[i];\n            if (vis[v]) continue;\n            vis[v] = mark, q.push(v);\n        }\n    }\n}\n\nint vis[N][N], v1[N], v2[N], ans[N], stk[N], top;\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n    \n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; ++i)\n        scanf(\"%d%d\", &u, &v), addE(u, v);\n\n    for (int i = 1; i <= n; ++i)\n        bfs(i, 1, vis[i]);\n\n    for (int u = 1; u <= n; ++u) {\n        memset(v1, 0, sizeof v1);\n        memset(v2, 0, sizeof v2);\n        top = 0;\n        for (int i = fir[u]; i; i = nxt[i])\n            stk[++top] = to[i];\n        for (int i = 1, v; i <= top; ++i)\n            if (!v1[v = stk[i]])\n                v1[u] = i, bfs(v, v, v1);\n        for (int i = top, v; i >= 1; --i)\n            if (!v2[v = stk[i]])\n                v2[u] = i, bfs(v, v, v2);\n        for (int i = fir[u], v; i; i = nxt[i])\n            v = to[i], ans[i] = (vis[v][u] == (v1[v] != v2[v]));\n    }\n    \n    for (int i = 1; i <= m; ++i)\n        puts(ans[i] ? \"same\" : \"diff\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//using pi = pair<int, int>;\nconst int MAXN = 1005;\nconst int MAXM = 200005;\n \nvector<int> gph[MAXN];\nint adj[MAXN][MAXN], vis[MAXN];\nint n, m;\nint s[MAXM], e[MAXM];\n \nvoid dfs(int r, int v){\n\tvis[v] = 1;\n\tadj[r][v]++;\n\tint cnt=gph[v].size();\n\tfor(int it=0;it<cnt;it++){\n\t\tint i=gph[v][it];\n\t\tif(i == r) continue;\n\t\tif(!vis[i] && adj[r][i] < 2){\n\t\t\tdfs(r, i);\n\t\t}\n\t}\n}\n \nint main(){\n\tcin >> n >> m;\n\tfor(int i=0; i<m; i++){\n\t\tscanf(\"%d %d\",&s[i],&e[i]);\n\t\tgph[s[i]].push_back(e[i]);\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tint cnt=gph[i].size();\n\t\tfor(int it=0;it<cnt;it++){\n\t\t\tint j=gph[i][it];\n\t\t\tif(adj[i][j] < 2){\n\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\tdfs(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t    for(int j=1;j<=n;j++){\n\t        printf(\"%d \",adj[i][j]);\n\t    }\n\t    printf(\"\\n\");\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tif(adj[e[i]][s[i]] == 0){\n\t\t\tputs(adj[s[i]][e[i]] > 1 ? \"diff\" : \"same\");\n\t\t}\n\t\telse{\n\t\t\tputs(adj[s[i]][e[i]] > 1 ? \"same\" : \"diff\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\n\nvector <int> graph[1001];\n\nvoid addedge(int u,int v)\n{\n\tgraph[u].push_back(v);\n}\n\nint vis[1001][1001];\nstruct\n{\n\tint first,second;\n}edge[200001];\nint mark[1001];\nint times=1;\nint tmp;\n\nvoid dfs(int from,int now)\n{\n\tvis[from][now]++;\n\tmark[now]=1;\n\tfor(auto to:graph[now])\n\t{\n\t\tif(to==from)continue;\n\t\tif(vis[from][to]<2&&!mark[to])\n\t\t{\n\t\t\tdfs(from,to);\n\t\t}\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"sep2_0.in\",\"r\",stdin);\n//\tfreopen(\"sep.out\",\"w\",stdout);\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\tedge[i].first=from;\n\t\tedge[i].second=to;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto to:graph[i])\n\t\t{\n\t\t\tif(vis[i][to]<2)\n\t\t\t{\n\t\t\t\tmemset(mark,0,sizeof(mark));\n\t\t\t\tdfs(i,to);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t//return 0;\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcout<<\"(\"<<vis[i][j]<<\",\"<<vis2[i][j]<<\")\";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(vis[to][from])\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(vis[from][to]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define inlien inline\n#define retrun return\n#define cpnst const\nbool can[1111][1111],exc[1111][1111];\ninline bool ask(int x,int y)\n{return can[y][x]^exc[x][y];}\nint x[111111],y[111111],n,m;\n#include<vector>\nstd::vector<int>v[1111];\nbool vis[1111];\ninline void dfs(int s,int p)\n{\n\tif(vis[p])return;\n\tvis[p]=can[s][p]=1;\n\tfor(register int i=0;i<v[p].size();i++)\n\t\tdfs(s,v[p][i]);\n}\nint frm[1111];\ninline void efs(int fs,int s,int p)\n{\n\tif(vis[p])return;vis[p]=1;\n\tif(frm[p])if(frm[p]^s)exc[fs][p]=1;frm[p]=s;\n\tfor(register int i=0;i<v[p].size();i++)\n\t\tefs(fs,s,v[p][i]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tregister int i,ii;\n\tfor(i=1;i<=m;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]),v[x[i]].push_back(y[i]);\n\tfor(i=1;i<=n;i++)\n\t{for(ii=1;ii<=n;ii++)vis[ii]=0;dfs(i,i);}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(ii=1;ii<=n;ii++)vis[ii]=frm[ii]=0;\n\t\tvis[i]=1;\n\t\tfor(ii=0;ii<v[i].size();ii++)efs(i,v[i][ii],v[i][ii]);\n\t\tfor(ii=1;ii<=n;ii++)vis[ii]=0;\n\t\tfor(ii=v[i].size()-1;~ii;ii--)efs(i,v[i][ii],v[i][ii]);\n\t}for(i=1;i<=m;i++)puts(ask(x[i],y[i])?\"diff\":\"same\");\n}\n/*\nGiving the world a better yourself is giving yourself a better world. \n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nint n, m;\nint ghead[MAXN], gnxt[MAXM], gto[MAXM];\nint rhead[MAXN], rnxt[MAXM], rto[MAXM];\n\nint ans[MAXM];\n\nint cur[MAXN], ncur;\nint q[MAXN], qhead, qtail;\nint mn[MAXN], mx[MAXN]; bool reach[MAXN];\n\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &m);\n\tREP(i, n) ghead[i] = -1, rhead[i] = -1;\n\tREP(i, m) { \n\t\tint a, b; scanf(\"%d%d\", &a, &b); --a, --b;\n\t\tgnxt[i] = ghead[a], ghead[a] = i, gto[i] = b; \n\t\trnxt[i] = rhead[b], rhead[b] = i, rto[i] = a;\n\t}\n\n\tREP(i, m) ans[i] = -1;\n\tREP(i, n) {\n\t\tncur = 0; for (int x = ghead[i]; x != -1; x = gnxt[x]) cur[ncur++] = x;\n\t\tREP(j, n) mn[j] = INT_MAX; qhead = qtail = 0;\n\t\tREP(j, ncur) { \n\t\t\tint x = cur[j], rt = gto[x]; if (mn[rt] != INT_MAX) continue;\n\t\t\tq[qhead++] = rt; mn[rt] = j;\n\t\t\twhile (qtail < qhead) { int at = q[qtail++]; for (int y = ghead[at]; y != -1; y = gnxt[y]) { int to = gto[y]; if (mn[to] == INT_MAX) mn[to] = j, q[qhead++] = to; } }\n\t\t}\n\t\tREP(j, n) mx[j] = INT_MIN; mx[i] = -1; qhead = qtail = 0;\n\t\tfor (int j = ncur - 1; j >= 0; --j) {\n\t\t\tint x = cur[j], rt = gto[x]; if (mx[rt] != INT_MIN) continue;\n\t\t\tq[qhead++] = rt; mx[rt] = j;\n\t\t\twhile (qtail < qhead) { int at = q[qtail++]; for (int y = ghead[at]; y != -1; y = gnxt[y]) { int to = gto[y]; if (mx[to] == INT_MIN) mx[to] = j, q[qhead++] = to; } }\n\t\t}\n\t\tREP(j, n) reach[j] = false; mn[i] = -1; qhead = qtail = 0;\n\t\tq[qhead++] = i; reach[i] = true;\n\t\twhile (qtail < qhead) { int at = q[qtail++]; for (int y = rhead[at]; y != -1; y = rnxt[y]) { int to = rto[y]; if (!reach[to]) reach[to] = true, q[qhead++] = to; } }\n\t\tREP(j, ncur) {\n\t\t\tint x = cur[j], to = gto[x];\n\t\t\tbool ab = mn[to] != mx[to], ba = reach[to];\n\t\t\t//printf(\"%d->%d: ab=%d ba=%d\\n\", i + 1, to + 1, ab ? 1 : 0, ba ? 1 : 0);\n\t\t\tans[x] = ab == ba ? 0 : 1;\n\t\t}\n\t}\n\n\tREP(i, m) printf(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3.3e3,M=2.2e5;\nvector<int>v[N];\nint n,m,s[M],t[M],dp[N][N],a[N][N],vis[N];\nvoid dfs(int x,int S,int fi)\n{a[S][x]=1;\n\tfor(int i=0;i<v[x].size();i++)\n\t{int j=v[x][i];if(j!=fi)dp[S][j]=1;\n\t\tif(vis[j])continue;\n\t\tvis[j]=1;dfs(j,S,fi);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y),v[x].push_back(y);s[i]=x,t[i]=y;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{memset(vis,0,sizeof(vis));vis[i]=1;\n\t\tfor(int j=0;j<v[i].size();j++)vis[v[i][j]]=1;\n\t\tfor(int j=0;j<v[i].size();j++)\n\t\tdfs(v[i][j],i,v[i][j]);\n\t}\n\tfor(int i=1;i<=m;i++)\n\tif((dp[s[i]][t[i]]&&!a[t[i]][s[i]])||(a[t[i]][s[i]]&&!dp[s[i]][t[i]]))puts(\"diff\");\n\telse puts(\"same\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nnamespace SCC{\n    void visit(const vector<vector<int>>&G,vector<int>&vs,vector<int>&used,int v){\n        used[v]=true;\n        for(auto u:G[v]){\n            if(!used[u])visit(G,vs,used,u);\n        }\n        vs.push_back(v);\n    }\n\n    void visit2(const vector<vector<int>>&T,vector<int>&used,vector<int>&comp,vector<int>&vec,int k,int v){\n        comp[v]=k;\n        used[v]=true;\n        vec.push_back(v);\n\n        for(auto u:T[v]){\n            if(!used[u])visit2(T,used,comp,vec,k,u);\n        }\n    }\n\n    void decompose(const vector<vector<int>>&G,vector<vector<int>>&H,vector<int>&comp){\n        vector<vector<int>>T(G.size());\n        for(int i=0;i<G.size();i++){\n            for(auto v:G[i]){\n                T[v].push_back(i);\n            }\n        }\n        comp.resize(G.size());\n\n        vector<int>vs(G.size());\n        vector<int>used(G.size());\n        for(int i=0;i<G.size();i++){\n            if(!used[i])visit(G,vs,used,i);\n        }\n        reverse(vs.begin(),vs.end());\n        fill(used.begin(),used.end(),0);\n\n        int K=0;\n        vector<vector<int>>S;\n        for(auto v:vs){\n            if(!used[v]){\n                S.push_back(vector<int>());\n                visit2(T,used,comp,S.back(),K++,v);\n            }\n        }\n\n        H.resize(K);\n        fill(used.begin(),used.end(),0);\n        for(int i=0;i<K;i++){\n            for(auto v:S[i]){\n                for(auto u:G[v]){\n                    if(used[comp[u]]||comp[v]==comp[u])continue;\n                    used[comp[u]]=true;\n                    H[comp[v]].push_back(comp[u]);\n                }\n            }\n            for(auto v:H[i])used[v]=false;\n        }\n\n    }\n}\n\n\n\nint N,M;\nint A[222222],B[222222];\nbool ans[222222];\n\nvector<vint>g;\nvector<vint>rg;\nvint comp;\n\nbool mark[2222];\nint semi[2222];\nvoid dfs(int v,int se){\n    semi[v]=se;\n    for(auto u:g[v]){\n        if(comp[v]!=comp[u])continue;\n        if(semi[u]!=-1)continue;\n        if(se==-5)dfs(u,u);\n        else dfs(u,se);\n    }\n}\n\nbool re[2222];\nvoid dfs2(int v){\n    re[v]=true;\n    for(auto u:rg[v]){\n        if(semi[v]!=semi[u])continue;\n        if(re[u])continue;\n        dfs2(u);\n    }\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&M);\n    g.resize(N);rg.resize(N);\n    rep(i,M){\n        scanf(\"%lld%lld\",&A[i],&B[i]);\n        A[i]--;B[i]--;\n        g[A[i]].pb(B[i]);\n        rg[B[i]].pb(A[i]);\n    }\n\n    vector<vint>h;\n    SCC::decompose(g,h,comp);\n\n    set<pint>latte;\n\n    rep(s,h.size()){\n        vint ei(h.size());\n        ei[s]=1;\n        for(int v=s;v<h.size();v++){\n            for(auto u:h[v]){\n                ei[u]+=ei[v];\n            }\n        }\n        for(auto u:h[s]){\n            if(ei[u]!=1)latte.insert({s,u});\n        }\n    }\n    rep(i,M){\n        if(latte.find({comp[A[i]],comp[B[i]]})!=latte.end())ans[i]=true;\n    }\n\n    latte=set<pint>();\n    rep(i,N){\n        memset(semi,-1,sizeof(semi));\n        memset(re,0,sizeof(re));\n        memset(mark,0,sizeof(mark));\n\n        dfs(i,-5);\n        rep(j,N)if(j==semi[j])dfs2(j);\n        rep(j,M)if(comp[A[j]]==comp[i]&&comp[B[j]]==comp[i]&&semi[A[j]]!=semi[B[j]]&&(A[j]!=i||semi[B[j]]!=B[j]))mark[B[j]]=true;\n\n        rep(j,N)if(mark[j]&&re[j])mark[semi[j]]=true;\n        for(auto u:g[i])if(u==semi[u]&&!mark[u])latte.insert({i,u});\n    }\n\n    rep(i,M){\n        if(latte.find({A[i],B[i]})!=latte.end())ans[i]=true;\n    }\n\n\n    rep(i,M){\n        if(ans[i])puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s){\n    for (int i=g[x];i;i=a[i][1])\n        if (a[i][0]!=s){\n            if (!f[s][a[i][0]][0])f[s][a[i][0]][0]=x;\n            else\n                if (!f[s][a[i][0]][1])f[s][a[i][0]][1]=x;\n            if (f[s][a[i][0]][0]==x)dfs(a[i][0],s);\n        }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for (int i=1;i<=m;i++){\n        cin>>e[i][0]>>e[i][1];\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++)\n        dfs(i,i);\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][0])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][0]));\n        sig==sig1?cout<<\"same\"<<endl:cout<<\"diff\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nvector<int> E[1010];\nint M;\nint ID[1010][1010];\nint G[1010][1010];\nint P[1010][1010];\nint D[2][1010];\nint A[202020],B[202020];\n\nvoid dfs(int cur,int org) {\n\tif(G[org][cur]) return;\n\tG[org][cur]=1;\n\tFORR(e,E[cur]) dfs(e,org);\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tMINUS(ID);\n\t\n\tFOR(i,M) {\n\t\tcin>>A[i]>>B[i];\n\t\tA[i]--;\n\t\tB[i]--;\n\t\tE[A[i]].push_back(B[i]);\n\t\tID[A[i]][B[i]]=i;\n\t}\n\t\n\tFOR(i,N) dfs(i,i);\n\tFOR(i,N) {\n\t\t\n\t\tFOR(j,2) {\n\t\t\tFOR(x,N) D[j][x]=-1<<30;\n\t\t\tpriority_queue<pair<int,int>> PQ;\n\t\t\tFOR(x,N) if(ID[i][x]>=0) {\n\t\t\t\tD[j][x]=ID[i][x];\n\t\t\t\tif(j) D[j][x]=-D[j][x];\n\t\t\t\tPQ.push({D[j][x],x});\n\t\t\t}\n\t\t\t\n\t\t\twhile(PQ.size()) {\n\t\t\t\tint cur=PQ.top().second;\n\t\t\t\tint sc=PQ.top().first;\n\t\t\t\tPQ.pop();\n\t\t\t\t\n\t\t\t\tif(D[j][cur]!=sc) continue;\n\t\t\t\tFORR(e,E[cur]) if(D[j][e]<sc) {\n\t\t\t\t\tD[j][e]=sc;\n\t\t\t\t\tPQ.push({sc,e});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFOR(x,N) {\n\t\t\tif(D[0][x]==-1<<30) P[i][x]=0;\n\t\t\telse if(D[0][x]==-D[1][x]) P[i][x]=1;\n\t\t\telse P[i][x]=2;\n\t\t}\n\t}\n\t\n\tFOR(i,M) {\n\t\tx=P[A[i]][B[i]]==2;\n\t\ty=G[B[i]][A[i]];\n\t\t\n\t\tif(x==y) cout<<\"same\"<<endl;\n\t\telse cout<<\"diff\"<<endl;\n\t}\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\nconst int Max_N(1050);\nconst int Max_M(200050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct edge\n{\n\tedge(int _t, int _pos) : t(_t), pos(_pos) {}\n\tint t, pos;\n};\nint N, M, S, Ans[Max_M];\nvector<edge> G[Max_N];\nbool done[Max_N], Can[Max_N][Max_N];\n\nvoid dfs1(int u)\n{\n\tif (Can[S][u])\n\t\treturn;\n\tCan[S][u] = true;\n\tfor (int i = 0, t;i < G[u].size();++i)\n\t\tdfs1(G[u][i].t);\n}\n\nvoid dfs2(int u)\n{\n\tif (done[u])\n\t\treturn;\n\tdone[u] = true;\n\tfor (int i = 0, t;i < G[u].size();++i)\n\t\tdfs2(G[u][i].t);\n}\n\nint main()\n{\n\tgi(N), gi(M);\n\tfor (int i = 1, s, t;i <= M;++i)\n\t\tgi(s), gi(t), G[s].push_back(edge(t, i)), Ans[i] = 0;\n\tfor (S = 1;S <= N;++S)\n\t{\n\t\tCan[S][S] = true;\n\t\tfor (int i = 0, t;i < G[S].size();++i)\n\t\t\tif (Can[S][t = G[S][i].t])\n\t\t\t\tAns[G[S][i].pos] = 1;\n\t\t\telse\n\t\t\t\tdfs1(t);\n\t}\n\tfor (S = 1;S <= N;++S)\n\t{\n\t\tmemset(done, false, sizeof(done)), done[S] = true; \n\t\tfor (int i = G[S].size() - 1, t;i >= 0;--i)\n\t\t\tif (done[t = G[S][i].t])\n\t\t\t\tAns[G[S][i].pos] = 1;\n\t\t\telse\n\t\t\t\tdfs2(t);\n\t}\n\tfor (int s = 1;s <= N;++s)\n\t\tfor (int i = 0;i < G[s].size();++i)\n\t\t\tif (Can[G[s][i].t][s])\n\t\t\t\t++Ans[G[s][i].pos];\n\tfor (int i = 1;i <= M;++i)\n\t{\n\t\tif (Ans[i] != 1)\n\t\t\tputc('s'), putc('a'), putc('m'), putc('e');\n\t\telse\n\t\t\tputc('d'), putc('i'), putc('f'), putc('f');\n\t\tputc('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 1005;\nconst int M = 200005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, m, U[M], V[M], id[N][N], ID;\nvector<int> e[N];\nint vis1[N], vis2[N];\nbool vis[N], ok1[N][N], ok2[N][N]; \n\nvoid DFS1(int u, int rt) {\n\tok1[rt][u] = vis[u] = 1;\n\tfor (auto v : e[u]) {\n\t\tif (vis[v]) continue;\n\t\tDFS1(v, rt);\n\t}\n}\n\nvoid DFS2(int u, int tp) {\n\tvis[u] = 1;\n\tfor (auto v : e[u]) {\n\t\tif (vis[v]) continue;\n\t\t(tp == 1? vis1[v] : vis2[v]) = id[u][v];\n\t\tDFS2(v, tp);\n\t}\n}\n\nvoid init() {\n\tread(n); read(m);\n\tfor (int i = 1, u, v; i <= m; ++i) {\n\t\tread(u); read(v);\n\t\tU[i] = u; V[i] = v;\n\t\tid[u][v] = ++ID;\n\t\te[u].push_back(v);\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmset(vis, 0);\n\t\tDFS1(i, i);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tmset(vis, 0);\n\t\tmset(vis1, 0);\n\t\tDFS2(i, 1);\n\t\treverse(e[i].begin(), e[i].end());\n\t\tmset(vis, 0);\n\t\tmset(vis2, 0);\n\t\tDFS2(i, 2);\n\t\tfor (auto v : e[i]) {\n\t\t\tok2[i][v] = (vis1[v] != id[i][v] || vis2[v] != id[i][v]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint u = U[i], v = V[i];\n\t\tputs(ok1[v][u] == ok2[u][v]? \"same\" : \"diff\");\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nvector<vector<int>> g, ind;\n\nvector<int> ord;\n\nvector<bool> usd;\nvector<vector<int>> gr;\nvector<int> comp;\nvoid ts(int u)\n{\n\tif (usd[u])\n\t\treturn;\n\tusd[u] = true;\n\tfor (int v : g[u])\n\t\tts(v);\n\tord.push_back(u);\n}\n\nvoid scc(int u, int c)\n{\n\tif (comp[u] != -1)\n\t\treturn;\n\tcomp[u] = c;\n\tfor (int v : gr[u])\n\t\tscc(v, c);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tg.resize(n);\n\tgr.resize(n);\n\tind.resize(n);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\tg[a].push_back(b);\n\t\tgr[b].push_back(a);\n\t\tind[a].push_back(i);\n\t}\n\tusd.resize(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tts(i);\n\treverse(ord.begin(), ord.end());\n\tcomp.resize(n, -1);\n\tint c = 0;\n\tfor (int x : ord)\n\t{\n\t\tif (comp[x] == -1)\n\t\t\tscc(x, c++);\n\t}\n\tvector<vector<int>> g1(c);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j : g[i])\n\t\t\tif (comp[i] != comp[j])\n\t\t\t\tg1[comp[i]].push_back(comp[j]);\n\tfor (auto& x : g1)\n\t{\n\t\t//sort(x.begin(), x.end());\n\t\t//x.resize(unique(x.begin(), x.end()) - x.begin());\n\t}\n\tvector<vector<int>> cc(c);\n\tfor (int i = 0; i < n; ++i)\n\t\tcc[comp[i]].push_back(i);\n\tvector<bool> diff(m);\n\tfor (int i = 0; i < c; ++i)\n\t{\n\t\tvector<int> q;\n\t\tvector<int> cnt(c, 0), from(n, -1);\n\t\tcnt[i] = 2;\n\t\tfrom[i] = i;\n\t\tfor (int j : g1[i])\n\t\t\tif (cnt[j] == 0)\n\t\t\t\tcnt[j] = 1, from[j] = j, q.push_back(j);\n\t\t\telse if (cnt[j] == 1)\n\t\t\t\t++cnt[j];\n\t\tfor (int it = 0; it < q.size(); ++it)\n\t\t{\n\t\t\tint x = q[it];\n\t\t\tfor (int y : g1[x])\n\t\t\t{\n\t\t\t\tif (cnt[y] == 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cnt[x] == 2)\n\t\t\t\t\tcnt[y] = 2, q.push_back(y);\n\t\t\t\telse if (cnt[y] == 1)\n\t\t\t\t{\n\t\t\t\t\tif (from[y] == from[x])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tcnt[y] = 2, q.push_back(y);\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\tcnt[y] = 1, from[y] = from[x], q.push_back(y);\n\t\t\t}\n\t\t}\n\t\tfor (int x : cnt)\n\t\t\tcerr << x << ' ';\n\t\tcerr << '\\n';\n\t\tfor (int i1 : cc[i])\n\t\t\tfor (int j = 0; j < g[i1].size(); ++j)\n\t\t\t\tif (i != comp[g[i1][j]] && cnt[comp[g[i1][j]]] == 2)\n\t\t\t\t\tdiff[ind[i1][j]] = true;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tvector<int> q;\n\t\tvector<int> cnt(n, 0), from(n, -1);\n\t\tcnt[i] = 2;\n\t\tfrom[i] = i;\n\t\tfor (int j : g[i])\n\t\t\tcnt[j] = 1, from[j] = j, q.push_back(j);\n\t\tfor (int it = 0; it < q.size(); ++it)\n\t\t{\n\t\t\tint x = q[it];\n\t\t\tfor (int y : g[x])\n\t\t\t{\n\t\t\t\tif (cnt[y] == 2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cnt[x] == 2)\n\t\t\t\t\tcnt[y] = 2, q.push_back(y);\n\t\t\t\telse if (cnt[y] == 1)\n\t\t\t\t{\n\t\t\t\t\tif (from[y] == from[x])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tcnt[y] = 2, q.push_back(y);\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\tcnt[y] = 1, from[y] = from[x], q.push_back(y);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < g[i].size(); ++j)\n\t\t\tif (comp[i] == comp[g[i][j]] && cnt[g[i][j]] != 2)\n\t\t\t\tdiff[ind[i][j]] = true;\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t\tif (diff[i])\n\t\t\tcout << \"diff\\n\";\n\t\telse\n\t\t\tcout << \"same\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\ts[++top]=e[p].k;\n\t\t\tif(vis[i][e[p].k]) continue;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>1;p--){\n\t\t\tif(vis[i][s[p]]) continue;\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define N 800002\ntypedef long long ll;\nvector<int>v[N];\nint n,m,a[N][2],rt,id[1002][1002],ie[1002][1002];\nbool re[1002][1002],vis[1002],nx[1002][1002];\nvoid dfs(int te)\n{\n\tfor(int i=0;i<v[te].size();i++)\n\t{\n\t\tint j=v[te][i];\n\t\tif(!re[rt][j])re[rt][j]=1,dfs(j);\n\t}\n}\nvoid df55(int te,int ti)\n{//printf(\"%d \",te);\n\tfor(int i=0;i<v[te].size();i++)\n\t{\n\t\tint j=v[te][i];if(te==rt)ti=i+1;\n\t\tif(!vis[j])\n\t\t{\n\t\t\tvis[j]=1;\n\t\t\tif(id[rt][j]&&id[rt][j]!=ti)nx[rt][j]=1;\n\t\t\tid[rt][j]=ti;df55(j,ti);\n\t\t}\n\t}\n}\nvoid df5(int te,int ti)\n{//printf(\"%d \",te);\n\tfor(int i=((int)v[te].size())-1;~i;i--)\n\t{\n\t\tint j=v[te][i];if(te==rt)ti=i+1;\n\t\tif(!vis[j])\n\t\t{\n\t\t\tvis[j]=1;\n\t\t\tif(id[rt][j]&&id[rt][j]!=ti)nx[rt][j]=1;\n\t\t\tid[rt][j]=ti;df5(j,ti);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);v[x].push_back(y);\n\t\ta[i][0]=x,a[i][1]=y;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\trt=i,re[rt][rt]=1,dfs(i);\n\t\tfor(int j=1;j<=n;j++)vis[j]=0;vis[i]=1;\n\t\tdf55(i,0);for(int j=1;j<=n;j++)vis[j]=0;vis[i]=1;\n\t\tdf5(i,0);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(re[a[i][1]][a[i][0]]^nx[a[i][0]][a[i][1]])puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//test\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\nstruct graph_t\n{\n\tint front,nex;\n}graph[201001],graph2[201001],graph3[201001];\nint tail=1000,tail2=1000,tail3=1000;\n\nvoid addedge(int u,int v)\n{\n\tint tmp=graph[u].nex;\n\tgraph[u].nex=++tail;\n\tgraph[tail].front=v;\n\tgraph[tail].nex=tmp;\n}\n\nvoid addedge2(int u,int v)\n{\n\tint tmp=graph2[u].nex;\n\tgraph2[u].nex=++tail2;\n\tgraph2[tail2].front=v;\n\tgraph2[tail2].nex=tmp;\n}\n\nvoid addedge3(int u,int v)\n{\n\tint tmp=graph3[u].nex;\n\tgraph3[u].nex=++tail3;\n\tgraph3[tail3].front=v;\n\tgraph3[tail3].nex=tmp;\n}\n\nint vis[1001];\npair<int,int> edge[200001];\nint nfinish=0;\nint finish[1001];\nint nconnect=0;\nint connect[1001];\nint indegree[1001],outdegree[1001];\nint cnt[1001][1001];\n\nvoid dfs1(int now)\n{\n\tvis[now]=1;\n\tfor(int i=graph[now].nex;i;i=graph[i].nex)\n\t{\n\t\tif(vis[graph[i].front]!=1)\n\t\t{\n\t\t\tdfs1(graph[i].front);\n\t\t}\n\t}\n\tfinish[nfinish++]=now;\n}\n\nvoid dfs2(int now)\n{\n//\tprintf(\"dfs2(%d)\\n\",now);\n\tvis[now]=2;\n\tconnect[now]=nconnect;\n\tfor(int i=graph2[now].nex;i;i=graph2[i].nex)\n\t{\n\t\tif(vis[graph2[i].front]!=2)\n\t\t{\n\t\t\tdfs2(graph2[i].front);\n\t\t}\n\t}\n}\n\nvoid dfs3(int from,int now)\n{\n\tfor(int i=graph3[now].nex;i;i=graph3[i].nex)\n\t{\n\t\tcnt[from][graph3[i].front]+=cnt[from][now];\n\t\tdfs3(from,graph3[i].front);\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\taddedge2(to,from);\n\t\tedge[i]=make_pair(from,to);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i]!=1)dfs1(i);\n\t}\n\tfor(int i=nfinish-1;i>=0;i--)\n\t{\n\t\tif(vis[finish[i]]!=2)\n\t\t{\n\t\t\tnconnect++;\n\t\t\tdfs2(finish[i]);\n\t\t}\n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<connect[i]<<\" \";\n\t}\n\tcout<<endl;*/\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=graph[i].nex;j;j=graph[j].nex)\n\t\t{\n\t\t\tif(connect[i]==connect[graph[j].front])\n\t\t\t{\n\t\t\t\toutdegree[i]++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=graph2[i].nex;j;j=graph2[j].nex)\n\t\t{\n\t\t\tif(connect[i]==connect[graph2[j].front])\n\t\t\t{\n\t\t\t\tindegree[i]++;\n\t\t\t}\n\t\t} \n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tprintf(\"in:%d,out:%d\\n\",indegree[i],outdegree[i]);\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(connect[from]!=connect[to])addedge3(connect[from],connect[to]);\n\t}\n\tfor(int i=1;i<=nconnect;i++)\n\t{\n\t\tcnt[i][i]=1;\n\t\tdfs3(i,i);\n\t}\n/*\tfor(int i=1;i<=nconnect;i++)\n\t{\n\t\tfor(int j=1;j<=nconnect;j++)\n\t\t{\n\t\t\tcout<<cnt[i][j];\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(connect[from]==connect[to])\n\t\t{\n\t\t\tif(indegree[to]==1||outdegree[from]==1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cnt[connect[from]][connect[to]]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/"
  },
  {
    "language": "C++",
    "code": "/// kAAzuki Hoshino\n/*\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long long ll;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n//#define inf 1000000000\n#define mod 1000000007\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n    return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n    o<<\"{\";\n    for(const T& v:vc) o<<v<<\",\";\n    o<<\"}\";\n    return o;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MAXM = 200005;\nconst int MAXN = 1005;\nint used[MAXM], condition[MAXM], vis[MAXN][MAXN], a[MAXM], b[MAXM] ;\nvi adj[MAXN];\nint N,M;\nint r[MAXN];\n\nvoid dfs(int s, int base){\n\tif(vis[base][s])return;\n\tvis[base][s]=1;\n\tfor(auto t:adj[s]){\n\t\tdfs(t, base);\n\t}\n}\n\nvoid bfs(int s){\n\tmemset(used,0,sizeof(used));\n\tmemset(r,-1,sizeof(r));\n\tfor(auto t:adj[s]){\n\t\tif(r[t]!=-1){\n\t\t\tused[t]=1;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<int> q;\n\t\tq.push(t);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tr[v] = t;\n\t\t\tfor(auto u:adj[v]){\n\t\t\t\tif(u==s)continue;\n\t\t\t\tif(r[u]!=-1){\n\t\t\t\t\tif(r[u]!=t)used[u]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor(int i=1;i<=N;i++)if(used[i])q.push(i);\n\twhile(!q.empty()){\n\t\tint v = q.front();q.pop();\n\t\tused[v]=1;\n\t\tfor(auto t:adj[v]){\n\t\t\tif(t==s)continue;\n\t\t\tif(used[t])continue;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\tfor(int i=1;i<=M;i++){\n\t\tif(a[i]==s){\n\t\t\tcondition[i] = used[b[i]];\n\t\t}\n\t}\n\n}\n\nsigned main(){\nIOS;\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n\t\n\tcin >> N >> M;\n  for(int i=1;i<=M;i++){\n  \tcin >> a[i] >> b[i];\n  \tadj[a[i]].pb(b[i]);\n  }  \n  for(int i=1;i<=N;i++){\n  \tdfs(i, i);\n  }\n  for(int i=1;i<=N;i++){\n  \tbfs(i);\n  }\n  for(int i=1;i<=M;i++){\n  \tif(condition[i]==vis[b[i]][a[i]]){\n  \t\tcout << \"same\" << endl;\n  \t}\n  \telse cout << \"diff\" << endl;\n  }\n\nreturn 0;\n}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+1;\nint n,m;\nint f[N][N][2],e[N*N][2],g[N],a[N*N][2];\nvoid ins(int x,int y){\n    static int sum=1;\n    a[++sum][0]=y,a[sum][1]=g[x],g[x]=sum;\n}\nvoid dfs(int x,int s,int v){ \n    for (int i=g[x];i;i=a[i][1])\n        if (a[i][0]!=s){\n            if (x==s)v=a[i][0];\n            if (f[s][a[i][0]][0]==v||f[s][a[i][0]][1]==v||(f[s][a[i][0]][0]&&f[s][a[i][0]][1]))continue;\n            if (!f[s][a[i][0]][0])f[s][a[i][0]][0]=v;\n            else\n                f[s][a[i][0]][1]=v;\n            dfs(a[i][0],s,v);\n        }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for (int i=1;i<=m;i++){\n        cin>>e[i][0]>>e[i][1];\n        ins(e[i][0],e[i][1]);\n    }\n    for (int i=1;i<=n;i++)\n        dfs(i,i,0);\n    for (int i=1;i<=m;i++){\n        bool sig=f[e[i][1]][e[i][0]][0];\n        bool sig1=((f[e[i][0]][e[i][1]][0]&&f[e[i][0]][e[i][1]][0]!=e[i][1])||(f[e[i][0]][e[i][1]][1]&&f[e[i][0]][e[i][1]][1]!=e[i][1]));\n        sig==sig1?cout<<\"same\"<<endl:cout<<\"diff\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <vector>\nconst int maxn = 1005;\nconst int maxm = 200005;\nstd::vector<int> G[maxn], RG[maxn];\ninline void ins_edge(int u, int v) {\n  G[u].push_back(v);\n  RG[v].push_back(u);\n}\n\nbool rvis[maxn];\nvoid dfs_r(int x) {\n  rvis[x] = true;\n  for(int v : RG[x]) {\n    if(!rvis[v]) {\n      dfs_r(v);\n    }\n  }\n}\n\nint typ[maxn][2];\nvoid dfs_t(int x, int bg) {\n  if(typ[x][0]) {\n    typ[x][1] = bg;\n  } else {\n    typ[x][0] = bg;\n  }\n  for(int v : G[x]) {\n    if(!typ[v][1] && typ[v][0] != bg) {\n      dfs_t(v, bg);\n    }\n  }\n}\n\nint E[maxm][2];\nint flag[maxn][maxn];\ninline void deal(int s) {\n  memset(rvis, 0, sizeof(rvis));\n  dfs_r(s);\n  for(int v : G[s]) {\n    if(rvis[v]) {\n#ifdef LOCAL\n      printf(\"Edge (%d, %d) type 1\\n\", s, v);\n#endif\n      flag[s][v] ^= 1;\n    }\n  }\n  memset(typ, 0, sizeof(typ));\n  typ[s][0] = typ[s][1] = 0x7f7f7f7f;\n  for(int v : G[s]) {\n    dfs_t(v, v);\n  }\n  for(int v : G[s]) {\n    if(typ[v][1]) {\n#ifdef LOCAL\n      printf(\"Edge (%d, %d) type 2(%d, %d)\\n\", s, v, typ[v][0], typ[v][1]);\n#endif\n      flag[s][v] ^= 1;\n    }\n  }\n}\n\nint main() {\n  int n, m; scanf(\"%d%d\", &n, &m);\n  for(int i = 1; i <= m; i ++) {\n    int u, v; scanf(\"%d%d\", &u, &v);\n    E[i][0] = u; E[i][1] = v;\n    ins_edge(u, v);\n  }\n  for(int i = 1; i <= n; i ++) deal(i);\n  for(int i = 1; i <= m; i ++) {\n    const int u = E[i][0], v = E[i][1];\n    if(flag[u][v]) {\n      puts(\"diff\");\n    } else {\n      puts(\"same\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define L long long\n\nusing namespace std;\n\nL n,m;\nL s[100010],e[100010];\nL ih[1111][1111];\nL chk[1111];\n\nvector<L>v[1111],back[1111];\nqueue<L>Q;\n\n\nL chk1[1111],chk2[1111];\n\nL ord[1111],ordtop;\nL scc[1111],scccolor;\n\nvoid dfs1(L x){\n\tL i;\n\tfor(i=0;i<v[x].size();i++)\n\t{\n\t\tif(!chk1[v[x][i]])\n\t\t{\n\t\t\tchk1[v[x][i]]=1;\n\t\t\tdfs1(v[x][i]);\n\t\t}\n\t}\n\tordtop++;\n\tord[ordtop]=x;\n}\n\nvoid dfs2(L x){\n\tscc[x]=scccolor;\n\tL i;\n\tfor(i=0;i<back[x].size();i++)\n\t{\n\t\tif(!chk2[back[x][i]])\n\t\t{\n\t\t\tchk2[back[x][i]]=1;\n\t\t\tdfs2(back[x][i]);\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tL i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&s[i],&e[i]);\n\t\tv[s[i]].push_back(e[i]);\n\t\tback[e[i]].push_back(s[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t\tchk[j]=0;\n\t\tchk[i]=-1;\n\t\tfor(j=0;j<v[i].size();j++)\n\t\t{\n\t\t\tchk[v[i][j]]=v[i][j];\n\t\t\tQ.push(v[i][j]);\n\t\t}\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tL x=Q.front();Q.pop();\n\t\t\t//printf(\"%lld %lld, \",x,chk[x]);\n\t\t\tfor(j=0;j<v[x].size();j++)\n\t\t\t{\n\t\t\t\tif(chk[x]==-1)\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(chk[v[x][j]])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chk[v[x][j]]!=chk[x]&&chk[v[x][j]]!=-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tih[i][v[x][j]]=1;\n\t\t\t\t\t\t\tchk[v[x][j]]=-1;\n\t\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchk[v[x][j]]=chk[x];\n\t\t\t\t\t\tQ.push(v[x][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//puts(\"\");\n\t}\n\t\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(!chk1[i])\n\t\t{\n\t\t\tchk1[i]=1;\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\tfor(i=n;i>=1;i--)\n\t{\n\t\tif(!chk2[ord[i]])\n\t\t{\n\t\t\tscccolor++;\n\t\t\tchk2[ord[i]]=1;\n\t\t\tdfs2(ord[i]);\n\t\t}\n\t}\n\t\n\t/*for(i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%lld \",scc[i]);\n\t}*/\n\t\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tprintf(ih[s[i]][e[i]]^(scc[s[i]]==scc[e[i]])?\"diff\":\"same\");\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define cri const register int\n#define re register\nusing namespace std;\nvector<int>to[1010];\nint n,m,a[200010],b[200010],fi[2][1010][1010];\nint V[1010],v[1010],X,now,dfn[1010],low[1010],bl[1010],sta[1010],top,num,dcc;\nvoid tj(cri x){\n\tsta[++top]=x;v[x]=1;\n\tdfn[x]=low[x]=++num;\n\tfor(int y:to[x]) if(!dfn[y])\n\t\ttj(y),low[x]=min(low[x],low[y]);\n\telse if(v[y]) low[x]=min(low[x],dfn[y]);\n\tif(low[x]==dfn[x]){\n\t\t++dcc;\n\t\twhile(sta[top]!=x) bl[sta[top]]=dcc,v[sta[top--]]=0;\n\t\tbl[sta[top]]=dcc;v[sta[top--]]=0;\n\t}\n}\nvoid dfs(cri x,cri opt,cri fr){\n\tif(V[x]==now) return;\n\tfi[opt][X][x]=fr;\n\tfor(int y:to[x]) dfs(y,opt,fr);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) \n\t\tscanf(\"%d%d\",&a[i],&b[i]),to[a[i]].push_back(b[i]);\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) tj(i);//cout<<1<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tV[i]=++now;X=i;\n\t\tfor(int j=0;j<to[i].size();j++) dfs(to[i][j],0,to[i][j]);\n\t\tV[i]=++now;\n\t\tfor(int j=-1+to[i].size();~j;j--) dfs(to[i][j],1,to[i][j]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tcri x=a[i],y=b[i];\n\t\tif(bl[x]!=bl[y]&&fi[0][x][y]!=fi[1][x][y]) puts(\"diff\");\n\t\telse if(bl[x]==bl[y]&&fi[0][x][y]==y&&fi[1][x][y]==y) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define P pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\nconst int N=1005;\nint n,m,x,y;\nint d[N];\nvector<P>e[N];\nvector<int>e2[N];\nbool can[N],bz[N],bz2[N];\nvoid cover(int x){\n\tif(bz2[x])return;\n\tbz2[x]=1;d[1]=x;\n\tfor(int l=0,r=1;x=d[++l],l<=r;)\n\t\tfor(P i:e[x])if(!bz2[i.fi])\n\t\t\tbz2[i.fi]=1,d[++r]=i.fi;\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfo(i,1,m){\n\t\tcin>>x>>y;\n\t\te[x].pb(P(y,i));\n\t\te2[y].pb(x);\n\t}\n\tfo(i,1,n){\n\t\tfo(j,1,n)bz2[j]=bz[j]=0;\n\t\td[1]=i;bz[i]=1;\n\t\tfor(int l=0,r=1;x=d[++l],l<=r;)\n\t\t\tfor(int i:e2[x])if(!bz[i])\n\t\t\t\td[++r]=i,bz[i]=1;\n\t\tbz2[i]=1;\n\t\tfor(P j:e[i]){\n\t\t\tcan[j.se]=bz2[j.fi];\n\t\t\tcover(j.fi);\n\t\t}\n\t\tfo(j,1,n)bz2[j]=0;\n\t\tfd(j,0,e[i].size()-1){\n\t\t\tx=e[i][j].fi;\n\t\t\ty=e[i][j].se;\n\t\t\tcan[y]|=bz2[x];\n\t\t\tcover(x);\n\t\t\tcan[y]=can[y]?(bz[x]?0:1):(bz[x]?1:0);\n\t\t}\n\t}\n\tfo(i,1,m)printf(can[i]?\"diff\\n\":\"same\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1e3 + 10, MAX_M = 2e5 + 10;\n\nstruct Edge {\n    int v, id;\n    Edge() {}\n    Edge(int v, int id) : v(v), id(id) {}\n};\n\nint N, M, nScc, degScc[MAX_N], way[MAX_N];\nbool ans[MAX_M];\nvector<Edge> edge[MAX_N], edgeScc[MAX_N];\nvector<int> nodesScc[MAX_N];\n\nint dfn[MAX_N], low[MAX_N], scc[MAX_N], dfs_tick;\nstack<int> stk;\n\nvoid tarjan(int x) {\n    dfn[x] = low[x] = ++dfs_tick;\n    stk.push(x);\n    for (Edge _i : edge[x]) {\n        int i = _i.v;\n        if (!dfn[i]) {\n            tarjan(i);\n            low[x] = min(low[x], low[i]);\n        } else if (!scc[i]) low[x] = min(low[x], dfn[i]);\n    }\n    if (low[x] >= dfn[x]) {\n        nScc++;\n        while (stk.top() != x) scc[stk.top()] = nScc, nodesScc[nScc].push_back(stk.top()), stk.pop();\n        scc[stk.top()] = nScc; nodesScc[nScc].push_back(stk.top()); stk.pop();\n    }\n}\n\nvector<Edge> edge_local[MAX_N];\nvector<pair<int, int>> back[MAX_N];\nbool in_stk[MAX_N];\n\nvoid tarjan_local(int x, vector<int> &edge_tree) {\n    low[x] = dfn[x] = ++dfs_tick;\n    stk.push(x); in_stk[x] = true;\n    back[x].clear();\n    back[x].emplace_back(dfn[x], 0);\n    back[x].emplace_back(dfn[x], 0);\n    for (Edge _i : edge_local[x]) {\n        int i = _i.v;\n        if (!dfn[i]) {\n            edge_tree.push_back(_i.id);\n            tarjan_local(i, edge_tree);\n            low[x] = min(low[x], low[i]);\n            back[x].insert(back[x].end(), back[i].begin(), back[i].end());\n        } else if (in_stk[i]) {\n            low[x] = min(low[x], dfn[i]);\n            back[x].emplace_back(dfn[i], _i.id);\n        }\n    }\n    sort(back[x].begin(), back[x].end());\n    back[x].resize(2);\n    if (dfn[x] != 1 && back[x][1].first >= dfn[x]) {\n        ans[back[x][0].second] = true;\n    }\n    if (low[x] >= dfn[x]) {\n        while (stk.top() != x) in_stk[stk.top()] = false, stk.pop();\n        in_stk[stk.top()] = false; stk.pop();\n    }\n}\n\nvoid tarjan_check(int x, int &scc_cnt) {\n    low[x] = dfn[x] = ++dfs_tick;\n    stk.push(x); in_stk[x] = true;\n    for (Edge _i : edge_local[x]) {\n        int i = _i.v;\n        if (!dfn[i]) {\n            tarjan_check(i, scc_cnt);\n            low[x] = min(low[x], low[i]);\n        } else if (in_stk[i]) {\n            low[x] = min(low[x], dfn[i]);\n        }\n    }\n    if (low[x] >= dfn[x]) {\n        scc_cnt++;\n        while (stk.top() != x) in_stk[stk.top()] = false, stk.pop();\n        in_stk[stk.top()] = false; stk.pop();\n    }\n}\n\nvoid solve(int cid) {\n    vector<int> edge_tree;\n    for (int i : nodesScc[cid]) {\n        for (Edge _j : edge[i]) {\n            int j = _j.v;\n            if (scc[j] == cid) {\n                edge_local[i].push_back(_j);\n            }\n        }\n    }\n    for (int i : nodesScc[cid]) dfn[i] = low[i] = 0;\n    dfs_tick = 0;\n    tarjan_local(nodesScc[cid][0], edge_tree);\n    for (int i : edge_tree) {\n        for (int j : nodesScc[cid]) edge_local[j].clear(), dfn[j] = low[j] = 0;\n        dfs_tick = 0;\n        for (int j : nodesScc[cid]) {\n            for (Edge _k : edge[j]) {\n                int k = _k.v;\n                if (scc[k] != cid) continue;\n                if (_k.id != i) edge_local[j].push_back(_k);\n                else edge_local[k].emplace_back(j, 0);\n            }\n        }\n        int scc_cnt = 0;\n        for (int j : nodesScc[cid])\n            if (!dfn[j])\n                tarjan_check(j, scc_cnt);\n        if (scc_cnt != 1) ans[i] = true;\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    for (int i = 1; i <= M; i++) {\n        int a, b; scanf(\"%d%d\", &a, &b);\n        edge[a].emplace_back(b, i);\n    }\n    for (int i = 1; i <= N; i++)\n        if (!dfn[i])\n            tarjan(i);\n    for (int i = 1; i <= N; i++)\n        for (Edge _j : edge[i]) {\n            int j = _j.v;\n            if (scc[i] == scc[j]) continue;\n            edgeScc[scc[i]].emplace_back(scc[j], _j.id), degScc[scc[j]]++;\n        }\n    for (int i = 1; i <= nScc; i++) {\n        fill_n(way + 1, nScc, 0);\n        way[i] = 1;\n        for (int j = nScc; j; j--) {\n            for (Edge _k : edgeScc[j]) {\n                int k = _k.v;\n                way[k] = min(2, way[k] + way[j]);\n            }\n        }\n        for (Edge _j : edgeScc[i]) {\n            int j = _j.v;\n            if (way[j] > 1) {\n                ans[_j.id] = true;\n            }\n        }\n    }\n    for (int i = 1; i <= nScc; i++) {\n        solve(i);\n    }\n    for (int i = 1; i <= M; i++)\n        printf(ans[i] ? \"diff\\n\" : \"same\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[M],V[M];\nvector<int>e[N],d[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs1(int u,int k)\n{\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n        d[U[i]].push_back(V[i]);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=666;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis1[e[i][j]])\n            dfs1(e[i][j],d[i][j]);\n        for(int j=up-1;j>=0;j--)\n            if(!vis2[e[i][j]])\n            dfs2(e[i][j],d[i][j]);\n        for(int j=1;j<=n;j++)\n            if(vis1[j]&&j!=i)\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(mp[U[i]][V[i]]&&mp[V[i]][U[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1005;\nint mn[N][N],mx[N][N],a[N*200],b[N*200],n,m;\nvi e[N];\n\nint vis[N];\nvoid dfs(int u,int id,int from,int f){\n\tif(vis[u]||u==from)return; vis[u]=1;\n\tif(f)mx[from][u]=id;\n\telse mn[from][u]=id;\n\tfor(auto v:e[u])\n\t\tif(!vis[v])dfs(v,id,from,f);\n}\n\nint main(){\n\tread(n),read(m);\n\trep(i,1,m){\n\t\tread(a[i]),read(b[i]);\n\t\te[a[i]].pb(b[i]);\n\t}\n\trep(u,1,n){\n\t\tsort(e[u].begin(),e[u].end());\n\t\tint sz=e[u].size();\n\t\tmemset(vis,0,sizeof vis);\n\t\trep(i,0,sz-1)\n\t\t\tdfs(e[u][i],e[u][i],u,0);\n\t\tmemset(vis,0,sizeof vis);\n\t\tper(i,sz-1,0)\n\t\t\tdfs(e[u][i],e[u][i],u,1);\n\t}\n\trep(i,1,m)\n\t\tputs((!mx[b[i]][a[i]])==(mn[a[i]][b[i]]!=mx[a[i]][b[i]])\n\t\t\t\t?\"diff\":\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\nint n,m,minn[1005],maxx[1005],u[200005],v[200005];\nbool f1[1005][1005],f2[1005][1005],flag[1005];\nqueue<int>q;\nlong long tot;\nvector<int>out[1005];\nvoid bfs(int s,bool*flag,int*a)\n{\n\tflag[s]=1;\n\ta[s]=s;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(auto to:out[node])\n\t\t{\n\t\t\ttot++;\n\t\t\tif(!flag[to])\n\t\t\t{\n\t\t\t\tflag[to]=1,a[to]=s;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tout[u[i]].push_back(v[i]);\n\t}\n\tfor(int i=1;i<=n;i++)bfs(i,f1[i],minn);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsort(out[i].begin(),out[i].end());\n\t\tint t=(int)out[i].size();\n\t\tmemset(flag,0,sizeof(flag));\n\t\tflag[i]=1;\n\t\tfor(int j=0;j<t;j++)\n\t\t  if(!flag[out[i][j]])\n\t\t    bfs(out[i][j],flag,minn);\n\t\tmemset(flag,0,sizeof(flag));\n\t\tflag[i]=1;\n\t\tfor(int j=t-1;j>=0;j--)\n\t\t  if(!flag[out[i][j]])\n\t\t    bfs(out[i][j],flag,maxx);\n\t\tfor(auto x:out[i])f2[i][x]=minn[x]<maxx[x];\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(f1[v[i]][u[i]]^f2[u[i]][v[i]])puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define sz(a) (int)(a).size()\n#define rep(i, a, b) for (int i = (a), _b = (b); i < _b; ++i)\n#define frep(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef vector<ii> vii;\n\nconst int inf = 1e9 + 7;\nconst ll linf  = 1ll * inf * inf;\nconst int N = 1000 + 7;\nconst int M = 20;\nconst int multipleTest = 0;\n\nint ways[N][N];\nint n, m;\n\nvii edge;\n\nclass StrComp {\npublic:\n\tint num[N], low[N];\n\tint cs[N];\n\tvector<int> adj[N];\n\t int cnt = 0;\n\t int comps = 0;\n\tbitset<N> go[N];\n\tvector<int> rev[N];\n\tint tIn[N];\n\tvector<int> nxt;\n\t\n\tint dp[N];\n\t\n\tvoid init(int r) {\n\t\trep(i, 1, n + 1) {\n\t\t\tnum[i] = low[i] = cs[i] = 0;\n\t\t\tadj[i].clear();\n\t\t\tgo[i].reset();\n\t\t\trev[i].clear();\n\t\t\ttIn[i] = 0;\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tcnt = comps = 0;\n\t\t nxt.clear();\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tadj[e.first].push_back(e.second);\n\t\t\t} else if (e.first == r) {\n\t\t\t\tnxt.push_back(e.second);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) if (!num[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t\tif (!r || nxt.size() <= 1) return;\n\t\tfor (ii e : edge) {\n\t\t\tif (e.first != r && e.second != r) {\n\t\t\t\tif (cs[e.first] != cs[e.second]) {\n\t\t\t\t\tint u = cs[e.first], v = cs[e.second];\n\t\t\t\t\tif (!go[u][v]) {\n\t\t\t\t\t\tgo[u].set(v);\n\t\t\t\t\t\trev[u].push_back(v);\n\t\t\t\t\t\t++tIn[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) dp[cs[v]]++;\n\t\t\n\t\tstatic int q[N], bot, top;\n\t\tbot = top = 0;\n\t\tfor (int i = 1; i <= comps; ++i) if (!tIn[i]) q[top++] = i;\n\t\t\n\t\twhile (bot < top) {\n\t\t\tint u = q[bot++];\n\t\t\tfor (int v : rev[u]) {\n\t\t\t\ttIn[v]--;\n\t\t\t\tdp[v] += dp[u];\n\t\t\t\tif (!tIn[v]) {\n\t\t\t\t\tq[top++] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int v : nxt) if (dp[cs[v]] > 1) ways[r][v] = true;\n\t}\n\t\n\tvoid dfs(int u) {\n\t\tstatic stack<int> stk;\n\t\tlow[u] = num[u] = ++cnt;\n\t\tstk.push(u);\n\t\tfor (int v : adj[u]) {\n\t\t\tif (cs[v]) continue;\n\t\t\tif (!num[v]) {\n\t\t\t\tdfs(v);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], num[v]);\n\t\t\t}\n\t\t}\n\t\tif (low[u] == num[u]) {\n\t\t\tcs[u] = ++comps;\n\t\t\twhile (stk.top() != u) {\n\t\t\t\tcs[stk.top()] = comps;\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t\tassert(!stk.empty() && stk.top() == u);\n\t\t\tstk.pop();\n\t\t}\n\t}\n} st;\n\nbool can[N][N];\nint root;\nvector<int> adj[N];\n\nvoid dfs(int u) {\n\tcan[root][u] = true;\n\tfor (int v : adj[u]) {\n\t\tif (can[root][v]) continue;\n\t\tdfs(v);\n\t}\n}\n\n\nvoid solve() {\n\tcin >> n >> m;\n\tmemset(ways, 0, sizeof(ways));\n\trep(i, 0, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tedge.push_back({u, v});\n\t\tadj[u].push_back(v);\n\t}\n\tfor (int i = 1; i <= n; ++i) st.init(i);\n\tfor (int i = 1; i <= n; ++i) {\n\t\troot = i;\n\t\tdfs(i);\n\t}\n\tfor (ii e : edge) {\n\t\tint u = e.first;\n\t\tint v = e.second;\n\t\tif (can[v][u]) {\n\t\t\tif (ways[u][v]) puts(\"same\");\n\t\t\telse puts(\"diff\");\n\t\t} else {\n\t\t\tif (ways[u][v]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}\n\nint main() {\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin);\n\t//    freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tint Test = 1;\n\tif (multipleTest) {\n\t\tcin >> Test;\n\t}\n\tfor(int i = 0; i < Test; ++i) {\n\t\t//        printf(\"Case #%d: \", i + 1);\n\t\tsolve();\n\t}\n#ifdef _LOCAL_\n\tcout << \"\\n\" << 1.0 * clock() / CLOCKS_PER_SEC << \"\\n\";\n#endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n #include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nvector<int> G[1010],R[1010],T[1010],id[1010];\nint ord[1010];\nbool vis[1010];\nint mem[1010];\nint cnt,cnt1,cnt2;\nvector<int> V;\nint A[200010],B[200010];\nbool can[200010];\nint now = 0;\n\nvoid unit(int v)\n{\n    if(vis[v])return;\n    vis[v] = true;\n    mem[v] = 1;\n    for(int i = 0; i < G[v].size(); i++)if(now != v || (i < cnt1 && cnt2 < i))unit(G[v][i]);\n    return;\n}\n\nvoid DFS1(int v)\n{\n    if(vis[v])return;\n    vis[v] = true;\n    for(int i = 0; i < G[v].size(); i++)DFS1(G[v][i]);\n    V.push_back(v);\n    return;\n}\n\nvoid DFS2(int v)\n{\n    if(ord[v] != 0)return;\n    ord[v] = cnt;\n    for(int i = 0; i < R[v].size(); i++)DFS2(R[v][i]);\n    return;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < M; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        R[b].push_back(a);\n        A[i] = a;\n        B[i] = b;\n        id[a].push_back(i);\n    }\n\n    memset(vis,false,sizeof(vis));\n    cnt = 0;\n    for(int i = 1; i <= N; i++)if(!vis[i])DFS1(i);\n    reverse(V.begin(),V.end());\n    for(int i = 1; i <= N; i++)if(ord[i] == 0)cnt++,DFS2(i);\n\n\n    for(int i = 1; i <= N; i++)\n    {\n        now++;\n        memset(mem,0,sizeof(mem));\n        memset(vis,false,sizeof(vis));\n        cnt1 = cnt2 = 0;\n        for(int j = 0; j < G[i].size(); j++)\n        {\n            cnt1++;\n            if(mem[B[id[i][j]]])can[id[i][j]] = true;\n            unit(G[i][j]);\n        }\n        memset(mem,0,sizeof(mem));\n        memset(vis,false,sizeof(mem));\n        cnt1 = cnt2 = G[i].size() - 1;\n        for(int j = G[i].size() - 1; j >= 0; j--)\n        {\n            cnt2--;\n            if(mem[B[id[i][j]]])can[id[i][j]] = true;\n            unit(G[i][j]);\n        }\n    }\n\n    for(int i = 0; i < M; i++)\n    {\n        int a = A[i],b = B[i];\n        if(ord[a] != ord[b])\n        {\n            if(can[i])printf(\"diff\\n\");\n            else printf(\"same\\n\");\n        }\n        else\n        {\n            if(can[i])printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#define maxn 1005\n#define _ 0\nusing namespace std;\nstruct nod\n{\n\tint nex,id;\n\tnod(int a,int b)\n\t{\n\t\tnex=a;\n\t\tid=b;\n\t}\n\tnod(){}\n};\nint n,m,tim;\nint vis[maxn];\nint bel[maxn][maxn][2];\nint u[maxn*maxn],v[maxn*maxn];\nvector<nod> edge[maxn];\nvoid dfs(int now,int fa,int b,int f)\n{\n\tvis[now]=tim; bel[fa][now][f]=b;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,fa,b,f);\n}\nvoid solve(int now)\n{\n\ttim++; vis[now]=tim;\n\tint len=edge[now].size();\n\tfor(int i=0;i<len;i++)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,0);\n\n\ttim++; vis[now]=tim;\n\tfor(int i=len-1;i>=0;i--)\n\t\tif(vis[edge[now][i].nex]!=tim)\n\t\t\tdfs(edge[now][i].nex,now,edge[now][i].id,1);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tedge[u[i]].push_back(nod(v[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsolve(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif( (bel[v[i]][u[i]][0]!=0) ^ _ ^ (bel[u[i]][v[i]][0]!=i || bel[u[i]][v[i]][1]!=i) )\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector< pair< int, int > > g[200000];\nusing int64 = unsigned long long;\nbool ans[200000];\n\nstruct StronglyConnectedComponents {\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y) {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k) {\n    return (comp[k]);\n  }\n\n  void dfs(int idx) {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build() {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n  }\n};\n\nvoid dfs(int idx) {\n\n  for(int _ = 0; _ < g[idx].size(); _ += 64) {\n    int l = _, r = min< int >(g[idx].size(), _ + 64);\n\n    queue< int64 > que;\n    vector< int64 > dp(N);\n    vector< vector< int64 > > qs(N);\n\n    for(int i = l; i < r; i++) {\n      auto &e = g[idx][i];\n      qs[e.first].emplace_back(i - l);\n      dp[idx] |= 1uLL << (i - l);\n    }\n    que.emplace(idx);\n\n    while(que.size()) {\n      int p = que.front();\n      que.pop();\n      for(int i = 0; i < g[p].size(); i++) {\n        auto &e = g[p][i];\n        auto pv = dp[e.first];\n        if(p == idx && l <= i && i < r && (dp[p] >> (i - l)) & 1) {\n          dp[e.first] |= dp[p] ^ (1uLL << (i - l));\n        } else {\n          dp[e.first] |= dp[p];\n        }\n        if(pv != dp[e.first]) que.emplace(e.first);\n      }\n\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(auto &s : qs[i]) {\n        if((dp[i] >> s) & 1) ans[g[idx][s + l].second] = true;\n      }\n    }\n\n  }\n}\n\nint X[200000], Y[200000];\nbool v[2000][2000];\n\nvoid dfs2(int idx, int idx2) {\n  if(v[idx][idx2]++) return;\n  for(auto &to : g[idx]) dfs2(to.first, idx2);\n}\n\nint main() {\n\n  scanf(\"%d %d\", &N, &M);\n  StronglyConnectedComponents scc(N);\n\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    --a, --b;\n    X[i] = a, Y[i] = b;\n    g[a].emplace_back(b, i);\n    scc.add_edge(a, b);\n  }\n  scc.build();\n\n  for(int i = 0; i < N; i++) {\n    dfs(i);\n    dfs2(i, i);\n  }\n  for(int i = 0; i < M; i++) {\n    puts(ans[i] ^ (scc[X[i]] == scc[Y[i]]) ? \"diff\" : \"same\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 1e3 + 5;\nconst int M = 5e5 + 5;\n \nint fir[N] , ne[M] , to[M] , cnt , x , y , scc[N] , scc_tot , dfs_clock , dfn[N] , low[N] , Id[M] , n , m;\nint A[M] , B[M];\nint stk[N] , top;\nint ans[M];\nint L[N][N], R[N][N];\n\nvoid add(int x, int y) {\n\tne[++ cnt] = fir[x];\n\tfir[x] = cnt;\n\tto[cnt] = y;\n}\n\nbool can[N][N];\n\nqueue <int> q;\n\nvector <int> son[N];\n\n#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])\n\nvoid solve(int x) {\n\twhile(!q.empty()) q.pop();\n\tq.push(x);\n\twhile(!q.empty()) {\n\t\tint ind = q.front();\n\t\tcan[x][ind] = 1;\n\t\tq.pop();\n\t\tForeachson(i, ind) {\n\t\t\tint V = to[i];\n\t\t\tif(can[x][V]) continue;\n\t\t\tq.push(V);\n\t\t\tcan[x][V] = 1;\n\t\t}\n\t}\n\t\n\tForeachson(i, x) {\n\t\tint V = to[i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!L[x][V]) {\n\t\t\tq.push(V);\n\t\t\tL[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tForeachson(j, ind) {\n\t\t\t\tint v = to[j];\n\t\t\t\tif(!L[x][v] && v != x) {\n\t\t\t\t\tL[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < (int) son[x].size(); ++ i) {\n\t\tint V = son[x][i];\n\t\twhile(!q.empty()) q.pop();\n\t\tif(!R[x][V]) {\n\t\t\tq.push(V);\n\t\t\tR[x][V] = V;\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint ind = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int j = 0; j < (int) son[ind].size(); ++ j) {\n\t\t\t\tint v = son[ind][j];\n\t\t\t\tif(!R[x][v] && v != x) {\n\t\t\t\t\tR[x][v] = V;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nmain(void) {\n\tscanf(\"%d%d\" , &n , &m);\n\tfor(int i = 1;i <= m;++ i) {\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tA[i] = x , B[i] = y;\n\t\tadd(x, y);\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tForeachson(j, i) {\n\t\t\tint V = to[j];\n\t\t\tson[i].push_back(V);\n\t\t}\n\t\treverse(son[i].begin(), son[i].end());\n\t}\n\t\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tsolve(i);\n\t}\n\t\n\tfor(int i = 1; i <= m; ++ i) {\n\t\tif(L[A[i]][B[i]] != B[i] || R[A[i]][B[i]] != B[i]) {\n\t\t\tif(!can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t\telse {\n\t\t\tif(can[B[i]][A[i]]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nll n,m;\nvector<ll> g[1010];\nvector<P> es;\nll cnt[1010][1010];\nbool vis[1010];\n\nvoid dfs(ll v,ll st){\n  vis[v]=true;\n  cnt[st][v]++;\n  for(ll nv : g[v]){\n    if(vis[nv]||nv==st||cnt[st][nv]>=2)continue;\n    dfs(nv,st);\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,m){\n    ll a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    es.push_back(P(a,b));\n  }\n\n  rep(i,n){\n    for(ll v : g[i]){\n      memset(vis,0,sizeof(vis));\n      dfs(v,i);\n    }\n  }\n\n  rep(i,m){\n    ll a=cnt[es[i].fi][es[i].se];\n    ll b=cnt[es[i].se][es[i].fi];\n    if((a>=2&&b>=1)||(a<2&&b<1))cout<<\"same\"<<endl;\n    else cout<<\"diff\"<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<unordered_map>\n#include<utility>\ntemplate<typename T>\nclass UnionFind {\n public:\n  void unite(const T& a, const T& b) {\n    auto x = find(a), y = find(b);\n    if(rank_[x] < rank_[y]) std::swap(x, y);\n    parent_[y] = x;\n    if(rank_[x] == rank_[y]) rank_[x] += 1;\n  }\n  T find(const T& x) {\n    if(!parent_.count(x)) {\n      rank_[x] = 1;\n      return parent_[x] = x;\n    }\n    return (parent_[x] == x) ? x : (parent_[x] = find(parent_[x]));\n  }\n private:\n  std::unordered_map<T, T> parent_;\n  std::unordered_map<T, int> rank_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight = long long;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// 強連結成分分解 O(|V| + |E|)\nstd::vector<std::vector<Vertex>> strongly_connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  std::stack<Vertex> S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  // Tarjan\n  std::function<int(Vertex v)> dfs = [&](Vertex v) {\n    num[v] = low[v] = ++timer;\n    S.push(v); inS[v] = true;\n    for(const auto& e: G[v]) {\n      if(!num[e.to])     low[v] = std::min(low[v], dfs(e.to));\n      else if(inS[e.to]) low[v] = std::min(low[v], num[e.to]);\n    }\n    if(num[v] == low[v]) {\n      scc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto w = S.top(); S.pop(); inS[w] = false;\n        scc.back().push_back(w);\n        if(v == w) break;\n      }\n    }\n    return low[v];\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v);\n  return scc;\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Graph G(N);\n  vector<int> a(M), b(M);\n  for(auto i=0; i<M; ++i) {\n    cin >> a[i] >> b[i];\n    --a[i]; --b[i];\n    G[a[i]].push_back({a[i], b[i]});\n  }\n\n  auto scc = strongly_connected_component(G);\n  vector<int> group(N);\n  for(auto i=0; i<scc.size(); ++i) for(auto v: scc[i]) group[v] = i;\n\n  vector<int> in(N), out(N);\n  UnionFind<int> uf;\n  for(auto i=0; i<M; ++i) if(group[a[i]] != group[b[i]]) {\n    ++in[b[i]];\n    ++out[a[i]];\n    uf.unite(group[a[i]], group[b[i]]);\n  }\n\n  vector<int> indeg(N), outdeg(N);\n  for(auto i=0; i<M; ++i) if(group[a[i]] == group[b[i]]) {\n    ++outdeg[a[i]];\n    ++indeg[b[i]];\n  }\n  for(auto i=0; i<M; ++i) {\n    if(group[a[i]]!=group[b[i]]) {\n      if(uf.find(group[a[i]]) == uf.find(group[b[i]])) {\n        auto ai = in[a[i]]+1;\n        auto ao = out[a[i]]-1;\n        auto bi = in[b[i]]-1;\n        auto bi = out[b[i]]+1;\n        if(1<=ai&&1<=ao&&1<=bi&&1<=bo)cout << \"diff\" <<endl;\n        else                          cout << \"same\" <<endl;\n      } else {\n        cout << \"same\" << endl;\n      }\n    } else {\n      if(1<outdeg[a[i]] && 1<indeg[b[i]]) cout << \"same\" << endl;\n      else                                cout << \"diff\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint fir[1010],ex[200010],ey[200010];\nstd::vector<int>G[1010];\nint vis[1010][1010],que[1010],hd,tl,from[1010];\nbool vv[1010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),x,y;\n\tfor(int i=1;i<=m;++i)ex[i]=x=gi(),ey[i]=y=gi(),G[x].push_back(y);\n\tfor(int s=1;s<=n;++s){\n\t\tint*v=vis[s];\n\t\tv[s]=1;hd=tl=0,que[tl++]=s;from[s]=0;\n\t\twhile(hd^tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i:G[x])\n\t\t\t\tif(!v[i])v[i]=1,from[i]=(x==s?i:from[x]),que[tl++]=i;\n\t\t\t\telse if(from[x]!=from[i])from[i]=-1;\n\t\t}\n\t\thd=tl=0,que[tl++]=s;\n\t\tmemset(vv,0,sizeof vv);vv[s]=1;\n\t\twhile(hd^tl){\n\t\t\tint x=que[hd++];\n\t\t\tfor(int i:G[x]){\n\t\t\t\tif(!vv[i])vv[i]=1,que[tl++]=i;\n\t\t\t\tif(x!=s&&i!=from[x])++v[i];\n\t\t\t\tif(x!=s&&from[x]!=from[i])from[i]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tx=ex[i],y=ey[i];\n\t\tif(vis[y][x])puts(vis[x][y]==1?\"diff\":\"same\");\n\t\telse puts(vis[x][y]==1?\"same\":\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nnamespace SCC{\n    void visit(const vector<vector<int>>&G,vector<int>&vs,vector<int>&used,int v){\n        used[v]=true;\n        for(auto u:G[v]){\n            if(!used[u])visit(G,vs,used,u);\n        }\n        vs.push_back(v);\n    }\n\n    void visit2(const vector<vector<int>>&T,vector<int>&used,vector<int>&comp,vector<int>&vec,int k,int v){\n        comp[v]=k;\n        used[v]=true;\n        vec.push_back(v);\n\n        for(auto u:T[v]){\n            if(!used[u])visit2(T,used,comp,vec,k,u);\n        }\n    }\n\n    void decompose(const vector<vector<int>>&G,vector<vector<int>>&H,vector<int>&comp){\n        vector<vector<int>>T(G.size());\n        for(int i=0;i<G.size();i++){\n            for(auto v:G[i]){\n                T[v].push_back(i);\n            }\n        }\n        comp.resize(G.size());\n\n        vector<int>vs(G.size());\n        vector<int>used(G.size());\n        for(int i=0;i<G.size();i++){\n            if(!used[i])visit(G,vs,used,i);\n        }\n        reverse(vs.begin(),vs.end());\n        fill(used.begin(),used.end(),0);\n\n        int K=0;\n        vector<vector<int>>S;\n        for(auto v:vs){\n            if(!used[v]){\n                S.push_back(vector<int>());\n                visit2(T,used,comp,S.back(),K++,v);\n            }\n        }\n\n        H.resize(K);\n        fill(used.begin(),used.end(),0);\n        for(int i=0;i<K;i++){\n            for(auto v:S[i]){\n                for(auto u:G[v]){\n                    if(comp[v]==comp[u])continue;\n                    H[comp[v]].push_back(comp[u]);\n                }\n            }\n        }\n\n    }\n}\n\n\n\nint N,M;\nint A[222222],B[222222];\nbool ans[222222];\n\nvector<vint>g;\nvector<vint>rg;\nvint comp;\n\nbool mark[2222];\nint semi[2222];\nvoid dfs(int v,int se){\n    semi[v]=se;\n    for(auto u:g[v]){\n        if(comp[v]!=comp[u])continue;\n        if(semi[u]!=-1)continue;\n        if(se==-5)dfs(u,u);\n        else dfs(u,se);\n    }\n}\n\nbool re[2222];\nvoid dfs2(int v){\n    re[v]=true;\n    for(auto u:rg[v]){\n        if(semi[v]!=semi[u])continue;\n        if(re[u])continue;\n        dfs2(u);\n    }\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&M);\n    g.resize(N);rg.resize(N);\n    rep(i,M){\n        scanf(\"%lld%lld\",&A[i],&B[i]);\n        A[i]--;B[i]--;\n        g[A[i]].pb(B[i]);\n        rg[B[i]].pb(A[i]);\n    }\n\n\n\n    vector<vint>h;\n    SCC::decompose(g,h,comp);\n\n    set<pint>latte;\n\n    rep(s,h.size()){\n        vint ei(h.size());\n        ei[s]=1;\n        for(int v=s;v<h.size();v++){\n            for(auto u:h[v]){\n                ei[u]+=ei[v];\n            }\n        }\n        for(auto u:h[s]){\n            if(ei[u]!=1)latte.insert({s,u});\n        }\n    }\n    rep(i,M){\n        if(latte.find({comp[A[i]],comp[B[i]]})!=latte.end())ans[i]=true;\n    }\n\n    latte=set<pint>();\n    rep(i,N){\n        memset(semi,-1,sizeof(semi));\n        memset(re,0,sizeof(re));\n        memset(mark,0,sizeof(mark));\n\n        dfs(i,-5);\n        rep(j,N)if(j==semi[j])dfs2(j);\n        rep(j,M)if(comp[A[j]]==comp[i]&&comp[B[j]]==comp[i]&&semi[A[j]]!=semi[B[j]]&&(A[j]!=i||semi[B[j]]!=B[j]))mark[B[j]]=true;\n\n        rep(j,N)if(mark[j]&&re[j])mark[semi[j]]=true;\n        for(auto u:g[i])if(u==semi[u]&&!mark[u])latte.insert({i,u});\n    }\n\n    rep(i,M){\n        if(latte.find({A[i],B[i]})!=latte.end())ans[i]=true;\n    }\n\n\n    rep(i,M){\n        if(ans[i])puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n// for testing\n\n//*\n\nvoid kosaraju(int);\nvoid kosaraju2(int, int);\n\nint mat[1010][1010];\n\nvoid kosaraju_mat(int f) {\n    for (int u=1; u<=n; ++u) {\n        if (mat[f][u] && !starred[u]) {\n            starred[u] = true;\n            kosaraju_mat(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2_mat(int f, int f2) {\n    unf[f] = f2;\n    for (int u=1; u<=n; ++u) {\n        if (mat[u][f] && !unf[u]) {\n            kosaraju2_mat(u, f2);\n        }\n    }\n}\n\nvoid slow_print() {\n    memset(starred, 0, 1010 * sizeof(bool));\n    memset(unf, 0, 1010 * sizeof(int));\n    kos.clear();\n    for (auto u : piv) {\n        mat[u.first][u.second] = 1;\n    }\n    int c = 0, i;\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n        int u = *it;\n        if (!unf[u]) {\n            ++c;\n            kosaraju2(u, u);\n        }\n    }\n    for (auto u : piv) {\n        int tc = 0;\n        --mat[u.first][u.second];\n        ++mat[u.second][u.first];\n        kos.clear();\n        memset(starred, 0, 1010 * sizeof(bool));\n        memset(unf, 0, 1010 * sizeof(int));\n        for (i=1; i<=n; ++i) {\n            if (!starred[i]) {\n                starred[i] = true;\n                kosaraju_mat(i);\n            }\n        }\n        for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n            int u = *it;\n            if (!unf[u]) {\n                ++tc;\n                kosaraju2_mat(u, u);\n            }\n        }\n        printf(\"%d\", c != tc);\n        //puts(c == tc ? \"same\" : \"diff\");\n        ++mat[u.first][u.second];\n        --mat[u.second][u.first];\n    }\n}\n\n//*/\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            res[removed][u] = 0;\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return res[removed][s] ? res[removed][s] : -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : bll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nvoid topological_sort(int f) {\n    for (int u : ll[f]) {\n        int n2 = unf[u];\n        if (!starred[n2]) {\n            starred[n2] = true;\n            topological_sort(n2);\n        }\n    }\n    topo_sort[topo_cnt++] = f;\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (auto it = kos.rbegin(); it != kos.rend(); ++it) {\n        int u = *it;\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n        /*\n        printf(\"i = %d\\n\", i);\n        for (int j=1; j<=n; ++j) {\n            printf(\"%d %d\\n\", starred[j], res[i][j]);\n        }\n        //*/\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    memset(starred, 0, 1010);\n    for (i=1; i<=n; ++i) {\n        int n2 = unf[i];\n        if (!starred[n2]) {\n            starred[n2] = true;\n            topological_sort(n2);\n        }\n    }\n    reverse(topo_sort, topo_sort + topo_cnt);\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=0; i<topo_cnt; ++i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    /*\n    for (i=1; i<=n; ++i) {\n        for (int j=1; j<=n; ++j) {\n            printf(\"%s\", dag_visit[i].test(j) ? \"1\" : \"0\");\n        }\n        puts(\"\");\n    }\n    //*/\n    for (i=1; i<=n; ++i) {\n        printf(\"%d \", unf[i]);\n    }\n    puts(\"\");\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n            //printf(\"%d\", t==-1 || t == u.first);\n        } else {\n            int n1 = unf[u.first], n2 = unf[u.second];\n            puts(dag_edge[n1][n2] >= 2 || dag_second_visit[n1].test(n2) ? \"diff\" : \"same\");\n            //printf(\"%d\", dag_edge[n1][n2] >= 2 || dag_second_visit[n1].test(n2));\n        }\n    }\n    /*\n    puts(\"===\");\n    slow_print();\n    //*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,x[200005],y[200005],book[1005];\nint top,nex[200005],to[200005],fir[1005];\nmap<int,int> mp[1005],mp2[1005];\ninline void lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\ninline void ss(int v,int w,int ww){\n\tbook[v]=i;\n\tif(ww==1)\n\t\tmp[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss(to[top1],w==0?top1:w,v==i?1:0);\n}\ninline void ss2(int v,int w,int ww){\n\tbook[v]=i;\n\tif(ww==1)\n\t\tmp2[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss2(to[top1],w==0?top1:w,v==i?1:0);\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=m;i++){\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t\tlj(x[i],y[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tss(i,0,0);\n\tfor(i=1;i<=top;i++){\n\t\tnex[i]=0;\n\t\tto[i]=0;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tbook[i]=0;\n\t\tfir[i]=0;\n\t}\n\ttop=0;\n\tfor(i=m;i>=1;i--)\n\t\tlj(x[i],y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tss2(i,0,0);\n\tfor(i=1;i<=m;i++){\n\t\tif((mp[y[i]][x[i]]!=0)+(mp[x[i]][y[i]]+mp2[x[i]][y[i]]==m+1)==1)\n\t\t\tprintf(\"same\\n\");\n\t\telse\n\t\t\tprintf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 1005;\nconst int Maxm = 200005;\nconst int mod1 = 1000000007;\nconst int mod2 = 1000000009;\n\nint n, m;\nint a[Maxm], b[Maxm];\nvector <ii> neigh[Maxn];\nint cur, tim[Maxn], low[Maxn];\nint imp[Maxm];\nint my[Maxn];\nvector <int> S;\nbool onStack[Maxn];\nint curcol, col[Maxn];\nint res[Maxm];\nvector <int> gneigh[Maxn];\nbool vis[Maxn];\nii ways[Maxn][Maxn];\n\nint Connect(int v)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tmy[v] = -1;\n\tS.push_back(v); onStack[v] = true;\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (!tim[u.first]) {\n\t\t\timp[u.second] |= 2;\n\t\t\tres += Connect(u.first); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v]) {\n\t\t\tif (my[v] != -1) imp[my[v]] ^= 1;\n\t\t\tlow[v] = tim[u.first];\n\t\t\timp[u.second] ^= 1; \n\t\t\tmy[v] = u.second;\n\t\t}\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tcurcol++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tcol[w] = curcol;\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int v, int forb)\n{\n\tint res = 0;\n\tcur++; tim[v] = low[v] = cur;\n\tS.push_back(v); onStack[v] = true;\n\tif (v == b[forb]) {\n\t\tint u = a[forb];\n\t\tif (!tim[u]) {\n\t\t\tres += Count(u, forb); low[v] = min(low[v], low[u]); \n\t\t} else if (onStack[u] && tim[u] < low[v])\n\t\t\tlow[v] = tim[u];\n\t}\n\tfor (int i = 0; i < neigh[v].size(); i++) {\n\t\tii u = neigh[v][i];\n\t\tif (u.second == forb) continue;\n\t\tif (!tim[u.first]) {\n\t\t\tres += Count(u.first, forb); low[v] = min(low[v], low[u.first]);\n\t\t} else if (onStack[u.first] && tim[u.first] < low[v])\n\t\t\tlow[v] = tim[u.first];\n\t}\n\tif (tim[v] == low[v]) {\n\t\tres++;\n\t\tint w;\n\t\tdo {\n\t\t\tw = S.back(); S.pop_back();\n\t\t\tonStack[w] = false;\n\t\t} while (w != v);\n\t}\n\treturn res;\n}\n\nint Count(int forb)\n{\n\tint ans = 0;\n\tcur = 0;\n\tfill(tim, tim + Maxn, 0); fill(low, low + Maxn, 0);\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tans += Count(i, forb);\n\treturn ans; \n}\n\nvoid Solve(int v)\n{\n\tif (vis[v]) return;\n\tvis[v] = true;\n\tfor (int i = 0; i < gneigh[v].size(); i++) {\n\t\tint u = gneigh[v][i];\n\t\tSolve(u);\n\t\tways[v][u].first = (ways[v][u].first + 1) % mod1;\n\t\tways[v][u].second = (ways[v][u].second + 1) % mod2;\n\t\tfor (int j = 1; j <= curcol; j++) {\n\t\t\tways[v][j].first = (ways[v][j].first + ways[u][j].first) % mod1;\n\t\t\tways[v][j].second = (ways[v][j].second + ways[u][j].second) % mod2;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d\", &a[i], &b[i]);\n\t\tneigh[a[i]].push_back(ii(b[i], i));\n\t}\n\tint comp = 0;\n\tfor (int i = 1; i <= n; i++) if (!tim[i])\n\t\tcomp += Connect(i);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (col[a[i]] != col[b[i]]) {\n\t\t\tgneigh[col[a[i]]].push_back(col[b[i]]);\n\t\t\tif (imp[i]) res[i] = Count(i) != comp;\n\t\t} else if (imp[i]) res[i] = Count(i) != comp;\n\tfor (int i = 1; i <= n; i++)\n\t\tSolve(i);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!imp[i] && col[a[i]] != col[b[i]])\n\t\t\tres[i] = ways[col[a[i]]][col[b[i]]] != ii(1, 1);\n\t\tprintf(\"%s\\n\", res[i]? \"diff\": \"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5,M=2e5+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N];\nint vis1[N],vis2[N];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs1(int u,int k)\n{\n    if(vis1[u]) return;\n    vis1[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis1[v]) continue;\n        dfs1(v,k);\n    }\n}\nvoid dfs2(int u,int k)\n{\n    if(vis2[u]) return;\n    vis2[u]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];if(vis2[v]) continue;\n        dfs2(v,k);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis1,0,sizeof(vis1));\n        memset(vis2,0,sizeof(vis2));\n        vis1[i]=vis2[i]=666;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            dfs1(e[i][j],j+1);\n        for(int j=up-1;j>=0;j--)\n            dfs2(e[i][j],j+1);\n        for(int j=1;j<=n;j++)\n            if(vis1[j])\n        {\n            if(vis1[j]==vis2[j]) mp[i][j]=1;\n            else mp[i][j]=2;\n        }\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]]==2) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]]==1) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N = 1005, M = 200005;\n\nint n, m, sc, cc, non, wh[N], col[N];\nbool vis[N], ans[M], shu[N], can[N];\npii e[M];\n\nvector<int> adj[N], rev[N], out[N], st;\n\nvoid tdfs (int I) {\n\tif(vis[I]) return;\n\tvis[I] = true;\n\tfor(auto &T : adj[I]) if(T != non) tdfs(T);\n\tst.push_back(I);\n}\n\nvoid rdfs (int I) {\n\tif(vis[I]) return;\n\twh[I] = sc;\n\tvis[I] = true;\n\tif(I != non) for(auto &T : rev[I]) rdfs(T);\n}\n\nvoid toposort (int I) {\n\tnon = I; sc = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vis[i]) tdfs(i);\n\t}\n\tfill(vis+1, vis+1+n, 0);\n\twhile(!st.empty()) {\n\t\tint T = st.back(); st.pop_back();\n\t\tif(!vis[T]) {rdfs(T); sc++;}\n\t}\n\tfill(vis+1, vis+1+n, 0);\n}\n\nvoid cdfs (int I) {\n\tcol[I] = cc;\n\tvis[I] = true;\n\tif(shu[I] && I != st[cc]) {\n\t\tcan[I] = true;\n\t\tif(wh[I] == wh[st[cc]]) can[st[cc]] = true;\n\t}\n\tfor(auto &T : adj[I]) {\n\t\tif(T == non) continue;\n\t\tif(vis[T]) {\n\t\t\tif(col[I] == col[T]) continue;\n\t\t\tif(wh[T] == wh[st[col[T]]]) can[st[col[T]]] = true;\n\t\t}\n\t\telse cdfs(T);\n\t}\n}\n\nvoid solve (int I) {\n\ttoposort(I);\n\tfor(auto &T : adj[I]) shu[T] = true;\n\tfor(auto &T : adj[I]) {\n\t\tif(vis[T]) continue;\n\t\tst.push_back(T);\n\t\tcdfs(T); cc++;\n\t}\n\tfor(auto &T : out[I]) {\n\t\tans[T] = can[e[T].Y];\n\t}\n\tcc = 0; st.clear();\n\tfill(vis+1, vis+1+n, 0);\n\tfill(shu+1, shu+1+n, 0);\n\tfill(can+1, can+1+n, 0);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\te[i] = {A, B};\n\t\tout[A].push_back(i);\n\t\tadj[A].push_back(B);\n\t\trev[B].push_back(A);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!out[i].empty()) solve(i);\n\t}\n\ttoposort(0);\n\tfor(int i=1;i<=m;i++) {\n\t\tputs(ans[i] ^ (wh[e[i].X] == wh[e[i].Y]) ? \"diff\" : \"same\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nstruct CostGraph\n{\n    using T = ll;\n    CostGraph(const int v) : V{v}, edge(v), rev_edge(v) {}\n    struct Edge\n    {\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        const int from;\n        const int to;\n        const T cost;\n        bool operator<(const Edge& e) const { return cost != e.cost ? cost < e.cost : to < e.to; }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge(to, from, cost));\n    }\n    const int V;\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n};\nclass StrongConnectedComponent\n{\npublic:\n    StrongConnectedComponent(const CostGraph& g)\n        : comp_num{0}, size(g.V), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            for (const auto& e : g.edge[i]) {\n                edge.push_back(make_pair(e.from, e.to));\n            }\n        }\n        vector<int> st;\n        vector<bool> used(size, false);\n        for (int i = 0; i < size; i++) {\n            if (not used[i]) {\n                dfs1_scc(g, i, st, used);\n            }\n        }\n        for (int i = 0; i < st.size(); i++) {\n            const int s = st[st.size() - i - 1];\n            if (comp[s] == -1) {\n                dfs2_scc(g, s, comp_num);\n                comp_num++;\n            }\n        }\n    }\n    const vector<int>& getComp() const { return comp; }\n    CostGraph toDAG() const\n    {\n        CostGraph dag(comp_num);\n        for (const auto& e : edge) {\n            const int u = comp[e.first];\n            const int v = comp[e.second];\n            if (u != v) {\n                dag.addEdge(u, v, 1);\n            }\n        }\n        return dag;\n    }\n\nprivate:\n    void dfs1_scc(const CostGraph& g, const int s, vector<int>& st, vector<bool>& used)\n    {\n        used[s] = true;\n        for (const auto& e : g.edge[s]) {\n            if (not used[e.to]) {\n                dfs1_scc(g, e.to, st, used);\n            }\n        }\n        st.push_back(s);\n    }\n    void dfs2_scc(const CostGraph& g, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g.rev_edge[s]) {\n            if (comp[e.to] == -1) {\n                dfs2_scc(g, e.to, c);\n            }\n        }\n    };\n    int comp_num;\n    const int size;\n    vector<int> comp;\n    vector<pair<int, int>> edge;\n};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(e, E) for (const auto& e : E)\n#define RESIDUE(s, t) (capacity[s][t] - flow[s][t])\nusing Weight = ll;\nusing Array = vector<ll>;\nusing Matrix = vector<vector<ll>>;\nstruct Edge\n{\n    Edge() = default;\n    Edge(const int src, const int dst, const ll weight) : src{src}, dst{dst}, weight{weight} {}\n    int src;\n    int dst;\n    ll weight;\n};\nusing Graph = vector<vector<Edge>>;\nGraph cutTree(const Graph& g)\n{\n    int n = g.size();\n    Matrix capacity(n, Array(n)), flow(n, Array(n));\n    for (int u = 0; u < n; u++) {\n        for (const int e : g[u]) {\n            capacity[u][e] += e.weight;\n        }\n    }\n\n    vector<int> p(n), prev;\n    vector<Weight> w(n);\n    for (int s = 1; s < n; ++s) {\n        int t = p[s];  // max-flow(s, t)\n        REP(i, n)\n        REP(j, n)\n        flow[i][j] = 0;\n        Weight total = 0;\n        while (1) {\n            queue<int> Q;\n            Q.push(s);\n            prev.assign(n, -1);\n            prev[s] = s;\n            while (!Q.empty() && prev[t] < 0) {\n                int u = Q.front();\n                Q.pop();\n                FOR(e, g[u])\n                if (prev[e.dst] < 0 && RESIDUE(u, e.dst) > 0) {\n                    prev[e.dst] = u;\n                    Q.push(e.dst);\n                }\n            }\n            if (prev[t] < 0) goto esc;\n            Weight inc = INF<ll>;\n            for (int j = t; prev[j] != j; j = prev[j])\n                inc = min(inc, RESIDUE(prev[j], j));\n            for (int j = t; prev[j] != j; j = prev[j])\n                flow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n            total += inc;\n        }\n    esc:\n        w[s] = total;  // make tree\n        REP(u, n)\n        if (u != s && prev[u] != -1 && p[u] == t)\n            p[u] = s;\n        if (prev[p[t]] != -1)\n            p[s] = p[t], p[t] = s, w[s] = w[t], w[t] = total;\n    }\n    Graph T(n);  // (s, p[s]) is a tree edge of weight w[s]\n    REP(s, n)\n    if (s != p[s]) {\n        T[s].push_back(Edge(s, p[s], w[s]));\n        T[p[s]].push_back(Edge(p[s], s, w[s]));\n    }\n    return T;\n}\n\n// Gomory-Hu tree を用いた最大流 O(n)\nWeight maximumFlow(const Graph& T, int u, int t, int p = -1, Weight w = INF<ll>)\n{\n    if (u == t) return w;\n    Weight d = INF<ll>;\n    FOR(e, T[u])\n    if (e.dst != p)\n        d = min(d, maximumFlow(T, e.dst, t, u, min(w, e.weight)));\n    return d;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    CostGraph g(N);\n    using P = pair<int, int>;\n    vector<P> edge(M);\n    Graph g_(N);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g.addEdge(u, v, 1);\n        g_[u].push_back(Edge{u, v, 1});\n        edge[i] = {u, v};\n    }\n\n    const auto tree = cutTree(g_);\n    StrongConnectedComponent scc(g);\n    const vector<int> comp = scc.getComp();\n    for (int i = 0; i < M; i++) {\n        const int u = edge[i].first;\n        const int v = edge[i].second;\n        if (comp[u] != comp[v]) {\n            const ll cut = maximumFlow(tree, u, v);\n            if (cut > 1) {\n                cout << \"diff\" << endl;\n            } else {\n                cout << \"same\" << endl;\n            }\n        } else {\n            const ll cut = maximumFlow(tree, u, v);\n            if (cut > 1) {\n                cout << \"diff\" << endl;\n            } else {\n                cout << \"same\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(int x){write(x);putchar('\\n');}\nconst int MAXN=1005;\nconst int MAXM=200005;\nstruct edge{int x,y,next;}a[MAXM];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\n\nbitset<MAXN> bi[MAXM+MAXN],bnow;\nvoid dfs(int x,int o)\n{\n\tif(bi[o][x])return ;\n\tbi[o][x]=1;\n\tfor(int k=last[x];k;k=a[k].next)dfs(a[k].y,o);\n}\nint ans[MAXM],sta[MAXM],tp;\nint n,m;\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);\n\t}\n\tfor(int i=1;i<=n;i++)dfs(i,m+i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttp=0;\n\t\tfor(int k=last[i],lst=1;k;k=a[k].next,lst++)\n\t\t{\n\t\t\tsta[++tp]=k;bi[lst]=bi[lst-1];\n\t\t\tbi[lst][i]=1;\n\t\t\tdfs(a[k].y,lst);\n\t\t}\n\t\tsta[tp+1]=0;\n\t\tbi[m+n+1].reset();bi[m+n+1][i]=1;\n\t\twhile(tp)\n\t\t{\n\t\t\tif(sta[tp+1])dfs(a[sta[tp+1]].y,m+n+1);\n\t\t\tbnow=bi[m+n+1]|bi[tp-1];\n\t\t\tint y=a[sta[tp]].y;\n\t\t\tif(bi[m+y][i]==bnow[y])\n\t\t\t\tans[sta[tp]]=1;\n\t\t\ttp--;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ans[i])puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define rpe(i,r,l) for(int i=(r);i>=(l);--i)\n#define rpp(i,x,e,head) for(int i=head[x];~i;i=e[i].next)\n#define dyes cerr<<\"yes\"<<endl\n#define dbg(x) cerr<<#x<<\"=\"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define pts puts(\"\")\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ninline ll readll(){\n    ll f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1LL;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\ntemplate <class T> inline void chmax(T &a,T b){if(a<b) a=b;}\ntemplate <class T> inline void chmin(T &a,T b){if(a>b) a=b;}\ninline void swap(int &a,int &b){int c=a;a=b;b=c;}\nusing namespace std;\n#define mst(a,val) memset(a,val,sizeof(a))\n#define pii pair<int,int>\n#define piii pair<int,pair<int,int> >\n#define mp(i,j) make_pair(i,j)\n#define fi first\n#define sc second\n#define inf (0x3f3f3f3f)\n#define infl (0x3f3f3f3f3f3f3f3fLL)\n#define forvec(i,j) for(vector<int>::iterator i=j.begin();i!=j.end();++i)\n#define forvecv(i,j) for(vector<int>::iterator i=--j.end();i>=j.begin();--i)\n//=====================head end======================//\nconst int N=1010;\nconst int M=2e5+10;\nstruct node{\n    int next,to,id;\n}e[M<<1];\nint head[N],cnt;\ninline void add(int u,int v,int id){\n    e[cnt].id=id;e[cnt].to=v;e[cnt].next=head[u];head[u]=cnt++;\n}\nint n,m;\nint rea[N][N],vis[N];\ninline void dfs1(int x,int frm){\n    vis[x]=1;rea[frm][x]=1;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(vis[v]) continue;\n\tdfs1(v,frm);\n    }\n}\nint p[N][N],q[N][N],col;\ninline void dfs2(int x,int frm){\n    p[frm][x]=col;vis[x]=1;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(vis[v]) continue;\n\tdfs2(v,frm);\n    }\n}\ninline void dfs3(int x,int frm){\n    q[frm][x]=col;vis[x]=1;\n    rpp(i,x,e,head){\n\tint v=e[i].to;if(vis[v]) continue;\n\tdfs3(v,frm);\n    }\n}\nstruct edge{int u,v,id;}E[N];\nint main(){\n    mst(head,-1);n=read();m=read();\n    rep(i,1,m){\n\tint u=read(),v=read();\n\tadd(u,v,i);E[i].id=i;E[i].u=u;E[i].v=v;\n     }\n    rep(i,1,n){rep(j,1,n) vis[j]=0;dfs1(i,i);}\n    rep(x,1,n){\n\tvector<int> fk;\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\trpp(i,x,e,head){\n\t    fk.push_back(i);\n\t    col=e[i].id;\n\t    int v=e[i].to;if(vis[v]) continue;\n\t    dfs2(v,x);\n\t}\n\treverse(fk.begin(),fk.end());\n\trep(j,1,n) vis[j]=0;vis[x]=1;\n\tfor(auto i:fk){\n\t    col=e[i].id;\n\t    int v=e[i].to;if(vis[v]) continue;\n\t    dfs3(v,x);\n\t}\n    }\n    rep(i,1,m){\n\tint u=E[i].u,v=E[i].v;\n\tint k=rea[v][u];\n\tk^=(p[u][v]!=i||q[u][v]!=i);\n\tif(k){puts(\"diff\");}\n\telse puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=1005;\nint n,m,foo[N][N],bar[N][N],ans[N*200];\nvector<int>E[N],Q[N];\nvoid dfs(int u,int c,int *mrk){\n\tif(mrk[u])return;mrk[u]=c;\n\tfor(int v:E[u])if(!mrk[v])dfs(v,c,mrk);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tE[x].push_back(y);\n\t\tQ[x].push_back(i);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfoo[i][i]=bar[i][i]=-1;\n\t\tfor(int j=0;j<E[i].size();++j)\n\t\t\tdfs(E[i][j],j+1,foo[i]);\n\t\tfor(int j=E[i].size()-1;~j;--j)\n\t\t\tdfs(E[i][j],j+1,bar[i]);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<E[i].size();++j){\n\t\t\tint x=(foo[E[i][j]][i]?1:0),y=(foo[i][E[i][j]]<=j)|(bar[i][E[i][j]]>j+1);\n\t\t\tans[Q[i][j]]=x^y;\n\t\t}\n\tfor(int i=1;i<=m;++i)puts(ans[i]?\"diff\":\"same\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,x[200005],y[200005],book[1005];\nint top,nex[200005],to[200005],fir[1005];\nmap<int,int> mp[1005],mp2[1005];\ninline void lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\ninline void ss(int v,int w){\n\tbook[v]=i;\n\tmp[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss(to[top1],w==0?top1:w);\n}\ninline void ss2(int v,int w){\n\tbook[v]=i;\n\tmp2[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss2(to[top1],w==0?top1:w);\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=m;i++){\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t\tlj(x[i],y[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tss(i,0);\n\tfor(i=1;i<=top;i++){\n\t\tnex[i]=0;\n\t\tto[i]=0;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tbook[i]=0;\n\t\tfir[i]=0;\n\t}\n\ttop=0;\n\tfor(i=m;i>=1;i--)\n\t\tlj(x[i],y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tss2(i,0);\n\tfor(i=1;i<=m;i++){\n\t\tif((mp[y[i]][x[i]]!=0)+(mp[x[i]][y[i]]+mp2[x[i]][y[i]]==m+1)==1)\n\t\t\tprintf(\"same\\n\");\n\t\telse\n\t\t\tprintf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200200;\ninline int read(int x=0,bool f=0,char ch=getchar()){\n\tfor(;!isdigit(ch);ch=getchar()) f=ch=='-';\n\tfor(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\nint n,m,tot,fi[N],to[N],u[N],ne[N];\nbool vis[1010][1010];\nint pre[1010][1010],suf[1010][1010],que[N],l,r;\nvoid dfs(int x,int id){\n\tvis[id][x]=true;\n\tfor(int i=fi[x];i;i=ne[i]) if(!vis[id][to[i]]) dfs(to[i],id);\n}\nvoid dfs1(int x,int id,int k){\n\tpre[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!pre[id][to[i]]) dfs1(to[i],id,k);\n}\nvoid dfs2(int x,int id,int k){\n\tsuf[id][x]=k;\n\tfor(int i=fi[x];i;i=ne[i]) if(!suf[id][to[i]]) dfs2(to[i],id,k);\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1,x,y;i<=m;++i) x=read(),y=read(),ne[++tot]=fi[x],u[tot]=x,to[fi[x]=tot]=y;\n\tfor(int i=1;i<=n;++i) dfs(i,i);\n\tfor(int i=1;i<=n;++i){\n\t\tvector<int> s; int sz=0; pre[i][i]=suf[i][i]=1;\n\t\tfor(int j=fi[i];j;j=ne[j]) s.push_back(to[j]);\n\t\tfor(int j:s){\n\t\t\t++sz;\n\t\t\tif(!pre[i][j]) dfs1(j,i,sz);\n\t\t}\n\t\treverse(s.begin(),s.end());\n\t\tfor(int j:s){\n\t\t\tif(!suf[i][j]) dfs2(j,i,sz);\n\t\t\t--sz;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint x=u[i],y=to[i];\n\t\tif(vis[y][x]^(pre[x][y]!=suf[x][y])) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 2005;\nconst LL M = 400005;\n\nvector <LL> G[N];\nLL vis[2][N][N],p[2][N],vi[N];\nLL eu[M],ev[M],n,m;\n\nvoid dfs_vis(LL u,LL rt){\n\tvis[0][rt][u] = 1;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(vis[0][rt][v]) continue;\n\t\tdfs_vis(v,rt);\n\t}\n}\n\nvoid get_vis(){\n\tfor(LL i = 1;i <= n;i ++){\n\t\tmemset(vi,0,sizeof(vi));\n\t\tdfs_vis(i,i);\n\t}\n}\n\nvoid dfs_sol(LL u,LL col,LL pid,LL rt){\n\tp[pid][u] = col;\n\tvi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++){\n\t\tLL v = G[u][i];\n\t\tif(p[pid][v]) continue;\n\t\tdfs_sol(v,col,pid,rt);\n\t}\n}\n\nvoid solve(LL u){\n\tmemset(p,0,sizeof(p));\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = 0;i < G[u].size();i ++) if(!vi[G[u][i]]) dfs_sol(G[u][i],i + 1,0,u);\n\tmemset(vi,0,sizeof(vi)); vi[u] = 1;\n\tfor(LL i = (LL)(G[u].size()) - 1;i >= 0;i --) if(!vi[G[u][i]]) dfs_sol(G[u][i],i + 1,1,u);\n\tfor(LL i = 1;i <= n;i ++) if(vi[i] && p[0][i] != p[1][i]) vis[1][u][i] = 1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(LL i = 1;i <= m;i ++){\n\t\tcin >> eu[i] >> ev[i];\n\t\tG[eu[i]].push_back(ev[i]);\n\t}\n\tget_vis();\n\tfor(LL i = 1;i <= n;i ++) solve(i);\n\tfor(LL i = 1;i <= m;i ++) cout << ((vis[0][ev[i]][eu[i]] ^ vis[1][eu[i]][ev[i]]) ? \"diff\" : \"same\") << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define inc(i,j,k) for(re int i=j;i<=k;i++)\nusing namespace std;\nconst int N=1e3+5;\nconst int M=2e5+5;\nbitset<N> vis;\nbool vis1[N][N],vis2[N][N];\nint n,m,a[M],b[M],mark[N];\nvector<int> to[N];\ninline void dfs1(int u,int s){\n\tif(vis1[s][u]) return;\n\tvis1[s][u]=1;\n\tfor(re int i=0;i<to[u].size();i++) dfs1(to[u][i],s);\n}\ninline void dfs2(int u,int s,int tp,int c){\n\tif(vis[u]) return;\n\tvis[u]=1;\n\tif(!tp) mark[u]=c;\n\telse vis2[s][u]=(c!=mark[u]);\n\tfor(re int i=0;i<to[u].size();i++) dfs2(to[u][i],s,tp,c);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tinc(i,1,m){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tto[a[i]].push_back(b[i]);\n\t}\n\tinc(i,1,n) dfs1(i,i);\n\tinc(u,1,n){\n\t\tvis.reset(),vis[u]=1;\n\t\tfor(re int i=0;i<to[u].size();i++) dfs2(to[u][i],u,0,i);\n\t\tvis.reset(),vis[u]=1;\n\t\tfor(re int i=to[u].size()-1;~i;i--) dfs2(to[u][i],u,1,i);\n\t}\n\tinc(i,1,m) puts(vis1[b[i]][a[i]]^vis2[a[i]][b[i]]?\"diff\":\"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define N 1010\nvector <int> nxt[N]; bool arr[N][N],arr2[N][N],vis[N]; int vis2[N],vis1[N],num[N][N],n,m,fr[N*300],to[N*300],idx;\nvoid init() {for(int i=1;i<=n;i++) vis[i]=false;}\nvoid dfs(int p,int from)\n{\n\tvis[p]=true,arr[from][p]=true;\n\tfor(int i=0;i<(int)nxt[p].size();i++) if(!vis[nxt[p][i]]) dfs(nxt[p][i],from);\n}\nvoid dfs2(int p)\n{\n\tvis[p]=true;\n\tfor(int i=0;i<(int)nxt[p].size();i++) if(!vis[nxt[p][i]])\n\t\tvis1[nxt[p][i]]=num[p][nxt[p][i]],dfs2(nxt[p][i]);\t\n}\nvoid dfs3(int p)\n{\n\tvis[p]=true;\n\tfor(int i=(int)nxt[p].size()-1;~i;i--) if(!vis[nxt[p][i]])\n\t\tvis2[nxt[p][i]]=num[p][nxt[p][i]],dfs3(nxt[p][i]);\t\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,a,b;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b),nxt[a].push_back(b);\n\t\tnum[a][b]=++idx,fr[idx]=a,to[idx]=b;\n\t}\n\tfor(int i=1;i<=n;i++) dfs(i,i),init();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdfs2(i),init(),dfs3(i),init();\n\t\tfor(int j=0;j<(int)nxt[i].size();j++)\n\t\t\tif(vis1[nxt[i][j]]!=num[i][nxt[i][j]]||vis2[nxt[i][j]]!=num[i][nxt[i][j]])\n\t\t\t\tarr2[i][nxt[i][j]]=true;\n\t\tfor(int j=1;j<=n;j++) vis1[i]=vis2[i]=0;\n\t}\n\tfor(int i=1;i<=idx;i++) printf(arr[to[i]][fr[i]]^arr2[fr[i]][to[i]]?\"diff\\n\":\"same\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m,tot;\nint vis[1005],c[1005][1005],d[1005][1005];\nvector<pii> adj[1005];\nbool ans[200005];\n\nvoid dfs1(int u,int f){\n\tc[f][u]=1;\n\tfor(auto v:adj[u]){\n\t\tif(vis[v.fi]) continue;\n\t\tvis[v.fi]=1;\n\t\tdfs1(v.fi,f);\n\t}\n}\n\nvoid dfs2(int u,int x,int f){\n\tfor(auto v:adj[u]){\n\t\tif(v.fi==x||vis[v.fi]) continue;\n\t\tvis[v.fi]=f;\n\t\tdfs2(v.fi,x,f);\n\t}\n}\n\nint main(){\n\tn=readint(); m=readint();\n\tint x,y;\n\tfor(int i=1;i<=m;i++){\n\t\tx=readint(); y=readint();\n\t\tadj[x].pb(mp(y,i));\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvis[i]=1;\n\t\tdfs1(i,i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(auto v:adj[i]){\n\t\t\tif(!vis[v.fi]){\n\t\t\t\tvis[v.fi]=v.fi;\n\t\t\t\tdfs2(v.fi,i,v.fi);\n\t\t\t}\n\t\t}\n\t\tfor(auto v:adj[i]) if(vis[v.fi]!=v.fi) d[i][v.fi]=1;\n\t\treverse(adj[i].begin(),adj[i].end());\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(auto v:adj[i]){\n\t\t\tif(!vis[v.fi]){\n\t\t\t\tvis[v.fi]=v.fi;\n\t\t\t\tdfs2(v.fi,i,v.fi);\n\t\t\t}\n\t\t}\n\t\tfor(auto v:adj[i]) if(vis[v.fi]!=v.fi) d[i][v.fi]=1;\n\t}\n\tfor(int i=1;i<=n;i++) for(auto v:adj[i]) if(c[v.fi][i]==d[i][v.fi]) ans[v.se]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(ans[i]) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nconst int MV = 1003;\nconst int ME = 200005;\n\nint n, m;\nvector<int> v[MV];\nint frm[ME], tar[ME];\nint way1[MV][MV], way2[MV][MV], dir[MV][MV];\n\nvoid input()\n{\n\tread(n), read(m);\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tread(frm[i]), read(tar[i]);\n\t\tdir[frm[i]][tar[i]]++;\n\t\tv[frm[i]].push_back(tar[i]);\n\t}\n}\n\nbool ban[MV];\n\nvoid dfs(int x, int *s)\n{\n\tfor(auto y : v[x])\n\t\tif(!s[y] && !ban[y])\n\t\t{\n\t\t\ts[y]++;\n\t\t\tdfs(y, s);\n\t\t}\n}\n\nvoid work()\n{\n\tfor(int x=1; x<=n; x++)\n\t{\n\t\tban[x] = 1;\n\t\tfor(int i=0; i<v[x].size(); i++) ban[v[x][i]] = 1, dfs(v[x][i], way1[x]), ban[v[x][i]] = 0;\n\t\tfor(int i=v[x].size()-1; i>=0; i--) ban[v[x][i]] = 1, dfs(v[x][i], way2[x]), ban[v[x][i]] = 0;\n\t\tban[x] = 0;\n\t}\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tdir[i][j] += way1[i][j]+way2[i][j];\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint a = frm[i], b = tar[i];\n\t\tif(dir[a][b]==1 && !dir[b][a]) puts(\"same\");\n\t\telse if(dir[a][b]>=2 && !dir[b][a]) puts(\"diff\");\n\t\telse if(dir[a][b]==1 && dir[b][a]) puts(\"diff\");\n\t\telse if(dir[a][b]>=2 && dir[b][a]) puts(\"same\");\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//save code\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <set>\nusing namespace std;\n\nvoid read(int &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n} \n\nvoid read(long long &x)\n{\n\tchar ch=getchar();bool f=0;x=0;\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\tif(f)x=-x;\n}\n\nstruct graph_t\n{\n\tint front,nex;\n}graph[201001],graph2[201001],graph3[201001];\nint tail=1000,tail2=1000,tail3=1000;\n\nvoid addedge(int u,int v)\n{\n\tint tmp=graph[u].nex;\n\tgraph[u].nex=++tail;\n\tgraph[tail].front=v;\n\tgraph[tail].nex=tmp;\n}\n\nvoid addedge2(int u,int v)\n{\n\tint tmp=graph2[u].nex;\n\tgraph2[u].nex=++tail2;\n\tgraph2[tail2].front=v;\n\tgraph2[tail2].nex=tmp;\n}\n\nvoid addedge3(int u,int v)\n{\n\tint tmp=graph3[u].nex;\n\tgraph3[u].nex=++tail3;\n\tgraph3[tail3].front=v;\n\tgraph3[tail3].nex=tmp;\n}\n\nint vis[1001];\npair<int,int> edge[200001];\nint nfinish=0;\nint finish[1001];\nint nconnect=0;\nint connect[1001];\nint indegree[1001],outdegree[1001];\nint cnt[1001][1001];\n\nvoid dfs1(int now)\n{\n\tvis[now]=1;\n\tfor(int i=graph[now].nex;i;i=graph[i].nex)\n\t{\n\t\tif(vis[graph[i].front]!=1)\n\t\t{\n\t\t\tdfs1(graph[i].front);\n\t\t}\n\t}\n\tfinish[nfinish++]=now;\n}\n\nvoid dfs2(int now)\n{\n//\tprintf(\"dfs2(%d)\\n\",now);\n\tvis[now]=2;\n\tconnect[now]=nconnect;\n\tfor(int i=graph2[now].nex;i;i=graph2[i].nex)\n\t{\n\t\tif(vis[graph2[i].front]!=2)\n\t\t{\n\t\t\tdfs2(graph2[i].front);\n\t\t}\n\t}\n}\n\nvoid dfs3(int from,int now)\n{\n\t//vis[now]=3+from;\n\tfor(int i=graph3[now].nex;i;i=graph3[i].nex)\n\t{\n\t\tif(cnt[from][graph3[i].front]>1)continue;\n\t\t//if(vis[now]==3+from)continue;\n\t\tcnt[from][graph3[i].front]+=cnt[from][now];\n\t\tdfs3(from,graph3[i].front);\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\tread(n);read(m);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from,to;\n\t\tread(from);read(to);\n\t\taddedge(from,to);\n\t\taddedge2(to,from);\n\t\tedge[i]=make_pair(from,to);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i]!=1)dfs1(i);\n\t}\n\tfor(int i=nfinish-1;i>=0;i--)\n\t{\n\t\tif(vis[finish[i]]!=2)\n\t\t{\n\t\t\tnconnect++;\n\t\t\tdfs2(finish[i]);\n\t\t}\n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<connect[i]<<\" \";\n\t}\n\tcout<<endl;*/\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=graph[i].nex;j;j=graph[j].nex)\n\t\t{\n\t\t\tif(connect[i]==connect[graph[j].front])\n\t\t\t{\n\t\t\t\toutdegree[i]++;\n\t\t\t}\n\t\t}\n\t\tfor(int j=graph2[i].nex;j;j=graph2[j].nex)\n\t\t{\n\t\t\tif(connect[i]==connect[graph2[j].front])\n\t\t\t{\n\t\t\t\tindegree[i]++;\n\t\t\t}\n\t\t} \n\t}\n/*\tfor(int i=1;i<=n;i++)\n\t{\n\t\tprintf(\"in:%d,out:%d\\n\",indegree[i],outdegree[i]);\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(connect[from]!=connect[to])addedge3(connect[from],connect[to]);\n\t}\n\tfor(int i=1;i<=nconnect;i++)\n\t{\n\t\tcnt[i][i]=1;\n\t\tdfs3(i,i);\n\t}\n/*\tfor(int i=1;i<=nconnect;i++)\n\t{\n\t\tfor(int j=1;j<=nconnect;j++)\n\t\t{\n\t\t\tcout<<cnt[i][j];\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint from=edge[i].first,to=edge[i].second;\n\t\tif(connect[from]==connect[to])\n\t\t{\n\t\t\tif(indegree[to]==1||outdegree[from]==1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cnt[connect[from]][connect[to]]>1)\n\t\t\t{\n\t\t\t\tputs(\"diff\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"same\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2\n1 3\n2 3\n\n2 2\n1 2\n2 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\n#define X first\n#define Y second\ntypedef long long ll; \nint n, m; \nbool can[1005][1005], vis[1005], ans[200005]; \nstd::vector<std::pair<int, int> > adj[1005]; \nvoid dfs(int rt, int u)\n{\n\tvis[u] = true; \n\tfor (auto it : adj[u])\n\t{\n\t\tif (it.first == rt || vis[it.first])\n\t\t\tcontinue; \n\t\tdfs(rt, it.first); \n\t}\n}\nvoid work()\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tmemset(vis, false, sizeof(vis)); \n\t\tfor (auto it : adj[i])\n\t\t{\n\t\t\tif (vis[it.first])\n\t\t\t\tans[it.second] = true; \n\t\t\telse\n\t\t\t\tdfs(i, it.first); \n\t\t}\n\t}\n}\nvoid fill(int rt, int u)\n{\n\tif (can[rt][u])\n\t\treturn; \n\tcan[rt][u] = true; \n\tfor (auto it : adj[u])\n\t\tfill(rt, it.first); \n}\nint main()\n{\n\t// freopen(\"ARC092-F.in\", \"r\", stdin); \n\tscanf(\"%d%d\", &n, &m); \n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint u, v; \n\t\tscanf(\"%d%d\", &u, &v); \n\t\tadj[--u].pb(mp(--v, i)); \n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfill(i, i); \n\twork(); \n\tfor (int i = 0; i < n; i++)\n\t\tstd::reverse(adj[i].begin(), adj[i].end()); \n\twork(); \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (auto it : adj[i])\n\t\t\tans[it.second] ^= can[it.first][i]; \n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tputs(ans[i] ? \"diff\" : \"same\"); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define p_b push_back\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 1010;\nint n, m;\nvector<int> e[N], id[N], _e[N], _id[N];\nint p[2][N]; bool w[N];\nbool ans[200010];\n\nvoid dfs(int u, int id, int o) {\n\tp[o][u] = id;\n\tfor(int i = 0; i < e[u].size(); ++i)\n\t\tif(!p[o][e[u][i]]) dfs(e[u][i], id, o);\n}\n\nvoid dfs2(int u) {\n\tw[u] = 1;\n\tfor(int i = 0; i < e[u].size(); ++i)\n\t\tif(!w[e[u][i]]) dfs2(e[u][i]);\n}\n\nint main() {\n\tint i, j, x, y;\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, 1, m) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\te[x].p_b(y); id[x].p_b(i);\n\t\t_e[y].p_b(x); _id[y].p_b(i);\n\t}\n\trep(i, 1, n) {\n\t\tmemset(p, 0, sizeof p);\n\t\tp[0][i] = p[1][i] = n+1;\n\t\tfor(j = 0; j < e[i].size(); ++j)\n\t\t\tif(!p[0][e[i][j]]) dfs(e[i][j], id[i][j], 0);\n\t\tfor(j = e[i].size()-1u; ~j; --j)\n\t\t\tif(!p[1][e[i][j]]) dfs(e[i][j], id[i][j], 1);\n//\t\trep(j, 1, n) printf(\"%d \", p[0][j]); puts(\"\");\n//\t\trep(j, 1, n) printf(\"%d \", p[1][j]); puts(\"\");\n\t\t\n\t\tfor(j = 0; j < e[i].size(); ++j)\n\t\tif(p[0][e[i][j]] != id[i][j] || p[1][e[i][j]] != id[i][j]) ans[id[i][j]] ^= 1;\n\t}\n\trep(i, 1, n) {\n\t\tmemset(w, 0, sizeof w);\n\t\tdfs2(i);\n\t\t\n\t\tfor(j = 0; j < _e[i].size(); ++j)\n\t\tif(w[_e[i][j]]) ans[_id[i][j]] ^= 1;\n\t}\n\trep(i, 1, m)\n\tif(ans[i]) puts(\"diff\"); else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(int x){write(x);putchar('\\n');}\nconst int MAXN=1005;\nconst int MAXM=200005;\nstruct edge{int x,y,next;}a[MAXM];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\n\n//bitset<MAXN> bi[MAXM+MAXN],bnow;\nint vi[MAXN][MAXN];\nvoid dfs1(int x,int o)\n{\n\tif(vi[o][x])return ;\n\tvi[o][x]=1;\n\tfor(int k=last[x];k;k=a[k].next)dfs1(a[k].y,o);\n}\nint bi[2][MAXN],tim;\nvoid dfs2(int x,int o)\n{\n\tif(bi[o][x])return ;\n\tbi[o][x]=tim;\n\tfor(int k=last[x];k;k=a[k].next)dfs2(a[k].y,o);\n}\nint ans[MAXM],sta[MAXM],tp;\nint n,m;\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tn=read();m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tdfs1(i,i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ttp=0;memset(bi,0,sizeof(bi));\n\t\tbi[0][i]=bi[1][i]=1;\n\t\tfor(int k=last[i],lst=1;k;k=a[k].next,lst++)\n\t\t{\n\t\t\tsta[++tp]=k;tim=lst;\n\t\t\tdfs2(a[k].y,0);\n\t\t}\n\t\tsta[tp+1]=0;\n\t\twhile(tp)\n\t\t{\n\t\t\tif(sta[tp+1])dfs2(a[sta[tp+1]].y,1);\n\t\t\tint y=a[sta[tp]].y;\n\t\t\tif(vi[y][i]==(bi[1][y]||(bi[0][y]<tp&&bi[0][y])))\n\t\t\t\tans[sta[tp]]=1;\n\t\t\ttp--;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ans[i])puts(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1005\n#define M 200005\nusing namespace std;\n\nint n,m;\nbool irp[N][N],lnk[N][N];\nint rt,cnt,fir[N];\nbool col[N];\nvector<int>to[N];\nstruct edge{int u,v;}e[M];\n\ninline int read()\n{\n\tint ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\ninline void add(int a,int b){to[a].push_back(b);e[++cnt]=(edge){a,b};}\n\ninline void dfs(int x)\n{\n\tcol[x]=lnk[rt][x]=1;\n\tfor(auto it:to[x]) if(!col[it]) dfs(it);\n}\n\ninline void insert(int x)\n{\n\trt=x;\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n\treverse(to[x].begin(),to[x].end());\n\tmemset(col+1,0,n*sizeof(int));\n\tcol[x]=1;\n\tfor(auto it:to[x])\n\t\tif(col[it]) irp[x][it]=1;\n\t\telse dfs(it);\n}\n\nint main()\n{\n//\tfreopen(\"test.in\",\"r\",stdin);\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint a=read(),b=read();\n\t\tadd(a,b);\n\t}\n\tfor(int i=1;i<=n;++i)insert(i);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x=e[i].u,y=e[i].v;\n\t\tputs(irp[x][y]^lnk[y][x]?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <memory.h>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e6;\nint n, m;\n\nstruct _edge {\n    int x, i;\n    _edge(int x, int i) : x(x), i(i) {}\n};\n\nint dist[1001][1001];\nvector<_edge> edge[1001];\nvector<_edge> redge[1001];\nint ans[200000];\nvoid dfs(int dist[], int x, int e) {\n    for (_edge i : edge[x]) {\n        if (dist[i.x] != m && dist[i.x] != e) {\n            if (dist[i.x] != -1) {\n                dist[i.x] = m;\n            }\n            else {\n                dist[i.x] = e;\n            }\n            dfs(dist, i.x, e);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        edge[a].emplace_back(b, i);\n        redge[b].emplace_back(a, i);\n    }\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            dist[i][j] = -1;\n        }\n\n        dist[i][i] = m;\n        for (_edge j : edge[i]) {\n            if (dist[i][j.x] != m) {\n                if (dist[i][j.x] != -1) dist[i][j.x] = m;\n                else dist[i][j.x] = j.i;\n                dfs(dist[i], j.x, j.i);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (_edge e : edge[i]) {\n            int j = e.x;\n            int t = e.i;\n            if ((dist[j][i] != -1) == (dist[i][j] != m)) {\n                ans[t] = 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(ans[i] ? \"diff\\n\" : \"same\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e3+5;\nint n,m,U[N],V[N],id,f[N],dfn[N],low[N];\nvector<int>e[N];\nstack<int>s;\nbool vis[N];\nint mp[N][N][2];\nvoid dfs(int u)\n{\n    dfn[u]=low[u]=++id;\n    s.push(u);\n    vis[u]=true;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!dfn[v]) dfs(v),low[u]=min(low[u],low[v]);\n        else if(vis[v]) low[u]=min(low[u],dfn[v]);\n    }\n    if(low[u]==dfn[u])\n    {\n        while(s.top()!=u)\n            vis[s.top()]=false,f[s.top()]=u,s.pop();\n        f[u]=u;s.pop();vis[u]=false;\n    }\n}\nvoid dfs(int u,int fa,int k,int opt)\n{\n    vis[u]=true;mp[fa][u][opt]=k;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!vis[v])\n            dfs(v,fa,k,opt);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&U[i],&V[i]);\n        e[U[i]].push_back(V[i]);\n    }\n    dfs(1);\n    for(int i=1;i<=n;i++)\n    {\n        memset(vis,false,sizeof(vis));\n        vis[i]=true;\n        int up=e[i].size();\n        for(int j=0;j<up;j++)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,j+1,0);\n        memset(vis,false,sizeof(vis));\n        vis[i]=true;\n        for(int j=up-1;j>=0;j--)\n            if(!vis[e[i][j]])\n            dfs(e[i][j],i,j+1,1);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[U[i]]==f[V[i]])\n        {\n            if(mp[U[i]][V[i]][0]!=mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n        else\n        {\n            if(mp[U[i]][V[i]][0]==mp[U[i]][V[i]][1]) printf(\"same\\n\");\n            else printf(\"diff\\n\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\nconst int N=1005;\n\nint n,m;\nint hd[N],to[N*200],pr[N*200],tot;\nvoid addedge(int u,int v) {to[tot]=v;pr[tot]=hd[u];hd[u]=tot;}\n\n\nint dfn[N],low[N],D,s[N],top;bool in[N];\nint cnt,sz[N],pos[N],tmp[N][N];\n\nvoid dfs(int u)\n{\n\tlow[u]=dfn[u]=++D;\n\ts[++top]=u;in[u]=true;\n\tfor (int i=hd[u];i;i=pr[i]) \n\tif (!dfn[to[i]]) \n\t{\n\t\tdfs(to[i]);\n\t\tlow[u]=min(low[u],low[to[i]]);\n\t}else if (in[to[i]]) low[u]=min(low[u],dfn[to[i]]);\n\tif (low[u]==dfn[u])\n\t{\n\t\t++cnt;\n\t\tint t;\n\t\tdo\n\t\t{\n\t\t\tt=s[top--];\n\t\t\ttmp[cnt][++sz[cnt]]=t;\n\t\t\tpos[t]=cnt;\n\t\t\tin[t]=false;\n\t\t}while (t!=u);\n\t}\n}\n\n\n\n\n\nbool ans[N*200];\nbitset<N> r[N];\n\nint pp[N][N];\nvoid work(int id)\n{\n\tif (in[id]) return ;\n\tin[id]=true;\n\n\tfor (int i=1;i<=sz[id];i++) \n\tfor (int v,j=hd[tmp[id][i]];j;j=pr[j]) \n\tif (pos[v=to[j]]!=id) work(pos[v]),r[id]=r[id]|r[pos[v]],pp[id][pos[v]]++;\n\n\tfor (int i=1;i<=sz[id];i++) \n\tfor (int v,j=hd[tmp[id][i]];j;j=pr[j]) \n\tif (pos[v=to[j]]!=id) \n\t{\n\t\tif (pp[id][pos[v]]>1||r[id].test(pos[v])) ans[j]=true;\n\t\tr[id].set(pos[v]);\n\t}\n}\n\nint din[N],dout[N];\n\nint o[N][N],I[N*200];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int u,v,i=1;i<=m;i++)\n\t{\n\t\t++tot;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tif (!o[u][v]) \n\t\t{\n\t\t\taddedge(u,v);\n\t\t\tI[i]=o[u][v]=i;\n\t\t}else I[i]=o[u][v];\n\t}\n\n\n\tfor (int i=1;i<=n;i++) if (!dfn[i]) dfs(i);\n\t\n\tmemset(in,false,sizeof(in));\n\t\n\tfor (int i=1;i<=cnt;i++) if (!in[i]) work(i);\n\n\n\t\n\tfor (int u=1;u<=n;u++)\n\t\tfor (int i=hd[u];i;i=pr[i]) \n\t\tif (pos[to[i]]==pos[u]) din[to[i]]++,dout[u]++;\n\t\n\tfor (int u=1;u<=n;u++)\n\t\tfor (int i=hd[u];i;i=pr[i]) \n\t\tif (pos[to[i]]==pos[u]) if (din[to[i]]==1||dout[u]==1) ans[i]=true;\n\t\t\n\tfor (int i=1;i<=m;i++) if (ans[I[i]]) puts(\"diff\");else puts(\"same\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n\tstatic const int S=1e7;\n\tchar rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n\tfastio() {rpos=len=wpos=0;}\n\tinline char Getchar()\n\t{\n\t\tif (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n\t\tif (!len) return EOF;\n\t\treturn rbuf[rpos++];\n\t}\n\ttemplate <class T> inline void Get(T &x)\n\t{\n\t\tchar ch;bool f;T res;\n\t\twhile (!isdigit(ch=Getchar()) && ch!='-') {}\n\t\tif (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n\t\twhile (isdigit(ch=Getchar())) res=res*10+ch-'0';\n\t\tx=(f?res:-res);\n\t}\n\tinline void getstring(char *s)\n\t{\n\t\tchar ch;\n\t\twhile ((ch=Getchar())<=32) {}\n\t\tfor (;ch>32;ch=Getchar()) *s++=ch;\n\t\t*s='\\0';\n\t}\n\tinline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n\tinline void Writechar(char ch)\n\t{\n\t\tif (wpos==S) flush();\n\t\twbuf[wpos++]=ch;\n\t}\n\ttemplate <class T> inline void Print(T x,char ch)\n\t{\n\t\tchar s[20];int pt=0;\n\t\tif (x==0) s[++pt]='0';\n\t\telse\n\t\t{\n\t\t\tif (x<0) Writechar('-'),x=-x;\n\t\t\twhile (x) s[++pt]='0'+x%10,x/=10;\n\t\t}\n\t\twhile (pt) Writechar(s[pt--]);\n\t\tWritechar(ch);\n\t}\n\tinline void printstring(char *s)\n\t{\n\t\tint pt=1;\n\t\twhile (s[pt]!='\\0') Writechar(s[pt++]);\n\t}\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ntemplate<typename T> inline int quick_pow(int x,T y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ntemplate<typename T> inline int quick_pow(int x,T y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=2000;\nconst int MAXM=2e5;\n\nint n,m;\nvector<Pair> v[MAXN+48];\nvector<int> vv[MAXN+48];\nbool visited1[MAXN+48],visited2[MAXN+48],visited3[MAXN+48],ok[MAXN+48];\nint ans[MAXM+48];\n\ninline void dfs1(int cur)\n{\n\tvisited1[cur]=true;\n\tfor (register int i=0;i<int(vv[cur].size());i++)\n\t{\n\t\tregister int y=vv[cur][i];\n\t\tif (!visited1[y]) dfs1(y);\n\t}\n}\n\ninline void dfs2(int cur)\n{\n\tvisited2[cur]=true;\n\tfor (register int i=0;i<int(v[cur].size());i++)\n\t{\n\t\tregister int y=v[cur][i].x;\n\t\tif (!visited2[y]) dfs2(y);\n\t}\n}\n\nint main ()\n{\n#ifdef LOCAL\n\tdouble TIME=clock();\n\tfreopen (\"a.in\",\"r\",stdin);\n\tfreopen (\"a.out\",\"w\",stdout);\n\tcerr<<\"Running...\"<<endl;\n#endif\n\tio.Get(n);io.Get(m);int x,y;\n\tfor (register int i=1;i<=m;i++)\n\t{\n\t\tio.Get(x);io.Get(y);\n\t\tv[x].pb(mp(y,i));vv[y].pb(x);\n\t}\n\tfor (register int i=1;i<=n;i++)\n\t{\n\t\tmemset(visited1,false,sizeof(visited1));\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tmemset(ok,false,sizeof(ok));\n\t\tdfs1(i);visited2[i]=true;\n\t\tfor (register int j=0;j<int(v[i].size())-1;j++)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j+1;k<int(v[i].size());k++)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tmemset(visited2,false,sizeof(visited2));\n\t\tfor (register int j=int(v[i].size())-1;j>=1;j--)\n\t\t{\n\t\t\tdfs2(v[i][j].x);\n\t\t\tfor (register int k=j-1;k>=0;k--)\n\t\t\t\tif (visited2[v[i][k].x]) ok[v[i][k].x]=true;\n\t\t}\n\t\tfor (register int j=0;j<int(v[i].size());j++) ans[v[i][j].y]=(visited1[v[i][j].x]^ok[v[i][j].x]);\n\t}\n\tfor (register int i=1;i<=m;i++) printf(ans[i]?\"diff\\n\":\"same\\n\");\n\tio.flush();\n#ifdef LOCAL\n\tcerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\ntypedef unsigned char byte;\ntypedef unsigned int uint;\ntypedef unsigned long long int ulli;\n\n// 1~n: found value, -1: not found, -2: more than 2\nint res[1010][1010];\nvector<int> ll[1010], bll[1010];\nbool starred[1010];\nint cnt[1010];\n\nint unf[1010];\nvector<int> kos;\nvector<pii> piv;\n\nint dag_edge[1010][1010];\nbitset<1010> dag_visit[1010], dag_second_visit[1010];\nint topo_sort[1010], topo_cnt;\n\nint n;\nint find_stars(int, int);\n\nvoid get_star_list(int removed) {\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (int u : bll[removed]) {\n        if (unf[u] == unf[removed]) {\n            starred[u] = true;\n        }\n    }\n    for (int u : bll[removed]) {\n        if (starred[u]) {\n            find_stars(removed, u);\n        }\n    }\n}\n\nint find_stars(int removed, int s) {\n    int r = -1;\n    if (res[removed][s]) return res[removed][s];\n    if (cnt[s] >= 2) return -1;\n    ++cnt[s];\n    for (int u : ll[s]) {\n        if (u == removed || unf[u] != unf[removed]) continue;\n        int temp = find_stars(removed, u);\n        if (starred[u]) temp = temp == -1 || temp == u ? u : -2;\n        if (temp == -2) r = -2;\n        else if (temp != -1) r = r == -1 || r == temp ? temp : -2;\n    }\n    --cnt[s];\n    return res[removed][s] = r;\n}\n\nvoid kosaraju(int f) {\n    for (int u : ll[f]) {\n        if (!starred[u]) {\n            starred[u] = true;\n            kosaraju(u);\n        }\n    }\n    kos.push_back(f);\n}\n\nvoid kosaraju2(int f, int f2) {\n    unf[f] = f2;\n    for (int u : ll[f]) {\n        if (!unf[u]) {\n            kosaraju2(u, f2);\n        }\n    }\n}\n\nvoid topological_sort(int f) {\n    if (starred[f]) return;\n    starred[f] = true;\n    for (int u : ll[f]) {\n        topological_sort(unf[u]);\n    }\n    topo_sort[topo_cnt++] = f;\n}\n\nint main() {\n    int m;\n    scanf(\"%d%d\", &n, &m);\n    int i;\n    for (i=0; i<m; ++i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        ll[a].push_back(b);\n        piv.emplace_back(a, b);\n        bll[b].push_back(a);\n    }\n    for (i=1; i<=n; ++i) {\n        if (!starred[i]) {\n            starred[i] = true;\n            kosaraju(i);\n        }\n    }\n    for (int u : kos) {\n        if (!unf[u]) {\n            kosaraju2(u, u);\n        }\n    }\n    for (i=1; i<=n; ++i) {\n        get_star_list(i);\n    }\n    for (auto u : piv) {\n        ++dag_edge[unf[u.first]][unf[u.second]];\n    }\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (i=1; i<=n; ++i) {\n        int f = unf[i];\n        if (!starred[f]) {\n            topological_sort(f);\n        }\n    }\n    memset(starred, 0, 1010 * sizeof(bool));\n    for (i=0; i<topo_cnt/2; ++i) {\n        swap(topo_sort[i], topo_sort[topo_cnt - 1 - i]);\n    }\n    for (i=topo_cnt-1; i>=0; --i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_edge[f][f2]) {\n                bitset<1010> u;\n                u.set(f2);\n                dag_visit[f] |= dag_visit[f2] | u;\n            }\n        }\n    }\n    for (i=0; i<topo_cnt; ++i) {\n        int f = topo_sort[i];\n        for (int j=i+1; j<topo_cnt; ++j) {\n            int f2 = topo_sort[j];\n            if (dag_visit[f].test(f2)) {\n                dag_second_visit[f] |= dag_visit[f2];\n            }\n        }\n    }\n    for (auto u : piv) {\n        if (unf[u.first] == unf[u.second]) {\n            int t = find_stars(u.second, u.first);\n            puts(t == -1 || t == u.first ? \"diff\" : \"same\");\n        } else {\n            puts(dag_edge[unf[u.first]][unf[u.second]] >= 2 || dag_second_visit[unf[u.first]].test(unf[u.second]) ? \"diff\" : \"same\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 1024;\nint N,M;\nvector<P2> V[MC];\nvector<P2> E;\nbool ans[200010];\nbool visited[MC];\n\nvoid dfs(int q){\n\tvisited[q] = 1;\n\tfor(auto u : V[q]){\n\t\tif(visited[u.first]) continue;\n\t\tdfs(u.first);\n\t}\n}\n\nint main(){\n\tcin >> N >> M;\n\trepp(i,0,M){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tV[a].PB(MP(b,i));\n\t\tE.PB(MP(a,b));\n\t}\n\trepp(i,1,N+1){\n\t\tfill(visited,visited+MC,0);\n\t\tvisited[i] = 1;\n\t\trepp(j,0,V[i].size()){\n\t\t\tif(visited[V[i][j].first]) ans[V[i][j].second] = 1;\n\t\t\telse dfs(V[i][j].first);\n\t\t}\n\t\tfill(visited,visited+MC,0);\n\t\tvisited[i] = 1;\n\t\trepm(j,V[i].size()-1,-1){\n\t\t\tif(visited[V[i][j].first]) ans[V[i][j].second] = 1;\n\t\t\telse dfs(V[i][j].first);\n\t\t}\n\t}\n\trepp(i,1,N+1){\n\t\tfill(visited,visited+MC,0);\n\t\tdfs(i);\n\t\trepp(j,0,M) if(E[j].second == i && visited[E[j].first]) ans[j] ^= 1;\n\t}\n\trepp(i,0,M) cout << (ans[i] ? \"diff\" : \"same\") << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int INF=0x7f7f7f7f;\nconst int maxn=(2e5)+10;\nint n,m,tot,head[1010],nxt[maxn];\nint from[maxn],to[maxn];\nbool vis[1010],ans;\nvoid add(int x) {\n\ttot++; nxt[tot]=head[x];\n\thead[x]=tot;\n}\nint S;\nvoid dfs(int u) {\n\tvis[u]=1;\n\tif (u==to[S]) { ans=1; return; }\n\tfor (int i=head[u],v;i;i=nxt[i]) {\n\t\tv=to[i];\n\t\tif (S==i||vis[v]) continue;\n\t\tdfs(v);\n\t\tif (ans) return;\n\t}\n}\nint dfn[1010],low[1010];\nint sid[1010],cnt,idx;\nbool inStack[1010];\nint st[1010];\nvoid tarjan(int u) {\n    dfn[u]=low[u]=++idx;\n    inStack[u]=1;\n    st[++tot]=u;\n    for (int i=head[u],v;i;i=nxt[i]) {\n        v=to[i];\n        if (dfn[v]==-1) {\n            tarjan(v);\n            low[u]=min(low[u],low[v]);\n        }\n        else if (inStack[v])\n            low[u]=min(low[u],dfn[v]);\n    }\n    if (dfn[u]==low[u]) {\n        cnt++;\n        while (1) {\n            int v=st[tot];\n            tot--; inStack[v]=0;\n            sid[v]=cnt;\n            if (v==u) break;\n        }\n    }\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m);\n\tfor (int i=1;i<=m;i++) {\n\t\tread(from[i]); read(to[i]);\n\t\tadd(from[i]);\n\t}\n\tmemset(dfn,-1,sizeof(dfn));\n\ttot=0;\n\tfor (int i=1;i<=n;i++) {\n\t\tif (dfn[i]==-1) tarjan(i);\n\t}\n\tint x,y;\n\tfor (int i=1;i<=m;i++) {\n\t\tx=from[i];\n\t\ty=to[i];\n\t\tS=i;\n\t\tans=0;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(x);\n\t\tif (sid[x]==sid[y]&&vis[y]) printf(\"same\\n\");\n\t\telse if (sid[x]!=sid[y]&&!vis[y]) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\n\ntypedef pair<int, int> P;\n\n#define fir first\n#define sec second\n\nvector<P> G[N];\n\nbool mark[N][N], mp[N][N], vis[N]; int ct[N][N];\n\nint rt, n; \n\nvoid dfs(int u, int type) {\n    vis[u] = 1;\n    if (mp[rt][u] && !mark[rt][u]) ct[rt][u] |= 1;\n    if (!type) {\n        for (auto v : G[u]) if (!vis[v.sec])\n            mark[u][v.sec] = 1, dfs(v.sec, type), mark[u][v.sec] = 0;\n    } else for (int i = G[u].size() - 1; i >= 0; i--) if (!vis[G[u][i].sec])\n        mark[u][G[u][i].sec] = 1, dfs(G[u][i].sec, type), mark[u][G[u][i].sec] = 0;\n}\n\ninline void clr() {\n    for (int i = 1; i <= n; i++) vis[i] = 0;\n}\n\ninline void solve(int u) {\n    rt = u, clr(), dfs(u, 0), clr(), dfs(u, 1);\n    for (int i = 1; i <= n; i++) if (vis[i]) ct[i][u] |= 2;\n}\n\nint ans[N];\n\nint main() {\n    int m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(P(i, b)), mp[a][b] = 1;\n    for (int i = 1; i <= n; i++) sort(G[i].begin(), G[i].end());\n    for (int i = 1; i <= n; i++) solve(i);\n    for (int i = 1; i <= n; i++) for (auto v : G[i]) \n        if (ct[i][v.sec] != 0 && ct[i][v.sec] != 3) ans[v.fir] = 1;\n    for (int i = 1; i <= m; i++) puts(ans[i] ? \"diff\" : \"same\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tusing P = pair<int,int>;\n\n\tint N,M; cin >> N >> M;\n\tmap<P,int> eid;\n\tVV<int> G(N);\n\trep(i,M){\n\t\tint x,y; cin >> x >> y;\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\teid[P(x,y)] = i;\n\t}\n\tVV<bool> reach(N,V<bool>(N));\n\tV<bool> ex(M);\n\trep(s,N){\n\t\treach[s][s] = true;\n\t\tqueue<int> q; q.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor(int u: G[v]) if(!reach[s][u]){\n\t\t\t\treach[s][u] = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\trep(s,N){\n\t\trep(_,2){\n\t\t\tV<bool> vis(N); vis[s] = true;\n\t\t\tfunction<void(int)> dfs = [&](int v){\n\t\t\t\tif(vis[v]) return;\n\t\t\t\tvis[v] = true;\n\t\t\t\tfor(int u: G[v]) dfs(u);\n\t\t\t};\n\t\t\tfor(int c: G[s]){\n\t\t\t\tint e = eid[P(s,c)];\n\t\t\t\tif(vis[c]) ex[e] = true;\n\t\t\t\tdfs(c);\n\t\t\t}\n\t\t\treverse(all(G[s]));\n\t\t}\n\t}\n\tV<bool> same(M);\n\trep(x,N){\n\t\tfor(int y: G[x]){\n\t\t\tint e = eid[P(x,y)];\n\t\t\tsame[e] = reach[y][x] ^ ex[e];\n\t\t}\n\t}\n\trep(i,M) cout << (!same[i] ? \"same\" : \"diff\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=1005;\nconst int M=200005;\nvector<int> e[N];\nint head[N],tot;\nint n,m,x[M],y[M];\nint co1[N][N],co2[N][N];\nint vis[N],q[N];\nvoid dfs(int x,int co){\n\tvis[x]=co;\n\tfor (auto i:e[x]) if (!vis[i]) dfs(i,co);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,m){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\te[x[i]].PB(y[i]);\n\t}\n\tFor(i,1,n){\n\t\t*q=0;\n\t\tfor (auto j:e[i]) q[++*q]=j;\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tFor(j,1,*q) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co1[i][j]=vis[j];\n\t\tFor(j,1,n) vis[j]=(j==i?-1:0);\n\t\tRep(j,*q,1) if (!vis[q[j]]) dfs(q[j],q[j]);\n\t\tFor(j,1,n) co2[i][j]=vis[j];\n\t}\n\tFor(i,1,m){\n\t\tbool f1=(co1[y[i]][x[i]]!=0);\n\t\tbool f2=(co2[x[i]][y[i]]&&co2[x[i]][y[i]]!=y[i])||\n\t\t\t\t(co1[x[i]][y[i]]&&co1[x[i]][y[i]]!=y[i]);\n\t\tputs(f1^f2?\"diff\":\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nstd::vector<int>to[1010],t[1010];\nint ans[200100],fr[1010][1010],tg[1010][1010],I;\nvoid dfs(re int a,re int*ff)\n{\n\tfor(re int i=0;i<to[a].size();i++)if(!ff[to[a][i]])\n\t{\n\t\tff[to[a][i]]=ff[a];dfs(to[a][i],ff);\n\t}\n}\nint main()\n{\n\tre int n,m,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re int i=1;i<=m;i++)scanf(\"%d%d\",&x,&y),to[x].push_back(y),t[x].push_back(i);\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfr[I][I]=tg[I][I]=-1;\n\t\tfor(re int i=0;i<to[I].size();i++)if(!fr[I][to[I][i]])\n\t\t{\n\t\t\tfr[I][to[I][i]]=to[I][i];dfs(to[I][i],fr[I]);\n\t\t}\n\t\tfor(re int i=to[I].size()-1;i>=0;i--)if(!tg[I][to[I][i]])\n\t\t{\n\t\t\ttg[I][to[I][i]]=to[I][i];dfs(to[I][i],tg[I]);\n\t\t}\n\t}\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfor(re int i=0;i<to[I].size();i++)if(to[I][i]==I)ans[t[I][i]]=1;\n\t\telse{//printf(\"**%d %d %d\\n\",I,i->to,tg[I][i->to]);\n\t\t\tans[t[I][i]]=(fr[I][to[I][i]]==to[I][i]&&tg[I][to[I][i]]==to[I][i])==(fr[to[I][i]][I]==0);\n\t\t}\n\t}\n\tfor(re int i=1;i<=m;i++)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <map>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long lint;\n#define p(a,b) make_pair(a,b)\n\nint main(){\n    lint N,M;\n    \n    scanf(\"%lld %lld\",&N,&M);\n    vector<int> edge[1001];\n    int *A,*B;\n    A=new int[M+1];\n    B=new int[M+1];\n    map<pair<int,int>,int> eind;\n    for(int i=1;i<=M;i++){\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        A[i]=a;\n        B[i]=b;\n        edge[a].push_back(b);\n        eind[p(a,b)]=i;\n    }\n\n    bool *conn;\n    conn=new bool[M+1];\n    for(int i=1;i<=M;i++) conn[i]=false;\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=N;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=0;e+1<edge[v].size();e++){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e+1]]) conn[eind[p(v,edge[v][e+1])]]=true;\n        }\n    }\n\n    for(int v=1;v<=N;v++){\n        bool chk[1001];\n        for(int i=1;i<=1000;i++) chk[i]=false;\n        chk[v]=true;\n\n        stack<int> prev;\n        for(int e=-1+edge[v].size();e>0;e--){\n            prev.push(edge[v][e]);\n            while(!prev.empty()){\n                int t=prev.top();\n                prev.pop();\n                chk[t]=true;\n                for(int x : edge[t]){\n                    if(!chk[x]) prev.push(x);\n                }\n            }\n            if(chk[edge[v][e-1]]) conn[eind[p(v,edge[v][e-1])]]=true;\n        }\n    }\n\n    bitset<1001> map[1001];\n    for(int i=1;i<=N;i++){\n        map[i]=0;\n        map[i][i]=true;\n    }\n\n    for(int v=1;v<=N;v++){\n        for(int e=1;e<=M;e++) map[A[e]]|=map[B[e]];\n    }\n\n    for(int i=1;i<=M;i++){\n        if(map[B[i]][A[i]]==conn[i]) printf(\"same\\n\");\n        else printf(\"diff\\n\");\n    }\n\n    delete[] A,B,conn;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxm 200010\n#define maxn 1010\nusing namespace std;\ntypedef long long LL;\nstruct Edge {\n    int from, to, ne;\n}edge[maxm];\nint head[maxn], ne[maxm], pre[maxm], T, tot;\nbool flag[maxn][maxn];\nint f1[maxn][maxn], f2[maxn][maxn], vis[maxn];\nvoid add(int u, int v) {\n    if (~ne[u]) pre[ne[u]] = tot;\n    else head[u] = tot;\n    edge[tot] = {u, v, ne[u]};\n    ne[u] = tot++;\n}\nvoid dfs1(int src, int u) {\n    flag[src][u] = true; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v] != T) dfs1(src, v);\n    }\n}\nvoid dfs2(int src, int exc, int u, int f[maxn][maxn]) {\n    if (f[exc][u]==-1) f[exc][u] = src; vis[u] = T;\n    for (int i = ne[u]; ~i; i = edge[i].ne) {\n        int v = edge[i].to;\n        if (vis[v]!=T && v!=exc) dfs2(src, exc, v, f);\n    }\n}\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    int n, m;\n    memset(ne, -1, sizeof ne);\n    memset(head, -1, sizeof head);\n    memset(f1, -1, sizeof f1);\n    memset(f2, -1, sizeof f2);\n    scanf(\"%d%d\", &n, &m);\n    F(i, 0, m) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u, v);\n    }\n//    F2(i, 1, n) printf(\"%d\\n\", head[i]);\n//    F(i, 0, m) printf(\"%d\\n\", pre[i]);\n//    F2(i, 1, n) {\n//        ++T; dfs1(i, i);\n//    }\n    F2(i, 1, n) {\n        for (int j = ne[i]; ~j; j = edge[j].ne) {\n            ++T; dfs2(j, i, edge[j].to, f1);\n        }\n        if (head[i]==-1) continue;\n        for (int j = head[i]; ; j = pre[j]) {\n//            printf(\"dfs2 : %d %d\\n\", i, j);\n            ++T; dfs2(j, i, edge[j].to, f2);\n            if (j==ne[i]) break;\n        }\n    }\n\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", flag[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f1[i][j]); puts(\"\");\n//    }\n//    F2(i, 1, n) {\n//        F2(j, 1, n) printf(\"%d \", f2[i][j]); puts(\"\");\n//    }\n    F(i, 0, m) {\n        int u=edge[i].from, v=edge[i].to;\n        if (f1[u][v]!=-1 ^ (f1[u][v]!=i||f2[u][v]!=i)) puts(\"diff\");\n        else puts(\"same\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define ll long long\n#define inf 20021225\n#define N 1010\n#define M 200010 \nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nvector<int> ed[N];\nvoid add(int x,int y,int &id){id=ed[x].size(); ed[x].push_back(y);} \nint con[N][N],s,noc[N][N],n,m; bool vis[N][N]; bool ok[M];\nvoid dfs(int *a,int x,int v)\n{\n\tif(~a[x]||x==s)\treturn; a[x]=v; vis[s][x]=1;\n\tfor(int i=0;i<ed[x].size();i++)\tdfs(a,ed[x][i],v);\n}\nvoid solve()\n{\n\tmemset(con,-1,sizeof(con)); memset(noc,-1,sizeof(noc));\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int i=0;i<ed[x].size();i++)\n\t\t\ts=x,dfs(con[x],ed[x][i],i);\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int i=(int)ed[x].size()-1;~i;i--)\n\t\t\ts=x,dfs(noc[x],ed[x][i],i);\n}\nint u[M],v[M],id[M];\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;i++)\n\t\tu[i]=read(),v[i]=read(),add(u[i],v[i],id[i]);\n\tsolve();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif((vis[v[i]][u[i]])^((con[u[i]][v[i]]<id[i]&&~con[u[i]][v[i]])||noc[u[i]][v[i]]>id[i]))\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 1021\n#define MXN 1021\n#define PB push_back\n#define FZ(X) memset(X,0,sizeof(X))\nstruct Scc{\n  int n, nScc, vst[MXN], bln[MXN];\n  vector<int> E[MXN], rE[MXN], vec;\n  void init(int _n){\n    n = _n;\n    for (int i=0; i<MXN; i++){\n      E[i].clear();\n      rE[i].clear();\n    }\n  }\n  void add_edge(int u, int v){\n    E[u].PB(v);\n    rE[v].PB(u);\n  }\n  void DFS(int u){\n    vst[u]=1;\n    for (auto v : E[u])\n      if (!vst[v]) DFS(v);\n    vec.PB(u);\n  }\n  void rDFS(int u){\n    vst[u] = 1;\n    bln[u] = nScc;\n    for (auto v : rE[u])\n      if (!vst[v]) rDFS(v);\n  }\n  void solve(){\n    nScc = 0;\n    vec.clear();\n    FZ(vst);\n    for (int i=0; i<n; i++)\n      if (!vst[i]) DFS(i);\n    reverse(vec.begin(),vec.end());\n    FZ(vst);\n    for (auto v : vec){\n      if (!vst[v]){\n        rDFS(v);\n        nScc++;\n      }\n    }\n  }\n} graph;\nvoid build(){\n\n}\n#define M 202020\nint n , m , a[ M ] , b[ M ];\nvoid init(){\n  n = getint();\n  m = getint();\n  graph.init( n );\n  for( int i = 0 ; i < m ; i ++ ){\n    a[ i ] = getint() - 1;\n    b[ i ] = getint() - 1;\n    graph.add_edge( a[ i ] , b[ i ] );\n  }\n  graph.solve();\n}\nvector<int> vv[ N ];\nint ind[ N ] , dst[ N ][ N ];\nint way[ N ][ N ] , instk[ N ];\nvoid go( int fr , int now ){\n  instk[ now ] = 1;\n  for( int nxt : graph.E[ now ] ){\n    if( way[ fr ][ nxt ] ){\n      if( instk[ nxt ] )\n        continue;\n      if( way[ fr ][ nxt ] == 2 )\n        continue;\n      way[ fr ][ nxt ] = 2;\n      go( fr , nxt );\n      continue;\n    }\n    way[ fr ][ nxt ] = 1;\n    go( fr , nxt );\n  }\n  instk[ now ] = 0;\n}\nvoid solve(){\n  for( int i = 0 ; i < n ; i ++ ){\n    way[ i ][ i ] = 1;\n    go( i , i );\n  }\n  {\n    for( int i = 0 ; i < m ; i ++ )\n      if( graph.bln[ a[ i ] ] !=\n          graph.bln[ b[ i ] ] ){\n        vv[ graph.bln[ a[ i ] ] ].push_back(\n            graph.bln[ b[ i ] ] );\n        ind[ graph.bln[ b[ i ] ] ] ++;\n      }\n    vector<int> topo;\n    for( int i = 0 ; i < graph.nScc ; i ++ )\n      if( ind[ i ] == 0 )\n        topo.push_back( i );\n    for( size_t _ = 0 ; _ < topo.size() ; _ ++ ){\n      int i = topo[ _ ];\n      for( auto nxt : vv[ i ] ){\n        for( size_t _s = 0 ; _s <= _ ; _s ++ ){\n          int fr = topo[ _s ];\n          if( fr == i or dst[ fr ][ i ] )\n            dst[ fr ][ nxt ] = max( dst[ fr ][ nxt ],\n                                    dst[ fr ][ i ] + 1 );\n        }\n        ind[ nxt ] --;\n        if( ind[ nxt ] == 0 )\n          topo.push_back( nxt );\n      }\n    }\n  }\n  for( int i = 0 ; i < m ; i ++ )\n    if( graph.bln[ a[ i ] ] !=\n        graph.bln[ b[ i ] ] ){\n      if( dst[ graph.bln[ a[ i ] ] ][ graph.bln[ b[ i ] ] ] > 1 )\n        puts( \"diff\" );\n      else\n        puts( \"same\" );\n    }else{\n      if( way[ a[ i ] ][ b[ i ] ] > 1 )\n        puts( \"same\" );\n      else\n        puts( \"diff\" );\n    }\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define vec vector<int>\n#define dead not_bad\n#define bad gooood\n\n#define left not_right\n#define y1 what\n\nusing namespace std;\n\nconst int N = (int) 1e3 + 10;\nconst int M = (int) 2e5 + 10;\nconst int K = (int) 350;\nconst ll LINF = (ll) 1e18;\nconst int INF = (int) 1e9 + 7;\nconst int ALPHA = 26;\nconst int mod = INF + 2;\nconst double PI = 3.14159265359;\nconst ld EPS = (ld) 1e-12;\n\nint n, m;\nvec v[N];\nint from[M], to[M];\nint used[N][N], u[N][N];\n\nvoid dfs(int st, int x) {\n  used[st][x] = 1;\n  for (auto it : v[x]) {\n    if (!used[st][it]) {\n      dfs(st, it);\n    }\n  }\n}\n\nint tmp[N];\n\nvoid dfs1(int st, int x) {\n  tmp[x] = 1;\n  for (auto it : v[x]) {\n    if (st == it) \n      continue;\n    if (!tmp[it]) {\n      dfs1(st, it);\n    }\n  }\n}\n\nint main() {\n  #define fn \"saddle\"\n  #ifdef witch\n      freopen(\"input.txt\", \"r\", stdin);\n      freopen(\"output.txt\", \"w\", stdout);\n  #else\n      //freopen(fn\".in\", \"r\", stdin);\n      //freopen(fn\".out\", \"w\", stdout);\n  #endif\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    cin >> from[i] >> to[i];\n    v[from[i]].pb(to[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    dfs(i, i);\n    memset(tmp, 0, sizeof(tmp));\n    for (int j = 0; j < sz(v[i]); j++) {\n      if (tmp[v[i][j]]) {\n        u[i][v[i][j]] = 1;\n      }\n      dfs1(i, v[i][j]);\n    }\n    memset(tmp, 0, sizeof(tmp));\n    for (int j = sz(v[i]) - 1; j >= 0; j--) {\n      if (tmp[v[i][j]]) {\n        u[i][v[i][j]] = 1;\n      }\n      dfs1(i, v[i][j]);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    //cout << u[from[i]][to[i]] << ' ' << used[to[i]][from[i]] << \"\\n\";\n    if (u[from[i]][to[i]] + used[to[i]][from[i]] == 1) {\n      cout << \"diff\\n\";\n    } else {\n      cout << \"same\\n\";\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector> \n#include <string>\n\nusing namespace std;\nconst int MAXN = 1e3 + 10;\nstruct node\n{\n\tint nxt, id;\n\tnode(int a, int b)\n\t{\n\t\tnxt = a;\n\t\tid = b;\n\t}\n\tnode() {}\n};\nint n, m, tim;\nint vis[MAXN];\nint res[MAXN][MAXN][2];\nint u[MAXN * MAXN], v[MAXN * MAXN];\nvector <node> edge[MAXN];\ninline void _read(int &x)\n{\n\tx = 0;\n\tchar t = getchar();\n\twhile (!isdigit(t)) t = getchar();\n\twhile (isdigit(t))\n\t{\n\t\tx = x * 10 + t - '0';\n\t\tt = getchar();\n\t}\n}\ninline void dfs(const int &now, const int fa, const int &b, const int &f)\n{\n\tvis[now] = tim;\n\tres[fa][now][f] = b;\n\tregister int len = edge[now].size();\n\tfor (register int i = 0; i < len; i++)\n\t\tif (vis[edge[now][i].nxt] != tim)\n\t\t\tdfs(edge[now][i].nxt, fa, b, f);\n}\ninline void solve(const int & now)\n{\n\ttim++; vis[now] = tim;\n\tregister int len = edge[now].size();\n\tfor (register int i = 0; i < len; i++)\n\t\tif (vis[edge[now][i].nxt] != tim)\n\t\t\tdfs(edge[now][i].nxt, now, edge[now][i].id, 0);\n\n\treverse(edge[now].begin(), edge[now].end());\n\n\tvis[now] = ++tim;\n\tfor (register int i = 0; i < len; i++)\n\t\tif (vis[edge[now][i].nxt] != tim)\n\t\t\tdfs(edge[now][i].nxt, now, edge[now][i].id, 1);\n}\nint main(int argc, char **Argv)\n{\n\t_read(n), _read(m);\n\tfor (register int i = 1; i <= m; i++)\n\t{\n\t\t_read(u[i]), _read(v[i]);\n\t\tedge[u[i]].push_back(node(v[i], i));\n\t}\n\tfor (register int i = 1; i <= n; i++)\n\t\tsolve(i);\n\tfor (register int i = 1; i <= m; i++)\n\t{\n\t\tif ((res[v[i]][u[i]][0] != 0) ^ 0 ^ (res[u[i]][v[i]][0] != i || res[u[i]][v[i]][1] != i))\n\t\t\tputs(\"diff\");\n\t\telse\n\t\t\tputs(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<1)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],vis[N];\nvector<int> e[N];\n/*\nvoid dfs(int st,int u,int now){\n\tif (st==u) return;\n\tif (a[st][u]>=2) return;\n\tif (a[st][u]==1 && vis[u]==now) return;\n\tif (a[st][u]==0) vis[u]=now;\n\ta[st][u]++;\n\trep (i,0,(int)e[u].size()-1) dfs(st,e[u][i],now);\n}\n*/\nvoid dfs(int p, int node, int dir)\n{\n\tif (node == p)return;\n\tif (a[p][node] >= 2)return;\n\tif (a[p][node] == 1 && vis[node] == dir)return;\n\tif (a[p][node] == 0)vis[node] = dir;\n\ta[p][node]++;\n\tfor (int i = 0; i < e[node].size(); i++)dfs(p, e[node][i], dir);\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read();\n\t\te[x[i]].push_back(y[i]);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,-1,sizeof(vis));\n\t\trep (j,0,(int)e[i].size()-1) dfs(i,e[i][j],e[i][j]);\n\t}\n\trep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]]>=1;\n\t\tbool f2=a[x[i]][y[i]]>=2;\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int INF=0x7f7f7f7f;\nconst int maxn=(2e5)+10;\nint n,m;\nint to[maxn],from[maxn],S;\nbool mk[1010][1010],dis[1010][1010],vis[1010];\nvector<int> g[1010];\nvoid dfs(int u) {\n\tvis[u]=1;\n\tmk[S][u]=1;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (!vis[v]) dfs(v);\n\t}\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m);\n\tfor (int i=1;i<=m;i++) {\n\t\tread(from[i]); read(to[i]);\n\t\tg[from[i]].push_back(to[i]);\n\t}\n\tint x,y;\n\tfor (S=1;S<=n;S++) {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvis[S]=1;\n\t\tfor (int i=0,v;i<g[S].size();i++) {\n\t\t\tv=g[S][i];\n\t\t\tif (!vis[v]) dfs(v);\n\t\t\telse dis[S][v]=1;\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tvis[S]=1;\n\t\tfor (int i=g[S].size()-1,v;i>=0;i--) {\n\t\t\tv=g[S][i];\n\t\t\tif (!vis[v]) dfs(v);\n\t\t\telse dis[S][v]=1;\n\t\t}\n\t}\n\tfor (int i=1;i<=m;i++) {\n\t\tx=from[i],y=to[i];\n\t\tif (dis[x][y]==mk[y][x]) printf(\"same\\n\");\n\t\telse printf(\"diff\\n\");\n\t}\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 2005;\n\nconst int M = 4e5 + 5;\n\nint n, m, x, y;\nint fi[N], nt[M], to[M], tot;\n\nvoid link(int x, int y) {\n\tnt[++ tot] = fi[x], to[tot] = y, fi[x] = tot;\n}\n\nint bz[N];\n\nvoid dg(int x) {\n\tif(bz[x]) return;\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tdg(to[i]);\n}\n\nint b[N][N];\n\nint d[N], d0, ky[N][N];\n\nvoid dfs(int x) {\n\tif(bz[x]) return;\n\tbz[x] = 1;\n\tfor(int i = fi[x]; i; i = nt[i])\n\t\tdfs(to[i]);\n}\n\n#define mem(a) memset(a, 0, sizeof a)\n\nint ans[M];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tlink(x, y);\n\t}\n\tfo(st, 1, n) {\n\t\tmem(bz); d0 = 0;\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\td[++ d0] = to[i];\n\t\tbz[st] = 1;\n\t\tfo(i, 1, d0) {\n\t\t\tky[st][d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfo(j, 1, n) b[st][j] |= bz[j];\n\t\tmem(bz); bz[st] = 1;\n\t\tfd(i, d0, 1) {\n\t\t\tky[st][d[i]] |= bz[d[i]];\n\t\t\tdfs(d[i]);\n\t\t}\n\t\tfo(j, 1, n) b[st][j] |= bz[j];\n\t}\n\tfo(st, 1, n) {\n\t\tfor(int i = fi[st]; i; i = nt[i])\n\t\t\tans[i] = b[to[i]][st] ^ ky[st][to[i]];\n\t}\n\tfo(i, 1, m) pp(\"%s\\n\", ans[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N;\nvector<int> E[1010];\nint M;\nint ID[1010][1010];\nint G[1010][1010];\nint P[1010][1010];\nint D[2][1010];\nint A[202020],B[202020];\n\nvoid dfs(int cur,int org) {\n\tG[org][cur]=1;\n\tFORR(e,E[cur]) if(G[org][e]==0) dfs(e,org);\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tMINUS(ID);\n\t\n\tFOR(i,M) {\n\t\tcin>>A[i]>>B[i];\n\t\tA[i]--;\n\t\tB[i]--;\n\t\tE[A[i]].push_back(B[i]);\n\t\tID[A[i]][B[i]]=i;\n\t}\n\t\n\tFOR(i,N) dfs(i,i);\n\tFOR(i,N) {\n\t\tFOR(j,2) {\n\t\t\tFOR(x,N) D[j][x]=-1<<30;\n\t\t\tpriority_queue<pair<int,int>> PQ;\n\t\t\tFOR(x,N) if(ID[i][x]>=0) {\n\t\t\t\tD[j][x]=ID[i][x];\n\t\t\t\tif(j) D[j][x]=-D[j][x];\n\t\t\t\tPQ.push({D[j][x],x});\n\t\t\t}\n\t\t\t\n\t\t\twhile(PQ.size()) {\n\t\t\t\tint cur=PQ.top().second;\n\t\t\t\tint sc=PQ.top().first;\n\t\t\t\tPQ.pop();\n\t\t\t\t\n\t\t\t\tif(D[j][cur]!=sc) continue;\n\t\t\t\tFORR(e,E[cur]) if(D[j][e]<sc) {\n\t\t\t\t\tif(e==i) continue;\n\t\t\t\t\tD[j][e]=sc;\n\t\t\t\t\tPQ.push({sc,e});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFOR(x,N) {\n\t\t\tif(D[0][x]!=-1<<30 && D[0][x]!=-D[1][x]) P[i][x]=1;\n\t\t}\n\t}\n\t\n\tFOR(i,M) {\n\t\tif(P[A[i]][B[i]]==G[B[i]][A[i]]) cout<<\"same\"<<endl;\n\t\telse cout<<\"diff\"<<endl;\n\t}\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#define N 1005\n#define M 200005\nusing namespace std;\nstruct Edge{\n\tint to,next;\n}edge[M];\nint head[N],tot;\nvoid addedge(int from,int to){\n\tedge[++tot].to=to;\n\tedge[tot].next=head[from];\n\thead[from]=tot;\n}\nint p1[N][N];\nvoid dfs1(int now,int p){\n\tset<int> s;\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\ts.insert(v);\n\t}\n\tfor(set<int>::iterator it=s.begin();it!=s.end();++it){\n\t\tint v=*it;\n\t\tif(p1[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp1[p][v]=now;\n\t\tdfs1(v,p);\n\t}\n}\nint p2[N][N];\nvoid dfs2(int now,int p){\n\tset<int> s;\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tint v=edge[i].to;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\ts.insert(-v);\n\t}\n\tfor(set<int>::iterator it=s.begin();it!=s.end();++it){\n\t\tint v=-*it;\n\t\tif(p2[p][v]){\n\t\t\tcontinue;\n\t\t}\n\t\tp2[p][v]=now;\n\t\tdfs2(v,p);\n\t}\n}\nint u[M],v[M];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;++i){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\taddedge(u[i],v[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tp1[i][i]=i;\n\t\tdfs1(i,i);\n\t\tp2[i][i]=i;\n\t\tdfs2(i,i);\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint flag=0;\n\t\tif(p1[v[i]][u[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(p1[u[i]][v[i]]!=p2[u[i]][v[i]]){\n\t\t\tflag^=1;\n\t\t}\n\t\tif(flag){\n\t\t\tprintf(\"diff\\n\");\n\t\t}else{\n\t\t\tprintf(\"same\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1100;\n\nint u[maxn], v[maxn];\nvector<int> g[maxn];\nbool chk[maxn][maxn];\nint root;\nbool vis[maxn];\n\nnamespace SCC {\n\tconst int N = 1100;\n\tint T, qn;\n\tint q[N], vis[N];\n\tvector<int> adj[N], radj[N];\n\t\n\tvoid dfs(int u) {\n\t\tvis[u] = 1;\n\t\tfor (int v : adj[u]) {\n\t\t\tif (!vis[v]) dfs(v);\n\t\t}\n\t\tq[++qn] = u;\n\t}\n\t\n\tvoid rdfs(int u) {\n\t\tvis[u] = T;\n\t\tfor (int v : radj[u]) {\n\t\t\tif (!vis[v]) rdfs(v);\n\t\t}\n\t}\n\t\n\tvoid SCC(int n) {\n\t\tmemset(vis, 0, sizeof(int) * (n + 1));\n\t\tqn = 0;\n\t\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\t\tmemset(vis, 0, sizeof(int) * (n + 1));\n\t\tfor (int i = n; i > 0; i--) if (!vis[q[i]]) ++T, rdfs(q[i]);\n\t}\n};\n\ninline void dfs(int u) {\n\tvis[u] = true;\n\tfor(auto v : g[u]) {\n\t\tif(vis[v]) {\n\t\t\tif(u == root) chk[root][v] = false;\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v);\n\t\tif(u == root) chk[root][v] &= true;\n\t\telse chk[root][v] = false;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n, m; cin >> n >> m;\n\tfor(int i = 0; i < m; ++ i) {\n\t\tcin >> u[i] >> v[i];\n\t\tg[u[i]].push_back(v[i]);\n\t\tSCC::adj[u[i]].push_back(v[i]);\n\t\tSCC::radj[v[i]].push_back(u[i]);\n\t}\n\t// get SCC\n\tSCC::SCC(n);\n\t// check the u -> v edge is the unique way.\n\tfor(int i = 1; i <= n; ++ i) for(int j = 1; j <= n; ++ j) chk[i][j] = true;\n\tfor(int step = 0; step < 2; ++ step) {\n\t\tfor(int i = 1; i <= n; ++ i) {\n\t\t\troot = i;\n\t\t\tif(step) reverse(g[i].begin(), g[i].end());\n\t\t\tmemset(vis, false, sizeof vis);\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++ i) {\n\t\tint flag = SCC::vis[u[i]] == SCC::vis[v[i]];\n\t\tif(chk[u[i]][v[i]] == flag) cout << \"diff\\n\";\n\t\telse cout << \"same\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 1e3 + 5;\nconst int maxm = 2e5 + 5;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nvector<int> adj[maxn];\nint id[maxn][maxn];\nbool vis[maxn][maxn];\nbool vis1[maxn];\nint a[maxm],b[maxm];\nbool res[maxm];\nint n , m;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> m;\n    for(int i = 1 ; i <= m ; ++i){\n        cin >> a[i] >> b[i];\n        adj[a[i]].pb(i);\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        queue<int> q;\n        q.push(i);vis[i][i] = 1;\n        while(q.size()){\n            auto u = q.front();q.pop();\n            for(auto &c : adj[u]){\n                if(vis[i][b[c]] == 0){\n                    vis[i][b[c]] = 1;q.push(b[c]);\n                }\n            }\n        }\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        memset(vis1,0,sizeof vis1);\n        vis1[i] = 1;\n        for(auto &c : adj[i]){\n            if(vis1[b[c]]){\n                res[c] = 1;\n                continue;\n            }\n            queue<int> q;q.push(b[c]);vis1[b[c]] = 1;\n            while(q.size()){\n                auto u = q.front();q.pop();\n                for(auto &c : adj[u]){\n                    if(vis1[b[c]] == 0){\n                        vis1[b[c]] = 1;q.push(b[c]);\n                    }\n                }\n            }\n        }\n        reverse(adj[i].begin(),adj[i].end());\n        memset(vis1,0,sizeof vis1);\n        vis1[i] = 1;\n        for(auto &c : adj[i]){\n            if(vis1[b[c]]){\n                res[c] = 1;\n                continue;\n            }\n            queue<int> q;q.push(b[c]);vis1[b[c]] = 1;\n            while(q.size()){\n                auto u = q.front();q.pop();\n                for(auto &c : adj[u]){\n                    if(vis1[b[c]] == 0){\n                        vis1[b[c]] = 1;q.push(b[c]);\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 1 ; i <= m ; ++i){\n//        cout << vis[b[i]][a[i]] << \" \" << res[i] << \" \";\n        if(vis[b[i]][a[i]] == res[i])cout << \"same\\n\";\n        else cout << \"diff\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1010\n#define M 200200\nusing namespace std;\n\nint n, m;\nint tot, fir[N], nxt[M], to[M];\n\nvoid addE(int u, int v) {\n    nxt[++tot] = fir[u], fir[u] = tot, to[tot] = v;\n}\n\nvoid dfs(int u, int mk, int *vis) {\n    vis[u] = mk;\n    for (int i = fir[u], v; i; i = nxt[i]) {\n        v = to[i];\n        if (vis[v] == mk) continue;\n        dfs(v, mk, vis);\n    }\n}\n\nint vis[N][N], lch[N], rch[N], ans[N], stk[N], top;\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n    \n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; ++i)\n        scanf(\"%d%d\", &u, &v), addE(u, v);\n\n    for (int i = 1; i <= n; ++i)\n        dfs(i, 1, vis[i]);\n\n    for (int u = 1; u <= n; ++u) {\n        memset(lch, 0, sizeof lch);\n        memset(rch, 0, sizeof rch);\n        top = 0;\n        for (int i = fir[u]; i; i = nxt[i])\n            stk[++top] = to[i];\n        for (int i = top, v; i >= 1; --i)\n            if (!lch[v = stk[i]]) lch[u] = i, dfs(v, i, lch);\n        for (int i = 1, v; i <= top; ++i)\n            if (!rch[v = stk[i]]) rch[u] = i, dfs(v, i, rch);\n        for (int i = fir[u], v; i; i = nxt[i]) {\n            v = to[i];\n            if (vis[v][u] == (lch[v] != rch[v]))\n                ans[i] = 1;\n        }\n    }\n    \n    for (int i = 1; i <= m; ++i)\n        puts(ans[i] ? \"same\" : \"diff\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M;\nint A[1 << 18], B[1 << 18];\nint Answer[1 << 18];\n\n// 強連結成分分解\nvector<int> X[1009], Y[1009], I;\nbool used[1009];\nint col[1009], group[1009], cnts;\n\nvoid dfs1(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tdfs1(X[pos][i]);\n\t}\n\tI.push_back(pos);\n}\n\nvoid dfs2(int pos) {\n\tcol[pos] = cnts; group[cnts]++;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (col[Y[pos][i]] >= 1) continue;\n\t\tdfs2(Y[pos][i]);\n\t}\n}\n\n// DAG における計算\nvector<pair<int, int>> Z[1009];\nint dp[1009][1009];\n\n// サイクルの列挙\nvector<pair<int, int>> P[1009], Q[1009];\nint Score1[1 << 18], Score2[1 << 18];\n\nint dfs5(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < P[pos].size(); i++) {\n\t\tif (used[P[pos][i].first] == true) continue;\n\t\tr += dfs5(P[pos][i].first);\n\t}\n\treturn r;\n}\n\nint dfs6(int pos) {\n\tused[pos] = true; int r = 1;\n\tfor (int i = 0; i < Q[pos].size(); i++) {\n\t\tif (used[Q[pos][i].first] == true) continue;\n\t\tr += dfs6(Q[pos][i].first);\n\t}\n\treturn r;\n}\n\n// 最後の計算\nvector<int> J[1009], J2[1009], K;\nint colo[1009], cntv;\n\nvoid dfs3(int pos) {\n\tused[pos] = true;\n\tfor (int i : J[pos]) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\tK.push_back(pos);\n}\n\nvoid dfs4(int pos) {\n\tcolo[pos] = cntv;\n\tfor (int i : J2[pos]) {\n\t\tif (colo[i] >= 1) continue;\n\t\tdfs4(i);\n\t}\n}\n\nbool calc(int pos) {\n\tfor (int i = 1; i <= N; i++) J[i].clear();\n\tfor (int i = 1; i <= N; i++) J2[i].clear();\n\tfor (int i = 1; i <= N; i++) used[i] = false;\n\tfor (int i = 1; i <= N; i++) colo[i] = 0;\n\tcntv = 0;\n\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (i == pos) continue;\n\t\tJ[A[i]].push_back(B[i]);\n\t\tJ2[B[i]].push_back(A[i]);\n\t}\n\tK.clear();\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs3(i);\n\t}\n\t\n\tfor (int i = K.size() - 1; i >= 0; i--) {\n\t\tif (colo[K[i]] >= 1) continue;\n\t\tcntv++; dfs4(K[i]);\n\t}\n\n\tif (cnts == cntv) return false;\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= M; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tX[A[i]].push_back(B[i]);\n\t\tY[B[i]].push_back(A[i]);\n\t}\n\n\t// ステップ 1: 強連結成分ごとに分ける\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\t\tdfs1(i);\n\t}\n\tfor (int i = I.size() - 1; i >= 0; i--) {\n\t\tif (col[I[i]] >= 1) continue;\n\t\tcnts++; dfs2(I[i]);\n\t}\n\n\t// ステップ 2: DAG のグラフを処理する\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tZ[col[A[i]]].push_back(make_pair(col[B[i]], i));\n\t}\n\tfor (int i = 1; i <= cnts; i++) {\n\t\tdp[i][i] = 1;\n\t\tfor (int j = 1; j <= cnts; j++) {\n\t\t\tfor (int k = 0; k < Z[j].size(); k++) {\n\t\t\t\tdp[i][Z[j][k].first] += dp[i][j];\n\t\t\t\tif (dp[i][Z[j][k].first] >= 2) dp[i][Z[j][k].first] = 2;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] == col[B[i]]) continue;\n\t\tif (dp[col[A[i]]][col[B[i]]] >= 2) Answer[i] = 2;\n\t\telse Answer[i] = 1;\n\t}\n\n\t// ステップ 3: 候補辺の列挙\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tP[A[i]].push_back(make_pair(B[i], i));\n\t\tQ[B[i]].push_back(make_pair(A[i], i));\n\t\tAnswer[i] = 1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < P[i].size(); j++) {\n\t\t\tint V1 = dfs5(P[i][j].first);\n\t\t\tScore1[P[i][j].second] = V1;\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) used[j] = false;\n\t\tused[i] = true;\n\t\tfor (int j = 0; j < Q[i].size(); j++) {\n\t\t\tint V2 = dfs6(Q[i][j].first);\n\t\t\tScore2[Q[i][j].second] = V2;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (col[A[i]] != col[B[i]]) continue;\n\t\tif (group[col[A[i]]] <= Score1[i] + Score2[i]) Answer[i] = 0;\n\t}\n\n\t// ステップ 4: 最後の計算\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] >= 1) continue;\n\t\tbool flag = calc(i);\n\t\tif (flag == false) Answer[i] = 1;\n\t\telse Answer[i] = 2;\n\t}\n\n\t// 出力\n\tfor (int i = 1; i <= M; i++) {\n\t\tif (Answer[i] == 1) printf(\"same\\n\");\n\t\tif (Answer[i] == 2) printf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*==============================\n * Authot : ylsoi\n * Time : 2018.3.20\n * Problem : ARC92F\n * File : ARC92F.cpp\n * Algorithm : Strange Algorithm\n * ===========================*/\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\nvoid File(){\n\tfreopen(\"ARC92F.in\",\"r\",stdin);\n\tfreopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nvector<int>E[maxn];\nint n,m,beg[maxn],len,num[maxn][maxn];\nbool can[maxn][maxn],vis[maxn],can1[maxn][maxn];\nint vis1[maxn],vis2[maxn],from[maxm],to[maxm];\nvoid dfs(int u,int rt){\n\tvis[u]=1;\n\tcan[rt][u]=1;\n\tint size=E[u].size()-1;\n\tREP(i,0,size){\n\t\tint v=E[u][i];\n\t\tif(vis[v])continue;\n\t\tdfs(v,rt);\n\t}\n}\nvoid dfs1(int u){\n\tvis[u]=1;\n\tint size=E[u].size()-1;\n\tREP(i,0,size){\n\t\tint v=E[u][i];\n\t\tif(vis[v])continue;\n\t\tvis1[v]=num[u][v];\n\t\tdfs1(v);\n\t}\n}\nvoid dfs2(int u){\n\tvis[u]=1;\n\tint size=E[u].size()-1;\n\tDREP(i,size,0){\n\t\tint v=E[u][i];\n\t\tif(vis[v])continue;\n\t\tvis2[v]=num[u][v];\n\t\tdfs2(v);\n\t}\n}\nint main(){\n\t//File();\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tE[u].push_back(v);\n\t\tnum[u][v]=++len;\n\t\tfrom[len]=u;\n\t\tto[len]=v;\n\t}\n\tREP(i,1,n){\n\t\tdfs(i,i);\n\t\tmem(vis);\n\t}\n\tREP(i,1,n){\n\t\tdfs1(i);\n\t\tmem(vis);\n\t\tdfs2(i);\n\t\tmem(vis);\n\t\tint size=E[i].size()-1;\n\t\tREP(j,0,size){\n\t\t\tint v=E[i][j];\n\t\t\tif(vis1[v]!=num[i][v] || vis2[v]!=num[i][v])\n\t\t\t\tcan1[i][v]=1;\n\t\t}\n\t\tmem(vis1);\n\t\tmem(vis2);\n\t}\n\tREP(i,1,m){\n\t\tint u=from[i],v=to[i];\n\t\tif((can[v][u]^can1[u][v])==0)\n\t\t\tputs(\"same\");\n\t\telse puts(\"diff\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nvector<int> e[1010];\nint n, m;\n\nint fr[200010];\nint to[200010];\nchar gyaku[200010];\n\nbitset<1001> reach[1001], todo;\nqueue<int> q;\n\nvoid F(int x){\n\ttodo.reset();\n\tauto& v = e[x];\n\tint s = v.size();\n\tfor(int i=0; i<s; ++i){\n\t\tint y = to[v[i]];\n\t\tif(todo[y]){\n\t\t\tgyaku[v[i]] = 1;\n\t\t} else {\n\t\t\tq.push(y);\n\t\t\ttodo[y]=1;\n\t\t\twhile(q.size()){\n\t\t\t\tint a=q.front(); q.pop();\n\t\t\t\tfor(int ei:e[a]){\n\t\t\t\t\tint b=to[ei];\n\t\t\t\t\tif(b == x || todo[b]) continue;\n\t\t\t\t\ttodo[b]=1; q.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treach[x] = todo;\n\ttodo.reset();\n\tfor(int i=s-1; 0<=i; --i){\n\t\tint y = to[v[i]];\n\t\tif(todo[y]){\n\t\t\tgyaku[v[i]] = 1;\n\t\t} else {\n\t\t\tq.push(y);\n\t\t\ttodo[y]=1;\n\t\t\twhile(q.size()){\n\t\t\t\tint a=q.front(); q.pop();\n\t\t\t\tfor(int ei:e[a]){\n\t\t\t\t\tint b=to[ei];\n\t\t\t\t\tif(b == x || todo[b]) continue;\n\t\t\t\t\ttodo[b]=1; q.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tread(n, m);\n\tfor(int i=1; i<=m; ++i){\n\t\tint a, b; read(a, b);\n\t\tfr[i] = a; to[i] = b;\n\t\te[a].pb(i);\n\t}\n\tfor(int i=1; i<=n; ++i) F(i);\n\t\n\tfor(int i=1; i<=m; ++i){\n\t\tif(gyaku[i] != reach[to[i]][fr[i]]){\n\t\t\tputs(\"diff\");\n\t\t} else {\n\t\t\tputs(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1010;\nint n,m,ind,cnt,top;\nint vis[N],que[N],stk[N],bl[N],dfn[N],low[N],u[N*200],v[N*200];\nbool ok[N],ins[N];\nvector<int> ve[N],id[N];\ninline void tarjan(int x){\n\tstk[++top]=x; ins[x]=1; dfn[x]=low[x]=++ind;\n\tfor(auto to:ve[x])\n\t\tif(!dfn[to]) tarjan(to),low[x]=min(low[x],low[to]);\n\t\telse if(ins[to]) low[x]=min(low[x],dfn[to]);\n\tif(low[x]==dfn[x]){\n\t\tint y; ++cnt;\n\t\tdo y=stk[top--],ins[y]=0,bl[y]=cnt;\n\t\twhile(y!=x);\n\t}\n}\ninline void solve(int rt){\n\tint head=1,tail=0; vis[rt]=++ind;\n\tfor(int i=0;i<ve[rt].size();++i){\n\t\tok[id[rt][i]]|=vis[ve[rt][i]]==ind;\n\t\tif(vis[ve[rt][i]]!=ind) vis[ve[rt][i]]=ind,que[++tail]=ve[rt][i];\n\t\twhile(head<=tail){\n\t\t\tint x=que[head++];\n\t\t\tfor(auto to:ve[x]) if(vis[to]!=ind) vis[to]=ind,que[++tail]=to;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,a,b;i<=m;++i) scanf(\"%d%d\",&a,&b),ve[a].push_back(b),id[a].push_back(i),u[i]=a,v[i]=b;\n\ttarjan(1);\n\tfor(int i=1;i<=n;++i) solve(i),reverse(ve[i].begin(),ve[i].end()),reverse(id[i].begin(),id[i].end()),solve(i);\n\tfor(int i=1;i<=m;++i){\n\t\tif(bl[u[i]]==bl[v[i]]) puts(ok[i]?\"same\":\"diff\");\n\t\telse puts(ok[i]?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1005;\nconst int M = 200005;\n\nvector<int> G[N];\n\nint a[M], b[M], vis[N], w[N][N], p[N][N], q[N][N];\n\nint n, m;\n\nvoid dfs(int u, int x)\n{\n\tvis[u] = 1, w[x][u] = 1;\n\tfor (auto v : G[u])\n\t\tif (!vis[v])\n\t\t\tdfs(v, x);\n}\n\nvoid dfs2(int u, int x, bool ch)\n{\n\tfor (auto v : G[u])\n\t\tif (v != x && !vis[v])\n\t\t{\n\t\t\tvis[v] = vis[u];\n\t\t\tdfs2(v, x, ch);\n\t\t}\n\tif (!ch)\n\t\tp[x][u] = vis[u];\n\telse\n\t\tq[x][u] = vis[u];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> a[i] >> b[i];\n\t\tG[a[i]].push_back(b[i]);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tdfs(i, i);\t\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tint SZ = G[i].size();\n\t\tfor (int j = 0; j < SZ; j++)\n\t\t{\n\t\t\tint v = G[i][j];\n\t\t\tif (!vis[v])\n\t\t\t\tvis[v] = v, dfs2(v, i, 0);\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tfor (int j = SZ - 1; j >= 0; j--)\n\t\t{\n\t\t\tint v = G[i][j];\n\t\t\tif (!vis[v])\n\t\t\t\tvis[v] = v, dfs2(v, i, 1);\t\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x = w[b[i]][a[i]];\n\t\tint y = (p[a[i]][b[i]] != b[i] || q[a[i]][b[i]] != b[i]);\n\t\tif (x == y)\n\t\t\tcout << \"same\" << endl;\n\t\telse\n\t\t\tcout << \"diff\" << endl;\n\t}\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long int lld;\nconst int MAX=1020;\nconst int MOD=1000000007;\nvector<int> adj[MAX],adj_s[MAX],radj[MAX],radj_s[MAX],group[MAX],g_adj[MAX];\nvector<pii> cnd;\nstack<int> scc_chk,fin_chk,temp;\nint n,m,id[MAX],chk[MAX],id_len,pos[MAX][MAX],tab[MAX][MAX],src=-1,dst=-1;\nint g_tab[MAX][MAX],g_pos[MAX][MAX],g_in[MAX],g_out[MAX],g_cnt[MAX][MAX],fin[MAX*200];\nvoid scc1(int x){\n    if(chk[x]) return;\n    chk[x]=1;\n    for(int i=0;i<adj[x].size();i++) scc1(adj[x][i]);\n    scc_chk.push(x);\n}\nvoid scc2(int x,int y){\n    if(!chk[x]) return;\n    chk[x]=0,id[x]=y,group[y].push_back(x);\n    for(int i=0;i<radj[x].size();i++) scc2(radj[x][i],y);\n}\nvoid cntdp(int x){\n    if(g_cnt[x][0]) return;\n    g_cnt[x][0]=1,g_cnt[x][x]=1;\n    for(int i=0;i<g_adj[x].size();i++){\n        cntdp(g_adj[x][i]);\n        for(int j=1;j<=id_len;j++) g_cnt[x][j]+=g_cnt[g_adj[x][i]][j],g_cnt[x][j]%=MOD;\n    }\n}\nvoid dfs(int x){\n    if(chk[x]) return;\n    chk[x]=1;\n    for(int i=0;i<adj_s[x].size();i++) {\n        if(!chk[adj_s[x][i]]) dfs(adj_s[x][i]),cnd.push_back(make_pair(x,adj_s[x][i]));\n    }\n}\nvoid rdfs(int x){\n    if(!chk[x]) return;\n    chk[x]=0;\n    for(int i=0;i<radj_s[x].size();i++) {\n        if(chk[radj_s[x][i]]) rdfs(radj_s[x][i]),cnd.push_back(make_pair(radj_s[x][i],x));\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        int t1,t2;\n        scanf(\"%d%d\",&t1,&t2);\n        adj[t1].push_back(t2);\n        radj[t2].push_back(t1);\n        tab[t1][t2]=i;\n    }\n    for(int i=1;i<=n;i++) scc1(i);\n    while(!scc_chk.empty()){\n        int t=scc_chk.top();\n        scc_chk.pop();\n        if(chk[t]) scc2(t,id_len++);\n    }\n    for(int i=1;i<=n;i++) for(int j=0;j<adj[i].size();j++){\n        if(id[i]!=id[adj[i][j]]) {\n            if(!g_tab[id[i]][id[adj[i][j]]]) g_adj[id[i]].push_back(id[adj[i][j]]);\n            g_tab[id[i]][id[adj[i][j]]]++;\n        }\n        else{\n            adj_s[i].push_back(adj[i][j]);\n            radj_s[adj[i][j]].push_back(i);\n        }\n    }\n    for(int i=0;i<id_len;i++){\n        g_out[i]=g_adj[i].size();\n        for(int j=0;j<g_adj[i].size();j++)  g_in[g_adj[i][j]]++;//printf(\"%d:%d \",g_adj[i][j],g_tab[i][g_adj[i][j]]);\n        //printf(\"\\n\");\n    }\n    for(int i=0;i<id_len;i++) cntdp(i);\n    for(int i=0;i<id_len;i++) for(int j=0;j<id_len;j++) if(i!=j&&g_tab[i][j]==1) if(g_cnt[i][j]==1) g_pos[i][j]=1;//printf(\"%d %d\\n\",i,j);\n    for(int i=0;i<id_len;i++) dfs(group[i][0]),rdfs(group[i][0]);\n    for(int i=0;i<cnd.size();i++){\n        fin_chk.push(cnd[i].first);\n        while(!fin_chk.empty()){\n            int t=fin_chk.top();\n            fin_chk.pop();\n            if(chk[t]==0){\n                temp.push(t);\n                chk[t]=1;\n                for(int j=0;j<adj_s[t].size();j++){\n                    if(cnd[i].first!=t||cnd[i].second!=adj_s[t][j]) fin_chk.push(adj_s[t][j]);\n                }\n            }\n        }\n        if(temp.size()!=group[id[cnd[i].first]].size()) pos[cnd[i].first][cnd[i].second]=1;\n        //printf(\"%d %d %d %d\\n\",cnd[i].first,cnd[i].second,temp.size(),group[id[cnd[i].first]].size());\n        while(!temp.empty()){\n            chk[temp.top()]=0;\n            temp.pop();\n        }\n    }\n    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++){\n        if(tab[i][j]>0){\n            if(id[i]==id[j]) fin[tab[i][j]]=!pos[i][j];\n            else fin[tab[i][j]]=g_pos[id[i]][id[j]];\n        }\n    }\n    for(int i=1;i<=m;i++){\n        if(fin[i]) printf(\"same\\n\");\n        else printf(\"diff\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e3+7,maxm=1e5+7;\nint c[2][maxn][maxn];\nvector<int> G[maxn];\nint a[maxm],b[maxm];\nvoid dfs(int x,int st,int ptr,bool typ){\n\tif(!c[typ][st][x]) c[typ][st][x]=ptr;else return ;//cout<<st<<' '<<x<<endl;\n\tfor(int y:G[x]) if(!c[typ][st][y]) dfs(y,st,ptr,typ);\n}\nint main(){\n\tint n,m;cin>>n>>m;\n\tfor(int i=1;i<=m;++i) scanf(\"%d%d\",&a[i],&b[i]),G[a[i]].push_back(b[i]);\n\tfor(int x=1;x<=n;++x) {\n\t\tc[0][x][x]=c[1][x][x]=1;\n\t\tfor(auto y:G[x]) dfs(y,x,y,0);\n\t\treverse(G[x].begin(),G[x].end());\n\t\tfor(auto y:G[x]) dfs(y,x,y,1);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tbool flag=(c[0][b[i]][a[i]]>0);//cout<<flag<<endl;\n\t\tif(c[0][a[i]][b[i]]!=c[1][a[i]][b[i]]) flag^=1;//cout<<c[0][3][4]<<' '<<c[1][3][4]<<' '<<a[i]<<' '<<b[i]<<endl;\n\t\tif(flag) puts(\"diff\");else puts(\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tregister int x=0;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9')\tch=getchar();\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=1e3+5;\nconst int M=2e5+5;\nstruct each{\n\tint x,y;\n}a[M];\nvector<int>b[N];\nint n,m,cnt[N],suf[N][N],pre[N][N],vis[N],vi[N][N];\nvoid dfs(int x){\n\tint si=b[x].size(); vis[x]=1;\n\tfor(int i=0;i<si;i++)\n\t\tif(!vis[b[x][i]])\tdfs(b[x][i]);\n}\nvoid dfs(int x,int k,int ty){\n\tint si=b[x].size();\tvis[x]=1;\n\tif(ty){\n\t\tfor(int i=si-1;~i;i--){\n\t\t\tint v=b[x][i];\n\t\t\tif(!vis[v]) pre[k][v]=x,dfs(v,k,ty);\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=0;i<si;i++){\n\t\t\tint v=b[x][i];\n\t\t\tif(!vis[v]) suf[k][v]=x,dfs(v,k,ty);\n\t\t}\n\t}\n}\nbool check(int x){\n\tint v=b[x][cnt[x]++];\n\tif(pre[x][v]==suf[x][v]&&pre[x][v]==x&&suf[x][v]==x)\treturn false;\n\telse\treturn true;\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;i++){\n\t\ta[i].x=read(),a[i].y=read();\n\t\tb[a[i].x].push_back(a[i].y);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tdfs(i);\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tvi[i][j]=vis[j],vis[j]=0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)\tvis[j]=0;\n\t\tdfs(i,i,0);\n\t\tfor(int j=1;j<=n;j++)\tvis[j]=0;\n\t\tdfs(i,i,1);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(vi[a[i].y][a[i].x]^check(a[i].x))\tputs(\"diff\");\n\t\telse\tputs(\"same\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1000;\nconst int MAXM=200000;\nvector<int>G[MAXN+5]; \nint to[MAXM + 5];\nvoid addedge(int u, int i) {G[u].push_back(i);}\nint tag[MAXN + 5], que[2*MAXN + 5];\nbool ans1[MAXM + 5], ans2[MAXM + 5];\nint n, m;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint a; scanf(\"%d%d\", &a, &to[i]);\n\t\taddedge(a, i);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) tag[j] = 0;\n\t\tint s = 1, t = 0;\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\ttag[que[++t] = to[G[i][p]]] = G[i][p];\n\t\twhile( s <= t ) {\n\t\t\tint x = que[s++], y = tag[x];\n\t\t\tfor(int p=0;p<G[x].size();p++) {\n\t\t\t\tint q = to[G[x][p]];\n\t\t\t\tif( q != i ) {\n\t\t\t\t\tif( tag[q] != -1 ) {\n\t\t\t\t\t\tif( tag[q] == 0 )\n\t\t\t\t\t\t\ttag[que[++t] = q] = y;\n\t\t\t\t\t\telse if( tag[q] != y )\n\t\t\t\t\t\t\ttag[que[++t] = q] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse ans1[G[x][p]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\tif( tag[to[G[i][p]]] == -1 ) ans2[G[i][p]] = 1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tputs(ans1[i] ^ ans2[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nstd::vector<int>to[1010],t[1010];\nint ans[200100],fr[1010][1010],tg[1010][1010],I;\nvoid dfs(re int a,re int*ff)\n{\n\tfor(re int i=0;i<to[a].size();i++)if(!ff[to[a][i]])\n\t{\n\t\tff[to[a][i]]=ff[a];dfs(to[a][i],ff);\n\t}\n}\nint main()\n{\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\tre int n,m,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(re int i=1;i<=m;i++)scanf(\"%d%d\",&x,&y),to[x].push_back(y),t[x].push_back(i);\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfr[I][I]=tg[I][I]=-1;\n\t\tfor(re int i=0;i<to[I].size();i++)if(!fr[I][to[I][i]])\n\t\t{\n\t\t\tfr[I][to[I][i]]=to[I][i];dfs(to[I][i],fr[I]);\n\t\t}\n\t\tfor(re int i=to[I].size()-1;i>=0;i--)if(!tg[I][to[I][i]])\n\t\t{\n\t\t\ttg[I][to[I][i]]=to[I][i];dfs(to[I][i],tg[I]);\n\t\t}\n\t}\n\tfor(I=1;I<=n;I++)\n\t{\n\t\tfor(re int i=0;i<to[I].size();i++)if(to[I][i]==I)ans[t[I][i]]=1;\n\t\telse{//printf(\"**%d %d %d\\n\",I,i->to,tg[I][i->to]);\n\t\t\tans[t[I][i]]=(fr[I][to[I][i]]==to[I][i]&&tg[I][to[I][i]]==to[I][i])==(fr[to[I][i]][I]==0);\n\t\t}\n\t}\n\tfor(re int i=1;i<=m;i++)puts(ans[i]?\"same\":\"diff\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<bitset>\nusing namespace std;\nconst int MAXN=1005;\nint n,m;\nint ex[MAXN],ey[MAXN];\nvector<int> ver[MAXN];\nbool ok[MAXN][MAXN];\nvoid dfs(int u,bool tag[]) {\n\ttag[u]=1;\n\tfor(int v:ver[u])\n\t\tif(!tag[v]) dfs(v,tag);\n}\nint a[MAXN][MAXN],b[MAXN][MAXN];\nvoid mak_tag(int u,int tag[],int id) {\n\ttag[u]=id;\n\tfor(int v:ver[u]) if(!tag[v])\n\t\tmak_tag(v,tag,id);\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,x,y;i<=m;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tver[x].push_back(y);\n\t\tex[i]=x,ey[i]=y;\n\t}\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tdfs(i,ok[i]);\n\tfor(int i=1;i<=n;i++) {\n\t\ta[i][i]=-1;\n\t\tfor(int j=0;j<(int)ver[i].size();j++)\n\t\t\tif(!a[i][ver[i][j]]) mak_tag(ver[i][j],a[i],j+1);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tb[i][i]=-1;\n\t\tfor(int j=ver[i].size()-1;~j;j--)\n\t\t\tif(!b[i][ver[i][j]]) mak_tag(ver[i][j],b[i],j+1);\n\t}\n\n\tfor(int i=1;i<=m;i++) {\n\t\tint x=ex[i],y=ey[i];\n\t\tputs((ok[y][x])^(a[x][y]!=b[x][y])?\"diff\":\"same\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define cri const register int\n#define re register\nusing namespace std;\nvector<int>to[1010];\nint n,m,a[200010],b[200010],fi[2][1010][1010];\nint V[1010],v[1010],X,now,dfn[1010],low[1010],bl[1010],sta[1010],top,num,dcc;\nvoid tj(cri x){\n\tsta[++top]=x;v[x]=1;\n\tdfn[x]=low[x]=++num;\n\tfor(int y:to[x]) if(!dfn[y])\n\t\ttj(y),low[x]=min(low[x],low[y]);\n\telse if(v[y]) low[x]=min(low[x],dfn[y]);\n\tif(low[x]==dfn[x]){\n\t\t++dcc;\n\t\twhile(sta[top]!=x) bl[sta[top]]=dcc,v[sta[top--]]=0;\n\t\tbl[sta[top]]=dcc;v[sta[top--]]=0;\n\t}\n}\nvoid dfs(cri x,cri opt,cri fr){\n\tif(V[x]==now) return;\n\tfi[opt][X][x]=fr;V[x]=now;\n\tfor(int y:to[x]) dfs(y,opt,fr);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) \n\t\tscanf(\"%d%d\",&a[i],&b[i]),to[a[i]].push_back(b[i]);\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) tj(i);//cout<<1<<endl;\n\tfor(int i=1;i<=n;i++){\n\t\tV[i]=++now;X=i;\n\t\tfor(int j=0;j<to[i].size();j++) dfs(to[i][j],0,to[i][j]);\n\t\tV[i]=++now;\n\t\tfor(int j=-1+to[i].size();~j;j--) dfs(to[i][j],1,to[i][j]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tcri x=a[i],y=b[i];\n\t\tif(bl[x]!=bl[y]&&fi[0][x][y]!=fi[1][x][y]) puts(\"diff\");\n\t\telse if(bl[x]==bl[y]&&fi[0][x][y]==y&&fi[1][x][y]==y) puts(\"diff\");\n\t\telse puts(\"same\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 1005\nusing namespace std;\nchar buf[30000005],*p1=buf-1;\nint read(){\n\tint w=0;char c=*(++p1);\n\twhile(!isdigit(c)) c=*(++p1);\n\twhile(isdigit(c)){w=(w<<3)+(w<<1)+c-'0';c=*(++p1);}\n\treturn w;\n}\nstruct edge{\n\tint k,next;\n}e[400005];\nstruct ed{\n\tint x,y;\n}E[200005];\nint n,m,home[N],cnt=-1,D,s[N],top,id[N],tot,dfn[N],mn[N],cc;\nbool ins[N],vis[N][N],temp[N];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid tarjan(int k){\n\tdfn[k]=mn[k]=++cc;s[++top]=k;\n\tins[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next){\n\t\tif(!dfn[e[i].k]){\n\t\t\ttarjan(e[i].k);\n\t\t\tmn[k]=min(mn[k],mn[e[i].k]);\n\t\t}\n\t\telse if(ins[e[i].k]) mn[k]=min(mn[k],mn[e[i].k]);\n\t}\n\tif(dfn[k]==mn[k]){\n\t\tid[k]=++tot;ins[k]=0;\n\t\twhile(s[top]!=k){\n\t\t\tid[s[top]]=tot;ins[s[top]]=0;\n\t\t\ttop--;\n\t\t}\n\t\ttop--;\n\t}\n}\nint q[1005];\nvoid bfs(int x){\n\tint tou=0,wei=1,k;q[0]=x;\n\tvis[D][D]=vis[D][x]=1;\n\twhile(tou<wei){\n\t\tk=q[tou++];\n\t\tfor(int i=home[k];~i;i=e[i].next) if(!vis[D][e[i].k])\n\t\t\tq[wei++]=e[i].k,vis[D][e[i].k]=1;\n\t}\n}\nint main(){\n\tfread(buf,1,sizeof(buf),stdin);\n\tmemset(home,-1,sizeof(home));\n\tn=read();m=read();\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tx=read();y=read();\n\t\tadd(x,y);\n\t\tE[i].x=x;E[i].y=y;\n\t}\n\tfor(int i=1;i<=n;i++) if(!dfn[i]) cc=0,tarjan(i);\n\tfor(int i=1;i<=n;i++){\n\t\tD=i;top=0;\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tif(vis[i][e[p].k]) continue;\n\t\t\ts[++top]=e[p].k;\n\t\t\tbfs(e[p].k);\n\t\t\tvis[i][e[p].k]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) temp[p]=vis[i][p];\n\t\tmemset(vis[i],0,sizeof(vis[i]));\n\t\tfor(int p=top;p>1;p--){\n\t\t\tif(vis[i][s[p]]) continue;\n\t\t\tbfs(s[p]);\n\t\t\tvis[i][s[p]]=0;\n\t\t}\n\t\tfor(int p=1;p<=n;p++) vis[i][p]|=temp[p];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x=E[i].x,y=E[i].y;\n\t\tif(id[x]==id[y]){\n\t\t\tif(!vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}else{\n\t\t\tif(vis[x][y]) puts(\"diff\");\n\t\t\telse puts(\"same\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1050\n#define maxm 205030\n#define x first\n#define y second\n\nusing namespace std;\ntypedef pair<int,int> pi;\nbool f[maxn][maxn],g[maxn][maxn],vis[maxn];\nint n,m;\nvector <int> h[maxn];\npi a[maxm];\n\nvoid dfs(int rt,int u,int o)\n{\n    if (o>0) vis[u]=true,f[rt][u]=true;\n    for (int i=0;i<h[u].size();i++)\n    {\n        int v=h[u][i];\n        if (!vis[v]) dfs(rt,v,o+1);\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=0;i<m;i++)\n    {\n        scanf(\"%d%d\",&a[i].x,&a[i].y);\n        h[a[i].x].push_back(a[i].y);\n    }\n    for (int i=1;i<=n;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        dfs(i,1,-1);\n        for (int j=1;j<=n;j++) g[i][j]=f[i][j],f[i][j]=false;\n        dfs(i,1,0);\n    }\n    for (int i=0;i<m;i++) if (f[a[i].y][a[i].x]^g[a[i].x][a[i].y]) printf(\"diff\\n\"); else printf(\"same\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> ii;\n\nconst int N = 1005;\n\nvector<int> graph[N];\n\nint n, m, l[N], r[N], cnt[N][N], vis[N][N];\n\nvoid dfs(int u, int p, int root, int mark) {\n    if(u == p || u == root) return ;\n    if(cnt[root][u] >= 2) return ;\n    if(vis[root][u] == mark) return ;\n    vis[root][u] = mark; cnt[root][u]++;\n    for(int i = 0; i < graph[u].size(); i++) {\n        int v = graph[u][i];\n        if(v == p) continue;\n        dfs(v, u, root, mark);\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> m;\n    for(int i = 1; i <= m; i++) {\n        cin >> l[i] >> r[i];\n        graph[l[i]].pb(r[i]);\n    }\n    for(int i = 1; i <= n; i++) {\n        for(int j = 0; j < graph[i].size(); j++) {\n            int v = graph[i][j];\n            dfs(v, i, i, v);\n        }\n    }\n    for(int i = 1; i <= m; i++) {\n        if(cnt[l[i]][r[i]] >= 2) {\n            if(cnt[r[i]][l[i]] == 0)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n        else {//1\n            if(cnt[r[i]][l[i]] >= 1)\n                cout << \"diff\\n\";\n            else\n                cout << \"same\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 5121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\n\nint x[210000];\nint y[210000];\nint ans[210000];\nint v[2100];\nvector<pair<int,int> >g[2100];\nvector<pair<int,int> >rev[2100];\nint L[2100];\nint R[2100];\nvoid dfs1(int a,int b){\n\tL[a]=b;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(~L[g[a][i].first])continue;\n\t\tdfs1(g[a][i].first,b);\n\t}\n}\nvoid dfs2(int a,int b){\n\tR[a]=b;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(~R[g[a][i].first])continue;\n\t\tdfs2(g[a][i].first,b);\n\t}\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tx[i]=p;\n\t\ty[i]=q;\n\t\tg[p].push_back(make_pair(q,i));\n\t\trev[q].push_back(make_pair(p,i));\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++)v[j]=0;\n\t\tv[i]=1;\n\t\tqueue<int>Q;\n\t\tQ.push(i);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor(int j=0;j<g[at].size();j++){\n\t\t\t\tint to=g[at][j].first;\n\t\t\t\tif(v[to])continue;\n\t\t\t\tv[to]=1;\n\t\t\t\tQ.push(to);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<rev[i].size();j++){\n\t\t\tif(v[rev[i][j].first])ans[rev[i][j].second]++;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tL[j]=R[j]=-1;\n\t\t}\n\t\tL[i]=R[i]=0;\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tif(L[g[i][j].first]==-1)dfs1(g[i][j].first,j);\n\t\t}\n\t\tfor(int j=g[i].size();j>0;j--){\n\t\t\tif(R[g[i][j-1].first]==-1)dfs2(g[i][j-1].first,j-1);\n\t\t}\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tif(L[g[i][j].first]!=j||R[g[i][j].first]!=j)ans[g[i][j].second]++;\n\t\t}\n\t}\n\tfor(int i=0;i<b;i++){\n\t\t// printf(\"%d \",ans[i]);\n\t\tif(ans[i]==1)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nvector<int>to[1010];\nbool A[1010][1010],B[1010][1010];\nvoid dfs1(int u,int o)\n{\n\tif(A[o][u])return ;\n\tA[o][u]=true;\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs1(to[u][i],o);\n\treturn ;\n}\nint book[1010];\nbool vis[1010];\nvoid dfs2(int u,int o,int s,bool ok=false)\n{\n\tif(vis[u])return ;\n\tvis[u]=true;\n\tif(!ok)book[u]=s;\n\telse B[o][u]=(s!=book[u]);\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs2(to[u][i],o,s,ok);\n\treturn ;\n}\nint U[200010],V[200010];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d %d\",&U[i],&V[i]);\n\t\tto[U[i]].push_back(V[i]);\n\t}\n\tfor(int i=1;i<=n;i++)dfs1(i,i);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmemset(book,0,sizeof(book));\n\t\tmemset(vis,0,sizeof(vis));vis[i]=true;\n\t\tint num=to[i].size();\n\t\tfor(int j=0;j<num;j++)\n\t\t\tdfs2(to[i][j],i,j);\n\t\tmemset(vis,0,sizeof(vis));vis[i]=true;\n\t\tfor(int j=num-1;j>=0;j--)\n\t\t\tdfs2(to[i][j],i,j,true);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(A[V[i]][U[i]]^B[U[i]][V[i]])printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1; \n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,x[200005],y[200005],book[1005];\nint top,nex[200005],to[200005],fir[1005];\nmap<int,int> mp[1005],mp2[1005];\ninline void lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\ninline void ss(int v,int w,int ww){\n\tbook[v]=i;\n\t//if(ww=1)\n\t//\tmp[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss(to[top1],w==0?top1:w,v==i?1:0);\n}\ninline void ss2(int v,int w,int ww){\n\tbook[v]=i;\n\t//if(ww=1)\n\t//\tmp2[i][v]=w;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(book[to[top1]]!=i)\n\t\t\tss2(to[top1],w==0?top1:w,v==i?1:0);\n}\nint main(){\n//\tfreopen(\"number.in\",\"r\",stdin);\n//\tfreopen(\"number.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(i=1;i<=m;i++){\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t\tlj(x[i],y[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tss(i,0,0);\n\tfor(i=1;i<=top;i++){\n\t\tnex[i]=0;\n\t\tto[i]=0;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tbook[i]=0;\n\t\tfir[i]=0;\n\t}\n\ttop=0;\n\tfor(i=m;i>=1;i--)\n\t\tlj(x[i],y[i]);\n\tfor(i=1;i<=n;i++)\n\t\tss2(i,0,0);\n\tfor(i=1;i<=m;i++){\n\t\tif((mp[y[i]][x[i]]!=0)+(mp[x[i]][y[i]]+mp2[x[i]][y[i]]==m+1)==1)\n\t\t\tprintf(\"same\\n\");\n\t\telse\n\t\t\tprintf(\"diff\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x); i<=(y); i++)\n#define per(i,x,y) for (int i=(x); i>=(y); i--)\n#define ll long long\n#define N 1005\n#define M 200005\nusing namespace std;\nll read(){\n\tchar ch=getchar(); ll x=0; int op=1;\n\tfor (; !isdigit(ch); ch=getchar()) if (ch=='-') op=-1;\n\tfor (; isdigit(ch); ch=getchar()) x=(x<<1)+(x<<1)+ch-'0';\n\treturn x*op;\n}\nint n,m,a[N][N],x[M],y[M],z[M],vis[N],p[N][N],q[N][N];\nvector<int> e[N];\nvoid dfs(int st,int u){\n\tvis[u]=1; a[st][u]=1;\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs(st,v);\n\t}\n}\nvoid dfs1(int st,int u,int id){\n\tvis[u]=1; p[st][u]=min(id,p[st][u]);\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs1(st,v,id);\n\t}\n}\nvoid dfs2(int st,int u,int id){\n\tvis[u]=1; q[st][u]=max(id,q[st][u]);\n\trep (i,0,(int)e[u].size()-1){\n\t\tint v=e[u][i]; if (!vis[v]) dfs2(st,v,id);\n\t}\n}\nint main(){\n\tn=read(); m=read();\n\trep (i,1,m){\n\t\tx[i]=read(),y[i]=read(); z[i]=(int)e[x[i]].size();\n\t\te[x[i]].push_back(y[i]);\n\t}\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(i,i);\n\t}\n\tmemset(p,0x3f,sizeof(p)); memset(q,0xc0,sizeof(q));\n\trep (i,1,n){\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\trep (j,0,(int)e[i].size()-1) if (!vis[e[i][j]]) dfs1(i,e[i][j],j);\n\t\tmemset(vis,0,sizeof(vis)); vis[i]=1;\n\t\tper (j,(int)e[i].size()-1,0) if (!vis[e[i][j]]) dfs2(i,e[i][j],j);\n\t}\n\t//printf(\"%d\\n\",a[3][1]);\n\t//printf(\"%d %d\\n\",p[1][3],q[1][3]);\n\t//printf(\"%d\\n\",a[4][3]);\n\t//printf(\"%d %d\\n\",p[3][4],q[3][4]);\n\trep (i,1,m){\n\t\tbool f1=a[y[i]][x[i]];\n\t\tbool f2=p[x[i]][y[i]]!=z[i] || q[x[i]][y[i]]!=z[i];\n\t\tif (f1==f2) puts(\"same\"); else puts(\"diff\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 1005;\nconst int M = 200005;\nbool not_necessary[N][N];\nvector<int> con[N];\nint a[M], b[M];\nint vis[N];\nint fe[N];\n\nstruct graph {\n  int n;\n  vector<vector<int>> adj;\n  graph(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst) {\n    adj[src].push_back(dst);\n  }\n\n  vector<vector<int>> strongly_connected_components() {\n    vector<vector<int>> scc;\n    vector<int> S, B, I(n);\n    function<void(int)> dfs = [&](int u) {\n      B.push_back(I[u] = S.size());\n      S.push_back(u);\n      for (int v: adj[u]) {\n        if (!I[v]) dfs(v);\n        else while (I[v] < B.back()) B.pop_back();\n      }\n      if (I[u] == B.back()) {\n        scc.push_back({});\n        B.pop_back();\n        for (; I[u] < S.size(); S.pop_back()) {\n          scc.back().push_back(S.back());\n          I[S.back()] = n + scc.size();\n        }\n      }\n    };\n    for (int u = 0; u < n; ++u)\n      if (!I[u]) dfs(u);\n    return scc; // I[u] - n is the index of u\n  }\n};\n\ntemplate<class T>\nstruct fixedSizeQueue{\n\tint n, L, R;\n\tT * arr;\n\tfixedSizeQueue(int n) : n(n){\n\t\tarr = new T[2 * n + 10];\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tvoid push_back(T x){\n\t\tarr[++R] = x; \n\t}\n\n\tvoid push_front(T x){\n\t\tarr[--L] = x;\n\t}\n\t\n\tT front(){\n\t\treturn arr[L];\n\t}\n\n\tT back(){\n\t\treturn arr[R];\n\t}\n\n\tT pop_front(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[L++];\n\t}\n\n\tT pop_back(){\n\t\tif(L > R){\n\t\t\tthrow runtime_error(\"empty queue access\");\n\t\t\treturn T();\n\t\t}\n\t\treturn arr[R--];\n\t}\n\n\tvoid re_init_indices(){\n\t\tL = n + 5;\n\t\tR = L - 1;\n\t}\n\n\tbool empty(){\n\t\treturn L > R;\n\t}\n};\nint main(){\n\tint n, m; sd(n); sd(m);\n\tgraph g(n + 1);\n\tfor(int i = 1; i <= m; i++){\n\t\tsd(a[i]);\n\t\tsd(b[i]);\n\t\tcon[a[i]].push_back(b[i]);\n\t\tg.add_edge(a[i], b[i]);\n\t}\n\tvector<vector<int>> comp = g.strongly_connected_components();\n\tvector<int> where(n + 1);\n\tfor(int i = 0; i < comp.size(); i++)\n\t\tfor(auto it : comp[i])\n\t\t\twhere[it] = i;\n\tfixedSizeQueue<pii> q(n);\n\tfor(int i = 1; i <= n; i++){\n\t\tq.re_init_indices();\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int v : con[i]){\n\t\t\tq.push_back({v, v});\n\t\t\tvis[v] = 1;\n\t\t\tfe[v] = v;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tauto it = q.pop_front();\n\t\t\tint u = it.F, firstEdge = it.S;\n\t\t\tfor(int v : con[u]){\n\t\t\t\tif(v == i || vis[v] >= 2) continue;\n\t\t\t\tif(vis[v] == 1 && firstEdge == fe[v]) continue;\n\t\t\t\tq.push_back({v, firstEdge});\n\t\t\t\tif(vis[v] == 0)\n\t\t\t\t\tfe[v] = firstEdge;\n\t\t\t\tvis[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int v : con[i]) if(vis[v] == 2){\n\t\t\tnot_necessary[i][v] = 1;\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\n\t\tprintf( (not_necessary[a[i]][b[i]] ^ (where[a[i]] != where[b[i]] )) ? \"same\\n\" : \"diff\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<vector<pair<int,int> > > graph;\n\n#define ALL(obj) (obj).begin(), (obj).end() \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n\nbool dfs_condition_1(graph g,vector<bool> &check,int now,int dest){\n    if(now==dest) return true;\n    check[now-1] = true;\n              cout << now << endl;\n    rep(i,g[now-1].size()){\n        if(!check[g[now-1][i].second-1]){ \n            if(dfs_condition_1(g, check,g[now-1][i].second,dest)) return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs_condition_2(graph g,vector<int> &check,int num, int now,int a){\n\n    if(check[now-1]==-1) check[now-1] = num;\n          \n    rep(i,g[now-1].size()){\n        if(g[now-1][i].second!=a && check[g[now-1][i].second-1]==-1) dfs_condition_2(g, check, num, g[now-1][i].second, a);\n\n    }\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<pair<pair<int,int>, int> > e(m);\n    rep(i,m){\n        int a,b; \n        cin >> a; \n        cin >> b; \n        e[i] = make_pair(make_pair(a,b), i);\n    }\n    graph g(n);\n    sort(ALL(e));\n    int j=0;\n    rep(i,n){\n        while(j<m && e[j].first.first==i+1){\n            g[i].push_back(e[j].first);\n            j++;\n        }\n    }\n   \n    vector<bool> cf(m), cs(m);\n     \n    rep(i,m){\n        vector<bool> check(n);\n        cf[e[i].second] = dfs_condition_1(g, check, e[i].first.second, e[i].first.first);\n    } \n \n    rep(i,n){\n        vector<int> cmax(n),cmin(n);\n        rep(k,n){cmax[k]=-1; cmin[k]=-1;}\n        rep(k,g[i].size()){\n            dfs_condition_2(g, cmin, k, g[i][k].second, i+1);\n        }\n\n        rep(k,g[i].size()){\n            dfs_condition_2(g, cmax, g[i].size() - k - 1, g[i][g[i].size() - k - 1].second, i+1);\n        }\n        rep(k,n) cout << cmax[k] << endl;\n        pair<pair<int,int>, int> pp = make_pair(make_pair(i + 1, 0), 0);\n        vector<pair<pair<int,int>, int> >::iterator itr = lower_bound(e.begin(), e.end(), pp);\n        rep(k,g[i].size()){\n           if(cmax[g[i][k].second-1]==k && cmin[g[i][k].second-1]==k) cs[(*itr++).second]=true;\n        }\n\n    }\n    //rep(i,m) if(cf[i]) cout << i+1 << \": cf true\" << endl;\n    //rep(i,m) if(cs[i]) cout << i+1 << \": cs true\" << endl;\n    rep(i,m){\n        if((cf[i]||cs[i])&&!(cf[i]&&cs[i])) cout << \"same\" << endl;\n        else cout << \"diff\" << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<set>\n#include<unordered_map>\n#include<vector>\ntypedef long long ll;\nusing namespace std;\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define N 1010\n#define M 200010\nvector<int>G[N];\nint a[M],b[M],vis[2][N][N];\nvoid dfs(int mod,int a,int b,int col){\n\tif(vis[mod][a][b])return;\n\tvis[mod][a][b]=col;\n\tfor(auto q:G[b])dfs(mod,a,q,col);\n}\nint main(){\n\tint i,j,n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].pb(b[i]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tvis[0][i][i]=vis[1][i][i]=1;\n\t\tfor(j=0;j<G[i].size();j++)dfs(0,i,G[i][j],j+1);\n\t\tfor(j=G[i].size()-1;j>=0;j--)dfs(1,i,G[i][j],j+1);\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tint x=(vis[0][a[i]][b[i]]!=vis[1][a[i]][b[i]]);\n\t\tint y=vis[0][b[i]][a[i]]!=0;\n\t\tif(x^y)printf(\"diff\\n\");\n\t\telse printf(\"same\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 1000;\nconst int MAXM = 200000;\n\nvector<int>G[MAXN + 5]; int to[MAXM + 5];\nvoid addedge(int u, int i) {G[u].push_back(i);}\n\nint tag[MAXN + 5], que[2*MAXN + 5];\nbool ans1[MAXM + 5], ans2[MAXM + 5];\n\nint n, m;\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1;i<=m;i++) {\n\t\tint a; scanf(\"%d%d\", &a, &to[i]);\n\t\taddedge(a, i);\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) tag[j] = 0;\n\t\tint s = 1, t = 0;\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\ttag[que[++t] = to[G[i][p]]] = G[i][p];\n\t\twhile(s<=t) {\n\t\t\tint x = que[s++], y = tag[x];\n\t\t\tfor(int p=0;p<G[x].size();p++) {\n\t\t\t\tint q = to[G[x][p]];\n\t\t\t\tif( q != i ) {\n\t\t\t\t\tif( tag[q] != -1 ) {\n\t\t\t\t\t\tif( tag[q] == 0 )\n\t\t\t\t\t\t\ttag[que[++t] = q] = y;\n\t\t\t\t\t\telse if( tag[q] != y )\n\t\t\t\t\t\t\ttag[que[++t] = q] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse ans1[G[x][p]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int p=0;p<G[i].size();p++)\n\t\t\tif( tag[to[G[i][p]]] == -1 ) ans2[G[i][p]] = 1;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tputs(ans1[i] ^ ans2[i] ? \"diff\" : \"same\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\nostream& operator<<(ostream& os, const pair<char, int>& unit) {\n  return os << unit.first << \"^\" << unit.second;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 1010, M = 200010;\n\nint n, m;\nbool vis[N];\nvector<pair<int, int>> g[N], ig[N];\n\nbool ans[M];\n\nvoid reachable(int u) {\n  vis[u] = true;\n  for (const auto& pr : g[u])\n    if (!vis[pr.first])\n      reachable(pr.first);\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m;\n  for (int i = 1; i <= m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u].emplace_back(v, i);\n    ig[v].emplace_back(u, i);\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    for (int rep = 0; rep < 2; ++rep) {\n      memset(vis, 0, sizeof(vis));\n      vis[i] = true;\n      for (const auto &pr : g[i])\n        if (vis[pr.first])\n          ans[pr.second] = true;\n        else\n          reachable(pr.first);\n      reverse(g[i].begin(), g[i].end());\n    }\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    memset(vis, 0, sizeof(vis));\n    reachable(i);\n    for (const auto& pr : ig[i]) {\n      int j, id;\n      tie(j, id) = pr;\n      ans[id] ^= vis[j];\n    }\n  }\n  for (int i = 1; i <= m; ++i)\n    cout << (ans[i] ? \"diff\\n\" : \"same\\n\");\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n      -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 1005;\nconst int   M   = 2e5 + 5;\n\ntypedef pair<int,int>   ii;\n\nbool ans[M];\nbool vis[N];\n\nvector<ii>  fr[N];\nvector<ii>  to[N];\n\nvoid dfs(int u,int forbid)  {\n    if(!vis[u]) {\n        vis[u] = 1;\n\n        for(ii  e : fr[u])  if (e.X != forbid)\n            dfs(e.X,forbid);\n    }\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int m;  cin >> m;\n\n    for(int i = 0 ; i < m ; ++i)    {\n        int x;  cin >> x;\n        int y;  cin >> y;\n        \n        fr[x].pb(y,i);\n        to[y].pb(x,i);\n    }\n    for(int u = 1 ; u <= n ; ++u)   {\n        fill(vis + 1,vis + 1 + n,0);    for(ii  e : fr[u])  ans[e.Y] |= vis[e.X],   dfs(e.X,u);     reverse(all(fr[u]));\n        fill(vis + 1,vis + 1 + n,0);    for(ii  e : fr[u])  ans[e.Y] |= vis[e.X],   dfs(e.X,u);\n    }\n    for(int u = 1 ; u <= n ; ++u)   {\n        fill(vis + 1,vis + 1 + n,0);\n\n        dfs(u,0);\n\n        for(ii  e : to[u])\n            ans[e.Y] ^= vis[e.X];\n    }\n    for(int i = 0 ; i < m ; ++i)    {\n        if (ans[i]) cout << \"diff\\n\";\n        else        cout << \"same\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <bitset>\n#include <iostream>\nusing namespace std;\nconst int N=1010,M=200010;\nint n,m;\nnamespace G{\n\tint h1[N],h2[N],tot;\n\tint g1sum[N][N],g2sum[N][N];\n\tstruct Edge{\n\t\tint v,next;\n\t}e[M*2];\n\tint oriCnt,oriEdge[M][2];\n\tvoid addEdge(int u,int v,int *h=h1){\n\t\te[++tot]=(Edge){v,h[u]}; h[u]=tot;\n\t\tif(h==h1){\n\t\t\toriCnt++;\n\t\t\toriEdge[oriCnt][0]=u;\n\t\t\toriEdge[oriCnt][1]=v;\n\t\t\tg1sum[u][v]++;\n\t\t}\n\t\telse\n\t\t\tg2sum[u][v]++;\n\t}\n\tint dfn[N],low[N],dfnTimer;\n\tint bcnt,bel[N];\n\tvoid TarjanDfs(int u){\n\t\tstatic int sta[N],top=0;\n\t\tstatic bool inStack[N];\n\t\tdfn[u]=low[u]=++dfnTimer;\n\t\tsta[++top]=u;\n\t\tinStack[u]=true;\n\t\tfor(int i=h1[u],v;i;i=e[i].next){\n\t\t\tv=e[i].v;\n\t\t\tif(!dfn[v]){\n\t\t\t\tTarjanDfs(v);\n\t\t\t\tlow[u]=min(low[u],low[v]);\n\t\t\t}\n\t\t\telse if(inStack[v])\n\t\t\t\tlow[u]=min(low[u],dfn[v]);\n\t\t}\n\t\tif(dfn[u]==low[u]){\n\t\t\tbcnt++;\n\t\t\tint x;\n\t\t\tdo{\n\t\t\t\tx=sta[top--];\n\t\t\t\tinStack[x]=false;\n\t\t\t\tbel[x]=bcnt;\n\t\t\t}while(x!=u);\n\t\t}\n\t}\n\tvoid Tarjan(){\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!dfn[i])\n\t\t\t\tTarjanDfs(i);\n\t}\n\tvoid buildGraph(){\n\t\tfor(int i=1;i<=oriCnt;i++){\n\t\t\tint u=oriEdge[i][0],v=oriEdge[i][1];\n\t\t\tif(bel[u]!=bel[v])\n\t\t\t\taddEdge(bel[u],bel[v],h2);\n\t\t}\n\t}\n\tint recMin[N][N],recMax[N][N];\n\tvoid dfs(int u,int rt,int st,int *arr){\n\t\tif(arr[u])\n\t\t\treturn;\n\t\tarr[u]=st;\n\t\tfor(int i=h1[u],v;i;i=e[i].next)\n\t\t\tif((v=e[i].v)!=rt)\n\t\t\t\tdfs(v,rt,st,arr);\n\t}\n\tvoid calc(){\n\t\tfor(int u=1;u<=n;u++){\n\t\t\tfor(int v=1;v<=n;v++)\n\t\t\t\tif(g1sum[u][v])\n\t\t\t\t\tdfs(v,u,v,recMin[u]);\n\t\t\tfor(int v=n;v>=1;v--)\n\t\t\t\tif(g1sum[u][v])\n\t\t\t\t\tdfs(v,u,v,recMax[u]);\n\t\t}\n\t}\n\tbool existAnother(int u,int v){\n\t\treturn recMin[u][v]!=v||recMax[u][v]!=v;\n\t}\n\tbool judgeEdge(int u,int v){\n\t\tif(bel[u]==bel[v]){\n\t\t\tif(g1sum[u][v]>1)\n\t\t\t\treturn false;\n\t\t\treturn !existAnother(u,v);\n\t\t}\n\t\telse{\n\t\t\tif(g1sum[u][v]>1||g2sum[bel[u]][bel[v]]>1)\n\t\t\t\treturn true;\n\t\t\treturn existAnother(u,v);\n\t\t}\n\t}\n}\nvoid readData(){\n\tscanf(\"%d%d\",&n,&m);\n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG::addEdge(u,v);\n\t}\n}\nvoid solve(){\n\tfor(int i=1;i<=m;i++){\n\t\tint u=G::oriEdge[i][0],v=G::oriEdge[i][1];\n\t\tputs(G::judgeEdge(u,v)?\"diff\":\"same\");\n\t}\n}\nint main(){\n\treadData();\n\tG::Tarjan();\n\tG::buildGraph();\n\tG::calc();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1010\n#define M 200200\nusing namespace std;\n\nint n, m;\nint tot, fir[N], nxt[M], to[M];\n\nvoid addE(int u, int v) {\n    nxt[++tot] = fir[u], fir[u] = tot, to[tot] = v;\n}\n\nvoid dfs(int u, int mk, int *vis) {\n    vis[u] = mk;\n    for (int i = fir[u], v; i; i = nxt[i]) {\n        v = to[i];\n        if (vis[v]) continue;\n        dfs(v, mk, vis);\n    }\n}\n\nint vis[N][N], lch[N], rch[N], ans[N], stk[N], top;\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n    \n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; ++i)\n        scanf(\"%d%d\", &u, &v), addE(u, v);\n\n    for (int i = 1; i <= n; ++i)\n        dfs(i, 1, vis[i]);\n\n    for (int u = 1; u <= n; ++u) {\n        memset(lch, 0, sizeof lch);\n        memset(rch, 0, sizeof rch);\n        top = 0;\n        for (int i = fir[u]; i; i = nxt[i])\n            stk[++top] = to[i];\n        for (int i = top, v; i >= 1; --i)\n            if (!lch[v = stk[i]]) lch[u] = i, dfs(v, i, lch);\n        for (int i = 1, v; i <= top; ++i)\n            if (!rch[v = stk[i]]) rch[u] = i, dfs(v, i, rch);\n        for (int i = fir[u], v; i; i = nxt[i]) {\n            v = to[i];\n            if (vis[v][u] == (lch[v] != rch[v]))\n                ans[i] = 1;\n        }\n    }\n    \n    for (int i = 1; i <= m; ++i)\n        puts(ans[i] ? \"same\" : \"diff\");\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N\t1000\n#define M\t200000\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint oo[1 + M * 3], oh[1 + M * 3];\n\nint link(int o, int h) {\n\tstatic int _ = 1;\n\n\too[_] = o, oh[_] = h;\n\treturn _++;\n}\n\nint ii[M], jj[M];\nint ae[N], af[N], ae_[N], cc[N], qu[N], cnt;\n\nvoid dfs1(int i) {\n\tint o;\n\n\tif (cc[i])\n\t\treturn;\n\tcc[i] = -1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tdfs1(j);\n\t}\n\tqu[--cnt] = i;\n}\n\nvoid dfs2(int j, int c) {\n\tint o;\n\n\tif (cc[j] != -1)\n\t\treturn;\n\tcc[j] = c;\n\tfor (o = af[j]; o; o = oo[o]) {\n\t\tint h = oh[o], i = ii[h];\n\n\t\tdfs2(i, c);\n\t}\n}\n\nchar visited[N]; int c;\nint hh[N * 2], cnt_;\n\nvoid dfs3(int i) {\n\tint o;\n\n\tvisited[i] = 1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tif (!visited[j] && cc[j] == c)\n\t\t\thh[cnt_++] = h, dfs3(j);\n\t}\n}\n\nvoid dfs4(int j) {\n\tint o;\n\n\tvisited[j] = 2;\n\tfor (o = af[j]; o; o = oo[o]) {\n\t\tint h = oh[o], i = ii[h];\n\n\t\tif (visited[i] == 1 && cc[i] == c)\n\t\t\thh[cnt_++] = h, dfs4(i);\n\t}\n}\n\nint h_;\n\nint dfs5(int i, int t) {\n\tint o;\n\n\tif (i == t)\n\t\treturn 1;\n\tif (visited[i])\n\t\treturn 0;\n\tvisited[i] = 1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tif (h != h_ && dfs5(j, t))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tstatic int dd[N];\n\tstatic char diff[M];\n\tint n, n_, m, g, g_, h, i, j, s;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (h = 0; h < m; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tii[h] = i, jj[h] = j;\n\t\tae[i] = link(ae[i], h);\n\t\taf[j] = link(af[j], h);\n\t}\n\tcnt = n;\n\tfor (i = 0; i < n; i++)\n\t\tif (!cc[i])\n\t\t\tdfs1(i);\n\tn_ = 0;\n\tfor (g = 0; g < n; g++) {\n\t\ti = qu[g];\n\t\tif (cc[i] == -1)\n\t\t\tdfs2(i, n_++);\n\t}\n\tfor (h = 0; h < m; h++) {\n\t\ti = cc[ii[h]], j = cc[jj[h]];\n\t\tif (i != j)\n\t\t\tae_[i] = link(ae_[i], h);\n\t}\n\tfor (s = 0; s < n_; s++) {\n\t\tint o;\n\n\t\tmemset(dd, 0, n_ * sizeof *dd);\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tdd[j]++;\n\t\t}\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tif (dd[j] > 1)\n\t\t\t\tdiff[h] = 1;\n\t\t}\n\t\tmemset(dd, -1, n_ * sizeof *dd), dd[s] = 0;\n\t\tfor (i = s; i < n_; i++)\n\t\t\tif (dd[i] != -1)\n\t\t\t\tfor (o = ae_[i]; o; o = oo[o]) {\n\t\t\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\t\t\tdd[j] = max(dd[j], dd[i] + 1);\n\t\t\t\t}\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tif (dd[j] > 1)\n\t\t\t\tdiff[h] = 1;\n\t\t}\n\t}\n\tfor (c = 0; c < n_; c++) {\n\t\tcnt = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tif (cc[i] == c)\n\t\t\t\tqu[cnt++] = i;\n\t\tcnt_ = 0;\n\t\tdfs3(qu[0]);\n\t\tdfs4(qu[0]);\n\t\tfor (g_ = 0; g_ < cnt_; g_++) {\n\t\t\th = hh[g_];\n\t\t\tfor (g = 0; g < cnt; g++)\n\t\t\t\tvisited[qu[g]] = 0;\n\t\t\th_ = h;\n\t\t\tdiff[h] = !dfs5(ii[h], jj[h]);\n\t\t}\n\t}\n\tfor (h = 0; h < m; h++)\n\t\tprintf(diff[h] ? \"diff\\n\" : \"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N\t1000\n#define M\t200000\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint oo[1 + M * 3], oh[1 + M * 3];\n\nint link(int o, int h) {\n\tstatic int _ = 1;\n\n\too[_] = o, oh[_] = h;\n\treturn _++;\n}\n\nint ii[M], jj[M];\nint ae[N], af[N], ae_[N], cc[N], qu[N], cnt;\n\nvoid dfs1(int i) {\n\tint o;\n\n\tif (cc[i])\n\t\treturn;\n\tcc[i] = -1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tdfs1(j);\n\t}\n\tqu[--cnt] = i;\n}\n\nvoid dfs2(int j, int c) {\n\tint o;\n\n\tif (cc[j] != -1)\n\t\treturn;\n\tcc[j] = c;\n\tfor (o = af[j]; o; o = oo[o]) {\n\t\tint h = oh[o], i = ii[h];\n\n\t\tdfs2(i, c);\n\t}\n}\n\nint dd[N];\n\nvoid dfs3(int i) {\n\tint o;\n\n\tdd[i] = -1;\n\tqu[cnt++] = i;\n\tfor (o = ae_[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = cc[jj[h]];\n\n\t\tif (--dd[j] == 0)\n\t\t\tdfs3(j);\n\t}\n}\n\nchar visited[N]; int c;\nint hh[M], cnt_;\n\nvoid dfs4(int i) {\n\tint o;\n\n\tvisited[i] = 1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tif (!visited[j] && cc[j] == c)\n\t\t\thh[cnt_++] = h, dfs4(j);\n\t}\n}\n\nvoid dfs5(int j) {\n\tint o;\n\n\tvisited[j] = 2;\n\tfor (o = af[j]; o; o = oo[o]) {\n\t\tint h = oh[o], i = ii[h];\n\n\t\tif (visited[i] == 1 && cc[i] == c)\n\t\t\thh[cnt_++] = h, dfs5(i);\n\t}\n}\n\nint h_;\n\nint dfs6(int i, int t) {\n\tint o;\n\n\tif (i == t)\n\t\treturn 1;\n\tif (visited[i])\n\t\treturn 0;\n\tvisited[i] = 1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tif (h != h_ && dfs6(j, t))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tstatic char diff[M];\n\tint n, n_, m, g, g_, h, i, j;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (h = 0; h < m; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tii[h] = i, jj[h] = j;\n\t\tae[i] = link(ae[i], h);\n\t\taf[j] = link(af[j], h);\n\t}\n\tcnt = n;\n\tfor (i = 0; i < n; i++)\n\t\tif (!cc[i])\n\t\t\tdfs1(i);\n\tn_ = 0;\n\tfor (g = 0; g < n; g++) {\n\t\ti = qu[g];\n\t\tif (cc[i] == -1)\n\t\t\tdfs2(i, n_++);\n\t}\n\tfor (h = 0; h < m; h++) {\n\t\ti = cc[ii[h]], j = cc[jj[h]];\n\t\tif (i != j)\n\t\t\tae_[i] = link(ae_[i], h), dd[j]++;\n\t}\n\tcnt = 0;\n\tfor (i = 0; i < n_; i++)\n\t\tif (dd[i] == 0)\n\t\t\tdfs3(i);\n\tfor (g = 0; g < cnt; g++) {\n\t\tint s = qu[g], o;\n\n\t\tmemset(dd, 0, n_ * sizeof *dd);\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tdd[j]++;\n\t\t}\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tif (dd[j] > 1)\n\t\t\t\tdiff[h] = 1;\n\t\t}\n\t\tmemset(dd, -1, n_ * sizeof *dd);\n\t\tdd[s] = 0;\n\t\tfor (g_ = g; g_ < cnt; g_++) {\n\t\t\ti = qu[g_];\n\t\t\tif (dd[i] != -1)\n\t\t\t\tfor (o = ae_[i]; o; o = oo[o]) {\n\t\t\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\t\t\tdd[j] = max(dd[j], dd[i] + 1);\n\t\t\t\t}\n\t\t}\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tif (dd[j] > 1)\n\t\t\t\tdiff[h] = 1;\n\t\t}\n\t}\n\tfor (c = 0; c < n_; c++) {\n\t\tcnt = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tif (cc[i] == c)\n\t\t\t\tqu[cnt++] = i;\n\t\tcnt_ = 0;\n\t\tdfs4(qu[0]);\n\t\tdfs5(qu[0]);\n\t\tfor (g_ = 0; g_ < cnt_; g_++) {\n\t\t\th = hh[g_];\n\t\t\tfor (g = 0; g < cnt; g++)\n\t\t\t\tvisited[qu[g]] = 0;\n\t\t\th_ = h;\n\t\t\tdiff[h] = !dfs6(ii[h], jj[h]);\n\t\t}\n\t}\n\tfor (h = 0; h < m; h++)\n\t\tprintf(diff[h] ? \"diff\\n\" : \"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\null c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\nhwll g[N_MAX];\nhwll invg[N_MAX];\n\null gin[N_MAX];\n\nsll iswatched[2000][2000];\nvoid dfs (ull v, ull x, ull y) {\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = g[i].b;\n\t\tif (u == x) continue;\n\t\tif (iswatched[x][u] == n) continue;\n\t\tif (iswatched[x][u] == y) continue;\n\n\t\tif (iswatched[x][u] >= 0) {\n\t\t\tiswatched[x][u] = n;\n\t\t} else {\n\t\t\tiswatched[x][u] = y;\n\t\t}\n\t\tdfs(u, x, y);\n\t}\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < m; i++) {\n\t\tg[i] = (hwll){a[i], b[i]};\n\t\tinvg[i] = (hwll){b[i], a[i]};\n\t}\n\tqsort(g, m, sizeof(hwll), phwllABcomp);\n\tqsort(invg, m, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < m && g[j].a == i) j++;\n\t\ti++;\n\t}\n\n\t// for (i = 0; i < m; i++) {\n\t// \tprintf(\"%llu-%llu\\n\", g[i].a, g[i].b);\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tiswatched[i][j] = -1;\n\t\t}\n\n\t\tfor (j = gin[i]; j < gin[i + 1]; j++) {\n\t\t\tull u = g[j].b;\n\t\t\tif (iswatched[i][u] >= 0) {\n\t\t\t\tiswatched[i][u] = n;\n\t\t\t} else {\n\t\t\t\tiswatched[i][u] = u;\n\t\t\t}\n\t\t\tdfs(u, i, u);\n\n\t\t\t// printf(\"%llu-%llu: \", i, u);\n\t\t\t// for (ki = 0; ki < n; ki++) {\n\t\t\t// \tprintf(\"%lld \", iswatched[i][ki]);\n\t\t\t// }\n\t\t\t// puts(\"\");\n\t\t}\n\t}\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tprintf(\"%lld \", iswatched[i][j]);\n\t// \t}\n\t// \tputs(\"\");\n\t// }\n\n\tfor (i = 0; i < m; i++) {\n\t\tull isrev = ((iswatched[b[i]][a[i]] >= 0) ? 1 : 0);\n\t\tull iscon = ((iswatched[a[i]][b[i]] == n) ? 1 : 0);\n\t\tputs((isrev ^ iscon) ? \"diff\" : \"same\");\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < m; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &c[i]);\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \txy[i].a--;\n\t// \txy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N\t1000\n#define M\t200000\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint oo[1 + M * 3], oh[1 + M * 3];\n\nint link(int o, int h) {\n\tstatic int _ = 1;\n\n\too[_] = o, oh[_] = h;\n\treturn _++;\n}\n\nint ii[M], jj[M];\nint ae[N], af[N], ae_[N], cc[N], qu[N], cnt;\n\nvoid dfs1(int i) {\n\tint o;\n\n\tif (cc[i])\n\t\treturn;\n\tcc[i] = -1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tdfs1(j);\n\t}\n\tqu[--cnt] = i;\n}\n\nvoid dfs2(int j, int c) {\n\tint o;\n\n\tif (cc[j] != -1)\n\t\treturn;\n\tcc[j] = c;\n\tfor (o = af[j]; o; o = oo[o]) {\n\t\tint h = oh[o], i = ii[h];\n\n\t\tdfs2(i, c);\n\t}\n}\n\nchar visited[N]; int c;\nint hh[N * 2], cnt_;\n\nvoid dfs3(int i) {\n\tint o;\n\n\tvisited[i] = 1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tif (!visited[j] && cc[j] == c)\n\t\t\thh[cnt_++] = h, dfs3(j);\n\t}\n}\n\nvoid dfs4(int j) {\n\tint o;\n\n\tvisited[j] = 2;\n\tfor (o = af[j]; o; o = oo[o]) {\n\t\tint h = oh[o], i = ii[h];\n\n\t\tif (visited[i] == 1 && cc[i] == c)\n\t\t\thh[cnt_++] = h, dfs4(i);\n\t}\n}\n\nint h_;\n\nint dfs5(int i, int t) {\n\tint o;\n\n\tif (i == t)\n\t\treturn 1;\n\tif (visited[i])\n\t\treturn 0;\n\tvisited[i] = 1;\n\tfor (o = ae[i]; o; o = oo[o]) {\n\t\tint h = oh[o], j = jj[h];\n\n\t\tif (h != h_ && cc[j] == c && dfs5(j, t))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tstatic int dd[N];\n\tstatic char diff[M];\n\tint n, n_, m, g, g_, h, i, j, s;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (h = 0; h < m; h++) {\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tii[h] = i, jj[h] = j;\n\t\tae[i] = link(ae[i], h);\n\t\taf[j] = link(af[j], h);\n\t}\n\tcnt = n;\n\tfor (i = 0; i < n; i++)\n\t\tif (!cc[i])\n\t\t\tdfs1(i);\n\tn_ = 0;\n\tfor (g = 0; g < n; g++) {\n\t\ti = qu[g];\n\t\tif (cc[i] == -1)\n\t\t\tdfs2(i, n_++);\n\t}\n\tfor (h = 0; h < m; h++) {\n\t\ti = cc[ii[h]], j = cc[jj[h]];\n\t\tif (i != j)\n\t\t\tae_[i] = link(ae_[i], h);\n\t}\n\tfor (s = 0; s < n_; s++) {\n\t\tint o;\n\n\t\tmemset(dd, 0, n_ * sizeof *dd);\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tdd[j]++;\n\t\t}\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tif (dd[j] > 1)\n\t\t\t\tdiff[h] = 1;\n\t\t}\n\t\tmemset(dd, -1, n_ * sizeof *dd), dd[s] = 0;\n\t\tfor (i = s; i < n_; i++)\n\t\t\tif (dd[i] != -1)\n\t\t\t\tfor (o = ae_[i]; o; o = oo[o]) {\n\t\t\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\t\t\tdd[j] = max(dd[j], dd[i] + 1);\n\t\t\t\t}\n\t\tfor (o = ae_[s]; o; o = oo[o]) {\n\t\t\th = oh[o], j = cc[jj[h]];\n\t\t\tif (dd[j] > 1)\n\t\t\t\tdiff[h] = 1;\n\t\t}\n\t}\n\tfor (c = 0; c < n_; c++) {\n\t\tcnt = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tif (cc[i] == c)\n\t\t\t\tqu[cnt++] = i;\n\t\tcnt_ = 0;\n\t\tdfs3(qu[0]);\n\t\tdfs4(qu[0]);\n\t\tfor (g_ = 0; g_ < cnt_; g_++) {\n\t\t\th = hh[g_];\n\t\t\tfor (g = 0; g < cnt; g++)\n\t\t\t\tvisited[qu[g]] = 0;\n\t\t\th_ = h;\n\t\t\tdiff[h] = !dfs5(ii[h], jj[h]);\n\t\t}\n\t}\n\tfor (h = 0; h < m; h++)\n\t\tprintf(diff[h] ? \"diff\\n\" : \"same\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 100000000\n#define MOD 1000000007\n#define PI 3.14159265359\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint mp[1111][1111];\n\nint main()\n{\n\tint n,m;cin >> n >> m;\n\tvector<P> v;\n\tREP(i,n)REP(j,n)mp[i][j] = INF;\n\tREP(i,n)mp[i][i] = 0;\n\tREP(i,m){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv.PB(MP(a,b));\n\t\tmp[a][b] = 1;\n\t}\n\t\n\t\n\tREP(k,n)REP(i,n)REP(j,n){\n\t\tmp[i][j] = min(mp[i][j],mp[i][k] + mp[k][j]);\n\t}\n\t\n\tREP(i,m){\n\t\tint a = v[i].FI;\n\t\tint b = v[i].SE;\n\t\tint ab = 1;\n\t\tint ba = INF;\n\t\tREP(j,n){\n\t\t\tif(mp[a][j]+mp[j][b] < INF && mp[a][j] != mp[a][b] + mp[b][j] && mp[j][b] != mp[j][a] + mp[a][b])ab = max(ab,mp[a][j]+mp[j][b]);\n\t\t\tif((j == a || j == b) || mp[b][j] != mp[b][a] + mp[a][j] && mp[j][a] != mp[j][b] + mp[b][a])ba = min(ba,mp[b][j]+mp[j][a]);\n\t\t}\n\t\t//cout << ab << ' ' << ba << endl;\n\t\tif((ab > 1 && ba == INF) || (ab == 1 && ba < INF)){\n\t\t\tcout << \"diff\" << '\\n';\n\t\t}\n\t\telse{\n\t\t\tcout << \"same\" << '\\n';\n\t\t}\n\t}\n\t\t\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint N;\n\tint M;\n\tint[] a;\n\tint[] b;\n\tArrayList<Integer>[] g;\n\tboolean[][] go;\n\tint[][] ref;\n\n\tvoid dfs(int cur, int ori) {\n\t\tgo[ori][cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!go[ori][dst])\n\t\t\t\tdfs(dst, ori);\n\t\t}\n\t}\n\n\tvoid paint_min(int cur, int ori, int col, int[] min) {\n\t\tif (min[cur] > col)\n\t\t\tmin[cur] = col;\n\t\telse\n\t\t\treturn;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == ori)\n\t\t\t\tcontinue;\n\t\t\tpaint_min(dst, ori, col, min);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\ta = new int[M];\n\t\tb = new int[M];\n\t\tg = new ArrayList[N];\n\t\tref = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\tref[i][j] = -1;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\t//N<=10^3\n\t\t//M<=2*10^5\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tref[a[i]][b[i]] = i;\n\t\t}\n\t\tgo = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tdfs(i, i);\n\t\tboolean[][] go2 = new boolean[N][N];\n\t\tint[] a = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(a, g[i].size());\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tpaint_min(g[i].get(j), i, j, a);\n\t\t\t}\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tif (a[g[i].get(j)] != j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(a, g[i].size());\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tpaint_min(g[i].get(j), i, g[i].size() - 1 - j, a);\n\t\t\t}\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tif (a[g[i].get(j)] != g[i].size() - 1 - j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (!go[b[i]][a[i]] && !go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else if (go[b[i]][a[i]] && go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"diff\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tint N;\n\tint M;\n\tint[] a;\n\tint[] b;\n\tArrayList<Integer>[] g;\n\tboolean[][] go;\n\tint[][] ref;\n\n\tvoid dfs(int cur, int ori) {\n\t\tgo[ori][cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!go[ori][dst])\n\t\t\t\tdfs(dst, ori);\n\t\t}\n\t}\n\n\tvoid paint_min(int cur, int ori, int col, int[] min) {\n\t\tif (min[cur] > col)\n\t\t\tmin[cur] = col;\n\t\telse\n\t\t\treturn;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == ori)\n\t\t\t\tcontinue;\n\t\t\tpaint_min(dst, ori, col, min);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\ta = new int[M];\n\t\tb = new int[M];\n\t\tg = new ArrayList[N];\n\t\tref = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\tref[i][j] = -1;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\t//N<=10^3\n\t\t//M<=2*10^5\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tref[a[i]][b[i]] = i;\n\t\t}\n\t\tgo = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tdfs(i, i);\n\t\tboolean[][] go2 = new boolean[N][N];\n\t\tint[] tmp = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(tmp, g[i].size());\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tpaint_min(g[i].get(j), i, j, tmp);\n\t\t\t}\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tif (tmp[g[i].get(j)] != j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(tmp, g[i].size());\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tpaint_min(g[i].get(j), i, g[i].size() - 1 - j, tmp);\n\t\t\t}\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tif (tmp[g[i].get(j)] != g[i].size() - 1 - j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (!go[b[i]][a[i]] && !go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else if (go[b[i]][a[i]] && go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"diff\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*;\n\nclass SCC{\n\tList<Integer>[] edges;\n\tList<Integer>[] redges;\n\tboolean[] used;\n\tint[] comp;\n\tint comp_num=0;\n\tint n;\n\n\tList<Integer>[] scc_edges;\n\tList<Integer> sorted_comp;\n\t// 最後尾までの最大距離\n\tint[] rank;\n\tSet<Integer>[] dab;\n\n\tSCC(int n){\n\t\tthis.n=n;\n\t\tedges = new ArrayList[n];\n\t\tredges=new ArrayList[n];\n\t\tcomp = new int[n];\n\t\tused=new boolean[n];\n\t\tfor(int i=0;i<n;++i)edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n;++i)redges[i]=new ArrayList<>();\n\t\tArrays.fill(comp, -1);\n\t}\n\tvoid add_edges(int u, int v){\n\t\tedges[u].add(v);\n\t\tredges[v].add(u);\n\t}\n\tvoid scc(){\n\t\tDeque<Integer> visit = new ArrayDeque<>();\n\t\tArrays.fill(used, false);\n\t\tfor(int i=0;i<n;++i)if(!used[i])dfs1(i, visit);\n\t\twhile(!visit.isEmpty()){\n\t\t\tint v = visit.pollLast();\n\t\t\tif(comp[v]>=0)continue;\n\t\t\tdfs2(v);\n\t\t\tcomp_num++;\n\t\t}\n\t}\n\n\tvoid topoSort(){\n\t\tSet<Integer>[] ed = new Set[n];\n\t\tfor(int i=0;i<n;++i)ed[i] = new HashSet<>();\n\n\t\tdab = new Set[n];\n\t\tfor(int i=0;i<n;++i)dab[i] = new HashSet<>();\n\n\t\tfor(int i=0;i<n;++i)for(int u: edges[i]){\n\t\t\tif(comp[i]!=comp[u]){\n\t\t\t\tif(!ed[comp[i]].add(comp[u]))dab[comp[i]].add(comp[u]);\n\t\t\t}\n\t\t}\n\t\tscc_edges = new ArrayList[n];\n\t\tfor(int i=0;i<n;++i)scc_edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n;++i)for(int u: ed[i])scc_edges[i].add(u);\n\t\tArrays.fill(used, false);\n\t\tsorted_comp = new ArrayList<>();\n\t\tfor(int i=0;i<comp_num;++i)if(!used[i])dfs3(i, sorted_comp);\n\t\tCollections.reverse(sorted_comp);\n\n//\t\tfor(int i=0;i<n;++i)System.out.print(comp[i]+\" \");\n//\t\tSystem.out.println();\n//\t\tfor(int i=0;i<comp_num;++i)for(int u: scc_edges[i])System.out.println(i+\" to \"+u);\n\t\t\n\t\trank = new int[comp_num];\n\t\tArrays.fill(rank, -1);\n\t\tfor(int i=0;i<comp_num;++i)dfs4(i);\n\t}\n\n\tvoid dfs1(int v, Deque que){\n\t\tused[v]=true;\n\t\tfor(int u: edges[v])if(!used[u])dfs1(u, que);\n\t\tque.addLast(v);\n\t}\n\tvoid dfs2(int v){\n\t\tcomp[v]=comp_num;\n\t\tfor(int u: redges[v])if(comp[u]<0)dfs2(u);\n\t}\n\tvoid dfs3(int v, List list){\n\t\tused[v]=true;\n\t\tfor(int u: scc_edges[v])if(!used[u])dfs3(u, list);\n\t\tlist.add(v);\n\t}\n\tint dfs4(int v){\n\t\tif(rank[v]>=0)return rank[v];\n\t\tfor(int u: scc_edges[v]){\n//\t\t\tSystem.out.println(v+\" \"+u);\n\t\t\trank[v] = Math.max(rank[v], dfs4(u));\n\t\t}\n\t\trank[v]++;\n\t\treturn rank[v];\n\t}\n}\n\nclass Main{\n\n\tstatic void solve(){\n\t\tint n = ni(), m=ni();\n\t\tSCC scc = new SCC(n);\n\t\tint[] a = new int[m];\n\t\tint[] b = new int[m];\n\t\tint[] in = new int[n];\n\t\tint[] ou = new int[n];\n\t\tfor(int i=0;i<m;++i){\n\t\t\ta[i]=ni()-1;\n\t\t\tb[i]=ni()-1;\n\t\t\tscc.add_edges(a[i], b[i]);\n\t\t}\n\t\tscc.scc();\n\t\tscc.topoSort();\n\t\tfor(int i=0;i<n;++i){\n\t\t\tfor(int u: scc.edges[i]){\n\t\t\t\tif(scc.comp[i]==scc.comp[u]){\n\t\t\t\t\tou[i]++;in[u]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;++i){\n\t\t\tif(scc.comp[a[i]]==scc.comp[b[i]]){\n\t\t\t\tif(ou[a[i]]>1 && in[b[i]]>1){\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(scc.rank[scc.comp[a[i]]] - scc.rank[scc.comp[b[i]]]==1 && !scc.dab[scc.comp[a[i]]].contains(scc.comp[b[i]])){\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t}\n \n \n \n \n\tpublic static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*;\n\nclass SCC{\n\tList<Integer>[] edges;\n\tList<Integer>[] redges;\n\tboolean[] used;\n\tint[] comp;\n\tint comp_num=0;\n\tint n;\n\n\tList<Integer>[] scc_edges;\n\tList<Integer> sorted_comp;\n\t// 最後尾までの最大距離\n\tint[] rank;\n\n\tSCC(int n){\n\t\tthis.n=n;\n\t\tedges = new ArrayList[n];\n\t\tredges=new ArrayList[n];\n\t\tcomp = new int[n];\n\t\tused=new boolean[n];\n\t\tfor(int i=0;i<n;++i)edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n;++i)redges[i]=new ArrayList<>();\n\t\tArrays.fill(comp, -1);\n\t}\n\tvoid add_edges(int u, int v){\n\t\tedges[u].add(v);\n\t\tredges[v].add(u);\n\t}\n\tvoid scc(){\n\t\tDeque<Integer> visit = new ArrayDeque<>();\n\t\tArrays.fill(used, false);\n\t\tfor(int i=0;i<n;++i)if(!used[i])dfs1(i, visit);\n\t\twhile(!visit.isEmpty()){\n\t\t\tint v = visit.pollLast();\n\t\t\tif(comp[v]>=0)continue;\n\t\t\tdfs2(v);\n\t\t\tcomp_num++;\n\t\t}\n\t}\n\n\tvoid topoSort(){\n\t\tSet<Integer>[] ed = new Set[n];\n\t\tfor(int i=0;i<n;++i)ed[i] = new HashSet<>();\n\t\tfor(int i=0;i<n;++i)for(int u: edges[i])if(comp[i]!=comp[u])ed[comp[i]].add(comp[u]);\n\t\tscc_edges = new ArrayList[n];\n\t\tfor(int i=0;i<n;++i)scc_edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n;++i)for(int u: ed[i])scc_edges[i].add(u);\n\t\tArrays.fill(used, false);\n\t\tsorted_comp = new ArrayList<>();\n\t\tfor(int i=0;i<comp_num;++i)if(!used[i])dfs3(i, sorted_comp);\n\t\tCollections.reverse(sorted_comp);\n\n//\t\tfor(int i=0;i<n;++i)System.out.print(comp[i]+\" \");\n//\t\tSystem.out.println();\n//\t\tfor(int i=0;i<comp_num;++i)for(int u: scc_edges[i])System.out.println(i+\" to \"+u);\n\t\t\n\t\trank = new int[comp_num];\n\t\tArrays.fill(rank, -1);\n\t\tfor(int i=0;i<comp_num;++i)dfs4(i);\n\t}\n\n\tvoid dfs1(int v, Deque que){\n\t\tused[v]=true;\n\t\tfor(int u: edges[v])if(!used[u])dfs1(u, que);\n\t\tque.addLast(v);\n\t}\n\tvoid dfs2(int v){\n\t\tcomp[v]=comp_num;\n\t\tfor(int u: redges[v])if(comp[u]<0)dfs2(u);\n\t}\n\tvoid dfs3(int v, List list){\n\t\tused[v]=true;\n\t\tfor(int u: scc_edges[v])if(!used[u])dfs3(u, list);\n\t\tlist.add(v);\n\t}\n\tint dfs4(int v){\n\t\tif(rank[v]>=0)return rank[v];\n\t\tfor(int u: scc_edges[v]){\n\t\t\tSystem.out.println(v+\" \"+u);\n\t\t\trank[v] = Math.max(rank[v], dfs4(u));\n\t\t}\n\t\trank[v]++;\n\t\treturn rank[v];\n\t}\n}\n\nclass Main{\n\n\tstatic void solve(){\n\t\tint n = ni(), m=ni();\n\t\tSCC scc = new SCC(n);\n\t\tint[] a = new int[m];\n\t\tint[] b = new int[m];\n\t\tint[] in = new int[n];\n\t\tint[] ou = new int[n];\n\t\tfor(int i=0;i<m;++i){\n\t\t\ta[i]=ni()-1;\n\t\t\tb[i]=ni()-1;\n\t\t\tscc.add_edges(a[i], b[i]);\n\t\t}\n\t\tscc.scc();\n\t\tscc.topoSort();\n\t\tfor(int i=0;i<n;++i){\n\t\t\tfor(int u: scc.edges[i]){\n\t\t\t\tif(scc.comp[i]==scc.comp[u]){\n\t\t\t\t\tou[i]++;in[u]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;++i){\n\t\t\tif(scc.comp[a[i]]==scc.comp[b[i]]){\n\t\t\t\tif(ou[a[i]]>1 && in[b[i]]>1){\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(scc.rank[scc.comp[a[i]]] - scc.rank[scc.comp[b[i]]]==1){\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t}\n \n \n \n \n\tpublic static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint N;\n\tint M;\n\tint[] a;\n\tint[] b;\n\tArrayList<Integer>[] g;\n\tboolean[][] go;\n\tint[][] ref;\n\n\tvoid dfs(int cur, int ori) {\n\t\tgo[ori][cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!go[ori][dst])\n\t\t\t\tdfs(dst, ori);\n\t\t}\n\t}\n\n\tvoid paint_min(int cur, int ori, int col, int[] min) {\n\t\tif (min[cur] > col)\n\t\t\tmin[cur] = col;\n\t\telse\n\t\t\treturn;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == ori)\n\t\t\t\tcontinue;\n\t\t\tpaint_min(dst, ori, col, min);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\ta = new int[M];\n\t\tb = new int[M];\n\t\tg = new ArrayList[N];\n\t\tref = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\tref[i][j] = -1;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\t//N<=10^3\n\t\t//M<=2*10^5\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tref[a[i]][b[i]] = i;\n\t\t}\n\t\tgo = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tdfs(i, i);\n\t\tboolean[][] go2 = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint[] a = new int[N];\n\t\t\tArrays.fill(a, g[i].size());\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tpaint_min(g[i].get(j), i, j, a);\n\t\t\t}\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tif (a[g[i].get(j)] != j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(a, g[i].size());\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tpaint_min(g[i].get(j), i, g[i].size() - 1 - j, a);\n\t\t\t}\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tif (a[g[i].get(j)] != g[i].size() - 1 - j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (!go[b[i]][a[i]] && !go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else if (go[b[i]][a[i]] && go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"diff\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tint N;\n\tint M;\n\tint[] a;\n\tint[] b;\n\tArrayList<Integer>[] g;\n\tboolean[][] go;\n\tint[][] ref;\n\n\tvoid dfs(int cur, int ori) {\n\t\tgo[ori][cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!go[ori][dst])\n\t\t\t\tdfs(dst, ori);\n\t\t}\n\t}\n\n\tvoid paint_min(int cur, int ori, int col, int[] min) {\n\t\tif (min[cur] > col)\n\t\t\tmin[cur] = col;\n\t\telse\n\t\t\treturn;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == ori)\n\t\t\t\tcontinue;\n\t\t\tpaint_min(dst, ori, col, min);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\ta = new int[M];\n\t\tb = new int[M];\n\t\tg = new ArrayList[N];\n\t\tref = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\tref[i][j] = -1;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\t//N<=10^3\n\t\t//M<=2*10^5\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = Integer.parseInt(sc.next());\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tref[a[i]][b[i]] = i;\n\t\t}\n\t\tgo = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tdfs(i, i);\n\t\tboolean[][] go2 = new boolean[N][N];\n\t\tint[] tmp = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(tmp, g[i].size());\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tpaint_min(g[i].get(j), i, j, tmp);\n\t\t\t}\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tif (tmp[g[i].get(j)] != j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(tmp, g[i].size());\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tpaint_min(g[i].get(j), i, g[i].size() - 1 - j, tmp);\n\t\t\t}\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tif (tmp[g[i].get(j)] != g[i].size() - 1 - j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (!go[b[i]][a[i]] && !go2[a[i]][b[i]]) {\n\t\t\t\tpw.println(\"same\");\n\t\t\t} else if (go[b[i]][a[i]] && go2[a[i]][b[i]]) {\n\t\t\t\tpw.println(\"same\");\n\t\t\t} else {\n\t\t\t\tpw.println(\"diff\");\n\t\t\t}\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Set;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packD(n, from, to);\n\t\tint[] clus = decomposeToSCC(g);\n\t\tint[][] cg = condense(g, clus);\n\t\t\n\t\tint u = cg.length;\n\t\tint[][] dp = new int[u][u];\n\t\tfor(int i = 0;i < u;i++){\n\t\t\tdp[i][i] = 1;\n\t\t\tfor(int j = i;j >= 0;j--){\n\t\t\t\tfor(int e : cg[j]){\n\t\t\t\t\tdp[i][e] = Math.min(2, dp[i][e] + dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] ep = new int[n];\n\t\tSet<Long> chas = new HashSet<>();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint p = 0;\n\t\t\tfor(int e : g[i]){\n\t\t\t\tif(clus[i] == clus[e]){\n\t\t\t\t\tep[p++] = e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong[][] done = new long[p+1][(n>>>6)+1];\n\t\t\tdone[0][i>>>6] |= 1L<<i;\n\t\t\tfor(int j = 0;j < p;j++){\n\t\t\t\tfor(int k = 0;k < done[j].length;k++){\n\t\t\t\t\tdone[j+1][k] = done[j][k];\n\t\t\t\t}\n\t\t\t\tdfs(done[j+1], ep[j], g, clus);\n\t\t\t}\n\t\t\t\n\t\t\tlong[][] doneb = new long[p+1][(n>>>6)+1];\n\t\t\tdoneb[p][i>>>6] |= 1L<<i;\n\t\t\tfor(int j = p-1;j >= 0;j--){\n\t\t\t\tfor(int k = 0;k < doneb[j].length;k++){\n\t\t\t\t\tdoneb[j][k] = doneb[j+1][k];\n\t\t\t\t}\n\t\t\t\tdfs(doneb[j], ep[j], g, clus);\n\t\t\t}\n\t\t\tfor(int j = 0;j < p;j++){\n\t\t\t\tif((done[j][ep[j]>>>6]|doneb[j+1][ep[j]>>>6])<<~ep[j]>=0){\n\t\t\t\t\tchas.add((long)i<<32|ep[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(clus[from[i]] != clus[to[i]]){\n\t\t\t\tif(dp[clus[from[i]]][clus[to[i]]] == 2){\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(chas.contains((long)from[i]<<32|to[i])){\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void dfs(long[] done, int cur, int[][] g, int[] clus)\n\t{\n\t\tfor(int e : g[cur]){\n\t\t\tif(clus[e] == clus[cur] && done[e>>>6]<<~e>=0){\n\t\t\t\tdone[e>>>6] |= 1L<<e;\n\t\t\t\tdfs(done, e, g, clus);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int[][] condense(int[][] g, int[] clus)\n\t{\n\t\tint n = g.length;\n\t\tint m = 0;\n\t\tfor(int i = 0;i < n;i++)m = Math.max(m, clus[i]);\n\t\tm++;\n\t\t\n\t\tint[] cp = new int[m];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcp[clus[i]] += g[i].length;\n\t\t}\n\t\tint[][] c = new int[m][];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tc[i] = new int[cp[i]];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < g[i].length;j++){\n\t\t\t\tc[clus[i]][--cp[clus[i]]] = clus[g[i][j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tArrays.sort(c[i]);\n\t\t\tint jp = 0;\n\t\t\tfor(int j = 0;j < c[i].length;j++){\n\t\t\t\tif((j == 0 || c[i][j] != c[i][j-1]) && c[i][j] != i){\n\t\t\t\t\tc[i][jp++] = c[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tc[i] = Arrays.copyOf(c[i], jp);\n\t\t}\n\t\treturn c;\n\t}\n\n\t\n\tpublic static int[] decomposeToSCC(int[][] g)\n\t{\n\t\tint n = g.length;\n\t\tint[] stack = new int[n+1];\n\t\tint[] ind = new int[n+1];\n\t\tint[] ord = new int[n];\n\t\tArrays.fill(ord, -1);\n\t\tint[] low = new int[n];\n\t\tArrays.fill(low, -1);\n\t\tint sp = 0;\n\t\tint id = 0; // preorder\n\t\tint[] clus = new int[n];\n\t\tint cid = 0;\n\t\tint[] cstack = new int[n+1];\n\t\tint csp = 0;\n\t\tboolean[] incstack = new boolean[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ord[i] == -1){\n\t\t\t\tind[sp] = 0;\n\t\t\t\tcstack[csp++] = i;\n\t\t\t\tstack[sp++] = i;\n\t\t\t\tincstack[i] = true;\n\t\t\t\twhile(sp > 0){\n\t\t\t\t\tint cur = stack[sp-1];\n\t\t\t\t\tif(ind[sp-1] == 0){\n\t\t\t\t\t\tord[cur] = low[cur] = id++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ind[sp-1] < g[cur].length){\n\t\t\t\t\t\tint nex = g[cur][ind[sp-1]];\n\t\t\t\t\t\tif(ord[nex] == -1){\n\t\t\t\t\t\t\tind[sp-1]++;\n\t\t\t\t\t\t\tind[sp] = 0;\n\t\t\t\t\t\t\tincstack[nex] = true;\n\t\t\t\t\t\t\tcstack[csp++] = nex;\n\t\t\t\t\t\t\tstack[sp++] = nex;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// shortcut\n//\t\t\t\t\t\t\tU.tr(cur, nex, incstack[nex], low[nex], stack);\n\t\t\t\t\t\t\tif(incstack[nex])low[cur] = Math.min(low[cur], low[nex]);\n\t\t\t\t\t\t\tind[sp-1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(ord[cur] == low[cur]){\n\t\t\t\t\t\t\twhile(csp > 0){\n\t\t\t\t\t\t\t\tincstack[cstack[csp-1]] = false;\n\t\t\t\t\t\t\t\tclus[cstack[--csp]] = cid;\n\t\t\t\t\t\t\t\tif(cstack[csp] == cur)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcid++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(--sp >= 1)low[stack[sp-1]] = Math.min(low[stack[sp-1]], low[stack[sp]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn clus;\n\t}\n\n\t\n\tstatic int[][] packD(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tint N;\n\tint M;\n\tint[] a;\n\tint[] b;\n\tArrayList<Integer>[] g;\n\tboolean[][] go;\n\tint[][] ref;\n\n\tvoid dfs(int cur, int ori) {\n\t\tgo[ori][cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!go[ori][dst])\n\t\t\t\tdfs(dst, ori);\n\t\t}\n\t}\n\n\tvoid paint_min(int cur, int ori, int col, int[] min) {\n\t\tif (min[cur] > col)\n\t\t\tmin[cur] = col;\n\t\telse\n\t\t\treturn;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == ori)\n\t\t\t\tcontinue;\n\t\t\tpaint_min(dst, ori, col, min);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\ta = new int[M];\n\t\tb = new int[M];\n\t\tg = new ArrayList[N];\n\t\tref = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\tref[i][j] = -1;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\t//N<=10^3\n\t\t//M<=2*10^5\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tref[a[i]][b[i]] = i;\n\t\t}\n\t\tgo = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tdfs(i, i);\n\t\tboolean[][] go2 = new boolean[N][N];\n\t\tint[] tmp = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(tmp, g[i].size());\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tpaint_min(g[i].get(j), i, j, tmp);\n\t\t\t}\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tif (tmp[g[i].get(j)] != j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(tmp, g[i].size());\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tpaint_min(g[i].get(j), i, g[i].size() - 1 - j, tmp);\n\t\t\t}\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tif (tmp[g[i].get(j)] != g[i].size() - 1 - j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (!go[b[i]][a[i]] && !go2[a[i]][b[i]]) {\n\t\t\t\tpw.println(\"same\");\n\t\t\t} else if (go[b[i]][a[i]] && go2[a[i]][b[i]]) {\n\t\t\t\tpw.println(\"same\");\n\t\t\t} else {\n\t\t\t\tpw.println(\"diff\");\n\t\t\t}\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*;\n\nclass SCC{\n\tList<Integer>[] edges;\n\tList<Integer>[] redges;\n\tboolean[] used;\n\tint[] comp;\n\tint comp_num=0;\n\tint n;\n\n\tList<Integer>[] scc_edges;\n\tList<Integer> sorted_comp;\n\t// 最後尾までの最大距離\n\tint[] rank;\n\n\tSCC(int n){\n\t\tthis.n=n;\n\t\tedges = new ArrayList[n];\n\t\tredges=new ArrayList[n];\n\t\tcomp = new int[n];\n\t\tused=new boolean[n];\n\t\tfor(int i=0;i<n;++i)edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n;++i)redges[i]=new ArrayList<>();\n\t\tArrays.fill(comp, -1);\n\t}\n\tvoid add_edges(int u, int v){\n\t\tedges[u].add(v);\n\t\tredges[v].add(u);\n\t}\n\tvoid scc(){\n\t\tDeque<Integer> visit = new ArrayDeque<>();\n\t\tArrays.fill(used, false);\n\t\tfor(int i=0;i<n;++i)if(!used[i])dfs1(i, visit);\n\t\twhile(!visit.isEmpty()){\n\t\t\tint v = visit.pollLast();\n\t\t\tif(comp[v]>=0)continue;\n\t\t\tdfs2(v);\n\t\t\tcomp_num++;\n\t\t}\n\t}\n\n\tvoid topoSort(){\n\t\tSet<Integer>[] ed = new Set[n];\n\t\tfor(int i=0;i<n;++i)ed[i] = new HashSet<>();\n\t\tfor(int i=0;i<n;++i)for(int u: edges[i])if(comp[i]!=comp[u])ed[comp[i]].add(comp[u]);\n\t\tscc_edges = new ArrayList[n];\n\t\tfor(int i=0;i<n;++i)scc_edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n;++i)for(int u: ed[i])scc_edges[i].add(u);\n\t\tArrays.fill(used, false);\n\t\tsorted_comp = new ArrayList<>();\n\t\tfor(int i=0;i<comp_num;++i)if(!used[i])dfs3(i, sorted_comp);\n\t\tCollections.reverse(sorted_comp);\n\n//\t\tfor(int i=0;i<n;++i)System.out.print(comp[i]+\" \");\n//\t\tSystem.out.println();\n//\t\tfor(int i=0;i<comp_num;++i)for(int u: scc_edges[i])System.out.println(i+\" to \"+u);\n\t\t\n\t\trank = new int[comp_num];\n\t\tArrays.fill(rank, -1);\n\t\tfor(int i=0;i<comp_num;++i)dfs4(i);\n\t}\n\n\tvoid dfs1(int v, Deque que){\n\t\tused[v]=true;\n\t\tfor(int u: edges[v])if(!used[u])dfs1(u, que);\n\t\tque.addLast(v);\n\t}\n\tvoid dfs2(int v){\n\t\tcomp[v]=comp_num;\n\t\tfor(int u: redges[v])if(comp[u]<0)dfs2(u);\n\t}\n\tvoid dfs3(int v, List list){\n\t\tused[v]=true;\n\t\tfor(int u: scc_edges[v])if(!used[u])dfs3(u, list);\n\t\tlist.add(v);\n\t}\n\tint dfs4(int v){\n\t\tif(rank[v]>=0)return rank[v];\n\t\tfor(int u: scc_edges[v]){\n//\t\t\tSystem.out.println(v+\" \"+u);\n\t\t\trank[v] = Math.max(rank[v], dfs4(u));\n\t\t}\n\t\trank[v]++;\n\t\treturn rank[v];\n\t}\n}\n\nclass Main{\n\n\tstatic void solve(){\n\t\tint n = ni(), m=ni();\n\t\tSCC scc = new SCC(n);\n\t\tint[] a = new int[m];\n\t\tint[] b = new int[m];\n\t\tint[] in = new int[n];\n\t\tint[] ou = new int[n];\n\t\tfor(int i=0;i<m;++i){\n\t\t\ta[i]=ni()-1;\n\t\t\tb[i]=ni()-1;\n\t\t\tscc.add_edges(a[i], b[i]);\n\t\t}\n\t\tscc.scc();\n\t\tscc.topoSort();\n\t\tfor(int i=0;i<n;++i){\n\t\t\tfor(int u: scc.edges[i]){\n\t\t\t\tif(scc.comp[i]==scc.comp[u]){\n\t\t\t\t\tou[i]++;in[u]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;++i){\n\t\t\tif(scc.comp[a[i]]==scc.comp[b[i]]){\n\t\t\t\tif(ou[a[i]]>1 && in[b[i]]>1){\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(scc.rank[scc.comp[a[i]]] - scc.rank[scc.comp[b[i]]]==1){\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t}\n \n \n \n \n\tpublic static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Set;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packD(n, from, to);\n\t\tint[] clus = decomposeToSCC(g);\n\t\tint[][][] cg = condense(g, clus);\n\t\t\n\t\tint u = cg.length;\n\t\tint[][] dp = new int[u][u];\n\t\tfor(int i = 0;i < u;i++){\n\t\t\tdp[i][i] = 1;\n\t\t\tfor(int j = i;j >= 0;j--){\n\t\t\t\tfor(int[] e : cg[j]){\n\t\t\t\t\tdp[i][e[0]] = Math.min(2, dp[i][e[0]] + dp[i][j] * e[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] ep = new int[n];\n\t\tSet<Long> chas = new HashSet<>();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint p = 0;\n\t\t\tfor(int e : g[i]){\n\t\t\t\tif(clus[i] == clus[e]){\n\t\t\t\t\tep[p++] = e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong[][] done = new long[p+1][(n>>>6)+1];\n\t\t\tdone[0][i>>>6] |= 1L<<i;\n\t\t\tfor(int j = 0;j < p;j++){\n\t\t\t\tfor(int k = 0;k < done[j].length;k++){\n\t\t\t\t\tdone[j+1][k] = done[j][k];\n\t\t\t\t}\n\t\t\t\tdfs(done[j+1], ep[j], g, clus);\n\t\t\t}\n\t\t\t\n\t\t\tlong[][] doneb = new long[p+1][(n>>>6)+1];\n\t\t\tdoneb[p][i>>>6] |= 1L<<i;\n\t\t\tfor(int j = p-1;j >= 0;j--){\n\t\t\t\tfor(int k = 0;k < doneb[j].length;k++){\n\t\t\t\t\tdoneb[j][k] = doneb[j+1][k];\n\t\t\t\t}\n\t\t\t\tdfs(doneb[j], ep[j], g, clus);\n\t\t\t}\n\t\t\tfor(int j = 0;j < p;j++){\n\t\t\t\tif((done[j][ep[j]>>>6]|doneb[j+1][ep[j]>>>6])<<~ep[j]>=0){\n\t\t\t\t\tchas.add((long)i<<32|ep[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(clus[from[i]] != clus[to[i]]){\n\t\t\t\tif(dp[clus[from[i]]][clus[to[i]]] == 2){\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(chas.contains((long)from[i]<<32|to[i])){\n\t\t\t\t\tout.println(\"diff\");\n\t\t\t\t}else{\n\t\t\t\t\tout.println(\"same\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void dfs(long[] done, int cur, int[][] g, int[] clus)\n\t{\n\t\tfor(int e : g[cur]){\n\t\t\tif(clus[e] == clus[cur] && done[e>>>6]<<~e>=0){\n\t\t\t\tdone[e>>>6] |= 1L<<e;\n\t\t\t\tdfs(done, e, g, clus);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int[][][] condense(int[][] g, int[] clus)\n\t{\n\t\tint n = g.length;\n\t\tint m = 0;\n\t\tfor(int i = 0;i < n;i++)m = Math.max(m, clus[i]);\n\t\tm++;\n\t\t\n\t\tint[] cp = new int[m];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcp[clus[i]] += g[i].length;\n\t\t}\n\t\tint[][] c = new int[m][];\n\t\tint[][][] cg = new int[m][][];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tc[i] = new int[cp[i]];\n\t\t\tcg[i] = new int[cp[i]][];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < g[i].length;j++){\n\t\t\t\tc[clus[i]][--cp[clus[i]]] = clus[g[i][j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tArrays.sort(c[i]);\n\t\t\tint jp = 0;\n\t\t\tfor(int j = 0;j < c[i].length;){\n\t\t\t\tint k = j;\n\t\t\t\twhile(k < c[i].length && c[i][j] == c[i][k])k++;\n\t\t\t\tif(c[i][j] != i){\n\t\t\t\t\tcg[i][jp++] = new int[]{c[i][j], k-j};\n\t\t\t\t}\n\t\t\t\tj = k;\n\t\t\t}\n\t\t\tcg[i] = Arrays.copyOf(cg[i], jp);\n\t\t}\n\t\treturn cg;\n\t}\n\n\t\n\tpublic static int[] decomposeToSCC(int[][] g)\n\t{\n\t\tint n = g.length;\n\t\tint[] stack = new int[n+1];\n\t\tint[] ind = new int[n+1];\n\t\tint[] ord = new int[n];\n\t\tArrays.fill(ord, -1);\n\t\tint[] low = new int[n];\n\t\tArrays.fill(low, -1);\n\t\tint sp = 0;\n\t\tint id = 0; // preorder\n\t\tint[] clus = new int[n];\n\t\tint cid = 0;\n\t\tint[] cstack = new int[n+1];\n\t\tint csp = 0;\n\t\tboolean[] incstack = new boolean[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ord[i] == -1){\n\t\t\t\tind[sp] = 0;\n\t\t\t\tcstack[csp++] = i;\n\t\t\t\tstack[sp++] = i;\n\t\t\t\tincstack[i] = true;\n\t\t\t\twhile(sp > 0){\n\t\t\t\t\tint cur = stack[sp-1];\n\t\t\t\t\tif(ind[sp-1] == 0){\n\t\t\t\t\t\tord[cur] = low[cur] = id++;\n\t\t\t\t\t}\n\t\t\t\t\tif(ind[sp-1] < g[cur].length){\n\t\t\t\t\t\tint nex = g[cur][ind[sp-1]];\n\t\t\t\t\t\tif(ord[nex] == -1){\n\t\t\t\t\t\t\tind[sp-1]++;\n\t\t\t\t\t\t\tind[sp] = 0;\n\t\t\t\t\t\t\tincstack[nex] = true;\n\t\t\t\t\t\t\tcstack[csp++] = nex;\n\t\t\t\t\t\t\tstack[sp++] = nex;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// shortcut\n//\t\t\t\t\t\t\tU.tr(cur, nex, incstack[nex], low[nex], stack);\n\t\t\t\t\t\t\tif(incstack[nex])low[cur] = Math.min(low[cur], low[nex]);\n\t\t\t\t\t\t\tind[sp-1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(ord[cur] == low[cur]){\n\t\t\t\t\t\t\twhile(csp > 0){\n\t\t\t\t\t\t\t\tincstack[cstack[csp-1]] = false;\n\t\t\t\t\t\t\t\tclus[cstack[--csp]] = cid;\n\t\t\t\t\t\t\t\tif(cstack[csp] == cur)break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcid++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(--sp >= 1)low[stack[sp-1]] = Math.min(low[stack[sp-1]], low[stack[sp]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn clus;\n\t}\n\n\t\n\tstatic int[][] packD(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.Collections;\nimport java.io.PrintWriter;\n\npublic class Main {\n    static class E {\n        int to, id;\n        boolean res;\n        E(int to, int id, boolean res) {\n            this.to = to;\n            this.id = id;\n            this.res = res;\n        }\n    }\n\n    static boolean[] vis;\n    static void mark(ArrayList<E>[] g, int p, int r) {\n        vis[p] = true;\n        for (E e: g[p]) {\n            int d = e.to;\n            if (d == r || vis[d]) continue;\n            mark(g, d, r);\n        }\n    }\n    static void solve(ArrayList<E>[] g) {\n        int n = g.length;\n        for (int i = 0; i < n; i++) {\n            vis = new boolean[n];\n            for (E e: g[i]) {\n                int d = e.to;\n                if (vis[d]) e.res = true;\n                mark(g, d, i);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n    \tPrintWriter out = new PrintWriter(System.out);\n\n    \tint n = in.nextInt();\n        int m = in.nextInt();\n\n        boolean[][] scc = new boolean[n][n];\n\n        ArrayList<E>[] g = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<E>();\n        }\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt();\n            int b = in.nextInt();\n            a--; b--;\n            scc[a][b] = true;\n            g[a].add(new E(b, i, false));\n        }\n\n        for (int i = 0; i < n; i++) {\n            scc[i][i] = true;\n        }\n\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    scc[i][j] |= scc[i][k] && scc[k][j];\n                }\n            }\n        }\n\n        solve(g);\n        for (int i = 0; i < n; i++) {\n            Collections.reverse(g[i]);\n        }\n        solve(g);\n\n        boolean[] res = new boolean[m];\n        for (int i = 0; i < n; i++) {\n            for (E e: g[i]) {\n                res[e.id] = e.res ^ scc[e.to][i];\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            if (res[i]) {\n                out.println(\"diff\");\n            } else {\n                out.println(\"same\");\n            }\n        }\n        out.flush();\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n \n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n \n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n \n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n \n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n \n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n \n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n \n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n \n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n \n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tint N;\n\tint M;\n\tint[] a;\n\tint[] b;\n\tArrayList<Integer>[] g;\n\tboolean[][] go;\n\tint[][] ref;\n\n\tvoid dfs(int cur, int ori) {\n\t\tgo[ori][cur] = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!go[ori][dst])\n\t\t\t\tdfs(dst, ori);\n\t\t}\n\t}\n\n\tvoid paint_min(int cur, int ori, int col, int[] min) {\n\t\tif (min[cur] > col)\n\t\t\tmin[cur] = col;\n\t\telse\n\t\t\treturn;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (dst == ori)\n\t\t\t\tcontinue;\n\t\t\tpaint_min(dst, ori, col, min);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\ta = new int[M];\n\t\tb = new int[M];\n\t\tg = new ArrayList[N];\n\t\tref = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\tref[i][j] = -1;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\t//N<=10^3\n\t\t//M<=2*10^5\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tb[i] = sc.nextInt();\n\t\t\t--a[i];\n\t\t\t--b[i];\n\t\t\tg[a[i]].add(b[i]);\n\t\t\tref[a[i]][b[i]] = i;\n\t\t}\n\t\tgo = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tdfs(i, i);\n\t\tboolean[][] go2 = new boolean[N][N];\n\t\tint[] a = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(a, g[i].size());\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tpaint_min(g[i].get(j), i, j, a);\n\t\t\t}\n\t\t\tfor (int j = 0; j < g[i].size(); ++j) {\n\t\t\t\tif (a[g[i].get(j)] != j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(a, g[i].size());\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tpaint_min(g[i].get(j), i, g[i].size() - 1 - j, a);\n\t\t\t}\n\t\t\tfor (int j = g[i].size() - 1; j >= 0; --j) {\n\t\t\t\tif (a[g[i].get(j)] != g[i].size() - 1 - j) {\n\t\t\t\t\tgo2[i][g[i].get(j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (!go[b[i]][a[i]] && !go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else if (go[b[i]][a[i]] && go2[a[i]][b[i]]) {\n\t\t\t\tSystem.out.println(\"same\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"diff\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Linq.Enumerable;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        Random rnd = new Random(0);\n        public void Solve()\n        {\n            var n = ri;\n            var m = ri;\n            var G = Enumerate(n, x => new List<int>());\n            var RG = Enumerate(n, x => new List<int>());\n            var from = new int[m];\n            var to = new int[m];\n            for (int i = 0; i < m; i++)\n            {\n                from[i] = ri - 1;\n                to[i] = ri - 1;\n                G[from[i]].Add(i);\n                RG[to[i]].Add(i);\n            }\n            var go = new bool[m];\n            var back = new bool[m];\n            for (int r = 0; r < n; r++)\n            {\n                for (int k = 0; k < 2; k++)\n                {\n                    var vis = new bool[n];\n                    Action<int> dfs = null;\n                    dfs = x =>\n                    {\n                        vis[x] = true;\n                        foreach (var i in G[x])\n                        {\n                            var t = to[i];\n                            if (vis[t])\n                            {\n                                if (x == r) go[i] = true;\n                                continue;\n                            }\n                            else dfs(t);\n                        }\n                    };\n                    dfs(r);\n                    foreach (var i in RG[r])\n                    {\n                        var t = from[i];\n                        if (vis[t]) back[i] = true;\n                    }\n                    G[r].Reverse();\n                }\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                if (go[i] == back[i]) Console.WriteLine(\"same\");\n                else Console.WriteLine(\"diff\");\n            }\n        }\n\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter\n    {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char()\n        {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    List<int>[] G;\n    List<int>[] revG;\n    List<int>[] order;\n    List<int>[] revorder;\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int M = re.i();\n        G = new List<int>[N];\n        order = new List<int>[N];\n        revG = new List<int>[N];\n        revorder = new List<int>[N];\n        for(int j=0;j<N;j++){\n            G[j] = new List<int>();\n            order[j] = new List<int>();\n            revG[j] = new List<int>();\n            revorder[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = re.i()-1;\n            int t = re.i()-1;\n            G[f].Add(t);\n            revG[t].Add(f);\n            order[f].Add(j);\n            revorder[t].Add(j);\n        }\n        bool[] Changed = new bool[M];\n        for(int i=0;i<N;i++){\n            int[] OK1 = new int[N];\n            OK1[i] = N+5;\n            for(int j=0;j<G[i].Count;j++){\n                dfs(G[i][j],j+1,OK1);\n            }\n            int[] OK2 = new int[N];\n            OK2[i] = N+5;\n            for(int j=G[i].Count-1;j>=0;j--){\n                dfs(G[i][j],j+1,OK2);\n            }\n            for(int j=0;j<G[i].Count;j++){\n                if(OK1[G[i][j]] != j+1 || OK2[G[i][j]] != j+1){\n                    Changed[order[i][j]] = !Changed[order[i][j]];\n                }\n            }\n        }\n        StrongConnectedGraph Scc = new StrongConnectedGraph(G);\n        for(int i=0;i<N;i++){\n            for(int j=0;j<revG[i].Count;j++){\n                if(Scc.SameAffilication(i,revG[i][j])){\n                    Changed[revorder[i][j]] = !Changed[revorder[i][j]];\n                }\n            }\n        }\n        for(int i=0;i<M;i++){\n            if(Changed[i]){\n                sb.Append(\"diff\\n\");\n            }\n            else{\n                sb.Append(\"same\\n\");\n            }\n        }\n    }\n    void dfs(int v,int val,int[] OK){\n        if(OK[v] != 0){\n            return;\n        }\n        OK[v] = val;\n        for(int i=0;i<G[v].Count;i++){\n            dfs(G[v][i],val,OK);\n        }\n    }\n    void dfs(int v,bool[] OK){\n        if(OK[v]){\n            return;\n        }\n        OK[v] = true;\n        for(int i=0;i<G[v].Count;i++){\n            dfs(G[v][i],OK);\n        }\n    }\n}\nclass StrongConnectedGraph{\n    List<int>[] originalGraph;\n    List<int>[] reverseGraph;\n    public List<int>[] G;\n    int originalN;\n    public int N;\n    public int[] weight;\n    bool[] b;\n    int[] order;\n    int count;\n    public List<List<int>> division;\n    int[] affilication;\n    public StrongConnectedGraph(List<int>[] g){\n        originalGraph = g;\n        originalN = g.Length;\n        Calc();\n    }\n    void Calc(){\n        b = new bool[originalN];\n        order = new int[originalN];\n        reverseGraph = new List<int>[originalN];\n        for(int i=0;i<originalN;i++){\n            reverseGraph[i] = new List<int>();\n        }\n        for(int i=0;i<originalN;i++){\n            for(int j=0;j<originalGraph[i].Count;j++){\n                reverseGraph[originalGraph[i][j]].Add(i);\n            }\n        }\n        count = 0;\n        for(int i=0;i<originalN;i++){\n            if(!b[i]){\n                dfs1(i);\n            }\n        }\n        count = 0;\n        for(int i=0;i<originalN;i++){\n            b[i] = false;\n        }\n        affilication = new int[originalN];\n        division = new List<List<int>>();\n        for(int i=originalN-1;i>=0;i--){\n            if(!b[order[i]]){\n                division.Add(new List<int>());\n                dfs2(order[i]);\n                count++;\n            }\n        }\n    }\n    void dfs1(int v){\n        b[v] = true;\n        for(int i=0;i<originalGraph[v].Count;i++){\n            int t = originalGraph[v][i];\n            if(!b[t]){\n                dfs1(t);\n            }\n        }\n        order[count] = v;\n        count++;\n    }\n    void dfs2(int v){\n        b[v] = true;\n        division[count].Add(v);\n        affilication[v] = count;\n        for(int i=0;i<reverseGraph[v].Count;i++){\n            int t = reverseGraph[v][i];\n            if(!b[t]){\n                dfs2(t);\n            }\n        }\n    }\n    public bool SameAffilication(int u,int v){\n        return affilication[u] == affilication[v];\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    List<int>[] G;\n    List<int>[] revG;\n    List<int>[] order;\n    List<int>[] revorder;\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int M = re.i();\n        G = new List<int>[N];\n        order = new List<int>[N];\n        revG = new List<int>[N];\n        revorder = new List<int>[N];\n        for(int j=0;j<N;j++){\n            G[j] = new List<int>();\n            order[j] = new List<int>();\n            revG[j] = new List<int>();\n            revorder[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = re.i()-1;\n            int t = re.i()-1;\n            G[f].Add(t);\n            revG[t].Add(f);\n            order[f].Add(j);\n            revorder[t].Add(j);\n        }\n        bool[] Changed = new bool[M];\n        for(int i=0;i<N;i++){\n            int[] OK1 = new int[N];\n            OK1[i] = N+5;\n            for(int j=0;j<G[i].Count;j++){\n                dfs(G[i][j],j+1,OK1);\n            }\n            int[] OK2 = new int[N];\n            OK2[i] = N+5;\n            for(int j=G[i].Count-1;j>=0;j--){\n                dfs(G[i][j],j+1,OK2);\n            }\n            for(int j=0;j<G[i].Count;j++){\n                if(OK1[G[i][j]] != j+1 || OK2[G[i][j]] != j+1){\n                    Changed[order[i][j]] = !Changed[order[i][j]];\n                }\n            }\n        }\n        for(int i=0;i<N;i++){\n            bool[] OK = new bool[N];\n            dfs(i,OK);\n            for(int j=0;j<revG[i].Count;j++){\n                if(OK[revG[i][j]]){\n                    Changed[revorder[i][j]] = !Changed[revorder[i][j]];\n                }\n            }\n        }\n        for(int i=0;i<M;i++){\n            if(Changed[i]){\n                sb.Append(\"diff\\n\");\n            }\n            else{\n                sb.Append(\"same\\n\");\n            }\n        }\n    }\n    void dfs(int v,int val,int[] OK){\n        if(OK[v] != 0){\n            return;\n        }\n        OK[v] = val;\n        for(int i=0;i<G[v].Count;i++){\n            dfs(G[v][i],val,OK);\n        }\n    }\n    void dfs(int v,bool[] OK){\n        if(OK[v]){\n            return;\n        }\n        OK[v] = true;\n        for(int i=0;i<G[v].Count;i++){\n            dfs(G[v][i],OK);\n        }\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        Random rnd = new Random(0);\n        public void Solve()\n        {\n            var n = ri;\n            var m = ri;\n            var G = Enumerate(n, x => new List<int>());\n            var RG = Enumerate(n, x => new List<int>());\n            var from = new int[m];\n            var to = new int[m];\n            for (int i = 0; i < m; i++)\n            {\n                from[i] = ri - 1;\n                to[i] = ri - 1;\n                G[from[i]].Add(i);\n                RG[to[i]].Add(i);\n            }\n            var go = new bool[m];\n            var back = new bool[m];\n            for (int r = 0; r < n; r++)\n            {\n                for (int k = 0; k < 2; k++)\n                {\n                    var vis = new bool[n];\n                    Action<int> dfs = null;\n                    dfs = x =>\n                    {\n                        vis[x] = true;\n                        foreach (var i in G[x])\n                        {\n                            var t = to[i];\n                            if (vis[t])\n                            {\n                                if (x == r) go[i] = true;\n                                continue;\n                            }\n                            else dfs(t);\n                        }\n                    };\n                    dfs(r);\n                    foreach (var i in RG[r])\n                    {\n                        var t = from[i];\n                        if (vis[t]) back[i] = true;\n                    }\n                    G[r].Reverse();\n                }\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                if (go[i] == back[i]) Console.WriteLine(\"same\");\n                else Console.WriteLine(\"diff\");\n            }\n        }\n\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter\n    {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char()\n        {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=1005,MAXM=200005;\n \nint N,M;\nvector<int> adj[MAXN];\nint E[MAXM][2];\n \nint p[MAXN][MAXN],q[MAXN][MAXN];\nbool vis[MAXN];\n \nvoid mark(int s,int u,int id,int mk[])\n{\n\tif(u==s||vis[u])return;\n\tvis[u]=true;\n\tmk[u]=id;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t\tmark(s,adj[u][i],id,mk);\n}\n \nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1,a,b;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tE[i][0]=a;E[i][1]=b;\n\t\tadj[a].push_back(b);\n\t}\n\t\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tmemset(vis,0,sizeof vis);\n\t\tint id=0;\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],++id,p[i]);\n\t\tmemset(vis,0,sizeof vis);\n\t\treverse(adj[i].begin(),adj[i].end());\n\t\tid=adj[i].size();\n\t\tfor(int j=0;j<(int)adj[i].size();j++)\n\t\t\tmark(i,adj[i][j],id--,q[i]);\n\t}\n\t\n\tfor(int i=1;i<=M;i++)\n\t\tif((p[E[i][1]][E[i][0]]>0)==(p[E[i][0]][E[i][1]]!=q[E[i][0]][E[i][1]]))\n\t\t\tputs(\"same\");\n\t\telse\n\t\t\tputs(\"diff\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> g[200001];\nint n,m,op[1001][1001],a[200001],b[200001];\ninline void read(int &x){\n\tint a;scanf(\"%d\",&a);x=a;\n}\nbool visit[1001]={false};\nvoid dfs(int u,int c){//cout<<u<<\" \";\n\tvisit[u]=true;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(!visit[v]){\n\t\t\top[c][v]++;\n\t\t\tdfs(v,c);\n\t\t}\n\t}\n\tvisit[u]=false;\n}\nint main(){\n\tread(n);read(m);\n\tfor(int i=1;i<=m;i++){\n\t\tread(a[i]);read(b[i]);\n\t\tg[a[i]].push_back(b[i]);\n\t}\n\tfor(int i=1;i<=n;i++)dfs(i,i);\n\tfor(int i=1;i<=m;i++){\n\t\tif(op[a[i]][b[i]]&&op[b[i]][a[i]]){//qlt\n\t\t\tif(op[a[i]][b[i]]==1)printf(\"diff\\n\");\n\t\t\telse printf(\"same\\n\");\n\t\t}\n\t\telse{//bqlt\n\t\t\tif(op[a[i]][b[i]]==1)printf(\"same\\n\");\n\t\t\telse printf(\"diff\\n\");\n\t\t}\n\t}\n} "
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid File(){\n    freopen(\"ARC92F.in\",\"r\",stdin);\n    freopen(\"ARC92F.out\",\"w\",stdout);\n}\n#define REP(i,a,b) for(register int i=a;i<=b;++i)\n#define DREP(i,a,b) for(register int i=a;i>=b;--i)\n#define mem(a) memset(a,0,sizeof(a))\nconst int maxn=1000+10;\nconst int maxm=200000+10;\nvector<int>E[maxn];\nint n,m,beg[maxn],len,num[maxn][maxn];\nbool can[maxn][maxn],vis[maxn],can1[maxn][maxn];\nint vis1[maxn],vis2[maxn],from[maxm],to[maxm];\nvoid dfs(int u,int rt){\n    vis[u]=1;\n    can[rt][u]=1;\n    int size=E[u].size()-1;\n    REP(i,0,size){\n        int v=E[u][i];\n        if(vis[v])continue;\n        dfs(v,rt);\n    }\n}\nvoid dfs1(int u){\n    vis[u]=1;\n    int size=E[u].size()-1;\n    REP(i,0,size){\n        int v=E[u][i];\n        if(vis[v])continue;\n        vis1[v]=num[u][v];\n        dfs1(v);\n    }\n}\nvoid dfs2(int u){\n    vis[u]=1;\n    int size=E[u].size()-1;\n    DREP(i,size,0){\n        int v=E[u][i];\n        if(vis[v])continue;\n        vis2[v]=num[u][v];\n        dfs2(v);\n    }\n}\nint main(){\n    //File();\n    scanf(\"%d%d\",&n,&m);\n    REP(i,1,m){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        E[u].push_back(v);\n        num[u][v]=++len;\n        from[len]=u;\n        to[len]=v;\n    }\n    REP(i,1,n){\n        dfs(i,i);\n        mem(vis);\n    }\n    REP(i,1,n){\n        dfs1(i);\n        mem(vis);\n        dfs2(i);\n        mem(vis);\n        int size=E[i].size()-1;\n        REP(j,0,size){\n            int v=E[i][j];\n            if(vis1[v]!=num[i][v] || vis2[v]!=num[i][v])\n                can1[i][v]=1;\n        }\n        mem(vis1);\n        mem(vis2);\n    }\n    REP(i,1,m){\n        int u=from[i],v=to[i];\n        if((can[v][u]^can1[u][v])==0)\n            puts(\"same\");\n        else puts(\"diff\");\n    }\n    return 0;\n}//"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ninline void read(int &x)\n{\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\nstruct node{\n\tint nex,to,from;\n}edge[200005];\nint N,M;\nint head[1005],tot;\ninline void insert(int from,int to)\n{\n\tedge[++tot].nex=head[from];\n\thead[from]=tot;\n\tedge[tot].to=to;\n\tedge[tot].from=from;\n}\nint mex[1005][1005];\nvoid dfs(int v,int x)\n{\n\tfor(int i=head[x];i;i=edge[i].nex)\n\t\tif(mex[v][edge[i].to]<2)\n\t\t{\n\t\t\tmex[v][edge[i].to]++;\n\t\t\tdfs(v,edge[i].to);\n\t\t}\n}\nint main()\n{\n\tread(N);read(M);\n\tint u,v;\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tread(u);read(v);\n\t\tinsert(u,v);\n\t} \n\tfor(int i=1;i<=N;i++)\n\t\tdfs(i,i);\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tbool flag=0;\n\t\tif(mex[edge[i].from][edge[i].to]&&mex[edge[i].to][edge[i].from])\n\t\t\tif(mex[edge[i].from][edge[i].to]>=2)\n\t\t\t\tflag=1;\n\t\tif(!mex[edge[i].to][edge[i].from]&&mex[edge[i].from][edge[i].to]>=2)\n\t\t\tflag=1;\n\t\tif(flag)\n\t\t\tprintf(\"diff\\n\");\n\t\telse\n\t\t\tprintf(\"same\\n\");\n\t}\n\t\t\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nclass UnionFind():\n    def __init__(self, size):\n        self.table = [-1] * size\n\n    def find(self, x):\n        while 0 <= self.table[x]:\n            x = self.table[x]\n        return x\n\n    def unite(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            dx = -self.table[rx]\n            dy = -self.table[ry]\n            if dx != dy:\n                if dx < dy:\n                    self.table[rx] = ry\n                else:\n                    self.table[ry] = rx\n            else:\n                self.table[rx] -= 1\n                self.table[ry] = rx\n        return\n\n\ne = None\nre = None\n\n\npost = None\nrev = None\ncc = None\nscc = None\n\nt_post = 1\n\ndef dfs0(u, r):\n    global post, rev, t_post\n    global cc\n\n    cc.unite(u, r)\n    post[u] = 1  # dummy\n    for w in e[u]:\n        if post[w] == 0:\n            dfs0(w, r)\n    post[u] = t_post\n    rev[t_post] = u\n    t_post += 1\n\n\ndef dfs1(u, r, cr, visited):\n    global scc\n\n    scc.unite(u, r)\n    visited[u] = True\n    for w in re[u]:\n        if cc.find(w) != cr:\n            continue\n        if not visited[w]:\n            dfs1(w, r, cr, visited)\n\n\ndef dfs2(u, t, visited):\n\n    visited[u] = True\n    for w in e[u]:\n        if w == t:\n            return True\n        if not visited[w]:\n            r = dfs2(w, t, visited)\n            if r:\n                return True\n\n    return False\n\n\ndef find_another_path(n, s, t):\n    visited = [False] * (n + 1)\n    visited[s] = True\n    for i in e[s]:\n        if i != t:\n            r = dfs2(i, t, visited)\n            if r:\n                return True\n\n    return False\n\n\ndef solve(n, m, edges):\n    global post, rev\n    global cc, scc\n\n    post = [0] * (n + 1)\n    rev = [0] * (n + 1)\n    cc = UnionFind(n + 1)\n    scc = UnionFind(n + 1)\n    visited = [False] * (n + 1)\n\n    for r in range(1, n + 1):\n        if post[r] == 0:\n            cur = t_post\n            dfs0(r, r)\n            for v in range(t_post - 1, cur - 1, -1):\n                r1 = rev[v]\n                if not visited[r1]:\n                    cr = cc.find(r1)\n                    dfs1(r1, r1, cr, visited)\n\n    for a, b in edges:\n        scc_a = scc.find(a)\n        scc_b = scc.find(b)\n        pathf = find_another_path(n, a, b)\n        print('diff' if (scc_a == scc_b) ^ pathf else 'same')\n\n\ndef main():\n    global e, re\n\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    edges = []\n    e = [[] for _ in range(n + 1)]\n    re = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b = input().split()\n        a = int(a)\n        b = int(b)\n        edges.append((a, b))\n        e[a].append(b)\n        re[b].append(a)\n\n\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n\n    best, solution = int(-1e10), []\n    for p in range(2):\n        c = a.copy()\n\n        indexes = list(range(p, n, 2))\n        if len(indexes) == 0:\n            continue\n\n        maks = max([c[i] for i in indexes])\n        pick = next((i for i in indexes if c[i] == maks))\n        chosen = set([pick] if maks <= 0 else [i for i in indexes if c[i] > 0])\n        is_chosen = [(i in chosen) for i in range(n)]\n\n        tot, res = sum([c[i] for i in chosen]), []\n        for i in reversed(range(n)):\n            if not is_chosen[i]:\n                if i == 0 or i + 1 == len(c):\n                    res += [i]\n                    del c[i], is_chosen[i]\n                elif is_chosen[i - 1] == is_chosen[i + 1]:\n                    res += [i]\n                    c[i - 1] += c[i + 1]\n                    del c[i + 1], c[i], is_chosen[i + 1], is_chosen[i]\n\n        for end in [0]:\n            while len(c) > 1 and not is_chosen[end]:\n                res += [end]\n                del c[end], is_chosen[end]\n\n        if tot > best:\n            best, solution = tot, np.array(res) + 1\n\n    print(best, len(solution), *solution, sep='\\n')\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n\n    best, solution = int(-1e10), []\n    for p in range(2):\n        c = a.copy()\n\n        indexes = list(range(p, n, 2))\n        if len(indexes) == 0:\n            continue\n\n        maks = max([c[i] for i in indexes])\n        pick = next((i for i in indexes if c[i] == maks))\n        chosen = set([pick] if maks <= 0 else [i for i in indexes if c[i] > 0])\n        is_chosen = [(i in chosen) for i in range(n)]\n\n        tot, res = sum([c[i] for i in chosen]), []\n        for i in reversed(range(n)):\n            if not is_chosen[i]:\n                if i == 0 or i + 1 == len(c):\n                    res += [i]\n                    del c[i], is_chosen[i]\n                elif is_chosen[i - 1] == is_chosen[i + 1]:\n                    res += [i]\n                    c[i - 1] += c[i + 1]\n                    del c[i + 1], c[i], is_chosen[i + 1], is_chosen[i]\n\n        for end in (0):\n            while len(c) > 1 and not is_chosen[end]:\n                res += [end]\n                del c[end], is_chosen[end]\n\n        if tot > best:\n            best, solution = tot, np.array(res) + 1\n\n    print(best, len(solution), *solution, sep='\\n')\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n\n    best, solution = int(-1e10), []\n    for p in range(2):\n        c = a.copy()\n\n        indexes = list(range(p, n, 2))\n        if len(indexes) == 0:\n            continue\n\n        maks = max([c[i] for i in indexes])\n        pick = next((i for i in indexes if c[i] == maks))\n        chosen = set([pick] if maks <= 0 else [i for i in indexes if c[i] > 0])\n        is_chosen = [(i in chosen) for i in range(n)]\n\n        tot, res = sum([c[i] for i in chosen]), []\n        for i in reversed(range(n)):\n            if not is_chosen[i]:\n                if i == 0 or i + 1 == len(c):\n                    res += [i]\n                    del c[i], is_chosen[i]\n                elif is_chosen[i - 1] == is_chosen[i + 1]:\n                    res += [i]\n                    c[i - 1] += c[i + 1]\n                    del c[i + 1], c[i], is_chosen[i + 1], is_chosen[i]\n\n        for end in [0, -1]:\n            while len(c) > 1 and not is_chosen[end]:\n                res += [end]\n                del c[end], is_chosen[end]\n\n        if tot > best:\n            best, solution = tot, np.array(res) + 1\n\n    print(best, len(solution), *solution, sep='\\n')\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    def dfs0(u, st=-1, en=-1):\n        if en == -1:\n            for i, ku in enumerate(to[u]):\n                if can[u][ku][0] != -1: continue\n                can[u][ku][0] = i\n                dfs0(ku, u, i)\n            return\n        for ku in to[u]:\n            if ku == st: continue\n            if can[st][ku][0] != -1: continue\n            can[st][ku][0] = en\n            dfs0(ku, st, en)\n\n    def dfs1(u, st=-1, en=-1):\n        if en == -1:\n            sz = len(to[u])\n            for i, ku in enumerate(to[u][::-1]):\n                if can[u][ku][1] != -1: continue\n                can[u][ku][1] = sz - 1 - i\n                dfs1(ku, u, sz - 1 - i)\n            return\n        for ku in to[u]:\n            if ku == st: continue\n            if can[st][ku][1] != -1: continue\n            can[st][ku][1] = en\n            dfs1(ku, st, en)\n\n    to = defaultdict(list)\n    n, m = map(int, input().split())\n    ee = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        a, b = a - 1, b - 1\n        to[a].append(b)\n        ee.append([a, b])\n    for v in to.values():\n        v.sort()\n    #print(to)\n    can = [[[-1] * 2 for _ in range(n)] for _ in range(n)]\n    fin = [False] * n\n    for u, v in ee:\n        for w in [u, v]:\n            if not fin[w]:\n                fin[w] = True\n                dfs0(w)\n                dfs1(w)\n        # print(u,v)\n        # print(can[u][v][0] == can[u][v][1])\n        # print(sum(can[v][u]) == -2)\n        if (can[u][v][0] == can[u][v][1]) == (sum(can[v][u]) == -2):\n            print(\"same\")\n        else:\n            print(\"diff\")\n    #for x in can:\n    #    print(x)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n\n    best, solution = int(-1e10), []\n    for p in range(2):\n        c = a.copy()\n\n        indexes = list(range(p, n, 2))\n        if len(indexes) == 0:\n            continue\n\n        maks = max([c[i] for i in indexes])\n        pick = next((i for i in indexes if c[i] == maks))\n        chosen = set([pick] if maks <= 0 else [i for i in indexes if c[i] > 0])\n        is_chosen = [(i in chosen) for i in range(n)]\n\n        tot, res = sum([c[i] for i in chosen]), []\n        for i in reversed(range(n)):\n            if not is_chosen[i]:\n                if i == 0 or i + 1 == len(c):\n                    res += [i]\n                    del c[i], is_chosen[i]\n                elif is_chosen[i - 1] == is_chosen[i + 1]:\n                    res += [i]\n                    c[i - 1] += c[i + 1]\n                    del c[i + 1], c[i], is_chosen[i + 1], is_chosen[i]\n\n        for end in (0, ):\n            while len(c) > 1 and not is_chosen[end]:\n                res += [end]\n                del c[end], is_chosen[end]\n\n        if tot > best:\n            best, solution = tot, np.array(res) + 1\n\n    print(best, len(solution), *solution, sep='\\n')\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nclass UnionFind():\n    def __init__(self, size):\n        self.table = [-1] * size\n\n    def find(self, x):\n        while 0 <= self.table[x]:\n            x = self.table[x]\n        return x\n\n    def unite(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            dx = -self.table[rx]\n            dy = -self.table[ry]\n            if dx != dy:\n                if dx < dy:\n                    self.table[rx] = ry\n                else:\n                    self.table[ry] = rx\n            else:\n                self.table[rx] -= 1\n                self.table[ry] = rx\n        return\n\n\ne = None\nre = None\n\n\npost = None\nrev = None\ncc = None\nscc = None\n\nt = 1\n\ndef dfs0(u, r):\n    global post, rev, t\n    global cc\n\n    cc.unite(u, r)\n    post[u] = 1  # dummy\n    for w in e[u]:\n        if post[w] == 0:\n            dfs0(w, r)\n    post[u] = t\n    rev[t] = u\n    t += 1\n\n\ndef dfs1(u, r, cr, visited):\n    global scc\n\n    scc.unite(u, r)\n    visited[u] = True\n    for w in re[u]:\n        if cc.find(w) != cr:\n            continue\n        if not visited[w]:\n            dfs1(w, r, cr, visited)\n\n\ndef dfs2(u, r, first, rs, visited):\n\n    visited[u] = True\n    for w in e[u]:\n        if not visited[w]:\n            dfs2(w, r, first, rs, visited)\n        elif w != r and w != first:\n            rs.add((r, w))\n\n\ndef traverse(n, s, rs):\n    visited = [False] * (n + 1)\n    visited[s] = True\n    for w in e[s]:\n        visited[w] = True\n    for w in e[s]:\n        dfs2(w, s, w, rs, visited)\n\n\ndef solve(n, m, edges):\n    global post, rev\n    global cc, scc\n\n    post = [0] * (n + 1)\n    rev = [0] * (n + 1)\n    cc = UnionFind(n + 1)\n    scc = UnionFind(n + 1)\n\n    visited = [False] * (n + 1)\n    for r in range(1, n + 1):\n        if post[r] == 0:\n            cur = t\n            dfs0(r, r)\n            for v in range(t - 1, cur - 1, -1):\n                r1 = rev[v]\n                if not visited[r1]:\n                    cr = cc.find(r1)\n                    dfs1(r1, r1, cr, visited)\n\n    visited = [False] * (n + 1)\n    path_exists = set()\n    for a, b in edges:\n        if not visited[a]:\n            visited[a] = True\n            traverse(n, a, path_exists)\n\n\n    for a, b in edges:\n        scc_a = scc.find(a)\n        scc_b = scc.find(b)\n        exist = (a, b) in path_exists\n        print('diff' if (scc_a == scc_b) ^ exist else 'same')\n\n\ndef main():\n    global e, re\n\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    edges = []\n    e = [[] for _ in range(n + 1)]\n    re = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b = input().split()\n        a = int(a)\n        b = int(b)\n        edges.append((a, b))\n        e[a].append(b)\n        re[b].append(a)\n\n\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nclass UnionFind():\n    def __init__(self, size):\n        self.table = [-1] * size\n\n    def find(self, x):\n        while 0 <= self.table[x]:\n            x = self.table[x]\n        return x\n\n    def unite(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            dx = -self.table[rx]\n            dy = -self.table[ry]\n            if dx != dy:\n                if dx < dy:\n                    self.table[rx] = ry\n                else:\n                    self.table[ry] = rx\n            else:\n                self.table[rx] -= 1\n                self.table[ry] = rx\n        return\n\n\ne = None\nre = None\n\n\npost = None\nrev = None\ncc = None\nscc = None\n\nt = 1\n\ndef dfs0(u, r):\n    global post, rev, t\n    global cc\n\n    cc.unite(u, r)\n    post[u] = 1  # dummy\n    for w in e[u]:\n        if post[w] == 0:\n            dfs0(w, r)\n    post[u] = t\n    rev[t] = u\n    t += 1\n\n\ndef dfs1(u, r, cr, visited):\n    global scc\n\n    scc.unite(u, r)\n    visited[u] = True\n    for w in re[u]:\n        if cc.find(w) != cr:\n            continue\n        if not visited[w]:\n            dfs1(w, r, cr, visited)\n\n\ndef dfs2(u, r, rs, visited):\n    visited[u] = True\n    for w in e[u]:\n        if w != r and not w in rs:\n            rs.add(w)\n        if not visited[w]:\n            dfs2(w, r, rs, visited)\n\n\ndef find_another_paths(n, s, rs):\n    for w in e[s]:\n        visited = [False] * (n + 1)\n        visited[s] = True\n        dfs2(w, w, rs, visited)\n\n\ndef solve(n, m, edges):\n    global post, rev\n    global cc, scc\n\n    post = [0] * (n + 1)\n    rev = [0] * (n + 1)\n    cc = UnionFind(n + 1)\n    scc = UnionFind(n + 1)\n    visited = [False] * (n + 1)\n\n    for r in range(1, n + 1):\n        if post[r] == 0:\n            cur = t\n            dfs0(r, r)\n            for v in range(t - 1, cur - 1, -1):\n                r1 = rev[v]\n                if not visited[r1]:\n                    cr = cc.find(r1)\n                    dfs1(r1, r1, cr, visited)\n\n    another_paths = [None] * (n + 1)\n    for a, b in edges:\n        if another_paths[a] is None:\n            another_paths[a] = set()\n            find_another_paths(n, a, another_paths[a])\n\n\n    for a, b in edges:\n        scc_a = scc.find(a)\n        scc_b = scc.find(b)\n        exist = b in another_paths[a]\n        print('diff' if (scc_a == scc_b) ^ exist else 'same')\n\n\ndef main():\n    global e, re\n\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    edges = []\n    e = [[] for _ in range(n + 1)]\n    re = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b = input().split()\n        a = int(a)\n        b = int(b)\n        edges.append((a, b))\n        e[a].append(b)\n        re[b].append(a)\n\n\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    def dfs0(u, st=-1, en=-1):\n        if en == -1:\n            for i, ku in enumerate(to[u]):\n                if can[u][ku][0] != -1: continue\n                can[u][ku][0] = i\n                dfs0(ku, u, i)\n            return\n        for ku in to[u]:\n            if ku == st: continue\n            if can[st][ku][0] != -1: continue\n            can[st][ku][0] = en\n            dfs0(ku, st, en)\n\n    def dfs1(u, st=-1, en=-1):\n        if en == -1:\n            sz = len(to[u])\n            for i, ku in enumerate(to[u][::-1]):\n                if can[u][ku][1] != -1: continue\n                can[u][ku][1] = sz - 1 - i\n                dfs1(ku, u, sz - 1 - i)\n            return\n        for ku in to[u]:\n            if ku == st: continue\n            if can[st][ku][1] != -1: continue\n            can[st][ku][1] = en\n            dfs1(ku, st, en)\n\n    to = defaultdict(list)\n    n, m = map(int, input().split())\n    ee = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        a, b = a - 1, b - 1\n        to[a].append(b)\n        ee.append([a, b])\n    for v in to.values():\n        v.sort()\n    #print(to)\n    can = [[[-1] * 2 for _ in range(n)] for _ in range(n)]\n    fin = [False] * n\n    for u, v in ee:\n        for w in [u, v]:\n            if not fin[w]:\n                fin[w] = True\n                dfs0(w)\n                dfs1(w)\n        # print(u,v)\n        # print(can[u][v][0] == can[u][v][1])\n        # print(sum(can[v][u]) == -2)\n        if (can[u][v][0] == can[u][v][1]) == (sum(can[v][u]) == -2):\n            print(\"same\")\n        else:\n            print(\"diff\")\n    #for x in can:\n    #    print(x)\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\nuse std::collections::HashSet;\n\nfn main() {\n    input!{\n        n: usize,\n        m: usize,\n        es: [(usize1, usize1); m]\n    }\n    let mut g = vec![vec![]; n];\n    for &(a, b) in &es {\n        g[a].push(b);\n    }\n    let mut reach = vec![vec![false; n]; n];\n    let mut reach2 = vec![vec![false; n]; n];\n    for i in 0..n {\n        let mut done = vec![false; n];\n        done[i] = true;\n        for &j in &g[i] {\n            if done[j] {\n                reach2[i][j] = true;\n                continue;\n            }\n            done[j] = true;\n            dfs(j, &g, &mut done);\n        }\n        for j in 0..n {\n            reach[i][j] |= done[j];\n        }\n    }\n    for i in 0..n {\n        g[i].reverse();\n    }\n    for i in 0..n {\n        let mut done = vec![false; n];\n        done[i] = true;\n        for &j in &g[i] {\n            if done[j] {\n                reach2[i][j] = true;\n                continue;\n            }\n            done[j] = true;\n            dfs(j, &g, &mut done);\n        }\n    }\n    for &(a, b) in &es {\n        if reach[b][a] ^ reach2[a][b] {\n            println!(\"diff\");\n        } else {\n            println!(\"same\");\n        }\n    }\n}\n\nfn dfs(v: usize, g: &Vec<Vec<usize>>, done: &mut Vec<bool>) {\n    for &c in &g[v] {\n        if done[c] {\n            continue;\n        }\n        done[c] = true;\n        dfs(c, g, done);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\ntype Weight = i32;\n#[derive(Clone, Debug)]\nstruct Edge {\n    index: usize,\n    src: usize,\n    dest: usize,\n    weight: Weight,\n}\nimpl Edge {\n    fn new(index: usize, src: usize, dest: usize, weight: Weight) -> Edge {\n        Edge {\n            index: index,\n            src: src,\n            dest: dest,\n            weight: weight,\n        }\n    }\n}\ntype Edges = Vec<Edge>;\ntype Graph = Vec<Edges>;\nfn add_uni_edge(graph: &mut Graph, index: &mut usize, src: usize, dest: usize, weight: Weight) {\n    graph[src].push(Edge::new(*index, src, dest, weight));\n    *index += 1;\n}\n\nfn dfs(g: &Graph, from: usize, visited: &mut Vec<Option<usize>>, start_index: usize) {\n    if visited[from] != None { return; }\n    visited[from] = Some(start_index);\n    for edge in g[from].iter() {\n        dfs(g, edge.dest, visited, start_index);\n    }\n}\n\nfn main() {\n    let n: usize = read();\n    let m: usize = read();\n    let mut g: Graph = vec![vec![]; n];\n    let mut edges = vec![];\n    let mut visitable = vec![vec![false; n]; n];\n    let mut edge_delete_visitable = vec![true; m];\n    let mut e = 0;\n    for _ in 0..m {\n        let mut f: usize = read();\n        let mut t: usize = read();\n        f -= 1; t -= 1;\n        edges.push(Edge::new(e, f, t, 0));\n        add_uni_edge(&mut g, &mut e, f, t, 0);\n    }\n    for from in 0..n {\n        let mut min_value = vec![None; n];\n        let mut max_value = vec![None; n];\n        min_value[from] = Some(0);\n        max_value[from] = Some(0);\n        for edge in g[from].iter() {\n            dfs(&g, edge.dest, &mut min_value, edge.index);\n        }\n        for edge in g[from].iter().rev() {\n            dfs(&g, edge.dest, &mut max_value, edge.index);\n        }\n        for edge in g[from].iter() {\n            edge_delete_visitable[edge.index] = min_value[edge.dest].unwrap() != max_value[edge.dest].unwrap();\n        }\n        for to in 0..n {\n            visitable[from][to] = min_value[to] != None;\n        }\n    }\n    for edge in edges {\n        // println!(\"{} {}\", visitable[edge.dest][edge.src], edge_delete_visitable[edge.index]);\n        println!(\"{}\", if visitable[edge.dest][edge.src] == edge_delete_visitable[edge.index] { \"same\" } else { \"diff\" });\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\ntype Idx = i32;\nconst INF: Idx = 1 << 20;\n\nfn dfs<F>(g: &[Vec<(Idx, usize)>], lt: &F,\n          conn: &mut [Idx], v: usize, cur: Idx)\nwhere F: Fn(Idx, Idx) -> bool {\n    if !lt(cur, conn[v]) { return; }\n    conn[v] = cur;\n    for &(_, w) in g[v].iter() {\n        dfs(g, lt, conn, w, cur);\n    }\n}\n\nfn traverse<F>(g: &[Vec<(Idx, usize)>], lt: F, min: Idx) -> Vec<Vec<Idx>>\nwhere F: Fn(Idx, Idx) -> bool {\n    let n = g.len();\n    let mut conn = vec![vec![-min; n]; n];\n    for i in 0 .. n {\n        conn[i][i] = min;\n        for &(idx, w) in g[i].iter() {\n            dfs(&g, &lt, &mut conn[i], w, idx);\n        }\n    }\n    conn\n}\n\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        ab: [(usize1, usize1)],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (i, &(a, b)) in ab.iter().enumerate() {\n        g[a].push((i as Idx, b));\n    }\n    // increasing order\n    for adj in g.iter_mut() {\n        adj.sort();\n    }\n    let conn_orig = traverse(&g, |x, y| x < y, -INF);\n    // decreasing order\n    for adj in g.iter_mut() {\n        adj.reverse();\n    }\n    let conn_rev = traverse(&g, |x, y| x > y, INF);\n    for (i, (a, b)) in ab.into_iter().enumerate() {\n        let i = i as Idx;\n        let orig = conn_orig[a][b] != i || conn_rev[a][b] != i;\n        let rev = conn_orig[b][a] < INF;\n        puts!(\"{}\\n\", if orig ^ rev { \"diff\" } else { \"same\" });\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        eprintln!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n// ===\n\ntype DirectedGraph = Vec<Vec<usize>>;\n\nstruct StronglyConnectedComponent {\n    n: usize,\n    graph: DirectedGraph,\n    reversed_graph: DirectedGraph,\n    component_ids: Vec<usize>\n}\n\nimpl StronglyConnectedComponent {\n    fn new(g: DirectedGraph) -> Self {\n        let n = g.len();\n        let mut rg = vec![vec![]; n];\n        for i in 0..n {\n            for &to in &g[i] {\n                rg[to].push(i);\n            }\n        }\n        Self {\n            n: g.len(),\n            graph: g,\n            reversed_graph: rg,\n            component_ids: vec![]\n        }\n    }\n\n    fn decompose(&mut self) -> usize {\n        let mut visited = vec![false; self.n];\n        let mut rev_order = vec![];\n        for i in 0..self.n {\n            if !visited[i] {\n                self.dfs(i, &mut visited, &mut rev_order);\n            }\n        }\n\n        let mut visited = vec![false; self.n];\n        let mut id = 0;\n        let mut component_ids = vec![0; self.n];\n        for &r in rev_order.iter().rev() {\n            if !visited[r] {\n                self.rdfs(r, id, &mut visited, &mut component_ids);\n                id += 1;\n            }\n        }\n        self.component_ids = component_ids;\n        id\n    }\n\n    fn dfs(&self, now: usize, visited: &mut Vec<bool>, rev_order: &mut Vec<usize>) {\n        visited[now] = true;\n        for &to in &self.graph[now] {\n            if !visited[to] {\n                self.dfs(to, visited, rev_order);\n            }\n        }\n        rev_order.push(now);\n    }\n\n    fn rdfs(&self, now: usize, id: usize, visited: &mut Vec<bool>, component_ids: &mut Vec<usize>) {\n        visited[now] = true;\n        component_ids[now] = id;\n        for &to in &self.reversed_graph[now] {\n            if !visited[to] {\n                self.rdfs(to, id, visited, component_ids);\n            }\n        }\n    }\n}\n\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        edges: [(usize1, usize1); m]\n    };\n\n    let mut g = vec![vec![]; n];\n    for &e in &edges {\n        g[e.0].push(e.1);\n    }\n    let mut scc = StronglyConnectedComponent::new(g);\n    let gn = scc.decompose();\n\n    let mut change = vec![false; m];\n\n    let mut gg = vec![vec![]; gn];\n    let mut flag = dvec![m; gn, gn];\n\n\n    let mut indeg_in_component = vec![0; n];\n    let mut outdeg_in_component = vec![0; n];\n    for (&e, idx) in edges.iter().zip(0..m) {\n        let f = scc.component_ids[e.0];\n        let t = scc.component_ids[e.1];\n        if f != t {\n            if flag[f][t] == m {\n                flag[f][t] = idx;\n                gg[f].push(t);\n            } else {\n                change[idx] = true;\n                change[flag[f][t]] = true;\n            }\n        } else {\n            indeg_in_component[e.1] += 1;\n            outdeg_in_component[e.0] += 1;\n        }\n    }\n\n    for (&e, idx) in edges.iter().zip(0..m) {\n        let f = scc.component_ids[e.0];\n        let t = scc.component_ids[e.1];\n        if f == t {\n            change[idx] = outdeg_in_component[e.0] == 1 || indeg_in_component[e.1] == 1;\n        }\n    }\n\n\n    let mut visited = vec![gn; gn];\n    for i in 0..gn {\n        for &to in &gg[i] {\n            if visited[to] == i {\n                change[flag[i][to]] = true;\n            }\n            dfs(to, i, &mut visited, &gg);\n        }\n    }\n    for i in 0..gn {\n        gg[i].reverse();\n    }\n    let mut visited = vec![gn; gn];\n    for i in 0..gn {\n        for &to in &gg[i] {\n            if visited[to] == i {\n                change[flag[i][to]] = true;\n            }\n            dfs(to, i, &mut visited, &gg);\n        }\n    }\n\n    for i in 0..m {\n        if change[i] {\n            println!(\"diff\");\n        } else {\n            println!(\"same\");\n        }\n    }\n}\n\nfn dfs(now: usize, root: usize, visited: &mut Vec<usize>, graph: &Vec<Vec<usize>>) {\n    for &to in &graph[now] {\n        if visited[to] != root {\n            visited[to] = root;\n            dfs(to, root, visited, graph);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        eprintln!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n// ===\n\ntype DirectedGraph = Vec<Vec<usize>>;\n\nstruct StronglyConnectedComponent {\n    n: usize,\n    graph: DirectedGraph,\n    reversed_graph: DirectedGraph,\n    component_ids: Vec<usize>\n}\n\nimpl StronglyConnectedComponent {\n    fn new(g: DirectedGraph) -> Self {\n        let n = g.len();\n        let mut rg = vec![vec![]; n];\n        for i in 0..n {\n            for &to in &g[i] {\n                rg[to].push(i);\n            }\n        }\n        Self {\n            n: g.len(),\n            graph: g,\n            reversed_graph: rg,\n            component_ids: vec![]\n        }\n    }\n\n    fn decompose(&mut self) -> usize {\n        let mut visited = vec![false; self.n];\n        let mut rev_order = vec![];\n        for i in 0..self.n {\n            if !visited[i] {\n                self.dfs(i, &mut visited, &mut rev_order);\n            }\n        }\n\n        let mut visited = vec![false; self.n];\n        let mut id = 0;\n        let mut component_ids = vec![0; self.n];\n        for &r in rev_order.iter().rev() {\n            if !visited[r] {\n                self.rdfs(r, id, &mut visited, &mut component_ids);\n                id += 1;\n            }\n        }\n        self.component_ids = component_ids;\n        id\n    }\n\n    fn dfs(&self, now: usize, visited: &mut Vec<bool>, rev_order: &mut Vec<usize>) {\n        visited[now] = true;\n        for &to in &self.graph[now] {\n            if !visited[to] {\n                self.dfs(to, visited, rev_order);\n            }\n        }\n        rev_order.push(now);\n    }\n\n    fn rdfs(&self, now: usize, id: usize, visited: &mut Vec<bool>, component_ids: &mut Vec<usize>) {\n        visited[now] = true;\n        component_ids[now] = id;\n        for &to in &self.reversed_graph[now] {\n            if !visited[to] {\n                self.rdfs(to, id, visited, component_ids);\n            }\n        }\n    }\n}\n\nfn topological_sort(g: Vec<Vec<usize>>) -> i32 {\n    let n = g.len();\n    let mut indeg = vec![0; n];\n    for i in 0..n {\n        for &j in &g[i] {\n            indeg[j] += 1;\n        }\n    }\n    let mut que = VecDeque::new();\n    let mut dp = vec![-1i32; n];\n    let mut visited = vec![false; n];\n    for i in 0..n {\n        if indeg[i] == 0 {\n            que.push_back(i);\n            dp[i] = 0;\n            visited[i] = true;\n        }\n    }\n    while let Some(v) = que.pop_front() {\n        let now = dp[v];\n        for &j in &g[v] {\n            dp[j] = max(dp[j], now+1);\n            indeg[j] -= 1;\n            if indeg[j] == 0 {\n                que.push_back(j);\n                visited[j] = true;\n            }\n        }\n    }\n\n    let mut best = 0;\n    for i in 0..n {\n        if !visited[i] {\n            return -1;\n        }\n        best = max(best, dp[i]);\n    }\n    best+1\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        edges: [(usize1, usize1); m]\n    };\n\n    let mut g = vec![vec![]; n];\n    for &e in &edges {\n        g[e.0].push(e.1);\n    }\n\n    let mut scc = StronglyConnectedComponent::new(g);\n    let gn = scc.decompose();\n    let mut gg = vec![vec![]; gn];\n    let mut cango = dvec![false; gn, gn];\n    for i in 0..gn {\n        cango[i][i] = true;\n    }\n    for &e in &edges {\n        let f = scc.component_ids[e.0];\n        let t = scc.component_ids[e.1];\n        if f != t {\n            if !cango[f][t] {\n                cango[f][t] = true;\n                gg[f].push(t);\n            }\n        }\n    }\n\n    for i in 0..gn {\n        dfsg(i, i, &mut cango, &gg);\n    }\n\n    let mut flag = vec![0; m];\n    for (&e, idx) in edges.iter().zip(0..m) {\n        let f = scc.component_ids[e.0];\n        let t = scc.component_ids[e.1];\n        flag[idx] |= ifv!(cango[t][f], 1, 0);\n    }\n\n    let mut g = vec![vec![]; n];\n    for (&e, idx) in edges.iter().zip(0..m) {\n        g[e.0].push((e.1, idx));\n    }\n\n    for _w in 0..2 {\n        let mut visited = dvec![n; n];\n        for i in 0..n {\n            visited[i] = i;\n            for &(to, idx) in &g[i] {\n                if visited[to] == i {\n                    flag[idx] |= 2;\n                } else {\n                    visited[to] = i;\n                    dfs(to, i, &mut visited, &g);\n                }\n            }\n        }\n        for i in 0..n {\n            g[i].reverse();\n        }\n    }\n\n    for i in 0..m {\n        if flag[i] == 1 || flag[i] == 2 {\n            println!(\"diff\");\n        } else {\n            println!(\"same\");\n        }\n    }\n}\n\nfn dfsg(now: usize, root: usize, gg: &mut Vec<Vec<bool>>, graph: &Vec<Vec<usize>>) {\n    for &to in &graph[now] {\n        if !gg[root][to] {\n            gg[root][to] = true;\n            dfsg(to, root, gg, graph);\n        }\n    }\n}\n\nfn dfs(now: usize, root: usize, visited: &mut Vec<usize>, graph: &Vec<Vec<(usize, usize)>>) {\n    for &to in &graph[now] {\n        if visited[to.0] != root {\n            visited[to.0] = root;\n            dfs(to.0, root, visited, graph);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        eprintln!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\n// ===\n\ntype DirectedGraph = Vec<Vec<usize>>;\n\nstruct StronglyConnectedComponent {\n    n: usize,\n    graph: DirectedGraph,\n    reversed_graph: DirectedGraph,\n    component_ids: Vec<usize>\n}\n\nimpl StronglyConnectedComponent {\n    fn new(g: DirectedGraph) -> Self {\n        let n = g.len();\n        let mut rg = vec![vec![]; n];\n        for i in 0..n {\n            for &to in &g[i] {\n                rg[to].push(i);\n            }\n        }\n        Self {\n            n: g.len(),\n            graph: g,\n            reversed_graph: rg,\n            component_ids: vec![]\n        }\n    }\n\n    fn decompose(&mut self) -> usize {\n        let mut visited = vec![false; self.n];\n        let mut rev_order = vec![];\n        for i in 0..self.n {\n            if !visited[i] {\n                self.dfs(i, &mut visited, &mut rev_order);\n            }\n        }\n\n        let mut visited = vec![false; self.n];\n        let mut id = 0;\n        let mut component_ids = vec![0; self.n];\n        for &r in rev_order.iter().rev() {\n            if !visited[r] {\n                self.rdfs(r, id, &mut visited, &mut component_ids);\n                id += 1;\n            }\n        }\n        self.component_ids = component_ids;\n        id\n    }\n\n    fn dfs(&self, now: usize, visited: &mut Vec<bool>, rev_order: &mut Vec<usize>) {\n        visited[now] = true;\n        for &to in &self.graph[now] {\n            if !visited[to] {\n                self.dfs(to, visited, rev_order);\n            }\n        }\n        rev_order.push(now);\n    }\n\n    fn rdfs(&self, now: usize, id: usize, visited: &mut Vec<bool>, component_ids: &mut Vec<usize>) {\n        visited[now] = true;\n        component_ids[now] = id;\n        for &to in &self.reversed_graph[now] {\n            if !visited[to] {\n                self.rdfs(to, id, visited, component_ids);\n            }\n        }\n    }\n}\n\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        edges: [(usize1, usize1); m]\n    };\n\n    let mut g = vec![vec![]; n];\n    for &e in &edges {\n        g[e.0].push(e.1);\n    }\n    let mut scc = StronglyConnectedComponent::new(g);\n    let gn = scc.decompose();\n\n    let mut change = vec![false; m];\n\n    let mut gg = vec![vec![]; gn];\n    let mut flag = dvec![m; gn, gn];\n\n\n    let mut indeg_in_component = vec![0; n];\n    let mut outdeg_in_component = vec![0; n];\n    for (&e, idx) in edges.iter().zip(0..m) {\n        let f = scc.component_ids[e.0];\n        let t = scc.component_ids[e.1];\n        if f != t {\n            if flag[f][t] == m {\n                flag[f][t] = idx;\n                gg[f].push(t);\n            } else {\n                change[idx] = true;\n                change[flag[f][t]] = true;\n            }\n        } else {\n            indeg_in_component[e.1] += 1;\n            outdeg_in_component[e.0] += 1;\n        }\n    }\n\n    for (&e, idx) in edges.iter().zip(0..m) {\n        let f = scc.component_ids[e.0];\n        let t = scc.component_ids[e.1];\n        if f == t {\n            change[idx] = outdeg_in_component[e.0] == 1 || indeg_in_component[e.1] == 1;\n        }\n    }\n\n\n    let mut visited = vec![gn; gn];\n    for _w in 0..2 {\n        for i in 0..gn {\n            visited[i] = i;\n            for &to in &gg[i] {\n                if visited[to] == i {\n                    change[flag[i][to]] = true;\n                } else {\n                    dfs(to, i, &mut visited, &gg);\n                }\n            }\n        }\n        for i in 0..gn {\n            gg[i].reverse();\n        }\n    }\n\n    for i in 0..m {\n        if change[i] {\n            println!(\"diff\");\n        } else {\n            println!(\"same\");\n        }\n    }\n}\n\nfn dfs(now: usize, root: usize, visited: &mut Vec<usize>, graph: &Vec<Vec<usize>>) {\n    for &to in &graph[now] {\n        if visited[to] != root {\n            visited[to] = root;\n            dfs(to, root, visited, graph);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\ntype Idx = i32;\nconst INF: Idx = 1 << 20;\n\nfn dfs<F>(g: &[Vec<(Idx, usize)>], lt: &F,\n          conn: &mut [Idx], v: usize, cur: Idx)\nwhere F: Fn(Idx, Idx) -> bool {\n    if !lt(cur, conn[v]) { return; }\n    conn[v] = cur;\n    for &(_, w) in g[v].iter() {\n        dfs(g, lt, conn, w, cur);\n    }\n}\n\nfn traverse<F>(g: &[Vec<(Idx, usize)>], lt: F, min: Idx) -> Vec<Vec<Idx>>\nwhere F: Fn(Idx, Idx) -> bool {\n    let n = g.len();\n    let mut conn = vec![vec![-min; n]; n];\n    for i in 0 .. n {\n        conn[i][i] = min;\n        for &(idx, w) in g[i].iter() {\n            dfs(&g, &lt, &mut conn[i], w, idx);\n        }\n    }\n    conn\n}\n\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        m: usize,\n        ab: [(usize1, usize1); m],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (i, &(a, b)) in ab.iter().enumerate() {\n        g[a].push((i as Idx, b));\n    }\n    // increasing order\n    for i in 0 .. n {\n        g[i].sort();\n    }\n    let conn_orig = traverse(&g, |x, y| x < y, -INF);\n    // decreasing order\n    for i in 0 .. n {\n        g[i].reverse();\n    }\n    let conn_rev = traverse(&g, |x, y| x > y, INF);\n    // eprintln!(\"conn_orig = {:?}\", conn_orig);\n    // eprintln!(\"conn_rev  = {:?}\", conn_rev);\n    for (i, (a, b)) in ab.into_iter().enumerate() {\n        let i = i as Idx;\n        let orig = conn_orig[a][b] < i || conn_rev[a][b] > i;\n        let rev = conn_orig[b][a] < INF;\n        // eprintln!(\"({} {})\", orig, rev);\n        puts!(\"{}\\n\", if orig ^ rev { \"diff\" } else { \"same\" });\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Usize1};\n\nfn main() {\n    input!(n: usize, m: usize, ab: [(Usize1, Usize1); m]);\n    let mut g = vec![vec![]; n];\n    ab.iter().for_each(|&(a, b)| g[a].push(b));\n\n    let mut min_reachable = vec![vec![None; n]; n];\n    let mut max_reachable = vec![vec![None; n]; n];\n    for a in 0..n {\n        fn search(i: usize, a: usize, ckd: &mut [Option<usize>], g: &[Vec<usize>]) {\n            let c = g[a][i];\n            if ckd[c].is_some() {\n                return;\n            }\n            let mut que = std::collections::VecDeque::from(vec![c]);\n            ckd[c] = Some(i);\n            while let Some(x) = que.pop_front() {\n                for y in g[x].iter().copied().filter(|&y| y != a) {\n                    if ckd[y].is_some() {\n                        continue;\n                    }\n                    ckd[y] = Some(i);\n                    que.push_back(y);\n                }\n            }\n        }\n        for i in 0..g[a].len() {\n            search(i, a, &mut min_reachable[a], &g);\n        }\n        for i in (0..g[a].len()).rev() {\n            search(i, a, &mut max_reachable[a], &g);\n        }\n    }\n\n    for (a, b) in ab {\n        let a_to_b = min_reachable[a][b] != max_reachable[a][b];\n        let b_to_a = min_reachable[b][a].is_some();\n        println!(\"{}\", if a_to_b == b_to_a { \"same\" } else { \"diff\" });\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\ntype Idx = i32;\nconst INF: Idx = 1 << 20;\n\nfn dfs<F>(g: &[Vec<(Idx, usize)>], lt: &F,\n          conn: &mut [Idx], v: usize, cur: Idx)\nwhere F: Fn(Idx, Idx) -> bool {\n    if !lt(cur, conn[v]) { return; }\n    conn[v] = cur;\n    for &(_, w) in g[v].iter() {\n        dfs(g, lt, conn, w, cur);\n    }\n}\n\nfn traverse<F>(g: &[Vec<(Idx, usize)>], lt: F, min: Idx) -> Vec<Vec<Idx>>\nwhere F: Fn(Idx, Idx) -> bool {\n    let n = g.len();\n    let mut conn = vec![vec![-min; n]; n];\n    for i in 0 .. n {\n        conn[i][i] = min;\n        for &(idx, w) in g[i].iter() {\n            dfs(&g, &lt, &mut conn[i], w, idx);\n        }\n    }\n    conn\n}\n\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        ab: [(usize1, usize1)],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (i, &(a, b)) in ab.iter().enumerate() {\n        g[a].push((i as Idx, b));\n    }\n    // g[i] is already in the increasing order\n    let conn_orig = traverse(&g, |x, y| x < y, -INF);\n    // decreasing order\n    for adj in g.iter_mut() {\n        adj.reverse();\n    }\n    let conn_rev = traverse(&g, |x, y| x > y, INF);\n    for (i, (a, b)) in ab.into_iter().enumerate() {\n        let i = i as Idx;\n        let orig = conn_orig[a][b] != i || conn_rev[a][b] != i;\n        let rev = conn_orig[b][a] < INF;\n        puts!(\"{}\\n\", if orig ^ rev { \"diff\" } else { \"same\" });\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]