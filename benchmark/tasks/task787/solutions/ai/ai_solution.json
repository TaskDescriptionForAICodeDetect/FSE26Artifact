[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100005\n#define MAX_M 100005\n\nint parent[MAX_N], rank[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int px = find(x), py = find(y);\n    if (px == py) return;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else {\n        parent[py] = px;\n        if (rank[px] == rank[py])\n            rank[px]++;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int A[MAX_M], B[MAX_M];\n    for (int i = 0; i < M; i++)\n        scanf(\"%d %d\", &A[i], &B[i]);\n    \n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    int total_pairs = N * (N - 1) / 2;\n    int connectible_pairs = 0;\n    \n    int result[MAX_M];\n    \n    for (int m = M - 1; m >= 0; m--) {\n        unite(A[m], B[m]);\n        \n        connectible_pairs = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = i + 1; j <= N; j++) {\n                if (find(i) == find(j))\n                    connectible_pairs++;\n            }\n        }\n        \n        result[m] = total_pairs - connectible_pairs;\n    }\n    \n    for (int i = 0; i < M; i++)\n        printf(\"%d\\n\", result[i]);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:54:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int parent;\n    int size;\n} Node;\n\nNode *nodes;\n\nint find(int u) {\n    if (nodes[u].parent != u) {\n        nodes[u].parent = find(nodes[u].parent);\n    }\n    return nodes[u].parent;\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (nodes[u].size < nodes[v].size) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    nodes[v].parent = u;\n    nodes[u].size += nodes[v].size;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int (*bridges)[2] = malloc(M * sizeof(*bridges));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &bridges[i][0], &bridges[i][1]);\n        bridges[i][0]--;\n        bridges[i][1]--;\n    }\n\n    nodes = malloc(N * sizeof(*nodes));\n    for (int i = 0; i < N; i++) {\n        nodes[i].parent = i;\n        nodes[i].size = 1;\n    }\n\n    long long total_pairs = (long long)N * (N - 1) / 2;\n    long long *result = malloc(M * sizeof(*result));\n    result[M-1] = total_pairs;\n\n    for (int i = M - 1; i > 0; i--) {\n        int a = bridges[i][0];\n        int b = bridges[i][1];\n        int root_a = find(a);\n        int root_b = find(b);\n        if (root_a != root_b) {\n            result[i-1] = result[i] - (long long)nodes[root_a].size * nodes[root_b].size;\n            union_sets(a, b);\n        } else {\n            result[i-1] = result[i];\n        }\n    }\n\n    for (int i = 0; i < M; i++) {\n        printf(\"%lld\\n\", total_pairs - result[i]);\n    }\n\n    free(bridges);\n    free(nodes);\n    free(result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nstruct DSU {\n    vector<int> parent;\n    vector<int> size;\n    long long pairs;\n\n    DSU(int n) {\n        parent.resize(n + 1);\n        size.resize(n + 1, 1);\n        for (int i = 1; i <= n; ++i) {\n            parent[i] = i;\n        }\n        pairs = (long long)n * (n - 1) / 2;\n    }\n\n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    void unite(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return;\n        if (size[u] < size[v]) swap(u, v);\n        pairs -= (long long)size[u] * size[v];\n        parent[v] = u;\n        size[u] += size[v];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> bridges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> bridges[i].first >> bridges[i].second;\n    }\n\n    DSU dsu(N);\n    vector<long long> res(M);\n    for (int i = M - 1; i >= 0; --i) {\n        res[i] = dsu.pairs;\n        int a = bridges[i].first;\n        int b = bridges[i].second;\n        dsu.unite(a, b);\n    }\n\n    for (long long r : res) {\n        cout << r << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class DSU {\n        private int[] parent;\n        private int[] size;\n        private long pairs;\n\n        public DSU(int n) {\n            parent = new int[n + 1];\n            size = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                parent[i] = i;\n                size[i] = 1;\n            }\n            pairs = (long) n * (n - 1) / 2;\n        }\n\n        public int find(int u) {\n            if (parent[u] != u) {\n                parent[u] = find(parent[u]);\n            }\n            return parent[u];\n        }\n\n        public long getPairs() {\n            return pairs;\n        }\n\n        public void union(int u, int v) {\n            int rootU = find(u);\n            int rootV = find(v);\n            if (rootU == rootV) return;\n            if (size[rootU] < size[rootV]) {\n                int temp = rootU;\n                rootU = rootV;\n                rootV = temp;\n            }\n            pairs -= (long) size[rootU] * size[rootV];\n            parent[rootV] = rootU;\n            size[rootU] += size[rootV];\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n\n        int[][] bridges = new int[M][2];\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            bridges[i][0] = Integer.parseInt(st.nextToken());\n            bridges[i][1] = Integer.parseInt(st.nextToken());\n        }\n\n        DSU dsu = new DSU(N);\n        long[] res = new long[M];\n        res[M - 1] = 0;\n        for (int i = M - 1; i > 0; i--) {\n            int a = bridges[i][0];\n            int b = bridges[i][1];\n            res[i - 1] = dsu.getPairs();\n            dsu.union(a, b);\n        }\n\n        for (long num : res) {\n            pw.println(num);\n        }\n        pw.flush();\n    }\n}",
    "timestamp": "2025-08-05 22:55:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        int components;\n\n        UnionFind(int n) {\n            parent = new int[n + 1];\n            rank = new int[n + 1];\n            components = n;\n            for (int i = 1; i <= n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return false;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            components--;\n            return true;\n        }\n    }\n\n    public static int[] solve(int N, int[] A, int[] B) {\n        int M = A.length;\n        int[] result = new int[M];\n        boolean[] bridgeExists = new boolean[M];\n        \n        // Initially all bridges exist\n        for (int i = 0; i < M; i++) {\n            bridgeExists[i] = true;\n        }\n        \n        // Reverse process from last bridge to first\n        for (int i = M - 1; i >= 0; i--) {\n            UnionFind uf = new UnionFind(N);\n            \n            // Add back existing bridges\n            for (int j = 0; j < M; j++) {\n                if (j != i && bridgeExists[j]) {\n                    uf.union(A[j], B[j]);\n                }\n            }\n            \n            // Calculate unreachable pairs\n            int unreachablePairs = (N * (N - 1)) / 2 - countReachablePairs(uf, N);\n            result[i] = unreachablePairs;\n            \n            // Remove current bridge\n            bridgeExists[i] = false;\n        }\n        \n        return result;\n    }\n\n    private static int countReachablePairs(UnionFind uf, int N) {\n        int reachablePairs = 0;\n        Map<Integer, Integer> componentSizes = new HashMap<>();\n        \n        for (int i = 1; i <= N; i++) {\n            int root = uf.find(i);\n            componentSizes.put(root, componentSizes.getOrDefault(root, 0) + 1);\n        }\n        \n        for (int size : componentSizes.values()) {\n            reachablePairs += (size * (size - 1)) / 2;\n        }\n        \n        return reachablePairs;\n    }\n}",
    "timestamp": "2025-08-05 22:56:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    \n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else {\n            parent[py] = px;\n            if (rank[px] == rank[py]) {\n                rank[px]++;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<pair<int, int>> bridges(M);\n    for (int i = 0; i < M; i++) {\n        cin >> bridges[i].first >> bridges[i].second;\n        bridges[i].first--;\n        bridges[i].second--;\n    }\n    \n    vector<int> result(M);\n    for (int i = M - 1; i >= 0; i--) {\n        UnionFind uf(N);\n        int unreachable_pairs = N * (N - 1) / 2;\n        \n        for (int j = 0; j < M; j++) {\n            if (j == i) continue;\n            uf.unite(bridges[j].first, bridges[j].second);\n        }\n        \n        for (int x = 0; x < N; x++) {\n            for (int y = x + 1; y < N; y++) {\n                if (uf.find(x) == uf.find(y)) {\n                    unreachable_pairs--;\n                }\n            }\n        }\n        \n        result[i] = unreachable_pairs;\n    }\n    \n    for (int x : result) {\n        cout << x << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            if self.rank[root_u] > self.rank[root_v]:\n                self.parent[root_v] = root_u\n                self.size[root_u] += self.size[root_v]\n            elif self.rank[root_u] < self.rank[root_v]:\n                self.parent[root_u] = root_v\n                self.size[root_v] += self.size[root_u]\n            else:\n                self.parent[root_v] = root_u\n                self.rank[root_u] += 1\n                self.size[root_u] += self.size[root_v]\n\n    def get_size(self, u):\n        return self.size[self.find(u)]\n\ndef island_inconvenience(n, bridges):\n    uf = UnionFind(n)\n    inconvenience = [0] * len(bridges)\n    current_inconvenience = (n * (n - 1)) // 2\n    \n    for i in range(len(bridges) - 1, -1, -1):\n        inconvenience[i] = current_inconvenience\n        a, b = bridges[i]\n        if uf.find(a) != uf.find(b):\n            size_a = uf.get_size(a)\n            size_b = uf.get_size(b)\n            current_inconvenience -= size_a * size_b\n            uf.union(a, b)\n    \n    return inconvenience[::-1]\n\n# Example on how to use the function:\n# N = number of islands\n# M = number of bridges\n# bridges = list of tuples (A_i, B_i)\n\nN = 5\nbridges = [(0, 1), (1, 2), (2, 3), (0, 4)]\nprint(island_inconvenience(N, bridges))",
    "timestamp": "2025-08-13 12:58:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class IslandInconvenience {\n    static class UnionFind {\n        private int[] parent;\n        private int[] size;\n        \n        public UnionFind(int n) {\n            parent = new int[n];\n            size = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        public int find(int p) {\n            if (parent[p] != p) {\n                parent[p] = find(parent[p]);\n            }\n            return parent[p];\n        }\n\n        public void union(int p, int q) {\n            int rootP = find(p);\n            int rootQ = find(q);\n\n            if (rootP != rootQ) {\n                if (size[rootP] < size[rootQ]) {\n                    parent[rootP] = rootQ;\n                    size[rootQ] += size[rootP];\n                } else {\n                    parent[rootQ] = rootP;\n                    size[rootP] += size[rootQ];\n                }\n            }\n        }\n\n        public int connectedComponents() {\n            Set<Integer> components = new HashSet<>();\n            for (int i = 0; i < parent.length; i++) {\n                components.add(find(i));\n            }\n            return components.size();\n        }\n        \n        public int sizeOf(int p) {\n            return size[find(p)];\n        }\n    }\n\n    public static long[] findInconveniences(int n, int m, int[] a, int[] b) {\n        UnionFind uf = new UnionFind(n);\n        long[] inconvenience = new long[m];\n        long totalPairs = (long) n * (n - 1) / 2;\n\n        for (int i = m - 1; i >= 0; i--) {\n            int islandA = a[i] - 1;\n            int islandB = b[i] - 1;\n\n            if (uf.find(islandA) != uf.find(islandB)) {\n                long sizeA = uf.sizeOf(islandA);\n                long sizeB = uf.sizeOf(islandB);\n                uf.union(islandA, islandB);\n                totalPairs -= sizeA * sizeB;\n            }\n\n            inconvenience[i] = totalPairs;\n        }\n\n        return inconvenience;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] a = new int[m];\n        int[] b = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            a[i] = scanner.nextInt();\n            b[i] = scanner.nextInt();\n        }\n\n        long[] result = findInconveniences(n, m, a, b);\n        for (long inc : result) {\n            System.out.println(inc);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 12:58:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int parent;\n    int size;\n} UnionFind;\n\n// UnionFind initialization\nUnionFind* createUnionFind(int n) {\n    UnionFind* uf = (UnionFind*)malloc(n * sizeof(UnionFind));\n    for (int i = 0; i < n; ++i) {\n        uf[i].parent = i;\n        uf[i].size = 1;\n    }\n    return uf;\n}\n\n// Find function with path compression\nint find(UnionFind* uf, int x) {\n    if (uf[x].parent != x) {\n        uf[x].parent = find(uf, uf[x].parent);\n    }\n    return uf[x].parent;\n}\n\n// Union function with union by size\nvoid unionSets(UnionFind* uf, int x, int y) {\n    int rootX = find(uf, x);\n    int rootY = find(uf, y);\n    if (rootX != rootY) {\n        if (uf[rootX].size < uf[rootY].size) {\n            uf[rootX].parent = rootY;\n            uf[rootY].size += uf[rootX].size;\n        } else {\n            uf[rootY].parent = rootX;\n            uf[rootX].size += uf[rootY].size;\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int A[M], B[M];\n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n        --A[i]; // adjusting 1-based index to 0-based\n        --B[i]; // adjusting 1-based index to 0-based\n    }\n    \n    UnionFind* uf = createUnionFind(N);\n    long long totalPairs = (long long)N * (N - 1) / 2;\n    long long currentPairs = totalPairs;\n    long long inconveniences[M];\n    \n    for (int i = M - 1; i >= 0; --i) {\n        conveniences[i] = currentPairs;\n        int rootA = find(uf, A[i]);\n        int rootB = find(uf, B[i]);\n        \n        if (rootA != rootB) {\n            long long sizeA = uf[rootA].size;\n            long long sizeB = uf[rootB].size;\n            currentPairs -= sizeA * sizeB;\n            unionSets(uf, A[i], B[i]);\n        }\n    }\n    \n    for (int i = 0; i < M; ++i) {\n        printf(\"%lld\\n\", inconveniences[i]);\n    }\n    \n    free(uf);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:58:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent, size;\n    \n    UnionFind(int n) : parent(n), size(n, 1) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] == x) {\n            return x;\n        } else {\n            return parent[x] = find(parent[x]);\n        }\n    }\n\n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (size[rootX] < size[rootY]) {\n                swap(rootX, rootY);\n            }\n\n            parent[rootY] = rootX;\n            size[rootX] += size[rootY];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    int componentSize(int x) {\n        return size[find(x)];\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> bridges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> bridges[i].first >> bridges[i].second;\n        --bridges[i].first;\n        --bridges[i].second;\n    }\n\n    long long currentPairs = static_cast<long long>(N) * (N - 1) / 2;\n    vector<long long> inconveniences(M);\n\n    UnionFind uf(N);\n\n    for (int i = M - 1; i >= 0; --i) {\n        inconveniences[i] = currentPairs;\n        int u = bridges[i].first;\n        int v = bridges[i].second;\n\n        if (uf.find(u) != uf.find(v)) {\n            long long sizeU = uf.componentSize(u);\n            long long sizeV = uf.componentSize(v);\n\n            currentPairs -= sizeU * sizeV;\n            uf.unite(u, v);\n        }\n    }\n\n    for (int i = 0; i < M; ++i) {\n        cout << inconveniences[i] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:58:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.components = n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        self.components -= 1\n        return True\n\ndef solve_bridge_collapse(N, bridges):\n    total_pairs = N * (N - 1) // 2\n    result = []\n    \n    for i in range(len(bridges)):\n        uf = UnionFind(N)\n        \n        # Connect bridges up to but not including the current bridge\n        for j in range(len(bridges)):\n            if j != i:\n                uf.union(bridges[j][0] - 1, bridges[j][1] - 1)\n        \n        # Count unreachable pairs\n        current_pairs = uf.components * (uf.components - 1) // 2\n        result.append(total_pairs - current_pairs)\n    \n    return result\n\n# Example usage\nN = 4\nM = 3\nbridges = [(1, 2), (2, 3), (3, 4)]\nprint(solve_bridge_collapse(N, bridges))",
    "timestamp": "2025-08-13 12:58:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom sys import stdin\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    N, M = map(int, stdin.readline().split())\n    bridges = []\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        bridges.append((a-1, b-1))  # converting to 0-based\n\n    parent = [i for i in range(N)]\n    size = [1]*N\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return 0\n        if size[u_root] < size[v_root]:\n            u_root, v_root = v_root, u_root\n        parent[v_root] = u_root\n        res = size[u_root] * size[v_root]\n        size[u_root] += size[v_root]\n        return res\n\n    total_pairs = N * (N - 1) // 2\n    res = [total_pairs]\n    # Process bridges in reverse order\n    for a, b in reversed(bridges[1:]):\n        res.append(res[-1] - union(a, b))\n    res.reverse()\n    for num in res:\n        print(num)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:58:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class UnionFind {\n    constructor(size) {\n        this.parent = Array.from({ length: size }, (_, i) => i);\n        this.rank = Array(size).fill(1);\n        this.componentSize = Array(size).fill(1);\n        this.totalPairs = ((size - 1) * (size - 2)) / 2;\n    }\n\n    find(x) {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]);\n        }\n        return this.parent[x];\n    }\n\n    union(x, y) {\n        let rootX = this.find(x);\n        let rootY = this.find(y);\n\n        if (rootX !== rootY) {\n            if (this.rank[rootX] > this.rank[rootY]) {\n                this.parent[rootY] = rootX;\n                this.totalPairs -= this.componentSize[rootX] * this.componentSize[rootY];\n                this.componentSize[rootX] += this.componentSize[rootY];\n            } else if (this.rank[rootX] < this.rank[rootY]) {\n                this.parent[rootX] = rootY;\n                this.totalPairs -= this.componentSize[rootX] * this.componentSize[rootY];\n                this.componentSize[rootY] += this.componentSize[rootX];\n            } else {\n                this.parent[rootY] = rootX;\n                this.totalPairs -= this.componentSize[rootX] * this.componentSize[rootY];\n                this.componentSize[rootX] += this.componentSize[rootY];\n                this.rank[rootX]++;\n            }\n        }\n    }\n}\n\nfunction findInconveniences(N, M, bridges) {\n    let results = [];\n    let uf = new UnionFind(N + 1);\n\n    for (let i = M - 1; i >= 0; i--) {\n        results[i] = uf.totalPairs;\n        let [a, b] = bridges[i];\n        uf.union(a, b);\n    }\n\n    return results;\n}",
    "timestamp": "2025-08-13 12:59:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, M, bridges) {\n    let parent = new Array(N + 1).fill(0).map((_, i) => i);\n    let rank = new Array(N + 1).fill(0);\n    let connectedComponents = N;\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(x, y) {\n        let rootX = find(x);\n        let rootY = find(y);\n\n        if (rootX !== rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                [rootX, rootY] = [rootY, rootX];\n            }\n            parent[rootY] = rootX;\n            if (rank[rootX] === rank[rootY]) {\n                rank[rootX]++;\n            }\n            connectedComponents--;\n            return true;\n        }\n        return false;\n    }\n\n    let result = [];\n    let reversedBridges = bridges.slice().reverse();\n\n    let initialPairs = (N * (N - 1)) / 2;\n    let currentPairs = initialPairs;\n\n    for (let [a, b] of reversedBridges) {\n        let beforeUnion = connectedComponents;\n        union(a, b);\n        let afterUnion = connectedComponents;\n\n        if (beforeUnion !== afterUnion) {\n            currentPairs -= (beforeUnion * (beforeUnion - 1)) / 2 - (afterUnion * (afterUnion - 1)) / 2;\n        }\n\n        result.unshift(currentPairs);\n    }\n\n    return result;\n}",
    "timestamp": "2025-08-13 12:59:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class UnionFind {\n    constructor(size) {\n        this.parent = Array.from({ length: size + 1 }, (_, i) => i);\n        this.size = Array(size + 1).fill(1);\n    }\n\n    find(u) {\n        if (this.parent[u] !== u) {\n            this.parent[u] = this.find(this.parent[u]);\n        }\n        return this.parent[u];\n    }\n\n    union(u, v) {\n        const rootU = this.find(u);\n        const rootV = this.find(v);\n        if (rootU === rootV) return false;\n\n        if (this.size[rootU] > this.size[rootV]) {\n            this.parent[rootV] = rootU;\n            this.size[rootU] += this.size[rootV];\n        } else {\n            this.parent[rootU] = rootV;\n            this.size[rootV] += this.size[rootU];\n        }\n        return true;\n    }\n}\n\nfunction solve() {\n    const input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const bridges = input.slice(1, M + 1).map(line => line.split(' ').map(Number));\n\n    const uf = new UnionFind(N);\n    let totalPairs = N * (N - 1) / 2;\n    const result = [];\n    const components = new Map();\n    for (let i = 1; i <= N; i++) {\n        components.set(i, 1);\n    }\n\n    const answers = Array(M).fill(0);\n    let currentInconvenience = 0;\n    const reverseBridges = bridges.slice().reverse();\n    const ufReverse = new UnionFind(N);\n\n    for (let i = M - 1; i >= 0; i--) {\n        const [a, b] = reverseBridges[i];\n        const rootA = ufReverse.find(a);\n        const rootB = ufReverse.find(b);\n        if (rootA !== rootB) {\n            currentInconvenience += ufReverse.size[rootA] * ufReverse.size[rootB];\n            ufReverse.union(a, b);\n        }\n        answers[i] = currentInconvenience;\n    }\n\n    for (let i = 0; i < M; i++) {\n        if (i === M - 1) {\n            result.push(0);\n        } else {\n            result.push(answers[i + 1]);\n        }\n    }\n\n    console.log(result.join('\\n'));\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:59:49"
  }
]