[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = int;\nusing MAP_t = map<PR, int>;\n\nint encode(int x, int y) { return 3000 * x + y; }\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\nint merge(int idx1, int idx2, MAP_t& dest) {\n    dest = boards[idx1];\n    int res_v = scores[idx1];\n\n    for (const pair<PR, int>& itr : boards[idx2]) {\n        res_v += itr.second - dest[itr.first];\n        dest[itr.first] = itr.second;\n    }\n\n    return res_v;\n}\n\nint solve() {\n    MAP_t trg;\n\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            int sc = merge((1 << i), m, trg);\n            if (sc > scores[n]) {\n                boards[n] = trg;\n                scores[n] = sc;\n            }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores + (1 << N), 0);\n        for (int i = 0; i < (1 << N); ++i) boards[i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            x += 1000; y += 1000;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][encode(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                PR key = encode(x, y);\n                sc += d.d - boards[idx][key];\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint n;\nstruct dat{\n  int x,y;Dice d;\n  string rot;\n};\ndat A[N];\ntypedef pair<short,short> P;\ntypedef map<P,int> M;\n\nint getScore(M &mp){\n  int res = 0;\n  for(pair<P,int> p:mp) res += p.second;\n  return res;\n}\n\nM getNx(dat a,M res){\n  static int dx[1<<8]={},dy[1<<8]={};\n  dx['L'] = -1, dx['R'] = 1;\n  dy['F'] = -1, dy['B'] = 1;\n\n  int x = a.x, y = a.y;  \n  Dice d = a.d;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:a.rot){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nbool compare(const dat a,const dat b){\n  M p = getNx(a,getNx(b,M()));\n  M q = getNx(b,getNx(a,M()));\n  return getScore(p) < getScore(q);\n}\n\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      string rot;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot;\n      A[i] = (dat){x,y,Dice(l,r,f,b,d,u),rot};\n    }\n    sort(A,A+n,compare);\n    M ans;\n    for(int i=0;i<n;i++) ans = getNx(A[i],ans);\n    cout<<getScore(ans)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n// top front right left back bottom\n//front\nvoid S(vector<int>&in){\n  int tmp=in[1];\n  in[1]=in[0];\n  in[0]=in[4];\n  in[4]=in[5];\n  in[5]=tmp;\n}\n//right\nvoid E(vector<int>&in){\n  int tmp=in[2];\n  in[2]=in[0];\n  in[0]=in[3];\n  in[3]=in[5];\n  in[5]=tmp;\n}\n//turn\nvoid T(vector<int>&in){\n  int tmp=in[1];\n  in[1]=in[2];\n  in[2]=in[4];\n  in[4]=in[3];\n  in[3]=tmp;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<vip>in(n);\n\t\trep(i,n){\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tvi t(6);\n// top front right left back bottom\n\t\t\tcin>>t[3]>>t[2]>>t[1]>>t[4]>>t[5]>>t[0];\n\t\t\tstring s;cin>>s;\n\t\t\tin[i].pb({t[5],{x,y}});\n\t\t\trep(j,s.size()){\n\t\t\t\tif(s[j]=='R')E(t),x++;\n\t\t\t\tif(s[j]=='L')E(t),E(t),E(t),x--;\n\t\t\t\tif(s[j]=='F')S(t),y--;\n\t\t\t\tif(s[j]=='B')S(t),S(t),S(t),y++;\n\t\t\t\trep(k,in[i].size())if(in[i][k].second==pii(x,y)){in[i][k].first=t[5];goto end;}\n\t\t\t\tin[i].pb({t[5],{x,y}});\n\t\t\t\tend:;\n\t\t\t}\n\t\t}\n\t\tint N=1<<n;\n\t\tvi dp(N,-inf);\n\t\tdp[0]=0;\n\t\trep(i,N){\n\t\t\tmap<pii,int>ma;\n\t\t\trep(j,n)if(i&1<<j)rep(k,in[j].size())ma[in[j][k].second]=1;\n\t\t\trep(j,n)if((i&1<<j)==0){\n\t\t\t\tint sum=0;\n\t\t\t\trep(k,in[j].size())if(ma.count(in[j][k].second)==0)\n\t\t\t\t\tsum+=in[j][k].first;\n\t\t\t\tcmax(dp[i|1<<j],dp[i]+sum);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[N-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i=j; i<k;++i)\n#define rep(i,j) reps(i,0,j)\n#define pb emplace_back\n#define mk make_pair\ntypedef vector<int> Dice;\nenum{TOP, FRONT, RIGHT, LEFT, BACK, BOTTOM};\n#define rotate_swap(x,a,b,c,d) swap(x[a],x[b]);swap(x[b],x[c]);swap(x[c],x[d]);\nvoid rotate_r(Dice& dice){rotate_swap(dice, TOP, LEFT, BOTTOM, RIGHT);}\nvoid rotate_l(Dice& dice){rotate_swap(dice, TOP, RIGHT, BOTTOM, LEFT);}\nvoid rotate_f(Dice& dice){rotate_swap(dice, TOP, BACK, BOTTOM, FRONT);}\nvoid rotate_b(Dice& dice){rotate_swap(dice, TOP, FRONT, BOTTOM, BACK);}\nvector< map<pair<int,int>, int>> data;\nint N;\nint memo[1<<15];\nint solve(int depth, int bit, map<pair<int, int> ,int> field){\n\tif(depth == N){\n\t\treturn 0;\n\t}\n\tif(memo[bit] != -1){\n\t\treturn memo[bit];\n\t}\n\tmap<pair<int, int> , int> tmp = field;\n\tint mx = -1;\n\trep(i,N){\n\t\tif(!(1&(bit>>i))){\n\t\t\tint sum = 0;\n\t\t\tfor(auto j : data[i]){\n\t\t\t\tsum += j.second - tmp[j.first];\n\t\t\t}\n\t\t\tfor(auto j : data[i]){\n\t\t\t\ttmp[j.first] = j.second;\n\t\t\t}\n\t\t\tmx = max(mx, solve(depth+1,bit | (1<<i), tmp) + sum);\n\t\t\ttmp = field;\n\t\t}\n\t}\n\n\treturn memo[bit] = mx;\n\n}\nint main(){\n\twhile(true){\n\t\tcin >> N;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\tdata.clear();\n\t\tmemset(memo,-1,sizeof(memo));\n\t\trep(i,N){\n\t\t\tmap<pair<int,int>,int> field;\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tint l,r,f,b,d,u;\n\t\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\t\tDice dice = {u,f,r,l,b,d};\n\t\t\tstring rot;\n\t\t\tcin >> rot;\n\t\t\tfield[mk(y,x)] = dice[5];\n\t\t\trep(i,rot.size()){\n\t\t\t\tif(rot[i] == 'R'){\n\t\t\t\t\t++x;\n\t\t\t\t\trotate_r(dice);\n\t\t\t\t\tfield[mk(y,x)] = dice[5];\n\t\t\t\t}\n\t\t\t\telse if(rot[i] == 'B'){\n\t\t\t\t\t++y;\n\t\t\t\t\trotate_b(dice);\n\t\t\t\t\tfield[mk(y,x)] = dice[5];\n\t\t\t\t}\n\t\t\t\telse if(rot[i] == 'L'){\n\t\t\t\t\t--x;\n\t\t\t\t\trotate_l(dice);\n\t\t\t\t\tfield[mk(y,x)] = dice[5];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t--y;\n\t\t\t\t\trotate_f(dice);\n\t\t\t\t\tfield[mk(y,x)] = dice[5];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(auto j : field){\n\t\t\t\tprintf(\"(%d,%d) = %d\\n\",j.first.first, j.first.second, j.second);\n\t\t\t}*/\n\t\t\tdata.pb(field);\n\t\t}\n\t\tmap<pair<int, int>, int> clr;\n\t\tcout << solve(0, 0, clr) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 19191919;\n\nstruct Dice{\n    int x,y;\n    int l,r,f,b,d,u;\n\n    void read(){\n        cin >>x >>y >>l >>r >>f >>b >>d >>u;\n    }\n\n    void rot(char c){\n        int tmp;\n        if(c=='L'){\n            --x;\n            tmp = u;\n            u = r;\n            r = d;\n            d = l;\n            l = tmp;\n        }\n        else if(c=='R'){\n            ++x;\n            tmp = u;\n            u = l;\n            l = d;\n            d = r;\n            r = tmp;\n        }\n        else if(c=='F'){\n            --y;\n            tmp = u;\n            u = b;\n            b = d;\n            d = f;\n            f = tmp;\n        }\n        else if(c=='B'){\n            ++y;\n            tmp = u;\n            u = f;\n            f = d;\n            d = b;\n            b = tmp;\n        }\n    }\n\n    pi pos(){\n        return {x,y};\n    }\n\n    int val(){\n        return d;\n    }\n};\n\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        map<pi,int> cov;\n        vector<map<pi,int>> D(n);\n        rep(i,n){\n            Dice a;\n            a.read();\n            string rot;\n            cin >>rot;\n\n            map<pi,int> m;\n            m[a.pos()] = a.val();\n            for(char c:rot){\n                a.rot(c);\n                m[a.pos()] = a.val();\n            }\n\n            for(const auto &p:m){\n                cov[p.fi] |= (1<<i);\n            }\n            D[i] = m;\n        }\n\n        vector<int> dp(1<<n, -INF);\n        dp[0] = 0;\n        rep(mask,1<<n){\n            rep(i,n)if(!(mask>>i&1)){\n                int nmask = mask|(1<<i);\n\n                int add = 0;\n                for(const auto &p:D[i]){\n                    if((nmask|cov[p.fi]) == nmask) add += p.se;\n                }\n                dp[nmask] = max(dp[nmask], dp[mask]+add);\n            }\n        }\n        cout << dp[(1<<n)-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\n\nint n;\nstruct dat{int x,y;Dice d;};\ntypedef pair<short,short> P;\ntypedef map<P,int> M;\ntypedef set<P> S;\n\nM dice[N];\nM getMove(int x,int y,Dice d,string rot){\n  static int dx[1<<8]={},dy[1<<8]={};\n  dx['L'] = -1, dx['R'] = 1,dy['F'] = -1, dy['B'] = 1;\n  M res;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\npair<S,int> getNx(int idx,S used,int score){\n  for(pair<P,int>const &p:dice[idx]){\n    if(used.count(p.first)) continue;\n    used.insert(p.first);\n    score += p.second;\n  }\n  return make_pair(used,score);\n}\n\nint DP(){\n  map<S,int> dp[1<<N];\n  int res = 0;\n  dp[0][S()] = 0;\n  for(int bit=0;bit<(1<<n);dp[bit].clear(),bit++){\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      for(pair<S,int>const  &p:dp[bit]){\n        int nbit = bit | (1<<i);\n        pair<S,int> nx = getNx(i,p.first,p.second);\n        Max(dp[nbit][nx.first],nx.second);\n        Max(res,nx.second);\n      }\n    }\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      string rot;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot;\n      dice[i] = getMove(x,y,Dice(l,r,f,b,d,u),rot);\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\n//上、前、右、奥、左、下の順に\nstruct dice {\n\tint f[6];\n\tdice() {}\n\tdice(const vector<int> &v) {\n\t\trep(i, 6)f[i] = v[i];\n\t}\n\tdice(int x) {\n\t\trep(i, 6) {\n\t\t\tf[i] = x % 2;\n\t\t\tx /= 2;\n\t\t}\n\t}\n};\ndice ident(int a, int b) {\n\tdice res;\n\tint c;\n\tif (a == 1) {\n\t\tif (b == 2)c = 3;\n\t\telse if (b == 3)c = 5;\n\t\telse if (b == 5)c = 4;\n\t\telse c = 2;\n\t}\n\telse if (a == 2) {\n\t\tif (b == 1)c = 4;\n\t\telse if (b == 4)c = 6;\n\t\telse if (b == 6)c = 3;\n\t\telse c = 1;\n\t}\n\telse if (a == 3) {\n\t\tif (b == 1)c = 2;\n\t\telse if (b == 2)c = 6;\n\t\telse if (b == 5)c = 1;\n\t\telse c = 5;\n\t}\n\telse if (a == 4) {\n\t\tif (b == 1)c = 5;\n\t\telse if (b == 5)c = 6;\n\t\telse if (b == 6)c = 2;\n\t\telse c = 1;\n\t}\n\telse if (a == 5) {\n\t\tif (b == 1)c = 3;\n\t\telse if (b == 3)c = 6;\n\t\telse if (b == 6)c = 4;\n\t\telse c = 1;\n\t}\n\telse {\n\t\tif (b == 2)c = 4;\n\t\telse if (b == 3)c = 2;\n\t\telse if (b == 5)c = 3;\n\t\telse c = 5;\n\t}\n\n\tvector<int> z = { a,b,c,7 - b,7 - c,7 - a };\n\tdice ret(z);\n\treturn ret;\n}\ndice rollfront(dice x) {\n\tvector<int> z = { x.f[3],x.f[0],x.f[2],x.f[5],x.f[4],x.f[1] };\n\tdice ret(z);\n\treturn ret;\n}\ndice rollback(dice x) {\n\tvector<int> z = { x.f[1],x.f[5],x.f[2],x.f[0],x.f[4],x.f[3] };\n\tdice ret(z);\n\treturn ret;\n}\ndice rollright(dice x) {\n\tvector<int> z = { x.f[4],x.f[1],x.f[0],x.f[3],x.f[5],x.f[2] };\n\tdice ret(z);\n\treturn ret;\n}\ndice rollleft(dice x) {\n\tvector<int> z = { x.f[2],x.f[1],x.f[5],x.f[3],x.f[0],x.f[4] };\n\tdice ret(z);\n\treturn ret;\n}\nvoid roll(dice &d, char &c, int &x, int &y) {\n\tif (c == 'L')d = rollleft(d), --x;\n\telse if (c == 'R')d = rollright(d), ++x;\n\telse if (c == 'F')d = rollfront(d), --y;\n\telse d = rollback(d), ++y;\n}\n\nstruct status {\n\tint x, y;\n\tdice d;\n\tstring ord;\n};\n\nstatus s[15];\n\nusing speP = pair<P, int>;\n\nvector<speP> ori[15];\n\nint val[3000][3000];\nvoid make_b(int i) {\n\tori[i].clear();\n\tint x = s[i].x;\n\tint y = s[i].y;\n\tdice d = s[i].d;\n\tstring ord = s[i].ord;\n\tval[x][y] = d.f[5];\n\tvector<P> loc;\n\tloc.push_back({ x,y });\n\tfor (char t : ord) {\n\t\troll(d, t, x, y);\n\t\tval[x][y] = d.f[5];\n\t\tloc.push_back({ x,y });\n\t}\n\tsort(all(loc));\n\tloc.erase(unique(all(loc)), loc.end());\n\tfor (P p : loc) {\n\t\tint x = p.first, y = p.second;\n\t\tori[i].push_back({ {x,y},val[x][y] });\n\t\tval[x][y] = 0;\n\t}\n}\nconst int ep = 1500;\n\n\n\n\n\nvector<P> e[1 << 15];\n\nvoid upd(int s, int id) {\n\tint ns = s ^ (1 << id);\n\te[ns] = e[s];\n\tfor (speP p : ori[id]) {\n\t\te[ns].push_back(p.first);\n\t}\n\tsort(all(e[ns]));\n\te[ns].erase(unique(all(e[ns])), e[ns].end());\n}\nint ad(int s, int id) {\n\tint res = 0;\n\tfor (speP p : ori[id]) {\n\t\tint id = lower_bound(all(e[s]), p.first) - e[s].begin();\n\t\tif (id < e[s].size() && e[s][id] == p.first)continue;\n\t\tres += p.second;\n\t}\n\treturn res;\n}\nint n;\n\nint dp[1 << 15];\nvoid solve() {\n\trep(i, n) {\n\t\tint x, y; cin >> x >> y;\n\t\tx += ep; y += ep;\n\t\tint c[6];\n\t\trep(j, 6)cin >> c[j];\n\t\tstring ord; cin >> ord;\n\t\ts[i].x = x, s[i].y = y;\n\t\ts[i].d = vector<int>{ c[5],c[2],c[1],c[3],c[0],c[4] };\n\t\ts[i].ord = ord;\n\t\tmake_b(i);\n\t}\n\n\tfill(dp, dp + (1 << n), -mod);\n\tdp[0] = 0;\n\trep(i, (1 << n) - 1) {\n\t\trep(j, n) {\n\t\t\tif (i&(1 << j))continue;\n\t\t\tint ni = i ^ (1 << j);\n\t\t\tdp[ni] = max(dp[ni], dp[i] + ad(i, j));\n\t\t\tupd(i, j);\n\t\t}\n\t}\n\n\tcout << dp[(1 << n) - 1] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\twhile (cin >> n, n)solve();\n\t//solve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint n;\nstruct dat{int x,y;Dice d;};\ndat A[N];\nstring rot[N];\ntypedef pair<short,short> P;\ntypedef map<P,int> M;\n\nint getScore(M &mp){\n  int res = 0;\n  for(pair<P,int> p:mp) res += p.second;\n  return res;\n}\n\n\nM getNx(int idx,M res){\n  static int dx[1<<8]={};dx['L'] = -1, dx['R'] = 1;\n  static int dy[1<<8]={};dy['F'] = -1, dy['B'] = 1;\n  int x = A[idx].x, y = A[idx].y;  \n  Dice d = A[idx].d;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot[idx]){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nint DP(){\n  M dp[1<<N];\n  int score[1<<N]={};\n  int res = 0;\n  for(int bit;bit<(1<<n);bit++){\n    Max(res,score[bit]);\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      int nbit = bit | (1<<i);\n      M nmp = getNx(i,dp[bit]);\n      int nscore = getScore(nmp);\n      if(score[nbit] < nscore) dp[nbit] = nmp, score[nbit] = nscore;\n    }\n    dp[bit].clear();\n  }\n  return res;\n}\n \nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot[i];\n      A[i] = (dat){x,y,Dice(l,r,f,b,d,u)};\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 15\n#define MAX 2200\n#define OFFSET 1100\ntypedef pair<int, int> pii;\n\nclass Dice {\n  private:\n    void roll(int a, int b, int c, int d)\n    {\n        swap(v[a], v[b]);\n        swap(v[b], v[d]);\n        swap(v[c], v[d]);\n    }\n    \n  public:\n    int v[6], x, y;\n    string order;\n    void roll_B() { roll(0, 1, 4, 5); }\n    void roll_R() { roll(0, 3, 2, 5); }\n    void roll_F() { roll(0, 4, 1, 5); }\n    void roll_L() { roll(0, 2, 3, 5); }\n};\n\nint bit[MAX][MAX];\n\nvoid rot(int x, Dice &d)\n{\n    bit[d.y][d.x] |= (1<<x);\n    for (auto &c: d.order) {\n        if (c == 'L') {\n            c = 'R';\n            d.roll_L();\n            d.x--;\n        } else if (c == 'F') {\n            c = 'B';\n            d.roll_F();\n            d.y--;\n        } else if (c == 'R') {\n            c = 'L';\n            d.roll_R();\n            d.x++;\n        } else {\n            c = 'F';\n            d.roll_B();\n            d.y++;\n        }\n        bit[d.y][d.x] |= (1<<x);\n    }\n    reverse(d.order.begin(), d.order.end());\n}\n\nint get_cost(int S, Dice d)\n{\n    int res = 0;\n    set<pii> used;\n    if ((bit[d.y][d.x] & S) == 0) {\n        used.insert(pii(d.y, d.x));\n        res += d.v[5];\n    }\n        \n    for (auto c: d.order) {\n        if (c == 'L') {\n            d.x--;\n            d.roll_L();\n        } else if (c == 'F') {\n            d.y--;\n            d.roll_F();\n        } else if (c == 'R') {\n            d.x++;\n            d.roll_R();\n        } else {\n            d.y++;\n            d.roll_B();\n        }\n        \n        if (used.count(pii(d.y, d.x)) == 0 && (bit[d.y][d.x] & S) == 0) {\n            used.insert(pii(d.y, d.x));\n            res += d.v[5];\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Dice> d(N);\n        for (int i = 0; i < N; i++) {\n            cin >> d[i].x >> d[i].y;\n            d[i].x += OFFSET; d[i].y += OFFSET;\n            cin >> d[i].v[3] >> d[i].v[2] >> d[i].v[1];\n            cin >> d[i].v[4] >> d[i].v[5] >> d[i].v[0];\n            cin >> d[i].order;\n        }\n\n        memset(bit, 0, sizeof(bit));\n        \n        for (int i = 0; i < N; i++) {\n            rot(i, d[i]);\n        }        \n        \n        int dp[1<<MAX_N];\n        memset(dp, -1, sizeof(dp));\n\n        dp[0] = 0;\n        for (int i = 0; i < (1<<N); i++) {\n            if (dp[i] == -1) continue;                        \n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) continue;\n                int ni = i | (1<<j);                \n                dp[ni] = max(dp[ni], dp[i] + get_cost(i, d[j]));\n            }\n        }\n        cout << dp[(1<<N)-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<functional>\n#include<string>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define REC(ret,...) std::function<ret (__VA_ARGS__)>\ntemplate<typename T>\nbool chmin(T& l, T r) {\n\tbool res = l > r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nbool chmax(T& l, T r) {\n\tbool res = l < r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T> &v) {\n\tfor (auto &it : v)is >> it;\n\treturn is;\n}\ntypedef vector<int> V;\nint f(int x, int y, int z) {\n\treturn x + y + z;\n}\nconst int dx[4] = { 0,0,-1,1 };\nconst int dy[4] = { 1,-1,0,0 };\n#define BBB 0\n#define FFF 1\n#define LLL 2\n#define RRR 3\nconst int hiro[4][6] = {\n\t{0,1,5,4,2,3},\n\t{0,1,4,5,3,2},\n\t{4,5,2,3,1,0},\n\t{5,4,2,3,0,1}\n};\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef pair<int, int> P;\nvoid rot_move(vector<int>& state, int r, int&x, int &y) {\n\tx += dx[r];\n\ty += dy[r];\n\tvector<int> nxt(6);\n\tREP(i, 6)nxt[hiro[r][i]] = state[i];\n\tREP(i, 6)state[i] = nxt[i];\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tV x(N), y(N);\n\t\tVV dice(N, V(6));\n\t\tvector<string> rot(N);\n\t\tREP(i, N) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tcin >> dice[i];\n\t\t\tcin >> rot[i];\n\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\tif (it == 'B')it = BBB;\n\t\t\t\tif (it == 'F')it = FFF;\n\t\t\t\tif (it == 'L')it = LLL;\n\t\t\t\tif (it == 'R')it = RRR;\n\n\t\t\t}\n\t\t}\n\t\tvector<set<P>> fut(1<<N);\n\t\tREP(bit, 1 << N) {\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tfut[bit].insert(P(xx, yy));\n\t\t\t\tauto v = dice[i];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tfut[bit].insert(P(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV dp(1 << N, -1);\t\n\t\tdp[0] = 0;\n\t\tREC(int, int) dfs = [&](int bit) {\n\t\t\tif (dp[bit] >= 0)return dp[bit];\n\t\t\tdp[bit] = 0;\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tauto v = dice[i];\n\t\t\t\tint nxtbit = bit - (1 << i);\n\t\t\t\tint cost = dfs(nxtbit);\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tmap<P,int> memo;\n\t\t\t\tmemo[P(xx, yy)] = v[4];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tif (!fut[nxtbit].count(P(xx, yy))) {\n\t\t\t\t\t\tmemo[P(xx, yy)] = v[4];\t\t\n\t\t\t\t\t}\n\t\t\t\t\t//cout << xx << \" \" << yy << \" \" << v[4] << endl;\n\t\t\t\t\t//REP(i, 6)cout << v[i]; cout << endl;\n\t\t\t\t}\n\t\t\t\tfor (auto &it : memo) {\n\t\t\t\t\tcost += it.second;\n\t\t\t\t}\n\t\t\t\tchmax(dp[bit], cost);\n\t\t\t}\n\t\t\treturn dp[bit];\n\t\t};\n\t\tcout << dfs((1 << N) - 1) << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<short, short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<umap<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<unsigned short, umap<pii, char>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\n\nint n;\nstruct dat{int x,y;Dice d;};\ntypedef pair<short,short> P;\ntypedef map<P,int> M;\ntypedef set<P> S;\n\nM dice[N];\nM getMove(int x,int y,Dice d,string rot){\n  static int dx[1<<8]={},dy[1<<8]={};\n  dx['L'] = -1, dx['R'] = 1,dy['F'] = -1, dy['B'] = 1;\n  M res;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nint getScore(int idx,S &used){\n  int res = 0;\n  for(pair<P,int>const &p:dice[idx])\n    if(!used.count(p.first))res += p.second;\n  return res;\n}\n\nS getUsed(int idx,S used){\n  for(pair<P,int>const &p:dice[idx]) used.insert(p.first);\n  return used;\n}\n\n\nint DP(){\n  S used[1<<N];\n  int dp[1<<N] = {};\n  for(int bit=0;bit<(1<<n);bit++)\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      int nbit = bit | (1<<i);\n      int nscore = dp[bit] + getScore(i,used[bit]);\n      Max(dp[nbit],nscore);\n      if(used[nbit].empty()) used[nbit] = getUsed(i,used[bit]);\n\n    }\n  return dp[(1<<n)-1];\n}\n\n\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      string rot;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot;\n      dice[i] = getMove(x,y,Dice(l,r,f,b,d,u),rot);\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nll f(ll x, ll y) { return x + 10000 + (y + 10000) * 20000; }\n\nint main() {\n\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0)\n      break;\n    map<ll, map<int, ll>> mp;\n    for (int i = 0; i < n; i++) {\n      ll x, y;\n      cin >> x >> y;\n      ll a[6];\n      for (int j = 0; j < 6; j++)\n        cin >> a[j];\n      swap(a[3], a[2]);\n      int down = 4;\n      string s;\n      cin >> s;\n      mp[f(x, y)][i] = a[down];\n      for (auto &c : s) {\n        if (c == 'L') {\n          x -= 1;\n          ll b[6] = {a[5], a[4], a[2], a[3], a[0], a[1]};\n          for (int j = 0; j < 6; j++)\n            a[j] = b[j];\n          mp[f(x, y)][i] = a[down];\n        } else if (c == 'R') {\n          x += 1;\n          ll b[6] = {a[4], a[5], a[2], a[3], a[1], a[0]};\n          for (int j = 0; j < 6; j++)\n            a[j] = b[j];\n          mp[f(x, y)][i] = a[down];\n        } else if (c == 'F') {\n          y -= 1;\n          ll b[6] = {a[0], a[1], a[4], a[5], a[3], a[2]};\n          for (int j = 0; j < 6; j++)\n            a[j] = b[j];\n          mp[f(x, y)][i] = a[down];\n        } else {\n          y += 1;\n          ll b[6] = {a[0], a[1], a[5], a[4], a[2], a[3]};\n          for (int j = 0; j < 6; j++)\n            a[j] = b[j];\n          mp[f(x, y)][i] = a[down];\n        }\n      }\n    }\n    ll size = 1LL << n;\n    vector<vector<ll>> score(size);\n    for (int i = 0; i < size; i++)\n      score[i].resize(n);\n    for (auto &v : mp) {\n      ll bit = 0;\n      for (auto &w : v.second) {\n        bit |= 1LL << w.first;\n      }\n      for (auto &w : v.second) {\n        score[bit][w.first] += w.second;\n      }\n    }\n    vector<ll> dp(size);\n    dp[0] = 0;\n    for (int i = 0; i < size; i++) {\n      for (int j = 0; j < n; j++) {\n        if ((i >> j) & 1) {\n          continue;\n        }\n        ll next = i | (1LL << j);\n        ll sum = 0;\n        for (ll u = size - 1; u >= 0; u--) {\n          u &= i;\n          sum += score[u | (1LL << j)][j];\n        }\n        dp[next] = max(dp[next], dp[i] + sum);\n      }\n    }\n    cout << dp[size - 1] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\ntypedef pair<int,int> P;\nint p2i(P p){\n  return (p.first+1500)*3000+(p.second+1500);\n}\nunordered_set<int> used;\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    unordered_map<int,int> v;\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v.count(p2i(P(d.y,d.x)))||!used.count(p2i(P(d.y,d.x)))){\n\t//cout<<tmp<<\" \"<<d.bottom()<<endl;\n\ttmp+=d.bottom();\n\tif(v.count(p2i(P(d.y,d.x)))) tmp-=v[p2i(P(d.y,d.x))];\n\tv[p2i(P(d.y,d.x))]=d.bottom();\n\tused.insert(p2i(P(d.y,d.x)));\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(auto j:v) used.erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    used.clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nbool solve() {\n\tint N; cin >> N;\n\tif (N == 0) return (false);\n\tint X[20][33], Y[20][33], P[20][33];\n\tint size[20];\n\tfor (int i = 0; i < N; i++) {\n\t\tstring rot;\n\t\tint l, r, f, b, d, u;\n\t\tcin >> X[i][0] >> Y[i][0];\n\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\tP[i][0] = d;\n\t\tcin >> rot;\n\t\tfor (int j = 0; j < rot.size(); j++) {\n\t\t\tint nl, nr, nf, nb, nd, nu;\n\t\t\tX[i][j+1] = X[i][j];\n\t\t\tY[i][j+1] = Y[i][j];\n\t\t\tif (rot[j] == 'L') {\n\t\t\t\ttie(nl, nr, nd, nu) = tie(u, d, l, r);\n\t\t\t\ttie(l, r, d, u) = tie(nl, nr, nd, nu);\n\t\t\t\tX[i][j+1]--;\n\t\t\t}\n\t\t\tif (rot[j] == 'R') {\n\t\t\t\ttie(nl, nr, nd, nu) = tie(d, u, r, l);\n\t\t\t\ttie(l, r, d, u) = tie(nl, nr, nd, nu);\n\t\t\t\tX[i][j+1]++;\n\t\t\t}\n\t\t\tif (rot[j] == 'F') {\n\t\t\t\ttie(nb, nf, nd, nu) = tie(d, u, f, b);\n\t\t\t\ttie(b, f, d, u) = tie(nb, nf, nd, nu);\n\t\t\t\tY[i][j+1]--;\n\t\t\t}\n\t\t\tif (rot[j] == 'B') {\n\t\t\t\ttie(nb, nf, nd, nu) = tie(u, d, b, f);\n\t\t\t\ttie(b, f, d, u) = tie(nb, nf, nd, nu);\n\t\t\t\tY[i][j+1]++;\n\t\t\t}\n\t\t\tP[i][j+1] = d;\n\t\t}\n\t\tsize[i] = rot.size() + 1;\n\t}\n\t\n\tvint dp(1<<N, -INF);\n\tdp[0] = 0;\t\n\tfor (int b = 0; b < (1<<N); b++) {\n\t\tset<Pi> st;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!((b>>i)&1)) continue;\n\t\t\tfor (int j = 0; j < size[i]; j++) {\n\t\t\t\tst.emplace(X[i][j], Y[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint point = 0;\n\t\t\tif ((b>>i)&1) continue;\n\t\t\tset<Pi> st2;\n\t\t\tfor (int j = size[i]-1; j >= 0; j--) {\t\n\t\t\t\tPi p = Pi(X[i][j], Y[i][j]);\n\t\t\t\tif (!st.count(p)) {\n\t\t\t\t\tif (!st2.count(p)) {\n\t\t\t\t\t\tpoint += P[i][j];\n\t\t\t\t\t\tst2.insert(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tchmax(dp[b | (1<<i)], dp[b] + point);\n\t\t}\n\t}\n\tcout << dp[(1<<N)-1] << endl;\n\treturn (true);\n}\n\nint main() {\n\twhile (solve());\n\treturn (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nint rots(map<pii,int> &table, int n, bool update=false){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\tmap<pii,int> tb;\n\ttb[pii(pos.X, pos.Y)] = dc.point();\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[pii(pos.X,pos.Y)] = dc.point();\n\t}\n\t// merge\n\tint sum = 0;\n\tdc = dice_org[n];\n\tpos = dice_pos[n];\n\tif( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t\tsum += tb[pii(pos.X,pos.Y)];\n\t\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t}\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\tif( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t\t\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t\t\tsum += tb[pii(pos.X,pos.Y)];\n\t\t\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\tmap<pii, int> table;\n\t\t\trep(k,N) if( (1<<k)&i ) rots(table, k, true);\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + rots(table, k) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pb push_back\n\ntypedef struct {\n  int l, r, f, b, d, u;\n} dice;\n\ndice rotL(dice d)\n{\n  dice n = d;\n  n.l = d.u;\n  n.u = d.r;\n  n.r = d.d;\n  n.d = d.l;\n  return n;\n}\n\ndice rotR(dice d)\n{\n  dice n = d;\n  n.u = d.l;\n  n.r = d.u;\n  n.d = d.r;\n  n.l = d.d;\n  return n;\n}\n\ndice rotF(dice d)\n{\n  dice n = d;\n  n.f = d.u;\n  n.u = d.b;\n  n.b = d.d;\n  n.d = d.f;\n  return n;\n}\n\ndice rotB(dice d)\n{\n  dice n = d;\n  n.b = d.u;\n  n.u = d.f;\n  n.f = d.d;\n  n.d = d.b;\n  return n;\n}\n\ntypedef struct {\n  int x, y;\n  int num;\n} masu;\n\nmap<pair<int, int>, int> Max(map<pair<int, int>, int> a, map<pair<int, int>, int> b)\n{\n  int suma = 0, sumb = 0;\n  for (auto it = a.begin(); it != a.end(); it++) suma += it->second;\n  for (auto it = b.begin(); it != b.end(); it++) sumb += it->second;\n  if (suma > sumb) return a;\n  return b;\n}\n\nmap<pair<int, int>, int> stamp(map<pair<int, int>, int> p, vec<masu> s)\n{\n  rep(i, s.size()) {\n    if (p[make_pair(s[i].x, s[i].y)]) continue;\n    p[make_pair(s[i].x, s[i].y)] = s[i].num;\n  }\n  return p;\n}\n\nint main(void)\n{\n  while(1) {\n    int n;\n    cin >> n;\n    if (!n) break;\n    \n    vec<vec<masu> > stamps(n);\n    rep(t, n) {\n      int x, y;\n      cin >> x >> y;\n      dice d;\n      cin >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n      string rot;\n      cin >> rot;\n      map<pair<int, int>, int> dp;\n\n      masu s;\n      s.x = x; s.y = y; s.num = d.d;\n      stamps[t].pb(s);\n      dp[make_pair(x, y)] = 0;\n      rep(i, rot.length()) {\n        if (rot[i] == 'L') {\n          x--;\n          d = rotL(d);\n        } else if (rot[i] == 'R') {\n          x++;\n          d = rotR(d);\n        } else if (rot[i] == 'F') {\n          y--;\n          d = rotF(d);\n        } else {\n          y++;\n          d = rotB(d);\n        }\n        s.x = x; s.y = y; s.num = d.d;\n        if (dp.find(make_pair(x, y)) == dp.end()) {\n          stamps[t].pb(s);\n          dp[make_pair(x, y)] = stamps[t].size() - 1;\n        } else {\n          stamps[t][dp[make_pair(x, y)]] = s;\n        }\n      }\n    }\n\n    vec<map<pair<int, int>, int> > dp(1 << n);\n    rep(i, (1 << n)) {\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        dp[i + (1 << j)] = Max(dp[i + (1 << j)], stamp(dp[i], stamps[j]));\n      }\n    }\n    int sum = 0;\n    for (auto it = dp[(1 << n) - 1].begin(); it != dp[(1 << n) - 1].end(); it++) sum += it->second;\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint n;\nstruct dat{int x,y;Dice d;};\ndat A[N];\nstring rot[N];\ntypedef pair<int,int> P;\ntypedef map<P,int> M;\nM dice[N];\n\nint getScore(M &mp){\n  int res = 0;\n  for(pair<P,int> p:mp) res += p.second;\n  return res;\n}\n\n\nint dx[1<<8]={},dy[1<<8]={};\nM getNx(int idx,M &mp,int &score,bool flg = 0){\n  M tmp;\n  for(pair<P,int>const  &p:dice[idx]) {\n    tmp[p.first] = p.second;\n    score += p.second - mp[p.first];\n    mp[p.first] = p.second;\n  }\n  M res = flg? mp:M();\n  for(pair<P,int>const &p:tmp) mp[p.first] = p.second;\n  return res;\n}\n\n\nint DP(){\n  M dp[1<<N];\n  int score[1<<N]={};\n  for(int bit;bit<(1<<n);bit++){\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      int nbit = bit | (1<<i);\n      int nscore = score[bit];\n      getNx(i,dp[bit],nscore);\n      if(score[nbit] < nscore) score[nbit] = nscore,dp[nbit] = getNx(i,dp[bit],nscore,1);\n    }\n    dp[bit].clear();\n  }\n  return score[(1<<n)-1];\n}\n\nM getMove(int x,int y,Dice d,string rot){\n  M res;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nsigned main(){\n  dx['L'] = -1, dx['R'] = 1;\n  dy['F'] = -1, dy['B'] = 1;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot[i];\n      A[i] = (dat){x,y,Dice(l,r,f,b,d,u)};\n      dice[i] = getMove(x,y,Dice(l,r,f,b,d,u),rot[i]);\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nclass Dice {\npublic:\n\tint u, d, r, l, f, b;\n\tint x, y;\n\tstring rot;\n\n\tmap<pii, int> mp;\n\tint sum = 0;\n\n\tDice(){}\n\tvoid input(){\n\t\tcin >> x >> y;\n\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\tcin >> rot;\n\t\tmp[pii(x, y)] = d;\n        sum += d;\n\t}\n\n\tvoid rotate() {\n\t\trep (i, rot.size()) {\n\t\t\tchar c = rot[i];\n\t\t\tif (c == 'R') {\n\t\t\t\tint temp = r;\n\t\t\t\tr = u; u = l; l = d; d = temp;\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if (c == 'L') {\n\t\t\t\tint temp = u;\n\t\t\t\tu = r; r = d; d = l; l = temp;\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse if (c == 'F') {\n\t\t\t\tint temp = u;\n\t\t\t\tu = b; b = d; d = f; f = temp;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint temp = u;\n\t\t\t\tu = f; f = d; d = b; b = temp;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tsum -= mp[pii(x, y)];\n\t\t\tmp[pii(x, y)] = d;\n\t\t\tsum += mp[pii(x, y)];\n\t\t}\n\t}\n\n};\n\nvoid solve(int n) {\n\tvector<Dice> dice(n);\n\trep (i, n) {\n\t\tdice[i].input();\n\t\tdice[i].rotate();\n\t}\n\n\tset<pii> all_p;\n\trep (i, n) {\n\t\tfor (auto itr = dice[i].mp.begin(); itr != dice[i].mp.end(); itr++) {\n\t\t\tall_p.insert(itr->first);\n\t\t}\n\t}\n\n\tmap<pii, int> p2u;\n\tint cnt = 0;\n\tfor (auto itr = all_p.begin(); itr != all_p.end(); itr++) {\n\t\tp2u[*itr] = cnt++;\n\t}\n\n\tvector<int> out(cnt);\n\trep (i, n) {\n\t\tfor (auto itr = dice[i].mp.begin(); itr != dice[i].mp.end(); itr++) {\n\t\t\tpii p = itr->first;\n\t\t\tint u = p2u[p];\n\t\t\tout[u] += (1 << i);\n\t\t}\n\t}\n\n\tvector<int> dp(1 << n);\n\n\trep (i, 1 << n) {\n\t\trep (j, n) {\n\t\t\tif (i & (1 << j)) continue;\n\t\t\tint ni = i + (1 << j);\n\t\t\tint add = dice[j].sum;\n\t\t\tfor (auto itr = dice[j].mp.begin(); itr != dice[j].mp.end(); itr++) {\n\t\t\t\tpii p = itr->first;\n\t\t\t\tint score = itr->second;\n\t\t\t\tint u = p2u[p];\n\t\t\t\tif (out[u] & (~ni)) {\n\t\t\t\t\tadd -= score;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[ni] = max(dp[ni], dp[i] + add);\n\t\t}\n\t}\n\tint ans = 0;\n\trep (i, 1 << n) {\n\t\tans = max(ans, dp[i]);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return 0;\n\t\tsolve(n);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dice\n{\n  int x, y;\n  int l, r, f, b, d, u;\n\n  inline void RollF()\n  {\n    --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  inline void RollB()\n  {\n    ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  inline void RollL()\n  {\n    --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n  inline void RollR()\n  {\n    ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n};\n\nint N;\nDice dice[15];\nstring rot[15];\nint dp[1 << 15];\nint v[2100][2100], buff[2100][2100];\n\ninline void Roll(Dice& obj, char c)\n{\n  switch(c) {\n    case 'L':\n      obj.RollL();\n      return;\n    case 'R':\n      obj.RollR();\n      return;\n    case 'B':\n      obj.RollB();\n      return;\n    case 'F':\n      obj.RollF();\n      return;\n    default:\n      return;\n  }\n}\n\ninline int AddDice(int idx)\n{\n  int ret = 0;\n  Dice obj = dice[idx];\n  for(char c : rot[idx]) {\n    Roll(obj, c);\n    if(v[obj.y][obj.x] == -1) {\n      v[obj.y][obj.x] = idx;\n      buff[obj.y][obj.x] = obj.d;\n      ret += obj.d;\n    } else if(v[obj.y][obj.x] == idx) {\n      ret -= buff[obj.y][obj.x];\n      ret += obj.d;\n      buff[obj.y][obj.x] = obj.d;\n    }\n  }\n  return (ret);\n}\n\ninline void DeleteDice(int idx)\n{\n  Dice obj = dice[idx];\n  for(char c : rot[idx]) {\n    Roll(obj, c);\n    if(v[obj.y][obj.x] == idx) {\n      v[obj.y][obj.x] = -1;\n    }\n  }\n}\n\ninline int rec(int bit)\n{\n  if(bit == (1 << N) - 1) return (0);\n  if(~dp[bit]) return (dp[bit]);\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    if((bit >> i) & 1) continue;\n    int get = AddDice(i);\n    ret = max(ret, rec(bit | (1 << i)) + get);\n    DeleteDice(i);\n  }\n  return (dp[bit] = ret);\n}\n\nint main()\n{\n  memset(v, -1, sizeof(v));\n  while(cin >> N, N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> dice[i].x >> dice[i].y;\n      cin >> dice[i].l >> dice[i].r >> dice[i].f >> dice[i].b >> dice[i].d >> dice[i].u;\n      cin >> rot[i];\n      rot[i] = \"~\" + rot[i];\n      dice[i].x += 1050, dice[i].y += 1050;\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n \n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef pair<int,int> pii;\ntypedef pair<int,set<pii> > ps;\n \n// LRFB\nconst int R[4][6] = {\n    {4,5,2,3,1,0},\n    {5,4,2,3,0,1},\n    {0,1,4,5,3,2},\n    {0,1,5,4,2,3},\n};\nconst int vx[]={-1,1,0,0}, vy[]={0,0,-1,1};\n \npii S[20];\nint p[20][6];\nstring rot[20];\nint pp[16][2005][2005];\n \nvoid calc(int p[6], string rot, int n, int x, int y){\n    pp[n][y][x] = p[4]; //??????¢\n    if( rot.empty() ) return;\n    int np[6], r;\n    if( rot[0] == 'L' ) r = 0;\n    if( rot[0] == 'R' ) r = 1;\n    if( rot[0] == 'F' ) r = 2;\n    if( rot[0] == 'B' ) r = 3;\n    rep(i,6) np[ R[r][i] ] = p[i];\n    calc(np, rot.substr(1), n, x+vx[r], y+vy[r]);\n}\n \nint sum(int n, set<pii> &st){\n    int x = S[n].X;\n    int y = S[n].Y;\n    int ret = 0;\n    if( !st.count(pii(x,y)) ){\n        ret += pp[n][y][x];\n        st.insert( pii(x,y) );\n    }\n    rep(i,rot[n].length()){\n        int r;\n        if( rot[n][i] == 'L' ) r = 0;\n        if( rot[n][i] == 'R' ) r = 1;\n        if( rot[n][i] == 'F' ) r = 2;\n        if( rot[n][i] == 'B' ) r = 3;\n        x += vx[r];\n        y += vy[r];\n        if( !st.count(pii(x,y)) ){\n            ret += pp[n][y][x];\n            st.insert( pii(x,y) );\n        }\n    }\n    return ret;\n}\n \nint main(){\n    int N;\n    while(cin>>N, N){\n        fill( (int*)pp[0], (int*)pp[16], 0 );\n        rep(i,N){\n            int x, y;\n            cin >> x >> y;\n            x += 1001;\n            y += 1001;\n            S[i] = pii(x,y);\n            rep(j,6) cin >> p[i][j];\n            cin >> rot[i];\n            calc(p[i], rot[i], i, x, y);\n        }\n        ps dp[1<<16]={};\n        rep(k,1<<N){\n            rep(i,N) if( k&(1<<i) ){\n                auto st = dp[k^(1<<i)].Y;\n                int tmp = dp[k^(1<<i)].X + sum( i, st );\n                dp[k] = max( dp[k], ps(tmp, st) );\n            }\n        }\n        cout << dp[(1<<N)-1].X << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pb push_back\n\ntypedef struct {\n  int l, r, f, b, d, u;\n} dice;\n\ndice rotL(dice d)\n{\n  dice n = d;\n  n.l = d.u;\n  n.u = d.r;\n  n.r = d.d;\n  n.d = d.l;\n  return n;\n}\n\ndice rotR(dice d)\n{\n  dice n = d;\n  n.u = d.l;\n  n.r = d.u;\n  n.d = d.r;\n  n.l = d.d;\n  return n;\n}\n\ndice rotF(dice d)\n{\n  dice n = d;\n  n.f = d.u;\n  n.u = d.b;\n  n.b = d.d;\n  n.d = d.f;\n  return n;\n}\n\ndice rotB(dice d)\n{\n  dice n = d;\n  n.b = d.u;\n  n.u = d.f;\n  n.f = d.d;\n  n.d = d.b;\n  return n;\n}\n\ntypedef struct {\n  int x, y;\n  int num;\n} masu;\n\nmap<pair<int, int>, int> Max(map<pair<int, int>, int> a, map<pair<int, int>, int> b)\n{\n  int suma = 0, sumb = 0;\n  for (auto it = a.begin(); it != a.end(); it++) suma += it->second;\n  for (auto it = b.begin(); it != b.end(); it++) sumb += it->second;\n  if (suma > sumb) return a;\n  return b;\n}\n\nmap<pair<int, int>, int> stamp(map<pair<int, int>, int> p, vec<masu> s)\n{\n  rep(i, s.size()) {\n    if (p[make_pair(s[i].x, s[i].y)]) continue;\n    p[make_pair(s[i].x, s[i].y)] = s[i].num;\n  }\n  return p;\n}\n\nint main(void)\n{\n  while(1) {\n    int n;\n    cin >> n;\n    if (!n) break;\n    \n    vec<vec<masu> > stamps(n);\n    rep(t, n) {\n      int x, y;\n      cin >> x >> y;\n      dice d;\n      cin >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n      string rot;\n      cin >> rot;\n      map<pair<int, int>, int> dp;\n\n      masu s;\n      s.x = x; s.y = y; s.num = d.d;\n      stamps[t].pb(s);\n      dp[make_pair(x, y)] = 0;\n      rep(i, rot.length()) {\n        if (rot[i] == 'L') {\n          x--;\n          d = rotL(d);\n        } else if (rot[i] == 'R') {\n          x++;\n          d = rotR(d);\n        } else if (rot[i] == 'F') {\n          y--;\n          d = rotF(d);\n        } else {\n          y++;\n          d = rotB(d);\n        }\n        s.x = x; s.y = y; s.num = d.d;\n        if (dp.find(make_pair(x, y)) == dp.end()) {\n          stamps[t].pb(s);\n          dp[make_pair(x, y)] = i + 1;\n        } else {\n          stamps[t][dp[make_pair(x, y)]] = s;\n        }\n      }\n    }\n\n    vec<map<pair<int, int>, int> > dp(1 << n);\n    rep(i, (1 << n)) {\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        dp[i + (1 << j)] = Max(dp[i + (1 << j)], stamp(dp[i], stamps[j]));\n      }\n    }\n    int sum = 0;\n    for (auto it = dp[(1 << n) - 1].begin(); it != dp[(1 << n) - 1].end(); it++) sum += it->second;\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 15\ntypedef pair<int, int> pii;\n\nclass Dice {\n  private:\n    void roll(int a, int b, int c, int d)\n    {\n        swap(v[a], v[b]);\n        swap(v[b], v[d]);\n        swap(v[c], v[d]);\n    }\n    \n  public:\n    int v[6], x, y;\n    string order;\n    void roll_B() { roll(0, 1, 4, 5); }\n    void roll_R() { roll(0, 3, 2, 5); }\n    void roll_F() { roll(0, 4, 1, 5); }\n    void roll_L() { roll(0, 2, 3, 5); }\n};\n\nvoid rot(set<pii> &a, Dice &d)\n{\n    a.insert(pii(d.y, d.x));\n    for (auto &c: d.order) {\n        if (c == 'L') {\n            c = 'R';\n            d.roll_L();\n            d.x--;\n        } else if (c == 'F') {\n            c = 'B';\n            d.roll_F();\n            d.y--;\n        } else if (c == 'R') {\n            c = 'L';\n            d.roll_R();\n            d.x++;\n        } else {\n            c = 'F';\n            d.roll_B();\n            d.y++;\n        }\n        a.insert(pii(d.y, d.x));\n    }\n    reverse(d.order.begin(), d.order.end());\n}\n\nvoid merge(set<pii> &a, set<pii> &b)\n{\n    for (auto p: b) {\n        a.insert(p);\n    }\n}\n\nint get_cost(set<pii> decided, Dice d)\n{\n    int res = 0;    \n    if (decided.count(pii(d.y, d.x)) == 0) {\n        decided.insert(pii(d.y, d.x));\n        res += d.v[5];\n    }\n        \n    for (auto c: d.order) {\n        if (c == 'L') {\n            d.x--;\n            d.roll_L();\n        } else if (c == 'F') {\n            d.y--;\n            d.roll_F();\n        } else if (c == 'R') {\n            d.x++;\n            d.roll_R();\n        } else {\n            d.y++;\n            d.roll_B();\n        }\n        if (decided.count(pii(d.y, d.x)) == 0) {\n            decided.insert(pii(d.y, d.x));\n            res += d.v[5];\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Dice> d(N);\n        for (int i = 0; i < N; i++) {\n            cin >> d[i].x >> d[i].y;\n            cin >> d[i].v[3] >> d[i].v[2] >> d[i].v[1];\n            cin >> d[i].v[4] >> d[i].v[5] >> d[i].v[0];\n            cin >> d[i].order;\n        }\n\n        set<pii> a[MAX_N];\n        for (int i = 0; i < N; i++) {\n            rot(a[i], d[i]);\n        }\n       \n        int dp[1<<MAX_N];\n        memset(dp, -1, sizeof(dp));\n\n        dp[0] = 0;\n        for (int i = 0; i < (1<<N); i++) {\n            if (dp[i] == -1) continue;            \n            set<pii> decided;\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) {\n                    merge(decided, a[j]);\n                }\n            }\n\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) continue;\n                int ni = i | (1<<j);                \n                dp[ni] = max(dp[ni], dp[i] + get_cost(decided, d[j]));\n            }\n        }\n        cout << dp[(1<<N)-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nenum { U, B, L, F, R, D };\nstruct Dice {\n\tint face[6];\n\n\tDice() {\n\t\tface[F] = 1;\n\t\tface[R] = 2;\n\t\tface[U] = 3;\n\t\tface[B] = 6;\n\t\tface[L] = 5;\n\t\tface[D] = 4;\n\t}\n\n\tint find_face(int f) {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(face[i] == f) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R:\n\t\t\trotate(U, R, D, L);\n\t\t\tbreak;\n\t\tcase B:\n\t\t\trotate(U, B, D, F);\n\t\t\tbreak;\n\t\tcase L:\n\t\t\trotate(U, L, D, R);\n\t\t\tbreak;\n\t\tcase F:\n\t\t\trotate(U, F, D, B);\n\t\t\tbreak;\n\t\tcase U:\n\t\t\trotate(F, R, B, L);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tcase D:\n\t\t\trotate(F, L, B, R);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\tint& operator[](int n) { return face[n]; }\n\n\tconst int& operator[](int n) const { return face[n]; }\n\n\tstd::vector<Dice> all_rolls() {\n\t\tstd::vector<Dice> res;\n\t\tfor(int k = 0; k < 6; k++) {\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tres.push_back(*this);\n\t\t\t\tturn(R);\n\t\t\t}\n\t\t\tturn(k % 2 == 1 ? U : F);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c];\n\t\tface[c] = face[b];\n\t\tface[b] = face[a];\n\t\tface[a] = t;\n\t}\n};\n\ntypedef pair<int, int> P;\n\nDice dice[15];\nint X[15], Y[15];\nstring rot[15];\nmap<P, int> pos[15];\nint dp[16][1 << 15];\nset<P> used[1 << 15];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint l, r, f, b, d, u;\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\t\tcin >> rot[i];\n\t\t\tdice[i][L] = l;\n\t\t\tdice[i][R] = r;\n\t\t\tdice[i][F] = f;\n\t\t\tdice[i][B] = b;\n\t\t\tdice[i][D] = d;\n\t\t\tdice[i][U] = u;\n\n\t\t\tDice t = dice[i];\n\t\t\tint x = X[i], y = Y[i];\n\t\t\tpos[i].clear();\n\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\tfor(auto c : rot[i]) {\n\t\t\t\tif(c == 'L') t.turn(L), x--;\n\t\t\t\tif(c == 'R') t.turn(R), x++;\n\t\t\t\tif(c == 'F') t.turn(F), y--;\n\t\t\t\tif(c == 'B') t.turn(B), y++;\n\t\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 1 << N; i++) {\n\t\t\tused[i].clear();\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(i >> j & 1) {\n\t\t\t\t\tfor(auto p : pos[j]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tused[i].insert({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\t\tint s = dp[i][j];\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tint ns = s;\n\t\t\t\t\tfor(auto p : pos[k]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tint point = p.second;\n\t\t\t\t\t\tif(used[j].count({ x, y })) continue;\n\t\t\t\t\t\tns += point;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j | (1 << k)] = max(dp[i + 1][j | (1 << k)], ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\tans = max(ans, dp[N][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pb push_back\n\ntypedef struct {\n  int l, r, f, b, d, u;\n} dice;\n\ndice rotL(dice d)\n{\n  dice n = d;\n  n.l = d.u;\n  n.u = d.r;\n  n.r = d.d;\n  n.d = d.l;\n  return n;\n}\n\ndice rotR(dice d)\n{\n  dice n = d;\n  n.u = d.l;\n  n.r = d.u;\n  n.d = d.r;\n  n.l = d.d;\n  return n;\n}\n\ndice rotF(dice d)\n{\n  dice n = d;\n  n.f = d.u;\n  n.u = d.b;\n  n.b = d.d;\n  n.d = d.f;\n  return n;\n}\n\ndice rotB(dice d)\n{\n  dice n = d;\n  n.b = d.u;\n  n.u = d.f;\n  n.f = d.d;\n  n.d = d.b;\n  return n;\n}\n\ntypedef struct {\n  int x, y;\n  int num;\n} masu;\n\nmap<pair<int, int>, int> Max(map<pair<int, int>, int> a, map<pair<int, int>, int> b)\n{\n  int suma = 0, sumb = 0;\n  for (auto it = a.begin(); it != a.end(); it++) suma += it->second;\n  for (auto it = b.begin(); it != b.end(); it++) sumb += it->second;\n  if (suma > sumb) return a;\n  return b;\n}\n\nmap<pair<int, int>, int> stamp(map<pair<int, int>, int> p, vec<masu> s)\n{\n  rep(i, s.size()) {\n    if (p[make_pair(s[i].x, s[i].y)]) continue;\n    p[make_pair(s[i].x, s[i].y)] = s[i].num;\n  }\n  return p;\n}\n\nint main(void)\n{\n  while(1) {\n    int n;\n    cin >> n;\n    if (!n) break;\n    \n    vec<vec<masu> > stamps(n);\n    rep(t, n) {\n      int x, y;\n      cin >> x >> y;\n      dice d;\n      cin >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n      string rot;\n      cin >> rot;\n      map<pair<int, int>, int> dp;\n\n      masu s;\n      s.x = x; s.y = y; s.num = d.d;\n      stamps[t].pb(s);\n      dp[make_pair(x, y)] = 0;\n      rep(i, rot.length()) {\n        if (rot[i] == 'L') {\n          x--;\n          d = rotL(d);\n        } else if (rot[i] == 'R') {\n          x++;\n          d = rotR(d);\n        } else if (rot[i] == 'F') {\n          y--;\n          d = rotF(d);\n        } else {\n          y++;\n          d = rotB(d);\n        }\n        s.x = x; s.y = y; s.num = d.d;\n        if (dp.find(make_pair(x, y)) == dp.end()) {\n          stamps[t].pb(s);\n          dp[make_pair(x, y)] = i + 1;\n        } else {\n          stamps[t][dp[make_pair(x, y)]] = s;\n        }\n      }\n    }\n\n    vec<map<pair<int, int>, int> > dp(1 << n);\n    rep(i, (1 << n)) {\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        dp[i + (1 << j)] = Max(dp[i + (1 << j)], stamp(dp[i], stamps[j]));\n      }\n    }\n    int sum = 0;\n    for (auto it = dp[(1 << n) - 1].begin(); it != dp[(1 << n) - 1].end(); it++) sum += it->second;\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\n\nint n;\nstruct dat{int x,y;Dice d;};\ntypedef pair<short,short> P;\ntypedef map<P,int> M;\ntypedef set<P> S;\n\nM dice[N];\nM getMove(int x,int y,Dice d,string rot){\n  static int dx[1<<8]={},dy[1<<8]={};\n  dx['L'] = -1, dx['R'] = 1,dy['F'] = -1, dy['B'] = 1;\n  M res;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nint getScore(int idx,S &used){\n  int res = 0;\n  for(pair<P,int>const &p:dice[idx])\n    if(!used.count(p.first))res += p.second;\n  return res;\n}\n\nS getUsed(int idx,S used){\n  for(pair<P,int>const &p:dice[idx]) used.insert(p.first);\n  return used;\n}\n\n\nint DP(){\n  S used[1<<N];\n  int dp[1<<N] = {};\n  for(int bit=0;bit<(1<<n);bit++)\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      int nbit = bit | (1<<i);\n      int nscore = dp[bit] + getScore(i,used[bit]);\n      Max(dp[nbit],nscore);\n      if(used[nbit].empty()) used[nbit] = getUsed(i,used[bit]);\n\n    }\n  return dp[(1<<n)-1];\n}\n\n\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      string rot;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot;\n      dice[i] = getMove(x,y,Dice(l,r,f,b,d,u),rot);\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int LEFT = 0, RIGHT = 1, FRONT = 2, BACK = 3, BOTTOM = 4, TOP = 5;\n\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  \n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\"); /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n  }\n\n  void rot(char ch){rot(string(1,ch));}\n  \n  //奥に転がす\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //手前に転がす\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n  \n  //右に転がす\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //左に転がす\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //上から見て時計回りに回す\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //上からみて反時計回りに回す。\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint dy[300], dx[300];\n\nvoid init(){\n  \n  dy['N'] = 1; dy['E'] = 0; dy['S'] = -1; dy['W'] = 0;\n  \n  dx['N'] = 0; dx['E'] = 1; dx['S'] = 0; dx['W'] = -1;\n  \n}\n\nint n, x[15], y[15], to[2500][2500], fromx[500], fromy[500];\nstring s[15];\nDice dice[15];\n\ntypedef pair<int,int> P;\n\nconst int M = 15 * 30;\nconst int pepi = 1250;\n\nvoid compress(){\n  \n  map<P,int> used;\n  \n  for(int idx=0;idx<n;idx++){\n    \n    int X = x[idx] + pepi, Y = y[idx] + pepi;\n    \n    Dice d = dice[idx];\n    \n    used[P( X, Y )] = 0;\n    \n    for(int i=0;i<(int)s[idx].size();i++){\n      \n      X += dx[(int)s[idx][i]];\n      \n      Y += dy[(int)s[idx][i]];\n      \n      d.rot(s[idx][i]);\n      \n      used[P( X, Y )] = 0;\n      \n    }\n    \n  }\n  \n  int idx =  0;\n  \n  auto p = used.begin();\n  \n  while( p != used.end() ){\n    \n    int x = (*p).first.first;\n    \n    int y = (*p).first.second;\n    \n    to[x][y] = idx;\n    \n    fromx[idx] = x;\n    \n    fromy[idx] = y;\n    \n    idx++;\n    \n    p++;\n    \n  }\n  \n}\n\nint memo[2500][2500], maxs[1<<15];\nbitset<M> dp[1<<15];\n\nvoid update(bitset<M> S, int idx, int I, int nI){\n  \n  int sum = maxs[I];\n\n  int X = fromx[to[x[idx]+pepi][y[idx]+pepi]];\n  int Y = fromy[to[x[idx]+pepi][y[idx]+pepi]];\n  \n  Dice d = dice[idx];\n  \n  unordered_set<int> used;\n  \n  if( S[to[X][Y]] == 0 ){\n    S[to[X][Y]] = 1;\n    used.insert(to[X][Y]);\n    sum += d.val[BOTTOM];\n    memo[X][Y] = d.val[BOTTOM];\n  }\n  \n  for(int i=0;i<(int)s[idx].size();i++){\n    \n    X += dx[(int)s[idx][i]];\n    \n    Y += dy[(int)s[idx][i]];\n    \n    d.rot(s[idx][i]);\n    \n    if( used.count(to[X][Y]) ){\n      sum -= memo[X][Y];\n      sum += d.val[BOTTOM];\n      memo[X][Y] = d.val[BOTTOM];\n    }\n    \n    if( S[to[X][Y]] == 0 ){\n      S[to[X][Y]] = 1;\n      used.insert(to[X][Y]);\n      sum += d.val[BOTTOM];\n      memo[X][Y] = d.val[BOTTOM];\n    }\n    \n  }\n\n  if( maxs[nI] < sum ){\n    maxs[nI] = sum;\n    dp[nI] = S;\n  }\n  \n}\n\nsigned main(){\n  \n  init();\n  \n  while(1){\n    \n    cin>>n;\n    if( n == 0 ) break;\n    \n    for(int i=0;i<(1<<n);i++) dp[i] = maxs[i] = 0;\n    \n    for(int i=0;i<n;i++){\n            \n      cin>>x[i]>>y[i];\n      \n      int val[6];\n      \n      for(int j=0;j<6;j++) cin>>val[j];\n      \n      dice[i] = Dice(val);\n      \n      cin>>s[i];\n      \n      for(int j=0;j<(int)s[i].size();j++){\n\tif( s[i][j] == 'B' ) s[i][j] = 'N';\n\tif( s[i][j] == 'R' ) s[i][j] = 'E';\n\tif( s[i][j] == 'F' ) s[i][j] = 'S';\n\tif( s[i][j] == 'L' ) s[i][j] = 'W';\n      }\n      \n    }\n    \n    compress();\n    \n    for(int i=0;i<(1<<n);i++){\n      \n      for(int j=0;j<n;j++){\n\t\n\tif( !( i >> j & 1 ) ) update( dp[i], j, i, i | (1<<j) );\n\t\n      }\n      \n    }\n    \n    cout << maxs[(1<<n)-1] << endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pb push_back\n\ntypedef struct {\n  int l, r, f, b, d, u;\n} dice;\n\ndice rotL(dice d)\n{\n  dice n = d;\n  n.l = d.u;\n  n.u = d.r;\n  n.r = d.d;\n  n.d = d.l;\n  return n;\n}\n\ndice rotR(dice d)\n{\n  dice n = d;\n  n.u = d.l;\n  n.r = d.u;\n  n.d = d.r;\n  n.l = d.d;\n  return n;\n}\n\ndice rotF(dice d)\n{\n  dice n = d;\n  n.f = d.u;\n  n.u = d.b;\n  n.b = d.d;\n  n.d = d.f;\n  return n;\n}\n\ndice rotB(dice d)\n{\n  dice n = d;\n  n.b = d.u;\n  n.u = d.f;\n  n.f = d.d;\n  n.d = d.b;\n  return n;\n}\n\ntypedef struct {\n  int x, y;\n  int num;\n} masu;\n\npair<int, int> SUM = make_pair(2000, 2000);\n\nmap<pair<int, int>, int> Max(map<pair<int, int>, int> a, map<pair<int, int>, int> b)\n{\n  if (a[SUM] > b[SUM]) return a;\n  else return b;\n}\n\nmap<pair<int, int>, int> stamp(map<pair<int, int>, int> p, vec<masu> s)\n{\n  rep(i, s.size()) {\n    if (p.find(make_pair(s[i].x, s[i].y)) != p.end()) continue;\n    p[make_pair(s[i].x, s[i].y)] = s[i].num;\n    p[SUM] += s[i].num;\n  }\n  return p;\n}\n\nint main(void)\n{\n  while(1) {\n    int n;\n    cin >> n;\n    if (!n) break;\n    \n    vec<vec<masu> > stamps(n);\n    rep(t, n) {\n      int x, y;\n      cin >> x >> y;\n      dice d;\n      cin >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n      string rot;\n      cin >> rot;\n      map<pair<int, int>, int> dp;\n\n      masu s;\n      s.x = x; s.y = y; s.num = d.d;\n      stamps[t].pb(s);\n      dp[make_pair(x, y)] = 0;\n      rep(i, rot.length()) {\n        if (rot[i] == 'L') {\n          x--;\n          d = rotL(d);\n        } else if (rot[i] == 'R') {\n          x++;\n          d = rotR(d);\n        } else if (rot[i] == 'F') {\n          y--;\n          d = rotF(d);\n        } else {\n          y++;\n          d = rotB(d);\n        }\n        s.x = x; s.y = y; s.num = d.d;\n        if (dp.find(make_pair(x, y)) == dp.end()) {\n          stamps[t].pb(s);\n          dp[make_pair(x, y)] = stamps[t].size() - 1;\n        } else {\n          stamps[t][dp[make_pair(x, y)]] = s;\n        }\n      }\n    }\n\n    //vec<map<pair<int, int>, int> > dp(1 << n);\n    //dp[0][SUM] = 0;\n    //vec<vec<vec<int> > > dp(1 << n, vec<vec<int> >(4001, vec<int>(4001, 0)));\n    //dp[0][4000][4000] = 0;\n    /*\n    rep(i, (1 << n)) {\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        dp[i + (1 << j)] = Max(dp[i + (1 << j)], stamp(dp[i], stamps[j]));\n      }\n    }\n    */\n    /*\n    int sum = 0;\n    for (auto it = dp[(1 << n) - 1].begin(); it != dp[(1 << n) - 1].end(); it++) sum += it->second;\n    cout << sum << endl;\n    */\n    //cout << dp[(1 << n) - 1][SUM] << endl;\n    //cout << dp[(1 << n) - 1][4000][4000] << endl;\n\n    vec<int> dp(1 << n, 0);\n    rep(i, (1 << n)) {\n      map<pair<int, int>, int> m;\n      rep(j, n) {\n        if ((i >> j) % 2 == 0) continue;\n        rep(k, stamps[j].size()) {\n          m[make_pair(stamps[j][k].x, stamps[j][k].y)] = 1;\n        }\n      }\n\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        int cost = 0;\n        rep(k, stamps[j].size()) {\n          pair<int, int> p = make_pair(stamps[j][k].x, stamps[j][k].y);\n          if (m[p]) continue;\n          cost += stamps[j][k].num;\n        }\n        if (dp[i + (1 << j)] < dp[i] + cost) dp[i + (1 << j)] = dp[i] + cost;\n      }\n    }\n    cout << dp[(1 << n) - 1] << endl;\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n// top front right left back bottom\n//front\nvoid S(vector<int>&in){\n  int tmp=in[1];\n  in[1]=in[0];\n  in[0]=in[4];\n  in[4]=in[5];\n  in[5]=tmp;\n}\n//right\nvoid E(vector<int>&in){\n  int tmp=in[2];\n  in[2]=in[0];\n  in[0]=in[3];\n  in[3]=in[5];\n  in[5]=tmp;\n}\n//turn\nvoid T(vector<int>&in){\n  int tmp=in[1];\n  in[1]=in[2];\n  in[2]=in[4];\n  in[4]=in[3];\n  in[3]=tmp;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<vip>in(n);\n\t\trep(i,n){\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tvi t(6);\n// top front right left back bottom\n\t\t\tcin>>t[3]>>t[2]>>t[1]>>t[4]>>t[5]>>t[0];\n\t\t\tstring s;cin>>s;\n\t\t\tin[i].pb({t[5],{x,y}});\n\t\t\trep(j,s.size()){\n\t\t\t\tif(s[j]=='R')E(t),x++;\n\t\t\t\tif(s[j]=='L')E(t),E(t),E(t),x--;\n\t\t\t\tif(s[j]=='F')S(t),y--;\n\t\t\t\tif(s[j]=='B')S(t),S(t),S(t),y++;\n\t\t\t\trep(k,in[i].size())if(in[i][k].second==pii(x,y)){in[i][k].first=t[5];goto end;}\n\t\t\t\tin[i].pb({t[5],{x,y}});\n\t\t\t\tend:;\n\t\t\t}\n\t\t}\n\t\tint N=1<<n;\n\t\tvi dp(N,-inf);\n\t\tdp[0]=0;\n\t\trep(i,N)rep(j,n)if((i&1<<j)==0){\n\t\t\tmap<pii,int>ma;\n\t\t\trep(k,n)if(i&1<<k)rep(l,in[k].size())ma[in[k][l].second]=1;\n\t\t\tint sum=0;\n\t\t\trep(k,in[j].size())if(ma[in[j][k].second]==0)sum+=in[j][k].first;\n\t\t\tcmax(dp[i|1<<j],dp[i]+sum);\n\t\t}\n\t\tcout<<dp[N-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dice\n{\n  int x, y;\n  int l, r, f, b, d, u;\n\n  void RollF()\n  {\n    --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollB()\n  {\n    ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL()\n  {\n    --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n  void RollR()\n  {\n    ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n};\n\nint N;\nDice dice[15];\nstring rot[15];\nint dp[1 << 15];\nint v[2100][2100], buff[2100][2100];\n\nvoid Roll(Dice& obj, char c)\n{\n  switch(c) {\n    case 'L':\n      obj.RollL();\n      return;\n    case 'R':\n      obj.RollR();\n      return;\n    case 'B':\n      obj.RollB();\n      return;\n    case 'F':\n      obj.RollF();\n      return;\n    default:\n      return;\n  }\n}\n\nint AddDice(int idx)\n{\n  int ret = 0;\n  Dice obj = dice[idx];\n  for(char c : rot[idx]) {\n    Roll(obj, c);\n    if(v[obj.y][obj.x] == -1) {\n      v[obj.y][obj.x] = idx;\n      buff[obj.y][obj.x] = obj.d;\n      ret += obj.d;\n    } else if(v[obj.y][obj.x] == idx) {\n      ret -= buff[obj.y][obj.x];\n      ret += obj.d;\n      buff[obj.y][obj.x] = obj.d;\n    }\n  }\n  return (ret);\n}\n\nvoid DeleteDice(int idx)\n{\n  Dice obj = dice[idx];\n  for(char c : rot[idx]) {\n    Roll(obj, c);\n    if(v[obj.y][obj.x] == idx) {\n      v[obj.y][obj.x] = -1;\n    }\n  }\n}\n\nint rec(int bit)\n{\n  if(bit == (1 << N) - 1) return (0);\n  if(~dp[bit]) return (dp[bit]);\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    if((bit >> i) & 1) continue;\n    int get = AddDice(i);\n    ret = max(ret, rec(bit | (1 << i)) + get);\n    DeleteDice(i);\n  }\n  return (ret);\n}\n\nint main()\n{\n  memset(v, -1, sizeof(v));\n  while(cin >> N, N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> dice[i].x >> dice[i].y;\n      cin >> dice[i].l >> dice[i].r >> dice[i].f >> dice[i].b >> dice[i].d >> dice[i].u;\n      cin >> rot[i];\n      rot[i] = \"~\" + rot[i];\n      dice[i].x += 1050, dice[i].y += 1050;\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,set<pii> > ps;\n\n// LRFB\nconst int R[4][6] = {\n\t{4,5,2,3,1,0},\n\t{5,4,2,3,0,1},\n\t{0,1,4,5,3,2},\n\t{0,1,5,4,2,3},\n};\nconst int vx[]={-1,1,0,0}, vy[]={0,0,-1,1};\n\nint N;\npii S[20];\nint p[20][6];\nstring rot[20];\nint mp[3000][3000];\nint pp[20][3000][3000];\n\nvoid calc(int p[6], string rot, int n, int x, int y){\n\tpp[n][y][x] = p[4]; //?????¢\n\tif( rot.empty() ) return;\n\tint np[6], r;\n\tif( rot[0] == 'L' ) r = 0;\n\tif( rot[0] == 'R' ) r = 1;\n\tif( rot[0] == 'F' ) r = 2;\n\tif( rot[0] == 'B' ) r = 3;\n\trep(i,6) np[ R[r][i] ] = p[i];\n\tcalc(np, rot.substr(1), n, x+vx[r], y+vy[r]);\n}\n\nint sum(int n, set<pii> &st){\n\tint x = S[n].X;\n\tint y = S[n].Y;\n\tint ret = 0;\n\tif( !st.count(pii(x,y)) ){\n\t\tret += pp[n][y][x];\n\t\tst.insert( pii(x,y) );\n\t}\n\trep(i,rot[n].length()){\n\t\tint r;\n\t\tif( rot[n][i] == 'L' ) r = 0;\n\t\tif( rot[n][i] == 'R' ) r = 1;\n\t\tif( rot[n][i] == 'F' ) r = 2;\n\t\tif( rot[n][i] == 'B' ) r = 3;\n\t\tx += vx[r];\n\t\ty += vy[r];\n\t\tif( !st.count(pii(x,y)) ){\n\t\t\tret += pp[n][y][x];\n\t\t\tst.insert( pii(x,y) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint solve(int k, set<pii> &st){\n\tint ret=0;\n\trep(i,N) if( !((1<<i)&k) ){\n\t\tauto _st = st;\n\t\tret = max(ret, sum(i,_st) + solve(k|(1<<i), _st) );\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>N, N){\n\t\tfill( (int*)mp[0], (int*)mp[3000], 0 );\n\t\tfill( (int*)pp[0], (int*)pp[20], 0 );\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 1500;\n\t\t\ty += 1500;\n\t\t\tS[i] = pii(x,y);\n\t\t\trep(j,6) cin >> p[i][j];\n\t\t\tcin >> rot[i];\n\t\t\tcalc(p[i], rot[i], i, x, y);\n\t\t}\n\t\tset<pii> st;\n\t\tcout << solve(0,st) << endl;\n\t\t//ps dp[1<<16]={};\n//\t\tint dp[1<<16] = {};\n//\t\trep(k,1<<N){\n//\t\t\trep(i,N) if( k&(1<<i) ){\n//\t\t\t\t//auto st = dp[k^(1<<i)].Y;\n//\t\t\t\t//int tmp = dp[k^(1<<i)].X + sum( i, st );\n//\t\t\t\tint tmp = dp[k^(1<<i)] + sum( i, k^(1<<i) );\n//\t\t\t\tdp[k] = max( dp[k], tmp );\n//\t\t\t}\n//\t\t}\n//\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<double,int> P;\n\nstruct Dice{\n  int s[6];\n  void roll(char c){\n    int b;\n    if(c=='E'){\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='W'){\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='N'){\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='S'){\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n    // migi neji (not verified)\n    if(c=='R'){\n      b=s[1];\n      s[1]=s[3];\n      s[3]=s[4];\n      s[4]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      b=s[1];\n      s[1]=s[2];\n      s[2]=s[4];\n      s[4]=s[3];\n      s[3]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int hash(){\n    int res=0;\n    for(int i=0;i<6;i++) res=res*256+s[i];\n    return res;\n  }\n};\n\nint dp[1<<15],n,x[16],y[16];\nstring s[16];\nset<P>st[16];\n\nint main(){\n    while(cin>>n,n){\n        r(i,16)st[i].clear();\n        Dice D[n];\n        r(i,n){\n            cin>>x[i]>>y[i];\n            cin>>D[i].s[3]>>D[i].s[2]>>D[i].s[1]>>D[i].s[4]>>D[i].s[5]>>D[i].s[0];\n            cin>>s[i];s[i]=\"@\"+s[i];\n            int X=x[i],Y=y[i];\n            r(j,s[i].size()){\n                if(s[i][j]=='R')X++;\n                if(s[i][j]=='L')X--;\n                if(s[i][j]=='B')Y++;\n                if(s[i][j]=='F')Y--;\n                st[i].insert(P(X,Y));\n            }\n        }\n        memset(dp,0,sizeof(dp));\n        for(int i=0;i<(1<<n);i++){\n            for(int j=0;j<n;j++){\n                if((1<<j)&i)continue;\n                int sum=0,X=x[j],Y=y[j];\n                Dice d=D[j];\n                map<P,int>pre;\n                for(int k=0;k<s[j].size();k++){\n                    int flag=0;\n                    if(s[j][k]=='R')X++,d.roll('E');\n                    if(s[j][k]=='L')X--,d.roll('W');\n                    if(s[j][k]=='B')Y++,d.roll('N');\n                    if(s[j][k]=='F')Y--,d.roll('S');\n                    r(l,n)if(l!=j&&((1<<l)&i)){\n                        if(st[l].count(P(X,Y)))flag++;\n                    }\n                    if(flag)continue;\n                    if(pre.count(P(X,Y)))sum-=pre[P(X,Y)];\n                    pre[P(X,Y)]=d.s[5];\n                    sum+=d.s[5];\n                }\n                dp[i|(1<<j)]=max(dp[i|(1<<j)],dp[i]+sum);\n            }\n        }\n        cout<<dp[(1<<n)-1]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n//using pll = pair<ll, ll>;\nusing pii = pair<unsigned short, unsigned short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<umap<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<unsigned short, umap<pii, char>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nmap<pii, int> table;\nint tmp_table[4000][4000];\nint rots(int n, bool update=false){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\tmap<pii,int> tb;\n\t//fill( tb[0], tb[0]+4000*4000, 0 );\n\ttb[pii(pos.X, pos.Y)] = dc.point();\n\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[pii(pos.X,pos.Y)] = dc.point();\n\t\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\t}\n\t// merge\n\tint sum = 0;\n\tdc = dice_org[n];\n\tpos = dice_pos[n];\n\tif( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t\tsum += tb[pii(pos.X,pos.Y)];\n\t\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t}\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\tif( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t\t\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t\t\tsum += tb[pii(pos.X,pos.Y)];\n\t\t\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\t\t//rrep(i,N){\n\t\t//\tfill( table[0], table[0]+4000*4000, 0 );\n\t\t//\tcout << \"rots: \" << rots(i) << endl;\n\t\t//}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\t//fill( table[0], table[0]+4000*4000, 0 );\n\t\t\ttable.clear();\n\t\t\trep(k,N) if( (1<<k)&i ) rots(k, true);\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + rots(k) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dice\n{\n  int x, y;\n  int l, r, f, b, d, u;\n\n  void RollF()\n  {\n    --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollB()\n  {\n    ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL()\n  {\n    --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n  void RollR()\n  {\n    ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n};\n\nint N;\nDice dice[15];\nstring rot[15];\nint dp[1 << 15];\nint v[2100][2100], buff[2100][2100];\n\nvoid Roll(Dice& obj, char c)\n{\n  switch(c) {\n    case 'L':\n      obj.RollL();\n      return;\n    case 'R':\n      obj.RollR();\n      return;\n    case 'B':\n      obj.RollB();\n      return;\n    case 'F':\n      obj.RollF();\n      return;\n    default:\n      return;\n  }\n}\n\nint AddDice(int idx)\n{\n  int ret = 0;\n  Dice obj = dice[idx];\n  for(char c : rot[idx]) {\n    Roll(obj, c);\n    if(v[obj.y][obj.x] == -1) {\n      v[obj.y][obj.x] = idx;\n      buff[obj.y][obj.x] = obj.d;\n      ret += obj.d;\n    } else if(v[obj.y][obj.x] == idx) {\n      ret -= buff[obj.y][obj.x];\n      ret += obj.d;\n      buff[obj.y][obj.x] = obj.d;\n    }\n  }\n  return (ret);\n}\n\nvoid DeleteDice(int idx)\n{\n  Dice obj = dice[idx];\n  for(char c : rot[idx]) {\n    Roll(obj, c);\n    if(v[obj.y][obj.x] == idx) {\n      v[obj.y][obj.x] = -1;\n    }\n  }\n}\n\nint rec(int bit)\n{\n  if(bit == (1 << N) - 1) return (0);\n  if(~dp[bit]) return (dp[bit]);\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    if((bit >> i) & 1) continue;\n    int get = AddDice(i);\n    ret = max(ret, rec(bit | (1 << i)) + get);\n    DeleteDice(i);\n  }\n  return (dp[bit] = ret);\n}\n\nint main()\n{\n  memset(v, -1, sizeof(v));\n  while(cin >> N, N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> dice[i].x >> dice[i].y;\n      cin >> dice[i].l >> dice[i].r >> dice[i].f >> dice[i].b >> dice[i].d >> dice[i].u;\n      cin >> rot[i];\n      rot[i] = \"~\" + rot[i];\n      dice[i].x += 1050, dice[i].y += 1050;\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nenum { U, B, L, F, R, D };\nstruct Dice {\n\tint face[6];\n\n\tDice() {\n\t\tface[F] = 1;\n\t\tface[R] = 2;\n\t\tface[U] = 3;\n\t\tface[B] = 6;\n\t\tface[L] = 5;\n\t\tface[D] = 4;\n\t}\n\n\tint find_face(int f) {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(face[i] == f) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R:\n\t\t\trotate(U, R, D, L);\n\t\t\tbreak;\n\t\tcase B:\n\t\t\trotate(U, B, D, F);\n\t\t\tbreak;\n\t\tcase L:\n\t\t\trotate(U, L, D, R);\n\t\t\tbreak;\n\t\tcase F:\n\t\t\trotate(U, F, D, B);\n\t\t\tbreak;\n\t\tcase U:\n\t\t\trotate(F, R, B, L);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tcase D:\n\t\t\trotate(F, L, B, R);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\tint& operator[](int n) { return face[n]; }\n\n\tconst int& operator[](int n) const { return face[n]; }\n\n\tstd::vector<Dice> all_rolls() {\n\t\tstd::vector<Dice> res;\n\t\tfor(int k = 0; k < 6; k++) {\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tres.push_back(*this);\n\t\t\t\tturn(R);\n\t\t\t}\n\t\t\tturn(k % 2 == 1 ? U : F);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c];\n\t\tface[c] = face[b];\n\t\tface[b] = face[a];\n\t\tface[a] = t;\n\t}\n};\n\ntypedef pair<int, int> P;\n\nDice dice[15];\nint X[15], Y[15];\nstring rot[15];\nmap<P, int> pos[15];\nint dp[16][1 << 15];\nset<P> used[1 << 15];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint l, r, f, b, d, u;\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\t\tcin >> rot[i];\n\t\t\tdice[i][L] = l;\n\t\t\tdice[i][R] = r;\n\t\t\tdice[i][F] = f;\n\t\t\tdice[i][B] = b;\n\t\t\tdice[i][D] = d;\n\t\t\tdice[i][U] = u;\n\n\t\t\tDice t = dice[i];\n\t\t\tint x = X[i], y = Y[i];\n\t\t\tpos[i].clear();\n\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\tfor(auto c : rot[i]) {\n\t\t\t\tif(c == 'L') t.turn(L), x--;\n\t\t\t\tif(c == 'R') t.turn(R), x++;\n\t\t\t\tif(c == 'F') t.turn(F), y--;\n\t\t\t\tif(c == 'B') t.turn(B), y++;\n\t\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 1 << N; i++) {\n\t\t\tused[i].clear();\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(i >> j & 1) {\n\t\t\t\t\tfor(auto p : pos[j]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tused[i].insert({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, -1, sizeof dp);\n\t\tdp[0][0] = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\tint s = dp[i][j];\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tif(j >> k & 1) continue;\n\t\t\t\t\tint ns = s;\n\t\t\t\t\tfor(auto p : pos[k]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tint point = p.second;\n\t\t\t\t\t\tif(used[j].count({ x, y })) continue;\n\t\t\t\t\t\tns += point;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j | (1 << k)] = max(dp[i + 1][j | (1 << k)], ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\tans = max(ans, dp[N][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define ARRAY 65536\n#define DBG 0\n#define SHIFT 2200\nusing namespace std;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n      std::fill( (T*)array, (T*)(array+N), val );\n}\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n};\nclass iStump{\n  public:\n  int id, val;\n  iStump(int _id, int _val):id(_id),val(_val){}; \n};\n\n//int mpl[2200][2200] ={0};\n\n// ??§?¨????id 31*15?????§\nmap<pair<int,int>, int> memo;\n\nint main(void){\n  int n;\n  while(cin >> n){\n    vector<char> paths[ARRAY];\n    int xy[1024][16] = {0};\n    int dp[ARRAY] = {0};\n    int x, y, v;\n    int ans = 0;\n    int used_xy = 0;\n\n    string r;\n    Dice dice;\n    vector<Stump> ts[32];\n    vector<iStump> s[32];\n\n\n    rep(i,n){\n      cin >> x >> y;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      x+=1050;\n      y+=1050;\n      ts[i].push_back(Stump(x, y, dice[5]));\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        ts[i].push_back(Stump(x, y, dice[5]));\n      }\n      map<int, int> used;\n      for(int k = ts[i].size()-1; k >= 0 ; --k){\n        if(used[ts[i][k].x*SHIFT+ts[i][k].y] != 0){\n          ts[i][k].value = 0;\n        }else{\n          memo[make_pair(ts[i][k].x,ts[i][k].y)] = used_xy++;\n        }\n        used[ts[i][k].x*SHIFT+ts[i][k].y] = 1;\n      }\n      rep(k,ts[i].size()){\n          if(ts[i][k].value > 0){\n            int cell_id = memo[make_pair(ts[i][k].x,ts[i][k].y)];\n            s[i].push_back( iStump(cell_id, ts[i][k].value));\n            xy[ cell_id][i] = ts[i][k].value;\n          }\n      }\n      //cout << ts[i].size() << \" \" << s[i].size() << endl;;\n      used.clear();\n    }\n\n    rep(i, 1<<n){\n      int state = i;\n      int baselp = dp[state];\n\n      if(DBG) cout << \"baselp \" << baselp << endl;\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          int lp = 0;\n          //map<int, int> mpl;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          rep(l, s[k].size()){\n            iStump ss = s[k][l];\n            int current = 0;\n\n            rep(j, paths[state].size()){\n              current = xy[ss.id][paths[state][j]]!=0? xy[ss.id][paths[state][j]] : current;\n            }\n            lp += ss.val - current;\n\n          }\n          if(DBG)cout << \" res = \" << lp+baselp << endl;\n          if(dp[state|mask] < lp+baselp){\n            dp[state|mask] = lp+baselp;\n            paths[state|mask] = paths[state];\n            paths[state|mask].push_back(k);\n          }\n        }\n      }\n    }\n    if(DBG)cout <<\"case ans---\" <<endl;\n    cout << dp[(1<<n)-1] << endl;\n    if(DBG)cout <<\"case end---\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nusing P = pair<int,int>; //x,y;\nusing T = tuple<int,int,int>; //x,y,b\nint main(){\n    map<P,int> overlap;//int??????????????°?????????\n    map<P,int> Mov[15];\n    int N;\n    while(cin>>N,N){\n        overlap.clear();\n        for(int i=0;i<15;i++) Mov[i].clear();\n        for(int i=0;i<N;i++){\n            int x,y;\n            cin>>x>>y;\n            int l,r,f,b,d,u;\n            cin>>l>>r>>f>>b>>d>>u;\n            string rot;\n            cin>>rot;\n            overlap[P(x,y)]|=(1<<i);\n            Mov[i][P(x,y)]=d;\n            // cout<<d<<endl;\n            for(auto c:rot){\n                int temp=d;\n                switch(c){\n                    case 'L':\n                        d=l;l=u;u=r;r=temp;\n                        x--;\n                        break;\n                    case 'R':\n                        d=r;r=u;u=l;l=temp;\n                        x++;\n                        break;\n                    case 'B':\n                        d=b;b=u;u=f;f=temp;\n                        y++;\n                        break;\n                    case 'F':\n                        d=f;f=u;u=b;b=temp;\n                        y--;\n                        break;\n                    default:\n                        break;\n                }\n                // cout<<d<<endl;\n                overlap[P(x,y)]|=(1<<i);\n                Mov[i][P(x,y)]=d;\n            }\n        }\n        int dp[1<<N];\n        fill(dp,dp+(1<<N),0);\n        for(int b=0;b<(1<<N);b++){\n            for(int i=0;i<N;i++){\n                if(b&(1<<i)) continue;\n                int bb=b|(1<<i);\n                int diff=0;\n                for(auto p:Mov[i]){\n                    int x,y,d; tie(x,y)=p.first; d=p.second;\n                    if(overlap[P(x,y)]&b) continue;\n                    else diff+=d;\n                }\n                dp[bb]=max(dp[bb],dp[b]+diff);\n            }\n        }\n        cout<<dp[(1<<N)-1]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstruct dice {\n\tint top;\n\tint bottom;\n\tint front;\n\tint back;\n\tint left;\n\tint right;\n};\n\nvoid rotate_front(dice* d) {\n\tint tmp = d->top;\n\td->top = d->back;\n\td->back = d->bottom;\n\td->bottom = d->front;\n\td->front = tmp;\n}\n\nvoid rotate_back(dice* d) {\n\tint tmp = d->top;\n\td->top = d->front;\n\td->front = d-> bottom;\n\td->bottom = d-> back;\n\td->back = tmp;\n}\n\nvoid rotate_right(dice* d) {\n\tint tmp = d->top;\n\td->top = d->left;\n\td->left = d->bottom;\n\td->bottom = d->right;\n\td->right = tmp;\n}\n\nvoid rotate_left(dice* d) {\n\tint tmp = d->top;\n\td->top = d->right;\n\td->right = d->bottom;\n\td->bottom = d->left;\n\td->left = tmp;\n}\n\nint n;\nmap<P,int> mp;\nvector<PP> vec[101];\nint sum[101];\n\nll dp[1<<15];\nset<P> data[1<<15];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmp.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tdice d;\n\t\t\tscanf(\"%d%d%d%d%d%d\",&d.left,&d.right,&d.front,&d.back,&d.bottom,&d.top);\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tmap<P,int> m;\n\t\t\tm[P(x,y)]=d.bottom;\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]=='R'){\n\t\t\t\t\trotate_right(&d);\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='L'){\n\t\t\t\t\trotate_left(&d);\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='F'){\n\t\t\t\t\trotate_front(&d);\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='B'){\n\t\t\t\t\trotate_back(&d);\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tm[P(x,y)]=d.bottom;\n\t\t\t}\n\t\t\tvec[i].clear();\n\t\t\tsum[i]=0;\n\t\t\tfor(map<P,int>::iterator it=m.begin();it!=m.end();it++){\n\t\t\t\tvec[i].push_back(PP(it->first,it->second));\n\t\t\t\tsum[i]+=(it->second);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tdata[i].clear();\n\t\t}\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(!(i>>j & 1)){\n\t\t\t\t\tll val=dp[i];\n\t\t\t\t\tfor(int k=0;k<vec[j].size();k++){\n\t\t\t\t\t\tif(data[i].find(vec[j][k].first)==data[i].end()){\n\t\t\t\t\t\t\tdata[i|(1<<j)].insert(vec[j][k].first);\n\t\t\t\t\t\t\tval+=vec[j][k].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i|(1<<j)]=max(dp[i|(1<<j)],val);\n\t\t\t\t\tres=max(res,dp[i|(1<<j)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n \n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define MP(x,y) make_pair(x,y)\n#define ARRAY 65536\n#define X first\n#define Y second\n#define DBG 0\nusing namespace std;\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n      std::fill( (T*)array, (T*)(array+N), val );\n}\n \nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n \nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n  void print(){\n    cout << \"(  \" << x<< \" , \" << y<< \" ) \" << value << endl;\n  }\n};\nclass iStump{\n  public:\n  int id, val;\n  iStump(int _id, int _val):id(_id),val(_val){}; \n};\n \n//int mpl[2200][2200] ={0};\n \n// ???§??¨????id 31*15??????§\nmap<pair<int,int>, int> memo;\n \nint main(void){\n  int n;\n  int ca = 0;\n  while(cin >> n, n){\n    vector<char> paths[ARRAY]; //[state]??????¨???????????????????????????\n    int dp[ARRAY] = {0}; //[state]??????¨????????????§???\n    int xy[1024][16] = {0}; //[???§??¨?id]???[????????????id] ??? ??????????????????\n    int x, y, v;\n    int ans = 0;\n    int used_xy = 0;\n    memo.clear();\n \n    string r;\n    vector<Stump> ts[32];\n    vector<iStump> s[32];\n \n    rep(i,n){\n      Dice dice;\n      cin >> x >> y;\n      x+=1050;\n      y+=1050;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      ts[i].push_back(Stump(x, y, dice[5]));\n      if(DBG) ts[i].back().print();\n \n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        ts[i].push_back(Stump(x, y, dice[5]));\n        if(DBG) ts[i].back().print();\n      }\n \n      map<pair<int,int>, int> used;\n      for(int k = ts[i].size()-1; k >= 0 ; --k){\n        pair<int,int> xyz=MP(ts[i][k].x,+ts[i][k].y);\n        if(used[xyz] != 0) ts[i][k].value = 0;\n        if(memo[xyz] == 0){\n          //cout << xyz.X << \" \" << xyz.Y << \" \" << used_xy << endl;\n          memo[xyz] = ++used_xy;\n        }\n        used[xyz] = 1;\n      }\n \n \n      int sum = 0;\n      //cout << i << endl;\n      rep(k,ts[i].size()){\n        if(ts[i][k].value > 0){\n          int cell_id = memo[MP(ts[i][k].x,ts[i][k].y)];\n          s[i].push_back( iStump(cell_id, ts[i][k].value));\n          xy[cell_id][i] = ts[i][k].value;\n//           cout << cell_id << \" -> \" << xy[cell_id][i] << endl;\n          sum += xy[cell_id][i];\n        }\n      }\n//      cout << \"sum \" << sum << endl;\n    }\n//     rep(i, used_xy){\n//       rep(j, n){\n//         cout << xy[i][j] << \"\\t\";\n//       }cout << endl;\n//     }\n \n    //DP\n    rep(i, (1<<n)-1){\n      int state = i;\n      if(DBG) cout << \"baselp \" << dp[state] << endl;\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          int lp = 0;\n          if(DBG)cout << \"stump(rev) \" << k;\n \n          rep(l, s[k].size()){\n            iStump ss = s[k][l];\n            int current = 0;\n \n            for(int j = paths[state].size()-1; j >= 0; --j){\n              if(xy[ss.id][paths[state][j]] > 0){\n                current = xy[ss.id][paths[state][j]];\n                break;\n              }\n            }\n            if(current==0) lp += ss.val;\n          }\n          if(DBG)cout << \" res = \" << lp+dp[state] << endl;\n          if(dp[state|mask] < lp+dp[state]){\n            dp[state|mask] = lp+dp[state];\n            //paths[state|mask] = paths[state];\n            paths[state|mask].clear();\n            paths[state|mask].push_back(k);\n            rep(j,paths[state].size()) paths[state|mask].push_back(paths[state][j]);\n          }\n        }\n      }\n    }\n \n    cout << dp[(1<<n)-1] << endl;\n//     cout << \"case\" << endl;\n//     rep(i, paths[(1<<n)-1].size()){\n//       cout << paths[(1<<n)-1][i] << endl;\n//     }\n \n  }\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int MAX_N = 15;\n\nstruct Dice{\n  int l, r, f, b, d, u;\n  int x, y;\n\n  Dice(int _l, int _r, int _f, int _b, int _d, int _u, int _x, int _y){\n    l = _l; r = _r; f = _f; b = _b; d = _d; u = _u; x = _x; y = _y;\n  }\n\n  void Left(){\n    int tmp = u;\n    u = r;\n    r = d;\n    d = l;\n    l = tmp;\n    x -= 1;\n  }\n\n  void Right(){\n    int tmp = u;\n    u = l;\n    l = d;\n    d = r;\n    r = tmp;\n    x += 1;\n  }\n\n  void Front(){\n    int tmp = f;\n    f = u;\n    u = b;\n    b = d;\n    d = tmp;\n    y -= 1;\n  }\n\n  void Back(){\n    int tmp = u;\n    u = f;\n    f = d;\n    d = b;\n    b = tmp;\n    y += 1;\n  }\n\n  void Role(char c){\n    if(c == 'L') Left();\n    else if(c == 'R') Right();\n    else if(c == 'F') Front();\n    else Back();\n  }\n\n  pi cord(){\n    return pi(x, y);\n  }\n\n  void print(){\n    cout << l << \" \" << r << \" \" << f << \" \" << b << \" \" << d << \" \" << u << endl;\n  }\n};\n\nint N;\nmap<pi, int>Scores[16];\nmap<pi, int>Map;\nint dp[1<<MAX_N];\n\nint dfs(int S)\n{\n\n  if(S == (1<<N)-1){\n    return 0;\n  }\n\n  int &res = dp[S];\n  for(int u=0;u<N;++u){\n    if(!(S >> u & 1)){\n      int score = 0;\n      int nS = S | 1 << u;\n      for(auto mass: Scores[u]){\n\tpi cord = mass.first;\n\tif((Map[cord] & nS) == Map[cord]) score += mass.second;\n      }\n      res = max(res, dfs(nS) + score);      \n    }\n  }\n  return res;\n}\n\nint main()\n{\n  while(cin >> N, N){\n    memset(dp, 0, sizeof(dp));\n    for(int i=0;i<N;i++) Scores[i].clear();\n    Map.clear();\n    for(int i=0;i<N;i++){\n      int x, y, l, r, f, b, d, u;\n      string rot;\n      cin >> x >> y >> l >> r >> f >> b >> d >> u >> rot;\n      Dice dice(l, r, f, b, d, u, x, y);\n      pi cord = dice.cord();      \n      Scores[i][cord] =  dice.d;\n      if(Map.find(cord) == Map.end())\n\tMap[cord] = 0;\n      Map[cord] = Map[cord] | (1<<i);\n      for(auto c: rot){\n\tdice.Role(c);\n\t//\tdice.print();\n\tcord = dice.cord();\t\n\tScores[i][cord] =  dice.d;\n\tif(Map.find(cord) == Map.end())\n\t  Map[cord] = 0;\n\tMap[cord] = Map[cord] | (1<<i);\t\n      }\n\n\n      //      int sum = 0;\n      /*      for(auto x: Scores[i]){\n\tcout << x.first.first << \" \"<< x.first.second << \" \" << x.second << endl;\n\t//\tsum += x.second;\n      }\n\n      for(auto x: Map){\n\tcout << x.first.first << \" \"<< x.first.second << \" \" << x.second << endl;\t\n      }\n      */\n      //      cout << sum  << endl;\n    }\n    \n    cout << dfs(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dx[4] = {1, 0, 0, -1};\nint dy[4] = {0, 1, -1, 0};\n//l r f b d u\n//0 1 2 3 4 5\nint go[4][6] = {\n    {5, 4, 2, 3, 0, 1},\n    {0, 1, 5, 4, 2, 3},\n    {0, 1, 4, 5, 3, 2},\n    {4, 5, 2, 3, 1, 0}\n};\nconst int N(65555);\nconst int LOG(16);\nint x[LOG], y[LOG];\nchar st[555];\nint a[6], b[6], tp[555], lg2[N];\nvector<pair<pair<int, int>,int> > vec[LOG];\nint cnf[LOG][LOG], totcnf[N][LOG], ic[N][LOG], ans[N];\nint main() {\n    tp['R'] = 0;\n    tp['B'] = 1;\n    tp['F'] = 2;\n    tp['L'] = 3;\n    int n;\n    for(;;) {\n        scanf(\"%d\", &n);\n        if(!n) {\n            break;\n        }\n        for(int i(0); i < n; i++) {\n            scanf(\"%d%d\", &x[i], &y[i]);\n            for(int j(0); j < 6; j++) {\n                scanf(\"%d\", &a[j]);\n            }\n            scanf(\"%s\", st);\n            int len(strlen(st));\n            vec[i].clear();\n            for(int j(0); j <= len; j++) {\n                //printf(\"%d %d %d %d\\n\", i, x[i], y[i], a[4]);\n                vec[i].push_back(make_pair(make_pair(x[i], y[i]), a[4]));\n                if(j != len) {\n                    for(int k(0); k < 6; k++) {\n                        b[go[tp[st[j]]][k]] = a[k];\n                    }\n                    memcpy(a, b, sizeof(b));\n                    x[i] += dx[tp[st[j]]];\n                    y[i] += dy[tp[st[j]]];\n                }\n            }\n            for(int j(0); j + 1 < (int)vec[i].size(); j++) {\n                bool flag(false);\n                for(int k(j + 1); k < (int)vec[i].size(); k++) {\n                    if(vec[i][j].first == vec[i][k].first) {\n                        flag = true;\n                        break;\n                    }\n                }\n                if(flag) {\n                    vec[i].erase(vec[i].begin() + j);\n                    j--;\n                }\n            }\n            for(int j(0); j < i; j++) {\n                cnf[j][i] = 0;\n                cnf[i][j] = 0;\n                for(int k(0); k < (int)vec[i].size(); k++) {\n                    for(int l(0); l < (int)vec[j].size(); l++) {\n                        if(vec[i][k].first == vec[j][l].first) {\n                            cnf[j][i] |= 1 << k;\n                            cnf[i][j] |= 1 << l;\n                        }\n                    }\n                }\n                //printf(\"cnf[%d][%d] = %d\\n\", i, j, cnf[i][j]);\n            }\n        }\n        for(int i(0); i < n; i++) {\n            lg2[1 << i] = i;\n        }\n        for(int msk(0); msk < (1 << n); msk++) {\n            for(int i(0); i < n; i++) {\n                if((msk & (1 << i)) == 0) {\n                    ic[msk][i] = 0;\n                    totcnf[msk][i] = msk == 0 ? 0 : totcnf[msk - (msk & -msk)][i] | cnf[lg2[msk & -msk]][i];\n                    for(int j(0); j < (int)vec[i].size(); j++) {\n                        ic[msk][i] += (totcnf[msk][i] & (1 << j)) ? 0 : vec[i][j].second;\n                    }\n                    //printf(\"ic[%d][%d] = %d\\n\", msk, i, ic[msk][i]);\n                }\n            }\n        }\n        memset(ans, 0, sizeof(ans));\n        for(int msk(0); msk < (1 << n); msk++) {\n            for(int i(0); i < n; i++) {\n                if((msk & (1 << i)) == 0) {\n                    ans[msk | (1 << i)] = max(ans[msk | (1 << i)], ans[msk] + ic[msk][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\", ans[(1 << n) - 1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 16\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint n;\nstruct dat{int x,y;Dice d;};\ndat A[N];\nstring rot[N];\ntypedef pair<int,int> P;\ntypedef map<P,int> M;\n\nmap <M,int> mem[1<<N];\n\nint getScore(M mp){\n  int res = 0;\n  for(pair<P,int> p:mp) res += p.second;\n  return res;\n}\n\nM getNx(int idx,M res){\n  static int dx[1<<8]={};dx['L'] = -1, dx['R'] = 1;\n  static int dy[1<<8]={};dy['F'] = -1, dy['B'] = 1;\n  int x = A[idx].x, y = A[idx].y;  \n  Dice d = A[idx].d;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot[idx]){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nint dfs(int bit,M mp){\n  int res = getScore(mp);\n  if(mem[bit].count(mp)) return mem[bit][mp];\n\n  for(int i=0;i<n;i++){\n    if(bit>>i&1)continue;\n    int nbit = bit | (1<<i);\n    M nmp = getNx(i,mp);\n    res = max(res,dfs(nbit,nmp));\n  }\n  return mem[bit][mp] = res;\n}\n\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot[i];\n      A[i] = (dat){x,y,Dice(l,r,f,b,d,u)};\n    }\n    for(int i=0;i<(1<<N);i++) mem[i].clear();\n    cout<<dfs(0,M())<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct Dice {\n\tint tp;\n\tint bo;\n\tint no;\n\tint so;\n\tint ea;\n\tint we;\n\tDice(const int tp_, const int bo_, const int no_, const int so_, const int ea_, const int we_) :\n\t\ttp(tp_), bo(bo_), no(no_), so(so_), ea(ea_), we(we_) {\n\t}\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice() {\n\t\ttp = 1;\n\t\t/*bo = 6;\n\t\tno = 2;\n\t\tso = 5;\n\t\tea = 3;\n\t\twe = 4;*/\n\t}\n\tenum R_Way {\n\t\tR_Left=0,\n\t\tR_Front=1,\n\t\tR_Right=2,\n\t\tR_Back=3,\n\n\t\tR_Dummy,\n\t};\n\tint rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tint c = tp;\n\t\t\ttp = we;\n\t\t\twe = bo;\n\t\t\tbo = ea;\n\t\t\tea = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tint c = tp;\n\t\t\ttp = so;\n\t\t\tso = bo;\n\t\t\tbo = no;\n\t\t\tno = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\tint c = tp;\n\t\t\ttp = ea;\n\t\t\tea = bo;\n\t\t\tbo = we;\n\t\t\twe = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\tint c = tp;\n\t\t\ttp = no;\n\t\t\tno = bo;\n\t\t\tbo = so;\n\t\t\tso = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\treturn tp;\n\t}\n\tint rotate(const int way) {\n\t\treturn rotate(static_cast<R_Way>(way));\n\t}\n\tint hash()const {\n\t\treturn tp + we * 6 + no * 36;\n\t}\n};\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\n\nint gettop(int south, int east) {\n\treturn geteast(south, east);\n}\nint getsouth(int east, int top) {\n\treturn 7 - geteast(top, east);\n}\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\n\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,-1,0,1 };\n\npair<int,map<pair<short, short>, int>>getmemo(const vector<map<pair<short, short>, short>>&field,vector<pair<int,map<pair<short, short>, short>>>&memo,bitset<15>&used) {\n\tif (memo[used.to_ulong()].second.empty()) {\n\t\tif (!used.count()) {\n\t\t\treturn make_pair(0,map < pair<short, short>, short> ());\n\t\t}\n\t\telse {\n\t\t\tint high_sc = -1;\n\t\t\tmap<pair<int, int>, int>hi_fi;\n\t\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\t\tif (used[i]) {\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tauto pre(getmemo(field,memo, used));\n\t\t\t\t\t int sc = pre.first;\n\t\t\t\t\tauto pre_fi = pre.second;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tfor (auto n_c : field[i]) {\n\t\t\t\t\t\tif (pre_fi.find(n_c.first) == pre_fi.end()) {\n\t\t\t\t\t\t\tpre_fi[n_c.first] = n_c.second;\n\t\t\t\t\t\t\tsc += n_c.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (high_sc < sc) {\n\t\t\t\t\t\thigh_sc = sc;\n\t\t\t\t\t\thi_fi = pre_fi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[used.to_ulong()]=make_pair(high_sc, hi_fi);\n\t\t}\n\t}\n\telse {\n\t\treturn memo[used.to_ulong()];\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<map<pair<short, short>, short>>field(N, map<pair<short, short>, short>());\n\t\tmap<char, short>name;\n\t\tname['R'] = 2;\n\t\tname['L'] = 0;\n\t\tname['B'] = 3;\n\t\tname['F'] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmap<pair<short, short>, short>mp;\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tint l, r, f, b, d, u; cin >> l >> r >> f >> b >> d >> u;\n\t\t\tstring rot; cin >> rot;\n\t\t\tmp[make_pair(x, y)] = d;\n\t\t\tDice di(u, d, b, f, r, l);\n\n\t\t\tfor (auto c : rot) {\n\t\t\t\tconst int way = name[c];\n\t\t\t\tx += dx[way];\n\t\t\t\ty += dy[way];\n\t\t\t\tdi.rotate(way);\n\t\t\t\tmp[make_pair(x, y)] = di.bo;\n\t\t\t}\n\t\t\tfield[i] = mp;\n\t\t}\n\t\tvector<pair<int,map<pair<short, short>, short>>>memo(1<<N);\n\t\tbitset<15>bs((1 << N) - 1);\n\t\tauto ans = getmemo(field, memo, bs);\n\t\tcout << ans.first << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\n\n\nstruct Dice\n{\n\tint top, bottom, right, left, front, back;\n\tint x, y;\n\tstring s;\n\tDice() {};\n\tDice(int t, int bt, int r, int l, int f, int bk, int x, int y, string s) : top(t), bottom(bt), right(r), left(l), front(f), back(bk), x(x), y(y), s(s) { ; };\n\tvoid to_front() \n\t{\n\t\tint t = front;\n\t\tfront = top;\n\t\ttop = back;\n\t\tback = bottom;\n\t\tbottom = t;\n\t}\n\tvoid to_back() { REP(i, 3) to_front(); }\n\tvoid to_right() \n\t{\n\t\tint t = right;\n\t\tright = top;\n\t\ttop = left;\n\t\tleft = bottom;\n\t\tbottom = t;\n\t}\n\tvoid to_left() { REP(i, 3) to_right(); }\n};\n\nint n;\nvector<Dice> v;\nint vis[4000][4000];\nint dp[1 << 16];\n\nint solve(int bit)\n{\n\tif (bit == (1 << n) - 1) return 0;\n\tif (dp[bit] >= 0) return dp[bit];\n\tint res = 0;\n\tREP(i, n)\n\t{\n\t\tDice tmp = v[i];\n\t\tif ((bit >> i) & 1) continue;\n\t\tint nbit = bit | (1 << i);\n\t\tint sum = 0;\n\t\tint x = tmp.x, y = tmp.y;\n\t\tstring s = tmp.s;\n\t\tmap<pii, int> mp;\n\t\tif ((nbit | vis[x][y]) == nbit) mp[pii(x,y)] = tmp.bottom;\n\t\tfor (auto j : s)\n\t\t{\n\t\t\tif (j == 'L')\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\ttmp.to_left();\n\t\t\t}\n\t\t\tif (j == 'R')\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\ttmp.to_right();\n\t\t\t}\n\t\t\tif (j == 'F')\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\ttmp.to_front();\n\t\t\t}\n\t\t\tif (j == 'B')\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\ttmp.to_back();\n\t\t\t}\n\t\t\tif ((nbit | vis[x][y]) == nbit) mp[pii(x, y)] = tmp.bottom;\n\t\t}\n\t\tfor (auto k : mp) sum += k.second;\n\t\tchmax(res, solve(nbit) + sum);\n\t}\n\treturn dp[bit] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n, n)\n\t{\n\t\tMS(vis, 0);\n\t\tMS(dp, -1);\n\t\tv.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y, l, r, f, b, d, u;\n\t\t\tcin >> x >> y >> l >> r >> f >> b >> d >> u;\n\t\t\tx += 2000, y += 2000;\n\t\t\tstring s; cin >> s;\n\t\t\tv.emplace_back(u, d, r, l, f, b, x, y, s);\n\t\t}\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x = v[i].x, y = v[i].y;\n\t\t\tstring s = v[i].s;\n\t\t\tvis[x][y] |= 1 << i;\n\t\t\tfor(auto j : s)\n\t\t\t{\n\t\t\t\tif (j == 'L') x--;\n\t\t\t\tif (j == 'R') x++;\n\t\t\t\tif (j == 'F') y--;\n\t\t\t\tif (j == 'B') y++;\n\t\t\t\tvis[x][y] |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tcout << solve(0) << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int LEFT = 0, RIGHT = 1, FRONT = 2, BACK = 3, BOTTOM = 4, TOP = 5;\n\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  \n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\"); /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n  }\n\n  void rot(char ch){rot(string(1,ch));}\n  \n  //奥に転がす\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //手前に転がす\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n  \n  //右に転がす\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //左に転がす\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //上から見て時計回りに回す\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //上からみて反時計回りに回す。\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint dy[300], dx[300];\n\nvoid init(){\n  \n  dy['N'] = 1; dy['E'] = 0; dy['S'] = -1; dy['W'] = 0;\n  \n  dx['N'] = 0; dx['E'] = 1; dx['S'] = 0; dx['W'] = -1;\n  \n}\n\nint n, x[15], y[15];\nstring s[15];\nDice dice[15];\n\ntypedef pair<int,int> P;\n\nmap<P,int> dp[1<<15];\n\nint sum(map<P,int> S){\n  int res = 0;\n  for(auto p : S ) res += p.second;\n  return res;\n}\n\nmap<P,int> add(map<P,int> S, int idx){\n    \n  int X = x[idx], Y = y[idx];\n  \n  Dice d = dice[idx];\n  \n  set<P> used;\n  \n  if( S.count(P( X, Y )) == 0 ){\n    S[P( X, Y )] = d.val[BOTTOM];\n    used.insert(P( X, Y ));\n  }\n  \n  for(int i=0;i<(int)s[idx].size();i++){\n    \n    X += dx[(int)s[idx][i]];\n    \n    Y += dy[(int)s[idx][i]];\n    \n    d.rot(s[idx][i]);\n        \n    if( used.count(P( X, Y )) || S.count(P( X, Y )) == 0 ){\n      S[P( X, Y )] = d.val[BOTTOM];\n      used.insert(P( X, Y ));\n    }\n    \n  }\n  \n  return S;\n}\n\nsigned main(){\n  \n  init();\n\n  while(1){\n \n    cin>>n;\n    if( n == 0 ) break;\n\n    for(int i=0;i<(1<<n);i++) dp[i].clear();\n    \n    for(int i=0;i<n;i++){\n            \n      cin>>x[i]>>y[i];\n      \n      int val[6];\n      \n      for(int j=0;j<6;j++) cin>>val[j];\n      \n      dice[i] = Dice(val);\n      \n      cin>>s[i];\n      \n      for(int j=0;j<(int)s[i].size();j++){\n\tif( s[i][j] == 'B' ) s[i][j] = 'N';\n\tif( s[i][j] == 'R' ) s[i][j] = 'E';\n\tif( s[i][j] == 'F' ) s[i][j] = 'S';\n\tif( s[i][j] == 'L' ) s[i][j] = 'W';\n      }\n      \n    }\n    \n    for(int i=0;i<(1<<n);i++){\n      \n      for(int j=0;j<n;j++){\n\t\n\tif( !( i >> j & 1 ) ){\n\t  \n\t  if( sum( dp[i|(1<<j)] ) < sum( add( dp[i], j ) ) ){\n\t    \n\t    dp[ i | (1<<j) ] = add( dp[i], j );\n\t    \n\t  }\n\t  \n\t}\n\t\n      }\n      \n    }\n    \n    cout << sum( dp[(1<<n)-1] ) << endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*---------------*/\n/*   Darsein AC  */\n/*  O(L n^2 2^n) */\n/* imple: 18 min */\n/* debug:  5 min */\n/*---------------*/\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int L = 0, R = 1, F = 2, B = 3, D = 4, U = 5;\n\nvoid rotation(vi &dice, char dir){\n  if(dir == 'L'){\n    swap(dice[L],dice[U]); swap(dice[U],dice[R]); swap(dice[R],dice[D]);\n  }\n  if(dir == 'R'){\n    swap(dice[R],dice[U]); swap(dice[U],dice[L]); swap(dice[L],dice[D]);\n  }\n  if(dir == 'F'){\n    swap(dice[F],dice[U]); swap(dice[U],dice[B]); swap(dice[B],dice[D]);\n  }\n  if(dir == 'B'){\n    swap(dice[B],dice[U]); swap(dice[U],dice[F]); swap(dice[F],dice[D]);\n  }\n}\n\nint main(){\n  map<char,int> dx,dy;\n  dx['L'] = -1; dx['R'] = 1;\n  dy['F'] = -1; dy['B'] = 1;\n\n  int n;\n  while(cin >> n){\n    if(n==0)break;\n    vector< map<pii,int> > paint(n);\n    map<pii,int> mask;\n\n    rep(i,n){\n      pii pos;\n      cin >> pos.first >> pos.second;\n      vi dice(6);\n      rep(j,6)cin >> dice[j];\n      paint[i][pos] = dice[D];\n      mask[pos] |= 1<<i;\n\n      string rot;\n      cin >> rot;\n      rep(j,rot.size()){\n\trotation(dice,rot[j]);\n\tpos.first += dx[rot[j]]; pos.second += dy[rot[j]];\n\n\tpaint[i][pos] = dice[D];\n\tmask[pos] |= 1<<i;\n      }\n    }\n\n    vi dp(1<<n,0);\n    rep(bit,1<<n){\n      rep(i,n){\n\tif( (bit>>i) & 1 )continue;\n\n\tint nxt = dp[bit];\n\tfor(auto p : paint[i]){\n\t  pii pos = p.first;\n\t  int cost = p.second;\n\n\t  if(mask[pos]&bit)continue;\n\t  nxt += cost;\n\t}\n\tdp[bit|(1<<i)] = max(dp[bit|(1<<i)],nxt);\n      }\n    }\n\n    cout << dp[(1<<n)-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pb push_back\n\ntypedef struct {\n  int l, r, f, b, d, u;\n} dice;\n\ndice rotL(dice d)\n{\n  dice n = d;\n  n.l = d.u;\n  n.u = d.r;\n  n.r = d.d;\n  n.d = d.l;\n  return n;\n}\n\ndice rotR(dice d)\n{\n  dice n = d;\n  n.u = d.l;\n  n.r = d.u;\n  n.d = d.r;\n  n.l = d.d;\n  return n;\n}\n\ndice rotF(dice d)\n{\n  dice n = d;\n  n.f = d.u;\n  n.u = d.b;\n  n.b = d.d;\n  n.d = d.f;\n  return n;\n}\n\ndice rotB(dice d)\n{\n  dice n = d;\n  n.b = d.u;\n  n.u = d.f;\n  n.f = d.d;\n  n.d = d.b;\n  return n;\n}\n\ntypedef struct {\n  int x, y;\n  int num;\n} masu;\n\nmap<pair<int, int>, int> Max(map<pair<int, int>, int> a, map<pair<int, int>, int> b)\n{\n  int suma = 0, sumb = 0;\n  for (auto it = a.begin(); it != a.end(); it++) suma += it->second;\n  for (auto it = b.begin(); it != b.end(); it++) sumb += it->second;\n  if (suma > sumb) return a;\n  return b;\n}\n\nmap<pair<int, int>, int> stamp(map<pair<int, int>, int> p, vec<masu> s)\n{\n  rep(i, s.size()) {\n    if (p[make_pair(s[i].x, s[i].y)]) continue;\n    p[make_pair(s[i].x, s[i].y)] = s[i].num;\n  }\n  return p;\n}\n\nint main(void)\n{\n  while(1) {\n    int n;\n    cin >> n;\n    if (!n) break;\n    \n    vec<vec<masu> > stamps(n);\n    rep(t, n) {\n      int x, y;\n      cin >> x >> y;\n      dice d;\n      cin >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n      string rot;\n      cin >> rot;\n      map<pair<int, int>, int> dp;\n\n      masu s;\n      s.x = x; s.y = y; s.num = d.d;\n      stamps[t].pb(s);\n      dp[make_pair(x, y)] = 0;\n      rep(i, rot.length()) {\n        if (rot[i] == 'L') {\n          x--;\n          d = rotL(d);\n        } else if (rot[i] == 'R') {\n          x++;\n          d = rotR(d);\n        } else if (rot[i] == 'F') {\n          y--;\n          d = rotF(d);\n        } else {\n          y++;\n          d = rotB(d);\n        }\n        s.x = x; s.y = y; s.num = d.d;\n        if (dp.find(make_pair(x, y)) == dp.end()) {\n          stamps[t].pb(s);\n          dp[make_pair(x, y)] = i + 1;\n        } else {\n          stamps[t][dp[make_pair(x, y)]] = s;\n        }\n      }\n    }\n\n    vec<map<pair<int, int>, int> > dp(1 << n);\n    rep(i, (1 << n)) {\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        dp[i + (1 << j)] = Max(dp[i + (1 << j)], stamp(dp[i], stamps[j]));\n      }\n    }\n    int sum = 0;\n    for (auto it = dp[(1 << n) - 1].begin(); it != dp[(1 << n) - 1].end(); it++) sum += it->second;\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\ntypedef pair<int,int> P;\nset<P> used;\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    map<P,int> v;\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v.count(P(d.y,d.x))||!used.count(P(d.y,d.x))){\n\t//cout<<tmp<<\" \"<<d.bottom()<<endl;\n\ttmp+=d.bottom();\n\tif(v.count(P(d.y,d.x))) tmp-=v[P(d.y,d.x)];\n\tv[P(d.y,d.x)]=d.bottom();\n\tused.insert(P(d.y,d.x));\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(auto j:v) used.erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    used.clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = int;\nusing MAP_t = map<PR, int>;\n\nint encode(int x, int y) { return 3000 * x + y; }\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\nint merge(int idx1, int idx2, MAP_t& dest) {\n    dest = boards[idx1];\n    int res_v = scores[idx1];\n\n    for (const pair<PR, int>& itr : boards[idx2]) {\n        if (dest[itr.first] == 0) {\n            res_v += itr.second;\n            dest[itr.first] = itr.second;\n        }\n    }\n\n    return res_v;\n}\n\nint solve() {\n    MAP_t trg;\n\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            int sc = merge(m, (1 << i), trg);\n            if (sc > scores[n]) {\n                boards[n] = trg;\n                scores[n] = sc;\n            }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores + (1 << N), 0);\n        for (int i = 0; i < N; ++i) boards[1 << i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            x += 1000; y += 1000;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][encode(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                PR key = encode(x, y);\n                sc += d.d - boards[idx][key];\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nint table[4000][4000];\nint tb[4000][4000];\nint rots(int n){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\tfill( tb[0], tb[0]+4000*4000, 0 );\n\ttb[pos.X][pos.Y] = dc.point();\n\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[pos.X][pos.Y] = dc.point();\n\t\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\t}\n\t// merge\n\tint sum = 0;\n\tdc = dice_org[n];\n\tpos = dice_pos[n];\n\tif( table[pos.X][pos.Y] == 0 ){\n\t\ttable[pos.X][pos.Y] = tb[pos.X][pos.Y];\n\t\tsum += tb[pos.X][pos.Y];\n\t}\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\tif( table[pos.X][pos.Y] == 0 ){\n\t\t\ttable[pos.X][pos.Y] = tb[pos.X][pos.Y];\n\t\t\tsum += tb[pos.X][pos.Y];\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\t\t//rrep(i,N){\n\t\t//\tfill( table[0], table[0]+4000*4000, 0 );\n\t\t//\tcout << \"rots: \" << rots(i) << endl;\n\t\t//}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N) rep(k,N){\n\t\t\tint nx = (1<<k)|i;\n\t\t\tif( nx != i ){\n\t\t\t\tfill( table[0], table[0]+4000*4000, 0 );\n\t\t\t\trep(k,N) if( (1<<k)&i ) rots(k);\n\t\t\t\tdp[nx] = max( dp[nx], dp[i] + rots(k) );\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\ntypedef long long ll;\n#define ARRAY 65536\n#define DBG 0\n#define SHIFT 10000\nusing namespace std;\n\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n};\n\nvector<int> paths[ARRAY];\nll cells[ARRAY];\n\nint main(void){\n  int n;\n  while(cin >> n){\n    rep(i,ARRAY){paths[i].clear();cells[i]=0;}\n    int x, y, v;\n    int ans = 0;\n\n    string r;\n    Dice dice;\n    vector<Stump> s[32];\n\n\n    rep(i,n){\n      cin >> x >> y;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      x+=1050;\n      y+=1050;\n      s[i].push_back(Stump(x, y, dice[5]));\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        s[i].push_back(Stump(x, y, dice[5]));\n      }\n      map<int, int> used;\n      for(int k = s[i].size()-1; k >= 0 ; --k){\n        if(used[s[i][k].x*SHIFT+s[i][k].y] != 0){\n          s[i][k].value = 0;\n        }\n        used[s[i][k].x*SHIFT+s[i][k].y] = 1;\n      }\n      used.clear();\n    }\n\n    rep(i, 1<<n){\n      int state = i;\n      //int mpl[3000][3000] ={0};\n      map<int,int> mpl;\n      ll baselp = 0;\n      rep(l, paths[state].size()){\n        for(int l = paths[state].size()-1; l >= 0; --l){\n          if(DBG)cout << \", \" << paths[state][l];\n          rep(m, s[paths[state][l]].size()){\n            if(DBG)cout << \"(\" << s[paths[state][l]][m].x << \",\" << s[paths[state][l]][m].y << \")\";\n            // if(mpl[s[paths[state][l]][m].x][s[paths[state][l]][m].y] == 0){\n            //   mpl[s[paths[state][l]][m].x][s[paths[state][l]][m].y] = s[paths[state][l]][m].value;\n            //   baselp += s[paths[state][l]][m].value;\n            // }\n            if(mpl[s[paths[state][l]][m].x*SHIFT+s[paths[state][l]][m].y] == 0){\n              mpl[s[paths[state][l]][m].x*SHIFT+s[paths[state][l]][m].y] = s[paths[state][l]][m].value;\n              baselp += s[paths[state][l]][m].value;\n            }\n          }\n        }\n      }\n      if(DBG) cout << \"baselp \" << baselp << endl;\n\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          ll lp = 0;\n          //map<int, int> mpl;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          for(int l = s[k].size()-1; l >= 0; --l){\n            if(DBG)cout << \"(\" << s[k][l].x << \",\" << s[k][l].y << \")\";\n            // if( mpl[s[k][l].x][ s[k][l].y] > 0){\n            //   mpl[s[k][l].x][s[k][l].y] = s[k][l].value;\n            //   mpl[s[k][l].x][ s[k][l].y] = -mpl[s[k][l].x][ s[k][l].y];\n            //   lp += mpl[s[k][l].x][ s[k][l].y];\n            //   lp += s[k][l].value;\n            //   //s[k][l].value;\n            // }\n            if( mpl[s[k][l].x*SHIFT+s[k][l].y] > 0){\n              //mpl[s[k][l].x*SHIFT+s[k][l].y] = s[k][l].value;\n              mpl[s[k][l].x*SHIFT+s[k][l].y] = -mpl[s[k][l].x*SHIFT+ s[k][l].y];\n              lp += mpl[s[k][l].x*SHIFT+ s[k][l].y];\n              lp += s[k][l].value;\n              if(DBG) cout << lp << endl;\n              //s[k][l].value;\n            }else if( mpl[s[k][l].x*SHIFT+s[k][l].y] == 0){\n              lp += s[k][l].value;\n              if(DBG) cout << lp << endl;\n            }\n          }\n          if(DBG)cout << \" res = \" << lp+baselp << endl;\n          if(cells[state|mask] < lp+baselp){\n            cells[state|mask] = lp+baselp;\n            paths[state|mask] = paths[state];\n            paths[state|mask].push_back(k);\n          }\n          rep(l, s[k].size()){\n            if(DBG)cout << \"(\" << s[k][l].x << \",\" << s[k][l].y << \")\";\n            for(int l = s[k].size()-1; l >= 0; --l){\n              // if( mpl[s[k][l].x][ s[k][l].y] > 0){\n              //   mpl[s[k][l].x][ s[k][l].y] = -mpl[s[k][l].x][ s[k][l].y];\n              // }\n              if( mpl[s[k][l].x*SHIFT+ s[k][l].y] > 0){\n                mpl[s[k][l].x*SHIFT+s[k][l].y] = -mpl[s[k][l].x*SHIFT+s[k][l].y];\n              }\n            }\n          }\n        }\n      }\n    }\n    if(DBG)cout <<\"case ans---\" <<endl;\n    cout << cells[(1<<n)-1] << endl;\n    if(DBG)cout <<\"case end---\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct dice{\n  int a[6];\n};\nvoid rot(int &a,int &b,int &c,int &d){\n  int tmp=a; a=b; b=c; c=d; d=tmp;\n}\nvoid roll_f(dice &d){\n  rot(d.a[0],d.a[3],d.a[2],d.a[1]);\n}\nvoid roll_b(dice &d){\n  rot(d.a[0],d.a[1],d.a[2],d.a[3]);\n}\nvoid roll_l(dice &d){\n  rot(d.a[3],d.a[5],d.a[1],d.a[4]);\n}\nvoid roll_r(dice &d){\n  rot(d.a[3],d.a[4],d.a[1],d.a[5]);\n}\n\ntypedef pair<P,int> pi;\n\nint n;\nmap<P,int> nd[20];\nll dp[1<<15];\n\nint main(int argc, char const *argv[]){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,20)nd[i].clear();\n    rep(i,1<<15){\n      dp[i]=0;\n    }\n    rep(i,n){\n      dice d;\n      int sx,sy;\n      string s;\n      cin>>sx>>sy;\n      cin>>d.a[4]>>d.a[5]>>d.a[0]>>d.a[2]>>d.a[1]>>d.a[3];\n      cin>>s;\n      nd[i][P(sx,sy)]=d.a[1];\n      rep(j,s.length()){\n        if(s[j]=='F'){\n          roll_f(d);\n          sy--;\n        }\n        if(s[j]=='B'){\n          roll_b(d);\n          sy++;\n        }\n        if(s[j]=='R'){\n          roll_r(d);\n          sx++;\n        }\n        if(s[j]=='L'){\n          roll_l(d);\n          sx--;\n        }\n        nd[i][P(sx,sy)]=d.a[1];\n      }\n    }\n    rep(S,(1<<n)){\n      map<P,bool> used;\n      rep(i,n){\n        if((S&(1<<i))==0)continue;\n        for(auto it: nd[i]){\n          used[it.fi]=true;\n        }\n      }\n      rep(i,n){\n        if((S&(1<<i))!=0)continue;\n        ll add=0;\n        for(auto it: nd[i]){\n          if(used[it.fi])continue;\n          add+=it.se;\n        }\n        int T=S|(1<<i);\n        dp[T]=max(dp[T],dp[S]+add);\n      }\n    }\n    cout<<dp[(1<<n)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\n\n\nstruct Dice\n{\n\tint top, bottom, right, left, front, back;\n\tint x, y;\n\tstring s;\n\tDice(int t, int bt, int r, int l, int f, int bk, int x, int y, string s) : top(t), bottom(bt), right(r), left(l), front(f), back(bk), x(x), y(y), s(s) { ; };\n\tvoid to_front() \n\t{\n\t\tint t = front;\n\t\tfront = bottom;\n\t\tbottom = back;\n\t\tback = top;\n\t\ttop = t;\n\t}\n\tvoid to_back() { REP(i, 3) to_front(); }\n\tvoid to_right() \n\t{\n\t\tint t = right;\n\t\tright = top;\n\t\ttop = left;\n\t\tleft = bottom;\n\t\tbottom = t;\n\t}\n\tvoid to_left() { REP(i, 3) to_right(); }\n};\n\nint n;\nvector<Dice> v;\nint vis[5000][5000];\nint dp[1 << 16];\n\nint solve(int bit)\n{\n\tif (bit == (1 << n) - 1) return 0;\n\tif (dp[bit] >= 0) return dp[bit];\n\tint res = 0;\n\tREP(i, n)\n\t{\n\t\tif ((bit >> i) & 1) continue;\n\t\tint nbit = bit | (1 << i);\n\t\tint sum = 0;\n\t\tint x = v[i].x, y = v[i].y;\n\t\tstring s = v[i].s;\n\t\tif ((nbit | vis[x][y]) == nbit) sum += v[i].bottom;\n\t\tfor (auto j : s)\n\t\t{\n\t\t\tif (j == 'L')\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tv[i].to_left();\n\t\t\t}\n\t\t\tif (j == 'R')\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tv[i].to_right();\n\t\t\t}\n\t\t\tif (j == 'F')\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tv[i].to_front();\n\t\t\t}\n\t\t\tif (j == 'B')\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tv[i].to_back();\n\t\t\t}\n\t\t\tif ((nbit | vis[x][y]) == nbit) sum += v[i].bottom;\n\t\t}\n\t\tchmax(res, solve(nbit) + sum);\n\t}\n\treturn dp[bit] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n, n)\n\t{\n\t\tMS(vis, 0);\n\t\tMS(dp, -1);\n\t\tv.clear(); v.resize(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y, l, r, f, b, d, u;\n\t\t\tcin >> x >> y >> l >> r >> f >> b >> d >> u;\n\t\t\tx += 2000, y += 2000;\n\t\t\tstring s; cin >> s;\n\t\t\tv.emplace_back(u, d, r, l, f, b, x, y, s);\n\t\t}\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x = v[i].x, y = v[i].y;\n\t\t\tstring s = v[i].s;\n\t\t\tvis[x][y] |= 1 << i;\n\t\t\tfor(auto j : s)\n\t\t\t{\n\t\t\t\tif (j == 'L') x--;\n\t\t\t\tif (j == 'R') x++;\n\t\t\t\tif (j == 'F') y++;\n\t\t\t\tif (j == 'B') y--;\n\t\t\t\tvis[x][y] |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\ntypedef pair<int,int> P;\nset<P> used;\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    map<P,int> v;\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v.count(P(d.y,d.x))||!used.count(P(d.y,d.x))){\n    //cout<<tmp<<\" \"<<d.bottom()<<endl;\n    tmp+=d.bottom();\n    if(v.count(P(d.y,d.x))) tmp-=v[P(d.y,d.x)];\n    v[P(d.y,d.x)]=d.bottom();\n    used.insert(P(d.y,d.x));\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(auto j:v) used.erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    used.clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<functional>\n#include<string>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define REC(ret,...) std::function<ret (__VA_ARGS__)>\ntemplate<typename T>\nbool chmin(T& l, T r) {\n\tbool res = l > r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nbool chmax(T& l, T r) {\n\tbool res = l < r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T> &v) {\n\tfor (auto &it : v)is >> it;\n\treturn is;\n}\ntypedef vector<int> V;\nint f(int x, int y, int z) {\n\treturn x + y + z;\n}\nconst int dx[4] = { 0,0,-1,1 };\nconst int dy[4] = { 1,-1,0,0 };\n#define BBB 0\n#define FFF 1\n#define LLL 2\n#define RRR 3\nconst int hiro[4][6] = {\n\t{0,1,5,4,2,3},\n\t{0,1,4,5,3,2},\n\t{4,5,2,3,1,0},\n\t{5,4,2,3,0,1}\n};\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef pair<int, int> P;\nvoid rot_move(vector<int>& state, int r, int&x, int &y) {\n\tx += dx[r];\n\ty += dy[r];\n\tvector<int> nxt(6);\n\tREP(i, 6)nxt[hiro[r][i]] = state[i];\n\tREP(i, 6)state[i] = nxt[i];\n}\t\t\t\t\nmap<int, int> memo;\ninline int ch(int x, int y) {\n\tx += 1000;\n\ty += 1000;\n\treturn x * 2123 + y;\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tV x(N), y(N);\n\t\tVV dice(N, V(6));\n\t\tvector<string> rot(N);\n\t\tREP(i, N) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tcin >> dice[i];\n\t\t\tcin >> rot[i];\n\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\tif (it == 'B')it = BBB;\n\t\t\t\tif (it == 'F')it = FFF;\n\t\t\t\tif (it == 'L')it = LLL;\n\t\t\t\tif (it == 'R')it = RRR;\n\t\t\t}\n\t\t}\n\t\tvector<set<int>> fut(1<<N);\n\t\tREP(bit, 1 << N) {\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tfut[bit].insert(ch(xx, yy));\n\t\t\t\tauto v = dice[i];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tfut[bit].insert(ch(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV dp(1 << N, -1);\t\n\t\tdp[0] = 0;\n\t\tREC(int, int) dfs = [&](int bit) {\n\t\t\tif (dp[bit] >= 0)return dp[bit];\n\t\t\tdp[bit] = 0;\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tauto v = dice[i];\n\t\t\t\tint nxtbit = bit - (1 << i);\n\t\t\t\tint cost = dfs(nxtbit);\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tmemo.clear();\n\t\t\t\tif (!fut[nxtbit].count(ch(xx, yy)))memo[ch(xx, yy)] = v[4];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tif (!fut[nxtbit].count(ch(xx, yy))) {\n\t\t\t\t\t\tmemo[ch(xx, yy)] = v[4];\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto &it : memo) {\n\t\t\t\t\tcost += it.second;\n\t\t\t\t} \n\t\t\t\tchmax(dp[bit], cost);\n\t\t\t}\n\t\t\treturn dp[bit];\n\t\t};\n\t\tcout << dfs((1 << N) - 1) << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<short, short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<map<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<unsigned short, map<pii, char>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N;\n\nvector<int> t[15];\nstring u[15];\nint sx[15],sy[15];\nint dp[ (1<<15) ];\n\nvoid ry(vector<int> &v){\n  int tmp=v[2];\n  v[2]=v[4];\n  v[4]=v[3];\n  v[3]=v[5];\n  v[5]=tmp;\n}\n\nvoid rx(vector<int> &v){\n  int tmp=v[0];\n  v[0]=v[4];\n  v[4]=v[1];\n  v[1]=v[5];\n  v[5]=tmp;\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      t[i].clear();\n      t[i].resize(6);\n      cin>>sx[i]>>sy[i];\n      for(int j=0;j<6;j++)cin>>t[i][j];\n      cin>>u[i];\n    }\n    memset(dp,0,sizeof(dp));\n    map< P , int > w,mp;\n    for(int S=0;S<(1<<N);S++){\n      mp.clear();\n      \n      for(int i=0;i<N;i++){\n        if((S>>i&1)==0)continue;\n        P p=P(sx[i],sy[i]);\n        mp[p]=1;\n        for(int j=0;j<(int)u[i].size();j++){\n          if(u[i][j]=='L')p.first--;\n          if(u[i][j]=='R')p.first++;\n          if(u[i][j]=='F')p.second--;\n          if(u[i][j]=='B')p.second++;\n          mp[p]=1;\n        }\n      }\n      \n      for(int i=0;i<N;i++){\n        if(S>>i&1)continue;\n        vector<int> v=t[i];\n        P p=P(sx[i],sy[i]);\n        int cost=0;\n        w.clear();\n        if(!mp[p]){\n          cost-=w[p];\n          w[p]=v[4];\n          cost+=v[4];\n        }\n        \n        for(int j=0;j<(int)u[i].size();j++){\n          if(u[i][j]=='L'){\n            p.first--;\n            rx(v);rx(v);rx(v);\n          }\n          if(u[i][j]=='R'){\n            p.first++;\n            rx(v);\n          }\n          if(u[i][j]=='F'){\n            p.second--;\n            ry(v);ry(v);ry(v);\n          }\n          if(u[i][j]=='B'){\n            p.second++;\n            ry(v);\n          }\n\n          if(!mp[p]){\n            cost-=w[p];\n            w[p]=v[4];\n            cost+=v[4];\n          }\n        }\n        dp[S+(1<<i)]=max(dp[S+(1<<i)],dp[S]+cost);\n      }\n    }\n    cout<<dp[(1<<N)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n\n\n\nvector<tuple<ll,ll,ll>> table[20];\n//get<0> := x\n//get<1> := y\n//get<2> := value\n\nll tmp;\n\nll i,j;\nll n,m;\nll l,r,f,b,d,u;\n\nvoid rotate_l(){\n\ttmp = u;\n\tu = r;\n\tr = d;\n\td = l;\n\tl = tmp;\n\treturn;\n}\n\nvoid rotate_r(){\n\ttmp = u;\n\tu = l;\n\tl = d;\n\td = r;\n\tr = tmp;\n\treturn;\n}\n\nvoid rotate_b(){\n\ttmp = u;\n\tu = f;\n\tf = d;\n\td = b;\n\tb = tmp;\n\treturn;\n}\n\nvoid rotate_f(){\n\ttmp = u;\n\tu = b;\n\tb = d;\n\td = f;\n\tf = tmp;\n\treturn;\n}\n\nbool solve(){\n\tcin >> n;\n\tif(n == 0)return false;\n\n\tll x,y;\n\tstring s;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x >> y;\n\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\tcin >> s;\n\t\tm = s.size();\n\t\ttable[i].clear();\n\t\ttable[i].emplace_back(x,y,d);\n\t\t// cout << x << \" \" << y << \" \" << d << endl;\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(s[j] == 'L'){\n\t\t\t\trotate_l();\n\t\t\t\tx--;\n\t\t\t}else if(s[j] == 'R'){\n\t\t\t\trotate_r();\n\t\t\t\tx++;\n\t\t\t}else if(s[j] == 'B'){\n\t\t\t\trotate_b();\n\t\t\t\ty++;\n\t\t\t}else{\n\t\t\t\trotate_f();\n\t\t\t\ty--;\n\t\t\t}\n\n\t\t\tbool visited = false;\n\t\t\tauto itr = table[i].begin();\n\t\t\tfor(itr = table[i].begin(); itr != table[i].end(); ++itr) {\n\t\t\t\tint sx, sy, sd;\n\t\t\t\ttie(sx, sy, sd) = *itr;\n\t\t\t\tif (sx == x && sy == y) {\n\t\t\t\t\tvisited = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (visited) table[i].erase(itr);\n\t\t\ttable[i].emplace_back(x,y,d);\n\t\t\t// cout << x << \" \" << y << \" \" << d << endl;\n\t\t}\n\t}\n\n\tint N = n;\n\tvector<int> dp(1 << N, 0);\n\tfor(int b = 0; b < (1 << N); ++b) {\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tif ((b >> i) & 1) continue;\n\n\t\t\tint score = dp[b];\n\t\t\tfor(auto t : table[i]) {\n\t\t\t\tint x, y, d;\n\t\t\t\ttie(x, y, d) = t;\n\n\t\t\t\tbool filled = false;\n\t\t\t\tfor(int j = 0; j < N; ++j) {\n\t\t\t\t\tif(!((b >> j) & 1)) continue;\n\t\t\t\t\tfor(auto s : table[j]) {\n\t\t\t\t\t\tint sx, sy, sd;\n\t\t\t\t\t\ttie(sx, sy, sd) = s;\n\t\t\t\t\t\tif (sx == x && sy == y) {\n\t\t\t\t\t\t\tfilled = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!filled) score += d;\n\t\t\t}\n\n\t\t\tdp[b | (1 << i)] = max(dp[b | (1 << i)], score);\n\t\t}\n\t}\n\n\tcout << dp.back() << endl;\n\treturn true;\n}\n\n\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nmap<pii,int> tb[20];\nvoid rots(int n){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\ttb[n][pii(pos.X, pos.Y)] = dc.point();\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[n][pii(pos.X,pos.Y)] = dc.point();\n\t}\n}\n\nint solve(map<pii,int> &table, int n){\n\t// merge\n\tint sum = 0;\n\tfor(auto p: tb[n]) if( table.count(p.X) == 0 ){\n\t\ttable[p.X] = p.Y;\n\t\tsum += p.Y;\n\t}\n\treturn sum;\n}\n\nmap<pii, int> tables[1<<20];\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\n\t\trep(i,N){\n\t\t\ttb[i].clear();\n\t\t\trots(i);\n\t\t}\n\t\trep(i,1<<20) tables[i].clear();\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tauto table = tables[i];\n\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + solve(table, k) );\n\t\t\t\t\tif( tables[nx].empty() ){\n\t\t\t\t\t\ttables[nx] = table;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttables[i].clear();\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<umap<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<int, umap<pii, int>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 15\n\nclass Dice {\n  private:\n    void roll(int a, int b, int c, int d)\n    {\n        swap(v[a], v[b]);\n        swap(v[b], v[d]);\n        swap(v[c], v[d]);\n    }\n    \n  public:\n    int v[6], x, y;\n    string order;\n    void roll_B() { roll(0, 1, 4, 5); }\n    void roll_R() { roll(0, 3, 2, 5); }\n    void roll_F() { roll(0, 4, 1, 5); }\n    void roll_L() { roll(0, 2, 3, 5); }\n};\n\nint change(int y, int x)\n{\n    return (y << 25) + (x << 12);\n}\n\nvoid rot(set<int> &a, Dice &d)\n{\n    a.insert(change(d.y, d.x));\n    for (auto &c: d.order) {\n        if (c == 'L') {\n            c = 'R';\n            d.roll_L();\n            d.x--;\n        } else if (c == 'F') {\n            c = 'B';\n            d.roll_F();\n            d.y--;\n        } else if (c == 'R') {\n            c = 'L';\n            d.roll_R();\n            d.x++;\n        } else {\n            c = 'F';\n            d.roll_B();\n            d.y++;\n        }\n        a.insert(change(d.y, d.x));\n    }\n    reverse(d.order.begin(), d.order.end());\n}\n\nvoid merge(set<int> &a, set<int> &b)\n{\n    for (auto p: b) {\n        a.insert(p);\n    }\n}\n\nint get_cost(set<int> decided, Dice d)\n{\n    int res = 0;\n    if (decided.count(change(d.y, d.x)) == 0) {\n        decided.insert(change(d.y, d.x));\n        res += d.v[5];\n    }\n        \n    for (auto c: d.order) {\n        if (c == 'L') {\n            d.x--;\n            d.roll_L();\n        } else if (c == 'F') {\n            d.y--;\n            d.roll_F();\n        } else if (c == 'R') {\n            d.x++;\n            d.roll_R();\n        } else {\n            d.y++;\n            d.roll_B();\n        }\n        if (decided.count(change(d.y, d.x)) == 0) {\n            decided.insert(change(d.y, d.x));\n            res += d.v[5];\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Dice> d(N);\n        for (int i = 0; i < N; i++) {\n            cin >> d[i].x >> d[i].y;\n            cin >> d[i].v[3] >> d[i].v[2] >> d[i].v[1];\n            cin >> d[i].v[4] >> d[i].v[5] >> d[i].v[0];\n            cin >> d[i].order;\n        }\n\n        set<int> a[MAX_N];\n        for (int i = 0; i < N; i++) {\n            rot(a[i], d[i]);\n        }        \n        \n        int dp[1<<MAX_N];\n        memset(dp, -1, sizeof(dp));\n\n        dp[0] = 0;\n        for (int i = 0; i < (1<<N); i++) {\n            if (dp[i] == -1) continue;            \n            set<int> decided;\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) {\n                    merge(decided, a[j]);\n                }\n            }\n\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) continue;\n                int ni = i | (1<<j);                \n                dp[ni] = max(dp[ni], dp[i] + get_cost(decided, d[j]));\n            }\n        }\n        cout << dp[(1<<N)-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nclass Dice{\npublic:\n\n\tvoid roll(char dst){\n\t\tfor(int i = 0; i < 6; i++) work[i] = number[i];\n\t\tswitch(dst){\n\t\tcase 'R':\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tchar getTop(){\n\t\treturn number[0];\n\t}\n\n\tchar getEast(){\n\t\treturn number[2];\n\t}\n\n\tchar getNorth(){\n\t\treturn number[1];\n\t}\n\n\tchar getWest(){\n\t\treturn number[3];\n\t}\n\n\tchar getBottom(){\n\t\treturn number[5];\n\t}\n\n\tchar getSouth(){\n\t\treturn number[4];\n\t}\n\n\tvoid setNumber(int w0,int w1,int w2,int w3,int w4,int w5){\n\t\tnumber[0] = w0;\n\t\tnumber[1] = w1;\n\t\tnumber[2] = w2;\n\t\tnumber[3] = w3;\n\t\tnumber[4] = w4;\n\t\tnumber[5] = w5;\n\t}\n\n\tvoid setFirst(int left,int right,int front,int back,int down,int up){\n\t\tnumber[0] = up;\n\t\tnumber[1] = back;\n\t\tnumber[2] = right;\n\t\tnumber[3] = left;\n\t\tnumber[4] = front;\n\t\tnumber[5] = down;\n\t}\n\n\tint number[6];\n\tint work[6];\n};\n\nstruct Info{\n\tint x,y,value,all_index;\n};\n\nstruct Data{\n\tInfo loc;\n\tint state;\n};\n\nint N;\nint POW[17];\nint index[15]; //サイコロが転がるマスの数\nint table_index;\nint dp[32768];\nInfo info[15][32];\nchar buf[31];\nData table[500]; //サイコロが転がり得るマスの集計表\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++)index[i] = 0;\n\n\tint current_x,current_y;\n\tint left,right,front,back,down,up;\n\n\tDice dice;\n\tbool FLG;\n\n\t//サイコロの情報を取得\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&current_x,&current_y);\n\n\t\tscanf(\"%d %d %d %d %d %d\",&left,&right,&front,&back,&down,&up);\n\t\tdice.setFirst(left,right,front,back,down,up);\n\n\t\tinfo[i][index[i]].x = current_x;\n\t\tinfo[i][index[i]].y = current_y;\n\t\tinfo[i][index[i]].value = dice.getBottom();\n\n\t\tindex[i]++;\n\n\t\tscanf(\"%s\",buf);\n\n\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\n\t\t\tdice.roll(buf[k]); //ダイスを転がす\n\n\t\t\tswitch(buf[k]){\n\t\t\tcase 'L':\n\t\t\t\tcurrent_x--;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcurrent_x++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcurrent_y--;\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tcurrent_y++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\t//既に訪れたことのあるマスか調べる\n\t\t\tFLG = false;\n\n\t\t\tfor(int a = 0; a < index[i]; a++){\n\t\t\t\tif(info[i][a].x == current_x && info[i][a].y == current_y){\n\t\t\t\t\t\tinfo[i][a].value = dice.getBottom(); //新しい値で上書き\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!FLG){\n\t\t\t\tinfo[i][index[i]].x = current_x;\n\t\t\t\tinfo[i][index[i]].y = current_y;\n\t\t\t\tinfo[i][index[i]].value = dice.getBottom();\n\n\t\t\t\tindex[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//N個のサイコロ情報を統合する\n\ttable_index = 0;\n\tfor(int i = 0; i < 500; i++)table[i].state = 0;\n\n\tfor(int i = 0; i < N; i++){ //15\n\t\tfor(int k = 0; k < index[i]; k++){ //31\n\n\t\t\tFLG = false;\n\t\t\tfor(int a = 0; a < table_index; a++){\n\t\t\t\tif(table[a].loc.x == info[i][k].x && table[a].loc.y == info[i][k].y){ //テーブルに場所が登録済の場合\n\t\t\t\t\ttable[a].state += POW[i]; //マス毎に、サイコロの集合を持つ\n\t\t\t\t\tinfo[i][k].all_index = a; //逆引きインデックス\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!FLG){\n\t\t\t\ttable[table_index].loc.x = info[i][k].x;\n\t\t\t\ttable[table_index].loc.y = info[i][k].y;\n\t\t\t\ttable[table_index].state += POW[i];\n\t\t\t\tinfo[i][k].all_index = table_index;\n\t\t\t\ttable_index++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int state = 0; state < POW[N]; state++)dp[state] = 0;\n\n\tint sum,tmp_index,all_state;\n\tint next_state,next_value;\n\n\t //★★操作を逆順にして考える★★\n\tfor(int state = 0; state < POW[N]; state++){ //既に転がったサイコロの集合\n\t\tfor(int dice = 0; dice < N; dice++){\n\t\t\tif(state & (1 << dice))continue;\t//転がし済ならSKIP\n\t\t\tsum = 0;\n\t\t\t//あるサイコロについて、既に転がったサイコロとは重ならないマスの値の総和を求める\n\t\t\tfor(int i = 0; i < index[dice]; i++){\n\t\t\t\ttmp_index = info[dice][i].all_index;\n\t\t\t\tall_state = table[tmp_index].state;\n\n\t\t\t\tif(!(all_state & state)){ //そのマスを転がる自分を含めた集合と、既に転がったサイコロの集合との論理積が0の場合:自分がそのマスを初カバー\n\t\t\t\t\tsum += info[dice][i].value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext_state = state+POW[dice];\n\t\t\tnext_value = dp[state]+sum;\n\t\t\tdp[next_state] = max(dp[next_state],next_value);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[POW[N]-1]);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 17; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nenum { U, B, L, F, R, D };\nstruct Dice {\n\tint face[6];\n\n\tDice() {\n\t\tface[F] = 1;\n\t\tface[R] = 2;\n\t\tface[U] = 3;\n\t\tface[B] = 6;\n\t\tface[L] = 5;\n\t\tface[D] = 4;\n\t}\n\n\tint find_face(int f) {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(face[i] == f) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R:\n\t\t\trotate(U, R, D, L);\n\t\t\tbreak;\n\t\tcase B:\n\t\t\trotate(U, B, D, F);\n\t\t\tbreak;\n\t\tcase L:\n\t\t\trotate(U, L, D, R);\n\t\t\tbreak;\n\t\tcase F:\n\t\t\trotate(U, F, D, B);\n\t\t\tbreak;\n\t\tcase U:\n\t\t\trotate(F, R, B, L);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tcase D:\n\t\t\trotate(F, L, B, R);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\tint& operator[](int n) { return face[n]; }\n\n\tconst int& operator[](int n) const { return face[n]; }\n\n\tstd::vector<Dice> all_rolls() {\n\t\tstd::vector<Dice> res;\n\t\tfor(int k = 0; k < 6; k++) {\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tres.push_back(*this);\n\t\t\t\tturn(R);\n\t\t\t}\n\t\t\tturn(k % 2 == 1 ? U : F);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c];\n\t\tface[c] = face[b];\n\t\tface[b] = face[a];\n\t\tface[a] = t;\n\t}\n};\n\ntypedef pair<int, int> P;\n\nDice dice[15];\nint X[15], Y[15];\nstring rot[15];\nmap<P, int> pos[15];\nint dp[1 << 15];\nset<P> used[1 << 15];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint l, r, f, b, d, u;\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\t\tcin >> rot[i];\n\t\t\tdice[i][L] = l;\n\t\t\tdice[i][R] = r;\n\t\t\tdice[i][F] = f;\n\t\t\tdice[i][B] = b;\n\t\t\tdice[i][D] = d;\n\t\t\tdice[i][U] = u;\n\n\t\t\tDice t = dice[i];\n\t\t\tint x = X[i], y = Y[i];\n\t\t\tpos[i].clear();\n\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\tfor(auto c : rot[i]) {\n\t\t\t\tif(c == 'L') t.turn(L), x--;\n\t\t\t\tif(c == 'R') t.turn(R), x++;\n\t\t\t\tif(c == 'F') t.turn(F), y--;\n\t\t\t\tif(c == 'B') t.turn(B), y++;\n\t\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 1 << N; i++) {\n\t\t\tused[i].clear();\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(i >> j & 1) {\n\t\t\t\t\tfor(auto p : pos[j]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tused[i].insert({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tdp[0] = 0;\n\t\tfor(int i = 0; i < 1 << N; i++) {\n\t\t\tif(dp[i] == -1) continue;\n\t\t\tint s = dp[i];\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(i >> j & 1) continue;\n\t\t\t\tint ns = s;\n\t\t\t\tfor(auto p : pos[j]) {\n\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\tint point = p.second;\n\t\t\t\t\tif(used[i].count({ x, y })) continue;\n\t\t\t\t\tns += point;\n\t\t\t\t}\n\t\t\t\tdp[i | (1 << j)] = max(dp[i | (1 << j)], ns);\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[(1 << N) - 1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \nvector<map<P,int>> m;\nint c[4][6]={\n    {3,0,1,2,4,5},\n    {1,2,3,0,4,5},\n    {4,1,5,3,2,0},\n    {5,1,4,3,0,2}\n};\n\nstring s;\n\nvoid rec(int k,int i,int y,int x,vector<int> v){\n    m[i][{y,x}]=v[0];\n    if(s.length()==k) return;\n    vector<int> t(6);\n    if(s[k]=='L'){\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[0][j]];\n        }\n        rec(k+1,i,y,x-1,t);\n    }\n    else if(s[k]=='R'){\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[1][j]];\n        }\n        rec(k+1,i,y,x+1,t);\n    }\n    else if(s[k]=='F'){\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[2][j]];\n        }\n        rec(k+1,i,y-1,x,t);\n    }\n    else{\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[3][j]];\n        }\n        rec(k+1,i,y+1,x,t);\n    }\n}\n\n\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        m.clear();\n        m.resize(n);\n        for (int i = 0; i < n; i++) {\n            int x,y;cin >> x >> y;\n            vector<int> u(6);\n            cin >> u[3] >> u[1] >> u[4] >> u[5] >> u[0] >> u[2];\n            cin >> s;\n            rec(0,i,y,x,u);\n        }\n        vector<int> dp(1<<n,-INF);\n        dp[0]=0;\n        int ans=-INF;\n        for (int bit = 0; bit < 1<<n; bit++) {\n            ans=max(ans,dp[bit]);\n            for (int i = 0; i < n; i++) {\n                if(bit&(1<<i)) continue;\n                int sum = 0;\n                for (auto p:m[i]) {\n                    P t=p.first;\n                    bool f=true;\n                    for (int j = 0; j < n; j++) {\n                        if(bit&(1<<j)){\n                            if(m[j].find(t)!=m[j].end()){\n                                f=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(f) sum+= p.second;\n                }\n                int nx = bit|(1<<i);\n                dp[nx]=max(dp[nx],dp[bit]+sum);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nint n, C[15][6], cx[15], cy[15]; string px[15];\nmap<pair<int, int>, int>D[15], E[1 << 15];\nvector<tuple<int, int, int>>_D[15];\nvector<pair<int, int>>_E[1 << 15];\nint dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 15];\nvoid Init1(int I) {\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\tif (D[I][make_pair(cx[I], cy[I])] == 0)_D[I].push_back(make_tuple(cx[I], cy[I], C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(_D[I].begin(), _D[I].end());\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < D[j].size(); k++) {\n\t\t\tpair<int, int>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0)_E[p].push_back(pa); E[p][pa] = 1;\n\t\t}\n\t}\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\t_D[i].push_back(make_tuple(cx[i], cy[i], C[i][4]));\n\t\t\tD[i][make_pair(cx[i], cy[i])] = C[i][4]; Init1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<int, int>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], dp[i] + cnt);\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n b\nlurd\n f\n*/\nstruct Dice {\n  long long l, r, f, b, d, u, x, y;\n  Dice(long long _l = 4, long long _r = 3, long long _f = 2, long long _b = 5,\n       long long _d = 6, long long _u = 1, long long _x = 0, long long _y = 0)\n      : l(_l), r(_r), f(_f), b(_b), d(_d), u(_u), x(_x), y(_y) {}\n\n  void RollN() {\n    long long buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n    ++y;\n  }\n\n  void RollS() {\n    long long buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n    --y;\n  }\n\n  void RollE() {\n    long long buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n    ++x;\n  }\n\n  void RollW() {\n    long long buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n    --x;\n  }\n\n  void RollL() {\n    long long buff = f;\n    f = l;\n    l = b;\n    b = r;\n    r = buff;\n  }\n\n  void RollR() {\n    long long buff = f;\n    f = r;\n    r = b;\n    b = l;\n    l = buff;\n  }\n\n  vector<Dice> makeDice() {\n    vector<Dice> ret;\n    for (int i = 0; i < 6; i++) {\n      Dice d(*this);\n      if (i == 1) d.RollN();\n      if (i == 2) d.RollS();\n      if (i == 3) d.RollS(), d.RollS();\n      if (i == 4) d.RollE();\n      if (i == 5) d.RollW();\n      for (int j = 0; j < 4; j++) {\n        ret.emplace_back(d);\n        d.RollL();\n      }\n    }\n    return (ret);\n  }\n\n  bool operator==(const Dice &di) const {\n    return l == di.l && r == di.r && f == di.f && b == di.b && d == di.d &&\n           u == di.u;\n  }\n};\n\nconst int ofst = 1200;\nlong long n;\nvector<long long> dp;\nvector<vector<long long>> memo;\nvector<map<pair<int, int>, int>> v;\nlong long solve();\n\nint main() {\n  while (1) {\n    cin >> n;\n    if (n == 0) break;\n    dp.assign(1LL << n, 0);\n    memo.assign(3000, vector<long long>(3000, 0));\n    v.clear();\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n      int x, y, l, r, f, b, d, u;\n      string rot;\n      cin >> x >> y >> l >> r >> f >> b >> d >> u >> rot;\n      Dice di(l, r, f, b, d, u, x, y);\n      int len = rot.size();\n      for (int j = 0; j <= len; ++j) {\n        memo[di.x + ofst][di.y + ofst] |= 1 << i;\n        v[i][make_pair(di.x + ofst, di.y + ofst)] = di.d;\n        if (j == len) break;\n        if (rot[j] == 'R')\n          di.RollE();\n        else if (rot[j] == 'L')\n          di.RollW();\n        else if (rot[j] == 'F')\n          di.RollS();\n        else\n          di.RollN();\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong long solve() {\n  long long res = 0;\n  for (int i = 1; i < (1 << n); ++i)\n    for (int j = 0; j < n; ++j)\n      if (i >> j & 1) {\n        long long sum = dp[i - (1 << j)];\n        for (auto p : v[j]) {\n          int x = p.first.first, y = p.first.second;\n          if ((memo[x][y] & i) == (1 << j)) sum += p.second;\n        }\n        dp[i] = max(dp[i], sum);\n        res = max(res, dp[i]);\n      }\n  return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\n\nset<int> used[3000];\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    set<int> vi;\n    map<int,int> v[3000];\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v[d.y+1500].count(d.x)||!used[d.y+1500].count(d.x)){\n\t//cout<<tmp<<\" \"<<d.bottom()<<endl;\n\ttmp+=d.bottom();\n\tif(v[d.y+1500].count(d.x)) tmp-=v[d.y+1500][d.x];\n\tv[d.y+1500][d.x]=d.bottom();\n\tused[d.y+1500].insert(d.x);\n\tvi.insert(d.y+1500);\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(int k:vi) for(auto j:v[k]) used[k].erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    for(int k=0;k<3000;k++) used[k].clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = int;\nusing MAP_t = map<PR, int>;\n\nint encode(int x, int y) { return 3000 * x + y; }\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\nint merge(int idx1, int idx2, MAP_t& dest) {\n    dest = boards[idx1];\n    int res_v = scores[idx1];\n\n    for (const pair<PR, int>& itr : boards[idx2]) {\n        res_v += itr.second - dest[itr.first];\n        dest[itr.first] = itr.second;\n    }\n\n    return res_v;\n}\n\nint solve() {\n    MAP_t trg;\n\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            int sc = merge(m, (1 << i), trg);\n            if (sc > scores[n]) {\n                boards[n] = trg;\n                scores[n] = sc;\n            }\n\n            // sc = merge((1 << i), m, trg);\n            // if (sc > scores[n]) {\n            //     boards[n] = trg;\n            //     scores[n] = sc;\n            // }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores + (1 << N), 0);\n        for (int i = 0; i < (1 << N); ++i) boards[i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            x += 1000; y += 1000;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][encode(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                PR key = encode(x, y);\n                sc += d.d - (boards[idx].find(key) != end(boards[idx]) ? boards[idx][key] : 0);\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define MP(x,y) make_pair(x,y)\n#define ARRAY 65536\n#define X first\n#define Y second\n#define DBG 0\nusing namespace std;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n      std::fill( (T*)array, (T*)(array+N), val );\n}\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n  void print(){\n    cout << \"(  \" << x<< \" , \" << y<< \" ) \" << value << endl;\n  }\n};\nclass iStump{\n  public:\n  int id, val;\n  iStump(int _id, int _val):id(_id),val(_val){}; \n};\n\n//int mpl[2200][2200] ={0};\n\n// ??§?¨????id 31*15?????§\n//map<pair<int,int>, int> memo;\nint memo[2200][2200];\n\nint main(void){\n  int n;\n  while(cin >> n, n){\n    vector<char> paths[ARRAY]; //[state]?????¨???????????????????????????\n    int dp[ARRAY] = {0}; //[state]?????¨???????????§???\n    int xy[1024][16] = {0}; //[??§?¨?id]???[????????????id] ??? ??????????????????\n    int x, y, v;\n    int ans = 0;\n    int used_xy = 0;\n    Fill(memo, 0);\n\n    string r;\n    vector<Stump> ts[32];\n    vector<iStump> s[32];\n\n    rep(i,n){\n      Dice dice;\n      cin >> x >> y;\n      x+=1050;\n      y+=1050;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      ts[i].push_back(Stump(x, y, dice[5]));\n      if(DBG) ts[i].back().print();\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        ts[i].push_back(Stump(x, y, dice[5]));\n        if(DBG) ts[i].back().print();\n      }\n\n      map<pair<int,int>, int> used;\n      for(int k = ts[i].size()-1; k >= 0 ; --k){\n        pair<int,int> xyz=MP(ts[i][k].x,+ts[i][k].y);\n        if(used[xyz] != 0) ts[i][k].value = 0;\n        if(memo[xyz.X][xyz.Y] == 0){\n          //cout << xyz.X << \" \" << xyz.Y << \" \" << used_xy << endl;\n          memo[xyz.X][xyz.Y] = ++used_xy;\n        }\n        used[xyz] = 1;\n      }\n\n\n      int sum = 0;\n      //cout << i << endl;\n      rep(k,ts[i].size()){\n        if(ts[i][k].value > 0){\n          int cell_id = memo[ts[i][k].x][ts[i][k].y];\n          s[i].push_back( iStump(cell_id, ts[i][k].value));\n          xy[cell_id][i] = ts[i][k].value;\n//           cout << cell_id << \" -> \" << xy[cell_id][i] << endl;\n          sum += xy[cell_id][i];\n        }\n      }\n//      cout << \"sum \" << sum << endl;\n    }\n//     rep(i, used_xy){\n//       rep(j, n){\n//         cout << xy[i][j] << \"\\t\";\n//       }cout << endl;\n//     }\n\n    //DP\n    rep(i, (1<<n)-1){\n      int state = i;\n      if(DBG) cout << \"baselp \" << dp[state] << endl;\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          int lp = 0;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          rep(l, s[k].size()){\n            iStump ss = s[k][l];\n            int current = 0;\n\n            for(int j = paths[state].size()-1; j >= 0; --j){\n              if(xy[ss.id][paths[state][j]] > 0){\n                current = xy[ss.id][paths[state][j]];\n                break;\n              }\n            }\n            lp += ss.val - current;\n          }\n          if(DBG)cout << \" res = \" << lp+dp[state] << endl;\n          if(dp[state|mask] < lp+dp[state]){\n            dp[state|mask] = lp+dp[state];\n            paths[state|mask] = paths[state];\n            paths[state|mask].push_back(k);\n          }\n        }\n      }\n    }\n    if(DBG)cout <<\"case ans---\" <<endl;\n    cout << dp[(1<<n)-1] << endl;\n    if(DBG)cout <<\"case end---\" <<endl;\n//     cout << \"case\" << endl;\n//     rep(i, paths[(1<<n)-1].size()){\n//       cout << paths[(1<<n)-1][i] << endl;\n//     }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\ntypedef long long ll;\n#define ARRAY 65536\n#define DBG 0\n#define SHIFT 10000\nusing namespace std;\n\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n};\n\nvector<int> paths[ARRAY];\nll cells[ARRAY];\n//int mpl[2200][2200] ={0};\n\nint main(void){\n  int n;\n  while(cin >> n){\n    rep(i,ARRAY){paths[i].clear();cells[i]=0;}\n    int x, y, v;\n    int ans = 0;\n\n    string r;\n    Dice dice;\n    vector<Stump> s[32];\n\n\n    rep(i,n){\n      cin >> x >> y;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      x+=1050;\n      y+=1050;\n      s[i].push_back(Stump(x, y, dice[5]));\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        s[i].push_back(Stump(x, y, dice[5]));\n      }\n      map<int, int> used;\n      for(int k = s[i].size()-1; k >= 0 ; --k){\n        if(used[s[i][k].x*SHIFT+s[i][k].y] != 0){\n          s[i][k].value = 0;\n        }\n        used[s[i][k].x*SHIFT+s[i][k].y] = 1;\n      }\n      used.clear();\n    }\n\n    rep(i, 1<<n){\n      int state = i;\n      //int mpl[2200][2200] ={0};\n      int mpl[2200][2200] ={0};\n      //map<int,int> mpl;\n      ll baselp = 0;\n\n      for(int l = paths[state].size()-1; l >= 0; --l){\n        if(DBG)cout << \", \" << paths[state][l];\n        rep(m, s[paths[state][l]].size()){\n          if(DBG)cout << \"(\" << s[paths[state][l]][m].x << \",\" << s[paths[state][l]][m].y << \")\";\n          if(mpl[s[paths[state][l]][m].x][s[paths[state][l]][m].y] == 0){\n            mpl[s[paths[state][l]][m].x][s[paths[state][l]][m].y] = s[paths[state][l]][m].value;\n            baselp += s[paths[state][l]][m].value;\n          }\n          // if(mpl[s[paths[state][l]][m].x*SHIFT+s[paths[state][l]][m].y] == 0){\n          //   mpl[s[paths[state][l]][m].x*SHIFT+s[paths[state][l]][m].y] = s[paths[state][l]][m].value;\n          //   baselp += s[paths[state][l]][m].value;\n          // }\n        }\n      }\n      if(DBG) cout << \"baselp \" << baselp << endl;\n\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          ll lp = 0;\n          //map<int, int> mpl;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          for(int l = s[k].size()-1; l >= 0; --l){\n            if(DBG)cout << \"(\" << s[k][l].x << \",\" << s[k][l].y << \")\";\n            if( mpl[s[k][l].x][ s[k][l].y] > 0){\n              mpl[s[k][l].x][ s[k][l].y] = -mpl[s[k][l].x][ s[k][l].y];\n              lp += mpl[s[k][l].x][ s[k][l].y];\n              lp += s[k][l].value;\n            }else if( mpl[s[k][l].x][ s[k][l].y] == 0){\n              lp += s[k][l].value;\n            }\n            // if( mpl[s[k][l].x*SHIFT+s[k][l].y] > 0){\n            //   //mpl[s[k][l].x*SHIFT+s[k][l].y] = s[k][l].value;\n            //   mpl[s[k][l].x*SHIFT+s[k][l].y] = -mpl[s[k][l].x*SHIFT+ s[k][l].y];\n            //   lp += mpl[s[k][l].x*SHIFT+ s[k][l].y];\n            //   lp += s[k][l].value;\n            //   if(DBG) cout << lp << endl;\n            //   //s[k][l].value;\n            // }else if( mpl[s[k][l].x*SHIFT+s[k][l].y] == 0){\n            //   lp += s[k][l].value;\n            //   if(DBG) cout << lp << endl;\n            // }\n          }\n          if(DBG)cout << \" res = \" << lp+baselp << endl;\n          if(cells[state|mask] < lp+baselp){\n            cells[state|mask] = lp+baselp;\n            paths[state|mask] = paths[state];\n            paths[state|mask].push_back(k);\n          }\n          rep(l, s[k].size()){\n            if(DBG)cout << \"(\" << s[k][l].x << \",\" << s[k][l].y << \")\";\n            for(int l = s[k].size()-1; l >= 0; --l){\n              if( mpl[s[k][l].x][ s[k][l].y] > 0){\n                mpl[s[k][l].x][ s[k][l].y] = -mpl[s[k][l].x][ s[k][l].y];\n              }\n              // if( mpl[s[k][l].x*SHIFT+ s[k][l].y] > 0){\n              //   mpl[s[k][l].x*SHIFT+s[k][l].y] = -mpl[s[k][l].x*SHIFT+s[k][l].y];\n              // }\n            }\n          }\n        }\n      }\n    }\n    if(DBG)cout <<\"case ans---\" <<endl;\n    cout << cells[(1<<n)-1] << endl;\n    if(DBG)cout <<\"case end---\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nenum { U, B, L, F, R, D };\nstruct Dice {\n\tint face[6];\n\n\tDice() {\n\t\tface[F] = 1;\n\t\tface[R] = 2;\n\t\tface[U] = 3;\n\t\tface[B] = 6;\n\t\tface[L] = 5;\n\t\tface[D] = 4;\n\t}\n\n\tint find_face(int f) {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(face[i] == f) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R:\n\t\t\trotate(U, R, D, L);\n\t\t\tbreak;\n\t\tcase B:\n\t\t\trotate(U, B, D, F);\n\t\t\tbreak;\n\t\tcase L:\n\t\t\trotate(U, L, D, R);\n\t\t\tbreak;\n\t\tcase F:\n\t\t\trotate(U, F, D, B);\n\t\t\tbreak;\n\t\tcase U:\n\t\t\trotate(F, R, B, L);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tcase D:\n\t\t\trotate(F, L, B, R);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\tint& operator[](int n) { return face[n]; }\n\n\tconst int& operator[](int n) const { return face[n]; }\n\n\tstd::vector<Dice> all_rolls() {\n\t\tstd::vector<Dice> res;\n\t\tfor(int k = 0; k < 6; k++) {\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tres.push_back(*this);\n\t\t\t\tturn(R);\n\t\t\t}\n\t\t\tturn(k % 2 == 1 ? U : F);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c];\n\t\tface[c] = face[b];\n\t\tface[b] = face[a];\n\t\tface[a] = t;\n\t}\n};\n\ntypedef pair<int, int> P;\n\nDice dice[15];\nint X[15], Y[15];\nstring rot[15];\nmap<P, int> pos[15];\nint dp[16][1 << 15];\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint l, r, f, b, d, u;\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\t\tcin >> rot[i];\n\t\t\tdice[i][L] = l;\n\t\t\tdice[i][R] = r;\n\t\t\tdice[i][F] = f;\n\t\t\tdice[i][B] = b;\n\t\t\tdice[i][D] = d;\n\t\t\tdice[i][U] = u;\n\n\t\t\tDice t = dice[i];\n\t\t\tint x = X[i], y = Y[i];\n\t\t\tpos[i].clear();\n\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\tfor(auto c : rot[i]) {\n\t\t\t\tif(c == 'L') t.turn(L), x--;\n\t\t\t\tif(c == 'R') t.turn(R), x++;\n\t\t\t\tif(c == 'F') t.turn(F), y--;\n\t\t\t\tif(c == 'B') t.turn(B), y++;\n\t\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\t\tint s = dp[i][j];\n\t\t\t\tset<P> used;\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tif(j >> k & 1) {\n\t\t\t\t\t\tfor(auto p : pos[k]) {\n\t\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\t\tused.insert({ x, y });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tint ns = s;\n\t\t\t\t\tfor(auto p : pos[k]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tint point = p.second;\n\t\t\t\t\t\tif(used.count({ x, y })) continue;\n\t\t\t\t\t\tns += point;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j | (1 << k)] = max(dp[i + 1][j | (1 << k)], ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\tans = max(ans, dp[N][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define MP(x,y) make_pair(x,y)\n#define ARRAY 65536\n#define X first\n#define Y second\n#define DBG 0\nusing namespace std;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n      std::fill( (T*)array, (T*)(array+N), val );\n}\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n  void print(){\n    cout << \"(  \" << x<< \" , \" << y<< \" ) \" << value << endl;\n  }\n};\nclass iStump{\n  public:\n  int id, val;\n  iStump(int _id, int _val):id(_id),val(_val){}; \n};\n\n//int mpl[2200][2200] ={0};\n\n// ??§?¨????id 31*15?????§\nmap<pair<int,int>, int> memo;\n\nint main(void){\n  int n;\n  int ca = 0;\n  while(cin >> n, n){\n    vector<char> paths[ARRAY]; //[state]?????¨???????????????????????????\n    int dp[ARRAY] = {0}; //[state]?????¨???????????§???\n    int xy[1024][16] = {0}; //[??§?¨?id]???[????????????id] ??? ??????????????????\n    int x, y, v;\n    int ans = 0;\n    int used_xy = 0;\n    memo.clear();\n\n    string r;\n    vector<Stump> ts[32];\n    vector<iStump> s[32];\n\n    rep(i,n){\n      Dice dice;\n      cin >> x >> y;\n      x+=1050;\n      y+=1050;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      ts[i].push_back(Stump(x, y, dice[5]));\n      if(DBG) ts[i].back().print();\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        ts[i].push_back(Stump(x, y, dice[5]));\n        if(DBG) ts[i].back().print();\n      }\n\n      map<pair<int,int>, int> used;\n      for(int k = ts[i].size()-1; k >= 0 ; --k){\n        pair<int,int> xyz=MP(ts[i][k].x,+ts[i][k].y);\n        if(used[xyz] != 0) ts[i][k].value = 0;\n        if(memo[xyz] == 0){\n          //cout << xyz.X << \" \" << xyz.Y << \" \" << used_xy << endl;\n          memo[xyz] = ++used_xy;\n        }\n        used[xyz] = 1;\n      }\n\n\n      int sum = 0;\n      //cout << i << endl;\n      rep(k,ts[i].size()){\n        if(ts[i][k].value > 0){\n          int cell_id = memo[MP(ts[i][k].x,ts[i][k].y)];\n          s[i].push_back( iStump(cell_id, ts[i][k].value));\n          xy[cell_id][i] = ts[i][k].value;\n//           cout << cell_id << \" -> \" << xy[cell_id][i] << endl;\n          sum += xy[cell_id][i];\n        }\n      }\n//      cout << \"sum \" << sum << endl;\n    }\n//     rep(i, used_xy){\n//       rep(j, n){\n//         cout << xy[i][j] << \"\\t\";\n//       }cout << endl;\n//     }\n\n    //DP\n    rep(i, (1<<n)-1){\n      int state = i;\n      if(DBG) cout << \"baselp \" << dp[state] << endl;\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          int lp = 0;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          rep(l, s[k].size()){\n            iStump ss = s[k][l];\n            int current = 0;\n\n            for(int j = paths[state].size()-1; j >= 0; --j){\n              if(xy[ss.id][paths[state][j]] > 0){\n                current = xy[ss.id][paths[state][j]];\n                break;\n              }\n            }\n            if(current==0) lp += ss.val;\n          }\n          if(DBG)cout << \" res = \" << lp+dp[state] << endl;\n          if(dp[state|mask] < lp+dp[state]){\n            dp[state|mask] = lp+dp[state];\n            //paths[state|mask] = paths[state];\n            paths[state|mask].clear();\n            paths[state|mask].push_back(k);\n            rep(j,paths[state].size()) paths[state|mask].push_back(paths[state][j]);\n          }\n        }\n      }\n    }\n\n    cout << dp[(1<<n)-1] << endl;\n//     cout << \"case\" << endl;\n//     rep(i, paths[(1<<n)-1].size()){\n//       cout << paths[(1<<n)-1][i] << endl;\n//     }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = int;\nusing MAP_t = map<PR, int>;\n\nint encode(int x, int y) { return 3000 * x + y; }\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\nint merge(int idx1, int idx2, MAP_t& dest) {\n    dest = boards[idx1];\n    int res_v = scores[idx1];\n\n    for (const pair<PR, int>& itr : boards[idx2]) {\n        res_v += itr.second - dest[itr.first];\n        dest[itr.first] = itr.second;\n    }\n\n    return res_v;\n}\n\nint solve() {\n    MAP_t trg;\n\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            int sc = merge((1 << i), m, trg);\n            if (sc > scores[n]) {\n                boards[n] = trg;\n                scores[n] = sc;\n            }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores + (1 << N), 0);\n        for (int i = 0; i < (1 << N); ++i) boards[i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            x += 1000; y += 1000;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][encode(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                PR key = encode(x, y);\n                sc += d.d - boards[idx][key];\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\n#include <bitset>\nusing namespace std;\nconstexpr int maxnum = 15*30;\n\nint rot[4][6] = {{5, 4, 2, 3, 0, 1},\n                 {4, 5, 2, 3, 1, 0},\n                 {0, 1, 5, 4, 2, 3},\n                 {0, 1, 4, 5, 3, 2}};\nint dir_x[4] = {-1, 1, 0, 0};\nint dir_y[4] = {0, 0, -1, 1};\nvector<int> rotate(vector<int> a, int dir){\n    vector<int> res(6);\n    for(int i=0; i<6; i++){\n        res[i] = a[rot[dir][i]];\n    }\n    return res;\n}\nvector<int> dir_to_idx(string &s){\n    vector<int> res;\n    for(char c: s){\n        if(c == 'L') res.push_back(0);\n        else if(c == 'R') res.push_back(1);\n        else if(c == 'F') res.push_back(2);\n        else if(c == 'B') res.push_back(3);\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        vector<map<pair<int,int>, int>> boards(n);\n        for(int i=0; i<n; i++){\n            int x,y;\n            cin >> x >> y;\n            vector<int> p(6);\n            for(int i=0; i<6; i++){\n                cin >> p[i];\n            }\n            string s;\n            cin >> s;\n            vector<int> dirs = dir_to_idx(s);\n            boards[i][{x,y}] = p[4];\n            for(int j: dirs){\n                p = rotate(p, j);\n                x += dir_x[j];\n                y += dir_y[j];\n                boards[i][{x,y}] = p[4];\n            }\n        }\n\n        map<pair<int,int>, int> idx_cmp;\n        for(auto &b: boards){\n            for(auto &p: b){\n                idx_cmp[p.first] = 0;\n            }\n        }\n        int count = 0;\n        for(auto &p: idx_cmp){\n            p.second = count++;\n        }\n        \n        vector<int> dp(1<<n, 0);\n        vector<bitset<maxnum>> used(1<<n);\n        for(int i=0; i<(1<<n); i++){\n            for(int j=0; j<n; j++){\n                if(i>>j&1) continue;\n                int k = i | (1<<j);\n                bitset<maxnum> used_curr;\n                int add_points = 0;\n                for(auto &p: boards[j]){\n                    int pos = idx_cmp[p.first];\n                    used_curr[pos] = 1;\n                    if(used[i][pos] == 0){\n                        add_points += p.second;\n                    }\n                }\n                dp[k] = max(dp[k], dp[i]+add_points);\n                used[k] |= used_curr;\n            }\n        }\n        cout << dp[(1<<n)-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define ARRAY 65536\n#define DBG 0\n#define SHIFT 2200\nusing namespace std;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n      std::fill( (T*)array, (T*)(array+N), val );\n}\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n};\nclass iStump{\n  public:\n  int id, val;\n  iStump(int _id, int _val):id(_id),val(_val){}; \n};\n\n//int mpl[2200][2200] ={0};\n\n// ??§?¨????id 31*15?????§\nmap<pair<int,int>, int> memo;\n\nint main(void){\n  int n;\n  while(cin >> n, n){\n    vector<char> paths[ARRAY];\n    int xy[1024][16] = {0};\n    int dp[ARRAY] = {0};\n    int x, y, v;\n    int ans = 0;\n    int used_xy = 0;\n\n    string r;\n    Dice dice;\n    vector<Stump> ts[32];\n    vector<iStump> s[32];\n\n\n    rep(i,n){\n      cin >> x >> y;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      x+=1050;\n      y+=1050;\n      ts[i].push_back(Stump(x, y, dice[5]));\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        ts[i].push_back(Stump(x, y, dice[5]));\n      }\n      map<int, int> used;\n      for(int k = ts[i].size()-1; k >= 0 ; --k){\n        if(used[ts[i][k].x*SHIFT+ts[i][k].y] != 0){\n          ts[i][k].value = 0;\n        }else{\n          memo[make_pair(ts[i][k].x,ts[i][k].y)] = used_xy++;\n        }\n        used[ts[i][k].x*SHIFT+ts[i][k].y] = 1;\n      }\n      rep(k,ts[i].size()){\n          if(ts[i][k].value > 0){\n            int cell_id = memo[make_pair(ts[i][k].x,ts[i][k].y)];\n            s[i].push_back( iStump(cell_id, ts[i][k].value));\n            xy[ cell_id][i] = ts[i][k].value;\n          }\n      }\n      //cout << ts[i].size() << \" \" << s[i].size() << endl;;\n      used.clear();\n    }\n\n    rep(i, 1<<n){\n      int state = i;\n      int baselp = dp[state];\n\n      if(DBG) cout << \"baselp \" << baselp << endl;\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          int lp = 0;\n          //map<int, int> mpl;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          rep(l, s[k].size()){\n            iStump ss = s[k][l];\n            int current = 0;\n\n            rep(j, paths[state].size()){\n              current = xy[ss.id][paths[state][j]]!=0? xy[ss.id][paths[state][j]] : current;\n            }\n            lp += ss.val - current;\n\n          }\n          if(DBG)cout << \" res = \" << lp+baselp << endl;\n          if(dp[state|mask] < lp+baselp){\n            dp[state|mask] = lp+baselp;\n            paths[state|mask] = paths[state];\n            paths[state|mask].push_back(k);\n          }\n        }\n      }\n    }\n    if(DBG)cout <<\"case ans---\" <<endl;\n    cout << dp[(1<<n)-1] << endl;\n    if(DBG)cout <<\"case end---\" <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int MAX_N = 15;\n\nstruct Dice{\n  int l, r, f, b, d, u;\n  int x, y;\n\n  Dice(int _l, int _r, int _f, int _b, int _d, int _u, int _x, int _y){\n    l = _l; r = _r; f = _f; b = _b; d = _d; u = _u; x = _x; y = _y;\n  }\n\n  void Left(){\n    int tmp = u;\n    u = r;\n    r = d;\n    d = l;\n    l = tmp;\n    x -= 1;\n  }\n\n  void Right(){\n    int tmp = u;\n    u = l;\n    l = d;\n    d = r;\n    r = tmp;\n    x += 1;\n  }\n\n  void Front(){\n    int tmp = f;\n    f = u;\n    u = b;\n    b = d;\n    d = tmp;\n    y -= 1;\n  }\n\n  void Back(){\n    int tmp = u;\n    u = f;\n    f = d;\n    d = b;\n    b = tmp;\n    y += 1;\n  }\n\n  void Role(char c){\n    if(c == 'L') Left();\n    else if(c == 'R') Right();\n    else if(c == 'F') Front();\n    else Back();\n  }\n\n  pi cord(){\n    return pi(x, y);\n  }\n\n  void print(){\n    cout << l << \" \" << r << \" \" << f << \" \" << b << \" \" << d << \" \" << u << endl;\n  }\n};\n\nint N;\nmap<pi, int>Scores[16];\nmap<pi, int>Map;\nint dp[1<<MAX_N];\n\nint dfs(int S)\n{\n\n  int &res = dp[S];\n  if(res > 0){\n    return res;\n  }\n\n  if(S == (1<<N)-1){\n    return 0;\n  }\n  \n  for(int u=0;u<N;++u){\n    if(!(S >> u & 1)){\n      int score = 0;\n      int nS = S | 1 << u;\n      for(auto mass: Scores[u]){\n\tpi cord = mass.first;\n\tif((Map[cord] & nS) == Map[cord]) score += mass.second;\n      }\n      res = max(res, dfs(nS) + score);      \n    }\n  }\n  return res;\n}\n\nint main()\n{\n  while(cin >> N, N){\n    memset(dp, 0, sizeof(dp));\n    for(int i=0;i<N;i++) Scores[i].clear();\n    Map.clear();\n    for(int i=0;i<N;i++){\n      int x, y, l, r, f, b, d, u;\n      string rot;\n      cin >> x >> y >> l >> r >> f >> b >> d >> u >> rot;\n      Dice dice(l, r, f, b, d, u, x, y);\n      pi cord = dice.cord();      \n      Scores[i][cord] =  dice.d;\n      if(Map.find(cord) == Map.end())\n\tMap[cord] = 0;\n      Map[cord] = Map[cord] | (1<<i);\n      for(auto c: rot){\n\tdice.Role(c);\n\t//\tdice.print();\n\tcord = dice.cord();\t\n\tScores[i][cord] =  dice.d;\n\tif(Map.find(cord) == Map.end())\n\t  Map[cord] = 0;\n\tMap[cord] = Map[cord] | (1<<i);\t\n      }\n\n\n      //      int sum = 0;\n      /*      for(auto x: Scores[i]){\n\tcout << x.first.first << \" \"<< x.first.second << \" \" << x.second << endl;\n\t//\tsum += x.second;\n      }\n\n      for(auto x: Map){\n\tcout << x.first.first << \" \"<< x.first.second << \" \" << x.second << endl;\t\n      }\n      */\n      //      cout << sum  << endl;\n    }\n    \n    cout << dfs(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\n\nunordered_set<int> used[3000];\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    unordered_map<int,int> v[3000];\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v[d.y+1500].count(d.x)||!used[d.y+1500].count(d.x)){\n\t//cout<<tmp<<\" \"<<d.bottom()<<endl;\n\ttmp+=d.bottom();\n\tif(v[d.y+1500].count(d.x)) tmp-=v[d.y+1500][d.x];\n\tv[d.y+1500][d.x]=d.bottom();\n\tused[d.y+1500].insert(d.x);\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(int k=0;k<3000;k++)\n      for(auto j:v[k]) used[k].erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    for(int k=0;k<3000;k++) used[k].clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct Dice {\n\tint tp;\n\tint bo;\n\tint no;\n\tint so;\n\tint ea;\n\tint we;\n\tDice(const int tp_, const int bo_, const int no_, const int so_, const int ea_, const int we_) :\n\t\ttp(tp_), bo(bo_), no(no_), so(so_), ea(ea_), we(we_) {\n\t}\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice() {\n\t\ttp = 1;\n\t\t/*bo = 6;\n\t\tno = 2;\n\t\tso = 5;\n\t\tea = 3;\n\t\twe = 4;*/\n\t}\n\tenum R_Way {\n\t\tR_Left=0,\n\t\tR_Front=1,\n\t\tR_Right=2,\n\t\tR_Back=3,\n\n\t\tR_Dummy,\n\t};\n\tint rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tint c = tp;\n\t\t\ttp = we;\n\t\t\twe = bo;\n\t\t\tbo = ea;\n\t\t\tea = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tint c = tp;\n\t\t\ttp = so;\n\t\t\tso = bo;\n\t\t\tbo = no;\n\t\t\tno = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\tint c = tp;\n\t\t\ttp = ea;\n\t\t\tea = bo;\n\t\t\tbo = we;\n\t\t\twe = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\tint c = tp;\n\t\t\ttp = no;\n\t\t\tno = bo;\n\t\t\tbo = so;\n\t\t\tso = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\treturn tp;\n\t}\n\tint rotate(const int way) {\n\t\treturn rotate(static_cast<R_Way>(way));\n\t}\n\tint hash()const {\n\t\treturn tp + we * 6 + no * 36;\n\t}\n};\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\n\nint gettop(int south, int east) {\n\treturn geteast(south, east);\n}\nint getsouth(int east, int top) {\n\treturn 7 - geteast(top, east);\n}\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\n\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,-1,0,1 };\n\npair<int,vector<pair<short,short>>>getmemo(const vector<map<pair<short, short>, short>>&field,vector<pair<int,vector<pair<short, short>>>>&memo ,bitset<15>&used) {\n\tif (memo[used.to_ulong()].second.empty()) {\n\t\tif (!used.count()) {\n\t\t\treturn make_pair(0,vector<pair<short,short>>());\n\t\t}\n\t\telse {\n\t\t\tint high_sc = -1;\n\t\t\tvector<pair<short, short>> hi_fi;\n\t\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\t\tif (used[i]) {\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tauto pre(getmemo(field,memo, used));\n\t\t\t\t\t int sc = pre.first;\n\t\t\t\t\tauto pre_fi = pre.second;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tauto new_fi(pre_fi);\n\t\t\t\t\tfor (auto n_c : field[i]) {\n\t\t\t\t\t\tif (!binary_search(pre_fi.begin(), pre_fi.end(), n_c.first)) {\n\t\t\t\t\t\t\tsc += n_c.second;\n\t\t\t\t\t\t\tnew_fi.emplace_back(n_c.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (high_sc < sc) {\n\t\t\t\t\t\thigh_sc = sc;\n\n\t\t\t\t\t\tsort(new_fi.begin(), new_fi.end());\n\t\t\t\t\t\tnew_fi.erase(unique(new_fi.begin(), new_fi.end()), new_fi.end());\n\n\t\t\t\t\t\thi_fi = new_fi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[used.to_ulong()]=make_pair(high_sc, hi_fi);\n\t\t}\n\t}\n\telse {\n\t\treturn memo[used.to_ulong()];\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<map<pair<short, short>, short>>field(N, map<pair<short, short>, short>());\n\t\tmap<char, short>name;\n\t\tname['R'] = 2;\n\t\tname['L'] = 0;\n\t\tname['B'] = 3;\n\t\tname['F'] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmap<pair<short, short>, short>mp;\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tint l, r, f, b, d, u; cin >> l >> r >> f >> b >> d >> u;\n\t\t\tstring rot; cin >> rot;\n\t\t\tmp[make_pair(x, y)] = d;\n\t\t\tDice di(u, d, b, f, r, l);\n\n\t\t\tfor (auto c : rot) {\n\t\t\t\tconst int way = name[c];\n\t\t\t\tx += dx[way];\n\t\t\t\ty += dy[way];\n\t\t\t\tdi.rotate(way);\n\t\t\t\tmp[make_pair(x, y)] = di.bo;\n\t\t\t}\n\t\t\tfield[i] = mp;\n\t\t}\n\t\tvector<pair<int,vector<pair<short, short>>>>memo(1<<N);\n\t\tbitset<15>bs((1 << N) - 1);\n\t\tauto ans = getmemo(field, memo, bs);\n\t\tcout << ans.first << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nenum {\n    LEFT, RIGHT, FRONT, BACK, DOWN, UP\n};\n\nclass dice {\npublic:\n    dice(vector<int> score) : score(score) { assert(score.size() == 6); }\n\n    void roll(char dir) {\n        assert(dir == 'L' || dir == 'R' || dir == 'B' || dir == 'F');\n        vector<int> nscore = score;\n        if(dir == 'L') {\n            nscore[LEFT] = score[UP];\n            nscore[UP] = score[RIGHT];\n            nscore[RIGHT] = score[DOWN];\n            nscore[DOWN] = score[LEFT];\n        } else if(dir == 'R') {\n            nscore[RIGHT] = score[UP];\n            nscore[UP] = score[LEFT];\n            nscore[LEFT] = score[DOWN];\n            nscore[DOWN] = score[RIGHT];\n        } else if(dir == 'F') {\n            nscore[FRONT] = score[UP];\n            nscore[UP] = score[BACK];\n            nscore[BACK] = score[DOWN];\n            nscore[DOWN] = score[FRONT];\n        } else {\n            nscore[BACK] = score[UP];\n            nscore[UP] = score[FRONT];\n            nscore[FRONT] = score[DOWN];\n            nscore[DOWN] = score[BACK];\n        }\n        score = move(nscore);\n    }\n\n    int get_value(int dir) const {\n        return score[dir];\n    }\n\nprivate:\n    vector<int> score;\n};\n\nint main() {\n    const string dirs = \"LRFB\";\n    constexpr int dx[4] = {-1, 1, 0, 0};\n    constexpr int dy[4] = {0, 0, -1, 1};\n    int n;\n    while(cin >> n, n) {\n        // (x, y -> value);\n        using traj = map<pii, int>;\n        vector<traj> trajs;\n        for(int i = 0; i < n; ++i) {\n            int x, y;\n            cin >> x >> y;\n            vector<int> score(6);\n            for(int j = 0; j < 6; ++j) {\n                cin >> score[j];\n            }\n            string rot;\n            cin >> rot;\n            dice d(score);\n            traj t;\n            t[make_pair(x, y)] = d.get_value(DOWN);\n            for(char to : rot) {\n                int dir = dirs.find(to);\n                x += dx[dir], y += dy[dir];\n                d.roll(to);\n                t[make_pair(x, y)] = d.get_value(DOWN);\n            }\n            trajs.push_back(move(t));\n        }\n\n        vector<int> dp(1 << n);\n        for(int S = 0; S < (1 << n); ++S) {\n            set<pii> used;\n            for(int i = 0; i < n; ++i) {\n                if(S & (1 << i)) {\n                    for(auto& p : trajs[i]) {\n                        used.insert(p.first);\n                    }\n                }\n            }\n            for(int i = 0; i < n; ++i) {\n                if(S & (1 << i)) continue;\n                map<pii, int> new_values;\n                for(auto& p : trajs[i]) {\n                    if(used.count(p.first)) continue;\n                    new_values[p.first] = p.second;\n                }\n                int value = 0;\n                for(auto& p : new_values) {\n                    value += p.second;\n                }\n                dp[S | (1 << i)] = max(dp[S | (1 << i)], dp[S] + value);\n            }\n        }\n\n        cout << dp.back() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = pair<int, int>;\nusing MAP_t = map<PR, int>;\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\npair<MAP_t, int> merge(int idx, MAP_t m2) {\n    MAP_t res_m = boards[idx];\n    int res_v = scores[idx];\n    for (const pair<PR, int>& itr : m2) {\n        res_v += itr.second - res_m[itr.first];\n        res_m[itr.first] = itr.second;\n    }\n\n    return make_pair(res_m, res_v);\n}\n\nint solve() {\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            pair<MAP_t, int> mm = merge(m, boards[1 << i]);\n            if (mm.second > scores[n]) {\n                boards[n] = mm.first;\n                scores[n] = mm.second;\n            }\n\n            mm = merge((1 << i), boards[m]);\n            if (mm.second > scores[n]) {\n                scores[n] = mm.second;\n                boards[n] = mm.first;\n            }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores+(1<<N), 0);\n        for (int i = 0; i < (1 << N); ++i) boards[i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][make_pair(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                pair<int, int> key = make_pair(x, y);\n                sc += d.d - (boards[idx].find(key) != end(boards[idx]) ? boards[idx][key] : 0);\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 15\ntypedef pair<int, int> pii;\n\nclass Dice {\n  private:\n    void roll(int a, int b, int c, int d)\n    {\n        swap(v[a], v[b]);\n        swap(v[b], v[d]);\n        swap(v[c], v[d]);\n    }\n    \n  public:\n    int v[6], x, y;\n    string order;\n    void roll_B() { roll(0, 1, 4, 5); }\n    void roll_R() { roll(0, 3, 2, 5); }\n    void roll_F() { roll(0, 4, 1, 5); }\n    void roll_L() { roll(0, 2, 3, 5); }\n};\n\nint change(int y, int x)\n{\n    hash<int> z;\n    return z(y<<28) ^ z(x);\n}\n\nvoid rot(unordered_set<int> &a, Dice &d)\n{\n    a.insert(change(d.y, d.x));\n    for (auto &c: d.order) {\n        if (c == 'L') {\n            c = 'R';\n            d.roll_L();\n            d.x--;\n        } else if (c == 'F') {\n            c = 'B';\n            d.roll_F();\n            d.y--;\n        } else if (c == 'R') {\n            c = 'L';\n            d.roll_R();\n            d.x++;\n        } else {\n            c = 'F';\n            d.roll_B();\n            d.y++;\n        }\n        a.insert(change(d.y, d.x));\n    }\n    reverse(d.order.begin(), d.order.end());\n}\n\nvoid merge(unordered_set<int> &a, unordered_set<int> &b)\n{\n    for (auto p: b) {\n        a.insert(p);        \n    }\n}\n\nint get_cost(unordered_set<int> decided, Dice d)\n{\n    int res = 0;    \n    if (decided.count(change(d.y, d.x)) == 0) {\n        decided.insert(change(d.y, d.x));\n        res += d.v[5];\n    }\n        \n    for (auto c: d.order) {\n        if (c == 'L') {\n            d.x--;\n            d.roll_L();\n        } else if (c == 'F') {\n            d.y--;\n            d.roll_F();\n        } else if (c == 'R') {\n            d.x++;\n            d.roll_R();\n        } else {\n            d.y++;\n            d.roll_B();\n        }\n        if (decided.count(change(d.y, d.x)) == 0) {\n            decided.insert(change(d.y, d.x));\n            res += d.v[5];\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Dice> d(N);\n        for (int i = 0; i < N; i++) {\n            cin >> d[i].x >> d[i].y;\n            cin >> d[i].v[3] >> d[i].v[2] >> d[i].v[1];\n            cin >> d[i].v[4] >> d[i].v[5] >> d[i].v[0];\n            cin >> d[i].order;\n        }\n\n        unordered_set<int> a[MAX_N];\n        for (int i = 0; i < N; i++) {\n            rot(a[i], d[i]);\n        }\n       \n        int dp[1<<MAX_N];\n        memset(dp, -1, sizeof(dp));\n\n        dp[0] = 0;\n        for (int i = 0; i < (1<<N); i++) {\n            if (dp[i] == -1) continue;            \n            unordered_set<int> decided;\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) {\n                    merge(decided, a[j]);\n                }\n            }\n\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) continue;\n                int ni = i | (1<<j);                \n                dp[ni] = max(dp[ni], dp[i] + get_cost(decided, d[j]));\n            }\n        }\n        cout << dp[(1<<N)-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 15\ntypedef pair<int, int> pii;\n\nclass Dice {\n  private:\n    void roll(int a, int b, int c, int d)\n    {\n        swap(v[a], v[b]);\n        swap(v[b], v[d]);\n        swap(v[c], v[d]);\n    }\n    \n  public:\n    int v[6], x, y;\n    string order;\n    void roll_B() { roll(0, 1, 4, 5); }\n    void roll_R() { roll(0, 3, 2, 5); }\n    void roll_F() { roll(0, 4, 1, 5); }\n    void roll_L() { roll(0, 2, 3, 5); }\n};\n\nint change(int y, int x)\n{\n    return ((y << 25) + (x << 11));\n}\n\nvoid rot(unordered_set<int> &a, Dice &d)\n{\n    a.insert(change(d.y, d.x));\n    for (auto &c: d.order) {\n        if (c == 'L') {\n            c = 'R';\n            d.roll_L();\n            d.x--;\n        } else if (c == 'F') {\n            c = 'B';\n            d.roll_F();\n            d.y--;\n        } else if (c == 'R') {\n            c = 'L';\n            d.roll_R();\n            d.x++;\n        } else {\n            c = 'F';\n            d.roll_B();\n            d.y++;\n        }\n        a.insert(change(d.y, d.x));\n    }\n    reverse(d.order.begin(), d.order.end());\n}\n\nvoid merge(unordered_set<int> &a, unordered_set<int> &b)\n{\n    for (auto p: b) {\n        a.insert(p);        \n    }\n}\n\nint get_cost(unordered_set<int> decided, Dice d)\n{\n    int res = 0;    \n    if (decided.count(change(d.y, d.x)) == 0) {\n        decided.insert(change(d.y, d.x));\n        res += d.v[5];\n    }\n        \n    for (auto c: d.order) {\n        if (c == 'L') {\n            d.x--;\n            d.roll_L();\n        } else if (c == 'F') {\n            d.y--;\n            d.roll_F();\n        } else if (c == 'R') {\n            d.x++;\n            d.roll_R();\n        } else {\n            d.y++;\n            d.roll_B();\n        }\n        if (decided.count(change(d.y, d.x)) == 0) {\n            decided.insert(change(d.y, d.x));\n            res += d.v[5];\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Dice> d(N);\n        for (int i = 0; i < N; i++) {\n            cin >> d[i].x >> d[i].y;\n            cin >> d[i].v[3] >> d[i].v[2] >> d[i].v[1];\n            cin >> d[i].v[4] >> d[i].v[5] >> d[i].v[0];\n            cin >> d[i].order;\n        }\n\n        unordered_set<int> a[MAX_N];\n        for (int i = 0; i < N; i++) {\n            rot(a[i], d[i]);\n        }\n       \n        int dp[1<<MAX_N];\n        memset(dp, -1, sizeof(dp));\n\n        dp[0] = 0;\n        for (int i = 0; i < (1<<N); i++) {\n            if (dp[i] == -1) continue;            \n            unordered_set<int> decided;\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) {\n                    merge(decided, a[j]);\n                }\n            }\n\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) continue;\n                int ni = i | (1<<j);                \n                dp[ni] = max(dp[ni], dp[i] + get_cost(decided, d[j]));\n            }\n        }\n        cout << dp[(1<<N)-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\n\nset<int> used[3000];\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    set<int> vi;\n    map<int,int> v[3000];\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v[d.y+1500].count(d.x)||!used[d.y+1500].count(d.x)){\n\t//cout<<tmp<<\" \"<<d.bottom()<<endl;\n\ttmp+=d.bottom();\n\tif(v[d.y+1500].count(d.x)) tmp-=v[d.y+1500][d.x];\n\tv[d.y+1500][d.x]=d.bottom();\n\tused[d.y+1500].insert(d.x);\n\tvi.insert(d.y+1500);\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(int k:vi) for(auto j:v[k]) used[k].erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    for(int k=0;k<3000;k++) used[k].clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nint table[4000][4000];\nint tb[4000][4000];\nint tmp_table[4000][4000];\nint rots(int n, bool update=false){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\tfill( tb[0], tb[0]+4000*4000, 0 );\n\ttb[pos.X][pos.Y] = dc.point();\n\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[pos.X][pos.Y] = dc.point();\n\t\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\t}\n\t// merge\n\tint sum = 0;\n\tdc = dice_org[n];\n\tpos = dice_pos[n];\n\tif( table[pos.X][pos.Y] == 0 && tb[pos.X][pos.Y] > 0 ){\n\t\tif(update) table[pos.X][pos.Y] = tb[pos.X][pos.Y];\n\t\tsum += tb[pos.X][pos.Y];\n\t\ttb[pos.X][pos.Y] = 0;\n\t}\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\tif( table[pos.X][pos.Y] == 0 && tb[pos.X][pos.Y] > 0 ){\n\t\t\tif(update) table[pos.X][pos.Y] = tb[pos.X][pos.Y];\n\t\t\tsum += tb[pos.X][pos.Y];\n\t\t\ttb[pos.X][pos.Y] = 0;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\t\t//rrep(i,N){\n\t\t//\tfill( table[0], table[0]+4000*4000, 0 );\n\t\t//\tcout << \"rots: \" << rots(i) << endl;\n\t\t//}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\tfill( table[0], table[0]+4000*4000, 0 );\n\t\t\trep(k,N) if( (1<<k)&i ) rots(k, true);\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + rots(k) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 15\ntypedef pair<int, int> pii;\n\nclass Dice {\n  private:\n    void roll(int a, int b, int c, int d)\n    {\n        swap(v[a], v[b]);\n        swap(v[b], v[d]);\n        swap(v[c], v[d]);\n    }\n    \n  public:\n    int v[6], x, y;\n    string order;\n    void roll_B() { roll(0, 1, 4, 5); }\n    void roll_R() { roll(0, 3, 2, 5); }\n    void roll_F() { roll(0, 4, 1, 5); }\n    void roll_L() { roll(0, 2, 3, 5); }\n};\n\nint change(int y, int x)\n{\n    return (y<<28) ^ (x);\n}\n\nvoid rot(unordered_set<int> &a, Dice &d)\n{\n    a.insert(change(d.y, d.x));\n    for (auto &c: d.order) {\n        if (c == 'L') {\n            c = 'R';\n            d.roll_L();\n            d.x--;\n        } else if (c == 'F') {\n            c = 'B';\n            d.roll_F();\n            d.y--;\n        } else if (c == 'R') {\n            c = 'L';\n            d.roll_R();\n            d.x++;\n        } else {\n            c = 'F';\n            d.roll_B();\n            d.y++;\n        }\n        a.insert(change(d.y, d.x));\n    }\n    reverse(d.order.begin(), d.order.end());\n}\n\nvoid merge(unordered_set<int> &a, unordered_set<int> &b)\n{\n    for (auto p: b) {\n        a.insert(p);        \n    }\n}\n\nint get_cost(unordered_set<int> decided, Dice d)\n{\n    int res = 0;    \n    if (decided.count(change(d.y, d.x)) == 0) {\n        decided.insert(change(d.y, d.x));\n        res += d.v[5];\n    }\n        \n    for (auto c: d.order) {\n        if (c == 'L') {\n            d.x--;\n            d.roll_L();\n        } else if (c == 'F') {\n            d.y--;\n            d.roll_F();\n        } else if (c == 'R') {\n            d.x++;\n            d.roll_R();\n        } else {\n            d.y++;\n            d.roll_B();\n        }\n        if (decided.count(change(d.y, d.x)) == 0) {\n            decided.insert(change(d.y, d.x));\n            res += d.v[5];\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Dice> d(N);\n        for (int i = 0; i < N; i++) {\n            cin >> d[i].x >> d[i].y;\n            cin >> d[i].v[3] >> d[i].v[2] >> d[i].v[1];\n            cin >> d[i].v[4] >> d[i].v[5] >> d[i].v[0];\n            cin >> d[i].order;\n        }\n\n        unordered_set<int> a[MAX_N];\n        for (int i = 0; i < N; i++) {\n            rot(a[i], d[i]);\n        }\n       \n        int dp[1<<MAX_N];\n        memset(dp, -1, sizeof(dp));\n\n        dp[0] = 0;\n        for (int i = 0; i < (1<<N); i++) {\n            if (dp[i] == -1) continue;            \n            unordered_set<int> decided;\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) {\n                    merge(decided, a[j]);\n                }\n            }\n\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) continue;\n                int ni = i | (1<<j);                \n                dp[ni] = max(dp[ni], dp[i] + get_cost(decided, d[j]));\n            }\n        }\n        cout << dp[(1<<N)-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nint n, C[20][6], cx[20], cy[20]; string px[20];\nmap<pair<int, int>, int>D[20], E[1 << 16];\nvector<tuple<int, int, int>>_D[20];\nvector<pair<int, int>>_E[1 << 16];\nint dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 16];\nvoid Init1(int I) {\n\tvector<tuple<int, int, int, int>>__D;\n\t__D.push_back(make_tuple(cx[I], cy[I], -1, C[I][4]));\n\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\t__D.push_back(make_tuple(cx[I], cy[I], j, C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(__D.begin(), __D.end());\n\tfor (int i = 0; i < __D.size(); i++) {\n\t\tif (i == __D.size() - 1)_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\telse if (get<0>(__D[i]) != get<0>(__D[i + 1]) || get<1>(__D[i]) != get<1>(__D[i + 1])) {\n\t\t\t_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\t}\n\t}\n\treturn;\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\tpair<int, int>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0) { _E[p].push_back(pa); } E[p][pa] = 1;\n\t\t}\n\t}\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\tInit1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<int, int>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], dp[i] + cnt);\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct Dice {\n\tint tp;\n\tint bo;\n\tint no;\n\tint so;\n\tint ea;\n\tint we;\n\tDice(const int tp_, const int bo_, const int no_, const int so_, const int ea_, const int we_) :\n\t\ttp(tp_), bo(bo_), no(no_), so(so_), ea(ea_), we(we_) {\n\t}\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice() {\n\t\ttp = 1;\n\t\t/*bo = 6;\n\t\tno = 2;\n\t\tso = 5;\n\t\tea = 3;\n\t\twe = 4;*/\n\t}\n\tenum R_Way {\n\t\tR_Left=0,\n\t\tR_Front=1,\n\t\tR_Right=2,\n\t\tR_Back=3,\n\n\t\tR_Dummy,\n\t};\n\tint rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tint c = tp;\n\t\t\ttp = we;\n\t\t\twe = bo;\n\t\t\tbo = ea;\n\t\t\tea = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tint c = tp;\n\t\t\ttp = so;\n\t\t\tso = bo;\n\t\t\tbo = no;\n\t\t\tno = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\tint c = tp;\n\t\t\ttp = ea;\n\t\t\tea = bo;\n\t\t\tbo = we;\n\t\t\twe = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\tint c = tp;\n\t\t\ttp = no;\n\t\t\tno = bo;\n\t\t\tbo = so;\n\t\t\tso = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\treturn tp;\n\t}\n\tint rotate(const int way) {\n\t\treturn rotate(static_cast<R_Way>(way));\n\t}\n\tint hash()const {\n\t\treturn tp + we * 6 + no * 36;\n\t}\n};\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\n\nint gettop(int south, int east) {\n\treturn geteast(south, east);\n}\nint getsouth(int east, int top) {\n\treturn 7 - geteast(top, east);\n}\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\n\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,-1,0,1 };\n\npair<int,map<pair<int, int>, int>>getmemo(const vector<map<pair<int,int>,int>>&field,vector<pair<int,map<pair<int,int>,int>>>&memo,bitset<15>&used) {\n\tif (memo[used.to_ulong()].second.empty()) {\n\t\tif (!used.count()) {\n\t\t\treturn make_pair(0,map < pair<int, int>, int > ());\n\t\t}\n\t\telse {\n\t\t\tint high_sc = -1;\n\t\t\tmap<pair<int, int>, int>hi_fi;\n\t\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\t\tif (used[i]) {\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tauto pre(getmemo(field,memo, used));\n\t\t\t\t\t int sc = pre.first;\n\t\t\t\t\tauto pre_fi = pre.second;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tfor (auto n_c : field[i]) {\n\t\t\t\t\t\tif (pre_fi.find(n_c.first) == pre_fi.end()) {\n\t\t\t\t\t\t\tpre_fi[n_c.first] = n_c.second;\n\t\t\t\t\t\t\tsc += n_c.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (high_sc < sc) {\n\t\t\t\t\t\thigh_sc = sc;\n\t\t\t\t\t\thi_fi = pre_fi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[used.to_ulong()]=make_pair(high_sc, hi_fi);\n\t\t}\n\t}\n\telse {\n\t\treturn memo[used.to_ulong()];\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<map<pair<int, int>, int>>field(N, map<pair<int, int>, int>());\n\t\tmap<char, int>name;\n\t\tname['R'] = 2;\n\t\tname['L'] = 0;\n\t\tname['B'] = 3;\n\t\tname['F'] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmap<pair<int, int>, int>mp;\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tint l, r, f, b, d, u; cin >> l >> r >> f >> b >> d >> u;\n\t\t\tstring rot; cin >> rot;\n\t\t\tmp[make_pair(x, y)] = d;\n\t\t\tDice di(u, d, b, f, r, l);\n\n\t\t\tfor (auto c : rot) {\n\t\t\t\tconst int way = name[c];\n\t\t\t\tx += dx[way];\n\t\t\t\ty += dy[way];\n\t\t\t\tdi.rotate(way);\n\t\t\t\tmp[make_pair(x, y)] = di.bo;\n\t\t\t}\n\t\t\tfield[i] = mp;\n\t\t}\n\t\tvector<pair<int,map<pair<int,int>,int>>>memo(1<<N);\n\t\tbitset<15>bs((1 << N) - 1);\n\t\tauto ans = getmemo(field, memo, bs);\n\t\tcout << ans.first << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint n;\nstruct dat{int x,y;Dice d;};\ndat A[N];\nstring rot[N];\ntypedef pair<short,short> P;\ntypedef map<P,int> M;\nM dice[N];\n\nint getScore(M &mp){\n  int res = 0;\n  for(pair<P,int> p:mp) res += p.second;\n  return res;\n}\n\n\nint dx[1<<8]={},dy[1<<8]={};\nM getNx(int idx,M &mp,int &score,bool flg = 0){\n  M tmp;\n  for(pair<P,int>const  &p:dice[idx]) {\n    tmp[p.first] = p.second;\n    score += p.second - mp[p.first];\n    mp[p.first] = p.second;\n  }\n  M res = flg? mp:M();\n  for(pair<P,int>const &p:tmp) mp[p.first] = p.second;\n  return res;\n}\n\n\nint DP(){\n  M dp[1<<N];\n  int score[1<<N]={};\n  for(int bit;bit<(1<<n);bit++){\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      int nbit = bit | (1<<i);\n      int nscore = score[bit];\n      getNx(i,dp[bit],nscore);\n      if(score[nbit] < nscore) score[nbit] = nscore,dp[nbit] = getNx(i,dp[bit],nscore,1);\n    }\n    dp[bit].clear();\n  }\n  return score[(1<<n)-1];\n}\n\nM getMove(int x,int y,Dice d,string rot){\n  M res;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nsigned main(){\n  dx['L'] = -1, dx['R'] = 1;\n  dy['F'] = -1, dy['B'] = 1;\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot[i];\n      A[i] = (dat){x,y,Dice(l,r,f,b,d,u)};\n      dice[i] = getMove(x,y,Dice(l,r,f,b,d,u),rot[i]);\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstruct dice {\n\tint top;\n\tint bottom;\n\tint front;\n\tint back;\n\tint left;\n\tint right;\n};\n\nvoid rotate_front(dice* d) {\n\tint tmp = d->top;\n\td->top = d->back;\n\td->back = d->bottom;\n\td->bottom = d->front;\n\td->front = tmp;\n}\n\nvoid rotate_back(dice* d) {\n\tint tmp = d->top;\n\td->top = d->front;\n\td->front = d-> bottom;\n\td->bottom = d-> back;\n\td->back = tmp;\n}\n\nvoid rotate_right(dice* d) {\n\tint tmp = d->top;\n\td->top = d->left;\n\td->left = d->bottom;\n\td->bottom = d->right;\n\td->right = tmp;\n}\n\nvoid rotate_left(dice* d) {\n\tint tmp = d->top;\n\td->top = d->right;\n\td->right = d->bottom;\n\td->bottom = d->left;\n\td->left = tmp;\n}\n\nint n;\nvector<PP> vec[15];\n\nll dp[1<<15];\nset<P> data[1<<15];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tdice d;\n\t\t\tscanf(\"%d%d%d%d%d%d\",&d.left,&d.right,&d.front,&d.back,&d.bottom,&d.top);\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tmap<P,int> m;\n\t\t\tm[P(x,y)]=d.bottom;\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]=='R'){\n\t\t\t\t\trotate_right(&d);\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='L'){\n\t\t\t\t\trotate_left(&d);\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='F'){\n\t\t\t\t\trotate_front(&d);\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='B'){\n\t\t\t\t\trotate_back(&d);\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tm[P(x,y)]=d.bottom;\n\t\t\t}\n\t\t\tvec[i].clear();\n\t\t\tfor(map<P,int>::iterator it=m.begin();it!=m.end();it++){\n\t\t\t\tvec[i].push_back(PP(it->first,it->second));\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tdata[i].clear();\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif((i>>j) & 1){\n\t\t\t\t\tfor(int k=0;k<vec[j].size();k++){\n\t\t\t\t\t\tdata[i].insert(vec[j][k].first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(!((i>>j) & 1)){\n\t\t\t\t\tll val=dp[i];\n\t\t\t\t\tfor(int k=0;k<vec[j].size();k++){\n\t\t\t\t\t\tif(data[i].find(vec[j][k].first)==data[i].end()){\n\t\t\t\t\t\t\tval+=vec[j][k].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i|(1<<j)]=max(dp[i|(1<<j)],val);\n\t\t\t\t\tres=max(res,dp[i|(1<<j)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 16\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint n;\nstruct dat{int x,y;Dice d;};\ndat A[N];\nstring rot[N];\ntypedef pair<int,int> P;\ntypedef map<P,int> M;\n\n\nint getScore(M mp){\n  int res = 0;\n  for(pair<P,int> p:mp) res += p.second;\n  return res;\n}\n\n\nM getNx(int idx,M res){\n  static int dx[1<<8]={};dx['L'] = -1, dx['R'] = 1;\n  static int dy[1<<8]={};dy['F'] = -1, dy['B'] = 1;\n  int x = A[idx].x, y = A[idx].y;  \n  Dice d = A[idx].d;\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot[idx]){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n  return res;\n}\n\nint DP(){\n  M dp[1<<N];\n  for(int bit;bit<(1<<n);bit++){\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      int nbit = bit | (1<<i);\n      M nmp = getNx(i,dp[bit]);\n      if(getScore(dp[nbit]) < getScore(nmp)) dp[nbit] = nmp;\n    }\n  }\n  return getScore(dp[(1<<n)-1]);\n}\n\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot[i];\n      A[i] = (dat){x,y,Dice(l,r,f,b,d,u)};\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);++i)\n\nusing namespace std;\n\nstruct Dice {\n  int l,r,f,b,d,u;\n  void L() {\n    int tmp = l;\n    l = u;\n    u = r;\n    r = d;\n    d = tmp;\n  }\n  void R() {\n    L(); L(); L();\n  }\n  void F() {\n    int tmp = f;\n    f = u;\n    u = b;\n    b = d;\n    d = tmp;\n  }\n  void B() {\n    F(); F(); F();\n  }\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin>>n;\n    if (!n) break;\n    using P = pair<int,int>;\n    vector<map<P,int>> vd;\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      int l,r,f,b,d,u;\n      cin>>l>>r>>f>>b>>d>>u;\n      Dice dice = {l, r, f, b, d, u};\n      map<P,int> mp;\n      mp[make_pair(x,y)] = dice.d;\n      string s;\n      cin>>s;\n      for (char c:s) {\n        switch (c) {\n          case 'L':\n            dice.L();\n            --x;\n            break;\n          case 'R':\n            dice.R();\n            ++x;\n            break;\n          case 'F':\n            dice.F();\n            --y;\n            break;\n          case 'B':\n            dice.B();\n            ++y;\n            break;\n        }\n        mp[make_pair(x,y)] = dice.d;\n      }\n      vd.push_back(move(mp));\n    }\n    vector<set<P>> vs(1<<n);\n    REP(i,1<<n) {\n      REP(j,n) {\n        if ((i>>j) & 1) {\n          for (auto p : vd[j]) {\n            vs[i].insert(p.first);\n          }\n        }\n      }\n    }\n    vector<int> dp(1<<n, 0);\n    REP(i,1<<n) {\n      REP(j,n) {\n        if (!((i>>j)&1)) {\n          int score = 0;\n          for (auto p : vd[j]) {\n            if (vs[i].count(p.first)) continue;\n            score += p.second;\n          }\n          dp[i|(1<<j)] = max(dp[i|(1<<j)], dp[i] + score);\n        }\n      }\n    }\n    cout << dp.back() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n// top front right left back bottom\n//front\nvoid S(vector<int>&in){\n  int tmp=in[1];\n  in[1]=in[0];\n  in[0]=in[4];\n  in[4]=in[5];\n  in[5]=tmp;\n}\n//right\nvoid E(vector<int>&in){\n  int tmp=in[2];\n  in[2]=in[0];\n  in[0]=in[3];\n  in[3]=in[5];\n  in[5]=tmp;\n}\n//turn\nvoid T(vector<int>&in){\n  int tmp=in[1];\n  in[1]=in[2];\n  in[2]=in[4];\n  in[4]=in[3];\n  in[3]=tmp;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<vip>in(n);\n\t\trep(i,n){\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tvi t(6);\n// top front right left back bottom\n\t\t\tcin>>t[3]>>t[2]>>t[1]>>t[4]>>t[5]>>t[0];\n\t\t\tstring s;cin>>s;\n\t\t\tin[i].pb({t[5],{x,y}});\n\t\t\trep(j,s.size()){\n\t\t\t\tif(s[j]=='R')E(t),x++;\n\t\t\t\tif(s[j]=='L')E(t),E(t),E(t),x--;\n\t\t\t\tif(s[j]=='F')S(t),y--;\n\t\t\t\tif(s[j]=='B')S(t),S(t),S(t),y++;\n\t\t\t\trep(k,in[i].size())if(in[i][k].second==pii(x,y)){in[i][k].first=t[5];goto end;}\n\t\t\t\tin[i].pb({t[5],{x,y}});\n\t\t\t\tend:;\n\t\t\t}\n\t\t}\n\t\tint N=1<<n;\n\t\tvi dp(N,-inf);\n\t\tdp[0]=0;\n\t\trep(i,N){\n\t\t\tmap<pii,int>ma;\n\t\t\trep(j,n)if(i&1<<j)rep(k,in[j].size())ma[in[j][k].second]=1;\n\t\t\trep(j,n)if((i&1<<j)==0){\n\t\t\t\tint sum=0;\n\t\t\t\trep(k,in[j].size())if(ma.count(in[j][k].second)==0)\n\t\t\t\t\tsum+=in[j][k].first;\n\t\t\t\tcmax(dp[i|1<<j],dp[i]+sum);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[N-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct Dice {\n\tint tp;\n\tint bo;\n\tint no;\n\tint so;\n\tint ea;\n\tint we;\n\tDice(const int tp_, const int bo_, const int no_, const int so_, const int ea_, const int we_) :\n\t\ttp(tp_), bo(bo_), no(no_), so(so_), ea(ea_), we(we_) {\n\t}\n\tDice(vector<int>pips_) {\n\n\t}\n\tDice() {\n\t\ttp = 1;\n\t\t/*bo = 6;\n\t\tno = 2;\n\t\tso = 5;\n\t\tea = 3;\n\t\twe = 4;*/\n\t}\n\tenum R_Way {\n\t\tR_Left=0,\n\t\tR_Front=1,\n\t\tR_Right=2,\n\t\tR_Back=3,\n\n\t\tR_Dummy,\n\t};\n\tint rotate(const R_Way way) {\n\t\tswitch (way) {\n\t\tcase R_Right: {\n\t\t\tint c = tp;\n\t\t\ttp = we;\n\t\t\twe = bo;\n\t\t\tbo = ea;\n\t\t\tea = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tcase R_Back: {\n\t\t\tint c = tp;\n\t\t\ttp = so;\n\t\t\tso = bo;\n\t\t\tbo = no;\n\t\t\tno = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Left: {\n\t\t\tint c = tp;\n\t\t\ttp = ea;\n\t\t\tea = bo;\n\t\t\tbo = we;\n\t\t\twe = c;\n\t\t}\n\t\t\t\t\t break;\n\t\tcase R_Front: {\n\t\t\tint c = tp;\n\t\t\ttp = no;\n\t\t\tno = bo;\n\t\t\tbo = so;\n\t\t\tso = c;\n\t\t}\n\t\t\t\t\t  break;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t\treturn tp;\n\t}\n\tint rotate(const int way) {\n\t\treturn rotate(static_cast<R_Way>(way));\n\t}\n\tint hash()const {\n\t\treturn tp + we * 6 + no * 36;\n\t}\n};\nint geteast(int top, int south) {\n\tmap<pair<int, int>, int>mp;\n\tmp[make_pair(1, 2)] = 3;\n\tmp[make_pair(1, 3)] = 5;\n\tmp[make_pair(2, 3)] = 1;\n\tmp[make_pair(2, 4)] = 6;\n\tbool rev = false;\n\tif (top >= 4) {\n\t\trev = !rev; top = 7 - top;\n\t}\n\tif (south >= 4) {\n\t\trev = !rev; south = 7 - south;\n\t}\n\tif (top > south) {\n\t\trev = !rev; swap(top, south);\n\t}\n\treturn mp[make_pair(top, south)];\n}\n\nint gettop(int south, int east) {\n\treturn geteast(south, east);\n}\nint getsouth(int east, int top) {\n\treturn 7 - geteast(top, east);\n}\nbool operator==(const Dice&l, const Dice&r) {\n\treturn l.hash() == r.hash();\n}\n\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,-1,0,1 };\n\npair<int,map<pair<short, short>,short>>getmemo(const vector<map<pair<short, short>, short>>&field,vector<pair<int,map<pair<short, short>, short>>>&memo,bitset<15>&used) {\n\tif (memo[used.to_ulong()].second.empty()) {\n\t\tif (!used.count()) {\n\t\t\treturn make_pair(0,map < pair<short, short>, short> ());\n\t\t}\n\t\telse {\n\t\t\tint high_sc = -1;\n\t\t\tmap<pair<short, short>, short>hi_fi;\n\t\t\tfor (int i = 0; i < 15; ++i) {\n\t\t\t\tif (used[i]) {\n\t\t\t\t\tused[i] = false;\n\t\t\t\t\tauto pre(getmemo(field,memo, used));\n\t\t\t\t\t int sc = pre.first;\n\t\t\t\t\tauto pre_fi = pre.second;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tfor (auto n_c : field[i]) {\n\t\t\t\t\t\tif (pre_fi.find(n_c.first) == pre_fi.end()) {\n\t\t\t\t\t\t\tpre_fi[n_c.first] = n_c.second;\n\t\t\t\t\t\t\tsc += n_c.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (high_sc < sc) {\n\t\t\t\t\t\thigh_sc = sc;\n\t\t\t\t\t\thi_fi = pre_fi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[used.to_ulong()]=make_pair(high_sc, hi_fi);\n\t\t}\n\t}\n\telse {\n\t\treturn memo[used.to_ulong()];\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<map<pair<short, short>, short>>field(N, map<pair<short, short>, short>());\n\t\tmap<char, short>name;\n\t\tname['R'] = 2;\n\t\tname['L'] = 0;\n\t\tname['B'] = 3;\n\t\tname['F'] = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmap<pair<short, short>, short>mp;\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tint l, r, f, b, d, u; cin >> l >> r >> f >> b >> d >> u;\n\t\t\tstring rot; cin >> rot;\n\t\t\tmp[make_pair(x, y)] = d;\n\t\t\tDice di(u, d, b, f, r, l);\n\n\t\t\tfor (auto c : rot) {\n\t\t\t\tconst int way = name[c];\n\t\t\t\tx += dx[way];\n\t\t\t\ty += dy[way];\n\t\t\t\tdi.rotate(way);\n\t\t\t\tmp[make_pair(x, y)] = di.bo;\n\t\t\t}\n\t\t\tfield[i] = mp;\n\t\t}\n\t\tvector<pair<int,map<pair<short, short>, short>>>memo(1<<N);\n\t\tbitset<15>bs((1 << N) - 1);\n\t\tauto ans = getmemo(field, memo, bs);\n\t\tcout << ans.first << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> me;\n\nvector<int> rotate(char c, vector<int> a) {\n    if (c == 'R') {\n        return {a[4], a[5], a[2], a[3], a[1], a[0]};\n    }\n    if (c == 'F') {\n        return {a[0], a[1], a[5], a[4], a[2], a[3]};\n    }\n    if (c == 'L') {\n        return rotate('R', rotate('R', rotate('R', a)));\n    }\n    if (c == 'B') {\n        return rotate('F', rotate('F', rotate('F', a)));\n    }\n    exit(1);\n}\n\nint get_d() {\n    return me[4];\n}\n\nint n;\nvector<int> dp;\nvector<map<pair<int, int>, int>> mp;\nvector<set<pair<int, int>>> ss;\n\nint dfs(int a) {\n    if (dp[a] != -1) return dp[a];\n    int ret = 0;\n    for (int i = 0; i < n; i++) {\n        if (a >> i & 1) {\n            int acc = dfs(a ^ (1 << i));\n            for (auto &p : mp[i]) {\n                if (ss[a ^ (1 << i)].count(p.first) == 0) {\n                    acc += p.second;\n                }\n            }\n            ret = max(ret, acc);\n        }\n    }\n    return dp[a] = ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        mp = vector<map<pair<int, int>, int>>(n);\n        for (int i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            me.assign(6, 0);\n            for (int j = 0; j < 6; j++) cin >> me[j];\n            string s;\n            cin >> s;\n\n            mp[i][{x, y}] = get_d();\n            for (char c : s) {\n                me = rotate(c, me);\n                if (c == 'R') x++;\n                if (c == 'L') x--;\n                if (c == 'F') y--;\n                if (c == 'B') y++;\n                mp[i][{x, y}] = get_d();\n            }\n        }\n//        for (int i = 0; i < n; i++) {\n//            cerr << i << \"th\" << endl;\n//            for (auto &p : mp[i]) {\n//                cerr << \"(\" << p.first.first << \",\" << p.first.second << \"), \" << p.second << endl;\n//            }\n//        }\n        ss = vector<set<pair<int, int>>>(1 << n);\n        for (int i = 0; i < 1 << n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i >> j & 1) continue;\n                for (auto &p : mp[j]) {\n                    ss[i | (1 << j)].insert(p.first);\n                }\n            }\n        }\n        dp.assign(1 << n, -1);\n        dp[0] = 0;\n        int ans = 0;\n        for (int i = 0; i < 1 << n; i++) {\n            ans = max(ans, dfs(i));\n        }\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<unsigned short, unsigned short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<umap<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<unsigned short, umap<pii, char>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\n\n\nstruct Dice\n{\n\tint top, bottom, right, left, front, back;\n\tint x, y;\n\tstring s;\n\tDice() {};\n\tDice(int t, int bt, int r, int l, int f, int bk, int x, int y, string s) : top(t), bottom(bt), right(r), left(l), front(f), back(bk), x(x), y(y), s(s) { ; };\n\tvoid to_front() \n\t{\n\t\tint t = front;\n\t\tfront = top;\n\t\ttop = back;\n\t\tback = bottom;\n\t\tbottom = t;\n\t}\n\tvoid to_back() { REP(i, 3) to_front(); }\n\tvoid to_right() \n\t{\n\t\tint t = right;\n\t\tright = top;\n\t\ttop = left;\n\t\tleft = bottom;\n\t\tbottom = t;\n\t}\n\tvoid to_left() { REP(i, 3) to_right(); }\n};\n\nint n;\nvector<Dice> v;\nint vis[5000][5000];\nint dp[1 << 16];\n\nint solve(int bit)\n{\n\tif (bit == (1 << n) - 1) return 0;\n\tif (dp[bit] >= 0) return dp[bit];\n\tint res = 0;\n\tREP(i, n)\n\t{\n\t\tif ((bit >> i) & 1) continue;\n\t\tint nbit = bit | (1 << i);\n\t\tint sum = 0;\n\t\tint x = v[i].x, y = v[i].y;\n\t\tstring s = v[i].s;\n\t\tmap<pii, int> mp;\n\t\tif ((nbit | vis[x][y]) == nbit) mp[pii(x,y)] = v[i].bottom;\n\t\tfor (auto j : s)\n\t\t{\n\t\t\tif (j == 'L')\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tv[i].to_left();\n\t\t\t}\n\t\t\tif (j == 'R')\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tv[i].to_right();\n\t\t\t}\n\t\t\tif (j == 'F')\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tv[i].to_front();\n\t\t\t}\n\t\t\tif (j == 'B')\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tv[i].to_back();\n\t\t\t}\n\t\t\tif ((nbit | vis[x][y]) == nbit) mp[pii(x, y)] = v[i].bottom;\n\t\t}\n\t\tfor (auto k : mp) sum += k.second;\n\t\tchmax(res, solve(nbit) + sum);\n\t}\n\treturn dp[bit] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n, n)\n\t{\n\t\tMS(vis, 0);\n\t\tMS(dp, -1);\n\t\tv.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y, l, r, f, b, d, u;\n\t\t\tcin >> x >> y >> l >> r >> f >> b >> d >> u;\n\t\t\tx += 2000, y += 2000;\n\t\t\tstring s; cin >> s;\n\t\t\tv.emplace_back(u, d, r, l, f, b, x, y, s);\n\t\t}\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x = v[i].x, y = v[i].y;\n\t\t\tstring s = v[i].s;\n\t\t\tvis[x][y] |= 1 << i;\n\t\t\tfor(auto j : s)\n\t\t\t{\n\t\t\t\tif (j == 'L') x--;\n\t\t\t\tif (j == 'R') x++;\n\t\t\t\tif (j == 'F') y--;\n\t\t\t\tif (j == 'B') y++;\n\t\t\t\tvis[x][y] |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tcout << solve(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nint rots(map<pii,int> &table, int n, bool update=false){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\tmap<pii,int> tb;\n\ttb[pii(pos.X, pos.Y)] = dc.point();\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[pii(pos.X,pos.Y)] = dc.point();\n\t}\n\t// merge\n\tint sum = 0;\n\tfor(auto p: tb){\n\t\tif( table.count(p.X) == 0 ){\n\t\t\tif(update) table[p.X] = p.Y;\n\t\t\tsum += p.Y;\n\t\t}\n\t}\n\t//dc = dice_org[n];\n\t//pos = dice_pos[n];\n\t//if( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t//\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t//\tsum += tb[pii(pos.X,pos.Y)];\n\t//\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t//}\n\t//for(auto c: dice_rot[n]){\n\t//\trot( dc, pos, c );\n\t//\tif( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t//\t\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t//\t\tsum += tb[pii(pos.X,pos.Y)];\n\t//\t\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t//\t}\n\t//}\n\treturn sum;\n}\n\nmap<pii, int> tables[1<<20];\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\t//rep(k,N) if( (1<<k)&i ) rots(table, k, true);\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tauto table = tables[i];\n\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + rots(table, k, true) );\n\t\t\t\t\ttables[nx] = table;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttables[i].clear();\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nstruct DATA{\n  int x;\n  int y;\n  int num;\n};\n\nint mm[3000][3000] = {};\n\nvector<DATA> dice_vec(int sx, int sy,int *dice, char *rot){\n  int rotate[4][6] =\n    {{5,4,2,3,0,1}, //L\n     {4,5,2,3,1,0}, //R\n     {0,1,4,5,3,2}, //B\n     {0,1,5,4,2,3}};//F\n\n  vector<DATA> vec; \n\n  int u = 4;\n  \n  vec.push_back({sx,sy,dice[u]});\n  \n  for(int i=0;rot[i]!='\\0';i++){\n    int p = 0;\n    int new_dice[6];\n\n    if(rot[i] == 'L'){\n      p = 0;\n      sx--;\n    }\n    if(rot[i] == 'R'){\n      p = 1;\n      sx++;\n    }\n    if(rot[i] == 'B'){\n      p = 2;\n      sy++;\n    }\n    if(rot[i] == 'F'){\n      p = 3;\n      sy--;\n    }\n    \n    for(int j=0;j<6;j++){\n      new_dice[j] = dice[rotate[p][j]];\n    }\n    for(int j=0;j<6;j++)\n      dice[j] = new_dice[j];\n\n    vec.push_back({sx,sy,dice[u]});\n  }\n\n  return vec;\n}\n\nint dice[SIZE][6]; //lrfbdu\nchar rot[SIZE][50];\n\nvoid calc(int n){\n  int dp[1<<16] = {};\n  int sx[SIZE],sy[SIZE];\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",sx+i,sy+i);\n\n    for(int j=0;j<6;j++){\n      scanf(\"%d\",dice[i]+j);\n    }\n\n    scanf(\"%s\",rot[i]);\n  }\n\n  vector<DATA> vec[20];\n  \n  for(int i=0;i<n;i++){\n    vec[i] = dice_vec(sx[i],sy[i],dice[i], rot[i]);\n\n    set<pair<int,int> > ss;\n    for(int j=(int)vec[i].size()-1;j>=0;j--){\n      if(ss.find({vec[i][j].x,vec[i][j].y}) == ss.end()){\n        ss.insert({vec[i][j].x,vec[i][j].y});\n      }else{\n        vec[i][j].num = 0;\n      }\n      mm[vec[i][j].x+1500][vec[i][j].y+1500] = 0;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<vec[i].size();j++){\n      mm[vec[i][j].x+1500][vec[i][j].y+1500] |= 1<<i;\n    }\n  }\n  \n  for(int i=0;i<(1<<n);i++){\n\n    for(int j=0;j<n;j++){\n      if(i & (1<<j)) continue;\n\n      int next_bit = i | (1<<j);\n      int sum = dp[i];\n      //debug(sum);\n      \n      for(int k=0;k<vec[j].size();k++){\n        //cerr << vec[j][k].x << \" \" << vec[j][k].y << \" : \" << mm[vec[j][k].x+1500][vec[j][k].y+1500] << endl;\n        if((mm[vec[j][k].x+1500][vec[j][k].y+1500] | next_bit) == next_bit){\n          sum += vec[j][k].num;\n        }\n      }\n      //debug(sum);\n\n      dp[next_bit] = max(dp[next_bit],sum);\n    }\n  }\n\n  \n  printf(\"%d\\n\",dp[(1<<n)-1]);\n}\n\nint main(){\n  int n;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    calc(n);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct dice{\n  int a[6];\n};\nvoid rot(int &a,int &b,int &c,int &d){\n  int tmp=a; a=b; b=c; c=d; d=tmp;\n}\nvoid roll_f(dice &d){\n  rot(d.a[0],d.a[3],d.a[2],d.a[1]);\n}\nvoid roll_b(dice &d){\n  rot(d.a[0],d.a[1],d.a[2],d.a[3]);\n}\nvoid roll_l(dice &d){\n  rot(d.a[3],d.a[5],d.a[1],d.a[4]);\n}\nvoid roll_r(dice &d){\n  rot(d.a[3],d.a[4],d.a[1],d.a[5]);\n}\n\ntypedef pair<P,int> pi;\n\nint n;\nmap<P,int> nd[22];\nll dp[1<<16];\nmap<P,int> board[1<<16];\n\nint main(int argc, char const *argv[]){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,22)nd[i].clear();\n    rep(i,1<<16){\n      dp[i]=0;\n      board[i].clear();\n    }\n    rep(i,n){\n      dice d;\n      int sx,sy;\n      string s;\n      cin>>sx>>sy;\n      cin>>d.a[4]>>d.a[5]>>d.a[0]>>d.a[2]>>d.a[1]>>d.a[3];\n      cin>>s;\n      nd[i][P(sx,sy)]=d.a[1];\n      rep(j,s.length()){\n        if(s[j]=='F'){\n          roll_f(d);\n          sy--;\n        }\n        if(s[j]=='B'){\n          roll_b(d);\n          sy++;\n        }\n        if(s[j]=='R'){\n          roll_r(d);\n          sx++;\n        }\n        if(s[j]=='L'){\n          roll_l(d);\n          sx--;\n        }\n        nd[i][P(sx,sy)]=d.a[1];\n      }\n    }\n    rep(S,1<<n){\n      rep(i,n){\n        if((S&(1<<i))!=0)continue;\n        int ds=0;\n        for(auto it: nd[i]){\n          if(!board[S].count(it.fi))ds+=it.se;\n          else ds+=it.se-board[S][it.fi];\n        }\n        int T=S|(1<<i);\n        if(dp[T]<dp[S]+ds){\n          board[T]=board[S];\n          for(auto it : nd[i]){\n            board[T][it.fi]=it.se;\n          }\n          dp[T]=dp[S]+ds;\n        }\n      }\n    }\n    cout<<dp[(1<<n)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\n\nvector<int> t[15];\nstring u[15];\nint sx[15],sy[15];\nint dp[ (1<<15) ];\n\nvoid ry(vector<int> &v){\n  int tmp=v[2];\n  v[2]=v[4];\n  v[4]=v[3];\n  v[3]=v[5];\n  v[5]=tmp;\n}\n\nvoid rx(vector<int> &v){\n  int tmp=v[0];\n  v[0]=v[4];\n  v[4]=v[1];\n  v[1]=v[5];\n  v[5]=tmp;\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      t[i].clear();\n      t[i].resize(6);\n      cin>>sx[i]>>sy[i];\n      for(int j=0;j<6;j++)cin>>t[i][j];\n      cin>>u[i];\n    }\n    memset(dp,0,sizeof(dp));\n    for(int S=0;S<(1<<N);S++){\n      map<int,map<int,int> > w,mp;\n      \n      for(int i=0;i<N;i++){\n        if((S>>i&1)==0)continue;\n        int px=sx[i],py=sy[i];\n        mp[px][py]=1;\n        for(int j=0;j<(int)u[i].size();j++){\n          if(u[i][j]=='L')px--;\n          if(u[i][j]=='R')px++;\n          if(u[i][j]=='F')py--;\n          if(u[i][j]=='B')py++;\n          mp[px][py]=1;\n        }\n      }\n      \n      for(int i=0;i<N;i++){\n        if(S>>i&1)continue;\n        vector<int> v=t[i];\n        int px=sx[i],py=sy[i],cost=0;\n        w.clear();\n        if(!mp[px][py]){\n          cost-=w[px][py];\n          w[px][py]=v[4];\n          cost+=v[4];\n        }\n        \n        for(int j=0;j<(int)u[i].size();j++){\n          if(u[i][j]=='L'){\n            px--;\n            rx(v);rx(v);rx(v);\n          }\n          if(u[i][j]=='R'){\n            px++;\n            rx(v);\n          }\n          if(u[i][j]=='F'){\n            py--;\n            ry(v);ry(v);ry(v);\n          }\n          if(u[i][j]=='B'){\n            py++;\n            ry(v);\n          }\n\n          if(!mp[px][py]){\n            cost-=w[px][py];\n            w[px][py]=v[4];\n            cost+=v[4];\n          }\n        }\n        dp[S+(1<<i)]=max(dp[S+(1<<i)],dp[S]+cost);\n      }\n\n\n    }\n    cout<<dp[(1<<N)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<short, short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\ntemplate <class T>\n/*\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}*/\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<map<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<unsigned short, map<pii, char>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\n\nset<int> used[3000];\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    map<int,int> v[3000];\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v[d.y+1500].count(d.x)||!used[d.y+1500].count(d.x)){\n\t//cout<<tmp<<\" \"<<d.bottom()<<endl;\n\ttmp+=d.bottom();\n\tif(v[d.y+1500].count(d.x)) tmp-=v[d.y+1500][d.x];\n\tv[d.y+1500][d.x]=d.bottom();\n\tused[d.y+1500].insert(d.x);\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(int k=0;k<3000;k++)\n      for(auto j:v[k]) used[k].erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    for(int k=0;k<3000;k++) used[k].clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nint table[4000][4000];\nint tb[4000][4000];\nint rots(int n){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\tfill( tb[0], tb[0]+4000*4000, 0 );\n\ttb[pos.X][pos.Y] = dc.point();\n\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[pos.X][pos.Y] = dc.point();\n\t\t//cout << \"rots \" << pos.X << \" \" << pos.Y << \" \" << dc.point() << endl;\n\t}\n\t// merge\n\tint sum = 0;\n\tdc = dice_org[n];\n\tpos = dice_pos[n];\n\tif( table[pos.X][pos.Y] == 0 ){\n\t\ttable[pos.X][pos.Y] = tb[pos.X][pos.Y];\n\t\tsum += tb[pos.X][pos.Y];\n\t}\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\tif( table[pos.X][pos.Y] == 0 ){\n\t\t\ttable[pos.X][pos.Y] = tb[pos.X][pos.Y];\n\t\t\tsum += tb[pos.X][pos.Y];\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\t\t//rrep(i,N){\n\t\t//\tfill( table[0], table[0]+4000*4000, 0 );\n\t\t//\tcout << \"rots: \" << rots(i) << endl;\n\t\t//}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N) rep(k,N){\n\t\t\tint nx = (1<<k)|i;\n\t\t\tif( nx != i ){\n\t\t\t\tfill( table[0], table[0]+4000*4000, 0 );\n\t\t\t\trep(k,N) if( (1<<k)&i ) rots(k);\n\t\t\t\tdp[nx] = max( dp[nx], dp[i] + rots(k) );\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<functional>\n#include<string>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define REC(ret,...) std::function<ret (__VA_ARGS__)>\ntemplate<typename T>\nbool chmin(T& l, T r) {\n\tbool res = l > r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nbool chmax(T& l, T r) {\n\tbool res = l < r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T> &v) {\n\tfor (auto &it : v)is >> it;\n\treturn is;\n}\ntypedef vector<int> V;\nint f(int x, int y, int z) {\n\treturn x + y + z;\n}\nconst int dx[4] = { 0,0,-1,1 };\nconst int dy[4] = { 1,-1,0,0 };\n#define BBB 0\n#define FFF 1\n#define LLL 2\n#define RRR 3\nconst int hiro[4][6] = {\n\t{0,1,5,4,2,3},\n\t{0,1,4,5,3,2},\n\t{4,5,2,3,1,0},\n\t{5,4,2,3,0,1}\n};\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef pair<int, int> P;\nvoid rot_move(vector<int>& state, int r, int&x, int &y) {\n\tx += dx[r];\n\ty += dy[r];\n\tvector<int> nxt(6);\n\tREP(i, 6)nxt[hiro[r][i]] = state[i];\n\tREP(i, 6)state[i] = nxt[i];\n}\t\t\t\t\nmap<P, int> memo;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tV x(N), y(N);\n\t\tVV dice(N, V(6));\n\t\tvector<string> rot(N);\n\t\tREP(i, N) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tcin >> dice[i];\n\t\t\tcin >> rot[i];\n\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\tif (it == 'B')it = BBB;\n\t\t\t\tif (it == 'F')it = FFF;\n\t\t\t\tif (it == 'L')it = LLL;\n\t\t\t\tif (it == 'R')it = RRR;\n\t\t\t}\n\t\t}\n\t\tvector<set<P>> fut(1<<N);\n\t\tREP(bit, 1 << N) {\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tfut[bit].insert(P(xx, yy));\n\t\t\t\tauto v = dice[i];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tfut[bit].insert(P(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV dp(1 << N, -1);\t\n\t\tdp[0] = 0;\n\t\tREC(int, int) dfs = [&](int bit) {\n\t\t\tif (dp[bit] >= 0)return dp[bit];\n\t\t\tdp[bit] = 0;\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tauto v = dice[i];\n\t\t\t\tint nxtbit = bit - (1 << i);\n\t\t\t\tint cost = dfs(nxtbit);\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tmemo.clear();\n\t\t\t\tif (!fut[nxtbit].count(P(xx, yy)))memo[P(xx, yy)] = v[4];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tif (!fut[nxtbit].count(P(xx, yy))) {\n\t\t\t\t\t\tmemo[P(xx, yy)] = v[4];\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto &it : memo) {\n\t\t\t\t\tcost += it.second;\n\t\t\t\t} \n\t\t\t\tchmax(dp[bit], cost);\n\t\t\t}\n\t\t\treturn dp[bit];\n\t\t};\n\t\tcout << dfs((1 << N) - 1) << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstruct dice {\n\tint top;\n\tint bottom;\n\tint front;\n\tint back;\n\tint left;\n\tint right;\n};\n\nvoid rotate_front(dice* d) {\n\tint tmp = d->top;\n\td->top = d->back;\n\td->back = d->bottom;\n\td->bottom = d->front;\n\td->front = tmp;\n}\n\nvoid rotate_back(dice* d) {\n\tint tmp = d->top;\n\td->top = d->front;\n\td->front = d-> bottom;\n\td->bottom = d-> back;\n\td->back = tmp;\n}\n\nvoid rotate_right(dice* d) {\n\tint tmp = d->top;\n\td->top = d->left;\n\td->left = d->bottom;\n\td->bottom = d->right;\n\td->right = tmp;\n}\n\nvoid rotate_left(dice* d) {\n\tint tmp = d->top;\n\td->top = d->right;\n\td->right = d->bottom;\n\td->bottom = d->left;\n\td->left = tmp;\n}\n\nint n;\nvector<PP> vec[15];\n\nll dp[1<<15];\nset<P> data[1<<15];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tdice d;\n\t\t\tscanf(\"%d%d%d%d%d%d\",&d.left,&d.right,&d.front,&d.back,&d.bottom,&d.top);\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tmap<P,int> m;\n\t\t\tm[P(x,y)]=d.bottom;\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]=='R'){\n\t\t\t\t\trotate_right(&d);\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='L'){\n\t\t\t\t\trotate_left(&d);\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='F'){\n\t\t\t\t\trotate_front(&d);\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tif(str[j]=='B'){\n\t\t\t\t\trotate_back(&d);\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tm[P(x,y)]=d.bottom;\n\t\t\t}\n\t\t\tvec[i].clear();\n\t\t\tfor(map<P,int>::iterator it=m.begin();it!=m.end();it++){\n\t\t\t\tvec[i].push_back(PP(it->first,it->second));\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tdata[i].clear();\n\t\t}\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(!(i>>j & 1)){\n\t\t\t\t\tll val=dp[i];\n\t\t\t\t\tfor(int k=0;k<vec[j].size();k++){\n\t\t\t\t\t\tif(data[i].find(vec[j][k].first)==data[i].end()){\n\t\t\t\t\t\t\tdata[i|(1<<j)].insert(vec[j][k].first);\n\t\t\t\t\t\t\tval+=vec[j][k].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i|(1<<j)]=max(dp[i|(1<<j)],val);\n\t\t\t\t\tres=max(res,dp[i|(1<<j)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<functional>\n#include<string>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define REC(ret,...) std::function<ret (__VA_ARGS__)>\ntemplate<typename T>\nbool chmin(T& l, T r) {\n\tbool res = l > r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nbool chmax(T& l, T r) {\n\tbool res = l < r;\n\tif (res)l = r;\n\treturn res;\n}\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T> &v) {\n\tfor (auto &it : v)is >> it;\n\treturn is;\n}\ntypedef vector<int> V;\nint f(int x, int y, int z) {\n\treturn x + y + z;\n}\nconst int dx[4] = { 0,0,-1,1 };\nconst int dy[4] = { 1,-1,0,0 };\n#define BBB 0\n#define FFF 1\n#define LLL 2\n#define RRR 3\nconst int hiro[4][6] = {\n\t{0,1,5,4,2,3},\n\t{0,1,4,5,3,2},\n\t{4,5,2,3,1,0},\n\t{5,4,2,3,0,1}\n};\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef pair<int, int> P;\nvoid rot_move(vector<int>& state, int r, int&x, int &y) {\n\tx += dx[r];\n\ty += dy[r];\n\tvector<int> nxt(6);\n\tREP(i, 6)nxt[hiro[r][i]] = state[i];\n\tREP(i, 6)state[i] = nxt[i];\n}\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tV x(N), y(N);\n\t\tVV dice(N, V(6));\n\t\tvector<string> rot(N);\n\t\tREP(i, N) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tcin >> dice[i];\n\t\t\tcin >> rot[i];\n\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\tif (it == 'B')it = BBB;\n\t\t\t\tif (it == 'F')it = FFF;\n\t\t\t\tif (it == 'L')it = LLL;\n\t\t\t\tif (it == 'R')it = RRR;\n\n\t\t\t}\n\t\t}\n\t\tvector<set<P>> fut(1<<N);\n\t\tREP(bit, 1 << N) {\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tfut[bit].insert(P(xx, yy));\n\t\t\t\tauto v = dice[i];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tfut[bit].insert(P(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV dp(1 << N, -1);\t\n\t\tdp[0] = 0;\n\t\tREC(int, int) dfs = [&](int bit) {\n\t\t\tif (dp[bit] >= 0)return dp[bit];\n\t\t\tdp[bit] = 0;\n\t\t\tREP(i, N)if ((bit >> i) & 1) {\n\t\t\t\tauto v = dice[i];\n\t\t\t\tint nxtbit = bit - (1 << i);\n\t\t\t\tint cost = dfs(nxtbit);\n\t\t\t\tint xx = x[i];\n\t\t\t\tint yy = y[i];\n\t\t\t\tmap<P,int> memo;\n\t\t\t\tif (!fut[nxtbit].count(P(xx, yy)))memo[P(xx, yy)] = v[4];\n\t\t\t\tfor (auto &it : rot[i]) {\n\t\t\t\t\trot_move(v, it, xx, yy);\n\t\t\t\t\tif (!fut[nxtbit].count(P(xx, yy))) {\n\t\t\t\t\t\tmemo[P(xx, yy)] = v[4];\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto &it : memo) {\n\t\t\t\t\tcost += it.second;\n\t\t\t\t}\n\t\t\t\tchmax(dp[bit], cost);\n\t\t\t}\n\t\t\treturn dp[bit];\n\t\t};\n\t\tcout << dfs((1 << N) - 1) << endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nint rots(map<pii,int> &table, int n, bool update=false){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\tmap<pii,int> tb;\n\ttb[pii(pos.X, pos.Y)] = dc.point();\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[pii(pos.X,pos.Y)] = dc.point();\n\t}\n\t// merge\n\tint sum = 0;\n\tdc = dice_org[n];\n\tpos = dice_pos[n];\n\tif( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t\tsum += tb[pii(pos.X,pos.Y)];\n\t\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t}\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\tif( table.count(pii(pos.X,pos.Y)) == 0 && tb.count(pii(pos.X,pos.Y)) ){\n\t\t\tif(update) table[pii(pos.X,pos.Y)] = tb[pii(pos.X,pos.Y)];\n\t\t\tsum += tb[pii(pos.X,pos.Y)];\n\t\t\ttb.erase( tb.find(pii(pos.X,pos.Y)) );\n\t\t}\n\t}\n\treturn sum;\n}\n\nmap<pii, int> tables[1<<20];\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\t//rep(k,N) if( (1<<k)&i ) rots(table, k, true);\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tauto table = tables[i];\n\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + rots(table, k, true) );\n\t\t\t\t\ttables[nx] = table;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nshort p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nshort n, C[20][6], cx[20], cy[20]; string px[20];\nmap<pair<short, short>, short>D[20], E[1 << 16];\nvector<tuple<short, short, char>>_D[20];\nvector<pair<short, short>>_E[1 << 16];\nint dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 16];\nvoid Init1(int I) {\n\tvector<tuple<short, short, short, char>>__D;\n\t__D.push_back(make_tuple(cx[I], cy[I], -1, C[I][4]));\n\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\t__D.push_back(make_tuple(cx[I], cy[I], j, C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(__D.begin(), __D.end());\n\tfor (int i = 0; i < __D.size(); i++) {\n\t\tif (i == __D.size() - 1)_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\telse if (get<0>(__D[i]) != get<0>(__D[i + 1]) || get<1>(__D[i]) != get<1>(__D[i + 1])) {\n\t\t\t_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\t}\n\t}\n\treturn;\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0) { _E[p].push_back(pa); } E[p][pa] = 1;\n\t\t}\n\t}\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\tInit1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], dp[i] + cnt);\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = pair<int, int>;\nusing MAP_t = map<PR, int>;\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\nint merge(int idx1, int idx2, MAP_t& dest) {\n    dest = boards[idx1];\n    int res_v = scores[idx1];\n\n    for (const pair<PR, int>& itr : boards[idx2]) {\n        res_v += itr.second - dest[itr.first];\n        dest[itr.first] = itr.second;\n    }\n\n    return res_v;\n}\n\nMAP_t pool;\n\nint solve() {\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            int sc = merge(m, (1 << i), pool);\n            if (sc > scores[n]) {\n                boards[n] = pool;\n                scores[n] = sc;\n            }\n\n            sc = merge((1 << i), m, pool);\n            if (sc > scores[n]) {\n                boards[n] = pool;\n                scores[n] = sc;\n            }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores + (1 << N), 0);\n        for (int i = 0; i < (1 << N); ++i) boards[i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][make_pair(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                pair<int, int> key = make_pair(x, y);\n                sc += d.d - (boards[idx].find(key) != end(boards[idx]) ? boards[idx][key] : 0);\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\ntypedef long long ll;\n#define ARRAY 65536\n#define DBG 0\n#define SHIFT 10000\nusing namespace std;\n\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n};\n\nvector<int> paths[ARRAY];\nll cells[ARRAY];\n\nint main(void){\n  int n;\n  while(cin >> n){\n    rep(i,ARRAY){paths[i].clear();cells[i]=0;}\n    int x, y, v;\n    int ans = 0;\n\n    string r;\n    Dice dice;\n    vector<Stump> s[32];\n\n\n    rep(i,n){\n      cin >> x >> y;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      x+=1050;\n      y+=1050;\n      s[i].push_back(Stump(x, y, dice[5]));\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        s[i].push_back(Stump(x, y, dice[5]));\n      }\n    }\n\n    rep(i, 1<<n){\n      int state = i;\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          ll lp = 0;\n          map<int, int> mpl;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          rep(l, s[k].size()){\n            if(DBG)cout << \"(\" << s[k][l].x << \",\" << s[k][l].y << \")\";\n            for(int l = s[k].size()-1; l >= 0; --l){\n              if( mpl[s[k][l].x*SHIFT+ s[k][l].y] == 0){\n                mpl[s[k][l].x*SHIFT+s[k][l].y] = s[k][l].value;\n                lp += s[k][l].value;\n              }\n            }\n          }\n          rep(l, paths[state].size()){\n            for(int l = paths[state].size()-1; l >= 0; --l){\n              if(DBG)cout << \", \" << paths[state][l];\n              rep(m, s[paths[state][l]].size()){\n                if(DBG)cout << \"(\" << s[paths[state][l]][m].x << \",\" << s[paths[state][l]][m].y << \")\";\n                if(mpl[(s[paths[state][l]][m].x*SHIFT+ s[paths[state][l]][m].y)] == 0){\n                  mpl[(s[paths[state][l]][m].x*SHIFT+ s[paths[state][l]][m].y)] = s[paths[state][l]][m].value;\n                  lp += s[paths[state][l]][m].value;\n                }\n              }\n            }\n          }\n          if(DBG)cout << \" res = \" << lp << endl;\n          if(cells[state|mask] < lp){\n            cells[state|mask] = lp;\n            paths[state|mask] = paths[state];\n            paths[state|mask].push_back(k);\n          }\n        }\n      }\n    }\n    cout << cells[(1<<n)-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nmap<pii,int> tb[20];\nvoid rots(int n){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\ttb[n][pii(pos.X, pos.Y)] = dc.point();\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[n][pii(pos.X,pos.Y)] = dc.point();\n\t}\n}\n\nint solve(map<pii,int> &table, int n, bool update=false){\n\t// merge\n\tint sum = 0;\n\tfor(auto p: tb[n]) if( table.count(p.X) == 0 ){\n\t\tif(update) table[p.X] = p.Y;\n\t\tsum += p.Y;\n\t}\n\treturn sum;\n}\n\nmap<pii, int> tables[1<<20];\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\n\t\trep(i,N){\n\t\t\ttb[i].clear();\n\t\t\trots(i);\n\t\t}\n\t\trep(i,1<<20) tables[i].clear();\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\tauto table = tables[i];\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tif( tables[nx].empty() ){\n\t\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + solve(table, k, true) );\n\t\t\t\t\t\ttables[nx] = table;\n\t\t\t\t\t\ttable = tables[i];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + solve(table, k) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttables[i].clear();\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nshort p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nshort n, C[20][6], cx[20], cy[20]; string px[20];\nmap<pair<short, short>, short>D[20], E[1 << 16];\nvector<tuple<short, short, short>>_D[20];\nvector<pair<short, short>>_E[1 << 15];\nint dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 15];\nvoid Init1(int I) {\n\tvector<tuple<short, short, short, short>>__D;\n\t__D.push_back(make_tuple(cx[I], cy[I], -1, C[I][4]));\n\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\t__D.push_back(make_tuple(cx[I], cy[I], j, C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(__D.begin(), __D.end());\n\tfor (int i = 0; i < __D.size(); i++) {\n\t\tif (i == __D.size() - 1)_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\telse if (get<0>(__D[i]) != get<0>(__D[i + 1]) || get<1>(__D[i]) != get<1>(__D[i + 1])) {\n\t\t\t_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\t}\n\t}\n\treturn;\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0) { _E[p].push_back(pa); } E[p][pa] = 1;\n\t\t}\n\t}\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\tInit1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], dp[i] + cnt);\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pb push_back\n\ntypedef struct {\n  int l, r, f, b, d, u;\n} dice;\n\ndice rotL(dice d)\n{\n  dice n = d;\n  n.l = d.u;\n  n.u = d.r;\n  n.r = d.d;\n  n.d = d.l;\n  return n;\n}\n\ndice rotR(dice d)\n{\n  dice n = d;\n  n.u = d.l;\n  n.r = d.u;\n  n.d = d.r;\n  n.l = d.d;\n  return n;\n}\n\ndice rotF(dice d)\n{\n  dice n = d;\n  n.f = d.u;\n  n.u = d.b;\n  n.b = d.d;\n  n.d = d.f;\n  return n;\n}\n\ndice rotB(dice d)\n{\n  dice n = d;\n  n.b = d.u;\n  n.u = d.f;\n  n.f = d.d;\n  n.d = d.b;\n  return n;\n}\n\ntypedef struct {\n  int x, y;\n  int num;\n} masu;\n\nmap<pair<int, int>, int> Max(map<pair<int, int>, int> a, map<pair<int, int>, int> b)\n{\n  int suma = 0, sumb = 0;\n  for (auto it = a.begin(); it != a.end(); it++) suma += it->second;\n  for (auto it = b.begin(); it != b.end(); it++) sumb += it->second;\n  if (suma > sumb) return a;\n  return b;\n}\n\nmap<pair<int, int>, int> stamp(map<pair<int, int>, int> p, vec<masu> s)\n{\n  rep(i, s.size()) {\n    if (p[make_pair(s[i].x, s[i].y)]) continue;\n    p[make_pair(s[i].x, s[i].y)] = s[i].num;\n  }\n  return p;\n}\n\nint main(void)\n{\n  while(1) {\n    int n;\n    cin >> n;\n    if (!n) break;\n    \n    vec<vec<masu> > stamps(n);\n    rep(t, n) {\n      int x, y;\n      cin >> x >> y;\n      dice d;\n      cin >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n      string rot;\n      cin >> rot;\n      map<pair<int, int>, int> dp;\n\n      masu s;\n      s.x = x; s.y = y; s.num = d.d;\n      stamps[t].pb(s);\n      dp[make_pair(x, y)] = 0;\n      rep(i, rot.length()) {\n        if (rot[i] == 'L') {\n          x--;\n          d = rotL(d);\n        } else if (rot[i] == 'R') {\n          x++;\n          d = rotR(d);\n        } else if (rot[i] == 'F') {\n          y--;\n          d = rotF(d);\n        } else {\n          y++;\n          d = rotB(d);\n        }\n        s.x = x; s.y = y; s.num = d.d;\n        if (dp.find(make_pair(x, y)) == dp.end()) {\n          stamps[t].pb(s);\n          dp[make_pair(x, y)] = stamps[t].size() - 1;\n        } else {\n          stamps[t][dp[make_pair(x, y)]] = s;\n        }\n      }\n    }\n\n    vec<map<pair<int, int>, int> > dp(1 << n);\n    rep(i, (1 << n)) {\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        dp[i + (1 << j)] = Max(dp[i + (1 << j)], stamp(dp[i], stamps[j]));\n      }\n    }\n    int sum = 0;\n    for (auto it = dp[(1 << n) - 1].begin(); it != dp[(1 << n) - 1].end(); it++) sum += it->second;\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct Die{\n  int s[6];\n  int &top()   {return s[0];}\n  int &south() {return s[1];}\n  int &east()  {return s[2];}\n  int &west()  {return s[3];}\n  int &north() {return s[4];}\n  int &bottom(){return s[5];}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    string b(\"EWNSRL\");\n    int v[6][4]={{0,3,5,2},\n                 {0,2,5,3},\n                 {0,1,5,4},\n                 {0,4,5,1},\n                 {1,2,4,3},\n                 {1,3,4,2}};\n    for(int k=0;k<6;k++){\n      if(b[k]!=c) continue;\n      int t=s[v[k][0]];\n      s[v[k][0]]=s[v[k][1]];\n      s[v[k][1]]=s[v[k][2]];\n      s[v[k][2]]=s[v[k][3]];\n      s[v[k][3]]=t;\n    }\n  }\n  using ll = long long;\n  ll hash(){\n    ll res=0;\n    for(int i=0;i<6;i++) res=res*256+s[i];\n    return res;\n  }\n  bool operator==(const Die &d) const{\n    for(int i=0;i<6;i++) if(s[i]!=d.s[i]) return 0;\n    return 1;\n  }\n};\n\nvector<Die> makeDice(Die d){\n  vector<Die> res;\n  for(int i=0;i<6;i++){\n    Die t(d);\n    if(i==1) t.roll('N');\n    if(i==2) t.roll('S');\n    if(i==3) t.roll('S'),t.roll('S');\n    if(i==4) t.roll('L');\n    if(i==5) t.roll('R');\n    for(int k=0;k<4;k++){\n      res.push_back(t);\n      t.roll('E');\n    }\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<int> xs(n),ys(n);\n    vector<Die> ds(n);\n    vector<string> rs(n);\n\n    for(int i=0;i<n;i++){\n      cin>>xs[i]>>ys[i];\n      cin>>ds[i].west();\n      cin>>ds[i].east();\n      cin>>ds[i].south();\n      cin>>ds[i].north();\n      cin>>ds[i].bottom();\n      cin>>ds[i].top();\n      cin>>rs[i];\n    }\n\n    using P = pair<int, int>;\n    vector< set<P> > sp(n);\n    vector< map<P, int> > mp(n);\n    for(int i=0;i<n;i++){\n      int x=xs[i],y=ys[i];\n      Die d=ds[i];\n      sp[i].emplace(x,y);\n      mp[i][P(x,y)]=d.bottom();\n      for(char c:rs[i]){\n        if(c=='L') x--,d.roll('W');\n        if(c=='R') x++,d.roll('E');\n        if(c=='F') y--,d.roll('S');\n        if(c=='B') y++,d.roll('N');\n        sp[i].emplace(x,y);\n        mp[i][P(x,y)]=d.bottom();\n      }\n    }\n\n    int sz=1<<n;\n    const int INF = 1e9;\n    vector<int> dp(sz,-INF);\n    vector<set<P>> us(sz);\n    dp[0]=0;\n\n    for(int bit=0;bit<sz;bit++){\n      set<P> &used=us[bit];\n      for(int i=0;i<n;i++){\n        if((~bit>>i)&1) continue;\n        int old=bit^(1<<i);\n        used=us[old];\n        for(auto p:sp[i])\n          used.emplace(p);\n        break;\n      }\n\n      for(int i=0;i<n;i++){\n        if((bit>>i)&1) continue;\n        int nbit=bit|(1<<i);\n        int res=0;\n        for(auto p:sp[i])\n          if(!used.count(p))\n            res+=mp[i][p];\n        chmax(dp[nbit],dp[bit]+res);\n      }\n    }\n    cout<<dp[sz-1]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nshort p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nshort n, C[20][6], cx[20], cy[20]; string px[20];\nmap<pair<short, short>, short>D[20], E[1 << 16];\nvector<tuple<short, short, short>>_D[20];\nvector<pair<short, short>>_E[1 << 15];\nshort dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 15];\nvoid Init1(int I) {\n\tvector<tuple<short, short, short, short>>__D;\n\t__D.push_back(make_tuple(cx[I], cy[I], -1, C[I][4]));\n\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\t__D.push_back(make_tuple(cx[I], cy[I], j, C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(__D.begin(), __D.end());\n\tfor (int i = 0; i < __D.size(); i++) {\n\t\tif (i == __D.size() - 1)_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\telse if (get<0>(__D[i]) != get<0>(__D[i + 1]) || get<1>(__D[i]) != get<1>(__D[i + 1])) {\n\t\t\t_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\t}\n\t}\n\treturn;\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0) { _E[p].push_back(pa); } E[p][pa] = 1;\n\t\t}\n\t}\n\tE[p].clear();\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\tInit1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tshort cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], (short)(dp[i] + cnt));\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \nvector<map<P,int>> m(15);\nint c[4][6]={\n    {3,0,1,2,4,5},\n    {1,2,3,0,4,5},\n    {4,1,5,3,2,0},\n    {5,1,4,3,0,2}\n};\n\nvoid rec(int k,int i,int y,int x,string s,vector<int> v){\n    m[i][{y,x}]=v[0];\n    if(s.length()==k) return;\n    vector<int> t(6);\n    if(s[k]=='L'){\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[0][j]];\n        }\n        rec(k+1,i,y,x-1,s,t);\n    }\n    else if(s[k]=='R'){\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[1][j]];\n        }\n        rec(k+1,i,y,x+1,s,t);\n    }\n    else if(s[k]=='F'){\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[2][j]];\n        }\n        rec(k+1,i,y-1,x,s,t);\n    }\n    else{\n        for (int j = 0; j < 6; j++) {\n            t[j]=v[c[3][j]];\n        }\n        rec(k+1,i,y+1,x,s,t);\n    }\n}\n\n\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        m.clear();\n        m.resize(16);\n        for (int i = 0; i < n; i++) {\n            int x,y;cin >> x >> y;\n            vector<int> u(6);\n            cin >> u[3] >> u[1] >> u[4] >> u[5] >> u[0] >> u[2];\n            string ss;cin >> ss;\n            rec(0,i,y,x,ss,u);\n        }\n        vector<int> dp((1<<n)+1,-INF);\n        dp[0]=0;\n        int ans=-INF;\n        for (int bit = 0; bit < 1<<n; bit++) {\n            ans=max(ans,dp[bit]);\n            for (int i = 0; i < n; i++) {\n                if(bit&(1<<i)) continue;\n                int sum = 0;\n                for (auto p:m[i]) {\n                    P t=p.first;\n                    bool f=true;\n                    for (int j = 0; j < n; j++) {\n                        if(bit&(1<<j)){\n                            if(m[j].find(t)!=m[j].end()){\n                                f=false;\n                                break;\n                            }\n                        }\n                    }\n                    if(f) sum+= p.second;\n                }\n                int nx = bit|(1<<i);\n                dp[nx]=max(dp[nx],dp[bit]+sum);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nshort p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nshort n, C[20][6], cx[20], cy[20]; string px[20];\nmap<pair<short, short>, short>D[20], E[1 << 16];\nvector<tuple<short, short, short>>_D[20];\nvector<pair<short, short>>_E[1 << 16];\nint dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 16];\nvoid Init1(int I) {\n\tvector<tuple<short, short, short, short>>__D;\n\t__D.push_back(make_tuple(cx[I], cy[I], -1, C[I][4]));\n\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\t__D.push_back(make_tuple(cx[I], cy[I], j, C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(__D.begin(), __D.end());\n\tfor (int i = 0; i < __D.size(); i++) {\n\t\tif (i == __D.size() - 1)_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\telse if (get<0>(__D[i]) != get<0>(__D[i + 1]) || get<1>(__D[i]) != get<1>(__D[i + 1])) {\n\t\t\t_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\t}\n\t}\n\treturn;\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0) { _E[p].push_back(pa); } E[p][pa] = 1;\n\t\t}\n\t}\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\tInit1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], dp[i] + cnt);\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define UP    0\n#define DOWN  1\n#define FORE  2\n#define BACK  3\n#define RIGHT 4\n#define LEFT  5\n\nstruct Dice\n{\n  int face[6];\n  Dice(){}\n  Dice(int up, int down, int fore, int back, int right, int left)\n  {\n    face[UP] = up; face[DOWN] = down;\n    face[FORE]  = fore; face[BACK] = back;\n    face[RIGHT] = right; face[LEFT] = left;\n  }\n  void roll(int a, int b, int c, int d) {\n    swap(face[a], face[c]);\n    swap(face[b], face[d]);\n    swap(face[c], face[d]);\n  }\n  void roll2fore() { roll(FORE, BACK, UP, DOWN); }\n  void roll2back() { roll(BACK, FORE, UP, DOWN); }  \n  void roll2right() { roll(RIGHT, LEFT, UP, DOWN); }\n  void roll2left() { roll(LEFT, RIGHT, UP, DOWN); }\n  void rotate_clockwise() { roll(FORE, BACK, RIGHT, LEFT); }\n  void rotate_counterclockwise() { roll(FORE, BACK, LEFT, RIGHT); }\n  void print_face()\n  {\n    printf(\"UP   : %d\\n\", face[UP]);\n    printf(\"DOWN : %d\\n\", face[DOWN]);\n    printf(\"FORE : %d\\n\", face[FORE]);\n    printf(\"BACK : %d\\n\", face[BACK]);\n    printf(\"RIGHT: %d\\n\", face[RIGHT]);\n    printf(\"LEFT : %d\\n\", face[LEFT]);\n  }\n};\n\nint N;\nvector<int> x, y;\nvector<Dice> dice;\nvector<string> rot;\n\nint dp[1<<16];\nmap<P, bool> used;\n\nstring dir = \"LRFB\";\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint solve(int bit)\n{\n  if(bit == (1<<N)-1) return 0;\n  int& ret = dp[bit];\n  if(~ret) return ret;\n\n  ret = 0;\n  for(int i = 0; i < N; i++) {\n    if((bit >> i) & 1) continue;\n    map<P, int> me;    \n    Dice die = dice[i];\n    int nx = x[i], ny = y[i];\n    int sum = die.face[DOWN];    \n    used[P(ny, nx)] = true;\n    me[P(ny, nx)] = die.face[DOWN];\n    for(int j = 0; j < rot[i].size(); j++) {\n      int d = dir.find(rot[i][j]);\n      nx += dx[d], ny += dy[d];\n      switch(rot[i][j]) {\n      case 'L': die.roll2left(); break;\n      case 'R': die.roll2right(); break;\n      case 'F': die.roll2fore(); break;\n      case 'B': die.roll2back(); break;\n      }\n      if(used[P(ny, nx)] && me.count(P(ny, nx)) == 0) continue;\n      sum += die.face[DOWN] - me[P(ny, nx)];\n      me[P(ny, nx)] = die.face[DOWN] - me[P(ny, nx)];\n      used[P(ny, nx)] = true;\n    }\n    ret = max(ret, solve(bit | (1 << i)) + sum);\n    die = dice[i];\n    nx = x[i], ny = y[i];\n    used[P(ny, nx)] = false;\n    for(int j = 0; j < rot[i].size(); j++) {\n      int d = dir.find(rot[i][j]);\n      nx += dx[d], ny += dy[d];\n      switch(rot[i][j]) {\n      case 'L': die.roll2left(); break;\n      case 'R': die.roll2right(); break;\n      case 'F': die.roll2fore(); break;\n      case 'B': die.roll2back(); break;\n      }\n      if(used[P(ny, nx)] && me.count(P(ny, nx)) == 0) continue;\n      used[P(ny, nx)] = false;\n    }\n  }\n  \n  return ret;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    x.clear(); x.resize(N);\n    y.clear(); y.resize(N);\n    dice.clear(); dice.resize(N);\n    rot.clear(); rot.resize(N);\n    for(int i = 0; i < N; i++) {\n      cin >> x[i] >> y[i];\n      int l, r, f, b, d, u;\n      cin >> l >> r >> f >> b >> d >> u;\n      dice[i] = Dice(u, d, f, b, r, l);\n      cin >> rot[i];\n    }\n    used.clear();\n    memset(dp, -1, sizeof(dp));\n    cout << solve(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\n\nset<int> used[3000];\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    map<int,int> v[3000];\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v[d.y+1500].count(d.x)||!used[d.y+1500].count(d.x)){\n\t//cout<<tmp<<\" \"<<d.bottom()<<endl;\n\ttmp+=d.bottom();\n\tif(v[d.y+1500].count(d.x)) tmp-=v[d.y+1500][d.x];\n\tv[d.y+1500][d.x]=d.bottom();\n\tused[d.y+1500].insert(d.x);\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(int k=0;k<3000;k++)\n      for(auto j:v[k]) used[k].erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    for(int k=0;k<3000;k++) used[k].clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 15\ntypedef pair<int, int> pii;\n\nclass Dice {\n  private:\n    void roll(int a, int b, int c, int d)\n    {\n        swap(v[a], v[b]);\n        swap(v[b], v[d]);\n        swap(v[c], v[d]);\n    }\n    \n  public:\n    int v[6], x, y;\n    string order;\n    void roll_B() { roll(0, 1, 4, 5); }\n    void roll_R() { roll(0, 3, 2, 5); }\n    void roll_F() { roll(0, 4, 1, 5); }\n    void roll_L() { roll(0, 2, 3, 5); }\n};\n\nvoid rot(set<pii> &a, Dice &d)\n{\n    a.insert(pii(d.y, d.x));\n    for (auto &c: d.order) {\n        if (c == 'L') {\n            c = 'R';\n            d.roll_L();\n            d.x--;\n        } else if (c == 'F') {\n            c = 'B';\n            d.roll_F();\n            d.y--;\n        } else if (c == 'R') {\n            c = 'L';\n            d.roll_R();\n            d.x++;\n        } else {\n            c = 'F';\n            d.roll_B();\n            d.y++;\n        }\n        a.insert(pii(d.y, d.x));\n    }\n    reverse(d.order.begin(), d.order.end());\n}\n\nvoid merge(set<pii> &a, set<pii> &b)\n{\n    for (auto p: b) {\n        a.insert(p);\n    }\n}\n\nint get_cost(set<pii> decided, Dice d)\n{\n    int res = 0;    \n    if (decided.count(pii(d.y, d.x)) == 0) {\n        decided.insert(pii(d.y, d.x));\n        res += d.v[5];\n    }\n        \n    for (auto c: d.order) {\n        if (c == 'L') {\n            d.x--;\n            d.roll_L();\n        } else if (c == 'F') {\n            d.y--;\n            d.roll_F();\n        } else if (c == 'R') {\n            d.x++;\n            d.roll_R();\n        } else {\n            d.y++;\n            d.roll_B();\n        }\n        if (decided.count(pii(d.y, d.x)) == 0) {\n            decided.insert(pii(d.y, d.x));\n            res += d.v[5];\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        vector<Dice> d(N);\n        for (int i = 0; i < N; i++) {\n            cin >> d[i].x >> d[i].y;\n            cin >> d[i].v[3] >> d[i].v[2] >> d[i].v[1];\n            cin >> d[i].v[4] >> d[i].v[5] >> d[i].v[0];\n            cin >> d[i].order;\n        }\n\n        set<pii> a[MAX_N], decided[1<<MAX_N];\n        for (int i = 0; i < N; i++) {\n            rot(a[i], d[i]);\n        }        \n        \n        int dp[1<<MAX_N];\n        memset(dp, -1, sizeof(dp));\n\n        for (int i = 0; i < (1<<N); i++) {\n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) {\n                    merge(decided[i], a[j]);\n                }\n            }\n        }\n\n        \n        dp[0] = 0;\n        for (int i = 0; i < (1<<N); i++) {\n            if (dp[i] == -1) continue;                  \n            for (int j = 0; j < N; j++) {\n                if (i >> j & 1) continue;\n                int ni = i | (1<<j);                \n                dp[ni] = max(dp[ni], dp[i] + get_cost(decided[i], d[j]));\n            }\n        }\n        cout << dp[(1<<N)-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nshort p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nshort n, C[20][6], cx[20], cy[20]; string px[20];\nmap<pair<short, short>, short>D[20], E[1 << 16];\nvector<tuple<short, short, short>>_D[20];\nvector<pair<short, short>>_E[1 << 15];\nshort dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 15];\nvoid Init1(int I) {\n\tvector<tuple<short, short, short, short>>__D;\n\t__D.push_back(make_tuple(cx[I], cy[I], -1, C[I][4]));\n\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\t__D.push_back(make_tuple(cx[I], cy[I], j, C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(__D.begin(), __D.end());\n\tfor (int i = 0; i < __D.size(); i++) {\n\t\tif (i == __D.size() - 1)_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\telse if (get<0>(__D[i]) != get<0>(__D[i + 1]) || get<1>(__D[i]) != get<1>(__D[i + 1])) {\n\t\t\t_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\t}\n\t}\n\treturn;\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0) { _E[p].push_back(pa); } E[p][pa] = 1;\n\t\t}\n\t}\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\tInit1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tshort cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], (short)(dp[i] + cnt));\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define UP    0\n#define DOWN  1\n#define FORE  2\n#define BACK  3\n#define RIGHT 4\n#define LEFT  5\n\nstruct Dice\n{\n  int face[6];\n  Dice(){}\n  Dice(int up, int down, int fore, int back, int right, int left)\n  {\n    face[UP] = up; face[DOWN] = down;\n    face[FORE]  = fore; face[BACK] = back;\n    face[RIGHT] = right; face[LEFT] = left;\n  }\n  void roll(int a, int b, int c, int d) {\n    swap(face[a], face[c]);\n    swap(face[b], face[d]);\n    swap(face[c], face[d]);\n  }\n  void roll2fore() { roll(FORE, BACK, UP, DOWN); }\n  void roll2back() { roll(BACK, FORE, UP, DOWN); }  \n  void roll2right() { roll(RIGHT, LEFT, UP, DOWN); }\n  void roll2left() { roll(LEFT, RIGHT, UP, DOWN); }\n  void rotate_clockwise() { roll(FORE, BACK, RIGHT, LEFT); }\n  void rotate_counterclockwise() { roll(FORE, BACK, LEFT, RIGHT); }\n  void print_face()\n  {\n    printf(\"UP   : %d\\n\", face[UP]);\n    printf(\"DOWN : %d\\n\", face[DOWN]);\n    printf(\"FORE : %d\\n\", face[FORE]);\n    printf(\"BACK : %d\\n\", face[BACK]);\n    printf(\"RIGHT: %d\\n\", face[RIGHT]);\n    printf(\"LEFT : %d\\n\", face[LEFT]);\n  }\n};\n\nint N;\nvector<int> x, y;\nvector<Dice> dice;\nvector<string> rot;\n\nint dp[1<<16];\nmap<P, int> used;\n\nstring dir = \"LRFB\";\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint solve(int bit)\n{\n  if(bit == (1<<N)-1) return 0;\n  int& ret = dp[bit];\n  if(~ret) return ret;\n\n  ret = 0;\n  for(int i = 0; i < N; i++) {\n    if((bit >> i) & 1) continue;\n    used.clear();\n    for(int j = 0; j < N; j++) {\n      if((bit >> j) & 1) {\n\tint nx = x[j], ny = y[j];\n\tused[P(ny, nx)] = -1;\n\tfor(int k = 0; k < rot[j].size(); k++) {\n\t  int d = dir.find(rot[j][k]);\n\t  nx += dx[d], ny += dy[d];\n\t  used[P(ny, nx)] = -1;\n\t}\n      }\n    }\n    Dice die = dice[i];\n    int nx = x[i], ny = y[i];\n    int sum = die.face[DOWN];    \n    used[P(ny, nx)] = die.face[DOWN];\n    for(int j = 0; j < rot[i].size(); j++) {\n      int d = dir.find(rot[i][j]);\n      nx += dx[d], ny += dy[d];\n      switch(rot[i][j]) {\n      case 'L': die.roll2left(); break;\n      case 'R': die.roll2right(); break;\n      case 'F': die.roll2fore(); break;\n      case 'B': die.roll2back(); break;\n      }\n      if(used[P(ny, nx)] == -1) continue;\n      sum += die.face[DOWN] - used[P(ny, nx)];      \n      used[P(ny, nx)] = die.face[DOWN] - used[P(ny, nx)];\n    }\n    ret = max(ret, solve(bit | (1 << i)) + sum);\n  }\n  \n  return ret;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    x.clear(); x.resize(N);\n    y.clear(); y.resize(N);\n    dice.clear(); dice.resize(N);\n    rot.clear(); rot.resize(N);\n    for(int i = 0; i < N; i++) {\n      cin >> x[i] >> y[i];\n      int l, r, f, b, d, u;\n      cin >> l >> r >> f >> b >> d >> u;\n      dice[i] = Dice(u, d, f, b, r, l);\n      cin >> rot[i];\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << solve(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = int;\nusing MAP_t = map<PR, int>;\n\nint encode(int x, int y) { return 3000 * x + y; }\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\nint merge(int idx1, int idx2, MAP_t& dest) {\n    dest = boards[idx1];\n    int res_v = scores[idx1];\n\n    for (const pair<PR, int>& itr : boards[idx2]) {\n        res_v += itr.second - dest[itr.first];\n        dest[itr.first] = itr.second;\n    }\n\n    return res_v;\n}\n\nint solve() {\n    MAP_t trg;\n\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            int sc = merge(m, (1 << i), trg);\n            if (sc > scores[n]) {\n                boards[n] = trg;\n                scores[n] = sc;\n            }\n\n            sc = merge((1 << i), m, trg);\n            if (sc > scores[n]) {\n                boards[n] = trg;\n                scores[n] = sc;\n            }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores + (1 << N), 0);\n        for (int i = 0; i < (1 << N); ++i) boards[i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            x += 1000; y += 1000;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][encode(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                PR key = encode(x, y);\n                sc += d.d - (boards[idx].find(key) != end(boards[idx]) ? boards[idx][key] : 0);\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nclass Dice{\npublic:\n\n\tvoid roll(char dst){\n\t\tfor(int i = 0; i < 6; i++) work[i] = number[i];\n\t\tswitch(dst){\n\t\tcase 'R':\n\t\t\tsetNumber(work[3],work[1],work[0],work[5],work[4],work[2]);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tsetNumber(work[1],work[5],work[2],work[3],work[0],work[4]);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tsetNumber(work[4],work[0],work[2],work[3],work[5],work[1]);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tsetNumber(work[2],work[1],work[5],work[0],work[4],work[3]);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tchar getTop(){\n\t\treturn number[0];\n\t}\n\n\tchar getEast(){\n\t\treturn number[2];\n\t}\n\n\tchar getNorth(){\n\t\treturn number[1];\n\t}\n\n\tchar getWest(){\n\t\treturn number[3];\n\t}\n\n\tchar getBottom(){\n\t\treturn number[5];\n\t}\n\n\tchar getSouth(){\n\t\treturn number[4];\n\t}\n\n\tvoid setNumber(int w0,int w1,int w2,int w3,int w4,int w5){\n\t\tnumber[0] = w0;\n\t\tnumber[1] = w1;\n\t\tnumber[2] = w2;\n\t\tnumber[3] = w3;\n\t\tnumber[4] = w4;\n\t\tnumber[5] = w5;\n\t}\n\n\tvoid setFirst(int left,int right,int front,int back,int down,int up){\n\t\tnumber[0] = up;\n\t\tnumber[1] = back;\n\t\tnumber[2] = right;\n\t\tnumber[3] = left;\n\t\tnumber[4] = front;\n\t\tnumber[5] = down;\n\t}\n\n\tint number[6];\n\tint work[6];\n};\n\nstruct Info{\n\tint x,y,value,all_index;\n};\n\nstruct Data{\n\tInfo loc;\n\tint state;\n};\n\nint N;\nint POW[17];\nint dice_index[15]; //サイコロが転がるマスの数\nint table_index;\nint dp[32768];\nInfo info[15][32];\nchar buf[31];\nData table[500]; //サイコロが転がり得るマスの集計表\n\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++)dice_index[i] = 0;\n\n\tint current_x,current_y;\n\tint left,right,front,back,down,up;\n\n\tDice dice;\n\tbool FLG;\n\n\t//サイコロの情報を取得\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&current_x,&current_y);\n\n\t\tscanf(\"%d %d %d %d %d %d\",&left,&right,&front,&back,&down,&up);\n\t\tdice.setFirst(left,right,front,back,down,up);\n\n\t\tinfo[i][dice_index[i]].x = current_x;\n\t\tinfo[i][dice_index[i]].y = current_y;\n\t\tinfo[i][dice_index[i]].value = dice.getBottom();\n\n\t\tdice_index[i]++;\n\n\t\tscanf(\"%s\",buf);\n\n\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\n\t\t\tdice.roll(buf[k]); //ダイスを転がす\n\n\t\t\tswitch(buf[k]){\n\t\t\tcase 'L':\n\t\t\t\tcurrent_x--;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcurrent_x++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcurrent_y--;\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tcurrent_y++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\t//既に訪れたことのあるマスか調べる\n\t\t\tFLG = false;\n\n\t\t\tfor(int a = 0; a < dice_index[i]; a++){\n\t\t\t\tif(info[i][a].x == current_x && info[i][a].y == current_y){\n\t\t\t\t\t\tinfo[i][a].value = dice.getBottom(); //新しい値で上書き\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!FLG){\n\t\t\t\tinfo[i][dice_index[i]].x = current_x;\n\t\t\t\tinfo[i][dice_index[i]].y = current_y;\n\t\t\t\tinfo[i][dice_index[i]].value = dice.getBottom();\n\n\t\t\t\tdice_index[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//N個のサイコロ情報を統合する\n\ttable_index = 0;\n\tfor(int i = 0; i < 500; i++)table[i].state = 0;\n\n\tfor(int i = 0; i < N; i++){ //15\n\t\tfor(int k = 0; k < dice_index[i]; k++){ //31\n\n\t\t\tFLG = false;\n\t\t\tfor(int a = 0; a < table_index; a++){\n\t\t\t\tif(table[a].loc.x == info[i][k].x && table[a].loc.y == info[i][k].y){ //テーブルに場所が登録済の場合\n\t\t\t\t\ttable[a].state += POW[i]; //マス毎に、サイコロの集合を持つ\n\t\t\t\t\tinfo[i][k].all_index = a; //逆引きインデックス\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!FLG){\n\t\t\t\ttable[table_index].loc.x = info[i][k].x;\n\t\t\t\ttable[table_index].loc.y = info[i][k].y;\n\t\t\t\ttable[table_index].state += POW[i];\n\t\t\t\tinfo[i][k].all_index = table_index;\n\t\t\t\ttable_index++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int state = 0; state < POW[N]; state++)dp[state] = 0;\n\n\tint sum,tmp_index,all_state;\n\tint next_state,next_value;\n\n\t //★★操作を逆順にして考える★★\n\tfor(int state = 0; state < POW[N]; state++){ //既に転がったサイコロの集合\n\t\tfor(int dice = 0; dice < N; dice++){\n\t\t\tif(state & (1 << dice))continue;\t//転がし済ならSKIP\n\t\t\tsum = 0;\n\t\t\t//あるサイコロについて、既に転がったサイコロとは重ならないマスの値の総和を求める\n\t\t\tfor(int i = 0; i < dice_index[dice]; i++){\n\t\t\t\ttmp_index = info[dice][i].all_index;\n\t\t\t\tall_state = table[tmp_index].state;\n\n\t\t\t\tif(!(all_state & state)){ //そのマスを転がる自分を含めた集合と、既に転がったサイコロの集合との論理積が0の場合:自分がそのマスを初カバー\n\t\t\t\t\tsum += info[dice][i].value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext_state = state+POW[dice];\n\t\t\tnext_value = dp[state]+sum;\n\t\t\tdp[next_state] = max(dp[next_state],next_value);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[POW[N]-1]);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 17; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int LEFT = 0, RIGHT = 1, FRONT = 2, BACK = 3, BOTTOM = 4, TOP = 5;\n\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  \n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\"); /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n  }\n\n  void rot(char ch){rot(string(1,ch));}\n  \n  //奥に転がす\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //手前に転がす\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n  \n  //右に転がす\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //左に転がす\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //上から見て時計回りに回す\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //上からみて反時計回りに回す。\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint dy[300], dx[300];\n\nvoid init(){\n  \n  dy['N'] = 1; dy['E'] = 0; dy['S'] = -1; dy['W'] = 0;\n  \n  dx['N'] = 0; dx['E'] = 1; dx['S'] = 0; dx['W'] = -1;\n  \n}\n\nint n, x[15], y[15];\nstring s[15];\nDice dice[15];\n\ntypedef pair<int,int> P;\n\nmap<P,int> dp[1<<15];\n\nint sum(map<P,int> S){\n  int res = 0;\n  for(auto p : S ) res += p.second;\n  return res;\n}\n\nmap<P,int> add(map<P,int> S, int idx){\n    \n  int X = x[idx], Y = y[idx];\n  \n  Dice d = dice[idx];\n  \n  set<P> used;\n  \n  if( S.count(P( X, Y )) == 0 ){\n    S[P( X, Y )] = d.val[BOTTOM];\n    used.insert(P( X, Y ));\n  }\n  \n  for(int i=0;i<(int)s[idx].size();i++){\n    \n    X += dx[(int)s[idx][i]];\n    \n    Y += dy[(int)s[idx][i]];\n    \n    d.rot(s[idx][i]);\n        \n    if( used.count(P( X, Y )) || S.count(P( X, Y )) == 0 ){\n      S[P( X, Y )] = d.val[BOTTOM];\n      used.insert(P( X, Y ));\n    }\n    \n  }\n  \n  return S;\n}\n\nsigned main(){\n  \n  init();\n\n  while(1){\n \n    cin>>n;\n    if( n == 0 ) break;\n\n    for(int i=0;i<(1<<n);i++) dp[i].clear();\n    \n    for(int i=0;i<n;i++){\n            \n      cin>>x[i]>>y[i];\n      \n      int val[6];\n      \n      for(int j=0;j<6;j++) cin>>val[j];\n      \n      dice[i] = Dice(val);\n      \n      cin>>s[i];\n      \n      for(int j=0;j<(int)s[i].size();j++){\n\tif( s[i][j] == 'B' ) s[i][j] = 'N';\n\tif( s[i][j] == 'R' ) s[i][j] = 'E';\n\tif( s[i][j] == 'F' ) s[i][j] = 'S';\n\tif( s[i][j] == 'L' ) s[i][j] = 'W';\n      }\n      \n    }\n    \n    for(int i=0;i<(1<<n);i++){\n      \n      for(int j=0;j<n;j++){\n\t\n\tif( !( i >> j & 1 ) ){\n\t  \n\t  if( sum( dp[i|(1<<j)] ) < sum( add( dp[i], j ) ) ){\n\t    \n\t    dp[ i | (1<<j) ] = add( dp[i], j );\n\t    \n\t  }\n\t  \n\t}\n\t\n      }\n      \n    }\n    \n    cout << sum( dp[(1<<n)-1] ) << endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define UP    0\n#define DOWN  1\n#define FORE  2\n#define BACK  3\n#define RIGHT 4\n#define LEFT  5\n\nstruct Dice\n{\n  int face[6];\n  Dice(){}\n  Dice(int up, int down, int fore, int back, int right, int left)\n  {\n    face[UP] = up; face[DOWN] = down;\n    face[FORE]  = fore; face[BACK] = back;\n    face[RIGHT] = right; face[LEFT] = left;\n  }\n  void roll(int a, int b, int c, int d) {\n    swap(face[a], face[c]);\n    swap(face[b], face[d]);\n    swap(face[c], face[d]);\n  }\n  void roll2fore() { roll(FORE, BACK, UP, DOWN); }\n  void roll2back() { roll(BACK, FORE, UP, DOWN); }  \n  void roll2right() { roll(RIGHT, LEFT, UP, DOWN); }\n  void roll2left() { roll(LEFT, RIGHT, UP, DOWN); }\n  void rotate_clockwise() { roll(FORE, BACK, RIGHT, LEFT); }\n  void rotate_counterclockwise() { roll(FORE, BACK, LEFT, RIGHT); }\n  void print_face()\n  {\n    printf(\"UP   : %d\\n\", face[UP]);\n    printf(\"DOWN : %d\\n\", face[DOWN]);\n    printf(\"FORE : %d\\n\", face[FORE]);\n    printf(\"BACK : %d\\n\", face[BACK]);\n    printf(\"RIGHT: %d\\n\", face[RIGHT]);\n    printf(\"LEFT : %d\\n\", face[LEFT]);\n  }\n};\n\nint N;\nvector<int> sx, sy;\nvector<Dice> dice;\nvector<string> rot;\nvector< vector<P> > ftpts;\nvector< vector<int> > stamp;\n\nint dp[1<<16];\nmap<P, bool> used;\n\nstring dir = \"LRFB\";\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint solve(int bit)\n{\n  if(bit == (1<<N)-1) return 0;\n  int& ret = dp[bit];\n  if(~ret) return ret;\n\n  ret = 0;\n  for(int i = 0; i < N; i++) {\n    if((bit >> i) & 1) continue;\n    int sum = 0;\n    vector<P> reset;\n    for(int j = 0; j < ftpts[i].size(); j++) {\n      if(used[ftpts[i][j]]) continue;\n      used[ftpts[i][j]] = true;\n      sum += stamp[i][j];\n      reset.push_back(ftpts[i][j]);\n    }\n    ret = max(ret, solve(bit | (1 << i)) + sum);\n    for(int j = 0; j < reset.size(); j++) {\n      used[reset[j]] = false;\n    }\n  }\n  \n  return ret;\n}\n\nvoid init()\n{\n  sx.clear(); sx.resize(N);\n  sy.clear(); sy.resize(N);\n  dice.clear(); dice.resize(N);\n  rot.clear(); rot.resize(N);\n\n  for(int i = 0; i < N; i++) {\n    cin >> sx[i] >> sy[i];\n    int l, r, f, b, d, u;\n    cin >> l >> r >> f >> b >> d >> u;\n    dice[i] = Dice(u, d, f, b, r, l);\n    cin >> rot[i];\n  }  \n}\n\nvoid footprints()\n{\n  ftpts.clear(); ftpts.resize(N);\n  stamp.clear(); stamp.resize(N);\n  for(int i = 0; i < N; i++) {\n    Dice die = dice[i];\n    int x = sx[i], y = sy[i];\n    ftpts[i].push_back(P(x, y));\n    stamp[i].push_back(die.face[DOWN]);\n    for(int j = 0; j < rot[i].size(); j++) {\n      int d = dir.find(rot[i][j]);\n      x += dx[d], y += dy[d];\n      switch(rot[i][j]) {\n      case 'L': die.roll2left(); break;\n      case 'R': die.roll2right(); break;\n      case 'F': die.roll2fore(); break;\n      case 'B': die.roll2back(); break;\n      }\n      ftpts[i].push_back(P(x, y));\n      stamp[i].push_back(die.face[DOWN]);\n    }\n    reverse(all(ftpts[i]));\n    reverse(all(stamp[i]));\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    init();\n    footprints();\n    memset(dp, -1, sizeof(dp));\n    used.clear();\n    cout << solve(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<short, short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<map<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<unsigned short, map<pii, char>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n#define pb push_back\n\ntypedef struct {\n  int l, r, f, b, d, u;\n} dice;\n\ndice rotL(dice d)\n{\n  dice n = d;\n  n.l = d.u;\n  n.u = d.r;\n  n.r = d.d;\n  n.d = d.l;\n  return n;\n}\n\ndice rotR(dice d)\n{\n  dice n = d;\n  n.u = d.l;\n  n.r = d.u;\n  n.d = d.r;\n  n.l = d.d;\n  return n;\n}\n\ndice rotF(dice d)\n{\n  dice n = d;\n  n.f = d.u;\n  n.u = d.b;\n  n.b = d.d;\n  n.d = d.f;\n  return n;\n}\n\ndice rotB(dice d)\n{\n  dice n = d;\n  n.b = d.u;\n  n.u = d.f;\n  n.f = d.d;\n  n.d = d.b;\n  return n;\n}\n\ntypedef struct {\n  int x, y;\n  int num;\n} masu;\n\n\nvec<vec<int> > Max(vec<vec<int> > a, vec<vec<int> > b)\n{\n  if (a[4000][4000] > b[4000][4000]) return a;\n  else return b;\n}\n\nvec<vec<int> > stamp(vec<vec<int> > p, vec<masu> s)\n{\n  rep(i, s.size()) {\n    if (p[s[i].x + 2000][s[i].y + 2000]) continue;\n    p[s[i].x + 2000][s[i].y + 2000] = s[i].num;\n    p[4000][4000] += s[i].num;\n  }\n  return p;\n}\n\nint main(void)\n{\n  while(1) {\n    int n;\n    cin >> n;\n    if (!n) break;\n    \n    vec<vec<masu> > stamps(n);\n    rep(t, n) {\n      int x, y;\n      cin >> x >> y;\n      dice d;\n      cin >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n      string rot;\n      cin >> rot;\n      map<pair<int, int>, int> dp;\n\n      masu s;\n      s.x = x; s.y = y; s.num = d.d;\n      stamps[t].pb(s);\n      dp[make_pair(x, y)] = 0;\n      rep(i, rot.length()) {\n        if (rot[i] == 'L') {\n          x--;\n          d = rotL(d);\n        } else if (rot[i] == 'R') {\n          x++;\n          d = rotR(d);\n        } else if (rot[i] == 'F') {\n          y--;\n          d = rotF(d);\n        } else {\n          y++;\n          d = rotB(d);\n        }\n        s.x = x; s.y = y; s.num = d.d;\n        if (dp.find(make_pair(x, y)) == dp.end()) {\n          stamps[t].pb(s);\n          dp[make_pair(x, y)] = stamps[t].size() - 1;\n        } else {\n          stamps[t][dp[make_pair(x, y)]] = s;\n        }\n      }\n    }\n\n    //vec<map<pair<int, int>, int> > dp(1 << n);\n    vec<vec<vec<int> > > dp(1 << n, vec<vec<int> >(4001, vec<int>(4001, 0)));\n    dp[0][4000][4000] = 0;\n    rep(i, (1 << n)) {\n      rep(j, n) {\n        if ((i >> j) % 2) continue;\n        dp[i + (1 << j)] = Max(dp[i + (1 << j)], stamp(dp[i], stamps[j]));\n      }\n    }\n    /*\n    int sum = 0;\n    for (auto it = dp[(1 << n) - 1].begin(); it != dp[(1 << n) - 1].end(); it++) sum += it->second;\n    cout << sum << endl;\n    */\n    //cout << dp[(1 << n) - 1][SUM] << endl;\n    cout << dp[(1 << n) - 1][4000][4000] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nshort p[4][6] = { {5,4,2,3,0,1},{4,5,2,3,1,0},{0,1,5,4,2,3},{0,1,4,5,3,2} };\nshort n, C[20][6], cx[20], cy[20]; string px[20];\nmap<pair<short, short>, short>D[20], E[1 << 16];\nvector<tuple<short, short, char>>_D[20];\nvector<pair<short, short>>_E[1 << 15];\nint dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }, dp[1 << 15];\nvoid Init1(int I) {\n\tvector<tuple<short, short, short, char>>__D;\n\t__D.push_back(make_tuple(cx[I], cy[I], -1, C[I][4]));\n\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\tfor (int j = 0; j < px[I].size(); j++) {\n\t\tint A = 3, F[6] = { 0,0,0,0,0,0 };\n\t\tif (px[I][j] == 'L')A = 0; if (px[I][j] == 'R')A = 1;\n\t\tif (px[I][j] == 'F')A = 2; if (px[I][j] == 'B')A = 3;\n\t\tfor (int k = 0; k < 6; k++)F[k] = C[I][p[A][k]];\n\t\tfor (int k = 0; k < 6; k++)C[I][k] = F[k];\n\t\tcx[I] += dx[A]; cy[I] += dy[A];\n\t\t__D.push_back(make_tuple(cx[I], cy[I], j, C[I][4]));\n\t\tD[I][make_pair(cx[I], cy[I])] = C[I][4];\n\t}\n\tsort(__D.begin(), __D.end());\n\tfor (int i = 0; i < __D.size(); i++) {\n\t\tif (i == __D.size() - 1)_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\telse if (get<0>(__D[i]) != get<0>(__D[i + 1]) || get<1>(__D[i]) != get<1>(__D[i + 1])) {\n\t\t\t_D[I].push_back(make_tuple(get<0>(__D[i]), get<1>(__D[i]), get<3>(__D[i])));\n\t\t}\n\t}\n\treturn;\n}\nvoid Init2(int p) {\n\tfor (int j = 0; j < n; j++) {\n\t\tif ((p / (1 << j)) % 2 == 0)continue;\n\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\tif (E[p][pa] == 0) { _E[p].push_back(pa); } E[p][pa] = 1;\n\t\t}\n\t}\n\tsort(_E[p].begin(), _E[p].end());\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 15; i++) { D[i].clear(); _D[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++) { E[i].clear(); _E[i].clear(); }\n\t\tfor (int i = 0; i < 32768; i++)dp[i] = -1;\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx[i] >> cy[i]; for (int j = 0; j < 6; j++) cin >> C[i][j]; cin >> px[i];\n\t\t\tInit1(i);\n\t\t}\n\t\tfor (int i = 0; i < (1 << n); i++) Init2(i); dp[0] = 0;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i / (1 << j)) % 2 == 1)continue;\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int k = 0; k < _D[j].size(); k++) {\n\t\t\t\t\tpair<short, short>pa = make_pair(get<0>(_D[j][k]), get<1>(_D[j][k]));\n\t\t\t\t\tint pos1 = lower_bound(_E[i].begin(), _E[i].end(), pa) - _E[i].begin();\n\t\t\t\t\tif (_E[i].size() == pos1 || _E[i][pos1] != pa)cnt += get<2>(_D[j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + (1 << j)] = max(dp[i + (1 << j)], dp[i] + cnt);\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(i,s,n) for(int i=(s); i<(n); i++)\n#define rep(i,n) reps(i,0,n)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e9;\n\nstruct dice{\n\tint d[6];\n\tint point(){ return d[0]; }\n\tvoid set(int l, int r, int f, int b, int _d, int u){\n\t\td[3] = l;\n\t\td[1] = r;\n\t\td[4] = f;\n\t\td[5] = b;\n\t\td[0] = _d;\n\t\td[2] = u;\n\t}\n};\n\nvoid rot(dice &dc, pii &pos, char r){\n\tif( r == 'L' ){\n\t\tswap( dc.d[0], dc.d[3] );\n\t\tswap( dc.d[3], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[1] );\n\t\tpos.X--;\n\t}else if( r == 'R' ){\n\t\tswap( dc.d[0], dc.d[1] );\n\t\tswap( dc.d[1], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[3] );\n\t\tpos.X++;\n\t}else if( r == 'F' ){\n\t\tswap( dc.d[0], dc.d[4] );\n\t\tswap( dc.d[4], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[5] );\n\t\tpos.Y--;\n\t}else if( r == 'B' ){\n\t\tswap( dc.d[0], dc.d[5] );\n\t\tswap( dc.d[5], dc.d[2] );\n\t\tswap( dc.d[2], dc.d[4] );\n\t\tpos.Y++;\n\t}\n}\n\ndice dice_org[20];\npii dice_pos[20];\nstring dice_rot[20];\nmap<pii,int> tb[20];\nvoid rots(int n){\n\tdice dc = dice_org[n];\n\tpii pos = dice_pos[n];\n\t// pre\n\ttb[n][pii(pos.X, pos.Y)] = dc.point();\n\tfor(auto c: dice_rot[n]){\n\t\trot( dc, pos, c );\n\t\ttb[n][pii(pos.X,pos.Y)] = dc.point();\n\t}\n}\n\nint solve(map<pii,int> &table, int n){\n\t// merge\n\tint sum = 0;\n\tfor(auto p: tb[n]) if( table.count(p.X) == 0 ){\n\t\ttable[p.X] = p.Y;\n\t\tsum += p.Y;\n\t}\n\treturn sum;\n}\n\nmap<pii, int> tables[1<<20];\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 2000;\n\t\t\ty += 2000;\n\t\t\tdice_pos[i].X = x;\n\t\t\tdice_pos[i].Y = y;\n\n\t\t\tint l, r, f, b, d, u; \n\t\t\tcin >> l >> r >> f >> b >> d >> u; \n\t\t\tdice_org[i].set(l, r, f, b, d, u);\n\n\t\t\tcin >> dice_rot[i];\n\t\t}\n\n\t\trep(i,N){\n\t\t\ttb[i].clear();\n\t\t\trots(i);\n\t\t}\n\n\t\tint dp[1<<20] = {};\n\t\trep(i, 1<<N){\n\t\t\t//rep(k,N) if( (1<<k)&i ) rots(table, k, true);\n\t\t\trep(k,N){\n\t\t\t\tint nx = (1<<k)|i;\n\t\t\t\tif( nx != i ){\n\t\t\t\t\tauto table = tables[i];\n\t\t\t\t\tdp[nx] = max( dp[nx], dp[i] + solve(table, k) );\n\t\t\t\t\ttables[nx] = table;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttables[i].clear();\n\t\t}\n\t\tcout << dp[(1<<N)-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\nconst int TOP = 0,FRONT = 1,LEFT = 2, RIGHT = 3,BACK = 4,BOTTOM = 5;\nclass Dice{\npublic:\n  int val[6];\n  Dice(){for(int i=0;i<6;i++) val[i] = i;}\n  Dice(int val[6]){for(int i=0;i<6;i++) this->val[i] = val[i];}\n  Dice(int l,int r,int f,int b,int d,int u){\n    val[LEFT] = l, val[RIGHT] = r;\n    val[FRONT] = f, val[BACK] = b;\n    val[BOTTOM] = d, val[TOP] = u;\n  }\n  void rot(string s){\n    if(s == \"N\" || s == \"B\") rotN();\n    else if(s == \"S\" || s == \"F\") rotS();\n    else if(s == \"E\" || s == \"R\") rotE();\n    else if(s == \"W\" || s == \"L\") rotW();\n    else if(s == \"CW\") rotCW();\n    else if(s == \"CCW\") rotCCW();\n    else assert(!\"rot error\");\n  }\n\n  //?\\\\?????¢??????\n  void rotN(){\n    swap(val[TOP],val[FRONT]);\n    swap(val[FRONT],val[BOTTOM]);\n    swap(val[BOTTOM],val[BACK]);\n  }\n\n  //???????????¢??????\n  void rotS(){\n    //rotN(),rotN(),rotN();\n    swap(val[TOP],val[BACK]);\n    swap(val[BACK],val[BOTTOM]);\n    swap(val[BOTTOM],val[FRONT]);\n  }\n\n\n  //????????¢??????\n  void rotE(){\n    swap(val[TOP],val[LEFT]);\n    swap(val[LEFT],val[BOTTOM]);\n    swap(val[BOTTOM],val[RIGHT]);\n  }\n\n  //????????¢??????\n  void rotW(){\n    //rotE(),rotE(),rotE();\n    swap(val[TOP],val[RIGHT]);\n    swap(val[RIGHT],val[BOTTOM]);\n    swap(val[BOTTOM],val[LEFT]);\n  }\n\n  //???????????????????¨????????????????\n  void rotCW(){\n    swap(val[FRONT],val[RIGHT]);\n    swap(val[RIGHT],val[BACK]);\n    swap(val[BACK],val[LEFT]);\n  }\n\n  //??????????????????????¨???????????????????\n  void rotCCW(){\n    //rotCW(),rotCW(),rotCW();\n    swap(val[FRONT],val[LEFT]);\n    swap(val[LEFT],val[BACK]);\n    swap(val[BACK],val[RIGHT]);\n  }\n};\n\nint n;\nstruct dat{int x,y;Dice d;};\ndat A[N];\nstring rot[N];\ntypedef pair<short,short> P;\ntypedef map<P,int> M;\n\nint getScore(M &mp){\n  int res = 0;\n  for(pair<P,int> p:mp) res += p.second;\n  return res;\n}\n\n\nvoid getNx(int idx,M &res,int &score){\n  static int dx[1<<8]={};dx['L'] = -1, dx['R'] = 1;\n  static int dy[1<<8]={};dy['F'] = -1, dy['B'] = 1;\n  int x = A[idx].x, y = A[idx].y;  \n  Dice d = A[idx].d;\n  score += d.val[BOTTOM] - res[P(x,y)];\n  res[P(x,y)] = d.val[BOTTOM];\n  for(char ch:rot[idx]){\n    x += dx[(int)ch], y += dy[(int)ch];\n    d.rot(string(1,ch));\n    score += d.val[BOTTOM] - res[P(x,y)];\n    res[P(x,y)] = d.val[BOTTOM];\n  }\n}\n\nint DP(){\n  M dp[1<<N];\n  int score[1<<N]={};\n  int res = 0;\n  for(int bit;bit<(1<<n);bit++){\n    Max(res,score[bit]);\n    for(int i=0;i<n;i++) {\n      if(bit>>i&1)continue;\n      int nbit = bit | (1<<i);\n      int nscore = score[bit];\n      M nmp = dp[bit];\n      getNx(i,nmp,nscore);\n      if(score[nbit] < nscore) dp[nbit] = nmp, score[nbit] = nscore;\n    }\n    dp[bit].clear();\n  }\n  return res;\n}\n \nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      int x,y;\n      int l,r,f,b,d,u;\n      cin>>x>>y>>l>>r>>f>>b>>d>>u>>rot[i];\n      A[i] = (dat){x,y,Dice(l,r,f,b,d,u)};\n    }\n    cout<<DP()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Dice{\n  int y,x;\n  int s[6];\n  Dice(){}\n  void roll(char c){\n    //the view from above\n    // N\n    //W E\n    // S\n    //s[0]:top\n    //s[1]:south\n    //s[2]:east\n    //s[3]:west\n    //s[4]:north\n    //s[5]:bottom\n    int b;\n    if(c=='R'){\n      x++;\n      b=s[0];\n      s[0]=s[3];\n      s[3]=s[5];\n      s[5]=s[2];\n      s[2]=b;\n    }\n    if(c=='L'){\n      x--;\n      b=s[0];\n      s[0]=s[2];\n      s[2]=s[5];\n      s[5]=s[3];\n      s[3]=b;\n    }\n    if(c=='B'){\n      y++;\n      b=s[0];\n      s[0]=s[1];\n      s[1]=s[5];\n      s[5]=s[4];\n      s[4]=b;\n    }\n    if(c=='F'){\n      y--;\n      b=s[0];\n      s[0]=s[4];\n      s[4]=s[5];\n      s[5]=s[1];\n      s[1]=b;\n    }\n  }\n  int top() {\n    return s[0];\n  }\n  int bottom(){\n    return s[5];\n  }\n};\ntypedef pair<int,int> P;\nset<P> used;\nint memo[1<<16];\nint n;\nDice ds[16];\nstring rot[16];\nint dfs(int b){\n  if(~memo[b]) return memo[b];\n  int res=0;\n  for(int i=0;i<n;i++){\n    if((b>>i)&1) continue;\n    map<P,int> v;\n    int tmp=0;\n    Dice d=ds[i];\n    for(int j=0;j<(int)rot[i].size();j++){\n      if(v.count(P(d.y,d.x))||!used.count(P(d.y,d.x))){\n    //cout<<tmp<<\" \"<<d.bottom()<<endl;\n    tmp+=d.bottom();\n    if(v.count(P(d.y,d.x))) tmp-=v[P(d.y,d.x)];\n    v[P(d.y,d.x)]=d.bottom();\n    used.insert(P(d.y,d.x));\n      }\n      //cout<<d.y<<\" \"<<d.x<<\":\"<<tmp<<\" \"<<d.bottom()<<endl;\n      d.roll(rot[i][j]);\n    }\n    res=max(res,dfs(b+(1<<i))+tmp);\n    for(auto j:v) used.erase(j.first);\n  }\n  //cout<<b<<\" \"<<res<<endl;\n  return memo[b]=res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      cin>>ds[i].x>>ds[i].y;\n      cin>>ds[i].s[3]>>ds[i].s[2]>>ds[i].s[1];\n      cin>>ds[i].s[4]>>ds[i].s[5]>>ds[i].s[0];\n      cin>>rot[i];\n      rot[i]+=\"$\";//guard\n    }\n    used.clear();\n    memset(memo,-1,sizeof(memo));\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n\nusing Dice = std::array<int, 6>;\n\n// d[i] <- d[i + 1]\nstd::vector<std::vector<int>>\n    ways = {{0, 5, 1, 4},\n            {0, 4, 1, 5},\n            {3, 5, 2, 4},\n            {3, 4, 2, 5}};\n\nstd::vector<int> dx{-1, 1, 0, 0}, dy{0, 0, 1, -1};\n\nusing Route = std::map<std::pair<int, int>, int>;\n\nRoute input() {\n    int x, y;\n    std::cin >> x >> y;\n\n    Dice ds;\n    for (auto& d : ds) std::cin >> d;\n\n    std::string s;\n    std::cin >> s;\n\n    Route route;\n    route[std::make_pair(x, y)] = ds[4];\n\n    for (char c : s) {\n        int d;\n        for (d = 0; c != \"LRBF\"[d]; ++d) {}\n\n        const auto& way = ways[d];\n        auto tmp = ds[way[0]];\n        for (int i = 0; i + 1 < 4; ++i) {\n            ds[way[i]] = ds[way[i + 1]];\n        }\n        ds[way[3]] = tmp;\n\n        x += dx[d], y += dy[d];\n\n        route[std::make_pair(x, y)] = ds[4];\n    }\n    return route;\n}\n\nconstexpr int INF = 1 << 30;\n\nbool solve() {\n    int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    std::vector<Route> rs(n);\n    std::generate(rs.begin(), rs.end(), input);\n\n    std::vector<int> dp(1 << n, -INF);\n    dp[0] = 0;\n\n    for (int b = 0; b < (1 << n); ++b) {\n        std::set<std::pair<int, int>> filled;\n        for (int i = 0; i < n; ++i) {\n            if (!((b >> i) & 1)) continue;\n\n            for (const auto& p : rs[i]) {\n                filled.insert(p.first);\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if ((b >> i) & 1) continue;\n\n            int score = 0;\n            for (const auto& p : rs[i]) {\n                if (filled.count(p.first)) continue;\n                score += p.second;\n            }\n\n            int nb = b | (1 << i);\n            dp[nb] = std::max(dp[nb], dp[b] + score);\n        }\n    }\n\n    std::cout << dp.back() << std::endl;\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<short, short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\n/*template <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n\tstd::hash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std\n{\n\ttemplate<typename S, typename T> struct hash<pair<S, T>>\n\t{\n\t\tinline size_t operator()(const pair<S, T> & v) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\t::hash_combine(seed, v.first);\n\t\t\t::hash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n}*/\nenum {\n\tl, r, f, b, d, u\n};\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<map<pii, int>> dice(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvi buf(6);\n\t\t\tfor (auto&a : buf)cin >> a;\n\t\t\tstring dl;\n\t\t\tcin >> dl;\n\t\t\tdice[i][pii(x, y)] = buf[4];\n\t\t\tfor (char a : dl) {\n\t\t\t\tswitch (a) {\n\t\t\t\tcase'L':\n\t\t\t\t\tbuf = { buf[u],buf[d],buf[f],buf[b],buf[l],buf[r] };\n\t\t\t\t\tx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tbuf = { buf[d],buf[u],buf[f],buf[b],buf[r],buf[l] };\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[u],buf[d],buf[f],buf[b] };\n\t\t\t\t\ty--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tbuf = { buf[l],buf[r],buf[d],buf[u],buf[b],buf[f] };\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tdice[i][pii(x, y)] = buf[d];\n\t\t\t}\n\t\t}\n\t\tvector < pair<unsigned short, map<pii, char>>> dp(1 << n);\n\t\trep(i, 1 << n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (!(i & 1 << j))continue;\n\t\t\t\tint src = i&~(1 << j);\n\t\t\t\tint s = dp[src].first;\n\t\t\t\tfor (auto a : dice[j]) {\n\t\t\t\t\ts += a.second;\n\t\t\t\t\tif (dp[src].second.count(a.first))s -= dp[src].second[a.first];\n\t\t\t\t}\n\t\t\t\tif (s > dp[i].first) {\n\t\t\t\t\tdp[i].first = s;\n\t\t\t\t\tfor (auto&a : dp[src].second)dp[i].second[a.first] = a.second;\n\t\t\t\t\tfor (auto&a : dice[j])dp[i].second[a.first] = a.second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1 << n) - 1].first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nenum { U, B, L, F, R, D };\nstruct Dice {\n\tint face[6];\n\n\tDice() {\n\t\tface[F] = 1;\n\t\tface[R] = 2;\n\t\tface[U] = 3;\n\t\tface[B] = 6;\n\t\tface[L] = 5;\n\t\tface[D] = 4;\n\t}\n\n\tint find_face(int f) {\n\t\tfor(int i = 0; i < 6; i++) {\n\t\t\tif(face[i] == f) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tvoid turn(int dir) {\n\t\tswitch(dir) {\n\t\tcase R:\n\t\t\trotate(U, R, D, L);\n\t\t\tbreak;\n\t\tcase B:\n\t\t\trotate(U, B, D, F);\n\t\t\tbreak;\n\t\tcase L:\n\t\t\trotate(U, L, D, R);\n\t\t\tbreak;\n\t\tcase F:\n\t\t\trotate(U, F, D, B);\n\t\t\tbreak;\n\t\tcase U:\n\t\t\trotate(F, R, B, L);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tcase D:\n\t\t\trotate(F, L, B, R);\n\t\t\tbreak;  // ??????????????????????¨???????\n\t\tdefault:\n\t\t\tassert(false);\n\t\t}\n\t}\n\n\tint& operator[](int n) { return face[n]; }\n\n\tconst int& operator[](int n) const { return face[n]; }\n\n\tstd::vector<Dice> all_rolls() {\n\t\tstd::vector<Dice> res;\n\t\tfor(int k = 0; k < 6; k++) {\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tres.push_back(*this);\n\t\t\t\tturn(R);\n\t\t\t}\n\t\t\tturn(k % 2 == 1 ? U : F);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid rotate(int a, int b, int c, int d) {\n\t\tint t = face[d];\n\t\tface[d] = face[c];\n\t\tface[c] = face[b];\n\t\tface[b] = face[a];\n\t\tface[a] = t;\n\t}\n};\n\ntypedef pair<int, int> P;\n\nDice dice[15];\nint X[15], Y[15];\nstring rot[15];\nmap<P, int> pos[15];\nint dp[16][1 << 15];\nset<P> used[1 << 15];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint l, r, f, b, d, u;\n\t\t\tcin >> X[i] >> Y[i];\n\t\t\tcin >> l >> r >> f >> b >> d >> u;\n\t\t\tcin >> rot[i];\n\t\t\tdice[i][L] = l;\n\t\t\tdice[i][R] = r;\n\t\t\tdice[i][F] = f;\n\t\t\tdice[i][B] = b;\n\t\t\tdice[i][D] = d;\n\t\t\tdice[i][U] = u;\n\n\t\t\tDice t = dice[i];\n\t\t\tint x = X[i], y = Y[i];\n\t\t\tpos[i].clear();\n\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\tfor(auto c : rot[i]) {\n\t\t\t\tif(c == 'L') t.turn(L), x--;\n\t\t\t\tif(c == 'R') t.turn(R), x++;\n\t\t\t\tif(c == 'F') t.turn(F), y--;\n\t\t\t\tif(c == 'B') t.turn(B), y++;\n\t\t\t\tpos[i][{ x, y }] = t[D];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 1 << N; i++) {\n\t\t\tused[i].clear();\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(i >> j & 1) {\n\t\t\t\t\tfor(auto p : pos[j]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tused[i].insert({ x, y });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, -1, sizeof dp);\n\t\tdp[0][0] = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\t\tif(dp[i][j] == -1) continue;\n\t\t\t\tint s = dp[i][j];\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tint ns = s;\n\t\t\t\t\tfor(auto p : pos[k]) {\n\t\t\t\t\t\tint x = p.first.first, y = p.first.second;\n\t\t\t\t\t\tint point = p.second;\n\t\t\t\t\t\tif(used[j].count({ x, y })) continue;\n\t\t\t\t\t\tns += point;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j | (1 << k)] = max(dp[i + 1][j | (1 << k)], ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int j = 0; j < 1 << N; j++) {\n\t\t\tans = max(ans, dp[N][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,set<pii> > ps;\n\n// LRFB\nconst int R[4][6] = {\n\t{4,5,2,3,1,0},\n\t{5,4,2,3,0,1},\n\t{0,1,4,5,3,2},\n\t{0,1,5,4,2,3},\n};\nconst int vx[]={-1,1,0,0}, vy[]={0,0,-1,1};\n\npii S[20];\nint p[20][6];\nstring rot[20];\nint mp[3000][3000];\nint pp[20][3000][3000];\n\nvoid calc(int p[6], string rot, int n, int x, int y){\n\tpp[n][y][x] = p[4]; //?????¢\n\tif( rot.empty() ) return;\n\tint np[6], r;\n\tif( rot[0] == 'L' ) r = 0;\n\tif( rot[0] == 'R' ) r = 1;\n\tif( rot[0] == 'F' ) r = 2;\n\tif( rot[0] == 'B' ) r = 3;\n\trep(i,6) np[ R[r][i] ] = p[i];\n\tcalc(np, rot.substr(1), n, x+vx[r], y+vy[r]);\n}\n\nint sum(int n, set<pii> &st){\n\tint x = S[n].X;\n\tint y = S[n].Y;\n\tint ret = 0;\n\tif( !st.count(pii(x,y)) ){\n\t\tret += pp[n][y][x];\n\t\tst.insert( pii(x,y) );\n\t}\n\trep(i,rot[n].length()){\n\t\tint r;\n\t\tif( rot[n][i] == 'L' ) r = 0;\n\t\tif( rot[n][i] == 'R' ) r = 1;\n\t\tif( rot[n][i] == 'F' ) r = 2;\n\t\tif( rot[n][i] == 'B' ) r = 3;\n\t\tx += vx[r];\n\t\ty += vy[r];\n\t\tif( !st.count(pii(x,y)) ){\n\t\t\tret += pp[n][y][x];\n\t\t\tst.insert( pii(x,y) );\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N, N){\n\t\tfill( (int*)mp[0], (int*)mp[3000], 0 );\n\t\tfill( (int*)pp[0], (int*)pp[20], 0 );\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tx += 1500;\n\t\t\ty += 1500;\n\t\t\tS[i] = pii(x,y);\n\t\t\trep(j,6) cin >> p[i][j];\n\t\t\tcin >> rot[i];\n\t\t\tcalc(p[i], rot[i], i, x, y);\n\t\t}\n\t\tps dp[1<<16]={};\n\t\trep(k,1<<N){\n\t\t\trep(i,N) if( k&(1<<i) ){\n\t\t\t\tauto st = dp[k^(1<<i)].Y;\n\t\t\t\tint tmp = dp[k^(1<<i)].X + sum( i, st );\n\t\t\t\tdp[k] = max( dp[k], ps(tmp, st) );\n\t\t\t}\n\t\t}\n\t\tcout << dp[(1<<N)-1].X << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nstruct dice {\n    int l, r, f, b, d, u;\n    dice() {}\n    dice(int l, int r, int f, int b, int d, int u):\n        l(l), r(r), f(f), b(b), d(d), u(u) {}\n\n    dice rot_right() {\n        return dice(d, u, f, b, r, l);\n    }\n\n    dice rot_left() {\n        return dice(u, d, f, b, l, r);\n    }\n\n    dice rot_front() {\n        return dice(l, r, u, d, f, b);\n    }\n\n    dice rot_back() {\n        return dice(l, r, d, u, b, f);\n    }\n};\n\nusing PR = int;\nusing MAP_t = map<PR, int>;\n\nint encode(int x, int y) { return 3000 * x + y; }\n\nint N;\nMAP_t boards[1 << 15];\nint scores[1 << 15];\n\nint merge(int idx1, int idx2, MAP_t& dest) {\n    dest = boards[idx1];\n    int res_v = scores[idx1];\n\n    for (const pair<PR, int>& itr : boards[idx2]) {\n        res_v += itr.second - dest[itr.first];\n        dest[itr.first] = itr.second;\n    }\n\n    return res_v;\n}\n\nint solve() {\n    MAP_t trg;\n\n    for (int n = 1; n < (1 << N); ++n) {\n        for (int i = 0; i < N; ++i) {\n            if ((n & (1 << i)) == 0) continue;\n            int m = n ^ (1 << i);\n\n            int sc = merge((1 << i), m, trg);\n            if (sc > scores[n]) {\n                boards[n] = trg;\n                scores[n] = sc;\n            }\n        }\n    }\n\n    return scores[(1 << N) - 1];\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while (true) {\n        cin >> N; if (N == 0) break;\n        fill(scores, scores + (1 << N), 0);\n        for (int i = 0; i < N; ++i) boards[1 << i].clear();\n        for (int i = 0; i < N; ++i) {\n            int x, y; dice d; string p;\n            cin >> x >> y >> d.l >> d.r >> d.f >> d.b >> d.d >> d.u;\n\n            x += 1000; y += 1000;\n\n            int idx = 1 << i;\n            int sc = 0;\n\n            boards[idx][encode(x, y)] = d.d;\n            sc += d.d;\n\n            cin >> p;\n            for (char ch : p) {\n                if (ch == 'L') {\n                    --x;\n                    d = d.rot_left();\n                } else if (ch == 'R') {\n                    ++x;\n                    d = d.rot_right();\n                } else if (ch == 'B') {\n                    ++y;\n                    d = d.rot_back();\n                } else {\n                    --y;\n                    d = d.rot_front();\n                }\n                PR key = encode(x, y);\n                sc += d.d - boards[idx][key];\n                boards[idx][key] = d.d;\n            }\n            scores[idx] = sc;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\ntypedef long long ll;\n#define ARRAY 65536\n#define DBG 0\nusing namespace std;\n\n\nclass Dice{\n  //    1  /  rX     4  /\n  //  ___/    ->  _____/\n  //  2  | 3       2  |  1\n  //  |\n  //  v rY\n  //\n  //   0\n  //  1   2\n  public:\n    int value[6];\n    int id[6];\n    Dice(){\n      rep(i,6) id[i] = i;\n      rep(i,6) value[i] = i+1;\n    }\n    int& operator[](int x){return value[id[x]];}\n    void swp(int a, int b, int c, int d){\n      int tmp = id[a];\n      id[a] = id[b];\n      id[b] = id[c];\n      id[c] = id[d];\n      id[d] = tmp;\n    }\n    void rX(){swp(0, 3, 5, 2);}\n    void revX(){rX();rX();rX();}\n    void rY(){swp(0, 4, 5, 1);}\n    void revY(){rY();rY();rY();}\n    void print(){\n      rep(i,6)cout << value[id[i]] << \",\";\n      cout << endl;\n    }\n};\n\nclass Stump{\n  public:\n  int x, y, value;\n  Stump(int _x, int _y, int _value):x(_x),y(_y),value(_value){}; \n};\n\nvector<int> paths[ARRAY];\nll cells[ARRAY];\n\nint main(void){\n  int n;\n  while(cin >> n){\n    rep(i,ARRAY){paths[i].clear();cells[i]=0;}\n    int x, y, v;\n    int ans = 0;\n\n    string r;\n    Dice dice;\n    vector<Stump> s[32];\n\n\n    rep(i,n){\n      cin >> x >> y;\n      cin >> dice[3] >> dice[2] >> dice[1] >> dice[4] >> dice[5] >> dice[0];\n      x+=1050;\n      y+=1050;\n      s[i].push_back(Stump(x, y, dice[5]));\n\n      cin >> r;\n      rep(j,r.size()){\n        if( r[j] == 'L'){\n          dice.revX();x--;\n        }else if(r[j] == 'R'){\n          dice.rX();x++;\n        }else if(r[j] == 'F'){\n          dice.rY();y--;\n        }else{\n          dice.revY();y++;\n        }\n        s[i].push_back(Stump(x, y, dice[5]));\n      }\n    }\n\n    rep(i, 1<<n){\n      int state = i;\n      rep(k,n){\n        int mask = 1<<k;\n        if((state | mask) != state){\n          ll lp = 0;\n          map<pair<int,int>, int> mpl;\n          if(DBG)cout << \"stump(rev) \" << k;\n\n          rep(l, s[k].size()){\n            if(DBG)cout << \"(\" << s[k][l].x << \",\" << s[k][l].y << \")\";\n            for(int l = s[k].size()-1; l >= 0; --l){\n              if( mpl[make_pair(s[k][l].x, s[k][l].y)] == 0){\n                mpl[make_pair(s[k][l].x, s[k][l].y)] = s[k][l].value;\n                lp += s[k][l].value;\n              }\n            }\n          }\n          rep(l, paths[state].size()){\n            for(int l = paths[state].size()-1; l >= 0; --l){\n              if(DBG)cout << \", \" << paths[state][l];\n              rep(m, s[paths[state][l]].size()){\n                if(DBG)cout << \"(\" << s[paths[state][l]][m].x << \",\" << s[paths[state][l]][m].y << \")\";\n                if(mpl[make_pair(s[paths[state][l]][m].x, s[paths[state][l]][m].y)] == 0){\n                  mpl[make_pair(s[paths[state][l]][m].x, s[paths[state][l]][m].y)] = s[paths[state][l]][m].value;\n                  lp += s[paths[state][l]][m].value;\n                }\n              }\n            }\n          }\n          if(DBG)cout << \" res = \" << lp << endl;\n          if(cells[state|mask] < lp){\n            cells[state|mask] = lp;\n            paths[state|mask] = paths[state];\n            paths[state|mask].push_back(k);\n          }\n        }\n      }\n    }\n    cout << cells[(1<<n)-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N;\n\nvector<int> t[15];\nstring u[15];\nint sx[15],sy[15];\nint dp[ (1<<15) ];\nmap< P , int > mp;\n\nvoid ry(vector<int> &v){\n  int tmp=v[2];\n  v[2]=v[4];\n  v[4]=v[3];\n  v[3]=v[5];\n  v[5]=tmp;\n}\n\nvoid rx(vector<int> &v){\n  int tmp=v[0];\n  v[0]=v[4];\n  v[4]=v[1];\n  v[1]=v[5];\n  v[5]=tmp;\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    mp.clear();\n    for(int i=0;i<N;i++){\n      t[i].clear();\n      t[i].resize(6);\n      cin>>sx[i]>>sy[i];\n      for(int j=0;j<6;j++)cin>>t[i][j];\n      cin>>u[i];\n    }\n\n    for(int i=0;i<N;i++){\n      P p=P(sx[i],sy[i]);\n      mp[p]|=(1<<i);\n      for(int j=0;j<(int)u[i].size();j++){\n        if(u[i][j]=='L')p.first--;\n        if(u[i][j]=='R')p.first++;\n        if(u[i][j]=='F')p.second--;\n        if(u[i][j]=='B')p.second++;\n        mp[p]|=(1<<i);\n      }\n    }\n      \n    memset(dp,0,sizeof(dp));\n\n    for(int S=0;S<(1<<N);S++){\n      for(int i=0;i<N;i++){\n        if(S>>i&1)continue;\n        map< P , int > w;\n        vector<int> v=t[i];\n        P p=P(sx[i],sy[i]);\n        int cost=0;\n\n        if((mp[p]&S)==0){\n          cost-=w[p];\n          w[p]=v[4];\n          cost+=v[4];\n        }\n        \n        for(int j=0;j<(int)u[i].size();j++){\n          if(u[i][j]=='L'){\n            p.first--;\n            rx(v);rx(v);rx(v);\n          }\n          if(u[i][j]=='R'){\n            p.first++;\n            rx(v);\n          }\n          if(u[i][j]=='F'){\n            p.second--;\n            ry(v);ry(v);ry(v);\n          }\n          if(u[i][j]=='B'){\n            p.second++;\n            ry(v);\n          }\n          if((mp[p]&S)==0){\n            cost-=w[p];\n            w[p]=v[4];\n            cost+=v[4];\n          }\n        }\n        dp[S|(1<<i)]=max(dp[S|(1<<i)],dp[S]+cost);\n      }\n    }\n    cout<<dp[(1<<N)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "????????????????????????"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.string;\nimport std.container;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\n\nstruct Dice {\n    enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n    /*\n                                           z??????\n                                           |\n                                           |\n                                           |\n                                           |\n                                          / ------------------/\n                                         /                   /|\n                                        /                   / |\n                                       /        TOP        /  |\n                                      /                   /   |\n                                     /                   /    |\n                                    |-------------------|     |\n                                    |                   |RIGHT|\n                                    |                   |     |_______________ x??????\n                                    |                   |    /\n                                    |       FRONT       |   /\n                                    |                   |  /\n                                    |                   | /\n                                    |                   |/\n                                    |-------------------|\n                                   /\n                                  /\n                                 /\n                                /\n                              y??????\n    */\n    int[6] v;\n    this(int top, int front, int right) {\n        v[FACE.TOP]   = top;    v[FACE.BOTTOM] = 7 - top;\n        v[FACE.FRONT] = front;  v[FACE.BACK]   = 7 - front;\n        v[FACE.RIGHT] = right;  v[FACE.LEFT]   = 7 - right;\n    }\n    // clockwise\n    void rollX() { roll(FACE.TOP,  FACE.FRONT,  FACE.BOTTOM, FACE.BACK); }\n    void rollY() { roll(FACE.TOP,  FACE.LEFT,   FACE.BOTTOM, FACE.RIGHT); }\n    void rollZ() { roll(FACE.FRONT, FACE.RIGHT, FACE.BACK,   FACE.LEFT); }\n    void roll(int a, int b, int c, int d) {\n        int t = v[a];\n        v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n    }\n    Dice[] allStates() immutable {\n        Dice d = this;\n        Dice[] r;\n        foreach (i; 0 .. 6) {\n            if (i % 2 == 0) d.rollX();\n            else            d.rollY();\n            foreach (j; 0 .. 4) {\n                d.rollZ();\n                r ~= d;\n            }\n        }\n        return r;\n    }\n    bool sameDice(in Dice d) immutable {\n        Dice[] states = allStates();\n        return states.any!((a) => a.v == d.v);\n    }\n    string toString() {\n        return \"Dice\" ~ v.to!string;\n    }\n}\n\nvoid main() {\n    alias F = Dice.FACE;\n    immutable F[] input_order = [F.LEFT, F.RIGHT, F.FRONT, F.BACK, F.BOTTOM, F.TOP];\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    auto order = [\n        'L': (ref Dice d) { foreach (_; 0 .. 3) d.rollY(); },\n        'R': (ref Dice d) { d.rollY(); },\n        'F': (ref Dice d) { foreach (_; 0 .. 3) d.rollX(); },\n        'B': (ref Dice d) { d.rollX(); },\n    ];\n\n\n    int[char] dy = [ 'L': 0, 'R': 0, 'F': -1, 'B': 1 ];\n    int[char] dx = [ 'L': -1, 'R': 1, 'F': 0, 'B': 0 ];\n\n    while (true) {\n        int N;\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto as = new int[P][N];\n        foreach (n; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            int[] faces = readln.chomp.split(\" \").map!(to!int).array;\n            string rot = readln.chomp;\n            Dice d;\n            foreach (i; 0 .. 6) {\n                d.v[ input_order[i] ] = faces[i];\n            }\n            as[n][P(y, x)] = d.v[F.BOTTOM];\n            foreach (c; rot) {\n                y += dy[c];\n                x += dx[c];\n                order[c](d);\n                as[n][P(y, x)] = d.v[F.BOTTOM];\n            }\n        }\n\n        auto overwritten = new bool[P][1<<N]; // blocks overwritten later when 'bit' dices have dropped\n        foreach (int bit; 0 .. (1<<N)) {\n            foreach (int j; 0 .. N) {\n                if (bit & (1 << j)) continue;\n                foreach (x; as[j].keys) {\n                    overwritten[bit][x] = true;\n                }\n            }\n        }\n\n        auto dp = new int[1<<N];\n        dp[] = 0;\n        foreach (int k; 0 .. N) {\n            int bit = (1<<k) - 1;\n            while (bit < (1<<N)) {\n\n                foreach (i; 0 .. N) {\n                    // try to drop the i-th dice\n                    if ((1 << i) & bit) continue; // already dropped\n\n                    int r = dp[bit]; // r: current score when drop the i-th dice after dropped 'bit' dices\n                    auto w = overwritten[bit | 1<<i];\n                    foreach (p, v; as[i]) {\n                        if (p in w) continue;\n                        r += v;\n                    }\n                    dp[bit | 1<<i] = max(dp[bit | 1<<i], r);\n                }\n\n                int x = bit & ~bit;\n                int y = bit + x;\n                if (x == 0) break;\n                bit = ((bit & ~y) / x >> 1) | y;\n            }\n        }\n        writeln(dp[(1<<N) - 1]);\n    }\n\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.string;\nimport std.container;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\n\nstruct Dice {\n    enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n    /*\n                                           z??????\n                                           |\n                                           |\n                                           |\n                                           |\n                                          / ------------------/\n                                         /                   /|\n                                        /                   / |\n                                       /        TOP        /  |\n                                      /                   /   |\n                                     /                   /    |\n                                    |-------------------|     |\n                                    |                   |RIGHT|\n                                    |                   |     |_______________ x??????\n                                    |                   |    /\n                                    |       FRONT       |   /\n                                    |                   |  /\n                                    |                   | /\n                                    |                   |/\n                                    |-------------------|\n                                   /\n                                  /\n                                 /\n                                /\n                              y??????\n    */\n    int[6] v;\n    this(int top, int front, int right) {\n        v[FACE.TOP]   = top;    v[FACE.BOTTOM] = 7 - top;\n        v[FACE.FRONT] = front;  v[FACE.BACK]   = 7 - front;\n        v[FACE.RIGHT] = right;  v[FACE.LEFT]   = 7 - right;\n    }\n    // clockwise\n    void rollX() { roll(FACE.TOP,  FACE.FRONT,  FACE.BOTTOM, FACE.BACK); }\n    void rollY() { roll(FACE.TOP,  FACE.LEFT,   FACE.BOTTOM, FACE.RIGHT); }\n    void rollZ() { roll(FACE.FRONT, FACE.RIGHT, FACE.BACK,   FACE.LEFT); }\n    void roll(int a, int b, int c, int d) {\n        int t = v[a];\n        v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n    }\n    Dice[] allStates() immutable {\n        Dice d = this;\n        Dice[] r;\n        foreach (i; 0 .. 6) {\n            if (i % 2 == 0) d.rollX();\n            else            d.rollY();\n            foreach (j; 0 .. 4) {\n                d.rollZ();\n                r ~= d;\n            }\n        }\n        return r;\n    }\n    bool sameDice(in Dice d) immutable {\n        Dice[] states = allStates();\n        return states.any!((a) => a.v == d.v);\n    }\n    string toString() {\n        return \"Dice\" ~ v.to!string;\n    }\n}\n\nvoid main() {\n    alias F = Dice.FACE;\n    immutable F[] input_order = [F.LEFT, F.RIGHT, F.FRONT, F.BACK, F.BOTTOM, F.TOP];\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    auto order = [\n        'L': (ref Dice d) { foreach (_; 0 .. 3) d.rollY(); },\n        'R': (ref Dice d) { d.rollY(); },\n        'F': (ref Dice d) { foreach (_; 0 .. 3) d.rollX(); },\n        'B': (ref Dice d) { d.rollX(); },\n    ];\n\n\n    int[char] dy = [ 'L': 0, 'R': 0, 'F': -1, 'B': 1 ];\n    int[char] dx = [ 'L': -1, 'R': 1, 'F': 0, 'B': 0 ];\n\n    while (true) {\n        int N;\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto as = new int[P][N];\n        foreach (n; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            int[] faces = readln.chomp.split(\" \").map!(to!int).array;\n            string rot = readln.chomp;\n            Dice d;\n            foreach (i; 0 .. 6) {\n                d.v[ input_order[i] ] = faces[i];\n            }\n            as[n][P(y, x)] = d.v[F.BOTTOM];\n            foreach (c; rot) {\n                y += dy[c];\n                x += dx[c];\n                order[c](d);\n                as[n][P(y, x)] = d.v[F.BOTTOM];\n            }\n        }\n\n        auto dp = new int[1<<N];\n        dp[] = 0;\n        foreach (int k; 0 .. N) {\n            int bit = (1<<k) - 1;\n            while (bit < (1<<N)) {\n\n                foreach (i; 0 .. N) {\n                    // try to drop the i-th dice\n                    if ((1 << i) & bit) continue; // already dropped\n\n                    int r = dp[bit]; // r: current score when drop the i-th dice after dropped 'bit' dices\n\n                    bool[P] overwritten; // blocks overwritten later when 'bit' dices have dropped\n                    foreach (int j; 0 .. N) {\n                        if (bit & (1 << j)) continue;\n                        if (i == j) continue;\n                        foreach (x; as[j].keys) {\n                            overwritten[x] = true;\n                        }\n                    }\n\n                    foreach (p, v; as[i]) {\n                        if (p in overwritten) continue;\n                        r += v;\n                    }\n                    dp[bit | 1<<i] = max(dp[bit | 1<<i], r);\n                }\n\n                int x = bit & ~bit;\n                int y = bit + x;\n                if (x == 0) break;\n                bit = ((bit & ~y) / x >> 1) | y;\n            }\n        }\n        writeln(dp[(1<<N) - 1]);\n    }\n\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.string;\nimport std.container;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\n\nstruct Dice {\n    enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n    /*\n                                           z??????\n                                           |\n                                           |\n                                           |\n                                           |\n                                          / ------------------/\n                                         /                   /|\n                                        /                   / |\n                                       /        TOP        /  |\n                                      /                   /   |\n                                     /                   /    |\n                                    |-------------------|     |\n                                    |                   |RIGHT|\n                                    |                   |     |_______________ x??????\n                                    |                   |    /\n                                    |       FRONT       |   /\n                                    |                   |  /\n                                    |                   | /\n                                    |                   |/\n                                    |-------------------|\n                                   /\n                                  /\n                                 /\n                                /\n                              y??????\n    */\n    int[6] v;\n    this(int top, int front, int right) {\n        v[FACE.TOP]   = top;    v[FACE.BOTTOM] = 7 - top;\n        v[FACE.FRONT] = front;  v[FACE.BACK]   = 7 - front;\n        v[FACE.RIGHT] = right;  v[FACE.LEFT]   = 7 - right;\n    }\n    // clockwise\n    void rollX() { roll(FACE.TOP,  FACE.FRONT,  FACE.BOTTOM, FACE.BACK); }\n    void rollY() { roll(FACE.TOP,  FACE.LEFT,   FACE.BOTTOM, FACE.RIGHT); }\n    void rollZ() { roll(FACE.FRONT, FACE.RIGHT, FACE.BACK,   FACE.LEFT); }\n    void roll(int a, int b, int c, int d) {\n        int t = v[a];\n        v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n    }\n    Dice[] allStates() immutable {\n        Dice d = this;\n        Dice[] r;\n        foreach (i; 0 .. 6) {\n            if (i % 2 == 0) d.rollX();\n            else            d.rollY();\n            foreach (j; 0 .. 4) {\n                d.rollZ();\n                r ~= d;\n            }\n        }\n        return r;\n    }\n    bool sameDice(in Dice d) immutable {\n        Dice[] states = allStates();\n        return states.any!((a) => a.v == d.v);\n    }\n    string toString() {\n        return \"Dice\" ~ v.to!string;\n    }\n}\n\nvoid main() {\n    alias F = Dice.FACE;\n    immutable F[] input_order = [F.LEFT, F.RIGHT, F.FRONT, F.BACK, F.BOTTOM, F.TOP];\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    auto order = [\n        'L': (ref Dice d) { foreach (_; 0 .. 3) d.rollY(); },\n        'R': (ref Dice d) { d.rollY(); },\n        'F': (ref Dice d) { foreach (_; 0 .. 3) d.rollX(); },\n        'B': (ref Dice d) { d.rollX(); },\n    ];\n\n\n    int[char] dy = [ 'L': 0, 'R': 0, 'F': -1, 'B': 1 ];\n    int[char] dx = [ 'L': -1, 'R': 1, 'F': 0, 'B': 0 ];\n\n    while (true) {\n        int N;\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto as = new int[P][N];\n        foreach (n; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            int[] faces = readln.chomp.split(\" \").map!(to!int).array;\n            string rot = readln.chomp;\n            Dice d;\n            foreach (i; 0 .. 6) {\n                d.v[ input_order[i] ] = faces[i];\n            }\n            as[n][P(y, x)] = d.v[F.BOTTOM];\n            foreach (c; rot) {\n                y += dy[c];\n                x += dx[c];\n                order[c](d);\n                as[n][P(y, x)] = d.v[F.BOTTOM];\n            }\n        }\n\n        auto dp = new int[1<<N];\n        dp[] = 0;\n        foreach (int k; 0 .. N) {\n            int bit = (1<<k) - 1;\n            while (bit < (1<<N)) {\n\n                foreach (i; 0 .. N) {\n                    // try to drop the i-th dice\n                    if ((1 << i) & bit) continue; // already dropped\n\n                    int r = dp[bit]; // r: current score when drop the i-th dice after dropped 'bit' dices\n\n                    foreach (p, v; as[i]) {\n                        bool overwritten() {\n                            foreach (int j; 0 .. N) {\n                                if (bit & (1 << j)) continue;\n                                if (i == j) continue;\n                                if (p in as[j]) return true;\n                            }\n                            return false;\n                        }\n                        if (overwritten()) continue;\n                        r += v;\n                    }\n                    dp[bit | 1<<i] = max(dp[bit | 1<<i], r);\n                }\n\n                int x = bit & -bit;\n                int y = bit + x;\n                if (x == 0) break;\n                bit = ((bit & ~y) / x >> 1) | y;\n            }\n        }\n        writeln(dp[(1<<N) - 1]);\n    }\n\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.string;\nimport std.container;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\n\nstruct Dice {\n    enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n    /*\n                                           z??????\n                                           |\n                                           |\n                                           |\n                                           |\n                                          / ------------------/\n                                         /                   /|\n                                        /                   / |\n                                       /        TOP        /  |\n                                      /                   /   |\n                                     /                   /    |\n                                    |-------------------|     |\n                                    |                   |RIGHT|\n                                    |                   |     |_______________ x??????\n                                    |                   |    /\n                                    |       FRONT       |   /\n                                    |                   |  /\n                                    |                   | /\n                                    |                   |/\n                                    |-------------------|\n                                   /\n                                  /\n                                 /\n                                /\n                              y??????\n    */\n    int[6] v;\n    this(int top, int front, int right) {\n        v[FACE.TOP]   = top;    v[FACE.BOTTOM] = 7 - top;\n        v[FACE.FRONT] = front;  v[FACE.BACK]   = 7 - front;\n        v[FACE.RIGHT] = right;  v[FACE.LEFT]   = 7 - right;\n    }\n    // clockwise\n    void rollX() { roll(FACE.TOP,  FACE.FRONT,  FACE.BOTTOM, FACE.BACK); }\n    void rollY() { roll(FACE.TOP,  FACE.LEFT,   FACE.BOTTOM, FACE.RIGHT); }\n    void rollZ() { roll(FACE.FRONT, FACE.RIGHT, FACE.BACK,   FACE.LEFT); }\n    void roll(int a, int b, int c, int d) {\n        int t = v[a];\n        v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n    }\n    Dice[] allStates() immutable {\n        Dice d = this;\n        Dice[] r;\n        foreach (i; 0 .. 6) {\n            if (i % 2 == 0) d.rollX();\n            else            d.rollY();\n            foreach (j; 0 .. 4) {\n                d.rollZ();\n                r ~= d;\n            }\n        }\n        return r;\n    }\n    bool sameDice(in Dice d) immutable {\n        Dice[] states = allStates();\n        return states.any!((a) => a.v == d.v);\n    }\n    string toString() {\n        return \"Dice\" ~ v.to!string;\n    }\n}\n\nvoid main() {\n    alias F = Dice.FACE;\n    immutable F[] input_order = [F.LEFT, F.RIGHT, F.FRONT, F.BACK, F.BOTTOM, F.TOP];\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    auto order = [\n        'L': (ref Dice d) { foreach (_; 0 .. 3) d.rollY(); },\n        'R': (ref Dice d) { d.rollY(); },\n        'F': (ref Dice d) { foreach (_; 0 .. 3) d.rollX(); },\n        'B': (ref Dice d) { d.rollX(); },\n    ];\n\n\n    int[char] dy = [ 'L': 0, 'R': 0, 'F': -1, 'B': 1 ];\n    int[char] dx = [ 'L': -1, 'R': 1, 'F': 0, 'B': 0 ];\n\n    while (true) {\n        int N;\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto as = new int[P][N];\n        foreach (n; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            int[] faces = readln.chomp.split(\" \").map!(to!int).array;\n            string rot = readln.chomp;\n            Dice d;\n            foreach (i; 0 .. 6) {\n                d.v[ input_order[i] ] = faces[i];\n            }\n            as[n][P(y, x)] = d.v[F.BOTTOM];\n            foreach (c; rot) {\n                y += dy[c];\n                x += dx[c];\n                order[c](d);\n                as[n][P(y, x)] = d.v[F.BOTTOM];\n            }\n        }\n\n        auto dp = new int[1<<N];\n        dp[] = 0;\n        foreach (int k; 0 .. N) {\n            int bit = (1<<k) - 1;\n            while (bit < (1<<N)) {\n\n                foreach (i; 0 .. N) {\n                    // try to drop the i-th dice\n                    if ((1 << i) & bit) continue; // already dropped\n\n                    int r = dp[bit]; // r: current score when drop the i-th dice after dropped 'bit' dices\n\n                    bool[P] overwritten; // blocks overwritten later when 'bit' dices have dropped\n                    foreach (int j; 0 .. N) {\n                        if (bit & (1 << j)) continue;\n                        if (i == j) continue;\n                        foreach (x; as[j].keys) {\n                            overwritten[x] = true;\n                        }\n                    }\n\n                    foreach (p, v; as[i]) {\n                        if (p in overwritten) continue;\n                        r += v;\n                    }\n                    dp[bit | 1<<i] = max(dp[bit | 1<<i], r);\n                }\n\n                int x = bit & -bit;\n                int y = bit + x;\n                if (x == 0) break;\n                bit = ((bit & ~y) / x >> 1) | y;\n            }\n        }\n        writeln(dp[(1<<N) - 1]);\n    }\n\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.string;\nimport std.container;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\n\nstruct Dice {\n    enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n    /*\n                                           z??????\n                                           |\n                                           |\n                                           |\n                                           |\n                                          / ------------------/\n                                         /                   /|\n                                        /                   / |\n                                       /        TOP        /  |\n                                      /                   /   |\n                                     /                   /    |\n                                    |-------------------|     |\n                                    |                   |RIGHT|\n                                    |                   |     |_______________ x??????\n                                    |                   |    /\n                                    |       FRONT       |   /\n                                    |                   |  /\n                                    |                   | /\n                                    |                   |/\n                                    |-------------------|\n                                   /\n                                  /\n                                 /\n                                /\n                              y??????\n    */\n    int[6] v;\n    this(int top, int front, int right) {\n        v[FACE.TOP]   = top;    v[FACE.BOTTOM] = 7 - top;\n        v[FACE.FRONT] = front;  v[FACE.BACK]   = 7 - front;\n        v[FACE.RIGHT] = right;  v[FACE.LEFT]   = 7 - right;\n    }\n    // ?????¶?????????????????¨??\\?±???§???    void rollX() { roll(FACE.TOP,  FACE.FRONT,  FACE.BOTTOM, FACE.BACK); }\n    void rollY() { roll(FACE.TOP,  FACE.LEFT,   FACE.BOTTOM, FACE.RIGHT); }\n    void rollZ() { roll(FACE.FRONT, FACE.RIGHT, FACE.BACK,   FACE.LEFT); }\n    void roll(int a, int b, int c, int d) {\n        int t = v[a];\n        v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n    }\n    Dice[] allStates() immutable {\n        Dice d = this;\n        Dice[] r;\n        foreach (i; 0 .. 6) {\n            if (i % 2 == 0) d.rollX();\n            else            d.rollY();\n            foreach (j; 0 .. 4) {\n                d.rollZ();\n                r ~= d;\n            }\n        }\n        return r;\n    }\n    bool sameDice(in Dice d) immutable {\n        Dice[] states = allStates();\n        return states.any!((a) => a.v == d.v);\n    }\n    string toString() {\n        return \"Dice\" ~ v.to!string;\n    }\n}\n\nvoid main() {\n    alias F = Dice.FACE;\n    immutable F[] input_order = [F.LEFT, F.RIGHT, F.FRONT, F.BACK, F.BOTTOM, F.TOP];\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    auto order = [\n        'L': (ref Dice d) { foreach (_; 0 .. 3) d.rollY(); },\n        'R': (ref Dice d) { d.rollY(); },\n        'F': (ref Dice d) { foreach (_; 0 .. 3) d.rollX(); },\n        'B': (ref Dice d) { d.rollX(); },\n    ];\n\n\n    int[char] dy = [ 'L': 0, 'R': 0, 'F': -1, 'B': 1 ];\n    int[char] dx = [ 'L': -1, 'R': 1, 'F': 0, 'B': 0 ];\n\n    while (true) {\n        int N;\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto as = new int[P][N];\n        foreach (n; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            int[] faces = readln.chomp.split(\" \").map!(to!int).array;\n            string rot = readln.chomp;\n            Dice d;\n            foreach (i; 0 .. 6) {\n                d.v[ input_order[i] ] = faces[i];\n            }\n            as[n][P(y, x)] = d.v[F.BOTTOM];\n            foreach (c; rot) {\n                y += dy[c];\n                x += dx[c];\n                order[c](d);\n                as[n][P(y, x)] = d.v[F.BOTTOM];\n            }\n        }\n\n        auto overwritten = new bool[P][1<<N]; // blocks overwritten later when 'bit' dices have dropped\n        foreach (int bit; 0 .. (1<<N)) {\n            foreach (int j; 0 .. N) {\n                if (bit & (1 << j)) continue;\n                foreach (x; as[j].keys) {\n                    overwritten[bit][x] = true;\n                }\n            }\n        }\n\n        auto dp = new int[1<<N];\n        dp[] = 0;\n        foreach (int k; 0 .. N) {\n            int bit = (1<<k) - 1;\n            while (bit < (1<<N)) {\n\n                foreach (i; 0 .. N) {\n                    // try to drop the i-th dice\n                    if ((1 << i) & bit) continue; // already dropped\n\n                    int r = dp[bit]; // r: current score when drop the i-th dice after dropped 'bit' dices\n                    auto w = overwritten[bit | 1<<i];\n                    foreach (p, v; as[i]) {\n                        if (p in w) continue;\n                        r += v;\n                    }\n                    dp[bit | 1<<i] = max(dp[bit | 1<<i], r);\n                }\n\n                int x = bit & ~bit;\n                int y = bit + x;\n                if (x == 0) break;\n                bit = ((bit & ~y) / x >> 1) | y;\n            }\n        }\n        writeln(dp[(1<<N) - 1]);\n    }\n\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.string;\nimport std.container;\nimport std.typecons;\nimport core.memory;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\n\nstruct Dice {\n    enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n    /*\n                                           z??????\n                                           |\n                                           |\n                                           |\n                                           |\n                                          / ------------------/\n                                         /                   /|\n                                        /                   / |\n                                       /        TOP        /  |\n                                      /                   /   |\n                                     /                   /    |\n                                    |-------------------|     |\n                                    |                   |RIGHT|\n                                    |                   |     |_______________ x??????\n                                    |                   |    /\n                                    |       FRONT       |   /\n                                    |                   |  /\n                                    |                   | /\n                                    |                   |/\n                                    |-------------------|\n                                   /\n                                  /\n                                 /\n                                /\n                              y??????\n    */\n    int[6] v;\n    this(int top, int front, int right) {\n        v[FACE.TOP]   = top;    v[FACE.BOTTOM] = 7 - top;\n        v[FACE.FRONT] = front;  v[FACE.BACK]   = 7 - front;\n        v[FACE.RIGHT] = right;  v[FACE.LEFT]   = 7 - right;\n    }\n    // clockwise\n    void rollX() { roll(FACE.TOP,  FACE.FRONT,  FACE.BOTTOM, FACE.BACK); }\n    void rollY() { roll(FACE.TOP,  FACE.LEFT,   FACE.BOTTOM, FACE.RIGHT); }\n    void rollZ() { roll(FACE.FRONT, FACE.RIGHT, FACE.BACK,   FACE.LEFT); }\n    void roll(int a, int b, int c, int d) {\n        int t = v[a];\n        v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n    }\n    Dice[] allStates() immutable {\n        Dice d = this;\n        Dice[] r;\n        foreach (i; 0 .. 6) {\n            if (i % 2 == 0) d.rollX();\n            else            d.rollY();\n            foreach (j; 0 .. 4) {\n                d.rollZ();\n                r ~= d;\n            }\n        }\n        return r;\n    }\n    bool sameDice(in Dice d) immutable {\n        Dice[] states = allStates();\n        return states.any!((a) => a.v == d.v);\n    }\n    string toString() {\n        return \"Dice\" ~ v.to!string;\n    }\n}\n\nvoid main() {\n    alias F = Dice.FACE;\n    immutable F[] input_order = [F.LEFT, F.RIGHT, F.FRONT, F.BACK, F.BOTTOM, F.TOP];\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    auto order = [\n        'L': (ref Dice d) { foreach (_; 0 .. 3) d.rollY(); },\n        'R': (ref Dice d) { d.rollY(); },\n        'F': (ref Dice d) { foreach (_; 0 .. 3) d.rollX(); },\n        'B': (ref Dice d) { d.rollX(); },\n    ];\n\n\n    int[char] dy = [ 'L': 0, 'R': 0, 'F': -1, 'B': 1 ];\n    int[char] dx = [ 'L': -1, 'R': 1, 'F': 0, 'B': 0 ];\n\n    while (true) {\n        int N;\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto as = new int[P][N];\n        foreach (n; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            int[] faces = readln.chomp.split(\" \").map!(to!int).array;\n            string rot = readln.chomp;\n            Dice d;\n            foreach (i; 0 .. 6) {\n                d.v[ input_order[i] ] = faces[i];\n            }\n            as[n][P(y, x)] = d.v[F.BOTTOM];\n            foreach (c; rot) {\n                y += dy[c];\n                x += dx[c];\n                order[c](d);\n                as[n][P(y, x)] = d.v[F.BOTTOM];\n            }\n        }\n\n        auto overwritten = new bool[P][1<<N]; // blocks overwritten later when 'bit' dices have dropped\n        foreach (int bit; 0 .. (1<<N)) {\n            foreach (int j; 0 .. N) {\n                if (bit & (1 << j)) continue;\n                foreach (x; as[j].keys) {\n                    overwritten[bit][x] = true;\n                }\n            }\n        }\n\n        auto dp = new int[1<<N];\n        dp[] = 0;\n        foreach (int k; 0 .. N) {\n            int bit = (1<<k) - 1;\n            while (bit < (1<<N)) {\n\n                foreach (i; 0 .. N) {\n                    // try to drop the i-th dice\n                    if ((1 << i) & bit) continue; // already dropped\n\n                    int r = dp[bit]; // r: current score when drop the i-th dice after dropped 'bit' dices\n                    const w = overwritten[bit | 1<<i];\n                    foreach (p, v; as[i]) {\n                        if (p in w) continue;\n                        r += v;\n                    }\n                    dp[bit | 1<<i] = max(dp[bit | 1<<i], r);\n                }\n\n                int x = bit & ~bit;\n                int y = bit + x;\n                if (x == 0) break;\n                bit = ((bit & ~y) / x >> 1) | y;\n            }\n        }\n        writeln(dp[(1<<N) - 1]);\n        GC.collect();\n    }\n\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.algorithm;\nimport std.string;\nimport std.container;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\n\nstruct Dice {\n    enum FACE { TOP, FRONT, RIGHT, BOTTOM, BACK, LEFT };\n    /*\n                                           z??????\n                                           |\n                                           |\n                                           |\n                                           |\n                                          / ------------------/\n                                         /                   /|\n                                        /                   / |\n                                       /        TOP        /  |\n                                      /                   /   |\n                                     /                   /    |\n                                    |-------------------|     |\n                                    |                   |RIGHT|\n                                    |                   |     |_______________ x??????\n                                    |                   |    /\n                                    |       FRONT       |   /\n                                    |                   |  /\n                                    |                   | /\n                                    |                   |/\n                                    |-------------------|\n                                   /\n                                  /\n                                 /\n                                /\n                              y??????\n    */\n    int[6] v;\n    this(int top, int front, int right) {\n        v[FACE.TOP]   = top;    v[FACE.BOTTOM] = 7 - top;\n        v[FACE.FRONT] = front;  v[FACE.BACK]   = 7 - front;\n        v[FACE.RIGHT] = right;  v[FACE.LEFT]   = 7 - right;\n    }\n    // clockwise\n    void rollX() { roll(FACE.TOP,  FACE.FRONT,  FACE.BOTTOM, FACE.BACK); }\n    void rollY() { roll(FACE.TOP,  FACE.LEFT,   FACE.BOTTOM, FACE.RIGHT); }\n    void rollZ() { roll(FACE.FRONT, FACE.RIGHT, FACE.BACK,   FACE.LEFT); }\n    void roll(int a, int b, int c, int d) {\n        int t = v[a];\n        v[a] = v[b]; v[b] = v[c]; v[c] = v[d]; v[d] = t;\n    }\n    Dice[] allStates() immutable {\n        Dice d = this;\n        Dice[] r;\n        foreach (i; 0 .. 6) {\n            if (i % 2 == 0) d.rollX();\n            else            d.rollY();\n            foreach (j; 0 .. 4) {\n                d.rollZ();\n                r ~= d;\n            }\n        }\n        return r;\n    }\n    bool sameDice(in Dice d) immutable {\n        Dice[] states = allStates();\n        return states.any!((a) => a.v == d.v);\n    }\n    string toString() {\n        return \"Dice\" ~ v.to!string;\n    }\n}\n\nvoid main() {\n    alias F = Dice.FACE;\n    immutable F[] input_order = [F.LEFT, F.RIGHT, F.FRONT, F.BACK, F.BOTTOM, F.TOP];\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    auto order = [\n        'L': (ref Dice d) { foreach (_; 0 .. 3) d.rollY(); },\n        'R': (ref Dice d) { d.rollY(); },\n        'F': (ref Dice d) { foreach (_; 0 .. 3) d.rollX(); },\n        'B': (ref Dice d) { d.rollX(); },\n    ];\n\n\n    int[char] dy = [ 'L': 0, 'R': 0, 'F': -1, 'B': 1 ];\n    int[char] dx = [ 'L': -1, 'R': 1, 'F': 0, 'B': 0 ];\n\n    while (true) {\n        int N;\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto as = new int[P][N];\n        foreach (n; 0 .. N) {\n            int x, y;\n            scanf(\"%d %d\\n\", &x, &y);\n            int[] faces = readln.chomp.split(\" \").map!(to!int).array;\n            string rot = readln.chomp;\n            Dice d;\n            foreach (i; 0 .. 6) {\n                d.v[ input_order[i] ] = faces[i];\n            }\n            as[n][P(y, x)] = d.v[F.BOTTOM];\n            foreach (c; rot) {\n                y += dy[c];\n                x += dx[c];\n                order[c](d);\n                as[n][P(y, x)] = d.v[F.BOTTOM];\n            }\n        }\n\n        auto overwritten = new bool[P][1<<N]; // blocks overwritten later when 'bit' dices have dropped\n        foreach (int bit; 0 .. (1<<N)) {\n            foreach (int j; 0 .. N) {\n                if (bit & (1 << j)) continue;\n                foreach (x; as[j].keys) {\n                    overwritten[bit][x] = true;\n                }\n            }\n        }\n\n        auto dp = new int[1<<N];\n        dp[] = 0;\n        foreach (int k; 0 .. N) {\n            int bit = (1<<k) - 1;\n            while (bit < (1<<N)) {\n\n                foreach (i; 0 .. N) {\n                    // try to drop the i-th dice\n                    if ((1 << i) & bit) continue; // already dropped\n\n                    int r = dp[bit]; // r: current score when drop the i-th dice after dropped 'bit' dices\n                    const w = overwritten[bit | 1<<i];\n                    foreach (p, v; as[i]) {\n                        if (p in w) continue;\n                        r += v;\n                    }\n                    dp[bit | 1<<i] = max(dp[bit | 1<<i], r);\n                }\n\n                int x = bit & ~bit;\n                int y = bit + x;\n                if (x == 0) break;\n                bit = ((bit & ~y) / x >> 1) | y;\n            }\n        }\n        writeln(dp[(1<<N) - 1]);\n    }\n\n\n}"
  },
  {
    "language": "Python",
    "code": "def main():\n  while True:\n    n = int(input())\n    if n == 0:break\n    def spin(dice, direct):\n      l, r, f, b, d, u = dice\n      if direct == \"R\":\n        return [d, u, f, b, r, l]\n      if direct == \"L\":\n        return [u, d, f, b, l, r]\n      if direct == \"B\":\n        return [l, r, d, u, b, f]\n      if direct == \"F\":\n        return [l, r, u, d, f, b]\n    \n    def move(x, y, direct):\n      if direct == \"R\":\n        return x + 1, y\n      if direct == \"L\":\n        return x - 1, y\n      if direct == \"B\":\n        return x, y + 1\n      if direct == \"F\":\n        return x, y - 1\n    \n    update_lst = []\n    for _ in range(n):\n      x, y = map(int, input().split())\n      dice = list(map(int, input().split()))\n      rot = input()\n      update_point = {}\n      update_point[(x, y)] = dice[-2]\n      for direct in rot:\n        dice = spin(dice, direct)\n        x, y = move(x, y, direct)\n        update_point[(x, y)] = dice[-2]\n      update_lst.append(update_point)\n    \n    used_lst = [set() for _ in range(2 ** n)]\n    mask = 1\n    for i in range(n):\n      keys = set(update_lst[i].keys())\n      for j in range(2 ** n):\n        if not (mask & j): continue\n        used_lst[j] |= keys\n      mask <<= 1\n  \n    add_score = {}\n    mask = 1\n    for i in range(n):\n      update_point = update_lst[i]\n      for j in range(2 ** n):\n        if mask & j: continue\n        used_point = used_lst[j]\n        add = 0\n        for k, v in update_point.items():\n          if k not in used_point:\n            add += v\n        add_score[(j, mask)] = add\n      mask <<= 1\n    \n    dic = {}\n    end = 2 ** n - 1\n    def max_score(stat):\n      if stat in dic:return dic[stat]\n      if stat == end:return 0\n      \n      ret = 0\n      mask = 1\n      for i in range(n):\n        if stat & mask:\n          mask <<= 1\n          continue\n        ret = max(ret, add_score[(stat, mask)] + max_score(stat | mask))\n        mask <<= 1\n      dic[stat] = ret\n      return ret\n    \n    print(max_score(0))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nD = [\n    (2, 1, 5, 0, 4, 3), # 'L'\n    (1, 5, 2, 3, 0, 4), # 'U'\n    (3, 1, 0, 5, 4, 2), # 'R'\n    (4, 0, 2, 3, 5, 1), # 'D'\n]\ndef rotate_dice(L, k):\n    return [L[e] for e in D[k]]\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n\ndef solve():\n    D = \"LBRF\"\n\n    N = int(readline())\n    if N == 0:\n        return False\n\n    PS = []\n    memo = [-1]*(1 << N)\n    def dfs(state, us):\n        res = 0\n        if memo[state] != -1:\n            return memo[state]\n        for i in range(N):\n            if state & (1 << i):\n                continue\n            vs = set(us)\n            r = 0\n            for x, y, e in PS[i]:\n                k = (x, y)\n                if k in vs:\n                    continue\n                vs.add(k)\n                r += e\n            res = max(res, dfs(state | (1 << i), vs) + r)\n        memo[state] = res\n        return res\n\n    for i in range(N):\n        x, y = map(int, readline().split()); y = -y\n        l, r, f, b, d, u = map(int, readline().split())\n        L = [u, f, r, l, b, d]\n        s = readline().strip()\n        P = [(x, y, d)]\n        for e in map(D.index, s):\n            dx, dy = dd[e]\n            L = rotate_dice(L, e)\n            x += dx; y += dy\n            P.append((x, y, L[-1]))\n        P.reverse()\n        PS.append(P)\n    write(\"%d\\n\" % dfs(0, set()))\n    return True\nwhile solve():\n    ...\n"
  }
]