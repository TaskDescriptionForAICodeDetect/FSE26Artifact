[
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<(int)n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-100;\n      \n      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n      rep(i,dist[ff+inp[p]].size() ){\n\t//for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n      \n      //if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    \n  }\n  \n}\n\n#define N 1000\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<vector<int> > solve(vector<int> v)\n{\n\tvector<vector<int> > res;\n\tvector<int> parent;\n\tvector<int> sizes;\n\tparent.push_back(0);\n\tparent.push_back(0);\n\tsizes.push_back(v[0]);\n\tsizes.push_back(v[1]);\n\tvector<int> tmp;\n\ttmp.push_back(1);\n\tres.push_back(tmp);\n\ttmp.clear();\n\ttmp.push_back(0);\n\tres.push_back(tmp);\n\tint nownum = 1;\n\tfor(int i = 2; i < v.size(); i++){\n\t\tif(v[i] > 0){\n\t\t\tparent.push_back(nownum);\n\t\t\tsizes.push_back(v[i]);\n\t\t\tres[nownum].push_back(res.size());\n\t\t\ttmp.clear();\n\t\t\ttmp.push_back(nownum);\n\t\t\tres.push_back(tmp);\n\t\t\tnownum = res.size() - 1;\n\t\t} else {\n\t\t\tint partner = nownum;\n\t\t\tfor(int j = 0; j < -v[i]; j++){\n\t\t\t\tpartner = parent[partner];\n\t\t\t}\n\t\t\tres[partner].push_back(nownum);\n\t\t\tres[nownum].push_back(partner);\n\t\t\tif(res[nownum].size() == sizes[nownum]) nownum = parent[nownum];\n\t\t}\n\t}\n\t// for(int i = 0; i < res.size(); i++){\n\t// \tcout << i + 1 << \" \" << parent[i] + 1 << endl;\n\t// }\n\t// cout << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tvector<int> v;\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\twhile(tmp != 0){\n\t\t\tv.push_back(tmp);\n\t\t\tcin >> tmp;\n\t\t}\n\t\tvector<vector<int> > res = solve(v);\n\t\tfor(int i = 0; i < res.size(); i++){\n\t\t\tcout << i + 1 << \" \";\n\t\t\tsort(res[i].begin(), res[i].end());\n\t\t\tfor(int j = 0; j < res[i].size(); j++){\n\t\t\t\tcout << res[i][j] + 1;\n\t\t\t\tif(j == res[i].size() - 1) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(int *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff]=node;\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to = dist[ff+inp[p]];\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      assert(en[node]>0 && en[to]>0);\n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    int n,dist[N]={0},en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[cnt] = now;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      --sz[num[dd + cnt]];\n      g[num[dd + cnt]].push_back(now);\n      g[now].push_back(num[dd + cnt]);\n    } else if(dd > 0) {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    cin >> sz[0];\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nvoid solve() {\n  vector<int> R;\n  int n = 0;\n  for(int i; cin >> i, i; ) {\n    R.pb(i);\n    if (R[SZ(R)-1] > 0) n++;\n  }\n\n  int degs[110];\n  vector<int> G[110];\n  vector<int> path;\n  int cur = 0;\n  int cnt = 0;\n  rep(i, SZ(R)) {\n    if (R[i] > 0) {\n      cur = ++cnt;\n      degs[cnt] = R[i];\n      path.pb(cnt);\n      if (i) {\n        int prev = path[SZ(path)-2];\n        G[prev].pb(cur);\n        G[cur].pb(prev);\n      }\n    } else {\n      int t = path[SZ(path) + R[i] - 1];\n      G[t].pb(cur);\n      G[cur].pb(t);\n      while(G[cur].size() == degs[cur]) {\n        path.pop_back();\n        cur = path[SZ(path)-1];\n      }\n    }\n  }\n\n  rep(i, n) {\n    cout << i+1;\n    sort(ALL(G[i+1]));\n\n    rep(j, SZ(G[i+1])) {\n      cout << \" \" << G[i+1][j];\n    }\n    cout << endl;\n  }\n}\nint main() {\n  int n; cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\nint sgn(const double&r){return (r>EPS)-(r<-EPS);} // a>0  : sgn(a)>0\nint sgn(const double&a,const double&b){return sgn(a-b);} // b<=c : sgn(b,c)<=0\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll _n; cin>>_n;\n    rep(_,_n){\n        vl data;\n        ll tmp;\n        while(cin>>tmp,tmp){data.push_back(tmp);}\n        ll n=data.size();\n        vvl ans(1);\n        vl cap(1);\n        vl par(101,0);\n        ll depth=0, cur=1;\n\n\n        rep(i,data.size()){\n            ll d=data[i];\n            // puta(i,\":\",d,\"->\", depth, cur);\n            // puta(cap);\n            \n            if(cap.size()!=1 and cap[cur]<=0){\n                i--;\n                depth--;\n                // puta(cur,\"がいっぱい\", par[depth], \"に戻る\");\n                cur=par[depth];\n                continue;\n            }\n\n\n            if(d>0){\n                ans.push_back(vl(0));\n                cap.push_back(d);\n                cur = ans.size()-1;\n                if(depth){\n                    ans[cur].push_back(par[depth]);\n                    cap[cur]--;\n                    ans[par[depth]].push_back(cur);\n                    cap[par[depth]]--;\n                }\n                depth++;\n                par[depth]=cur;\n            }else{\n                ans[cur].push_back(par[depth+d]);\n                cap[cur]--;\n                ans[par[depth+d]].push_back(cur);\n                cap[par[depth+d]]--;\n            }\n            // rep(j,ans.size())puta(j,\":\",ans[j], \"cap=\", cap[j]);\n            // cerr<<\"\"<<endl;\n\n        }\n        range(j,1,ans.size()){\n            sort(all(ans[j]));\n            puta(j,ans[j]);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < now; j++) {\n        if(num[j] - cnt == dd && sz[j] > 1) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n        }\n      }\n    } else {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n    cin >> sz[0];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef complex<double> xy_t;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int n;\n  string tmp;\n  cin >> n;\n  getline(cin, tmp);\n  \n  while(n--){\n    getline(cin, tmp);\n    istringstream in(tmp);\n\n    int rec;\n    vector<int> record;\n    while(in >> rec) record.push_back(rec);\n    \n    int count = 0;\n    int depth = 0;\n    int vs[2000];\n    int unopen[2000];\n    vector<int> G[2000];\n\n    REP(i, record.size() - 1){\n      while(depth > 1 && unopen[depth] == 0) depth--;\n      \n      unopen[depth]--;\n      if(record[i] > 1){\n\tvs[++depth]   = ++count;\n\tunopen[depth] = record[i] - 1;\n\t\n\tif(depth > 1){\n\t  G[count].push_back(vs[depth-1]);\n\t  G[vs[depth-1]].push_back(count);\n\t}\n      }else{\n\tG[vs[depth + record[i]]].push_back(vs[depth]);\n\tG[vs[depth]].push_back(vs[depth + record[i]]);\n\tunopen[depth + record[i]]--;\n      }\n    }\n    \n    REP2(i, 1, count + 1){\n      cout << i;\n      sort(ALL(G[i]));\n      REP(j, G[i].size()) cout << \" \" << G[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nmap<int,vector<int> > m;\nint a[100];\nint nr;\n\nvoid dfs(int d){\n  int r;\n  cin>>r;\n  if(r==0){\n    throw 0;\n  }else if(r>0){\n    nr++;\n    a[d]=nr;\n    if(d){\n      m[a[d]].push_back(a[d-1]);\n      m[a[d-1]].push_back(a[d]);\n    }\n    for(int i=0;i<r-1;i++){\n      dfs(d+1);\n    }\n  }else{\n    m[a[d-1]].push_back(a[d-1+r]);\n    m[a[d-1+r]].push_back(a[d-1]);\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    m.clear();\n    nr=0;\n    try{\n      dfs(0);\n    }catch(...){};\n    for(auto e:m){\n      cout<<e.first;\n      sort(begin(e.second),end(e.second));\n      for(auto f:e.second){\n\tcout<<' '<<f;\n      }\n      cout<<endl;\n    }\n  }\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nvector<int> to[1000];\nint distnum[1000], door[1000];\nvoid init(){\n    rep(i, 1000) to[i].clear();\n    memset(distnum, 0, sizeof(distnum));\n    memset(door, 0, sizeof(door));\n}\nint main(){\n    int T; scanf(\"%d\", &T);\n    int _t;\n    rep(casenum, T){\n        init();\n        scanf(\"%d\", &_t);\n        int count = 0, dist = 0;\n        distnum[++dist] = ++count;\n        door[dist] = _t;\n        while(scanf(\"%d\", &_t) && _t){\n            while(dist > 0 && door[dist] == 0)\n              --dist;\n            --door[dist];\n            if(_t > 0){\n                distnum[++dist] = ++count;\n                door[dist] = _t - 1;\n                to[count].push_back(distnum[dist - 1]);\n                to[distnum[dist - 1]].push_back(count);\n            }else{\n                to[distnum[dist + _t]].push_back(distnum[dist]);\n                to[distnum[dist]].push_back(distnum[dist + _t]);\n                door[dist + _t]--;\n            }\n        }\n\n        REP(i, 1, count + 1){\n            printf(\"%d\", i);\n            sort(to[i].begin(), to[i].end());\n            rep(j, to[i].size())\n              printf(\" %d\", to[i][j]);\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < 1001; j++) {\n        if(num[j] - cnt == dd && sz[j] > 1) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n          break;\n        }\n      }\n    } else {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n    cin >> sz[0];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    vector<int> R;\n    void input() {\n        R.clear();\n        while (true) {\n            int x; cin >> x;\n            if (x == 0) break;\n            R.push_back(x);\n        }\n    }\n\n    vector< vector<int> > G;\n    int N;\n    vector<int> Z;\n\n    void dfs(int v, int& c, int d, vector<int>& x, int& nv) {\n        if (c == R.size()) return;\n        //cout << v << \" \" << c << \" \" << d << \" \" << x << endl;\n        int p = x[d];\n        x[d] = v;\n        while (c < R.size() && Z[v] > 0) {\n            int r = R[c];\n            if (r > 0) {\n                G[v].push_back(nv);\n                G[nv].push_back(v);\n                Z[v]--; Z[nv]--;\n                c++;\n                int n = nv; nv++;\n                dfs(n, c, d + 1, x, nv);\n            } else {\n                int n = x[d + r];\n                //cout << \"connect \" << v << \" \" << n << endl;\n                G[v].push_back(n);\n                G[n].push_back(v);\n                Z[v]--; Z[n]--;\n                c++;\n            }\n        }\n        x[d] = p;\n    }\n\n    void solve() {\n        Z.clear();\n        for (int i = 0; i < R.size(); i++) {\n            int r = R[i];\n            if (r > 0) {\n                Z.push_back(r);\n            }\n        }\n        N = int(Z.size());\n        G.clear(); G.resize(N);\n        vector<int> x(N, -1);\n        int c = 1;\n        int nv = 1;\n        dfs(0, c, 0, x, nv);\n        for (int i = 0; i < N; i++) {\n            sort(G[i].begin(), G[i].end());\n            int M = G[i].size();\n            cout << i + 1;\n            for (int j = 0; j < M; j++) {\n                cout << \" \" << G[i][j] + 1;\n            }\n            cout << endl;\n        }\n    }\n}\n\nint main() {\n    int N; cin >> N;\n    for (int i = 0; i < N; i++) {\n        input(); solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to;\n      rep(i,dist[ff+inp[p]].size() ){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n      }\n\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 1000\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1236>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nvector<vector<int>> G;\nvector<int> memo;\nvector<pii> roomdoor;\nmap<int,pii> mp;\nvoid dfs(int dep,int& i){\n    if(i >= memo.size()) return;\n    int idx = i;\n    int n = roomdoor[i].second;\n    mp[dep] = {i,n};\n    \n    i++;\n    while(i < memo.size()){\n        if(roomdoor[idx].first == 0) break;\n        if(memo[i] > 0){\n            int next = roomdoor[i].second;\n            G[n].push_back(next);\n            G[next].push_back(n);\n            roomdoor[idx].first--; roomdoor[i].first--;\n            dfs(dep+1,i);\n        }else{\n            \n            pii p = mp[dep+memo[i]];\n\n            int nextidx = p.first;\n            int next = p.second;\n            \n            G[n].push_back(next);\n            G[next].push_back(n);\n            \n            roomdoor[idx].first--; roomdoor[nextidx].first--;\n            i++;\n        }\n    }\n}\nvoid solve(){\n    mp.clear();\n    memo.clear();\n    roomdoor.clear();\n    G.clear();\n    int x; while(cin >> x,x) memo.push_back(x);\n    roomdoor.assign(memo.size(),{0,0});\n    int V = 0;\n    for(int i = 0; i < memo.size();i++){\n        if(memo[i] < 0) continue;\n        roomdoor[i] = {memo[i],V++};\n    }\n    G.resize(V);\n    int i = 0;\n    dfs(0,i);\n    for(int i = 0; i < V;i++){\n        cout << i + 1 << \" \";\n        sort(G[i].begin(),G[i].end());\n        cout << G[i] << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n; cin >> n;\n    while(n--){\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nqueue<int> record;\n\nvector<int> graph[101];\nint doors[101];\nint dist[101];\nint d2i[101]; // ??¢?´¢???(????????????|??????????????????)??¨?????¨?????????????????°???????????????????????????????????§????????¬?????§?????¢?????????\n\nvoid dfs(int& l_vis, int par)\n{\n  int now = l_vis;\n  dist[now] = (~par ? dist[par] + 1 : 0LL);\n  d2i[dist[now]] = now;\n  \n  while(doors[now] && record.size()) {\n    //assert(record.size());\n    int r = record.front(); record.pop();\n    \n    if(r > 0) {\n      doors[now]--; l_vis++;\n      graph[now].push_back(l_vis);\n      graph[l_vis].push_back(now);\n      doors[l_vis] = r - 1;\n      dfs(l_vis, now);\n    } else if(r < 0) {\n      int d = r + dist[now];\n      doors[now]--, doors[d2i[d]]--;\n      graph[now].push_back(d2i[d]);\n      graph[d2i[d]].push_back(now);\n    }\n    \n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N; cin >> N;\n  while(N--) {\n    for(auto& g : graph) g.clear();\n    memset(doors, 0, sizeof(doors));\n    memset(dist, -1, sizeof(dist));\n    memset(d2i, -1, sizeof(d2i));\n    \n    int memo;\n    while(cin >> memo, memo) record.push(memo);\n    doors[0] = record.front(); record.pop();\n\n    int l_vis = 0;\n    dfs(l_vis, -1);\n\n    rep(i, l_vis+1) {\n      cout << i+1;\n      sort(all(graph[i]));\n      rep(j, graph[i].size()) cout << \" \" << graph[i][j]+1;\n      cout << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n    for (auto it = mp.begin(); it != mp.end(); ++it) {\n        if (it != mp.begin()) {\n            os << \", \";\n        }\n        os << *it;\n    }\n    return os << \"]\";\n}\n\n// edit\n\nvoid add_edge(vector<vector<int>> &G, int from, int to) {\n    G[from].push_back(to);\n    G[to].push_back(from);\n}\n\nint add_node(vector<vector<int>> &G, vector<int> &deg, int v, int d) {\n    int sz = G.size();\n    G.push_back(vector<int>());\n    deg.push_back(d);\n    if (v == -1) {\n    } else {\n        G[v].push_back(sz);\n        G[sz].push_back(v);\n    }\n    return sz;\n}\n\nvoid solve() {\n    vector<int> inp;\n    while (true) {\n        int tmp;\n        cin >> tmp;\n        if (tmp == 0) break;\n        inp.push_back(tmp);\n    }\n\n    vector<vector<int>> G;\n    vector<int> path;\n    vector<int> deg;\n\n    int v = -1; // current state\n//    path.push_back(0);\n//    G.push_back(vector<int>(0));\n\n    for (auto e : inp) {\n        while (v != -1 && G[v].size() == deg[v]) {\n            path.pop_back();\n            v = path.back();\n        }\n        if (e > 0) {\n            v = add_node(G, deg, v, e);\n            path.push_back(v);\n        } else {\n            int from = v;\n            int to = *(path.end() + e - 1);\n            add_edge(G, from, to);\n        }\n    }\n\n    for (int i = 0; i < G.size(); ++i) {\n        cout << i + 1 << \" \";\n        sort(all(G[i]));\n//        for (auto e : G[i]) {\n        for (int j = 0; j < G[i].size(); ++j) {\n            int e = G[i][j];\n            cout << e + 1;\n            if (j + 1 == G[i].size()) {\n            } else {\n                cout << \" \";\n            }\n        }\n        cout << endl;\n    }\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    int n;\n    cin >> n;\n    REP(i, n)solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvector<int> seq;\n\nint n;\nvector<int> G[100];\n\nint idx,deg[100],depth[100];\nvoid dfs(int u,int d){\n\tn++;\n\tdepth[d]=u;\n\n\twhile(G[u].size()<deg[u]){\n\t\tif(seq[idx]>0){\n\t\t\tdeg[n]=seq[idx++];\n\t\t\tG[u].push_back(n);\n\t\t\tG[n].push_back(u);\n\t\t\tdfs(n,d+1);\n\t\t}\n\t\telse{\n\t\t\tint v=depth[d+seq[idx++]];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tseq.clear();\n\t\tfor(int a;scanf(\"%d\",&a),a;) seq.push_back(a);\n\n\t\tn=0;\n\t\tidx=1;\n\t\tdeg[0]=seq[0];\n\t\trep(u,100) G[u].clear();\n\t\tdfs(0,0);\n\n\t\trep(u,n){\n\t\t\tprintf(\"%d\",u+1);\n\t\t\tsort(G[u].begin(),G[u].end());\n\t\t\trep(i,G[u].size()) printf(\" %d\",G[u][i]+1);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nvector<vector<ll>> adj(101);\nvector<ll> corr;\nll cnt=0;\n\nvoid dfs(ll w,ll n){\n    corr.push_back(w);\n    while(adj[w].size()<n){\n        ll num;\n        cin>>num;\n        if(num<0){\n            ll p=corr[corr.size()-1+num];\n            adj[p].push_back(w);\n            adj[w].push_back(p);\n        }\n        else if(num==0){corr.pop_back(); return;}\n        else{\n            cnt++;\n            adj[cnt].push_back(w);\n            adj[w].push_back(cnt);\n            dfs(cnt,num);\n        }\n    }\n    //cout<<w<<\" \"<<n<<endl;\n    corr.pop_back();\n}\n\n\nint main(){\n    ll N;\n    cin>>N;\n    while(N--){\n    corr.clear();\n    cnt=0;\n    for(int i=0;i<101;i++){\n        adj[i].clear();\n    }\n    ll num;\n    cin>>num;\n    dfs(0,num+1);\n    for(int i=0;i<=cnt;i++){\n        cout<<i+1;\n        sort(adj[i].begin(),adj[i].end());\n        for(int t=0;t<adj[i].size();t++){\n            cout<<\" \"<<adj[i][t]+1;\n        }\n        cout<<endl;\n    }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nvoid solve(int n,vector<int> r){\n    Graph g(n);\n    int idx=0;\n    vector<int> vs;\n    vector<int> d(n);\n    auto addEdge=[&](int a,int b){\n        d[a]--,d[b]--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    };\n    int p=0;\n    function<void(int)> dfs=[&](int v){\n        d[v]+=r[p++];\n        vs.push_back(v);\n        while(d[v]){\n            if(r[p]<0){\n                int to=vs[vs.size()-1+r[p]];\n                addEdge(v,to);\n                p++;\n            }\n            else{\n                int to=idx++;\n                addEdge(v,to);\n                dfs(to);\n            }\n\n        }\n        vs.pop_back();\n    };\n    dfs(idx++);\n    for(int i=0;i<n;i++){\n        sort(g[i].begin(),g[i].end());\n        cout<<i+1;\n        for(auto &v:g[i]){\n            cout<<\" \"<<v+1;\n        }\n        cout<<endl;\n    }\n\n}\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        vector<int> r;\n        int x;\n        int v=0;\n        while(cin>>x,x){\n            r.push_back(x);\n            if(x>0) v++;\n        }\n        solve(v,r);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nvoid solve()\n{\n\tvi a;\n\tfor(int x;cin>>x;){\n\t\ta.push_back(x);\n\t\tif(!x) break;\n\t}\n\t\n\tvector<pii> es;\n\tvi path(1,0),deg(1,a[0]);\n\tfor(int i=0,j=0,v=0;i<a.size()-1;i++){\n\t\tif(a[i+1]==0) break;\n\t\tif(a[i+1]<0){\n\t\t\tes.emplace_back(path[j],path[j+a[i+1]]);\n\t\t\tdeg[j]--;\n\t\t}\n\t\tif(a[i+1]>0){\n\t\t\tv++;\n\t\t\tes.emplace_back(path[j],v);\n\t\t\tpath.push_back(v);\n\t\t\tdeg.push_back(a[i+1]-1);\n\t\t\tj++;\n\t\t}\n\t\twhile(deg[j]==0){\n\t\t\tpath.pop_back();\n\t\t\tdeg.pop_back();\n\t\t\tj--;\n\t\t}\n\t}\n\t\n\tint n=0;\n\tfor(auto p:es) n=max({n,p.first,p.second});\n\t\n\tvvi g(++n);\n\tfor(auto p:es){\n\t\tint u,v; tie(u,v)=p;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\trep(u,n){\n\t\tcout<<u+1;\n\t\tsort(all(g[u]));\n\t\tfor(int v:g[u]) cout<<' '<<v+1;\n\t\tcout<<endl;\n\t}\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\trep(_,tc) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < now; j++) {\n        if(num[j] - cnt == dd && sz[j] > 1) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n          break;\n        }\n      }\n    } else {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n    cin >> sz[0];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 2000\nint a[MAX_N],b[MAX_N],c[MAX_N],m,t,x;\nvector<int> G[MAX_N];\nvoid init(){\n  t=x=0;\n  memset(a,0,sizeof(a));\n  memset(b,0,sizeof(b));\n  memset(c,0,sizeof(c));\n  for(int i=0;i<MAX_N;i++) G[i].clear();\n}\nvoid dfs(int d){\n  int v=t,p=++x;\n  b[d]=p;\n  for(int i=0;(int)G[p].size()<a[v];i++){\n    t++;\n    if(a[t]>0){\n      G[p].push_back(x+1);\n      G[x+1].push_back(p);\n      dfs(d+1);\n    }else if(a[t]<0){\n      G[p].push_back(b[d+a[t]]);\n      G[b[d+a[t]]].push_back(p);\n    }else break;\n  }\n}\nint main(){\n  int n;cin>>n;\n  while(n--){\n    init();\n    for(int i=0;;i++){\n      cin>>a[i];\n      if(!a[i]){\n\tm=i;\n\tbreak;\n      }\n    }\n    dfs(0);\n    for(int i=1;i<=x;i++){\n      if(G[i].size()==0) break;\n      cout<<i<<\" \";\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<(int)G[i].size();j++)\n\tcout<<G[i][j]<<\" \\n\"[j==(int)G[i].size()-1];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX_ROOM = 110;\nint N;\nvector<int> E[MAX_ROOM];\nqueue<int> Q[MAX_ROOM];\n\n\nvoid addEdge(int a, int b) {\n  E[a].push_back(b);\n  E[b].push_back(a);\n}\n\nvoid rec(int p, int t, int num_door, stringstream& ss) {\n  for(int i = 0; i < num_door; ++i) {\n    if(!Q[t].empty()) {\n      addEdge(p,Q[t].front());\n      Q[t].pop();\n    } else {\n      int a;\n      ss >> a;\n      if(a > 0) {\n\taddEdge(p,++N);\n\trec(N, t+1, a-1, ss);\n      } else {\n\tQ[t+a].push(p);\n      }\n    }\n  }\n}\n\nint main() {\n  int t;\n  cin >> t;\n  getchar();\n  while(t--) {\n    for(int i = 0; i < MAX_ROOM; ++i) {\n      E[i].clear();\n      while(!Q[i].empty()) Q[i].pop();\n    }\n    string line;\n    getline(cin,line);\n    stringstream ss(line);\n    int a;\n    ss >> a;\n    N = 1;\n    rec(1,0,a,ss);\n    for(int i = 1; i <= N; ++i) {\n      cout << i;\n      sort(E[i].begin(), E[i].end());\n      for(int j = 0; j < E[i].size(); ++j)\n\tcout << \" \" << E[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int M = 101;\nint idx, ri;\nvi record;\nint d2i[M];\nvector<vi> graph;\n\nvoid dfs(int v, int depth, int ord){\n    d2i[depth] = v;\n\n    while(graph[v].size() != ord){\n        assert(graph[v].size() < ord);\n\n        int r = record[idx++];\n\n        if(r < 0){\n            int nd = depth + r;\n            int nv = d2i[nd];\n            graph[ v].push_back(nv);\n            graph[nv].push_back( v);\n        }\n        else {\n            int nv = ri++;\n            graph[ v].push_back(nv);\n            graph[nv].push_back(v);\n            dfs(nv, depth + 1, r);\n        }\n    }\n}\n\nint main(void){\n    int T; cin >> T;\n    rep(loooop, T){\n        record = vi();\n        for(int r; cin >> r, r;) record.push_back(r);\n\n        rep(i, M) d2i[i] = -1;\n        graph = vector<vi>(M);\n\n        idx = 0, ri = 0;\n        dfs(ri++, 0, record[idx++]);\n\n        int n = ri;\n        rep(i, n){\n            cout << i + 1;\n            sort(_all(graph[i]));\n            for(auto & e : graph[i]) cout << \" \" << e + 1;\n            cout << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int m;\n  cin >> m;\n  cin.ignore();\n  while(m--){\n    int tmp;\n    vector<int> v;\n    while(cin >> tmp && tmp != 0) v.push_back(tmp);\n    int n = v.size();\n    vector<int> to[200];\n    int size[200];\n    int cur = 0;\n    stack<int> stk;\n    stk.push(0);\n    int mem[200] = {};\n    REP(i, n){\n      int lev = stk.top();\n      stk.pop();\n      //printf(\"v[%d] = %d , lev = %d\\n\", i, v[i], lev);\n      if(v[i] > 0){\n        if(lev > 0){\n          //printf(\"%d <-> %d\\n\", mem[lev - 1], cur);\n          to[mem[lev - 1]].push_back(cur);\n          to[cur].push_back(mem[lev - 1]);\n        }\n        size[cur] = v[i];\n        mem[lev] = cur++;\n        REP(j, v[i] - 1) stk.push(lev + 1);\n      }else if(v[i] < 0){\n        lev--;\n        int lev2 = lev + v[i];\n        //printf(\"%d <-> %d\\n\", mem[lev], mem[lev2]);\n        to[mem[lev]].push_back(mem[lev2]);\n        to[mem[lev2]].push_back(mem[lev]);\n      }\n    }\n    REP(i, cur){\n      printf(\"%d \",  i + 1);\n      assert(to[i].size() == size[i]);\n      sort(to[i].begin(), to[i].end());\n      REP(j, to[i].size()){\n        printf(\"%d\", to[i][j] + 1);\n        if(j == to[i].size() - 1) cout << endl;\n        else cout << \" \";\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nsigned main() {\n    int n;\n    cin >> n;\n    rep(i, n) {\n        vint a;\n        do {\n            a.push_back(0);\n            cin >> a.back();\n        } while (a.back() != 0);\n        a[0] += 1;\n        vpint p{{0, 1}};\n        vvint ans{vint()};\n        int cur = 1;\n        rep(i, a.size()) {\n            if (a[i] > 0) {\n                ans.push_back(vint());\n                ans[p.back().first].push_back(cur);\n                if (i > 0) { ans[cur].push_back(p.back().first); }\n                p.back().second--;\n                p.push_back({cur, a[i] - 1});\n                cur++;\n            } else if (a[i] < 0) {\n                ans[p.back().first].push_back(p[p.size() + a[i] - 1].first);\n                ans[p[p.size() + a[i] - 1].first].push_back(p.back().first);\n                p.back().second--;\n                p[p.size() + a[i] - 1].second--;\n            } else {\n                break;\n            }\n            while (p.back().second == 0) { p.pop_back(); }\n        }\n        for (int i = 1; i < ans.size(); i++) {\n            cout << i;\n            sort(all(ans[i]));\n            rep(j, ans[i].size()) { cout << \" \" << ans[i][j]; }\n            cout << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nvector<int> in;\n \nvector<int> G[1000];\nint pos=0;\nint path[1000];\nint ed[1000];\nint newn;\n \nvoid dfs(int cv,int depth){\n  //cout << cv << ' ' << depth << endl;\n  path[depth] = cv;\n  ed[cv] = in[pos++];\n  bool ok = false;\n  while(pos < SZ(in)){\n    int t=in[pos];\n    //cout << t << endl;\n    if(t<0){\n      assert(depth+t>=0);\n      int nv=path[depth+t];\n      G[cv].pb(nv);\n      G[nv].pb(cv);\n      ++pos;\n    }else{\n      ++newn;\n      G[cv].pb(newn);\n      G[newn].pb(cv);\n      dfs(newn,depth+1);\n    }\n    if(SZ(G[cv]) == ed[cv]){\n      ok = true;\n      break;\n    }\n  }\n  if(!ok){\n    FOR(it,in) cerr << *it << ' ';\n  }\n  assert(ok);\n}\n \nvoid solve(){\n  newn = 0;\n  in.clear();\n  int t;\n  int no=0;\n  while(cin >> t, t){\n    no += t>0;\n    in.pb(t);\n  }\n  \n  rep(i,no) G[i].clear();\n  pos = 0;\n  dfs(0,0);\n  rep(i,no) sort(ALL(G[i]));\n \n  rep(i,no){\n    cout << i+1;\n    FOR(it,G[i]) cout << ' ' << *it+1;\n    cout << endl;\n  }\n}\n \nint main(){\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(100);\n\t\tint in, cnt = -1, times = -1, pre;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\tcnt++; times++;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, pre, node, edge);\n\t\t\t\tcur.pb(cnt);\n\t\t\t\tpre = times;\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\tfor(int i = pre; i >= 0; i--) {\n\t\t\t\t\tif(cur[i] - cnt == in && edge[i] > 0) {\n\t\t\t\t\t\tadd_Node(pre, i, node, edge);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!edge[pre]) pre--;\n\t\t\t\tcnt = cur[pre];\n\t\t\t}\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(node[i].empty())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator > (const dat &a)const{return T-t>a.T-a.t;}\n};\n\nbool onFront(const dat &a,const dat &b){return a.f==b.f&&1.0*a.t/a.T<1.0*b.t/b.T;}\nbool checkJam(const dat &a,const dat &b){return onFront(a,b)&&a.T-a.t<b.T-b.t;}\n\nint merge(vector<dat>&A,int idx){\n  dat &a = A[idx];\n  for(int i=0;i<(int)A.size();i++){\n    dat &b = A[i];\n    if(!checkJam(a,b))continue;\n    a.t=0, a.lap-=a.f, a.f=!a.f;\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1e9;\n  }\n  return a.T-a.t;\n}\n\nvoid Push(vector<dat>&A,dat &a){\n  for(int i=0;i<(int)a.V.size();i++)Push(A,a.V[i]);\n  a.V.clear();\n  if(a.lap) A.push_back(a);\n}\n\nint sim(vector<dat> A){\n  int res=0,idx=0;\n  vector<dat> tmp[2]={A};\n  while(1){\n    vector<dat> &A = tmp[idx];idx=!idx;\n    if(A.empty())break;\n    sort(A.begin(),A.end(),greater<dat>());\n    int mn = 1e9;\n    for(int i=A.size()-1;i>=0;i--)mn=min(mn,merge(A,i));\n\n    vector<dat>&nA=tmp[idx];tmp[idx].clear();\n    for(int i=0;i<(int)A.size();i++)\n      if(A[i].t+mn<A[i].T) A[i].t+=mn,nA.push_back(A[i]);\n      else A[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f,Push(nA,A[i]);\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Room{\n    int visited, dist;\n    vector<int> to;\n    Room(int door) {\n        to.resize(door, 0);\n        visited = 0;\n        dist = 0;\n    }\n    Room(int door, int before, int dist) : dist(dist){\n        to.resize(door, 0);\n        to[0] = before;\n        visited = 1;\n    }\n    void visit(int roomnum){\n        to[visited] = roomnum;\n        visited++;\n        return;\n    }\n    bool canBack(){ return visited <= to.size() - 1; }\n    void s(){ sort(to.begin(), to.end()); }\n    int before(){ return to[0]; }\n};\nvector<Room> house;\nint dfs(int num){\n    if(house[num].canBack()) return num;\n    if(house[num].before() >= 0)\n      return dfs(house[num].before());\n    else\n      return 0;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int T; cin >> T;\n    rep(casenum, T){\n        house.clear();\n        int _t;\n        int it = -1;\n        bool need_dfs = false;\n        while(cin >> _t && _t){\n            if(need_dfs) it = dfs(it);\n            int dist;\n            if(it != -1) dist = house[it].dist;\n            if(_t >= 0){\n                if(it == -1){\n                    house.push_back(Room(_t));\n                    it = 0;\n                    continue;\n                }\n                house.push_back(Room(_t, it, dist + 1));\n                int before = it;\n                it = house.size() - 1;\n                house[before].visit(it);\n                need_dfs = false;\n            }else{\n                int fd = dist + _t;\n                rep(i, house.size())\n                  if(fd == house[i].dist && house[i].canBack()){\n                      house[i].visit(it);\n                      house[it].visit(i);\n                      break;\n                  }\n                need_dfs = true;\n            }\n        }\n        it = 1;\n        for(Room& _r : house){\n            cout << it; it++;\n            _r.s();\n            for(int k : _r.to) cout << ' ' << k + 1;\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nclass room{\npublic:\n  int prev;\n  int doors;\n  int dist;\n  vector<int> next;\n  room(int p,int d,int d2){\n    prev=p;\n    doors=d;\n    dist=d2;\n    next=vector<int>();\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n-->0){\n    vector<room> rooms;\n    int r;\n    int p=-1;\n    int d=0;\n    while(cin >> r,r){\n      //printf(\"r=%d (p=%d,d=%d) :\\n\",r,p+1,d);\n      if(r>0){\n\td++;\n\trooms.push_back(room(p,r,d));\n\tif(p>=0){\n\t  //cout << \"connect (\" << p+1 << \"<=>\" << rooms.size() << \")\";\n\t  rooms[p].next.push_back(rooms.size()-1);\n\t  rooms[rooms.size()-1].next.push_back(p);\n\t}\n\tp=rooms.size()-1;\n\twhile(rooms[p].next.size()==rooms[p].doors){\n\t  d--;\n\t  p=rooms[p].prev;\n\t}\n      }else{\n\tint next;\n\tfor(next=0;next<rooms.size();next++){\n\t  if(d+r==rooms[next].dist&&rooms[next].next.size()!=rooms[next].doors)\n\t    break;\n\t}\n\t\n\t//cout << \"connect (\" << p+1 << \"<=>\" << next+1 << \")\";\n\trooms[p].next.push_back(next);\n\trooms[next].next.push_back(p);\n\twhile(rooms[p].next.size()==rooms[p].doors){\n\t  d--;\n\t  p=rooms[p].prev;\n\t}\n      }\n      //cout << endl;\n    }\n    //while(p!=-1);\n    for(int i=0;i<rooms.size();i++){\n      cout << i+1 << \" \";\n      while(rooms[i].next.size()!=rooms[i].doors);\n      sort(rooms[i].next.begin(),rooms[i].next.end());\n      for(int j=0;j<rooms[i].next.size();j++){\n\tcout << rooms[i].next[j]+1 << (j==rooms[i].next.size()-1?'\\n':' ');\n      }\n    }\n    //cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nvector<int> in;\n \nvector<int> G[1000];\nint pos=0;\nint path[1000];\nint ed[1000];\nint newn;\n \nvoid dfs(int cv,int depth){\n  //cout << cv << ' ' << depth << endl;\n  path[depth] = cv;\n  ed[cv] = in[pos++];\n  while(pos < SZ(in)){\n    int t=in[pos];\n    //cout << t << endl;\n    if(t<0){\n      assert(depth+t>=0);\n      int nv=path[depth+t];\n      G[cv].pb(nv);\n      G[nv].pb(cv);\n      ++pos;\n    }else{\n      ++newn;\n      G[cv].pb(newn);\n      G[newn].pb(cv);\n      dfs(newn,depth+1);\n    }\n    if(SZ(G[cv]) == ed[cv]) break;\n  }\n}\n \nvoid solve(){\n  newn = 0;\n  in.clear();\n  int t;\n  int no=0;\n  while(cin >> t, t){\n    no += t>0;\n    in.pb(t);\n  }\n  \n  rep(i,no) G[i].clear();\n  pos = 0;\n  dfs(0,0);\n  rep(i,no) sort(ALL(G[i]));\n \n  rep(i,no){\n    cout << i+1;\n    FOR(it,G[i]) cout << ' ' << *it+1;\n    cout << endl;\n  }\n}\n \nint main(){\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nVI sz, xs, dist, prv;\nVVI edge;\nint M;\nint dfs(int& i, int cur){\n  if(i == SZ(xs)) return cur;\n  if(sz[cur] == 0) return cur+1;\n  if(xs[i] < 0){\n\t++sz[cur];\n\t++sz[prv[cur]];\n\tint res = cur;\n\tcur = prv[cur];\n\tint d = -xs[i], p = prv[cur];\n\twhile(true){\n\t  if(dist[cur] - dist[p] == d) break;\n\t  p = prv[p];\n\t  /*\n\t  if(p == -1){\n\t\tcout << \"HALT with \" << i << \", \" << cur << endl;\n\t\tfor(int i=0;i<M;++i) cout << prv[i] << \" \";\n\t\tcout << endl;\n\t\tbreak;\n\t  }\n\t  */\n\t}\n\n\t--sz[cur];\n\t--sz[p];\n\tedge[cur].PB(p);\n\tedge[p].PB(cur);\n\t++i;\n\treturn res;\n  }\n  //cout << i << \" \" << cur << \" \" << sz[cur] << endl;\n  int nxt = cur + 1;\n  ++i;\n  while(sz[cur] > 0){\n\t--sz[cur];\n\t--sz[nxt];\n\tprv[nxt] = cur;\n\tdist[nxt] = dist[cur] + 1;\n\tint nxt_ = dfs(i, nxt);\n\tif(nxt_ != nxt){\n\t  edge[cur].PB(nxt);\n\t  edge[nxt].PB(cur);\n\t  nxt = nxt_;\n\t}\n  }\n\n  return nxt;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  while(N--){\n\txs.clear();\n\tsz.clear();\n\tM = 0;\n\twhile(true){\n\t  int x;\n\t  cin >> x;\n\t  if(x == 0) break;\n\t  xs.PB(x);\n\t  if(x > 0){\n\t\tsz.PB(x);\n\t\t++M;\n\t  }\n\t}\n\tprv.assign(101, -1);\n\tdist.assign(101, 0);\n\tedge.assign(101, VI());\n\tint it = 0;\n\tdfs(it,0);\n\n\tfor(int i=0;i<M;++i){\n\t  cout << i+1;\n\t  SORT(edge[i]);\n\t  for(int j=0;j<SZ(edge[i]);++j)\n\t\tcout << \" \" << edge[i][j]+1;\n\t  cout << endl;\n\t}\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nvector<int> a;\nvector<int> ord;\nint sz;\nvector<int> rest;\nint n,vidx=0;\nvector<int> g[100];\n\nvoid dfs(int& i,int pre){\n  if(a[i]>0){\n    int crtv=vidx++;\n    ord.push_back(crtv);\n    sz++;\n    if(pre!=-1){\n      g[pre].push_back(crtv);\n      g[crtv].push_back(pre);\n    }\n    rest[crtv]=a[i]-(pre==-1?0:1);\n    while(rest[crtv]){\n      dfs(++i,crtv);\n      rest[crtv]--;\n    }\n    ord.pop_back();\n    sz--;\n  }else{\n    int crtv=pre;\n    int backv=ord[sz-1+a[i]];\n    rest[backv]--;\n    g[crtv].push_back(backv);\n    g[backv].push_back(crtv);\n  }\n}\n\nvoid solve(){\n  a.clear();\n  n=0;\n  while(1){\n    int aa;\n    cin>>aa;\n    if(aa==0)break;\n    if(aa>0)n++;\n    a.push_back(aa);\n  }\n  vidx=0;\n  ord.clear();\n  sz=0;\n  rest.clear();\n  rest.resize(n);\n  rep(i,n)g[i].clear();\n  int hoge=0;\n  dfs(hoge,-1);\n  rep(i,n){\n    sort(all(g[i]));\n    cout<<i+1<<\" \"<<g[i][0]+1;\n    repl(j,1,g[i].size())cout<<\" \"<<g[i][j]+1;\n    cout<<endl;\n  }\n}\n\nint main(){\n  int cases;\n  cin>>cases;\n  while(cases--){\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to;\n      rep(i,dist[ff+inp[p]].size() ){\n\tif ( en[dist[ff+inp[p]][i]] >0){to=dist[ff+inp[p]][i];break;}\n      }\n\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      assert(en[node]>0 && en[to]>0);\n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvoid solve() {\n\tint t; cin >> t;\n\trep(aa, t) {\n\t\tvector<int> c;\n\t\tint r;\n\t\twhile (cin >> r, r) {\n\t\t\tc.push_back(r);\n\t\t}\n\t\tvector<int> rooms,dist;\n\t\tvector<vector<int>> g(100);\n\t\tqueue<int> q[100];\n\t\tint loc = -1; int cur = -1;\n\t\tvector<int> path;\n\t\trep(i, c.size()) {\n\t\t\tif (c[i] > 0) {\n\t\t\t\tcur++; loc++;\n\t\t\t\tif (!path.empty()) {\n\t\t\t\t\tint las = path.back();\n\t\t\t\t\tg[las].push_back(cur);\n\t\t\t\t\tg[cur].push_back(las);\n\t\t\t\t}\n\t\t\t\trooms.push_back(c[i]);\n\t\t\t\tdist.push_back(cur);\n\t\t\t\tq[loc].push(cur);\n\t\t\t\tpath.push_back(cur);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint id = c[i] + loc;\n\t\t\t\twhile (!q[id].empty()) {\n\t\t\t\t\tint idd = q[id].front();\n\t\t\t\t\tif (g[idd].size() == rooms[idd])q[id].pop();\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tint idd = q[id].front();\n\t\t\t\tg[idd].push_back(path.back());\n\t\t\t\tg[path.back()].push_back(idd);\n\t\t\t}\n\t\t\twhile (!path.empty()&&g[path.back()].size() == rooms[path.back()]) {\n\t\t\t\tpath.pop_back(); loc--;\n\t\t\t}\n\t\t}\n\t\trep(i, cur+1) {\n\t\t\tsort(g[i].begin(), g[i].end());\n\t\t\tcout << i + 1;\n\t\t\trep(j, g[i].size()) {\n\t\t\t\tcout << \" \" << g[i][j] + 1;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, next, pos, deg[1000];\nvi v, st;\nvector<vi> e;\n\nvoid rec(int c){\n\tdeg[c] = next;\n\tst.pb(c);\n\tif(deg[c] == 1){\n\t\tcout << \"HOGE\" << endl;\n\t\texit(0);\n\t}\n\trep(i, deg[c]){\n\t\tnext = v[pos++];\n\t\tif(next < 0){\n\t\t\tint to = st[st.size() + next - 1];\n\t\t\tdeg[to]--;\n\t\t\te[c].pb(to);\n\t\t\te[to].pb(c);\n\t\t}\n\t\telse{\n\t\t\te[c].pb(c + 1);\n\t\t\te[c + 1].pb(c);\n\t\t\trec(c + 1);\n\t\t}\n\t}\n\tst.pop_back();\n}\n\nint main(){\n\tint cs;\n\tcin >> cs;\n\twhile(cs--){\n\t\tv.clear();\n\t\tint t, m = 0;\n\t\twhile(cin >> t, t){\n\t\t\tv.pb(t);\n\t\t\tif(t > 0) m++;\n\t\t}\n\t\t\n\t\te.clear(); e.resize(m);\n\t\tnext = v[0];\n\t\tpos = 1;\n\t\trec(0);\n\t\t\n\t\trep(i, m){\n\t\t\tcout << (i + 1);\n\t\t\trep(j, e[i].size()) cout << \" \" << e[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nmap<int,vector<int> > m;\nint a[100];\nint er[100];\nint nr;\n\nvoid dfs(int d){\n  int r;\n  cin>>r;\n  if(r>0){\n    nr++;\n    a[d]=nr;\n    if(d){\n      m[a[d]].push_back(a[d-1]);\n      m[a[d-1]].push_back(a[d]);\n    }\n    er[d]=r-1;\n    for(int i=0;i<er[d];i++){\n      dfs(d+1);\n    }\n  }else{\n    er[d-1+r]--;\n    m[a[d-1]].push_back(a[d-1+r]);\n    m[a[d-1+r]].push_back(a[d-1]);\n  }\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    m.clear();\n    nr=0;\n    dfs(0);\n    int d;\n    cin>>d;\n    for(auto e:m){\n      cout<<e.first;\n      sort(begin(e.second),end(e.second));\n      for(auto f:e.second){\n\tcout<<' '<<f;\n      }\n      cout<<endl;\n    }\n  }\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <set>\nusing namespace std;\nmap<int,set<int> >stak;\nint nxt,RB[105][105],edge[105],deep[105];\nvoid dfs(int here) {\n\twhile (edge[here]>0) {\n\t\tint cur,i,j;scanf(\"%d\",&cur);\n\t\tif (cur>0) {\n\t\t\tRB[here][nxt]++,RB[nxt][here]++,deep[nxt]=deep[here]+1,edge[here]--,edge[nxt]=cur-1;\n\t\t\tstak[deep[nxt]].insert(nxt);\n\t\t\tif (!edge[here]) stak[deep[here]].erase(here);\n\t\t\tif (!edge[nxt]) stak[deep[nxt]].erase(nxt);\n\t\t\tdfs(nxt++);\n\t\t} else {\n\t\t\tj=deep[here]+cur;i=*stak[j].begin();\n\t\t\tRB[here][i]++,RB[i][here]++,edge[i]--,edge[here]--;\n\t\t\tif (!edge[here]) stak[deep[here]].erase(here);\n\t\t\tif (!edge[i]) stak[deep[i]].erase(i);\n\t\t}\n\t}\n}\nint main() {\n\tint N,i,j;scanf(\"%d\",&N);while (N--) {\n\t\tfor (i=0;i<105;edge[i]=deep[i]=0,i++) for (j=0;j<105;RB[i][j++]=0);\n\t\tstak.clear();stak[0].insert(1);scanf(\"%d\",&edge[1]);\n\t\tnxt=2;dfs(1);scanf(\"%*d\");for (i=1;i<nxt;i++) {\n\t\t\tprintf(\"%d\",i);for (j=1;j<nxt;j++) while (RB[i][j]--) printf(\" %d\",j);puts(\"\");}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n    vector<int> A;\n    int a;\n    while(cin >> a,a){A.emplace_back(a);}\n    int s=A.size(),n=0;\n    for (int i=0;i<s;++i) n+=(A[i]>0);\n    vector<vector<int>> G(n);\n    vector<int> d,rest(n),p(n);\n    d.emplace_back(0); rest[0]=A[0]; p[0]=-1;\n    int now=0;\n    for (int i=1;i<s;++i){\n        if (A[i]>0){\n            int nxt=d.size(); rest[nxt]=A[i];\n            d.emplace_back(d[now]+1);\n            G[now].emplace_back(nxt);\n            G[nxt].emplace_back(now);\n            --rest[now]; --rest[nxt];\n            p[nxt]=now; now=nxt;\n        } else {\n            for (int j=0;j<d.size();++j){\n                if (d[now]+A[i]==d[j]&&rest[j]){\n                    G[now].emplace_back(j);\n                    G[j].emplace_back(now);\n                    --rest[now]; --rest[j];\n                    break;\n                }\n            }\n        }\n        while(~now&&!rest[now]) now=p[now];\n    }\n    for (int v=0;v<n;++v){\n        cout << v+1;\n        sort(G[v].begin(),G[v].end());\n        for (int u:G[v]) cout << ' ' << u+1;\n        cout << '\\n';\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int t; cin >> t;\n    for (;t--;){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nvector<int> in;\n \nvector<int> G[1000];\nint pos=0;\nint path[1000];\nint ed[1000];\nint newn;\n \nvoid dfs(int cv,int depth){\n  //cout << cv << ' ' << depth << endl;\n\n  path[depth] = cv;\n  ed[cv] = in[pos++];\n  bool ok = false;\n  if(SZ(G[cv]) == ed[cv]) return;\n  while(pos < SZ(in)){\n    int t=in[pos];\n    //cout << t << endl;\n    if(t<0){\n      assert(depth+t>=0);\n      int nv=path[depth+t];\n      G[cv].pb(nv);\n      G[nv].pb(cv);\n      ++pos;\n    }else{\n      ++newn;\n      G[cv].pb(newn);\n      G[newn].pb(cv);\n      dfs(newn,depth+1);\n      assert(SZ(G[newn]) == ed[newn]);\n    }\n    if(SZ(G[cv]) == ed[cv]){\n      ok = true;\n      break;\n    }\n  }\n  assert(ok);\n}\n\nvector<int> killedge(vector<int> in){\n  rep(i,SZ(in))\n    if(in[i]<0){\n      --in[i+in[i]];\n      --in[i-1];\n      in.erase(in.begin()+i);\n      break;\n    }\n  return in;\n}\n \nvoid solve(){\n  in.clear();\n  int t;\n  while(cin >> t, t)\n    in.pb(t);\n  \n  while(true){\n      int no=0;\n      int degsum = 0;\n      newn = 0;\n      FOR(it,in){\n        int t=*it;\n        no += t>0;\n        degsum += (t>0) * t;\n      }\n\n      rep(i,no) G[i].clear();\n      pos = 0;\n      try{\n        dfs(0,0);\n      }catch(...){\n        in = killedge(in);\n        continue;\n      }\n      rep(i,no) sort(ALL(G[i]));\n\n      rep(i,no){\n        cout << i+1;\n        FOR(it,G[i]) cout << ' ' << *it+1;\n        cout << endl;\n      }\n      break;\n  }\n}\n \nint main(){\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int T;\n    cin >> T;\n    rep(t, T) {\n        vi a;\n        int x;\n        while (cin >> x, x != 0) {\n            a.emplace_back(x);\n        }\n        int L = a.size();\n        vi deg;\n        rep(i, L) {\n            if (a[i] > 0) {\n                deg.emplace_back(a[i]);\n            }\n        }\n        int n = deg.size();\n        Graph G(n);\n        vi prev(n, -1);\n        int now = 0;\n        int nxt = 1;\n\n        auto addEdge = [&](int x, int y) {\n            G[x].emplace_back(y);\n            G[y].emplace_back(x);\n            deg[x]--;\n            deg[y]--;\n        };\n\n        function<int(int,int)> Prev = [&](int x, int c) {\n            if (c == 0) return x;\n            return Prev(prev[x], c - 1);\n        };\n\n        rep2(i, 1, L) {\n            if (a[i] > 0) {\n                addEdge(now, nxt);\n                prev[nxt] = now;\n                now = nxt;\n                nxt++;\n            }\n            else {\n                addEdge(now, Prev(now, -a[i]));\n            }\n\n            while (now != 0 && deg[now] == 0) {\n                now = prev[now];\n            }\n        }\n\n        rep(i, n) {\n            sort(all(G[i]));\n            cout << i + 1;\n            for (auto x : G[i]) {\n                cout << \" \" << x + 1;\n            }\n            cout << endl;\n        }\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-1;\n      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n      rep(i,dist[ff+inp[p]].size() ){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n      }\n      if ( to == -1){p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> record;\nvector<int> dist;\nvector<int> deg;\nvector<vector<int>> edges;\nint idx;\n\nvoid dfs(int v, int p, int dep){\n    dist.push_back(dep);\n    int r = record[idx];\n    if(0 <= p){\n        r--;\n        edges.push_back({p});\n        deg[p]--;\n        edges[p].push_back(v);\n    }else{\n        edges.push_back({});\n    }\n    deg.push_back(r);\n    \n    while(deg[v]){\n        idx++;\n        if(record[idx]<0){\n            for(int i=0; i<dist.size(); i++){\n                if(dist[i] == dist[v] + record[idx]){\n                    edges[i].push_back(v);\n                    edges[v].push_back(i);\n                    deg[i]--;\n                    deg[v]--;\n                }\n            }\n        }else{\n            dfs(deg.size(), v, dep+1);\n        }\n    }\n}\n\nvoid solve(){\n    idx = 0;\n    dfs(0, -1, 0);\n    for(int i=0; i<edges.size(); i++){\n        auto edge = edges[i];\n        sort(edge.begin(), edge.end());\n        cout << i+1;\n        for(auto v: edge)\n            cout << \" \" << v+1;\n        cout << endl;\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    while (N--) {\n        record.clear();\n        dist.clear();\n        deg.clear();\n        edges.clear();\n        \n        int r;\n        while(cin >> r, r)\n            record.push_back(r);\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int l;\n  cin >> l;\n  while(l--){\n    vector<int> seq;\n    int n=0;\n    {\n      int tmp;\n      while(cin >> tmp, tmp){\n\tseq.push_back(tmp);\n\tif(tmp>0)n++;\n      }\n    }\n    \n    vector<int> deg(n,0);\n    vector< vector<int> > adj(n);\n\n    int id = 0;\n    vector<int> stack;\n    stack.push_back(0); deg[0] = seq[0];\n\n    for(int i=1;i<(int)seq.size();i++){\n      if(seq[i]>0){\n\tid++;\n\n\tadj[stack.back()].push_back(id);\n\tadj[id].push_back(stack.back());\n\tdeg[id] = seq[i]-1;\n\tdeg[stack.back()]--;\n\n\tstack.push_back(id);\n      }else{\n\tint nxt = stack[stack.size()-1+seq[i]];\n\n\tadj[stack.back()].push_back(nxt);\n\tadj[nxt].push_back(stack.back());\n\tdeg[nxt]--;\n\tdeg[stack.back()]--;\n      }\n      while(stack.size() && deg[stack.back()]==0)stack.pop_back();\n    }\n\n    for(int i=0;i<n;i++){\n      cout << i+1;\n      sort(adj[i].begin(), adj[i].end());\n      for(int u : adj[i])cout << \" \" << u+1;\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(100);\n\t\tint in, cnt = -1, times = -1, pre;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\tcnt++; times++;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, pre, node, edge);\n\t\t\t\tcur.pb(cnt);\n\t\t\t\tpre = times;\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\tint pnt;\n\t\t\t\tfor(pnt = times; pnt >= 0; pnt--)\n\t\t\t\t\tif(cur[pnt] - cnt == in && edge[pnt] > 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif(pnt == -1) return 0;\n\t\t\t\tadd_Node(pre, pnt, node, edge);\n\t\t\t\twhile(!edge[pre]) pre--;\n\t\t\t\tcnt = cur[pre];\n\t\t\t}\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(!node[i].size())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nclass room{\npublic:\n  int prev;\n  int doors;\n  int dist;\n  vector<int> next;\n  room(int p,int d,int d2){\n    prev=p;\n    doors=d;\n    dist=d2;\n    next=vector<int>();\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n-->0){\n    vector<room> rooms;\n    int r;\n    int p=-1;\n    int d=0;\n    while(cin >> r,r){\n      //printf(\"r=%d (p=%d,d=%d) :\\n\",r,p+1,d);\n      if(r>0){\n        d++;\n        rooms.push_back(room(p,r,d));\n        if(p>=0){\n          //cout << \"connect (\" << p+1 << \"<=>\" << rooms.size() << \")\";\n          rooms[p].next.push_back(rooms.size()-1);\n          rooms[rooms.size()-1].next.push_back(p);\n        }\n        p=rooms.size()-1;\n        /*\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n        */\n      }else{\n        int next;\n        for(next=0;next<rooms.size();next++){\n          if(d+r==rooms[next].dist&&rooms[next].next.size()!=rooms[next].doors)\n            break;\n        }\n\n        //cout << \"connect (\" << p+1 << \"<=>\" << next+1 << \")\";\n        rooms[p].next.push_back(next);\n        rooms[next].next.push_back(p);\n        /*\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n        */\n      }\n      //cout << endl;\n    }\n    //while(p!=-1);\n    for(int i=0;i<rooms.size();i++){\n      cout << i+1 << \" \";\n      //while(rooms[i].next.size()!=rooms[i].doors);\n      sort(rooms[i].next.begin(),rooms[i].next.end());\n      for(int j=0;j<rooms[i].next.size();j++){\n        cout << rooms[i].next[j]+1 << (j==rooms[i].next.size()-1?'\\n':' ');\n      }\n    }\n    //cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-1;\n      \n      //      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n      // rep(i,dist[ff+inp[p]].size() ){\n      for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n      if ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n\n      if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int Q; cin >> Q;\n  while (Q--) {\n    V<> deg(100, -1), v(100, -1);\n    VV<> g(100);\n    auto add_edge = [&](int i, int j) -> void {\n      --deg[i], --deg[j];\n      g[i].push_back(j);\n      g[j].push_back(i);\n    };\n    int x, t = -1, n = 0;\n    bool first = true;\n    while (cin >> x, x) {\n      if (x > 0) {\n        v[++t] = n;\n        deg[n] = x;\n        if (!first) {\n          add_edge(v[t - 1], n);\n        }\n        ++n;\n      } else {\n        add_edge(v[t + x], v[t]);\n      }\n      while (t >= 0 and !deg[v[t]]) {\n        --t;\n      }\n      first = false;\n    }\n    for (int i = 0; i < n; ++i) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for (int e : g[i]) cout << ' ' << e + 1;\n      cout << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nstruct state {\n  int index;\n  int free_child; //no. of free children\n};\n\nint trace_parent(int cur_index, int backtrack, int parentLookup[101]) {\n  if (backtrack == 0) return cur_index;\n  return trace_parent(parentLookup[cur_index], backtrack-1, parentLookup);\n}\n\n\nint main() {\n  int N; //no. of explorations\n  cin >> N;\n\n  for (int i = 0; i < N; i++) {\n    stack<state> path;\n    vector<int> output[101];\n    int parentLookup[101] = {-1}; //index is a child of entry on current path\n\n    int max_state = 1;\n    parentLookup[1] = 1;\n    \n    int entry;\n    cin >> entry;\n\n    while (entry != 0) {\n      if (entry > 0) {\n\tstate new_state = { max_state, entry-1 };\n\t\n\t//add to output\n\tif (new_state.index != 1) {\n\t  int parent = path.top().index;\n\t  parentLookup[new_state.index] = parent;\n\t  output[new_state.index].push_back(parent);\n\t  output[parent].push_back(new_state.index);\n\t}\n\t\n\tpath.push(new_state);\n\tmax_state++;\n      } else if (entry < 0) {\n\tint backlink_id = trace_parent(path.top().index, -entry, parentLookup);\n\toutput[path.top().index].push_back(backlink_id);\n\toutput[backlink_id].push_back(path.top().index);\n\tpath.top().free_child -= 1;\n\twhile (path.top().free_child == 0) {\n\t  path.pop();\n\t}\n      }\n      cin >> entry; \n    }\n    \n    for (int i = 1; i < max_state; i++) {\n      cout << i;\n      sort(output[i].begin(), output[i].end());\n      for (vector<int>::const_iterator j = output[i].begin(); j != output[i].end(); ++j) {\n\tcout << \" \" <<  *j;\n      }\n      cout << endl;\n    }\n  }\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Room{\n    int visited, dist;\n    vector<int> to;\n    Room(int door) {\n        to.resize(door, 0);\n        visited = 0;\n        dist = 0;\n    }\n    Room(int door, int before, int dist) : dist(dist){\n        to.resize(door, 0);\n        to[0] = before;\n        visited = 1;\n    }\n    void visit(int roomnum){\n        to[visited] = roomnum;\n        visited++;\n        return;\n    }\n    bool canBack(){ return visited <= to.size() - 1; }\n    void s(){ sort(to.begin(), to.end()); }\n    int before(){ return to[0]; }\n};\nvector<Room> house;\nint dfs(int num){\n    if(house[num].canBack()) return num;\n    if(house[num].before() >= 0)\n      return dfs(house[num].before());\n    else\n      return 0;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int T; cin >> T;\n    rep(casenum, T){\n        house.clear();\n        int _t;\n        int it = -1;\n        bool need_dfs = false;\n        while(cin >> _t && _t){\n            if(need_dfs) it = dfs(it);\n            int dist;\n            if(it != -1) dist = house[it].dist;\n            if(_t >= 0){\n                if(it == -1){\n                    house.push_back(Room(_t));\n                    it = 0;\n                    continue;\n                }\n                house.push_back(Room(_t, it, dist + 1));\n                int before = it;\n                it = house.size() - 1;\n                house[before].visit(it);\n                need_dfs = false;\n            }else{\n                int fd = dist + _t;\n                rep(i, house.size())\n                  if(fd == house[i].dist && house[i].canBack()){\n                      house[i].visit(it);\n                      house[it].visit(i);\n                      break;\n                  }\n                need_dfs = true;\n            }\n        }\n        it = 1;\n        for(Room& _r : house){\n            cout << it; it++;\n            _r.s();\n            for(int k : _r.to) cout << ' ' << k + 1;\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconstexpr int MAX = 114;\n\nint v;\nint deg[MAX], dv[MAX];\nvector<int> res[MAX];\n\nvoid dfs(size_t& idx, int depth, const vector<int>& q)\n{\n    deg[v] += q[idx];\n    dv[depth] = v;\n    \n    int nv = v++;\n    \n    while (idx < q.size() && deg[nv] > 0) {\n        const int val = q[++idx];\n        if (val > 0) {\n            deg[nv]--; deg[v]--;\n            res[nv].emplace_back(v);\n            res[v].emplace_back(nv);\n            dfs(idx, depth + 1, q);\n        } else {\n            int u = dv[depth + val];\n            deg[u]--; deg[nv]--;\n            res[u].emplace_back(nv);\n            res[nv].emplace_back(u);\n        }\n    }\n}\n\nvoid init(int N)\n{\n    v = 0;\n    for (int i = 0; i < N; i++) {\n        res[i].clear();\n        deg[i] = 0;\n    }\n}\n\nint main()\n{\n    int Tc;\n    cin >> Tc;\n    while (Tc--) {        \n        int x, N = 0;\n        vector<int> q;\n        while (cin >> x, x != 0) {\n            N += (x > 0);\n            q.emplace_back(x);\n        }\n        \n        init(N);\n        size_t idx = 0;\n        dfs(idx, 0, q);\n\n        for (int i = 0; i < N; i++) {\n            cout << i + 1;\n            sort(res[i].begin(), res[i].end());\n            for (const auto& r : res[i]) {\n                cout << \" \" << r + 1;\n            }\n            cout << endl;;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(100);\n\t\tint in, cnt = -1, times = -1, pre;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\tcnt++; times++;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, pre, node, edge);\n\t\t\t\tcur.pb(cnt);\n\t\t\t\tpre = times;\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\tfor(int i = times; i >= 0; i--) {\n\t\t\t\t\tif(cur[i] - cnt == in && edge[i] > 0) {\n\t\t\t\t\t\tadd_Node(pre, i, node, edge);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!edge[pre]) pre--;\n\t\t\t\tcnt = cur[pre];\n\t\t\t}\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(!node[i].size())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nstruct state {\n  int index;\n  int free_child; //no. of free children\n};\n\nint trace_parent(int cur_index, int backtrack, int parentLookup[101]) {\n  if (backtrack == 0) return cur_index;\n  return trace_parent(parentLookup[cur_index], backtrack-1, parentLookup);\n}\n\n\nint main() {\n  int N; //no. of explorations\n  cin >> N;\n\n  for (int i = 0; i < N; i++) {\n    stack<state> path;\n    vector<int> output[101];\n    int parentLookup[101] = {-1}; //index is a child of entry on current path\n\n    int max_state = 1;\n    parentLookup[1] = 1;\n    \n    int entry;\n    cin >> entry;\n\n    while (entry != 0) {\n      if (entry > 0) {\n\tstate new_state = { max_state, entry-1 };\n\t\n\t//add to output\n\tif (new_state.index != 1) {\n\t  int parent = path.top().index;\n\t  parentLookup[new_state.index] = parent;\n\t  output[new_state.index].push_back(parent);\n\t  output[parent].push_back(new_state.index);\n\t}\n\t\n\tpath.push(new_state);\n\tmax_state++;\n      } else if (entry < 0) {\n\tint backlink_id = trace_parent(path.top().index, -entry, parentLookup);\n\toutput[path.top().index].push_back(backlink_id);\n\toutput[backlink_id].push_back(path.top().index);\n\tpath.top().free_child -= 1;\n      }\n      while (path.top().free_child == 0) {\n\tpath.pop();\n      }\n      cin >> entry; \n    }\n    \n    \n    for (int i = 1; i < max_state; i++) {\n      cout << i;\n      sort(output[i].begin(), output[i].end());\n      for (vector<int>::const_iterator j = output[i].begin(); j != output[i].end(); ++j) {\n\tcout << \" \" <<  *j;\n      }\n      cout << endl;\n    }\n  }\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++){\n    vector<int> a;\n    while (1){\n      int x;\n      cin >> x;\n      if (x == 0){\n        break;\n      }\n      a.push_back(x);\n    }\n    int m = a.size();\n    int V = 0;\n    vector<vector<int>> E;\n    vector<pair<int, int>> R;\n    for (int j = 0; j < m; j++){\n      if (a[j] > 0){\n        R.push_back(make_pair(V, a[j]));\n        E.push_back(vector<int>(0));\n        V++;\n        if (R.size() > 1){\n          int v = R[R.size() - 2].first;\n          int w = R[R.size() - 1].first;\n          E[v].push_back(w);\n          E[w].push_back(v);\n          R[R.size() - 2].second--;\n          R[R.size() - 1].second--;\n        }\n      } else {\n        int v = R[R.size() - 1].first;\n        int w = R[R.size() - 1 + a[j]].first;\n        E[v].push_back(w);\n        E[w].push_back(v);\n        R[R.size() - 1].second--;\n        R[R.size() - 1 + a[j]].second--;\n      }\n      while (R.back().second == 0){\n        R.pop_back();\n        if (R.empty()){\n          break;\n        }\n      }\n    }\n    for (int j = 0; j < V; j++){\n      sort(E[j].begin(), E[j].end());\n      cout << j + 1;\n      for (int k : E[j]){\n        cout << ' ' << k + 1;\n      }\n      cout << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n//#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\n\nbool solve() {\n    vector<int> rec;\n    while (true) {\n        int x;\n        cin >> x;\n        if (x == 0) break;\n        rec.push_back(x);\n    }\n    int las = 0;\n    stack<int> stk;\n    // stk.push(0);\n    int N = rec.size();\n    vector<int> dist(N + 1), rem(N + 1);\n    int now = 0;\n    int pos = 0;\n    rem[1] = rec[0];\n    las = 1;\n    stk.push(1);\n    vector<vector<int>> st(N + 1);\n    FOR(i, 1, N) {\n        while (true) {\n            now = stk.top();\n            stk.pop();\n            if (rem[now] > 0) break;\n        }\n        // cerr << now << endl;\n        rem[now]--;\n        int c = rec[i];\n        if (c > 0) {\n            las++;\n            int nxt = las;\n            dist[las] = dist[now] + 1;\n            rem[nxt] = c - 1;\n            if (now == 0) rem[nxt]++;\n            if (now != 0) {\n                st[now].push_back(nxt);\n                st[nxt].push_back(now);\n            }\n            REP(_, c - 1) stk.push(nxt);\n        } else {\n            REP(j, las + 1) {\n                if (rem[j] && dist[j] - dist[now] == c) {\n                    rem[j]--;\n                    st[now].push_back(j);\n                    st[j].push_back(now);\n                    break;\n                }\n            }\n        }\n    }\n    FOR(i, 1, las + 1) {\n        cout << i;\n        sort(all(st[i]));\n        for (auto x : st[i]) {\n            cout << \" \" << x;\n        }\n        cout << endl;\n    }\n}\n\nsigned main() {\n    // while (solve())\n    int q;\n    cin >> q;\n    while (q--) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(int *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff]=node;\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to = dist[ff+inp[p]];\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      assert(en[node]>0 && en[to]>0);\n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    int n,dist[N]={0},en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct node {\n  int id, depth, children = 0;\n  //vector<node*> children;\n  node* parent;\n};\n\nmultiset<int> path[110];\nint cur = 0, n;\n\nvoid dfs_ninja(node x) {\n  int info;\n  cin >> info;\n  if(info > 0) {\n    while((x.id == 1 && x.children < info) || (x.id != 1 && x.children < info-1)) {\n      cur++;\n      node child;\n      child.id = cur; child.depth = x.depth + 1;\n      child.parent = &x;\n      x.children++;\n      path[x.id].insert(child.id);\n      path[child.id].insert(x.id);\n      dfs_ninja(child);\n    }\n    return;\n  }\n  else if(info < 0) {\n    node* ancestor = x.parent;\n    for(int i = 0; i < -info; i++) ancestor = ancestor->parent;\n    path[x.parent->id].erase(x.id);\n    path[x.id].erase(x.parent->id);\n    path[x.parent->id].insert(ancestor->id);\n    path[ancestor->id].insert(x.parent->id);\n    ancestor->children++;\n    cur--;\n    return;\n  }\n  else return;\n}\n\nint main() {\n  cin >> n;\n  for(int roop = 0; roop < n; roop++) {\n    node root;\n    cur++;\n    root.id = cur; root.depth = 0;\n    root.parent = nullptr;\n    dfs_ninja(root);\n    int fin;\n    cin >> fin;\n    for(int i = 0; i < cur; i++) {\n      cout << i+1 << \" \";\n      for(auto itr = path[i+1].begin(); itr != path[i+1].end(); itr++) {\n\tcout << *itr << \" \";\n      }\n      cout << endl;\n      path[i+1].clear();\n    }\n    cur = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, next, pos, deg[1000];\nvi v, st;\nvector<vi> e;\nchar in[1000];\n\nvoid rec(int c){\n\tdeg[c] = next;\n\tst.pb(c);\n\trep(i, deg[c]){\n\t\tif(pos == v.size()) break;\n\t\tnext = v[pos++];\n\t\tif(next < 0){\n\t\t\tint to = st[st.size() + next - 1];\n\t\t\tdeg[to]--;\n\t\t\te[c].pb(to);\n\t\t\te[to].pb(c);\n\t\t}\n\t\telse{\n\t\t\te[c].pb(c + 1);\n\t\t\te[c + 1].pb(c);\n\t\t\trec(c + 1);\n\t\t}\n\t}\n\tst.pop_back();\n}\n\nint main(){\n\tint cs;\n\tgets(in);\n\tsscanf(in, \"%d\", &cs);\n\twhile(cs--){\n\t\tgets(in);\n\t\tv.clear();\n\t\tint t, m = 0;\n\t\tstringstream ss(in);\n\t\twhile(ss >> t, t){\n\t\t\tv.pb(t);\n\t\t\tif(t > 0) m++;\n\t\t}\n\t\t\n\t\te.clear(); e.resize(m);\n\t\tnext = v[0];\n\t\tpos = 1;\n\t\trec(0);\n\t\t\n\t\trep(i, m){\n\t\t\tcout << (i + 1);\n\t\t\trep(j, e[i].size()) cout << \" \" << e[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[cnt] = now;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      --sz[num[dd + cnt]];\n      g[num[dd + cnt]].push_back(now);\n      g[now].push_back(num[dd + cnt]);\n    } else if(dd > 0) {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    } else {\n      throw (0);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    try {\n      Latte(idx, 0);\n      cin >> sz[0];\n    } catch(int x) {};\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nvector<int> edge[101];\nint door[101];\nint route[101];\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tmemset(door,0,sizeof(door));\n\t\tmemset(route,0,sizeof(route));\n\t\tfor(int j=0;j<100;j++){\n\t\t\tedge[j].clear();\n\t\t}\n\t\tint cnt=0,depth=0;\n\t\twhile(1){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x==0){\n\t\t\t\tfor(int i=0;i<cnt;i++){\n\t\t\t\t\tprintf(\"%d \",i+1);\n\t\t\t\t\tsort(edge[i].begin(),edge[i].end());\n\t\t\t\t\tfor(int j=0;j<edge[i].size();j++){\n\t\t\t\t\t\tprintf(\"%d%c\",edge[i][j]+1,j+1==edge[i].size()?'\\n':' ');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(x>0){\n\t\t\t\twhile(depth>1 && door[route[depth-1]]==edge[route[depth-1]].size())depth--;\n\t\t\t\tdoor[cnt]=x;\n\t\t\t\troute[depth]=cnt;\n\t\t\t\tif(depth>0){\n\t\t\t\t\tedge[cnt].push_back(route[depth-1]);\n\t\t\t\t\tedge[route[depth-1]].push_back(cnt);\n\t\t\t\t}\n\t\t\t\tdepth++;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(x<0){\n\t\t\t\twhile(depth>1 && door[route[depth-1]]==edge[route[depth-1]].size())depth--;\n\t\t\t\tedge[route[depth-1]].push_back(route[x+depth-1]);\n\t\t\t\tedge[route[x+depth-1]].push_back(route[depth-1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-100;\n      \n      //      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n       rep(i,dist[ff+inp[p]].size() ){\n\t //for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n      if ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n\n       //if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nvector<int> in;\n \nvector<int> G[1000];\nint pos=0;\nint path[1000];\nint ed[1000];\nint newn;\n \nvoid dfs(int cv,int depth){\n  //cout << cv << ' ' << depth << endl;\n  path[depth] = cv;\n  ed[cv] = in[pos++];\n  while(true){\n    int t=in[pos];\n    //cout << t << endl;\n    if(t<0){\n      int nv=path[depth+t];\n      G[cv].pb(nv);\n      G[nv].pb(cv);\n      ++pos;\n    }else{\n      ++newn;\n      G[cv].pb(newn);\n      G[newn].pb(cv);\n      dfs(newn,depth+1);\n    }\n    if(SZ(G[cv]) == ed[cv]) break;\n  }\n}\n \nvoid solve(){\n  newn = 0;\n  in.clear();\n  int t;\n  int no=0;\n  while(cin >> t, t){\n    no += t>0;\n    in.pb(t);\n  }\n \n  rep(i,no) G[i].clear();\n  pos = 0;\n  dfs(0,0);\n  rep(i,no) sort(ALL(G[i]));\n \n  rep(i,no){\n    cout << i+1;\n    FOR(it,G[i]) cout << ' ' << *it+1;\n    cout << endl;\n  }\n}\n \nint main(){\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi a, c, d;\n\t\tvector<vi> v(100);\n\t\tint in;\n\t\twhile(cin >> in, in)\n\t\t\ta.pb(in);\n\t\tint cur = 0, top = 0;\n\t\tc.pb(0); d.pb(a[0]);\n\t\tFOR(i, 1, a.size()) {\n\t\t\tif(a[i] > 0) {\n\t\t\t\ttop++;\n\t\t\t\tc.pb(c[cur]+1); d.pb(a[i]);\n\t\t\t\tv[top].pb(cur); v[cur].pb(top);\n\t\t\t\td[top]--; d[cur]--;\n\t\t\t\tcur = top;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to;\n\t\t\t\tfor(int j = top; j >= 0; j--) {\n\t\t\t\t\tif(c[j] - c[cur] == a[i]) {\n\t\t\t\t\t\tto = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[to].pb(cur); v[cur].pb(to);\n\t\t\t\td[to]--; d[cur]--;\n\t\t\t\tif(i == a.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t\twhile(!d[cur]) cur--;\n\t\t\t}\n\t\t}\n\t\tREP(i, top+1) {\n\t\t\tcout << i+1;\n\t\t\tsort(v[i].begin(), v[i].end());\n\t\t\tREP(j, v[i].size())\n\t\t\t\tcout << ' ' << v[i][j]+1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9+7\n\nusing namespace std;\n\nstruct room{\n  int depth;\n  int doors;\n  vector<int> dlist;\n  room() : depth(0), doors(0), dlist() {}\n};\n\nint main(){\n  int n; cin >> n;\n  REP(counter, n) {\n    int num;\n    vector<int> data;\n    int rs = 0;\n    while(cin >> num and num) {\n      data.push_back(num);\n      if(num > 0) rs++;\n    }\n    vector<room> rooms(rs);\n    int currentid = 0;\n    int currentdepth = 0;\n    vector<int> parents;\n    REP(i, data.size()){\n      // cout << data[i] << \" : \" << currentid << \", \" << currentdepth << endl;\n      // REP(j, parents.size()) cout << parents[j] << \" \";\n      // cout << endl;\n      if(data[i] > 1){\n        rooms[currentid].doors = data[i];\n        rooms[currentid].depth = currentdepth;\n        if(parents.size() != 0){\n          int parent = parents[currentdepth-1];\n          // cout << \"parent : \" << parent << \", \";\n          // cout << \"dest : \" << currentid << endl;\n          rooms[parent].dlist.push_back(currentid);\n          rooms[currentid].dlist.push_back(parent);\n        }\n        parents.push_back(currentid);\n        currentid++; currentdepth++;\n      } else if(data[i] == 1) {\n        rooms[currentid].doors = data[i];\n        rooms[currentid].depth = currentdepth;\n        if(parents.size() != 0){\n          int parent = parents[currentdepth-1];\n          // cout << \"parent : \" << parent << \", \";\n          // cout << \"dest : \" << currentid << endl;\n          rooms[parent].dlist.push_back(currentid);\n          rooms[currentid].dlist.push_back(parent);\n        }\n        currentdepth--;\n        while(currentdepth >= 0 and rooms[parents[currentdepth]].doors == rooms[parents[currentdepth]].dlist.size()){\n          // cout << \"del\" << endl;\n          parents.pop_back();\n          currentdepth--;\n        }\n        currentdepth++; currentid++;\n      } else {\n        currentdepth--;\n        int parent = parents[currentdepth];\n        // cout << \"parent : \" << parent << \", \";\n        int dest = parents[currentdepth + data[i]];\n        // cout << \"dest : \" << dest << endl;\n        rooms[parent].dlist.push_back(dest);\n        rooms[dest].dlist.push_back(parent);\n        while(currentdepth >= 0 and rooms[parents[currentdepth]].doors == rooms[parents[currentdepth]].dlist.size()){\n          // cout << \"del\" << endl;\n          parents.pop_back();\n          currentdepth--;\n        }\n        currentdepth++;\n      }\n    }\n    REP(i, rooms.size()) {\n      sort(ALL(rooms[i].dlist));\n      cout << i+1;\n      REP(j, rooms[i].doors){\n        cout << \" \" << rooms[i].dlist[j]+1;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nvoid solve()\n{\n\tvi a;\n\tfor(int x;cin>>x && x;) a.push_back(x);\n\t\n\tvector<pii> es;\n\tvi path(1,0),deg(1,a[0]);\n\tfor(int i=0,j=0,v=0;i<a.size()-1;i++){\n\t\twhile(deg[j]==0){\n\t\t\tpath.pop_back();\n\t\t\tdeg.pop_back();\n\t\t\tj--;\n\t\t}\n\t\tdeg[j]--;\n\t\tif(a[i+1]<0){\n\t\t\tes.emplace_back(path[j],path[j+a[i+1]]);\n\t\t\tdeg[j+a[i+1]]--;\n\t\t}\n\t\tif(a[i+1]>0){\n\t\t\tv++;\n\t\t\tes.emplace_back(path[j],v);\n\t\t\tpath.push_back(v);\n\t\t\tdeg.push_back(a[i+1]-1);\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tint n=0;\n\tfor(auto p:es) n=max({n,p.first,p.second});\n\t\n\tvvi g(++n);\n\tfor(auto p:es){\n\t\tint u,v; tie(u,v)=p;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\t\n\trep(u,n){\n\t\tcout<<u+1;\n\t\tsort(all(g[u]));\n\t\tfor(int v:g[u]) cout<<' '<<v+1;\n\t\tcout<<endl;\n\t}\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\trep(_,tc) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    vector<vector<int>> rooms(0);  // とりあえず0-indexed\n    vector<int> deg(0);            // ドアの個数\n    map<int, int> d2r;\n    int rec, dist = 0;\n    cin >> rec;\n    rooms.push_back(vector<int>(0));\n    deg.push_back(rec);\n    d2r[dist] = 0;\n    while (cin >> rec, rec != 0) {\n      while (rooms[d2r[dist]].size() == deg[d2r[dist]]) dist--;\n\n      if (rec > 0) {\n        deg.push_back(rec);\n        dist++;\n        rooms.push_back(vector<int>(1, d2r[dist - 1]));\n        d2r[dist] = rooms.size() - 1;\n        rooms[d2r[dist - 1]].push_back(d2r[dist]);\n      } else {\n        rooms[d2r[dist]].push_back(d2r[dist + rec]);\n        rooms[d2r[dist + rec]].push_back(d2r[dist]);\n      }\n    }\n    for (int r = 0; r < rooms.size(); r++) {\n      sort(rooms[r].begin(), rooms[r].end());\n      cout << r + 1 << ' ';\n      for (int j = 0; j < rooms[r].size(); j++) {\n        cout << rooms[r][j] + 1 << (j == rooms[r].size() - 1 ? \"\" : \" \");\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\n\n\n\n\n\nstruct state {\n  int index;\n  int free_child; //no. of free children\n};\n\n\n\nint trace_parent(int cur_index, int backtrack, int parentLookup[101]) {\n  if (backtrack == 0) return cur_index;\n  return trace_parent(parentLookup[cur_index], backtrack-1, parentLookup);\n}\n\n\nint main() {\n  int N; //no. of explorations\n  cin >> N;\n\n  for (int i = 0; i < N; i++) {\n    stack<state> path;\n    vector<int> output[101];\n    int parentLookup[101] = {-1}; //index is a child of entry on current path\n\n    int max_state = 1;\n    parentLookup[1] = 1;\n    \n    int entry;\n    cin >> entry;\n\n    while (entry != 0) {\n      //cout << \"inside entry:\" << entry <<  endl;\n      if (entry > 0) {\n\tstate new_state = { max_state, entry-1 };\n\t\n\t//add to output\n\tif (new_state.index != 1) {\n\t  int parent = path.top().index;\n\t  parentLookup[new_state.index] = parent;\n\t  output[new_state.index].push_back(parent);\n\t  output[parent].push_back(new_state.index);\n\t}\n\t\n\tpath.push(new_state);\n\tmax_state++;\n      } else if (entry < 0) {\n\tint backlink_id = trace_parent(path.top().index, -entry, parentLookup);\n\toutput[path.top().index].push_back(backlink_id);\n\toutput[backlink_id].push_back(path.top().index);\n\tpath.top().free_child -= 1;\n\tif (path.top().free_child == 0) {\n\t  path.pop();\n\t}\n      }\n      cin >> entry; \n    }\n    \n    for (int i = 1; i < max_state; i++) {\n      cout << i << \" \";\n      sort(output[i].begin(), output[i].end());\n      for (vector<int>::const_iterator j = output[i].begin(); j != output[i].end(); ++j) {\n\tcout << *j << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n; cin >> n;\n\twhile (n--)\n\t{\n\t\tvi v;\n\t\tint t;\n\t\twhile (cin >> t, t) v.push_back(t);\n\t\tint m = 0;\n\t\tREP(i, v.size()) if (v[i] > 0) m++;\n\t\tvi dist(m), rem(m);\n\t\tvector<vi> ans(m);\n\t\tstack<int> st;\n\t\tst.push(0);\n\t\tint r = 0;\n\t\tdist[0] = 0;\n\t\trem[0] = v[0];\n\t\tFOR(i, 1, v.size())\n\t\t{\n\t\t\twhile (rem[st.top()] == 0) st.pop();\n\t\t\tint tmp = st.top();\n\t\t\tif (v[i] > 0)\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\trem[tmp]--;\n\t\t\t\trem[r] = v[i]-1;\n\t\t\t\tans[tmp].push_back(r);\n\t\t\t\tans[r].push_back(tmp);\n\t\t\t\tdist[r] = dist[tmp] + 1;\n\t\t\t\tst.push(r);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(j, m)\n\t\t\t\t{\n\t\t\t\t\tif (dist[j] - dist[tmp] == v[i] && rem[j] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trem[tmp]--;\n\t\t\t\t\t\trem[j]--;\n\t\t\t\t\t\tans[tmp].push_back(j);\n\t\t\t\t\t\tans[j].push_back(tmp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tcout << i + 1 << \" \";\n\t\t\tsort(ALL(ans[i]));\n\t\t\tREP(j, ans[i].size())\n\t\t\t{\n\t\t\t\tcout << ans[i][j] + 1 << (j == ans[i].size() - 1 ? \"\\n\" : \" \");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(void) {\n  ll N;\n  cin >> N;\n  REP(_, 0, N) {\n    ll n = 0;\n    vector<ll> A;\n    while(1) {\n      ll x; cin >> x;\n      if(x == 0) break;\n      if(x > 0) n++;\n      A.push_back(x);\n    }\n\n    vector<vector<ll>> E(n);\n    vector<pll> stk;\n    ll idx = 0;\n    REP(i, 0, A.size()) {\n      if(A[i] > 0) {\n        stk.push_back(pll(idx++, A[i]));\n        if(stk.size() > 1) {\n          ll u = stk[stk.size() - 2].first, v = stk[stk.size() - 1].first;\n          E[u].push_back(v);\n          E[v].push_back(u);\n          stk[stk.size() - 1].second--;\n          stk[stk.size() - 2].second--;\n        }\n      } else {\n        ll u = stk[stk.size() - 1].first, v = stk[stk.size() - 1 + A[i]].first;\n        E[u].push_back(v);\n        E[v].push_back(u);\n        stk[stk.size() - 1].second--;\n        stk[stk.size() - 1 + A[i]].second--;\n      }\n      while(stk.size() > 0 && stk.back().second == 0) {\n        stk.resize(stk.size() - 1);\n      }\n    }\n\n    REP(i, 0, n) {\n      sort(E[i].begin(), E[i].end());\n      cout << i + 1;\n      REP(j, 0, E[i].size()) cout << \" \" << E[i][j] + 1;\n      cout << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 110\nusing namespace std;\nconst int INF = 1LL<<55;\nint Max(int &a,int b){return a=max(a,b);}\nint Min(int &a,int b){return a=min(a,b);}\nstruct dat{int cnt, num_door , dis;};\nvector<int> G[N];\nvector<int> rec;\nvector<dat> A;\n\nbool can_add_edge(int a,int b,int r){\n  return A[a].cnt && A[b].cnt && A[a].dis - A[b].dis == r;\n}\n\nvoid add_edge(int a,int b){\n  assert(A[a].cnt-- && A[b].cnt--);\n  G[a].push_back(b);\n  G[b].push_back(a);\n  sort(G[a].begin(),G[a].end());\n  sort(G[b].begin(),G[b].end());\n}\n\nvoid dfs(int idx,int num){\n  if(idx >= (int)rec.size()) return;\n  int pos = num;\n\n  while(idx<(int)rec.size() && rec[idx]<0){\n    for(int i=0;i<(int)A.size()-1;i++){\n      if(!can_add_edge(i,pos,rec[idx])) continue;\n      add_edge(i,pos);\n      idx++;\n      break;\n    }\n    while(pos && A[pos].cnt == 0) pos--;\n  }\n  if(idx >= (int)rec.size()) return;\n\n  while(A[pos].cnt == 0) pos--;\n  A.push_back((dat){rec[idx],rec[idx],A[pos].dis+1});\n  add_edge(pos,num+1);\n  dfs(idx+1,num+1);\n}\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    for(int i=0;i<N;i++) G[i].clear();    \n    rec.clear();\n    for(int a;cin>>a,a;)rec.push_back(a);\n\n    A.clear();\n    A.push_back((dat){rec[0],rec[0],0});\n    dfs(1,0);\n\n    for(int i=0;i<(int)A.size();i++){\n      cout<<i+1;\n      for(int a:G[i]) cout<<\" \"<<a+1;\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  while(n--){\n    int a[200],m,t=0,x=0;\n    for(int i=0;;i++){\n      cin>>a[i];\n      if(!a[i]){\n\tm=i;\n\tbreak;\n      }\n    }\n    vector<int> G[200],b(200,0),c(200,0);\n    stack<int> s;\n    for(int i=0;i<m;i++){\n      s.push(++x);\n      b[x]=a[i];\n      c[s.size()]=x;\n      while(a[i+1]<0&&(int)G[x].size()<b[x]) {\n\t//cout<<x<<\" \"<<s.size()<<\" \"<< a[i+1]<<\"/\"<<c[s.size()+a[i+1]]<<endl;\n\tG[x].push_back(c[s.size()+a[++i]]);\n\tG[c[s.size()+a[i]]].push_back(x);\n      }\n      for(int k;;){\n\tk=s.top();\n\tif(b[k]==(int)G[k].size()) s.pop();\n\telse break;\n      }\n      t=s.top();\n      if(a[i+1]>0){\n        //cout<<t<<\" \"<<x+1<<endl;\n\tG[t].push_back(x+1);\n\tG[x+1].push_back(t);\n      }else{\n\twhile(a[i+1]<0&&(int)G[t].size()<b[t]) {\n\t  //cout<<t<<\" \"<<s.size()<<\" \"<< a[i+1]<<\"/\"<<c[s.size()+a[i+1]]<<endl;\n\t  G[t].push_back(c[s.size()+a[++i]]);\n\t  G[c[s.size()+a[i]]].push_back(t);\n\t}\n      }\n    }\n    //for(int i=1;i<x;i++) cout<<i<<\" \"<<c[i]<<endl;\n    for(int i=1;i<=x;i++){\n      if(G[i].size()==0) break;\n      cout<<i<<\" \";\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<(int)G[i].size();j++)\n\tcout<<G[i][j]<<\" \\n\"[j==(int)G[i].size()-1];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(void) {\n  ll N;\n  cin >> N;\n  REP(_, 0, N) {\n    ll n = 0;\n    vector<ll> A;\n    while(1) {\n      ll x; cin >> x;\n      if(x == 0) break;\n      if(x > 0) n++;\n      A.push_back(x);\n    }\n\n    vector<vector<ll>> E(n);\n    vector<pll> stk;\n    ll idx = 0;\n    REP(i, 0, A.size()) {\n      if(A[i] > 0) {\n        stk.push_back(pll(idx++, A[i]));\n        if(stk.size() > 1) {\n          ll u = stk[stk.size() - 2].first, v = stk[stk.size() - 1].first;\n          E[u].push_back(v);\n          E[v].push_back(u);\n          stk[stk.size() - 1].second--;\n          stk[stk.size() - 2].second--;\n        }\n      } else {\n        ll u = stk[stk.size() - 1].first, v = stk[stk.size() - 1 + A[i]].first;\n        E[u].push_back(v);\n        E[v].push_back(u);\n        stk[stk.size() + A[i]].second--;\n        stk.back().second--;\n      }\n      while(stk.size() > 0 && stk.back().second == 0) {\n        stk.resize(stk.size() - 1);\n      }\n    }\n\n    REP(i, 0, n) {\n      sort(E[i].begin(), E[i].end());\n      cout << i + 1;\n      REP(j, 0, E[i].size()) cout << \" \" << E[i][j] + 1;\n      cout << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint size;\n\nvector<vector<int> > edge;\nvector<int> dim;\n\nvoid dfs(int depth, int* parent){\n\t/*\n\tprintf(\"depth %d\\n\", depth);\n\tfor(int i = 0; i < depth; i++){\n\t\tprintf(\"(%d, %d, %d)\", parent[i], dim[parent[i]], edge[parent[i]].size());\n\t}\n\tcout << endl;\n\t*/\n\tint val;\n\tcin >> val;\n\tif(val == 0){\n\t\treturn;\n\t}else if(val > 0){\n\t\tint idx = dim.size();\n\t\tdim.push_back(val);\n\t\tedge.push_back(vector<int>());\n\t\tif(depth){\n\t\t\tedge[idx].push_back(parent[depth- 1]);\n\t\t\tedge[parent[depth - 1]].push_back(idx);\n\t\t}\n\t\tparent[depth] = idx;\n\t\twhile(edge[idx].size() < val){\n\t\t\tdfs(depth + 1, parent);\n\t\t}\n\t\t\n\t}else{\n\t\tint ci = parent[depth - 1];\n\t\tint ti = parent[depth - 1 + val];\n\t\tedge[ci].push_back(ti);\n\t\tedge[ti].push_back(ci);\n\t}\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(N--){\n\t\tdim.clear();\n\t\tedge.clear();\n\t\tint parent[200];\n\t\tdfs(0, parent);\n\t\tint val;\n\t\tcin >> val;\n\t\tfor(int i = 0; i < dim.size(); i++){\n\t\t\tcout << (i + 1) ;\n\t\t\tsort(edge[i].begin(), edge[i].end());\n\t\t\tfor(auto v : edge[i]) cout << \" \" << (v + 1);\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-1;\n      \n      //      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n       rep(i,dist[ff+inp[p]].size() ){\n\t //for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n      if ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n\n       //if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi a, c, d;\n\t\tvector<vi> v(100);\n\t\tint in;\n\t\twhile(cin >> in, in)\n\t\t\ta.pb(in);\n\t\tint cur = 0, top = 0;\n\t\tc.pb(0); d.pb(a[0]);\n\t\tFOR(i, 1, a.size()) {\n\t\t\tif(a[i] > 0) {\n\t\t\t\ttop++;\n\t\t\t\tc.pb(c[cur]+1); d.pb(a[i]);\n\t\t\t\tv[top].pb(cur); v[cur].pb(top);\n\t\t\t\td[top]--; d[cur]--;\n\t\t\t\tcur = top;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to;\n\t\t\t\tfor(int j = cur; j >= 0; j--) {\n\t\t\t\t\tif(c[j] - c[cur] == a[i]) {\n\t\t\t\t\t\tto = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[to].pb(cur); v[cur].pb(to);\n\t\t\t\td[to]--; d[cur]--;\n\t\t\t\tif(i == a.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t\twhile(!d[cur]) cur--;\n\t\t\t}\n\t\t}\n\t\tREP(i, d.size()) {\n\t\t\tif(v[i].size()) {\n\t\t\t\tcout << i+1;\n\t\t\t\tsort(v[i].begin(), v[i].end());\n\t\t\t\tREP(j, v[i].size())\n\t\t\t\t\tcout << ' ' << v[i][j]+1;\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint a[500],x,c;\nint t[500],u[500];\nvector<int> G[500];\n \nvoid init(){\n  for(int i=0;i<500;i++){\n    G[i].clear();\n    u[i]=0;\n  }\n}\n \nint main(){\n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    init();\n    a[0]=x=c=1;\n    cin>>t[1];\n    int q;\n    while(1){\n      //if(x==0){cin>>q;break;}\n      int p=a[--x];\n      if(t[p]>0&&t[p]==(int)G[p].size())\n        continue; \n      cin>>q;\n      if(q==0)break;\n      if(q>0){\n        t[++c]=q;\n        G[p].push_back(c);\n        G[c].push_back(p);\n        a[x++]=p;\n        a[x++]=c;\n      }else{\n        G[p].push_back(a[x+q]);\n        G[a[x+q]].push_back(p);\n        if((int)G[p].size()<t[p])a[x++]=p;\n      }\n    }\n \n    for(int i=1;G[i].size();i++){\n      cout<<i;\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<(int)G[i].size();j++)\n        cout<<' '<<G[i][j];\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    for (int t = 0; t < n; ++t)\n    {\n        map<int,vector<int>> G;\n        map<int,vector<int>> vs;\n        int id = 0;\n        while (true) {\n            int a; cin >> a;\n            if (a == 0) break;\n\n            if (vs.empty()) {\n                for (int i = 0; i < a; ++i) {\n                    vs[0].push_back(id);\n                }\n                ++id;\n                continue;\n            }\n\n            auto tp = vs.rbegin();\n            int depth = tp->first;\n            vector<int>& v = tp->second;\n            int k = v.back();\n            v.pop_back();\n\n            if (v.size() == 0) {\n                vs.erase(depth);\n            }\n\n            if (a > 0) {\n                G[k].push_back(id);\n                G[id].push_back(k);\n                for (int i = 0; i < a-1; ++i) {\n                    vs[depth+1].push_back(id);\n                }\n                ++id;\n            } else {\n                int to = vs[depth + a].back();\n                G[k].push_back(to);\n                G[to].push_back(k);\n                vs[depth + a].pop_back();\n                if (vs[depth + a].size() == 0) {\n                    vs.erase(depth + a);\n                }\n            }\n        }\n\n        for (auto& tp : G) {\n            cout << tp.first + 1;\n            sort(tp.second.begin(), tp.second.end());\n            for (int v : tp.second) {\n                cout << \" \" << v + 1;\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid dfs(int node, int &p, vector<int> &seq, vector<int> &stk, vector<int> &ctr, vector<vector<int> > &adj){\n    if(seq[p] < 0){\n        int n = stk.size();\n        int curr = stk[n-1];\n        int prev = stk[n-1 +seq[p]];\n        adj[curr].push_back(prev);\n        adj[prev].push_back(curr);\n        ctr[prev]--;\n        p++;\n        return;\n    }\n    int n = adj.size();\n    adj.emplace_back();\n    ctr.push_back(seq[p]);\n    stk.push_back(n);\n    p++;\n    if(node!=-1){\n        adj[n].push_back(node);\n        adj[node].push_back(n);\n    }\n    while(ctr[n] > 0){\n        dfs(n, p, seq, stk, ctr, adj);\n        ctr[n]--;\n    }\n    stk.pop_back();\n}\n\nint main(){\n    int rep=0;\n    cin >> rep;\n    for(int r=0; r<rep; r++){\n        vector<int> a;\n        while(1){\n            int d;\n            cin >> d;\n            if(d == 0) break;\n            if(d > 0) d--;\n            a.push_back(d);\n        }\n        vector<int> ctr, stk;\n        vector<vector<int> > adj;\n        int p=0;\n        dfs(-1, p, a, stk, ctr, adj);\n        for(int i=0; i<(int)adj.size(); i++){\n            cout << i+1;\n            sort(adj[i].begin(), adj[i].end());\n            for(int j=0; j<(int)adj[i].size(); j++){\n                cout << \" \" << adj[i][j]+1;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n\n\nint trace_parent(int cur_index, int backtrack, int parentLookup[101]) {\n  if (backtrack == 1) return parentLookup[cur_index];\n  return trace_parent(parentLookup[cur_index], backtrack-1, parentLookup);\n}\n\n\nint main() {\n  int N; //no. of explorations\n  cin >> N;\n\n  for (int i = 0; i < N; i++) {\n    stack<int> path;\n    vector<int> output[101];\n    int parentLookup[101] = {-1}; //index is a child of entry on current path\n    int freeChild[101] = {-1}; // how many unclosed children\n\n    int max_state = 1;\n    parentLookup[1] = 1;\n    \n    int entry;\n    cin >> entry;\n\n    while (entry != 0) {\n      if (entry > 0) {\n\tint new_state = max_state;\n\tif (new_state == 1) {\n\t  freeChild[new_state] = entry;\n\t} else {\n\t  freeChild[new_state] = entry - 1;\n\t}\n\n\t\n\t//add to output\n\tif (new_state != 1) {\n\t  int parent = path.top();\n\t  parentLookup[new_state] = parent;\n\t  output[new_state].push_back(parent);\n\t  output[parent].push_back(new_state);\n\t}\n\t\n\tpath.push(new_state);\n\tmax_state++;\n      } else if (entry < 0) {\n\tint backlink_id = trace_parent(path.top(), -entry, parentLookup);\n\t//cout << \"parent of \" << path.top() << \"is: \" << backlink_id << endl;\n\toutput[path.top()].push_back(backlink_id);\n\toutput[backlink_id].push_back(path.top());\n\tfreeChild[path.top()] -= 1;\n\tfreeChild[backlink_id] -= 1;\n      }\n      \n      while (freeChild[path.top()] == 0) {\n\tif (path.top() == 1) break;\n\tpath.pop();\n\tfreeChild[path.top()] -= 1;\t\n      }\n      cin >> entry; \n    }\n    \n    \n    for (int i = 1; i < max_state; i++) {\n      cout << i;\n      sort(output[i].begin(), output[i].end());\n      for (vector<int>::const_iterator j = output[i].begin(); j != output[i].end(); ++j) {\n\tcout << \" \" <<  *j;\n      }\n      cout << endl;\n    }\n  }\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef complex<double> xy_t;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    int rec;\n    int count = 0;\n    int depth = 0;\n    int vs[2000];\n    int unopen[2000];\n    vector<int> G[2000];\n\n    while(cin >> rec && rec != 0){\n      while(depth > 0 && unopen[depth] == 0) depth--;\n      unopen[depth]--;\n      if(rec > 1){\n\tvs[++depth]   = ++count;\n\tunopen[depth] = rec - 1;\n\t\n\tif(depth > 1){\n\t  G[count].push_back(vs[depth-1]);\n\t  G[vs[depth-1]].push_back(count);\n\t}\n\t\n      }else{\n\tG[vs[depth + rec]].push_back(vs[depth]);\n\tG[vs[depth]].push_back(vs[depth + rec]);\n\tunopen[depth + rec]--;\n      }\n    }\n    \n    REP2(i, 1, count + 1){\n      cout << i;\n      sort(ALL(G[i]));\n      REP(j, G[i].size()) cout << \" \" << G[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[100];\nint sz[100], num[100];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < now; j++) {\n        if(num[j] - cnt == dd && sz[j] > 1) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n        }\n      }\n    } else {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 100; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n    cin >> sz[0];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  while(n--){\n    int a[200],m,t=0,x=0;\n    for(int i=0;;i++){\n      cin>>a[i];\n      if(!a[i]){\n\tm=i;\n\tbreak;\n      }\n    }\n    vector<int> G[200],b(200,0),c(200,0);\n    stack<int> s;\n    for(int i=0;i<m;i++){\n      s.push(++x);\n      b[x]=a[i];\n      c[s.size()]=x;\n      while(a[i+1]<0&&(int)G[x].size()<b[x]) {\n\t//cout<<x<<\" \"<<s.size()<<\" \"<< a[i+1]<<\"/\"<<c[s.size()+a[i+1]]<<endl;\n\tG[x].push_back(c[s.size()+a[++i]]);\n\tG[c[s.size()+a[i]]].push_back(x);\n      }\n      for(int k;;){\n\tk=s.top();\n\tif(b[k]==(int)G[k].size()) s.pop();\n\telse break;\n      }\n      t=s.top();\n      if(a[i+1]>0){\n        //cout<<t<<\" \"<<x+1<<endl;\n\tG[t].push_back(x+1);\n\tG[x+1].push_back(t);\n      }else{\n\twhile(a[i+1]<0&&(int)G[t].size()<b[t]) {\n\t  //cout<<t<<\" \"<<s.size()<<\" \"<< a[i+1]<<\"/\"<<c[s.size()+a[i+1]]<<endl;\n\t  G[t].push_back(c[s.size()+a[++i]]);\n\t  G[c[s.size()+a[i]]].push_back(t);\n\t}\n      }\n    }\n    //for(int i=1;i<x;i++) cout<<i<<\" \"<<c[i]<<endl;\n    for(int i=1;i<=x;i++){\n      if(G[i].size()==0) break;\n      cout<<i<<\" \";\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<(int)G[i].size();j++)\n\tcout<<G[i][j]<<\" \\n\"[j==(int)G[i].size()-1];\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cin.tie(0);\n}\n\n#define int ll\nvector<int> vertexs[300];\nint cnt[300];\nvoid solve(){\n    REP(i, 300) {\n        vertexs[i].clear();\n        cnt[i] = 0;\n    }\n    vector<int> inputs;\n    while (true) {\n        int a;\n        cin >> a;\n        if (a == 0) break;\n        inputs.push_back(a);\n    }\n    cnt[0] = inputs[0];\n    int n = 1;\n    vector<int> next;\n    next.push_back(0);\n    auto add = [](int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    };\n    for (int i = 1; i < inputs.size(); ++i) {\n        while (cnt[next.back()] == 0) {\n            next.pop_back();\n        }\n        if (inputs[i] < 0) {\n            cnt[next.back()]--;\n            cnt[next[next.size() - 1 + inputs[i]]]--;\n            add(next.back(), next[next.size() - 1 + inputs[i]]);\n        }\n        else {\n            cnt[next.back()]--;\n            next.push_back(n);\n            n++;\n            cnt[next.back()] = inputs[i] - 1;\n            add(next.back(), next[next.size() - 2]);\n        }\n    }\n    REP(i, n) {\n        cout << i + 1;\n        sort(ALL(vertexs[i]));\n        REP(q, vertexs[i].size()) {\n            cout << \" \" << vertexs[i][q] + 1;\n        }\n        cout << endl;\n    }\n}\n#undef int\nint main() {\n    init();\n    int t;\n    cin >> t;\n    REP(tea,t)\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi a, c, d;\n\t\tvector<vi> v(100);\n\t\tint in;\n\t\twhile(cin >> in, in)\n\t\t\ta.pb(in);\n\t\tint cur = 0, top = 1;\n\t\tc.pb(0); d.pb(a[0]);\n\t\tFOR(i, 1, a.size()) {\n\t\t\tif(a[i] > 0) {\n\t\t\t\tc.pb(c[cur]+1); d.pb(a[i]);\n\t\t\t\tv[top].pb(cur); v[cur].pb(top);\n\t\t\t\td[top]--; d[cur]--;\n\t\t\t\tcur = top++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to;\n\t\t\t\tfor(int j = cur; j >= 0; j--) {\n\t\t\t\t\tif(c[j] - c[cur] == a[i] && d[j] > 0) {\n\t\t\t\t\t\tto = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[to].pb(cur); v[cur].pb(to);\n\t\t\t\td[to]--; d[cur]--;\n\t\t\t\tif(i == a.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(!d[cur]) cur--;\n\t\t}\n\t\tREP(i, top) {\n\t\t\tcout << i+1;\n\t\t\tsort(v[i].begin(), v[i].end());\n\t\t\tREP(j, v[i].size())\n\t\t\t\tcout << ' ' << v[i][j]+1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=366,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        vector<int> S,deg;\n        while(1){\n            int a;cin>>a;\n            if(a==0) break;\n            if(a>0) deg.push_back(a);\n            S.push_back(a);\n        }\n        \n        int N=si(deg);\n        \n        vector<vector<int>> E(N);\n        vector<int> depth(N,INF),par(N,-1);\n        depth[0]=0;\n        \n        int now=0,nex=1;\n        \n        for(int t=1;t<si(S);t++){\n            int a=S[t];\n            if(a>0){\n                while(deg[now]==0) now=par[now];\n                deg[now]--;\n                deg[nex]--;\n                E[now].push_back(nex);\n                E[nex].push_back(now);\n                depth[nex]=depth[now]+1;\n                par[nex]=now;\n                \n                //cout<<now<<\" \"<<nex<<endl;\n                \n                now=nex;\n                nex++;\n            }else{\n                while(deg[now]==0) now=par[now];\n                for(int i=0;i<N;i++){\n                    if(depth[i]==depth[now]+a&&deg[i]){\n                        deg[i]--;\n                        deg[now]--;\n                        E[i].push_back(now);\n                        E[now].push_back(i);\n                        \n                        //cout<<now<<\" \"<<i<<endl;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        for(int i=0;i<N;i++){\n            cout<<i+1;\n            sort(all(E[i]));\n            for(int j:E[i]) cout<<\" \"<<j+1;\n            cout<<endl;\n        }\n        \n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    vector<int> r;\n    while(true){\n        int in;\n        cin >> in;\n        if(!in) break;\n        r.emplace_back(in);\n    }\n\n    vector<vector<int>> graph;\n    vector<int> cnts;\n    auto it=r.begin();\n    function<void(const int,const int)> dfs=[&](const int cnt,const int par){\n        const int id=graph.size();\n        graph.emplace_back(vector<int>(*it,-1));\n        cnts.emplace_back(cnt);\n        if(par!=-1) graph[id][0]=par;\n        ++it;\n        rep(i,1,graph[id].size()){\n            if(graph[id][i]!=-1) continue;\n            if(*it<0){\n                [&](){\n                    rep(j,0,graph.size()){\n                        if(cnts[j]-cnts[id]!=*it) continue;\n                        rep(k,0,graph[j].size()){\n                            if(graph[j][k]!=-1) continue;\n                            graph[id][i]=j;\n                            graph[j][k]=id;\n                            return;\n                        }\n                    }\n                }();\n                ++it;\n            }else{\n                graph[id][i]=graph.size();\n                dfs(cnt+1,id);\n            }\n        }\n    };\n    dfs(0,-1);\n    rep(i,0,graph.size()){\n        cout << i+1;\n        sort(graph[i].begin(),graph[i].end());\n        for(const auto id:graph[i]) cout << \" \" << id+1;\n        cout << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    int n;\n    cin >> n;\n    rep(i,0,n) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nclass room{\npublic:\n  int prev;\n  int doors;\n  int dist;\n  vector<int> next;\n  room(int p,int d,int d2){\n    prev=p;\n    doors=d;\n    dist=d2;\n    next=vector<int>();\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n-->0){\n    vector<room> rooms;\n    int r;\n    int p=-1;\n    int d=0;\n    while(cin >> r,r){\n      /*\n      //printf(\"r=%d (p=%d,d=%d) :\\n\",r,p+1,d);\n      if(r>0){\n        d++;\n        rooms.push_back(room(p,r,d));\n        if(p>=0){\n          //cout << \"connect (\" << p+1 << \"<=>\" << rooms.size() << \")\";\n          rooms[p].next.push_back(rooms.size()-1);\n          rooms[rooms.size()-1].next.push_back(p);\n        }\n        p=rooms.size()-1;\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n      }else{\n        int next;\n        for(next=0;next<rooms.size();next++){\n          if(d+r==rooms[next].dist&&rooms[next].next.size()!=rooms[next].doors)\n            break;\n        }\n\n        //cout << \"connect (\" << p+1 << \"<=>\" << next+1 << \")\";\n        rooms[p].next.push_back(next);\n        rooms[next].next.push_back(p);\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n      }\n      //cout << endl;\n    }\n    //while(p!=-1);\n    for(int i=0;i<rooms.size();i++){\n      cout << i+1 << \" \";\n      while(rooms[i].next.size()!=rooms[i].doors);\n      sort(rooms[i].next.begin(),rooms[i].next.end());\n      for(int j=0;j<rooms[i].next.size();j++){\n        cout << rooms[i].next[j]+1 << (j==rooms[i].next.size()-1?'\\n':' ');\n      }\n      */\n    }\n    //cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, next, pos, deg[1000], m;\nvi v, st;\nvector<vi> e;\n\nvoid rec(int c){\n\tdeg[c] = next;\n\tst.pb(c);\n\trep(i, deg[c] - 1){\n\t\tnext = v[pos++];\n\t\tif(next < 0){\n\t\t\tint to = st[st.size() + next - 1];\n\t\t\tdeg[to]--;\n\t\t\te[c].pb(to);\n\t\t\te[to].pb(c);\n\t\t}\n\t\telse{\n\t\t\te[c].pb(m);\n\t\t\te[m].pb(c);\n\t\t\trec(m++);\n\t\t}\n\t}\n\tst.pop_back();\n}\n\nint main(){\n\tint cs;\n\tcin >> cs;\n\twhile(cs--){\n\t\tv.clear();\n\t\tint t;\n\t\tm = 0;\n\t\twhile(cin >> t, t){\n\t\t\tv.pb(t);\n\t\t\tif(t > 0) m++;\n\t\t}\n\t\t\n\t\te.clear(); e.resize(m);\n\t\tnext = v[0];\n\t\tpos = m = 1;\n\t\trec(0);\n\t\t\n\t\trep(i, m){\n\t\t\tsort(all(e[i]));\n\t\t\tcout << (i + 1);\n\t\t\trep(j, e[i].size()) cout << \" \" << e[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint main(){\n\tint TT;\n\tcin>>TT;\n\trep(tt,TT){\n\t\tbool in[100]={};\n\t\tvector<int> ans[100];\n\t\tint sz[100]={},dis[100]={},it[100]={},p[100]={};\n\t\trep(i,100) dis[i]=1000;\n\t\tint now=0,N=1;\n\t\twhile(true){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x==0) break;\n\t\t\tif(x>0){\n\t\t\t\tans[now].pb(N);\n\t\t\t\tans[N].pb(now);\n\t\t\t\tp[N]=now;\n\t\t\t\tit[now]++;\n\t\t\t\tit[N]++;\n\t\t\t\tsz[N]=x;\n\t\t\t\tdis[N]=dis[now]+1;\n\t\t\t\tin[N]=1;\n\t\t\t\tnow=N;\n\t\t\t\tN++;\n\t\t\t}else{\n\t\t\t\trep(i,N) if(in[i]&&dis[i]-dis[now]==x){\n\t\t\t\t\tans[i].pb(now);\n\t\t\t\t\tans[now].pb(i);\n\t\t\t\t\tit[now]++;\n\t\t\t\t\tit[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(it[now]==sz[now]){\n\t\t\t\tin[now]=0;\n\t\t\t\tnow=p[now];\n\t\t\t}\n\t\t}\n\t\trep1(i,N-1){\n\t\t\tsort(all(ans[i]));\n\t\t\tcout<<i<<\" \";\n\t\t\trep(j,ans[i].size()){\n\t\t\t\tif(i==1&&j==0) continue;\n\t\t\t\tcout<<ans[i][j]<< (j+1==ans[i].size() ? \"\\n\" : \" \");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\nint n;\nvector<int> record;\nint m;\nmultiset<int> E[101];\nint num[101];\nint dep[101];\nint par[101];\n//-----------------------------------------------------------------\nvoid dfs(int& idx, int cur, int dpt) {\n\tif (idx == record.size()) return;\n\tif (E[cur].size() == num[cur]) return;\n\n\tif (0 < record[idx]) {\n\t\tm++;\n\t\tnum[m] = record[idx];\n\t\tif (0 < cur) {\n\t\t\tE[m].insert(cur);\n\t\t\tE[cur].insert(m);\n\t\t}\n\t\tdep[m] = dpt;\n\t\tpar[m] = cur;\n\t\tidx++;\n\t\tdfs(idx, m, dpt + 1);\n\t} else {\n\t\t//printf(\"<%d : %d : %d>\\n\", cur, dpt - 1, record[idx]);\n\t\trep(i, 0, m) if (dep[i] == dpt - 1 + record[idx] && E[i].size() < num[i]) {\n\t\t\tE[i].insert(cur);\n\t\t\tE[cur].insert(i);\n\t\t\t//printf(\"Break!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\n\tdfs(idx, cur, dpt);\n}\nvoid solve() {\n\tint idx = 0;\n\tm = 0;\n\trep(k, 0, 101) E[k].clear();\n\tdep[0] = -1;\n\tpar[0] = -1;\n\tnum[0] = -1;\n\tdfs(idx, 0, 0);\n\t//rep(i, 0, m) cout << dep[i] << endl;\n\trep(i, 0, m) {\n\t\tcout << (i + 1);\n\t\tfor (int j : E[i + 1]) cout << \" \" << j;\n\t\tcout << endl;\n\t}\n}\n//-----------------------------------------------------------------\nint main() {\n\tcin >> n;\n\trep(i, 0, n) {\n\t\trecord.clear();\n\n\t\tint j;\n\t\twhile (cin >> j) {\n\t\t\tif (j == 0) break;\n\t\t\trecord.push_back(j);\n\t\t}\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_ROOM = 100;\n\nvector<int> sequence;\n\nint next_v;\nint degree[MAX_ROOM];\nint dist[MAX_ROOM];\nvector<int> G[MAX_ROOM];\n\nvoid dfs(int v, int &idx) {\n\tif(idx == sequence.size()) return;\n\n\tdegree[v] = sequence[idx++] - (v ? 1 : 0);\n\n\twhile(degree[v]--) {\n\t\tif(sequence[idx] > 0) {\n\t\t\tG[v].emplace_back(next_v);\n\t\t\tG[next_v].emplace_back(v);\n\t\t\tdist[next_v] = dist[v] + 1;\n\t\t\tdfs(next_v++, idx);\n\t\t}\n\t\telse {\n\t\t\tfor(int u = 0; u < v; ++u) {\n\t\t\t\tif(dist[u] - dist[v] == sequence[idx] && degree[u]) {\n\t\t\t\t\tG[v].emplace_back(u);\n\t\t\t\t\tG[u].emplace_back(v);\n\t\t\t\t\t--degree[u];\n\t\t\t\t\t++idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init() {\n\tsequence.clear();\n\tnext_v = 1;\n\tmemset(dist, -1, sizeof(dist));\n\tdist[0] = 0;\n\tfor(auto &vec : G) vec.clear();\n}\n\nvoid solve() {\n\tinit();\n\tfor(int number; cin >> number && number;) {\n\t\tsequence.emplace_back(number);\n\t}\n\n\tint idx = 0;\n\tdfs(0, idx);\n\n\tfor(int v = 0; v < next_v; ++v) {\n\t\tsort(G[v].begin(), G[v].end());\n\t\tcout << v + 1;\n\t\tfor(const auto &to : G[v]) cout << \" \" << to + 1;\n\t\tcout << \"\\n\";\n\t}\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\n\twhile(t--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi a, c, d;\n\t\tvector<vi> v(100);\n\t\tint in;\n\t\twhile(cin >> in, in)\n\t\t\ta.pb(in);\n\t\tint cur = 0, top = 0;\n\t\tc.pb(0); d.pb(a[0]);\n\t\tFOR(i, 1, a.size()) {\n\t\t\tif(a[i] > 0) {\n\t\t\t\ttop++;\n\t\t\t\tc.pb(c[cur]+1); d.pb(a[i]);\n\t\t\t\tv[top].pb(cur); v[cur].pb(top);\n\t\t\t\td[top]--; d[cur]--;\n\t\t\t\tcur = top;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to;\n\t\t\t\tfor(int j = cur; j >= 0; j--) {\n\t\t\t\t\tif(c[j] - c[cur] == a[i]) {\n\t\t\t\t\t\tto = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[to].pb(cur); v[cur].pb(to);\n\t\t\t\td[to]--; d[cur]--;\n\t\t\t\tif(i == a.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t\twhile(!d[cur]) cur--;\n\t\t\t}\n\t\t}\n\t\tREP(i, d.size()) {\n\t\t\tcout << i+1;\n\t\t\tsort(v[i].begin(), v[i].end());\n\t\t\tREP(j, v[i].size())\n\t\t\t\tcout << ' ' << v[i][j]+1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main()\n{\n    int T;\n    cin >> T;\n    for (int t = 0; t < T; t++) {\n        vector<int> dim{1};\n        vector<int> d{0};\n        stack<int> st;\n        st.push(0);\n        using P = pair<int, int>;\n        vector<P> edge;\n        int pos = 0;\n        int node = 0;\n        while (true) {\n            while (not st.empty()) {\n                if (dim[st.top()] == 0) {\n                    st.pop();\n                    pos = st.empty() ? 0 : st.top();\n                } else {\n                    break;\n                }\n            }\n            int n;\n            cin >> n;\n            if (n == 0) {\n                break;\n            } else if (n > 0) {\n                dim[pos]--;\n                dim.push_back(pos == 0 ? n : n - 1);\n                node++;\n                d.push_back(d[pos] + 1);\n                edge.push_back({pos, node});\n                pos = node;\n                st.push(pos);\n            } else {\n                const int D = d[pos] + n;\n                for (int i = 1; i <= node; i++) {\n                    if (dim[i] > 0 and d[i] == D) {\n                        dim[i]--;\n                        edge.push_back({i, pos});\n                        dim[pos]--;\n                        break;\n                    }\n                }\n            }\n        }\n        vector<multiset<int>> g(node + 1);\n        for (const P& e : edge) {\n            g[e.first].insert(e.second);\n            g[e.second].insert(e.first);\n        }\n        for (int i = 1; i <= node; i++) {\n            cout << i;\n            for (const int to : g[i]) {\n                if (to > 0) {\n                    cout << \" \" << to;\n                }\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(int *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff]=node;\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to = dist[ff+inp[p]];\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      en[node]--;\n      en[to--];\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    if ( en[node]==0)break;\n    else p++;\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    int n,dist[N]={0},en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)break;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-100;\n      \n      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n      rep(i,dist[ff+inp[p]].size() ){\n\t//for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n      \n      //if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    \n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\nvector<int> in;\n\nvector<int> G[1000];\nint pos=0;\nint path[1000];\nint ed[1000];\nint newn;\n\nvoid dfs(int cv,int depth){\n  //cout << cv << ' ' << depth << endl;\n  path[depth] = cv;\n  ed[cv] = in[pos++];\n  while(pos<SZ(in)){\n    int t=in[pos];\n    //cout << t << endl;\n    if(t<0){\n      int nv=path[depth+t];\n      G[cv].pb(nv);\n      G[nv].pb(cv);\n      ++pos;\n    }else{\n      ++newn;\n      G[cv].pb(newn);\n      G[newn].pb(cv);\n      dfs(newn,depth+1);\n    }\n    if(SZ(G[cv]) == ed[cv]) break;\n  }\n}\n\nvoid solve(){\n  newn = 0;\n  in.clear();\n  int t;\n  int no=0;\n  while(cin >> t, t){\n    no += t>0;\n    in.pb(t);\n  }\n\n  rep(i,no) G[i].clear();\n  pos = 0;\n  dfs(0,0);\n  rep(i,no) sort(ALL(G[i]));\n\n  rep(i,no){\n    cout << i+1;\n    FOR(it,G[i]) cout << ' ' << *it+1;\n    cout << endl;\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint ind;\nint rmed[110];\nvector<int> edge[110];\nint dist[110], did[110];\n\n\nvoid dfs(int par) {\n    int a;\n    cin >> a;\n    if (a == 0) dfs(par);\n    else if (a > 0) {\n        int i = ++ind;\n        rmed[i] = a;\n        if (par == -1) {\n            dist[i] = 0;\n            did[0] = 1;\n        }\n        else {\n            edge[par].push_back(i);\n            edge[i].push_back(par);\n            dist[i] = dist[par] + 1;\n            did[dist[i]] = i;\n            --rmed[par];\n            --rmed[i];\n        }\n        while (rmed[i] > 0) {\n            dfs(i);\n        }\n    }\n    else {\n        edge[par].push_back(did[dist[par] + a]);\n        edge[did[dist[par] + a]].push_back(par);\n        --rmed[par];\n        --rmed[did[dist[par] + a]];\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        ind = 0;\n        for (int j = 0; j < 110; ++j) {\n            rmed[j] = 0;\n            dist[j] = -1;\n            did[j] = -1;\n            edge[j].clear();\n        }\n        dfs(-1);\n        for (int j = 1; j < 110; ++j) {\n            if (edge[j].size() == 0) break;\n            sort(edge[j].begin(), edge[j].end());\n            cout << j;\n            for (int k : edge[j]) {\n                cout << \" \" << k;\n            }\n            cout << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint main(void){\n\tint m;\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tvector<int> ans[105];\n\t\tvector<mp> sta;\n\t\tint n=0;\n\t\tsta.push_back(mp(10000,-1));\n\t\twhile(1){\n\t\t\t//printf(\"no .. %d\\n\",sta.back().sec+1);\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(a==0)break;\n\t\t\t\n\t\t\twhile(sta.back().fir==0)sta.pop_back();\n\t\t\tsta.back().fir--;\n\t\t\tif(a>0){\n\t\t\t\tint no = n;\n\t\t\t\tint to = sta.back().sec;\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tans[to].push_back(no);\n\t\t\t\t\tans[no].push_back(to);\n\t\t\t\t}\n\t\t\t\telse a++;\n\t\t\t\tsta.push_back(mp(a-1,no));\n\t\t\t\tn++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint no = sta.back().sec;\n\t\t\t\tint to = sta[sta.size()-1 + a].sec;\n\t\t\t\tans[to].push_back(no);\n\t\t\t\tans[no].push_back(to);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tsort(ans[i].begin(),ans[i].end());\n\t\t\tprintf(\"%d \",i+1);\n\t\t\trep(j,ans[i].size()){\n\t\t\t\tprintf(\"%d \",ans[i][j]+1);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9+7\n\nusing namespace std;\n\nstruct room{\n  int depth;\n  int doors;\n  vector<int> dlist;\n  room() : depth(0), doors(0), dlist() {}\n};\n\nint main(){\n  int n; cin >> n;\n  REP(counter, n) {\n    int num;\n    vector<int> data;\n    int rs = 0;\n    while(cin >> num and num) {\n      data.push_back(num);\n      if(num > 0) rs++;\n    }\n    vector<room> rooms(rs);\n    int currentid = 0;\n    int currentdepth = 0;\n    vector<int> parents;\n    REP(i, data.size()){\n      if(data[i] > 1){\n        rooms[currentid].doors = data[i];\n        rooms[currentid].depth = currentdepth;\n        if(parents.size() != 0){\n          int parent = parents[currentdepth-1];\n          rooms[parent].dlist.push_back(currentid);\n          rooms[currentid].dlist.push_back(parent);\n        }\n        parents.push_back(currentid);\n        currentid++; currentdepth++;\n      } else if(data[i] == 1) {\n        rooms[currentid].doors = data[i];\n        rooms[currentid].depth = currentdepth;\n        if(parents.size() != 0){\n          int parent = parents[currentdepth-1];\n          rooms[parent].dlist.push_back(currentid);\n          rooms[currentid].dlist.push_back(parent);\n        }\n        currentdepth--;\n        while(currentdepth >= 0 and rooms[parents[currentdepth]].doors == rooms[parents[currentdepth]].dlist.size()){\n          parents.pop_back();\n          currentdepth--;\n        }\n        currentdepth++; currentid++;\n      } else {\n        currentdepth--;\n        int parent = parents[currentdepth];\n        int dest = parents[currentdepth + data[i]];\n        rooms[parent].dlist.push_back(dest);\n        rooms[dest].dlist.push_back(parent);\n        while(currentdepth >= 0 and rooms[parents[currentdepth]].doors == rooms[parents[currentdepth]].dlist.size()){\n          parents.pop_back();\n          currentdepth--;\n        }\n        currentdepth++;\n      }\n    }\n    REP(i, rooms.size()) {\n      sort(ALL(rooms[i].dlist));\n      cout << i+1;\n      REP(j, rooms[i].doors){\n        cout << \" \" << rooms[i].dlist[j]+1;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(1000);\n\t\tint in, cnt = -1, times = -1, pre;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\tcnt++; times++;\n\t\t\t\t//cout << times+1 << ' ' << cnt << endl;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, pre, node, edge);\n\t\t\t\tcur.pb(cnt);\n\t\t\t\tpre = times;\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\t//REP(i, edge.size())\n\t\t\t\t\t//cout << edge[i] << ' ';\n\n\t\t\t\tint pnt;\n\t\t\t\tfor(pnt = times; pnt >= 0; pnt--) {\n\t\t\t\t\t//cout << cur[pnt] << ' ' << cnt << ' ' << edge[pnt] << endl;\n\t\t\t\t\tif(cur[pnt] - cnt == in && edge[pnt] > 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//cout << times+1 << ' ' << pnt+1 << endl;\n\t\t\t\tadd_Node(pre, pnt, node, edge);\n\t\t\t\twhile(!edge[pre])\n\t\t\t\t\tpre--;\n\t\t\t\tcnt = cur[pre];\n\t\t\t\t//cout << pre+1 << endl;\n\t\t\t}\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(!node[i].size())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nclass room{\npublic:\n  int prev;\n  int doors;\n  int dist;\n  vector<int> next;\n  room(int p,int d,int d2){\n    prev=p;\n    doors=d;\n    dist=d2;\n    next=vector<int>();\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n-->0){\n    vector<room> rooms;\n    int r;\n    int p=-1;\n    int d=0;\n    while(cin >> r,r){\n      //printf(\"r=%d (p=%d,d=%d) :\\n\",r,p+1,d);\n      if(r>0){\n        d++;\n        rooms.push_back(room(p,r,d));\n        if(p>=0){\n          //cout << \"connect (\" << p+1 << \"<=>\" << rooms.size() << \")\";\n          rooms[p].next.push_back(rooms.size()-1);\n          rooms[rooms.size()-1].next.push_back(p);\n        }\n        p=rooms.size()-1;\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n      }else{\n        int next;\n        for(next=0;next<rooms.size();next++){\n          if(d+r==rooms[next].dist&&rooms[next].next.size()!=rooms[next].doors)\n            break;\n        }\n\n        //cout << \"connect (\" << p+1 << \"<=>\" << next+1 << \")\";\n        rooms[p].next.push_back(next);\n        rooms[next].next.push_back(p);\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n      }\n      //cout << endl;\n    }\n    //while(p!=-1);\n    for(int i=0;i<rooms.size();i++){\n      cout << i+1 << \" \";\n      //while(rooms[i].next.size()!=rooms[i].doors);\n      sort(rooms[i].next.begin(),rooms[i].next.end());\n      for(int j=0;j<rooms[i].next.size();j++){\n        cout << rooms[i].next[j]+1 << (j==rooms[i].next.size()-1?'\\n':' ');\n      }\n    }\n    //cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1236>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nvector<vector<int>> G;\nvector<int> memo;\nvector<pii> roomdoor;\nmap<int,pii> mp;\nvoid dfs(int dep,int& i){\n    if(i >= memo.size()) return;\n    int idx = i;\n    int n = roomdoor[i].second;\n    mp[dep] = {i,n};\n    \n    i++;\n    while(i < memo.size()){\n        if(roomdoor[idx].first == 0) break;\n        if(memo[i] > 0){\n            int next = roomdoor[i].second;\n            G[n].push_back(next);\n            G[next].push_back(n);\n            roomdoor[idx].first--; roomdoor[i].first--;\n            dfs(dep+1,i);\n        }else{\n            \n            pii p = mp[dep+memo[i]];\n\n            int nextidx = p.first;\n            int next = p.second;\n            \n            G[n].push_back(next);\n            G[next].push_back(n);\n            \n            roomdoor[idx].first--; roomdoor[nextidx].first--;\n            i++;\n        }\n    }\n}\nvoid solve(){\n    mp.clear();\n    memo.clear();\n    roomdoor.clear();\n    G.clear();\n    int x; while(cin >> x,x) memo.push_back(x);\n    roomdoor.assign(memo.size(),{0,0});\n    int V = 0;\n    for(int i = 0; i < memo.size();i++){\n        if(memo[i] < 0) continue;\n        roomdoor[i] = {memo[i],V++};\n    }\n    G.resize(V);\n    int i = 0;\n    dfs(0,i);\n    for(int i = 0; i < V;i++){\n        cout << i + 1 << \" \";\n        sort(G[i].begin(),G[i].end());\n        for(auto v:G[i]){\n            cout << v+1 << \" \";\n        }\n        cout << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n; cin >> n;\n    while(n--){\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nclass room{\npublic:\n  int prev;\n  int doors;\n  int dist;\n  vector<int> next;\n  room(int p,int d,int d2){\n    prev=p;\n    doors=d;\n    dist=d2;\n    next=vector<int>();\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n-->0){\n    vector<room> rooms;\n    int r;\n    int p=-1;\n    int d=0;\n    while(cin >> r,r){\n      //printf(\"r=%d (p=%d,d=%d) :\\n\",r,p+1,d);\n      if(r>0){\n        d++;\n        rooms.push_back(room(p,r,d));\n        if(p>=0){\n          //cout << \"connect (\" << p+1 << \"<=>\" << rooms.size() << \")\";\n          rooms[p].next.push_back(rooms.size()-1);\n          rooms[rooms.size()-1].next.push_back(p);\n        }\n        p=rooms.size()-1;\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n      }else{\n        int next;\n        for(next=0;next<rooms.size();next++){\n          if(d+r==rooms[next].dist&&rooms[next].next.size()!=rooms[next].doors)\n            break;\n        }\n\n        //cout << \"connect (\" << p+1 << \"<=>\" << next+1 << \")\";\n        rooms[p].next.push_back(next);\n        rooms[next].next.push_back(p);\n        while(rooms[p].next.size()==rooms[p].doors){\n          d--;\n          p=rooms[p].prev;\n        }\n      }\n      //cout << endl;\n    }\n    //while(p!=-1);\n    for(int i=0;i<rooms.size();i++){\n      cout << i+1 << \" \";\n      while(rooms[i].next.size()!=rooms[i].doors);\n      sort(rooms[i].next.begin(),rooms[i].next.end());\n      for(int j=0;j<rooms[i].next.size();j++){\n        cout << rooms[i].next[j]+1 << (j==rooms[i].next.size()-1?'\\n':' ');\n      }\n    }\n    //cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(100);\n\t\tstack<int> s;\n\t\tint in, times = -1;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\ttimes++;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, s.top(), node, edge);\n\t\t\t\ts.push(times);\n\t\t\t\tcur.pb(s.size()-1);\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\tfor(int i = s.top(); i >= 0; i--) {\n\t\t\t\t\tif(cur[i] - cur[s.top()] == in && edge[i] > 0) {\n\t\t\t\t\t\tadd_Node(s.top(), i, node, edge);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!edge[s.top()]) {\n\t\t\t\t\tif(!s.top()) break;\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(node[i].empty())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 110\nusing namespace std;\nconst int INF = 1LL<<55;\nint Max(int &a,int b){return a=max(a,b);}\nint Min(int &a,int b){return a=min(a,b);}\nstruct dat{int cnt, num_door , dis;};\nint n;\nvector<int> G[N];\nvector<int> rec;\nvector<dat> A;\n\nbool can_add_edge(int a,int b,int r){\n  return A[a].cnt && A[b].cnt && A[a].dis - A[b].dis == r;\n}\n\nvoid add_edge(int a,int b){\n  assert(A[a].cnt-- && A[b].cnt--);\n  //  cout<<\"add_edge \"<<a<<\" \"<<b<<endl;\n  G[a].push_back(b);\n  G[b].push_back(a);\n  sort(G[a].begin(),G[a].end());\n  sort(G[b].begin(),G[b].end());\n}\n\nvoid erase_edge(int a,int b){\n  A[a].cnt++,A[b].cnt++;\n  for(auto it=G[a].begin();it!=G[a].end();it++)if(*it == b){G[a].erase(it);break;} \n  for(auto it=G[b].begin();it!=G[b].end();it++)if(*it == a){G[b].erase(it);break;} \n}\n\n\nvoid dfs(int idx,int num){\n  if(idx >= (int)rec.size()) return;\n  int pos = num;\n  //cout<<\"idx=\"<<idx<<\" pos=\"<<pos<<\" num=\"<<num<<\" dis=\"<<A[pos].dis<<endl;\n  //for(dat a:A) cout<<\"{\"<<a.cnt<<\",\"<<a.dis<<\"}\"<<\" \";cout<<endl;\n\n  while(idx<(int)rec.size() && rec[idx]<0){\n    //cout<<rec[idx]<<endl;\n    for(int i=0;i<(int)A.size()-1;i++){\n      if(!can_add_edge(i,pos,rec[idx])) continue;\n      add_edge(i,pos);\n      idx++;\n      break;\n    }\n    while(pos && A[pos].cnt == 0) pos--;\n  }\n  if(idx >= (int)rec.size()) return;\n\n  while(A[pos].cnt == 0) pos--;\n  A.push_back((dat){rec[idx],rec[idx],A[pos].dis+1});\n  add_edge(pos,num+1);\n  dfs(idx+1,num+1);\n}\n\n\nvoid solve(){\n  n = 0;\n  A.clear();\n  A.push_back((dat){rec[0],rec[0],0});\n  dfs(1,0);\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    for(int i=0;i<N;i++) G[i].clear();    \n    rec.clear();\n    for(int a;cin>>a,a;)rec.push_back(a);\n\n    solve();\n\n    for(int i=0;i<(int)A.size();i++){\n      cout<<i+1;\n      for(int a:G[i]) cout<<\" \"<<a+1;\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvoid addEdge(int a, int b, vector<vector<int>>& g, vector<int>& in){\n\tg[a].emplace_back(b);\n\tg[b].emplace_back(a);\n\tin[a]--; in[b]--;\n\tassert(in[a] >= 0 and in[b] >= 0 and \"invalid edge\");\n}\n\nvoid dfs(int& idx, int& num, vector<int>& d, vector<int>& in, vector<int>& par, vector<vector<int>>& g){\n\tint pos = num++;\n\t//cout << pos << endl;\n\twhile(in[pos] > 0 and idx < d.size()){\n\t\tif(d[idx] >= 0){\n\t\t\tidx++; \n\t\t\taddEdge(pos, num, g, in);\n\t\t\tpar[num] = pos;\n\t\t\tdfs(idx, num, d, in, par, g);\n\t\t}else{\n\t\t\tint p = pos;\n\t\t\trep(i,-d[idx]){\n\t\t\t\tp = par[p];\n\t\t\t}\n\t\t\tidx++;\n\t\t\tassert(p >= 0 and \"invalid par\");\n\t\t\taddEdge(p, pos, g, in);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\trep(_,n){\n\t\tint a;\n\t\tvector<int> d, in;\n\t\twhile(cin >> a, a){\n\t\t\tif(a >= 0){\n\t\t\t\tin.emplace_back(a);\n\t\t\t}\n\t\t\td.emplace_back(a);\n\t\t}\n\n\t\tvector<int> par(in.size(), - 1);\n\t\tvector<vector<int>> g(in.size());\n\t\tint idx = 1, num = 0; \n\t\tdfs(idx, num, d, in, par, g);\n\n\t\trep(i,in.size()){\n\t\t\tsort(all(g[i]));\n\t\t}\n\n\t\trep(i,in.size()){\n\t\t\tcout << i + 1;\n\t\t\trep(j,g[i].size()){\n\t\t\t\tcout << ' ' << g[i][j] + 1;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef vector<int> vi;\n\nint main(){\n  int l; cin >> l;\n  while(l--){\n    vi seq;\n    int n=0;\n    {\n      int tmp;\n      while(cin >> tmp, tmp){\n\tseq.pb(tmp);\n\tif(tmp>0)n++;\n      }\n    }\n    \n    vi d(n,0), s;\n    vector<vi> a(n);\n    int id = 0;\n    s.pb(0); d[0] = seq[0];\n\n    for(int i=1;i<(int)seq.size();i++){\n      if(seq[i]>0){\n\tid++;\n\n\ta[s.back()].pb(id);\n\ta[id].pb(s.back());\n\td[id] = seq[i]-1;\n\td[s.back()]--;\n\n\ts.pb(id);\n      }else{\n\tint u = s[s.size()-1+seq[i]];\n\n\ta[s.back()].pb(u);\n\ta[u].pb(s.back());\n\td[u]--;\n\td[s.back()]--;\n      }\n      while(s.size() && d[s.back()]==0)s.pop_back();\n    }\n\n    for(int i=0;i<n;i++){\n      cout << i+1;\n      sort(a[i].begin(), a[i].end());\n      for(int u : a[i])cout << \" \" << u+1;\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<int> m;\nvector<vector<int> > to;\nvector<int> node;\n\nvoid dfs()\n{\n    int k = n;\n    node.push_back(k);\n    ++ n;\n\n    for(int i=0; i<m[k]; ++i){\n        int a;\n        cin >> a;\n        if(a > 0){\n            m.push_back(a-1);\n            to[k].push_back(n);\n            to.push_back(vector<int>(1, k));\n            dfs();\n        }else{\n            int x = node[node.size()-1+a];\n            to[k].push_back(x);\n            to[x].push_back(k);\n            -- m[x];\n        }\n    }\n\n    node.pop_back();\n}\n\nint main()\n{\n    int d;\n    cin >> d;\n\n    while(--d >= 0){\n        int a;\n        cin >> a;\n\n        n = 0;\n        m = vector<int>(1, a);\n        to = vector<vector<int> >(1);\n        dfs();\n\n        for(int i=0; i<n; ++i){\n            cout << (i+1);\n            sort(to[i].begin(), to[i].end());\n            for(unsigned j=0; j<to[i].size(); ++j)\n                cout << ' ' << (to[i][j] + 1);\n            cout << endl;\n        }\n\n        cin >> a;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nint main() {\n\tint T;\n\tcin >> T;\n\trep(t, T) {\n\t\tvi input;\n\t\tint N = 0;\n\t\twhile (true) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif (a == 0)break;\n\t\t\tif (a > 0)N++;\n\t\t\tinput.push_back(a);\n\t\t}\n\t\tvvi G(N);\n\t\tvi num(N, 0);\n\t\tnum[0] = input[0];\n\n\t\tint pos = 0;\n\t\tint next = 1;\n\n\t\tstack<int> st;\n\t\tst.push(0);\n\n\t\tvector<set<int>> d(N);\n\t\td[0].insert(0);\n\n\t\tint dist = 0;\n\n\t\trepl(i, 1, input.size()) {\n\t\t\tint x = input[i];\n\n\t\t\t/*\n\t\t\tcout << \"num: \";\n\t\t\trep(j, N) {\n\t\t\t\tcout << num[j] << \" \";\n\t\t\t}cout << endl;\n\t\t\tcout << \"pos: \" << pos << endl;\n\t\t\tcout << \"input: \" << x << endl;\n\t\t\t*/\n\n\t\t\twhile (num[pos] == 0) {\n\t\t\t\tst.pop();\n\t\t\t\tpos = st.top();\n\t\t\t\tdist--;\n\t\t\t}\n\n\t\t\tif (x > 0) {\n\t\t\t\tnum[pos]--;\n\t\t\t\tG[pos].push_back(next);\n\t\t\t\tG[next].push_back(pos);\n\n\t\t\t\tpos = next;\n\t\t\t\tnext++;\n\t\t\t\tdist++;\n\t\t\t\td[dist].insert(pos);\n\t\t\t\tnum[pos] = x - 1;\n\t\t\t\tst.push(pos);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to = *d[dist + x].begin();\n\t\t\t\twhile (num[to] == 0) {\n\t\t\t\t\td[dist + x].erase(to);\n\t\t\t\t\tto = *d[dist + x].begin();\n\t\t\t\t}\n\n\t\t\t\tnum[pos]--;\n\t\t\t\tnum[to]--;\n\t\t\t\tG[pos].push_back(to);\n\t\t\t\tG[to].push_back(pos);\n\t\t\t}\n\t\t}\n\n\t\trep(i, N) {\n\t\t\tcout << i + 1 << \" \";\n\t\t\tsort(all(G[i]));\n\t\t\trep(j, G[i].size()) {\n\t\t\t\tcout << G[i][j] + 1;\n\t\t\t\tif (j != G[i].size() - 1) {\n\t\t\t\t\tcout << \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <vector>\n#include <array>\n#include <tuple>\n#include <utility>\n#include <numeric>\n#include <iomanip>\n#include <cctype>\n#include <cmath>\n#include <assert.h>\n#include <cstdlib>\n#include <list>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n    return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n    s << \"[\";\n    for (int i = 0; i < v.size(); i++) s << (i == 0 ? \"\" : \", \") << v[i];\n    s << \"]\";\n    return s;\n}\n\n#define ALL(a) (a).begin(), (a).end()\n\nconst int MAX_V = 110;\n\nvector<int> graph[MAX_V];\nint id[MAX_V];      // id[i] := ??±???i???????????????\nint deg[MAX_V];\n\nint main() {\n    int n;\n    cin >> n;\n\n    for (int loop = 0; loop < n; loop++) {\n        // ?????????\n        for (int i = 0; i < MAX_V; i++) {\n            graph[i].clear();\n            id[i] = -1;\n            deg[i] = 0;\n        }\n\n        int cur, r, num = 0, depth = 0;\n        stack<int> st;\n        cin >> r;\n\n        cur = num++;\n        deg[cur] = r;\n        id[depth] = cur;\n\n        while (cin >> r, r) {\n            // ?????¨????????????????????\\?¶?????????????????????¨??????????????£???????????????????????´??????\n            while (graph[cur].size() == deg[cur] && !st.empty()) {\n                cur = st.top(); st.pop();\n                depth--;\n            }\n            /*\n            cout << \"??\\???: \" << r << endl;\n            cout << \"?????¨: \" << cur << endl;\n            */\n\n            if (r > 0) {\n                // ?????¨?????????????????????????????????\n                st.push(cur);\n\n                // ?§????\n                depth++;\n\n                int nxt = num++;\n                graph[cur].push_back(nxt);\n                graph[nxt].push_back(cur);\n\n                cur = nxt;\n                deg[cur] = r;\n                id[depth] = cur;\n\n                // cout << \"{\" << cur + 1 << \", \" << nxt + 1 << \"}\" << endl;\n            } else {\n                // r????????§???????????¨?????¨???\n                graph[cur].push_back(id[depth + r]);\n                graph[id[depth + r]].push_back(cur);\n\n                // cout << \"{\" << cur + 1 << \", \" << id[depth + r] << \"}\" << endl;\n            }\n        }\n\n        // ??????\n        for (int v = 0; v < num; v++) {\n            cout << v + 1;\n            \n            sort(ALL(graph[v]));\n            for (int e : graph[v]) {\n                cout << \" \" << e + 1;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int m;\n  cin >> m;\n  cin.ignore();\n  while(m--){\n    string s;\n    getline(cin, s);\n    stringstream ss(s);\n    vector<int> v;\n    for(int n; ss >> n;){\n      v.push_back(n);\n    }\n    int n = v.size();\n    vector<int> to[200];\n    int cur = 0;\n    stack<int> stk;\n    stk.push(0);\n    int mem[100];\n    REP(i, n){\n      int lev = stk.top();\n      stk.pop();\n      //printf(\"v[%d] = %d , lev = %d\\n\", i, v[i], lev);\n      if(v[i] > 0){\n        if(lev > 0){\n          //printf(\"%d <-> %d\\n\", mem[lev - 1], cur);\n          to[mem[lev - 1]].push_back(cur);\n          to[cur].push_back(mem[lev - 1]);\n        }\n        mem[lev] = cur++;\n        REP(j, v[i] - 1) stk.push(lev + 1);\n      }else if(v[i] < 0){\n        lev--;\n        int lev2 = lev + v[i];\n        //printf(\"%d <-> %d\\n\", mem[lev], mem[lev2]);\n        to[mem[lev]].push_back(mem[lev2]);\n        to[mem[lev2]].push_back(mem[lev]);\n      }\n    }\n    REP(i, cur){\n      printf(\"%d \",  i + 1);\n      sort(to[i].begin(), to[i].end());\n      REP(j, to[i].size()){\n        printf(\"%d\", to[i][j] + 1);\n        if(j == to[i].size() - 1) cout << endl;\n        else cout << \" \";\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nvoid solve() {\n  vector<int> R;\n  int n = 0;\n  for(int i; cin >> i, i; ) {\n    R.pb(i);\n    if (i > 0) n++;\n  }\n\n  int degs[110];\n  vector<int> G[110];\n  vector<int> path;\n  int cur = 0;\n  int cnt = 0;\n  rep(i, SZ(R)) {\n    if (R[i] > 0) {\n      cur = ++cnt;\n      degs[cnt] = R[i];\n      path.pb(cnt);\n      if (SZ(path)>=2) {\n        int prev = path[SZ(path)-2];\n        G[prev].pb(cur);\n        G[cur].pb(prev);\n      }\n    } else {\n      int t = path[SZ(path) + R[i] - 1];\n      G[t].pb(cur);\n      G[cur].pb(t);\n      while(G[cur].size() == degs[cur]) {\n        path.pop_back();\n        if (SZ(path)>=1) {\n          cur = path[SZ(path)-1];\n        } else break;\n      }\n    }\n  }\n\n  rep(i, n) {\n    cout << i+1;\n    sort(ALL(G[i+1]));\n\n    rep(j, SZ(G[i+1])) {\n      cout << \" \" << G[i+1][j];\n    }\n    cout << endl;\n  }\n}\nint main() {\n  int n; cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int m;\n  cin >> m;\n  cin.ignore();\n  while(m--){\n    int tmp;\n    vector<int> v;\n    while(cin >> tmp && tmp != 0) v.push_back(tmp);\n    int n = v.size();\n    vector<int> to[200];\n    int cur = 0;\n    int mem[200] = {};\n    int rest[200] = {};\n    int level = 0;\n    REP(i, n){\n      while(level >= 0 && rest[level] == 0) level--;\n      //printf(\"v[%d] = %d , lev = %d\\n\", i, v[i], lev);\n      if(v[i] > 0){\n        if(level >= 0){\n          //printf(\"%d <-> %d\\n\", mem[lev - 1], cur);\n          to[mem[level]].push_back(cur);\n          to[cur].push_back(mem[level]);\n        }\n        mem[level + 1] = cur++;\n        rest[level]--;\n        rest[level + 1] = v[i] - 1;\n        level ++;\n      }else if(v[i] < 0){\n        //printf(\"%d <-> %d\\n\", mem[lev], mem[lev2]);\n        to[mem[level]].push_back(mem[level + v[i]]);\n        to[mem[level + v[i]]].push_back(mem[level]);\n        rest[level]--;\n        rest[level + v[i]]--;\n      }\n    }\n    REP(i, cur){\n      printf(\"%d \",  i + 1);\n      sort(to[i].begin(), to[i].end());\n      REP(j, to[i].size()){\n        printf(\"%d\", to[i][j] + 1);\n        if(j == to[i].size() - 1) cout << endl;\n        else cout << \" \";\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n\nint n,dep[100009],dim[100009],nxt,cnt;\nvector<int>v[100009];\n\nvoid dfs(int d,int n){\n    dep[d]=n;\n    while(v[n].size()<dim[n]){\n        cin>>nxt;\n        if(nxt<0){\n            int x=dep[d+nxt];\n            v[x].push_back(n);\n            v[n].push_back(x);\n        }\n        else{\n            cnt++;\n            dim[cnt]=nxt;\n            v[cnt].push_back(n);\n            v[n].push_back(cnt);\n            dfs(d+1,cnt);\n        }\n    }\n}\n\nint main(){\n    int T;\n    cin>>T;\n    while(T--){cnt=0;\n        r(i,100009)v[i].clear();\n        memset(dim,-1,sizeof(dim));\n        memset(dep,-1,sizeof(dep));\n        cin>>dim[0];\n        dfs(0,0);\n        cin>>nxt;\n        cnt++;\n        r(i,cnt){\n            cout<<i+1;\n            sort(v[i].begin(),v[i].end());\n            r(j,v[i].size())cout<<' '<<v[i][j]+1;\n            cout<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1236>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nvector<vector<int>> G;\nvector<int> memo;\nvector<pii> roomdoor;\nmap<int,pii> mp;\nvoid dfs(int dep,int& i){\n    if(i >= memo.size()) return;\n    int idx = i;\n    int n = roomdoor[i].second;\n    mp[dep] = {i,n};\n\n    i++;\n    while(i < memo.size()){\n        if(roomdoor[idx].first == 0) break;\n        if(memo[i] > 0){\n            int next = roomdoor[i].second;\n            G[n].push_back(next);\n            G[next].push_back(n);\n            roomdoor[idx].first--; roomdoor[i].first--;\n            dfs(dep+1,i);\n        }else{\n\n            pii p = mp[dep+memo[i]];\n\n            int nextidx = p.first;\n            int next = p.second;\n\n            G[n].push_back(next);\n            G[next].push_back(n);\n\n            roomdoor[idx].first--; roomdoor[nextidx].first--;\n            i++;\n        }\n    }\n}\nvoid solve(){\n    mp.clear();\n    memo.clear();\n    roomdoor.clear();\n    G.clear();\n    int x; while(cin >> x,x) memo.push_back(x);\n    roomdoor.assign(memo.size(),{0,0});\n    int V = 0;\n    for(int i = 0; i < memo.size();i++){\n        if(memo[i] < 0) continue;\n        roomdoor[i] = {memo[i],V++};\n    }\n    G.resize(V);\n    int i = 0;\n    dfs(0,i);\n    for(int i = 0; i < V;i++){\n        cout << i + 1 << \" \";\n        sort(G[i].begin(),G[i].end());\n        for(int j = 0; j < G[i].size(); j++){\n            cout << G[i][j]+1 << \" \\n\"[j==G[i].size()-1];\n        }\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n; cin >> n;\n    while(n--){\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 21:42\n// debug 22:39\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <sstream>\n#include <deque>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n\nusing namespace std;\n\nvoid joint(vector<int> &room, int roomNum) {\n    REP(i, room.size()) {\n        if(room[i] == 0) {\n            room[i] = roomNum;\n            break;\n        }\n    }\n}\n\nvoid dump(vector<int> &list, bool debug = true) {\n    if(debug) cout << \"dump: \";\n    REP(i, list.size()) cout << list[i] << \" \";\n    cout << endl;\n}\n\nvoid dumpRooms(vector<vector<int> > &rooms) {\n    REP(i, rooms.size()) {\n        cout << i + 1;\n        REP(j, rooms[i].size()) {\n            cout << \" \" << rooms[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int n;\n\n    cin >> n;\n\n    // n times\n    while(n--) {\n        int inp,\n            depth = 0;\n        vector<vector<int> > rooms;\n        vector<int> current;\n\n        // in + process\n        while(cin >> inp, inp) {\n\n            // 新規ドア\n            if(inp > 0) {\n                depth++;\n                rooms.push_back(vector<int>(inp, 0));\n                current.push_back(rooms.size());\n\n                // 今居た部屋と入った部屋をつなぐ\n                if(rooms.size() != 1) {\n                    joint(rooms[current[current.size() - 2] - 1], current.back());\n                    joint(rooms[current.back() - 1], current[current.size() - 2]);\n                }\n\n            // 既存ドア\n            } else {\n                // 今居た部屋とdepth - inpの部屋を繋ぐ\n                joint(rooms[depth + inp - 1], current.back());\n                joint(rooms[current.back() - 1], depth + inp);\n            }\n\n            // ドアが残っているか\n            int full = 1;\n            REP(i, rooms[current.back() - 1].size()) {\n                if(rooms[current.back() - 1][i] == 0) {\n                    full = 0;\n                    break;\n                }\n            }\n            if(full) {\n                current.pop_back();\n                depth--;\n            }\n\n            // dump(current);\n\n            // cout << endl;\n            // dumpRooms(rooms);\n            // cout << endl;\n        }\n\n        // out\n        REP(i, rooms.size()) {\n            cout << i + 1;\n            sort(rooms[i].begin(), rooms[i].end());\n            REP(j, rooms[i].size()) {\n                cout << \" \" << rooms[i][j];\n            }\n            cout << endl;\n        }\n    }   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<stack>\nusing namespace std;\nint T;\nmain()\n{\n\tcin>>T;\n\tfor(;T--;)\n\t{\n\t\tvector<int>dcnt(111,-1);\n\t\tvector<int>prev(111,-1);\n\t\tint now=0,sz=0,counter=0;\n\t\tvector<vector<int> >G(111);\n\t\tstack<int>dfs;\n\t\tdfs.push(0);\n\t\tint in;\n\t\twhile(cin>>in,in)\n\t\t{\n\t\t\twhile(dcnt[now]==0)\n\t\t\t{\n\t\t\t\tdfs.pop();\n\t\t\t\tnow=dfs.top();\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t\tif(in>0)\n\t\t\t{\n\t\t\t\tsz++;\n\t\t\t\tif(now>0)\n\t\t\t\t{\n\t\t\t\t\tG[now].push_back(sz);\n\t\t\t\t\tG[sz].push_back(now);\n\t\t\t\t\tdcnt[now]--;\n\t\t\t\t\tin--;\n\t\t\t\t}\n\t\t\t\tnow=sz;\n\t\t\t\tcounter++;\n\t\t\t\tdcnt[now]=in;\n\t\t\t\tprev[counter]=now;\n\t\t\t\tdfs.push(now);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint id=prev[counter+in];\n\t\t\t\tG[id].push_back(now);\n\t\t\t\tG[now].push_back(id);\n\t\t\t\tdcnt[id]--;\n\t\t\t\tdcnt[now]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=sz;i++)\n\t\t{\n\t\t\tsort(G[i].begin(),G[i].end());\n\t\t\tcout<<i;\n\t\t\tfor(int v:G[i])cout<<\" \"<<v;\n\t\t\tcout<<endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint g[100][100];\nint k[100];\n\nvoid add(int a, int b) {\n  if (a<0||b<0) return;\n  // printf(\"add %d %d\\n\", a, b);\n  g[a][b]++;\n  g[b][a]++;\n  k[a]--;\n  k[b]--;\n}\n\nint main() {\n  int T;cin>>T;\n  while(T--) {\n    int a;\n    vector<int> v;\n    while(cin>>a, a) {\n      v.push_back(a);\n    }\n    memset(g,0,sizeof(g));\n    int curroom = 0;\n    int roomnum = 0;\n    int counter = 0;\n    \n    vector<int> stk;  \n    FOR(it, v) {\n      int now = -1;\n      if (stk.size()) {\n        now = stk.back();\n      }\n      // cout << *it << endl;\n      // cout << \"stk = \";FOR(jt, stk) cout << *jt << \" \"; cout << endl;\n      // cout << \"k   = \"; REP(i,stk.size()) cout << k[i] << \" \"; cout << endl;\n      if (*it > 0) {\n        stk.push_back(roomnum);\n        k[roomnum] = *it;\n        add(now,roomnum);\n        roomnum++;\n      } else {\n        int dst = stk[stk.size()+*it-1];\n        add(now,dst);\n      }\n      while(stk.size() && k[stk.back()]==0) {\n        stk.pop_back();\n      }\n    }\n    REP(i,roomnum) {\n      cout << i+1;\n      REP(j,roomnum) {\n        REP(k,g[i][j]) {\n          cout << \" \" << j+1;\n        }\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(1000);\n\t\tint in, cnt = -1, times = -1, pre;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\tcnt++; times++;\n\t\t\t\t//cout << times+1 << ' ' << cnt << endl;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, pre, node, edge);\n\t\t\t\tcur.pb(cnt);\n\t\t\t\tpre = times;\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\t//REP(i, edge.size())\n\t\t\t\t\t//cout << edge[i] << ' ';\n\n\t\t\t\tint pnt;\n\t\t\t\tfor(pnt = times; pnt >= 0; pnt--) {\n\t\t\t\t\t//cout << cur[pnt] << ' ' << cnt << ' ' << edge[pnt] << endl;\n\t\t\t\t\tif(cur[pnt] - cnt == in && edge[pnt] > 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//cout << times+1 << ' ' << pnt+1 << endl;\n\t\t\t\tadd_Node(pre, pnt, node, edge);\n\t\t\t\twhile(!edge[pre])\n\t\t\t\t\tpre--;\n\t\t\t\tcnt = cur[pre];\n\t\t\t\t//cout << pre+1 << endl;\n\t\t\t}\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(!node[i].size())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint main(){\n\tint TT;\n\tcin>>TT;\n\trep(tt,TT){\n\t\tbool in[100]={};\n\t\tvector<int> ans[100];\n\t\tint sz[100]={},dis[100]={},it[100]={},p[100]={};\n\t\trep(i,100) dis[i]=1000;\n\t\tint now=0,N=1;\n\t\twhile(true){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x==0) break;\n\t\t\tif(x>0){\n\t\t\t\tans[now].pb(N);\n\t\t\t\tans[N].pb(now);\n\t\t\t\tp[N]=now;\n\t\t\t\tit[now]++;\n\t\t\t\tit[N]++;\n\t\t\t\tsz[N]=x;\n\t\t\t\tdis[N]=dis[now]+1;\n\t\t\t\tin[N]=1;\n\t\t\t\tnow=N;\n\t\t\t\tN++;\n\t\t\t}else{\n\t\t\t\trep(i,N) if(in[i]&&dis[i]-dis[now]==x){\n\t\t\t\t\tans[i].pb(now);\n\t\t\t\t\tans[now].pb(i);\n\t\t\t\t\tit[now]++;\n\t\t\t\t\tit[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(it[now]==sz[now]){\n\t\t\t\tin[now]=0;\n\t\t\t\tnow=p[now];\n\t\t\t}\n\t\t}\n\t\trep1(i,N-1){\n\t\t\tsort(all(ans[i]));\n\t\t\tcout<<i<<\" \";\n\t\t\tfor(int j:ans[i]) if(j) cout<<j<<\" \";\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nvector<int> G[MAX];\nint remain[MAX];\nint depth[MAX];\n\nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n\n    for(int i=0;i<MAX;i++){\n      G[i].clear();\n      remain[i] = 0;\n      depth[i] = -1;\n    }\n    vector<int> record;\n    vector<int> input;\n\n    int r,cur,upper;\n\n    while(cin >> r,r){\n      input.push_back(r);\n    }\n\n    remain[0] = input[0];\n    cur = 0, upper = 1, depth[0] = 0;\n\n    for(int i=1;i<input.size();i++){\n      //cout << \"the input => \" << input[i] << endl;\n      //cout << \"i = \" << i << \" cur = \" << cur << endl;\n      if( input[i] > 0 ){\n\n\tG[cur].push_back(upper);\n\tG[upper].push_back(cur);\n\tdepth[upper] = depth[cur] + 1;\n\tremain[upper] = input[i] - 1;\n\tassert(remain[upper] >= 0);\n\tremain[cur]--;\n\tassert(remain[cur] >= 0);\n\tcur = upper++;\n\n      } else {\n\tassert(depth[cur] != -1);\n\tint next = depth[cur] + input[i];\n\tfor(int j=record.size()-1;j>=0;j--){\n\t  if(next == depth[record[j]]){\n\t    next = record[j];\n\t    break;\n\t  }\n\t}\n\tassert(next >= 0);\n\tG[next].push_back(cur);\n\tG[cur].push_back(next);\n\tremain[next]--;\n\tassert(remain[next] >= 0);\n\tremain[cur]--;\n\tassert(remain[cur] >= 0);\n\n      }\n\n      record.push_back(cur);\n\n      for(int j=record.size()-1;j>=0;j--){\n\tif(remain[cur] != 0){\n\t  break;\n\t}\n\tcur = record[j];\n      }\n    }\n\n    for(int i=0;i<upper;i++){\n      cout << i+1;\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<G[i].size();j++){\n\tcout << \" \" <<  G[i][j]+1;\n      }\n      cout << endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < now; j++) {\n        if(num[j] - cnt == dd) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n          break;\n        }\n      }\n    } else {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n    cin >> sz[0];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int m;\n  cin >> m;\n  cin.ignore();\n  while(m--){\n    int tmp;\n    vector<int> v;\n    while(cin >> tmp && tmp != 0) v.push_back(tmp);\n    int n = v.size();\n    vector<int> to[200];\n    int cur = 0;\n    stack<int> stk;\n    stk.push(0);\n    int mem[100];\n    REP(i, n){\n      int lev = stk.top();\n      stk.pop();\n      //printf(\"v[%d] = %d , lev = %d\\n\", i, v[i], lev);\n      if(v[i] > 0){\n        if(lev > 0){\n          //printf(\"%d <-> %d\\n\", mem[lev - 1], cur);\n          to[mem[lev - 1]].push_back(cur);\n          to[cur].push_back(mem[lev - 1]);\n        }\n        mem[lev] = cur++;\n        REP(j, v[i] - 1) stk.push(lev + 1);\n      }else if(v[i] < 0){\n        lev--;\n        int lev2 = lev + v[i];\n        //printf(\"%d <-> %d\\n\", mem[lev], mem[lev2]);\n        to[mem[lev]].push_back(mem[lev2]);\n        to[mem[lev2]].push_back(mem[lev]);\n      }\n    }\n    REP(i, cur){\n      printf(\"%d \",  i + 1);\n      sort(to[i].begin(), to[i].end());\n      REP(j, to[i].size()){\n        printf(\"%d\", to[i][j] + 1);\n        if(j == to[i].size() - 1) cout << endl;\n        else cout << \" \";\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 110\nusing namespace std;\nconst int INF = 1LL<<55;\nint Max(int &a,int b){return a=max(a,b);}\nint Min(int &a,int b){return a=min(a,b);}\nstruct dat{int cnt, num_door , dis;};\nvector<int> G[N];\nvector<int> rec;\nvector<dat> A;\n\nbool can_add_edge(int a,int b,int r){\n  return A[a].cnt && A[b].cnt && A[a].dis - A[b].dis == r;\n}\n\nvoid add_edge(int a,int b){\n  assert(A[a].cnt-- && A[b].cnt--);\n  G[a].push_back(b);\n  G[b].push_back(a);\n  sort(G[a].begin(),G[a].end());\n  sort(G[b].begin(),G[b].end());\n}\n\nvoid dfs(int idx,int num){\n  if(idx >= (int)rec.size()) return;\n  int pos = num;\n\n  while(idx<(int)rec.size() && rec[idx]<0){\n    for(int i=0;i<(int)A.size()-1;i++){\n      if(!can_add_edge(i,pos,rec[idx])) continue;\n      add_edge(i,pos);\n      idx++;\n      break;\n    }\n    while(pos && A[pos].cnt == 0) pos--;\n  }\n  if(idx >= (int)rec.size()) return;\n\n  while(A[pos].cnt == 0) pos--;\n  A.push_back((dat){rec[idx],rec[idx],A[pos].dis+1});\n  add_edge(pos,num+1);\n  dfs(idx+1,num+1);\n}\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    for(int i=0;i<N;i++) G[i].clear();    \n    rec.clear();\n    for(int a;cin>>a,a;)rec.push_back(a);\n\n    A.clear();\n    A.push_back((dat){rec[0],rec[0],0});\n    dfs(1,0);\n\n    for(int i=0;i<(int)A.size();i++){\n      cout<<i+1;\n      for(int a:G[i]) cout<<\" \"<<a+1;\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 21:42\n// debug 22:39\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cctype>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <sstream>\n#include <deque>\n\n#define REP(i, n) for ( int i = 0; i < n; i++ )\n\nusing namespace std;\n\nvoid joint(vector<int> &room, int roomNum) {\n    REP(i, room.size()) {\n        if(room[i] == 0) {\n            room[i] = roomNum;\n            break;\n        }\n    }\n}\n\nint main() {\n    int n;\n\n    cin >> n;\n\n    // n times\n    while(n--) {\n        int inp,\n            depth = 0;\n        vector<vector<int> > rooms;\n        vector<int> current;\n\n        // in + process\n        while(cin >> inp, inp) {\n            // 新規ドア\n            if(inp > 0) {\n                depth++;\n                rooms.push_back(vector<int>(inp, 0));\n                current.push_back(rooms.size());\n\n                // 今居た部屋と入った部屋をつなぐ\n                if(rooms.size() != 1) {\n                    // if(current.back() == 0 || current[current.size() - 2] == 0) cout << \"case\" << caseNum << \", idx:\" << idx << endl;\n                    joint(rooms[current[current.size() - 2] - 1], current.back());\n                    joint(rooms[current.back() - 1], current[current.size() - 2]);\n                }\n\n            // 既存ドア\n            } else {\n                // 今居た部屋とdepth - inpの部屋を繋ぐ\n                // if(current.back() == 0 || depth + inp == 0) cout << \"case\" << caseNum << \", idx:\" << idx << endl;\n                joint(rooms[depth + inp - 1], current.back());\n                joint(rooms[current.back() - 1], depth + inp);\n            }\n\n            // ドアが埋まってる限り戻る\n            while(1) {\n                int full = 1;\n                REP(i, rooms[current.back() - 1].size()) {\n                    if(rooms[current.back() - 1][i] == 0) {\n                        full = 0;\n                        break;\n                    }\n                }\n                if(full) {\n                    current.pop_back();\n                    depth--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // out\n        REP(i, rooms.size()) {\n            cout << i + 1;\n            sort(rooms[i].begin(), rooms[i].end());\n            REP(j, rooms[i].size()) {\n                cout << \" \" << rooms[i][j];\n            }\n            cout << endl;\n        }\n    }   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-100;\n      \n      assert(dist[ff+inp[p]].size() <= 1);\n      rep(i,dist[ff+inp[p]].size() ){\n\t//for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n      \n      //if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    \n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = 114;\n\nint v;\nint deg[MAX], dv[MAX];\nvector<int> res[MAX];\n\nvoid dfs(size_t& idx, int depth, const vector<int>& q)\n{\n    deg[v] += q[idx];\n    dv[depth] = v;\n    \n    int nv = v++;\n    \n    while (idx < q.size() && deg[nv] > 0) {\n        const int val = q[++idx];\n        if (val > 0) {\n            deg[nv]--; deg[v]--;\n            res[nv].emplace_back(v);\n            res[v].emplace_back(nv);\n            dfs(idx, depth + 1, q);\n        } else {\n            int u = dv[depth + val];\n            deg[u]--; deg[nv]--;\n            res[u].emplace_back(nv);\n            res[nv].emplace_back(u);\n        }\n    }\n}\n\nvoid init(int N)\n{\n    v = 0;\n    for (int i = 0; i < N; i++) {\n        res[i].clear();\n        deg[i] = 0;\n    }\n}\n\nint main()\n{\n    int Tc;\n    cin >> Tc;\n    while (Tc--) {        \n        int x, N = 0;\n        vector<int> q;\n        while (cin >> x, x != 0) {\n            N += (x > 0);\n            q.emplace_back(x);\n        }\n        \n        init(N);\n        size_t idx = 0;\n        dfs(idx, 0, q);\n\n        for (int i = 0; i < N; i++) {\n            cout << i + 1;\n            sort(res[i].begin(), res[i].end());\n            for (const auto& r : res[i]) {\n                cout << \" \" << r + 1;\n            }\n            cout << endl;;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint main(void){\n\tint m;\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tvector<int> ans[105];\n\t\tvector<mp> sta;\n\t\tint n=0;\n\t\tsta.push_back(mp(10000,-1));\n\t\twhile(1){\n\t\t\t//printf(\"no .. %d\\n\",sta.back().sec+1);\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(a==0)break;\n\t\t\t\n\t\t\twhile(sta.back().fir==0)sta.pop_back();\n\t\t\tsta.back().fir--;\n\t\t\tif(a>0){\n\t\t\t\tint no = n;\n\t\t\t\tint to = sta.back().sec;\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tans[to].push_back(no);\n\t\t\t\t\tans[no].push_back(to);\n\t\t\t\t}\n\t\t\t\tsta.push_back(mp(a-1,no));\n\t\t\t\tn++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint no = sta.back().sec;\n\t\t\t\tint to = sta[sta.size()-1 + a].sec;\n\t\t\t\tans[to].push_back(no);\n\t\t\t\tans[no].push_back(to);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tsort(ans[i].begin(),ans[i].end());\n\t\t\tprintf(\"%d \",i+1);\n\t\t\trep(j,ans[i].size()){\n\t\t\t\tprintf(\"%d \",ans[i][j]+1);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tint r;\n\t\tvector<int> v;\n\t\twhile (cin >> r, r) {\n\t\t\tv.push_back(r);\n\t\t}\n\t\tint ma = -1, it = 0;\n\t\tint e[100] = {}, t[100] = {}, par[100] = {};\n\t\tvector<int> res[100];\n\t\tfor (auto ri : v) {\n\t\t\tif (ri > 0) {\n\t\t\t\tint to = ma + 1;\n\t\t\t\tpar[to] = it;\n\t\t\t\tif (to) {\n\t\t\t\t\tres[it].push_back(to);\n\t\t\t\t\tres[to].push_back(it);\n\t\t\t\t\tt[it]++;\n\t\t\t\t}\n\t\t\t\tt[to] = 1;\n\t\t\t\te[to] = ri;\n\t\t\t\tit = to;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to = it;\n\t\t\t\tfor (int i = 0; i < abs(ri); i++) {\n\t\t\t\t\tto = par[to];\n\t\t\t\t}\n\t\t\t\tt[it]++;\n\t\t\t\tt[to]++;\n\t\t\t\tres[it].push_back(to);\n\t\t\t\tres[to].push_back(it);\n\t\t\t}\n\t\t\tma = max(ma, it);\n\t\t\twhile (it && e[it] == t[it]) {\n\t\t\t\tit = par[it];\n\t\t\t}\n\t\t}\n\t\tint sz = 0;\n\t\twhile (e[sz]) sz++;\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tsort(res[i].begin(), res[i].end());\n\t\t\tcout << i + 1 << ' ';\n\t\t\tfor (int j = 0; j < e[i]; j++) {\n\t\t\t\tcout << res[i][j] + 1 << \" \\n\"[j + 1 == e[i]];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_ROOM = 100;\n\nvector<int> sequence;\n\nint next_v;\nint degree[MAX_ROOM];\nint dist[MAX_ROOM];\nvector<int> G[MAX_ROOM];\n\nvoid dfs(int v, int &idx) {\n\tif(idx == sequence.size()) return;\n\n\tdegree[v] = sequence[idx++] - (v ? 1 : 0);\n\n\twhile(degree[v]) {\n\t\tif(sequence[idx] > 0) {\n\t\t\tG[v].emplace_back(next_v);\n\t\t\tG[next_v].emplace_back(v);\n\t\t\t--degree[v];\n\t\t\tdist[next_v] = dist[v] + 1;\n\t\t\tdfs(next_v++, idx);\n\t\t}\n\t\telse {\n\t\t\tfor(int u = 0; u < v; ++u) {\n\t\t\t\tif(dist[u] - dist[v] == sequence[idx] && degree[u]) {\n\t\t\t\t\tG[v].emplace_back(u);\n\t\t\t\t\tG[u].emplace_back(v);\n\t\t\t\t\t--degree[v];\n\t\t\t\t\t--degree[u];\n\t\t\t\t\t++idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init() {\n\tsequence.clear();\n\tnext_v = 1;\n\tmemset(dist, -1, sizeof(dist));\n\tdist[0] = 0;\n\tfor(auto &vec : G) vec.clear();\n}\n\nvoid solve() {\n\tinit();\n\tfor(int number; cin >> number && number;) {\n\t\tsequence.emplace_back(number);\n\t}\n\n\tint idx = 0;\n\tdfs(0, idx);\n\n\tfor(int v = 0; v < next_v; ++v) {\n\t\tsort(G[v].begin(), G[v].end());\n\t\tcout << v + 1;\n\t\tfor(const auto &to : G[v]) cout << \" \" << to + 1;\n\t\tcout << \"\\n\";\n\t}\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\n\twhile(t--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Door{\n\tDoor(){\n\t\tto = -1;\n\t}\n\tDoor(int arg_to){\n\t\tto = arg_to;\n\t}\n\tint to;\n};\n\nstruct Node{\n\tNode(){\n\t\tdist_from_start = next_open_door = -1;\n\t}\n\n\tint dist_from_start,next_open_door;\n\tDoor to_parent;\n\tvector<Door> children;\n};\n\nNode nodes[1000];\n\nint bug_count = 0;\n\nvoid func(){\n\n\tbug_count++;\n\n\tfor(int i = 0; i < 1000; i++){\n\t\tnodes[i].children.clear();\n\t\tnodes[i].next_open_door = 0;\n\t\tnodes[i].to_parent.to = -1;\n\t}\n\n\tint index = 0;\n\n\tint tmp;\n\tint pre_room = -2;\n\n\tint debug = 0;\n\n\twhile(true){\n\t\tscanf(\"%d\",&tmp);\n\t\tif(tmp == 0)break;\n\n\t\tdebug++;\n\n\t\tif(tmp > 0){\n\n\t\t\tnodes[index].to_parent.to = pre_room;\n\n\t\t\tif(pre_room != -2){\n\n\t\t\t\tfor(int i = 0; i < tmp-1; i++){\n\t\t\t\t\tnodes[index].children.push_back(Door(-1));\n\t\t\t\t}\n\n\t\t\t\tnodes[pre_room].children[nodes[pre_room].next_open_door++].to = index;\n\t\t\t\tnodes[index].dist_from_start = nodes[pre_room].dist_from_start+1;\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < tmp; i++){\n\t\t\t\t\tnodes[index].children.push_back(Door(-1));\n\t\t\t\t}\n\n\t\t\t\tnodes[index].dist_from_start = 0;\n\t\t\t}\n\n\t\t\tif(tmp > 1){\n\t\t\t\tpre_room = index;\n\t\t\t}else{\n\n\t\t\t\twhile(pre_room != 0 && nodes[pre_room].next_open_door >= nodes[pre_room].children.size()){\n\t\t\t\t\tpre_room = nodes[pre_room].to_parent.to;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex++;\n\n\n\t\t}else{\n\n\t\t\tfor(int i = index-1; i >=0 ; i--){\n\t\t\t\tif(nodes[i].dist_from_start-nodes[pre_room].dist_from_start == tmp && nodes[i].next_open_door < nodes[i].children.size()){\n\n\t\t\t\t\tnodes[pre_room].children[nodes[pre_room].next_open_door++].to = i;\n\t\t\t\t\tnodes[i].children[nodes[i].next_open_door++].to = pre_room;\n\n\t\t\t\t\tif(nodes[pre_room].next_open_door >= nodes[pre_room].children.size()){\n\n\t\t\t\t\t\tpre_room = nodes[pre_room].to_parent.to;\n\n\t\t\t\t\t\twhile(pre_room != 0 && nodes[pre_room].next_open_door >= nodes[pre_room].children.size()){\n\t\t\t\t\t\t\tpre_room = nodes[pre_room].to_parent.to;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> work;\n\n\tfor(int i = 0; i < index; i++){\n\t\tprintf(\"%d\",i+1);\n\n\t\tif(i != 0)work.push_back(nodes[i].to_parent.to+1);\n\n\t\tfor(int k = 0; k < nodes[i].children.size(); k++){\n\t\t\twork.push_back(nodes[i].children[k].to+1);\n\t\t}\n\n\t\tsort(work.begin(),work.end());\n\n\t\tfor(int k = 0; k < work.size(); k++){\n\t\t\tprintf(\" %d\",work[k]);\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\twork.clear();\n\t}\n\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9+7\n\nusing namespace std;\nbool infected[20000];\nvector<int> parents;\n\nstruct room{\n  int depth;\n  int doors;\n  vector<int> dlist;\n  room() : depth(0), doors(0), dlist() {}\n};\n\nint main(){\n  int n; cin >> n;\n  REP(counter, n) {\n    int num;\n    vector<int> data;\n    int rs = 0;\n    while(cin >> num and num) {\n      data.push_back(num);\n      if(num > 0) rs++;\n    }\n    vector<room> rooms(rs);\n    int currentid = 0;\n    int currentdepth = 0;\n    vector<int> parents;\n    REP(i, data.size()){\n      if(data[i] > 0){\n        rooms[currentid].doors = data[i];\n        rooms[currentid].depth = currentdepth;\n        if(parents.size() != 0){\n          int parent = parents[currentdepth-1];\n          rooms[parent].dlist.push_back(currentid);\n          rooms[currentid].dlist.push_back(parent);\n        }\n        parents.push_back(currentid);\n        currentid++; currentdepth++;\n      } else {\n        currentdepth--;\n        int parent = parents[currentdepth];\n        int dest = parents[currentdepth + data[i]];\n        rooms[parent].dlist.push_back(dest);\n        rooms[dest].dlist.push_back(parent);\n        while(currentdepth >= 0 and rooms[parents[currentdepth]].doors == rooms[parents[currentdepth]].dlist.size()){\n          parents.pop_back();\n          currentdepth--;\n        }\n        currentdepth++;\n      }\n    }\n    REP(i, rooms.size()) {\n      sort(ALL(rooms[i].dlist));\n      cout << i+1;\n      REP(j, rooms[i].doors){\n        cout << \" \" << rooms[i].dlist[j]+1;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tvector<int>rs;\n\t\twhile (1) {\n\t\t\tint a; cin >> a;\n\t\t\tif (!a)break;\n\t\t\trs.push_back(a);\n\t\t}\n\t\tvector<vector<int>>edges(1000);\n\t\tvector<int>edgenum(1000);\n\t\tvector<int>root;\n\t\tint nowroom = -1;\n\t\tint nextroom = 0;\n\t\tfor (int i = 0; i < rs.size(); ++i) {\n\t\t\tif (rs[i] > 0) {\n\t\t\t\tif (i) {\n\t\t\t\t\tedges[nowroom].push_back(nextroom);\n\t\t\t\t\tedges[nextroom].push_back(nowroom);\n\t\t\t\t}\n\t\t\t\tnowroom = nextroom;\n\t\t\t\tnextroom = nextroom + 1;\n\t\t\t\troot.push_back(nowroom);\n\t\t\t\tedgenum[nowroom] = rs[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedges[nowroom].push_back(*(root.end() + rs[i]-1));\n\t\t\t\tedges[*(root.end() + rs[i] - 1)].push_back(nowroom);\n\t\t\t\tint checkroom = nowroom;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (edges[checkroom].size() < edgenum[checkroom]) {\n\t\t\t\t\t\tnowroom = checkroom;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\troot.pop_back();\n\t\t\t\t\t\tif (root.empty())break;\n\t\t\t\t\t\tcheckroom = root.back();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint id = 0;\n\t\twhile (edges[id].size()) {\n\t\t\tsort(edges[id].begin(), edges[id].end());\n\t\t\tcout << id + 1;\n\t\t\tfor (int i = 0; i < edges[id].size(); ++i) {\n\t\t\t\tcout <<\" \"<< edges[id][i]+1;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tid++;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-100;\n      \n      assert(dist[ff+inp[p]].size() == 1);\n      rep(i,dist[ff+inp[p]].size() ){\n\t//for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n      \n      //if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    \n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nVI sz, xs, dist, prv;\nVVI edge;\nint M;\nint dfs(int& i, int cur){\n  if(i == SZ(xs)) return cur;\n  if(sz[cur] == 0) return cur+1;\n  if(xs[i] < 0){\n\t++sz[cur];\n\t++sz[prv[cur]];\n\tint res = cur;\n\tcur = prv[cur];\n\tint d = -xs[i], p = prv[cur];\n\twhile(true){\n\t  if(dist[cur] - dist[p] == d) break;\n\t  p = prv[p];\n\t  /*\n\t  if(p == -1){\n\t\tcout << \"HALT with \" << i << \", \" << cur << endl;\n\t\tfor(int i=0;i<M;++i) cout << prv[i] << \" \";\n\t\tcout << endl;\n\t\tbreak;\n\t  }\n\t  */\n\t}\n\n\t--sz[cur];\n\t--sz[p];\n\tedge[cur].PB(p);\n\tedge[p].PB(cur);\n\t++i;\n\treturn res;\n  }\n  //cout << i << \" \" << cur << \" \" << sz[cur] << endl;\n  int nxt = cur + 1;\n  ++i;\n  while(sz[cur] > 0){\n\t--sz[cur];\n\t--sz[nxt];\n\tprv[nxt] = cur;\n\tdist[nxt] = dist[cur] + 1;\n\tint nxt_ = dfs(i, nxt);\n\tif(nxt_ != nxt){\n\t  edge[cur].PB(nxt);\n\t  edge[nxt].PB(cur);\n\t  nxt = nxt_;\n\t}\n  }\n\n  return nxt;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  while(N--){\n\txs.clear();\n\tsz.clear();\n\tM = 0;\n\twhile(true){\n\t  int x;\n\t  cin >> x;\n\t  if(x == 0) break;\n\t  xs.PB(x);\n\t  if(x > 0){\n\t\tsz.PB(x);\n\t\t++M;\n\t  }\n\t}\n\tprv.assign(110, -1);\n\tdist.assign(110, 0);\n\tedge.assign(110, VI());\n\tint it = 0;\n\tdfs(it,0);\n\n\tfor(int i=0;i<M;++i){\n\t  cout << i+1;\n\t  SORT(edge[i]);\n\t  for(int j=0;j<SZ(edge[i]);++j)\n\t\tcout << \" \" << edge[i][j]+1;\n\t  cout << endl;\n\t}\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX_ROOM = 110;\nint N;\nvector<int> E[MAX_ROOM];\nqueue<int> Q[MAX_ROOM];\n\nvoid addEdge(int a, int b) {\n  E[a].push_back(b);\n  E[b].push_back(a);\n}\n\nvoid rec(int p, int t, int num_door, queue<int>& que) {\n  for(int i = 0; i < num_door; ++i) {\n    if(!Q[t].empty()) {\n      addEdge(p,Q[t].front());\n      Q[t].pop();\n    } else {\n      int a;\n      a = que.front();\n      que.pop();\n      if(a > 0) {\n\taddEdge(p,++N);\n\trec(N, t+1, a-1, que);\n      } else {\n\tQ[t+a].push(p);\n      }\n    }\n  }\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while(t--) {\n    for(int i = 0; i < MAX_ROOM; ++i) {\n      E[i].clear();\n      while(!Q[i].empty()) Q[i].pop();\n    }\n    int a;\n    queue<int> que;\n    while(cin >> a && a) que.push(a);\n\n    a = que.front(); que.pop();\n    N = 1;\n    rec(1,0,a,que);\n\n    for(int i = 1; i <= N; ++i) {\n      cout << i;\n      sort(E[i].begin(), E[i].end());\n      for(int j = 0; j < E[i].size(); ++j)\n\tcout << \" \" << E[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(100);\n\t\tint in, cnt = -1, times = -1, pre;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\tcnt++; times++;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, pre, node, edge);\n\t\t\t\tcur.pb(cnt);\n\t\t\t\tpre = times;\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\tfor(int i = pre; i >= 0; i--) {\n\t\t\t\t\tif(cur[i] - cnt == in && edge[i] > 0) {\n\t\t\t\t\t\tadd_Node(pre, i, node, edge);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!edge[pre]) pre--;\n\t\t\tcnt = cur[pre];\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(node[i].empty())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 110;\n\nvector<int> G[N];\n\nvoid solve(){\n    rep(i,N) G[i].clear();\n\n    vector<int> r;\n    while(1){\n        int v;\n        scanf(\" %d\", &v);\n        if(v==0) break;\n        r.pb(v);\n    }\n    int R = r.size();\n    if(R==0){\n        printf(\"1\\n\");\n        return;\n    }\n\n    int num = 0;\n    rep(i,R)if(r[i]>0) ++num;\n    assert(num<N);\n\n    // simulate dfs\n    int ct = 0;\n    int here = 0;\n    vector<int> vis;\n    vector<int> val;\n\n    assert(r[0]>0);\n    vis.pb(ct++);\n    val.pb(r[0]);\n\n    for(int i=1; i<R; ++i){\n        while(val[here]<=0){\n            vis.pop_back();\n            if(vis.empty()) assert(false);\n\n            here = vis.back();\n        }\n\n        if(r[i]>0){\n            // dfs木の辺\n            int par = vis.back();\n            vis.pb(ct++);\n            here = vis.back();\n\n            val.pb(r[i]);\n            --val[par];\n            --val[here];\n            G[par].pb(here);\n            G[here].pb(par);\n        }\n        else{\n            // 後退辺\n            int V = vis.size();\n            int idx = V-1 +r[i];\n            assert(idx>=0);\n\n            int par = vis[idx];\n            --val[par];\n            --val[here];\n            G[par].pb(here);\n            G[here].pb(par);\n        }\n    }\n\n    rep(i,num){\n        printf(\"%d\", i+1);\n        sort(all(G[i]));\n        for(int j:G[i]) printf(\" %d\", j+1);\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n    int T;\n    scanf(\" %d\", &T);\n    while(T--) solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<(int)n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-100;\n      \n      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n      rep(i,dist[ff+inp[p]].size() ){\n\t//for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n\t\n      }\n      \n      \n      //if ( to == -1){cout << \"test\" << endl;p++;continue;}\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    \n  }\n  \n}\n\n#define N 1000\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n  }\n  assert(te==-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_ROOM = 100;\n\nvector<int> sequence;\n\nint next_v;\nint degree[MAX_ROOM];\nint dist[MAX_ROOM];\nvector<int> G[MAX_ROOM];\n\nvoid dfs(int v, int &idx) {\n\tif(idx == sequence.size()) return;\n\n\tdegree[v] = sequence[idx++] - (v ? 1 : 0);\n\n\twhile(degree[v]) {\n\t\tif(sequence[idx] > 0) {\n\t\t\tG[v].emplace_back(next_v);\n\t\t\tG[next_v].emplace_back(v);\n\t\t\t--degree[v];\n\t\t\tdist[next_v] = dist[v] + 1;\n\t\t\tdfs(next_v++, idx);\n\t\t}\n\t\telse {\n\t\t\tfor(int u = 0; u < v; ++u) {\n\t\t\t\tif(dist[u] - dist[v] == sequence[idx] && degree[u]) {\n\t\t\t\t\tG[v].emplace_back(u);\n\t\t\t\t\tG[u].emplace_back(v);\n\t\t\t\t\t--degree[v];\n\t\t\t\t\t--degree[u];\n\t\t\t\t\t++idx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid init() {\n\tsequence.clear();\n\tnext_v = 1;\n\tdist[0] = 0;\n\tfor(auto &vec : G) vec.clear();\n}\n\nvoid solve() {\n\tinit();\n\tfor(int number; cin >> number && number;) {\n\t\tsequence.emplace_back(number);\n\t}\n\n\tint idx = 0;\n\tdfs(0, idx);\n\n\tfor(int v = 0; v < next_v; ++v) {\n\t\tsort(G[v].begin(), G[v].end());\n\t\tcout << v + 1;\n\t\tfor(const auto &to : G[v]) cout << \" \" << to + 1;\n\t\tcout << \"\\n\";\n\t}\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\n\twhile(t--) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cassert>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 110\n\nusing namespace std;\n\nvector<int> G[MAX];\nint remain[MAX];\nint depth[MAX];\n\nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n\n    for(int i=0;i<MAX;i++){\n      G[i].clear();\n      remain[i] = 0;\n      depth[i] = -1;\n    }\n    vector<int> record;\n    vector<int> input;\n\n    int r,cur,upper;\n\n    while(cin >> r,r){\n      input.push_back(r);\n    }\n\n    remain[0] = input[0];\n    cur = 0, upper = 1, depth[0] = 0;\n\n    for(int i=1;i<input.size();i++){\n      //cout << \"the input => \" << input[i] << endl;\n      //cout << \"i = \" << i << \" cur = \" << cur << endl;\n      if( input[i] > 0 ){\n\n\tG[cur].push_back(upper);\n\tG[upper].push_back(cur);\n\tdepth[upper] = depth[cur] + 1;\n\tremain[upper] = input[i] - 1;\n\tassert(remain[upper] >= 0);\n\tremain[cur]--;\n\tassert(remain[cur] >= 0);\n\tcur = upper++;\n\n      } else {\n\tassert(depth[cur] != -1);\n\tint next = depth[cur] + input[i];\n\tfor(int j=record.size()-1;j>=0;j--){\n\t  if(next == depth[record[j]]){\n\t    next = record[j];\n\t    break;\n\t  }\n\t}\n\tassert(next >= 0);\n\tG[next].push_back(cur);\n\tG[cur].push_back(next);\n\tremain[next]--;\n\tassert(remain[next] >= 0);\n\tremain[cur]--;\n\tassert(remain[cur] >= 0);\n\n      }\n\n      record.push_back(cur);\n\n      for(int j=record.size()-1;j>=0;j--){\n\tif(remain[cur] != 0){\n\t  break;\n\t}\n\tcur = record[j];\n      }\n\n      //cout << \"i = \" << i << \" become \" << cur << endl;\n      /*\n      cout << \"graph---\" << endl;\n      for(int j=0;j<upper;j++){\n\tcout << j+1;\n\tfor(int k=0;k<G[j].size();k++){\n\t  cout << \" \" << G[j][k]+1;\n\t}\n\tcout << endl;\n      }\n      cout << endl;\n      */\n    }\n\n    for(int i=0;i<upper;i++){\n      cout << i+1;\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<G[i].size();j++){\n\tcout << \" \" <<  G[i][j]+1;\n      }\n      cout << endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint main(void){\n\tint m;\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tvector<int> ans[105];\n\t\tvector<mp> sta;\n\t\tint n=0;\n\t\tsta.push_back(mp(10000,-1));\n\t\twhile(1){\n\t\t\t/*\n\t\t\trep(i,sta.size()){\n\t\t\t\tprintf(\"(%d %d)\\n\",sta[i].sec+1,sta[i].fir);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(a==0)break;\n\t\t\t\n\t\t\twhile(sta.back().fir==0)sta.pop_back();\n\t\t\tsta.back().fir--;\n\t\t\tif(a>0){\n\t\t\t\tint no = n;\n\t\t\t\tint to = sta.back().sec;\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tans[to].push_back(no);\n\t\t\t\t\tans[no].push_back(to);\n\t\t\t\t}\n\t\t\t\telse a++;\n\t\t\t\tsta.push_back(mp(a-1,no));\n\t\t\t\tn++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint no = sta.back().sec;\n\t\t\t\tint to = sta[sta.size()-1 + a].sec;\n\t\t\t\tsta[sta.size()-1+a].fir--;\n\t\t\t\tans[to].push_back(no);\n\t\t\t\tans[no].push_back(to);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tsort(ans[i].begin(),ans[i].end());\n\t\t\tprintf(\"%d \",i+1);\n\t\t\trep(j,ans[i].size()){\n\t\t\t\tprintf(\"%d%c\",ans[i][j]+1,i+1==ans[i].size()?'\\n':' ');\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nVI sz, xs, dist, prv;\nVVI edge;\nint M;\nint dfs(int& i, int cur){\n  if(i == SZ(xs)) return cur;\n  if(xs[i] < 0){\n\tcur = prv[cur];\n\tint d = -xs[i], p = prv[cur];\n\twhile(true){\n\t  if(dist[cur] - dist[p] == d) break;\n\t  p = prv[p];\n\t}\n\n\t--sz[cur];\n\t--sz[p];\n\tedge[cur].PB(p);\n\tedge[p].PB(cur);\n\t++i;\n\treturn -1;\n  }\n  \n  int nxt = cur + 1;\n  ++i;\n  while(sz[cur] > 0){\n\t--sz[cur];\n\t--sz[nxt];\n\tprv[nxt] = cur;\n\tdist[nxt] = dist[cur] + 1;\n\tint nxt_ = dfs(i, nxt);\n\tif(nxt_ >= 0){\n\t  edge[cur].PB(nxt);\n\t  edge[nxt].PB(cur);\n\t  nxt = nxt_;\n\t}\n\telse{\n\t  ++sz[cur];\n\t  ++sz[nxt];\t  \n\t  dist[nxt] = 0;\n\t}\n  }\n\n  return nxt;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  while(N--){\n\txs.clear();\n\tsz.clear();\n\tM = 0;\n\twhile(true){\n\t  int x;\n\t  cin >> x;\n\t  if(x == 0) break;\n\t  xs.PB(x);\n\t  if(x > 0){\n\t\tsz.PB(x);\n\t\t++M;\n\t  }\n\t}\n\tprv.assign(110, -1);\n\tdist.assign(110, 0);\n\tedge.assign(110, VI());\n\tint it = 0, nxt = 0;\n\tdfs(it,0);\n\n\tfor(int i=0;i<M;++i){\n\t  cout << i+1;\n\t  SORT(edge[i]);\n\t  for(int j=0;j<SZ(edge[i]);++j)\n\t\tcout << \" \" << edge[i][j]+1;\n\t  cout << endl;\n\t}\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int T;\n    cin >> T;\n    for(;T>0;T--){\n        vector<int> a;\n        for(int x=1; x!=0;){\n            cin >> x;\n            if(x!=0) a.push_back(x);\n        }\n        int m = 1;\n        stack<int> st;\n        vector<int> deg, depth;\n        vector<vector<int> > g;\n        st.push(0);\n        depth.push_back(0);\n        deg.push_back(a[0]);\n        g.push_back({});\n        a.erase(a.begin());\n        for(auto x : a){\n            int prev = st.top();\n            if(x > 0){\n                deg.push_back(x);\n                depth.push_back(depth[prev]+1);\n                g.push_back({});\n                g[m].push_back(prev);\n                g[prev].push_back(m);\n                deg[m]--;\n                deg[prev]--;\n                st.push(m);\n                m++;\n            }\n            else{\n                for(int i=0;i<m;i++){\n                    if(depth[i]==depth[prev]+x && deg[i]>0){\n                        g[i].push_back(prev);\n                        g[prev].push_back(i);\n                        deg[i]--;\n                        deg[prev]--;\n                        break;\n                    }\n                }\n            }\n            while(!st.empty() && deg[st.top()]==0) st.pop();\n        }\n        for(int i=0;i<m;i++){\n            cout << i+1;\n            sort(g[i].begin(), g[i].end());\n            for(auto x : g[i]){\n                cout << ' ' << x+1;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nint main(void){\n\tint t;\n\tcin >> t;\n\n\trep(loop,t){\n\t\tvector<int> add;\n\n\t\tint cur;\n\t\twhile(cin >> cur,cur) add.push_back(cur);\n\n\t\tint n=0;\n\t\tfor(auto &it:add) if(it>0) n++;\n\n\t\tvector<vector<int>> ans(n);\n\t\tvector<int> degree(n,0),ord;\n\t\tcur=-1;\n\n\t\tfor(auto &it:add){\n\t\t\tint len=0;\n\t\t\tif(it>0){\n\t\t\t\tord.push_back(++cur);\n\t\t\t\tdegree[cur]=it;\n\n\t\t\t\tlen=ord.size();\n\t\t\t\tif(len>=2){\n\t\t\t\t\tconst int a=ord[len-1],b=ord[len-2];\n\t\t\t\t\tdegree[a]--,degree[b]--;\n\t\t\t\t\tans[a].push_back(b);\n\t\t\t\t\tans[b].push_back(a);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlen=ord.size();\n\t\t\t\tconst int a=ord[len-1],b=ord[len-1+it];\n\t\t\t\tdegree[a]--,degree[b]--;\n\t\t\t\tans[a].push_back(b);\n\t\t\t\tans[b].push_back(a);\n\t\t\t}\n\n\t\t\twhile(ord.size() && degree[ord[ord.size()-1]]==0) ord.pop_back();\n\t\t}\n\n\t\trep(i,n){\n\t\t\tcout << i+1;\n\t\t\tsort(_all(ans[i]));\n\t\t\tfor(auto &j:ans[i]) cout << \" \" << j+1;\n\t\t\tcout << endl;\n\t\t}\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100;\n\nvoid rec(int v, int &k, int &time,\n         vector<int> &node, vector<int> &num, Graph &g) {\n  node[time] = v;\n  for(int r; num[v] && cin >> r && r; --num[v]) {\n    int to = -1;\n    if(r > 0) {\n      to = k++;\n      num[to] = r - 1;\n      ++time;\n      rec(to, k, time, node, num, g);\n      --time;\n    } else {\n      to = node[r + time];\n      num[to] -= 1;\n    }\n    g[v].push_back(to);\n    g[to].push_back(v);\n  }\n}\n\nint main() {\n  for(int tc = (cin >> tc, tc); tc--; ) {\n    int time = 0;\n    Graph g(MAXN);\n    int k = 1;\n    vector<int> num(MAXN), node(MAXN, -1);\n    int r = (cin >> r, r);\n    num[0] = r;\n    rec(0, k, time, node, num, g);\n    assert(cin >> r && r == 0);\n    for(int i = 0; i < k; ++i) {\n      cout << i+1;\n      sort(g[i].begin(), g[i].end());\n      for(int j = 0; j < g[i].size(); ++j) {\n        cout << \" \" << g[i][j]+1;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX_ROOM = 110;\nint N;\nvector<int> E[MAX_ROOM];\nqueue<int> Q[MAX_ROOM];\n\n\nvoid addEdge(int a, int b) {\n  E[a].push_back(b);\n  E[b].push_back(a);\n}\n\nvoid rec(int p, int t, int num_door, stringstream& ss) {\n  for(int i = 0; i < num_door; ++i) {\n    if(!Q[t].empty()) {\n      addEdge(p,Q[t].front());\n      Q[t].pop();\n    } else {\n      int a;\n      ss >> a;\n      if(a > 0) {\n\taddEdge(p,++N);\n\trec(N, t+1, a-1, ss);\n      } else {\n\tQ[t+a].push(p);\n      }\n    }\n  }\n}\n\nint main() {\n  int t;\n  cin >> t;\n  getchar();\n  while(t--) {\n    for(int i = 0; i < MAX_ROOM; ++i) E[i].clear();\n    string line;\n    getline(cin,line);\n    stringstream ss(line);\n    int a;\n    ss >> a;\n    N = 1;\n    rec(1,0,a,ss);\n    for(int i = 1; i <= N; ++i) {\n      cout << i;\n      sort(E[i].begin(), E[i].end());\n      for(int j = 0; j < E[i].size(); ++j)\n\tcout << \" \" << E[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Room{\n    int visited, dist;\n    vector<int> to;\n    Room(int door) {\n        to.resize(door, 0);\n        visited = 0;\n        dist = 0;\n    }\n    Room(int door, int before, int dist) : dist(dist){\n        to.resize(door, 0);\n        to[0] = before;\n        visited = 1;\n    }\n    void visit(int roomnum){\n        to[visited] = roomnum;\n        visited++;\n        return;\n    }\n    bool canBack(){ return visited <= to.size() - 1; }\n    void s(){ sort(to.begin(), to.end()); }\n    int before(){ return to[0]; }\n};\nvector<Room> house;\nint dfs(int num){\n    if(house[num].canBack()) return num;\n    if(house[num].before() >= 0)\n      return dfs(house[num].before());\n    else\n      return 0;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int T; cin >> T;\n    rep(casenum, T){\n        house.clear();\n        int _t;\n        int it = -1;\n        bool need_dfs = false;\n        while(cin >> _t && _t){\n            if(need_dfs) it = dfs(it);\n            int dist;\n            if(it != -1) dist = house[it].dist;\n            if(_t >= 0){\n                if(it == -1){\n                    house.push_back(Room(_t));\n                    it = 0;\n                    continue;\n                }\n                house.push_back(Room(_t, it, dist + 1));\n                int before = it;\n                it = house.size() - 1;\n                house[before].visit(it);\n                need_dfs = false;\n            }else{\n                int fd = dist + _t;\n                rep(i, house.size())\n                  if(fd == house[i].dist && house[i].canBack()){\n                      house[i].visit(it);\n                      house[it].visit(i);\n                      break;\n                  }\n                need_dfs = true;\n            }\n        }\n        it = 1;\n        for(Room& _r : house){\n            cout << it; it++;\n            _r.s();\n            for(int k : _r.to) cout << ' ' << k + 1;\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to;\n      sort(dist[ff+inp[p]].begin(),dist[ff+inp[p]].end());\n      rep(i,dist[ff+inp[p]].size() ){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\n      }\n\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      \n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid add_Node(int a, int b, vector<vi> &node, vi &edge) {\n\tnode[a].pb(b);\n\tnode[b].pb(a);\n\tedge[a]--;\n\tedge[b]--;\n\treturn;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi edge, cur;\n\t\tvector<vi> node(100);\n\t\tstack<int> s;\n\t\tint in, times = -1;\n\t\twhile(cin >> in, in) {\n\t\t\tif(in > 0) {\n\t\t\t\ttimes++;\n\t\t\t\tedge.pb(in);\n\t\t\t\tif(times)\n\t\t\t\t\tadd_Node(times, s.top(), node, edge);\n\t\t\t\ts.push(times);\n\t\t\t\tcur.pb(s.size()-1);\n\t\t\t}\n\t\t\telse if(in < 0) {\n\t\t\t\tstack<int> ss(s);\n\t\t\t\twhile(ss.size()) {\n\t\t\t\t\tif(cur[ss.top()] - cur[s.top()] == in && edge[ss.top()] > 0) {\n\t\t\t\t\t\tadd_Node(s.top(), ss.top(), node, edge);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tss.pop();\n\t\t\t\t}\n\t\t\t\twhile(!edge[s.top()]) {\n\t\t\t\t\tif(!s.top()) break;\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, node.size()) {\n\t\t\tif(node[i].empty())\n\t\t\t\tcontinue;\n\t\t\tcout << i + 1;\n\t\t\tsort(node[i].begin(), node[i].end());\n\t\t\tREP(j, node[i].size())\n\t\t\t\tcout << ' ' << node[i][j] + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nusing Graph = vector< vector<int> >;\n\n#define fprintf(...) void(0)\n\nvoid add_vertex(Graph &G, vector<int> &deg, vector<int> &par, int val, int pre) {\n    G.push_back(vector<int>());\n    deg.push_back(val);\n    par.push_back(pre);\n}\n\nvoid add_edge(Graph &G, vector<int> &deg, int u, int v) {\n    fprintf(stderr, \"add edge: u = %d, v = %d\\n\", u, v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n    deg[u]--;\n    deg[v]--;\n    fprintf(stderr, \"deg of u = %d, v = %d\\n\", deg[u], deg[v]);\n}\n\nint main() {\n    int T; cin >> T;\n    while(T--) {\n        int val;\n\n        Graph G;\n        vector<int> deg, par;\n\n        int cur = 0;\n        while(cin >> val, val) {\n            if(G.empty()) {\n                add_vertex(G, deg, par, val, -1);\n            }\n            else {\n                if(val > 0) {\n                    int nxt = (int)G.size();\n                    while(deg[cur] == 0) {\n                        cur = par[cur];\n                    }\n\n                    add_vertex(G, deg, par, val, cur);\n                    add_edge(G, deg, cur, nxt);\n                    cur = nxt;\n                }\n                else {\n                    val = -val;\n                    while(deg[cur] == 0) {\n                        cur = par[cur];\n                    }\n\n                    int nxt = cur;\n                    for(int i=0; i<val; i++) nxt = par[nxt];\n                    add_edge(G, deg, cur, nxt);\n                }\n            }\n        }\n\n        for(int i=0; i<G.size(); i++) {\n            sort(G[i].begin(), G[i].end());\n\n            cout << i+1;\n            for(auto to : G[i]) cout << \" \" << to + 1;\n            cout << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n\nusing Bool = bool;\nusing Int = long long int;\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\n\nBool solve() {\n    Vector<Vector<Int>> graph;\n    Vector<Int> deg, dist;\n\n    Stack<Int> stk;\n    while (true) {\n        Int a;\n        std::cin >> a;\n\n        if (a == 0) break;\n        if (a > 0) {\n            Int v = graph.size();\n            graph.push_back(Vector<Int>());\n            deg.push_back(a);\n\n            if (stk.empty()) {\n                dist.push_back(0);\n            } else {\n                Int u = stk.top();\n                dist.push_back(dist[u] + 1);\n                graph[u].push_back(v);\n                graph[v].push_back(u);\n                --deg[u], --deg[v];\n            }\n            stk.push(v);\n        } else {\n            Int v = stk.top();\n            Int u;\n            for (u = 0; u < v; ++u) {\n                if (deg[u] > 0 && dist[u] - dist[v] == a) break;\n            }\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            --deg[u], --deg[v];\n        }\n\n        while (!stk.empty() && deg[stk.top()] == 0) stk.pop();\n    }\n\n    for (Int v = 0; v < graph.size(); ++v) {\n        std::cout << v + 1;\n        std::sort(graph[v].begin(), graph[v].end());\n        for (auto u : graph[v]) {\n            std::cout << ' ' << u + 1;\n        }\n        std::cout << std::endl;\n    }\n    return true;\n}\n\nint main() {\n    Int n;\n    std::cin >> n;\n    for (Int i = 0; i < n; ++i) solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nvoid solve() {\n  vector<int> vec;\n  while(true) {\n    int v; cin >> v;\n    if(v == 0) break;\n    vec.emplace_back(v);\n  }\n\n  int ptr = 1;\n  vector< vector<int> > ans(1, vector<int>());\n  vector<int> rec;\n  vector<int> deg(1, 0), tar(1, 0);\n  for(size_t i=0; i<vec.size(); i++) {\n    if(vec[i] > 0) {\n      int p = -1;\n      if(rec.size()) p = rec.back();\n      rec.emplace_back(ptr);\n\n      // add new element\n      tar.emplace_back(vec[i]);\n      deg.emplace_back(0);\n      ans.emplace_back(vector<int>());\n\n      if(p > 0) {\n        deg[ptr]++; deg[p]++;\n        ans[ptr].emplace_back(p);\n        ans[p  ].emplace_back(ptr);\n      }\n      ptr++;\n    }\n    else {\n      int dist = -vec[i];\n      int u = rec.back(), v = rec[rec.size() - 1 - dist];\n      deg[u]++; deg[v]++;\n      ans[u].emplace_back(v);\n      ans[v].emplace_back(u);\n    }\n\n    // remove tails\n    while(rec.size()) {\n      int p = rec.back();\n      if(deg[p] == tar[p]) rec.pop_back();\n      else break;\n    }\n  }\n\n  int N = ans.size();\n  for(int i=1; i<N; i++) {\n    sort(ans[i].begin(), ans[i].end());\n    cout << i;\n    for(auto e : ans[i]) cout << \" \" << e;\n    cout << endl;\n  }\n}\n\nint main() {\n  int N; cin >> N;\n  while(N--) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nvoid solve() {\n  vector<vector<int>> room(105, vector<int>(50, inf));\n  vector<int> door(105, 0), d(105, 0), idx(105, 0);\n  int id = 1;\n  int t;\n  stack<int> path;\n  while (cin >> t, t) {\n    if (t > 0) {\n      if (path.size()) {\n        room[path.top()][idx[path.top()]++] = id;\n        room[id][idx[id]++] = path.top();\n      }\n      door[id] = t;\n      d[id] = path.size();\n      path.push(id);\n      id++;\n      while (path.size() && idx[path.top()] == door[path.top()]) {\n        path.pop();\n      }\n    }\n    else {\n      FOR(i, 1, id) {\n        if (d[i] - d[path.top()] == t && idx[i] != door[i]) {\n          room[i][idx[i]++] = path.top();\n          room[path.top()][idx[path.top()]++] = i;\n          while (path.size() && idx[path.top()] == door[path.top()]) {\n            path.pop();\n          }\n          break;\n        }\n      }\n    }\n  }\n  FOR(i, 1, id) sort(room[i].begin(), room[i].end());\n  FOR(i, 1, id) {\n    cout << i;\n    rep(j, door[i]) cout << ' ' << room[i][j];\n    cout << '\\n';\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n;\n  cin >> n;\n  while (n--) {\n    solve();\n  }\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 50;\n\nvector<int> G[N];\n\nvoid solve(){\n    rep(i,N) G[i].clear();\n\n    vector<int> r;\n    while(1){\n        int v;\n        scanf(\" %d\", &v);\n        if(v==0) break;\n        r.pb(v);\n    }\n    int R = r.size();\n    if(R==0){\n        printf(\"1\\n\");\n        return;\n    }\n\n    int num = 0;\n    rep(i,R)if(r[i]>0) ++num;\n    assert(num<N);\n\n    // simulate dfs\n    int ct = 0;\n    int here = 0;\n    vector<int> vis;\n    vector<int> val;\n\n    assert(r[0]>0);\n    vis.pb(ct++);\n    val.pb(r[0]);\n\n    for(int i=1; i<R; ++i){\n        while(val[here]<=0){\n            vis.pop_back();\n            if(vis.empty()) assert(false);\n\n            here = vis.back();\n        }\n\n        if(r[i]>0){\n            // dfs木の辺\n            int par = vis.back();\n            vis.pb(ct++);\n            here = vis.back();\n\n            val.pb(r[i]);\n            --val[par];\n            --val[here];\n            G[par].pb(here);\n            G[here].pb(par);\n        }\n        else{\n            // 後退辺\n            int V = vis.size();\n            int idx = V-1 +r[i];\n            assert(idx>=0);\n\n            int par = vis[idx];\n            --val[par];\n            --val[here];\n            G[par].pb(here);\n            G[here].pb(par);\n        }\n    }\n\n    rep(i,num){\n        printf(\"%d\", i+1);\n        sort(all(G[i]));\n        for(int j:G[i]) printf(\" %d\", j+1);\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n    int T;\n    scanf(\" %d\", &T);\n    while(T--) solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint main(void){\n\tint m;\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tvector<int> ans[105];\n\t\tvector<mp> sta;\n\t\tint n=0;\n\t\tsta.push_back(mp(10000,-1));\n\t\twhile(1){\n\t\t\t//printf(\"no .. %d\\n\",sta.back().sec+1);\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(a==0)break;\n\t\t\t\n\t\t\twhile(sta.back().fir==0)sta.pop_back();\n\t\t\t\n\t\t\tif(a>0){\n\t\t\t\tint no = n;\n\t\t\t\tint to = sta.back().sec;\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tans[to].push_back(no);\n\t\t\t\t\tans[no].push_back(to);\n\t\t\t\t}\n\t\t\t\tsta.push_back(mp(a-1,no));\n\t\t\t\tn++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint no = sta.back().sec;\n\t\t\t\tint to = sta[sta.size()-1 + a].sec;\n\t\t\t\tans[to].push_back(no);\n\t\t\t\tans[no].push_back(to);\n\t\t\t\tsta.back().fir--;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tsort(ans[i].begin(),ans[i].end());\n\t\t\tprintf(\"%d \",i+1);\n\t\t\trep(j,ans[i].size()){\n\t\t\t\tprintf(\"%d \",ans[i][j]+1);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n#define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint INF = 1000000000;\n\nint n;\nint dist[110];\nint degree[110];\nvector<int> graph[110];\nint cur_room;\nint max_idx;\n\nint main(){\n  cin >> n;\n  REP(iter, n) {\n    REP(i, 100) {\n      dist[i] = INF;\n      degree[i] = 0;\n      graph[i] = vector<int>();\n    }\n\n    cur_room = -1;\n    int max_idx = -1;\n    while(1) {\n      int m;\n      cin >> m;\n      if (m == 0) break;\n\n      if (m > 0) {\n        int prev_room = cur_room;\n        max_idx++;\n        cur_room = max_idx;\n        \n        if (prev_room >= 0) {\n          degree[prev_room]--;\n          degree[cur_room] = m-1;\n          dist[cur_room] = dist[prev_room] + 1;\n        \n          graph[prev_room].push_back(cur_room);\n          graph[cur_room].push_back(prev_room);\n        } else {\n          degree[cur_room] = m;\n          dist[cur_room] = 0;\n        }\n        while(degree[cur_room] == 0) {\n          cur_room = graph[cur_room][0];\n          if (cur_room == 0) break;\n        }\n      } else {\n        for(int i=cur_room-1; i>=0; i--) {\n          if (degree[i] > 0 && dist[i] - dist[cur_room] == m) {\n            degree[cur_room]--;\n            degree[i]--;\n\n            graph[i].push_back(cur_room);\n            graph[cur_room].push_back(i);\n            break;\n          }\n        }\n\n        while(degree[cur_room] == 0) {\n          cur_room = graph[cur_room][0];\n          if (cur_room == 0) break;\n        }\n      }\n    }\n\n    REP(i, max_idx+1) {\n      sort(graph[i].begin(), graph[i].end());\n      cout << i+1 << \" \";\n      REP(j, graph[i].size()) {\n        cout << graph[i][j] + 1;\n        if (j < graph[i].size()-1) {\n          cout << \" \";\n        } else {\n          cout << endl;\n        }\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\n\nsigned main(){\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tvi in;\n\t\tvvi G(1010);\n\t\tvi co(1010);\n\t\tint t=-1;\n\t\twhile(1){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tif(!a)break;\n\t\t\tin.pb(a);\n\t\t}\n\t\t\n\t\tdeque<int>de;\n\t\trep(i,in.size()){\n\t\t\tif(in[i]>0){\n\t\t\t\t++t;\n\t\t\t\tco[t]=in[i];\n\t\t\t\tif(de.size()){\n\t\t\t\t\tint w=de.back();\n\t\t\t\t\tG[w].pb(t);\n\t\t\t\t\tG[t].pb(w);\n\t\t\t\t\tco[w]--;\n\t\t\t\t\tco[t]--;\n\t\t\t\t}\n\t\t\t\tde.pb(t);\n\t\t\t}else{\n\t\t\t\tint w=de[-1+de.size()+in[i]];\n\t\t\t\tint a=de.back();\n\t\t\t\tG[w].pb(a);\n\t\t\t\tG[a].pb(w);\n\t\t\t\tco[w]--;\n\t\t\t\tco[a]--;\n\t\t\t}\n\t\t\twhile(!de.empty()){\n\t\t\t\tif(co[de.back()]==0)de.pop_back();\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\trep(i,1010)if(G[i].size()){\n\t\t\tcout<<i+1;\n\t\t\tsort(all(G[i]));\n\t\t\trep(j,G[i].size())cout<<\" \"<<1+G[i][j];\n\t\t\tcout<<endl;\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nstruct state {\n  int index;\n  int free_child; //no. of free children\n};\n\nint trace_parent(int cur_index, int backtrack, int parentLookup[101]) {\n  if (backtrack == 0) return cur_index;\n  return trace_parent(parentLookup[cur_index], backtrack-1, parentLookup);\n}\n\n\nint main() {\n  int N; //no. of explorations\n  cin >> N;\n\n  for (int i = 0; i < N; i++) {\n    stack<state> path;\n    vector<int> output[101];\n    int parentLookup[101] = {-1}; //index is a child of entry on current path\n\n    int max_state = 1;\n    parentLookup[1] = 1;\n    \n    int entry;\n    cin >> entry;\n\n    while (entry != 0) {\n      if (entry > 0) {\n\tstate new_state = { max_state, entry-1 };\n\t\n\t//add to output\n\tif (new_state.index != 1) {\n\t  int parent = path.top().index;\n\t  parentLookup[new_state.index] = parent;\n\t  output[new_state.index].push_back(parent);\n\t  output[parent].push_back(new_state.index);\n\t}\n\t\n\tpath.push(new_state);\n\tmax_state++;\n      } else if (entry < 0) {\n\tint backlink_id = trace_parent(path.top().index, -entry, parentLookup);\n\toutput[path.top().index].push_back(backlink_id);\n\toutput[backlink_id].push_back(path.top().index);\n\tpath.top().free_child -= 1;\n\tif (path.top().free_child == 0) {\n\t  path.pop();\n\t}\n      }\n      cin >> entry; \n    }\n    \n    for (int i = 1; i < max_state; i++) {\n      cout << i << \" \";\n      sort(output[i].begin(), output[i].end());\n      for (vector<int>::const_iterator j = output[i].begin(); j != output[i].end(); ++j) {\n\tcout << *j << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct node {\n  int id, depth, children = 0;\n  //vector<node*> children;\n  node* parent;\n};\n\nmultiset<int> path[110];\nint cur = 0, n;\n\nvoid dfs_ninja(node x) {\n  int info;\n  cin >> info;\n  if(info > 0) {\n    while((x.id == 1 && x.children < info) || (x.id != 1 && x.children < info-1)) {\n      cur++;\n      node child;\n      child.id = cur; child.depth = x.depth + 1;\n      child.parent = &x;\n      x.children++;\n      path[x.id].insert(child.id);\n      path[child.id].insert(x.id);\n      dfs_ninja(child);\n    }\n    return;\n  }\n  else if(info < 0) {\n    node* ancestor = x.parent;\n    for(int i = 0; i < -info; i++) ancestor = ancestor->parent;\n    path[x.parent->id].erase(x.id);\n    path[x.id].erase(x.parent->id);\n    path[x.parent->id].insert(ancestor->id);\n    path[ancestor->id].insert(x.parent->id);\n    ancestor->children++;\n    cur--;\n    return;\n  }\n  else return;\n}\n\nint main() {\n  cin >> n;\n  for(int roop = 0; roop < n; roop++) {\n    node root;\n    cur++;\n    root.id = cur; root.depth = 0;\n    root.parent = nullptr;\n    dfs_ninja(root);\n    int fin;\n    cin >> fin;\n    for(int i = 0; i < cur; i++) {\n      cout << i+1 << \" \";\n      for(auto itr = path[i+1].begin(); itr != path[i+1].end(); itr++) {\n\tcout << *itr << \" \";\n      }\n      cout << endl;\n      path[i+1].clear();\n    }\n    cur = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint ncase;\nvector<int> G[105];\nint door[105];\nvector<int> path;\n\nint main(void)\n{\n\tcin >> ncase;\n\tfor(int nc = 0; nc < ncase; nc++){\n\t\t\n\t\tint room_id = 0, in;\n\t\tfor(int i = 0; i < 105; i++) G[i].clear();\n\t\tpath.clear(), path.push_back(0);\n\t\t\n\t\twhile(1){\n\t\t\tcin >> in;\n\t\t\tif(in == 0) break;\n\t\t\t\n\t\t\tif(in > 0){\n\t\t\t\troom_id++;\n\t\t\t\tdoor[room_id] = in;\n\t\t\t\tif(path.back() != 0){\n\t\t\t\t\tG[room_id].push_back(path.back());\n\t\t\t\t\tdoor[room_id]--;\n\t\t\t\t\tG[path.back()].push_back(room_id);\n\t\t\t\t\tdoor[path.back()]--;\n\t\t\t\t}\n\t\t\t\tpath.push_back(room_id);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint dest = path[path.size()+in-1];\n\t\t\t\tG[path.back()].push_back(dest);\n\t\t\t\tdoor[path.back()]--;\n\t\t\t\tG[dest].push_back(path.back());\n\t\t\t\tdoor[dest]--;\n\t\t\t}\n\t\t\t\n\t\t\twhile( door[path.back()] == 0 && path.back() != 0 ){\n\t\t\t\tpath.erase(path.end()-1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= room_id; i++){\n\t\t\tcout << i;\n\t\t\tsort(G[i].begin(), G[i].end());\n\t\t\tfor(int j = 0; j < G[i].size(); j++) cout << \" \" << G[i][j];\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(int *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff]=node;\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to = dist[ff+inp[p]];\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      en[node]--;\n      en[to--];\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    if ( en[node]==0)break;\n\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    int n,dist[N]={0},en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> record;\nvector<int> dist;\nvector<int> deg;\nvector<vector<int>> edges;\nint idx;\n\nvoid dfs(int v, int p, int dep){\n    dist.push_back(dep);\n    int r = record[idx];\n    if(0 <= p){\n        r--;\n        edges.push_back({p});\n        deg[p]--;\n        edges[p].push_back(v);\n    }else{\n        edges.push_back({});\n    }\n    deg.push_back(r);\n    \n    while(deg[v]){\n        idx++;\n        if(record[idx]<0){\n            for(int i=0; i<dist.size(); i++){\n                if(dist[i] == dist[v] + record[idx] && 0 < deg[i]){\n                    edges[i].push_back(v);\n                    edges[v].push_back(i);\n                    deg[i]--;\n                    deg[v]--;\n                }\n            }\n        }else{\n            dfs(deg.size(), v, dep+1);\n        }\n    }\n}\n\nvoid solve(){\n    idx = 0;\n    dfs(0, -1, 0);\n    for(int i=0; i<edges.size(); i++){\n        auto edge = edges[i];\n        sort(edge.begin(), edge.end());\n        cout << i+1;\n        for(auto v: edge)\n            cout << \" \" << v+1;\n        cout << endl;\n    }\n}\n\nint main(){\n    int N; cin >> N;\n    int cnt = 1;\n    while (N--) {\n        record.clear();\n        dist.clear();\n        deg.clear();\n        edges.clear();\n        \n        int r;\n        while(cin >> r, r)\n            record.push_back(r);\n        //cout << \"Case:\" << cnt << endl;\n        solve();\n        cnt++;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < now; j++) {\n        if(num[j] - cnt == dd && sz[j] > 1) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n          break;\n        }\n      }\n    } else if(dd > 0) {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    } else {\n      break;\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n    cin >> sz[0];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid solve(int N,vector<int>& v,vector<int>& deg){\n    vector<vector<int>> ans(N);\n    vector<int> dist(N,0),cnt(N,0);\n    vector<int> vis;\n    int n = v.size();\n    int node = -1;\n    for(int i=0;i<n;i++){\n        if(v[i]>0){\n            node++;\n            if(vis.empty()){\n                vis.push_back(node);\n                dist[node] = 1;\n            }else{\n                int now = vis.back();\n                cnt[now]++;\n                dist[node] = dist[now] + 1;\n                ans[now].push_back(node);\n                ans[node].push_back(now);\n                if(v[i]!=1) vis.push_back(node);\n                cnt[node]++;\n            }\n        }else{\n            int now = vis.back();\n            for(int j=vis.size()-2;j>=0;j--){\n                if(dist[now]+v[i]==dist[vis[j]]){\n                    cnt[now]++;\n                    cnt[vis[j]]++;\n                    ans[now].push_back(vis[j]);\n                    ans[vis[j]].push_back(now);\n                    break;\n                }\n            }\n        }\n        while(!vis.empty() && cnt[vis.back()]==deg[vis.back()]) vis.pop_back();\n    }\n    for(int i=0;i<ans.size();i++){\n        cout << i+1 << \" \";\n        sort(ans[i].begin(),ans[i].end());\n        for(int j=0;j<ans[i].size();j++){\n            cout << ans[i][j]+1 << (j!=ans[i].size()-1? \" \":\"\\n\");\n        }\n    }\n}\n\nint main(){\n    int T;\n    cin >> T;\n    for(int t=0;t<T;t++){\n        vector<int> v,deg;\n        int a,N = 0;\n        while(cin >> a && a!=0){\n            v.push_back(a);\n            if(a>0){\n                N++;\n                deg.push_back(a);\n            }\n        }\n        solve(N,v,deg);\n    }   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve(){\n\tint m=1,r;\n\tpair<int,int> next,now=make_pair(0,100);\n\tvector<pair<int,int> > stack;\n\tvector<vector<int> > ans;\n\tvector<int> door(1,100);\n\tans.push_back(vector<int>());\n\twhile(cin>>r, r){\n//\t\tcout << r;\n//\t\twhile(door[now.first] <= 0){\n//\t\t\tnow=stack.back();\n//\t\t\tstack.pop_back();\n//\t\t}\n\t\tif(r>0){\n\t\t\tnext=make_pair(m++, r);\n\t\t\tans[now.first].push_back(next.first);\n\t\t\t--door[now.first];\n\t\t\tans.push_back(vector<int>());\n\t\t\tdoor.push_back(r-1);\n//\t\t\tif(now.first > 0){\n\t\t\t\tans[next.first].push_back(now.first);\n//\t\t\t}\n\t\t\tstack.push_back(now);\n\t\t\tnow=next;\n\t\t}else{\n\t\t\tint tmp=stack[stack.size()+r].first;\n//\t\t\tint tmp=stack.size()+r;\n\t\t\tans[now.first].push_back(tmp);\n\t\t\t--door[now.first];\n\t\t\tans[tmp].push_back(now.first);\n\t\t\t--door[tmp];\n\t\t}\n\t\twhile(door[now.first] <= 0){\n\t\t\tnow=stack.back();\n\t\t\tstack.pop_back();\n\t\t}\n//\t\tcout <<\" now:\"<<now.first<< endl;\n\t}\n\tfor(auto it=ans.begin()+1; it!=ans.end(); ++it){\n\t\tcout << (it-ans.begin());\n\t\tsort((*it).begin(), (*it).end());\n\t\tfor(auto j:(*it))if(j>0)\tcout<<\" \"<<j;\n\t\tcout << endl;\n\t}\n}\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(--N>=0)\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nsigned main(){\n  \n  int T;\n  cin>>T;\n\n  while(T--){\n    \n    vector<int> A;\n    \n    int N = 0;\n    \n    while(1){\n      int a;\n      cin>>a;\n      if( a == 0 ) break;\n      A.push_back(a);\n      if( a > 0 ) N++;\n    }\n    \n    vector<int> G[N];\n    \n    typedef pair<int,int> P;\n    \n    vector<P> st;\n    \n    st.push_back( P( 0, A[0] ) );\n    \n    int next = 1;\n    \n    for(int i=1;i<(int)A.size();i++){\n      \n      if( A[i] > 0 ){\n\t\n\tint pre = st[(int)st.size()-1].first;\n\t\n\tG[pre].push_back( next );\n\t\n\tG[next].push_back( pre );\n\t\n\tst[(int)st.size()-1].second--;\n\t\n\tst.push_back( P( next, A[i] - 1 ) );\n\t\n\tnext++;\n\t\n      }else{\n\t\n\tint pre = st[(int)st.size()-1+A[i]].first;\n\tint node = st[(int)st.size()-1].first;\n\t\n\tG[pre].push_back( node );\n\t\n\tG[node].push_back( pre );\n\t\n\tst[(int)st.size()-1].second--;\n\t\n\tst[(int)st.size()-1+A[i]].second--;\n\t\n      }\n      \n      while( (int)st.size() != 0 && st[(int)st.size()-1].second == 0 ){\n\tst.pop_back();\n      }\n      \n    }\n    \n    for(int i=0;i<N;i++){\n      \n      cout<<i+1;\n                  \n      sort( G[i].begin(), G[i].end() );\n      \n      for(int j=0;j<(int)G[i].size();j++){\n\tcout<<' ';\n\tcout<<G[i][j]+1;\n      }\n      \n      cout<<endl;\n      \n    }\n    \n  }\n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid solve(int *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff]=node;\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n\n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to = dist[ff+inp[p]];\n      edge[to].push_back(node);\n      edge[node].push_back(to);\n      en[node]--;\n      en[to--];\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    if ( en[node]==0)break;\n    else p++;\n  }\n  \n}\n\n#define N 100\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    int n,dist[N]={0},en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n\n\n  \n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n  int T; cin >> T;  \n  while (T--) {\n    vector<int> A;\n    {\n      int a; \n      while (cin >> a and a) A.push_back(a);\n    }\n    int n = count_if(A.begin(), A.end(), [](int a) { return a > 0; });\n    vector<vector<int>> g(n);\n    vector<int> deg;\n    vector<int> stk;\n    int cur = 0;\n    for (int a : A) {\n      if (a > 0) {\n        if (stk.size()) {\n          --deg.back();\n          --a;\n          g[stk.back()].push_back(cur);\n          g[cur].push_back(stk.back());\n        } \n        stk.push_back(cur++);\n        deg.push_back(a);\n      } else {\n        int u = stk[stk.size() - 1 + a];\n        g[stk.back()].push_back(u);\n        g[u].push_back(stk.back());\n        --deg.back();\n        --deg[stk.size() - 1 + a];\n      }\n      while (deg.size() and deg.back() == 0) deg.pop_back(), stk.pop_back();\n    }\n    for (int i = 0; i < n; ++i) {\n      cout << i + 1;\n      sort(g[i].begin(), g[i].end());\n      for (int u : g[i]) cout << ' ' << u + 1;\n      cout << '\\n';\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tvector<int>rs;\n\t\twhile (1) {\n\t\t\tint a; cin >> a;\n\t\t\tif (!a)break;\n\t\t\trs.push_back(a);\n\t\t}\n\t\tvector<vector<int>>edges(1000);\n\t\tvector<int>edgenum(1000);\n\t\tvector<int>root;\n\t\tint nowroom = -1;\n\t\tint nextroom = 0;\n\t\tfor (int i = 0; i < rs.size(); ++i) {\n\t\t\tif (rs[i] > 0) {\n\t\t\t\tif (i) {\n\t\t\t\t\tedges[nowroom].push_back(nextroom);\n\t\t\t\t\tedges[nextroom].push_back(nowroom);\n\t\t\t\t}\n\t\t\t\tnowroom = nextroom;\n\t\t\t\tnextroom = nextroom + 1;\n\t\t\t\troot.push_back(nowroom);\n\t\t\t\tedgenum[nowroom] = rs[i];\n\t\t\t\tint checkroom = nowroom;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (edges[checkroom].size() < edgenum[checkroom]) {\n\t\t\t\t\t\tnowroom = checkroom;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\troot.pop_back();\n\t\t\t\t\t\tif (root.empty()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcheckroom = root.back();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedges[nowroom].push_back(*(root.end() + rs[i]-1));\n\t\t\t\tedges[*(root.end() + rs[i] - 1)].push_back(nowroom);\n\t\t\t\tint checkroom = nowroom;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (edges[checkroom].size() < edgenum[checkroom]) {\n\t\t\t\t\t\tnowroom = checkroom;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\troot.pop_back();\n\t\t\t\t\t\tif (root.empty()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcheckroom = root.back();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint id = 0;\n\t\twhile (edges[id].size()) {\n\t\t\tsort(edges[id].begin(), edges[id].end());\n\t\t\tcout << id + 1;\n\t\t\tfor (int i = 0; i < edges[id].size(); ++i) {\n\t\t\t\tcout <<\" \"<< edges[id][i]+1;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tid++;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9+7\n\nusing namespace std;\nbool infected[20000];\nvector<int> parents;\n\nstruct room{\n  int depth;\n  int doors;\n  vector<int> dlist;\n  room() : depth(0), doors(0), dlist() {}\n};\n\nint main(){\n  int n; cin >> n;\n  REP(counter, n) {\n    int num;\n    vector<int> data;\n    int rs = 0;\n    while(cin >> num and num) {\n      data.push_back(num);\n      if(num > 0) rs++;\n    }\n    vector<room> rooms(rs);\n    int currentid = 0;\n    int currentdepth = 0;\n    vector<int> parents;\n    REP(i, data.size()){\n      if(data[i] > 0){\n        rooms[currentid].doors = data[i];\n        rooms[currentid].depth = currentdepth;\n        if(parents.size() != 0){\n          int parent = parents[currentdepth-1];\n          rooms[parent].dlist.push_back(currentid);\n          rooms[currentid].dlist.push_back(parent);\n        }\n        parents.push_back(currentid);\n        currentid++; currentdepth++;\n      } else {\n        currentdepth--;\n        int parent = parents[currentdepth];\n        int dest = parents[currentdepth + data[i]];\n        rooms[parent].dlist.push_back(dest);\n        rooms[dest].dlist.push_back(parent);\n        while(currentdepth >= 0 and rooms[parents[currentdepth]].doors == rooms[parents[currentdepth]].dlist.size()){\n          parents.pop_back();\n          currentdepth--;\n        }\n        currentdepth++;\n      }\n    }\n    REP(i, rooms.size()) assert(rooms[i].doors == rooms[i].dlist.size());\n    REP(i, rooms.size()) {\n      sort(ALL(rooms[i].dlist));\n      cout << i+1;\n      REP(j, rooms[i].doors){\n        cout << \" \" << rooms[i].dlist[j]+1;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct node {\n  int id, depth, children = 0;\n  node* parent;\n};\n\nmultiset<int> path[110];\nint cur = 0, n;\n\nvoid dfs_ninja(node x) {\n  int info;\n  cin >> info;\n  if(info > 0) {\n    while((x.id == 1 && x.children < info) || (x.id != 1 && x.children < info-1)) {\n      cur++;\n      node child;\n      child.id = cur; child.depth = x.depth + 1;\n      child.parent = &x;\n      x.children++;\n      path[x.id].insert(child.id);\n      path[child.id].insert(x.id);\n      dfs_ninja(child);\n    }\n    return;\n  }\n  else if(info < 0) {\n    node* ancestor = x.parent;\n    for(int i = 0; i < -info; i++) ancestor = ancestor->parent;\n    path[x.parent->id].erase(x.id);\n    path[x.id].erase(x.parent->id);\n    path[x.parent->id].insert(ancestor->id);\n    path[ancestor->id].insert(x.parent->id);\n    ancestor->children++;\n    cur--;\n    return;\n  }\n  else return;\n}\n\nint main() {\n  cin >> n;\n  for(int roop = 0; roop < n; roop++) {\n    node root;\n    cur++;\n    root.id = cur; root.depth = 0;\n    root.parent = nullptr;\n    dfs_ninja(root);\n    int fin;\n    cin >> fin;\n    for(int i = 0; i < cur; i++) {\n      cout << i+1;\n      for(auto itr = path[i+1].begin(); itr != path[i+1].end(); itr++) {\n\tcout << \" \" << *itr;\n      }\n      cout << endl;\n      path[i+1].clear();\n    }\n    cur = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nstruct node {\n  int id, depth, children = 0;\n  //vector<node*> children;\n  node* parent;\n};\n\nmultiset<int> path[110];\nint cur = 0, n;\n\nvoid dfs_ninja(node x) {\n  int info;\n  cin >> info;\n  if(info > 0) {\n    while((x.id == 1 && x.children < info) || (x.id != 1 && x.children < info-1)) {\n      cur++;\n      node child;\n      child.id = cur; child.depth = x.depth + 1;\n      child.parent = &x;\n      x.children++;\n      path[x.id].insert(child.id);\n      path[child.id].insert(x.id);\n      dfs_ninja(child);\n    }\n    return;\n  }\n  else if(info < 0) {\n    node* ancestor = x.parent;\n    for(int i = 0; i < -info; i++) ancestor = ancestor->parent;\n    path[x.parent->id].erase(x.id);\n    path[x.id].erase(x.parent->id);\n    path[x.parent->id].insert(ancestor->id);\n    path[ancestor->id].insert(x.parent->id);\n    ancestor->children++;\n    cur--;\n    return;\n  }\n  else return;\n}\n\nint main() {\n  cin >> n;\n  for(int roop = 0; roop < n; roop++) {\n    node root;\n    cur++;\n    root.id = cur; root.depth = 0;\n    root.parent = nullptr;\n    dfs_ninja(root);\n    int fin;\n    cin >> fin;\n    for(int i = 0; i < cur; i++) {\n      cout << i+1 << \" \";\n      for(auto itr = path[i+1].begin(); itr != path[i+1].end(); itr++) {\n\tcout << *itr << \" \";\n      }\n      cout << endl;\n      path[i+1].clear();\n    }\n    cur = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < now; j++) {\n        if(num[j] - cnt == dd && sz[j] > 1) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n        }\n      }\n    } else {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 100; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    Latte(idx, 0);\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n    cin >> sz[0];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<(int)n;i++)\n#define rep(i,n) REP(i,0,n)\n#define N 1000\n\nvoid solve(vector<int> *dist,int *en,vector<int>*edge,vector<int>&inp,\n\t   int &p,int ff,int &cnt){//from first\n  int now = inp[p++];\n  int node = cnt;\n  dist[ff].push_back(node);\n  en[node] = cnt==0?now:now-1;\n  cnt++;\n  \n  while(p<inp.size() && en[node]){\n    if ( inp[p]<0){\n      int to=-100;      \n      rep(i,dist[ff+inp[p]].size() ){\n\t//for(int i=(int)dist[ff+inp[p]].size()-1;i>=0;i--){\n\tif ( en[dist[ff+inp[p]][i]] >0){\n\t  to=dist[ff+inp[p]][i];\n\t  break;\n\t}\t\n      }    \n\n      edge[to].push_back(node);\n      edge[node].push_back(to);      \n      en[node]--;\n      en[to]--;\n      p++;\n    }else if (inp[p]>0){\n      en[node]--;\n      edge[node].push_back(cnt);\n      edge[cnt].push_back(node);\n      solve(dist,en,edge,inp,p,ff+1,cnt);\n    }\n    \n  }\n  /*\n  REP(i,ff,N){\n    dist[i].clear();\n  }\n  */\n}\n\n\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    vector<int> edge[N];\n    vector<int> inp;\n    vector<int> dist[N];\n    int n,en[N]={0},p=0,cnt=0;\n    while(cin>>n && n !=0)inp.push_back(n);\n\n    solve(dist,en,edge,inp,p,0,cnt);\n    rep(i,N){\n      if ( edge[i].size() == 0)continue;\n      sort(edge[i].begin(),edge[i].end());\n      cout << i+1 ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j]+1;\n      cout << endl;\n    }\n\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> G[200];\nint Gs[200];\nint F[200];\nvector<int> V;\nint cnt;\nvoid solve(int id,int h){\n  F[id] = h;\n  //  cout << \"inid : \" << id << \" \" << h <<  \" \" << V[cnt] << \" F \" << F[id] << endl;\n  \n  for(int i=1;i<=100;i++){\n    int d = V[cnt];\n    if( d > 0 ){\n      if( !Gs[i] ) {\n        G[id].push_back( i );\n        G[i].push_back( id );\n        Gs[i] = d; cnt++;\n        solve(i,h+1);\n        i = 0;\n      }    \n    } else {\n      //cout << \"nex \" << d << \" i \" << i << \" = \"  << F[i]<<\" - \" << F[id] <<\" = \" << F[i]-F[id] << endl;\n        if( F[i]!=-1 && F[i] - F[id] == d && Gs[i] > (int)G[i].size() ){\n          G[id].push_back(i);\n          G[i].push_back(id);\n          cnt++;\n          i = 0;\n        }\n    }\n    if( (int)G[id].size() == Gs[id] ) {\n      //  cout <<\"id: \" << id << \" \" <<  G[id].size() <<\", \" << Gs[id] << endl;\n      break;\n    }\n    assert(i<100);\n  }\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    memset(F,-1,sizeof(F));\n    memset(Gs,0,sizeof(Gs));\n    V.clear();\n    for(int i=0;i<200;i++) G[i].clear();\n    int t;\n    while(cin>>t && t ) V.push_back(t);\n    \n    cnt = 0;\n    Gs[1]=V[cnt++];\n    solve(1,0);\n    for(int i=1;i<=100;i++){\n      if( G[i].empty() ) continue;\n      //      cout << Gs[i] << \" \" << G[i].size() << endl;\n      sort(G[i].begin(),G[i].end());\n      cout << i;\n      for(int j=0;j<(int)G[i].size();j++) cout << \" \" << G[i][j];\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nvector<int> in;\n \nvector<int> G[1000];\nint pos=0;\nint path[1000];\nint ed[1000];\nint newn;\n \nvoid dfs(int cv,int depth){\n  //cout << cv << ' ' << depth << endl;\n  path[depth] = cv;\n  ed[cv] = in[pos++];\n  bool ok = false;\n  while(pos < SZ(in)){\n    int t=in[pos];\n    //cout << t << endl;\n    if(t<0){\n      assert(depth+t>=0);\n      int nv=path[depth+t];\n      G[cv].pb(nv);\n      G[nv].pb(cv);\n      ++pos;\n    }else{\n      ++newn;\n      G[cv].pb(newn);\n      G[newn].pb(cv);\n      dfs(newn,depth+1);\n    }\n    if(SZ(G[cv]) == ed[cv]){\n      ok = true;\n      break;\n    }\n  }\n  assert(ok);\n}\n \nvoid solve(){\n  newn = 0;\n  in.clear();\n  int t;\n  int no=0;\n  while(cin >> t, t){\n    no += t>0;\n    in.pb(t);\n  }\n  \n  rep(i,no) G[i].clear();\n  pos = 0;\n  dfs(0,0);\n  rep(i,no) sort(ALL(G[i]));\n \n  rep(i,no){\n    cout << i+1;\n    FOR(it,G[i]) cout << ' ' << *it+1;\n    cout << endl;\n  }\n}\n \nint main(){\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nvector<int> v;\nint cur;\nint room;\nvector<int> G[1000];\nint dist[1000];\nvector<int> his;\n\nvoid dfs(int p, int d) {\n\tint r = v[cur];\n\tif(r < 0) {\n\t\tint x = his[his.size() - 1 + r];\n\t\tG[x].push_back(p);\n\t\tG[p].push_back(x);\n\t\treturn;\n\t}\n\tint now = room++;\n\this.push_back(now);\n\tdist[now] = d;\n\tif(p != -1) {\n\t\tG[now].push_back(p);\n\t\tG[p].push_back(now);\n\t}\n\n\twhile(G[now].size() < r) {\n\t\tcur++;\n\t\tdfs(now, d + 1);\n\t}\n\this.pop_back();\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\twhile(n--) {\n\t\tv.clear();\n\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\n\t\tint a;\n\t\twhile(cin >> a, a) v.push_back(a);\n\t\tcur = room = 0;\n\t\tdfs(-1, 0);\n\t\tfor(int i = 0; i < room; i++) {\n\t\t\tcout << i + 1;\n\t\t\tsort(G[i].begin(), G[i].end());\n\t\t\tfor(int r : G[i]) cout << \" \" << r + 1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX_ROOM = 110;\nint N;\nvector<int> E[MAX_ROOM];\nqueue<int> Q[MAX_ROOM];\n\nvoid addEdge(int a, int b) {\n  E[a].push_back(b);\n  E[b].push_back(a);\n}\n\nvoid rec(int p, int t, int num_door, stringstream& ss) {\n  for(int i = 0; i < num_door; ++i) {\n    if(!Q[t].empty()) {\n      addEdge(p,Q[t].front());\n      Q[t].pop();\n    } else {\n      int a;\n      if(!(ss >> a) || a == 0) return;\n      if(a > 0) {\n\taddEdge(p,++N);\n\trec(N, t+1, a-1, ss);\n      } else {\n\tQ[t+a].push(p);\n      }\n    }\n  }\n}\n\nint main() {\n  int t;\n  cin >> t;\n  getchar();\n  while(t--) {\n    for(int i = 0; i < MAX_ROOM; ++i) {\n      E[i].clear();\n      while(!Q[i].empty()) Q[i].pop();\n    }\n    string line;\n    getline(cin,line);\n    stringstream ss(line);\n    int a;\n    ss >> a;\n    N = 1;\n    rec(1,0,a,ss);\n    for(int i = 1; i <= N; ++i) {\n      cout << i;\n      sort(E[i].begin(), E[i].end());\n      for(int j = 0; j < E[i].size(); ++j)\n\tcout << \" \" << E[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint a[500],x,c;\nint t[500],u[500];\nvector<int> G[500];\n\nvoid init(){\n  for(int i=0;i<500;i++){\n    G[i].clear();\n    u[i]=0;\n  }\n}\n\nint main(){\n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    init();\n    a[0]=1,x=1;\n    cin>>t[1];\n    c=1;\n\n    while(1){\n      if(x==0){\n\tint q;\n\tcin>>q;\n\tassert(q==0);\n\tbreak;\n      }\n      int p=a[--x],q;\n\n      if(t[p]>0&&t[p]==(int)G[p].size()){\n\t//cout<<p<<'-'<<endl;\n\tcontinue;\n      }else{\n\t//cout<<p<<endl;\n      }\n\n      cin>>q;\n      if(q==0)break;\n      \n      if(q>0){\n\tt[++c]=q;\n\tG[p].push_back(c);\n\tG[c].push_back(p);\n\ta[x++]=p;\n\ta[x++]=c;\n      }else{\n\t/*\n\tcout<<p<<' '<<q<<' '<<x<<' '<<a[x+q]<<endl;\n\tfor(int i=0;i<x;i++)cout<<a[i]<<'=';cout<<endl;\n\t*/\n\tG[p].push_back(a[x+q]);\n\tG[a[x+q]].push_back(p);\n\tif((int)G[p].size()<t[p])a[x++]=p;\n      }\n    }\n\n    for(int i=1;G[i].size();i++){\n      cout<<i;\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<(int)G[i].size();j++)\n\tcout<<' '<<G[i][j];\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    while(N--) {\n        vector<int> cnt;\n        vector<vector<int>> g;\n        vector<int> st;\n        while(true) {\n            int rec;\n            cin >> rec;\n            if(!rec) {\n                break;\n            }\n\n            if(rec > 0) {\n                if(st.empty()) {\n                    st.push_back(0);\n                    g.push_back(vector<int>{});\n                    cnt.push_back(rec);\n                } else {\n                    int par = st.back();\n                    g[par].push_back(g.size());\n                    g.push_back(vector<int>(1, par));\n                    st.push_back(g.size()-1);\n                    cnt[par]--;\n                    cnt.push_back(rec-1);\n                }\n            } else {\n                int now = st.back();\n                int v = st[st.size()+rec-1];\n                g[v].push_back(now);\n                g[now].push_back(v);\n                cnt[v]--; cnt[now]--;\n            }\n            while(cnt[st.back()] == 0) {\n                st.pop_back();\n                if(st.empty()) {\n                    break;\n                }\n            }\n        }\n        for(int i=0; i<g.size(); ++i) {\n            cout << i+1 << ' ';\n            sort(g[i].begin(), g[i].end());\n            for(int j=0; j<g[i].size(); ++j) {\n                cout << g[i][j]+1 << \" \\n\"[j == g[i].size()-1] << flush;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi a, c, d;\n\t\tvector<vi> v(100);\n\t\tint in;\n\t\twhile(cin >> in, in)\n\t\t\ta.pb(in);\n\t\tint cur = 0, top = 0;\n\t\tc.pb(0); d.pb(a[0]);\n\t\tFOR(i, 1, a.size()) {\n\t\t\tif(a[i] > 0) {\n\t\t\t\ttop++;\n\t\t\t\tc.pb(c[cur]+1); d.pb(a[i]);\n\t\t\t\tv[top].pb(cur); v[cur].pb(top);\n\t\t\t\td[top]--; d[cur]--;\n\t\t\t\tcur = top;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to;\n\t\t\t\tfor(int j = cur-1; j >= 0; j--) {\n\t\t\t\t\tif(c[j] - c[cur] == a[i]) {\n\t\t\t\t\t\tto = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[to].pb(cur); v[cur].pb(to);\n\t\t\t\td[to]--; d[cur]--;\n\t\t\t\tif(i == a.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t\twhile(!d[cur]) cur--;\n\t\t\t}\n\t\t}\n\t\tREP(i, top+1) {\n\t\t\tcout << i+1;\n\t\t\tsort(v[i].begin(), v[i].end());\n\t\t\tREP(j, v[i].size())\n\t\t\t\tcout << ' ' << v[i][j]+1;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\n\nint main(){\n    int n;\n    cin >> n;\n    while(n--){\n        vector<int> mark;\n        while(1){\n            int a;\n            cin >> a;\n            if(a==0) break;\n            else mark.push_back(a);\n        }\n        vector<vector<int>> ans;\n        vector<int> num;\n        vector<int> order;\n        vector<int> dist(10000,0);\n        num.push_back(mark[0]);\n        ans.push_back({});\n        order.push_back(0);\n        int now = 0;\n\n        for(int i=1;i<mark.size();i++){\n            if(mark[i]>0){\n                ans.push_back({});\n                num.push_back(mark[i]);\n                int next = (int)(ans.size()) - 1;\n\n                ans[now].push_back(next);\n                ans[next].push_back(now);\n                dist[next] = dist[now] + 1;\n                \n                order.push_back(next);\n\n                int p = (int)(order.size()) - 1;\n                while(1){\n                    if(num[order[p]]>(int)(ans[order[p]].size())){\n                        now = order[p];\n                        break;\n                    }\n                    p --;\n                    if(p<0) break;\n                }\n            }else{\n                int ever = (int)(order.size())-1;\n                while(1){\n                    if(dist[order[ever]]==dist[now]+mark[i]) break;\n                    ever --;\n                }\n\n                ans[order[ever]].push_back(now);\n                ans[now].push_back(order[ever]);\n\n                int next = (int)(order.size()) - 1;\n                while(1){\n                    if(num[order[next]]>(int)(ans[order[next]].size())){\n                        now = order[next];\n                        break;\n                    }\n                    next --;\n                    if(next<0) break;\n                }\n            }\n        }\n\n        rep(i,ans.size()){\n            cout << i+1 ;\n            sort(ans[i].begin(),ans[i].end());\n            rep(j,ans[i].size()) cout << \" \" << ans[i][j]+1 ;\n            cout << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint main(void){\n\tint m;\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tvector<int> ans[105];\n\t\tvector<mp> sta;\n\t\tint n=0;\n\t\tsta.push_back(mp(10000,-1));\n\t\twhile(1){\n\t\t\t/*\n\t\t\trep(i,sta.size()){\n\t\t\t\tprintf(\"(%d %d)\\n\",sta[i].sec+1,sta[i].fir);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(a==0)break;\n\t\t\t\n\t\t\twhile(sta.back().fir==0)sta.pop_back();\n\t\t\tsta.back().fir--;\n\t\t\tif(a>0){\n\t\t\t\tint no = n;\n\t\t\t\tint to = sta.back().sec;\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tans[to].push_back(no);\n\t\t\t\t\tans[no].push_back(to);\n\t\t\t\t}\n\t\t\t\telse a++;\n\t\t\t\tsta.push_back(mp(a-1,no));\n\t\t\t\tn++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint no = sta.back().sec;\n\t\t\t\tint to = sta[sta.size()-1 + a].sec;\n\t\t\t\tsta[sta.size()-1+a].fir--;\n\t\t\t\tans[to].push_back(no);\n\t\t\t\tans[no].push_back(to);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tsort(ans[i].begin(),ans[i].end());\n\t\t\tprintf(\"%d \",i+1);\n\t\t\trep(j,ans[i].size()){\n\t\t\t\tprintf(\"%d%c\",ans[i][j]+1,j+1==ans[i].size()?'\\n':' ');\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    int rec, count = 0, depth = 0;\n    int vs[10000], unopen[10000];\n    vector<int> G[10000];\n\n    cin >> rec;\n    vs[++depth]\t  = ++count;\n    unopen[depth] = rec;\n    \n    while(cin >> rec && rec != 0){\n      while(depth > 0 && unopen[depth] == 0) depth--;      \n      unopen[depth]--;\n      if(rec > 0){\n\tvs[++depth]   = ++count;\n\tunopen[depth] = rec - 1;\n\tG[count].push_back(vs[depth-1]);\n\tG[vs[depth-1]].push_back(count);\n      }else{\n\tG[vs[depth + rec]].push_back(vs[depth]);\n\tG[vs[depth]].push_back(vs[depth + rec]);\n\tunopen[depth + rec]--;\n      }\n    }\n    \n    REP2(i, 1, count + 1){\n      cout << i;\n      sort(ALL(G[i]));\n      REP(j, G[i].size()) cout << \" \" << G[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <set>\nusing namespace std;\nint RB[105][105],deep[105],edge[105];\nmap<int,set<int> >dp;set<int>stak;\nint main() {\n    int N,i,j,k,here,cur,qt,gt;scanf(\"%d\",&N);while (N--) {\n        for (i=0;i<105;edge[i]=deep[i]=0,i++) for (j=0;j<105;RB[i][j++]=0);here=k=1;dp.clear();\n\t\tdp[0].insert(1);scanf(\"%d\",&edge[1]);stak.insert(0),stak.insert(-1);\n        while (scanf(\"%d\",&cur)!=EOF && cur) {\n            if (cur>0) {\n\t\t\t\tk++;stak.insert(-k);\n                edge[here]--,edge[k]+=cur-1;\n\t\t\t\tdeep[k]=deep[here]+1;dp[deep[k]].insert(k);\n\t\t\t\tRB[here][k]++,RB[k][here]++;\n\t\t\t\tif (!edge[here]) {\n\t\t\t\t\tdp[deep[here]].erase(here);\n\t\t\t\t\tstak.erase(-here);\n\t\t\t\t}\n\t\t\t\there=k;\n            } else {\n\t\t\t\tqt=deep[here]+cur,gt=*dp[qt].begin();\n\t\t\t\tedge[gt]--,edge[here]--,RB[gt][here]++,RB[here][gt]++;\n\t\t\t\tif (!edge[gt]) {\n\t\t\t\t\tdp[deep[gt]].erase(gt);\n\t\t\t\t\tstak.erase(-gt);\n\t\t\t\t}\n\t\t\t\tif (!edge[here]) {\n\t\t\t\t\tdp[deep[here]].erase(here);\n\t\t\t\t\tstak.erase(-here);\n\t\t\t\t\there=-(*stak.begin());\n\t\t\t\t}\n            }\n        }\n        for (i=1;i<=k;i++) {printf(\"%d\",i);for (j=1;j<=k;j++) while (RB[i][j]--) printf(\" %d\",j);puts(\"\");}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint main(void){\n\tint m;\n\tscanf(\"%d\",&m);\n\trep(i,m){\n\t\tvector<int> ans[105];\n\t\tvector<mp> sta;\n\t\tint n=0;\n\t\tsta.push_back(mp(10000,-1));\n\t\twhile(1){\n\t\t\t/*\n\t\t\trep(i,sta.size()){\n\t\t\t\tprintf(\"(%d %d)\\n\",sta[i].sec+1,sta[i].fir);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(a==0)break;\n\t\t\t\n\t\t\twhile(sta.back().fir==0)sta.pop_back();\n\t\t\tsta.back().fir--;\n\t\t\tif(a>0){\n\t\t\t\tint no = n;\n\t\t\t\tint to = sta.back().sec;\n\t\t\t\tif(to!=-1){\n\t\t\t\t\tans[to].push_back(no);\n\t\t\t\t\tans[no].push_back(to);\n\t\t\t\t}\n\t\t\t\telse a++;\n\t\t\t\tsta.push_back(mp(a-1,no));\n\t\t\t\tn++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint no = sta.back().sec;\n\t\t\t\tint to = sta[sta.size()-1 + a].sec;\n\t\t\t\tsta[sta.size()-1+a].fir--;\n\t\t\t\tans[to].push_back(no);\n\t\t\t\tans[no].push_back(to);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,n){\n\t\t\tsort(ans[i].begin(),ans[i].end());\n\t\t\tprintf(\"%d \",i+1);\n\t\t\trep(j,ans[i].size()){\n\t\t\t\tprintf(\"%d \",ans[i][j]+1);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint a[500],x,c;\nint t[500],u[500];\nvector<int> G[500];\n\nvoid init(){\n  c=0;\n  for(int i=0;i<500;i++){\n    G[i].clear();\n    u[i]=0;\n  }\n}\n\nint main(){\n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    init();\n    a[0]=1,x=1;\n    cin>>t[1];\n    c=1;\n\n    while(x){\n      int p=a[--x],q;\n      cin>>q;\n      if(q==0)break;\n      \n      if(q>0){\n\n\tt[++c]=q;\n\n\tG[p].push_back(c);\n\tG[c].push_back(p);\n\n\t//cout<<p<<' '<<c<<endl;\n\ta[x++]=p;\n\ta[x++]=c;\n      }else{\n\t/*\n\tcout<<p<<' '<<q<<' '<<x<<' '<<a[x+q]<<endl;\n\tfor(int i=0;i<x;i++)cout<<a[i]<<'=';cout<<endl;\n\t*/\n\tG[p].push_back(a[x+q]);\n\tG[a[x+q]].push_back(p);\n\tif((int)G[p].size()<t[p])a[x++]=p;\n      }\n    }\n\n    for(int i=1;G[i].size();i++){\n      cout<<i;\n      sort(G[i].begin(),G[i].end());\n      for(int j=0;j<(int)G[i].size();j++)\n\tcout<<' '<<G[i][j];\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef complex<double> xy_t;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    int tmp;\n    vector<int> record;\n    while(cin >> tmp && tmp != 0) record.push_back(tmp);\n    \n    int count = 0;\n    int depth = 0;\n    int vs[2000];\n    int degree[2000];\n    vector<int> G[2000];\n    \n    REP(i, record.size()){\n      while(depth > 1 && degree[depth] == 0) depth--;\n      \n      degree[depth]--;      \n      if(record[i] > 0){\n\t\n\tvs[++depth]   = ++count;\n\tdegree[depth] = record[i] - 1;\n\tif(depth > 1){\n\t  G[count].push_back(vs[depth-1]);\n\t  G[vs[depth-1]].push_back(count);\n\t}\n      }else{\n\tG[vs[depth + record[i]]].push_back(vs[depth]);\n\tG[vs[depth]].push_back(vs[depth + record[i]]);\n      }\n    }\n    \n    REP2(i, 1, count + 1){\n      cout << i;\n      sort(ALL(G[i]));\n      REP(j, G[i].size()) cout << \" \" << G[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<vector<int> > solve(vector<int> v)\n{\n\tvector<vector<int> > res;\n\tvector<int> parent;\n\tvector<int> sizes;\n\tparent.push_back(-1);\n\tparent.push_back(0);\n\tsizes.push_back(v[0]);\n\tsizes.push_back(v[1]);\n\tvector<int> tmp;\n\ttmp.push_back(1);\n\tres.push_back(tmp);\n\ttmp.clear();\n\ttmp.push_back(0);\n\tres.push_back(tmp);\n\tint nownum = 1;\n\tfor(int i = 2; i < v.size(); i++){\n\t\t// cout << i << endl;\n\t\tif(v[i] > 0){\n\t\t\tparent.push_back(nownum);\n\t\t\tsizes.push_back(v[i]);\n\t\t\tres[nownum].push_back(res.size());\n\t\t\ttmp.clear();\n\t\t\ttmp.push_back(nownum);\n\t\t\tres.push_back(tmp);\n\t\t\tnownum = res.size() - 1;\n\t\t} else {\n\t\t\tint partner = nownum;\n\t\t\tfor(int j = 0; j < -v[i]; j++){\n\t\t\t\tpartner = parent[partner];\n\t\t\t}\n\t\t\tres[partner].push_back(nownum);\n\t\t\tres[nownum].push_back(partner);\n\t\t}\n\t\twhile(parent[nownum] >= 0 && res[nownum].size() == sizes[nownum]) nownum = parent[nownum];\n\t}\n\t// for(int i = 0; i < res.size(); i++){\n\t// \tcout << i + 1 << \" \" << parent[i] + 1 << endl;\n\t// }\n\t// cout << endl;\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tvector<int> v;\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\twhile(tmp != 0){\n\t\t\tv.push_back(tmp);\n\t\t\tcin >> tmp;\n\t\t}\n\t\tvector<vector<int> > res = solve(v);\n\t\tfor(int i = 0; i < res.size(); i++){\n\t\t\tcout << i + 1 << \" \";\n\t\t\tsort(res[i].begin(), res[i].end());\n\t\t\tfor(int j = 0; j < res[i].size(); j++){\n\t\t\t\tcout << res[i][j] + 1;\n\t\t\t\tif(j == res[i].size() - 1) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cout << fixed << setprecision(10);\n  int cntout = 0;\n  int q; cin >> q;\n  while(q) {\n    q--;\n    vi v;\n    int tmp;\n    int cnt = 0;\n    while(1) {\n      cin >> tmp;\n      if(tmp == 0) break;\n      cnt += tmp > 0;\n      v.push_back(tmp);\n    }\n    vector<P> st;\n    vvi g(cnt);\n    int id = 0;\n    for(int i=0;i<(int)(v.size());++i) {\n      if(st.empty()) {\n        assert(v[i] > 0);\n        st.push_back({id, v[i]});\n        id++;\n        continue;\n      } else if(v[i] > 0) {\n        int pre = st.back().first;\n        st.back().second--;\n        v[i]--;\n        g[pre].push_back(id);\n        g[id].push_back(pre);\n        st.push_back({id, v[i]});\n        while(!st.empty() && st.back().second == 0) st.pop_back();\n        id++;\n      } else {\n        int diff = -v[i];\n        int pos = (int)(st.size()) - 1 - diff;\n        int id1 = st[pos].first;\n        int id2 = st.back().first;\n        g[id1].push_back(id2);\n        g[id2].push_back(id1);\n        st[pos].second--;\n        st.back().second--;\n        while(!st.empty() && st.back().second == 0) st.pop_back();\n      }\n    }\n    assert(cnt == id);\n    for(int i=0;i<cnt;++i) {\n      cout << i+1;\n      cntout++;\n      sort(g[i].begin(), g[i].end());\n      for(int j=0;j<(int)(g[i].size());++j) {\n        cout << \" \" << g[i][j] + 1;\n        cntout++;\n      }\n      cout << endl;\n      cntout++;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tvi a, c, d;\n\t\tvector<vi> v(100);\n\t\tint in;\n\t\twhile(cin >> in, in)\n\t\t\ta.pb(in);\n\t\tint cur = 0, top = 0;\n\t\tc.pb(0); d.pb(a[0]);\n\t\tFOR(i, 1, a.size()) {\n\t\t\tif(a[i] > 0) {\n\t\t\t\ttop++;\n\t\t\t\tc.pb(c[cur]+1); d.pb(a[i]);\n\t\t\t\tv[top].pb(cur); v[cur].pb(top);\n\t\t\t\td[top]--; d[cur]--;\n\t\t\t\tcur = top;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to;\n\t\t\t\tfor(int j = cur; j >= 0; j--) {\n\t\t\t\t\tif(c[j] - c[cur] == a[i] && d[j] > 0) {\n\t\t\t\t\t\tto = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[to].pb(cur); v[cur].pb(to);\n\t\t\t\td[to]--; d[cur]--;\n\t\t\t\tif(i == a.size()-1)\n\t\t\t\t\tbreak;\n\t\t\t\twhile(!d[cur]) cur--;\n\t\t\t}\n\t\t}\n\t\tREP(i, top+1) {\n\t\t\tcout << i+1;\n\t\t\tsort(v[i].begin(), v[i].end());\n\t\t\tREP(j, v[i].size())\n\t\t\t\tcout << ' ' << v[i][j]+1;\n\t\t\tcout << endl;\n\t\t}\n\t\tREP(i, c.size())\n\t\t\tcout << c[i] << ' ';\n\t\tREP(i, d.size())\n\t\t\tcout << d[i] << ' ';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef complex<double> xy_t;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint main(){\n  int n;\n  string tmp;\n  cin >> n;\n  getline(cin, tmp);\n  while(n--){\n    getline(cin, tmp);\n    istringstream in(tmp);\n\n    int rec;\n    vector<int> record;\n    while(in >> rec) record.push_back(rec);\n    \n    int count = 0;\n    int depth = 0;\n    int vs[2000];\n    int degree[2000];\n    vector<int> G[2000];\n\n    REP(i, record.size() - 1){\n      while(depth > 1 && degree[depth] == 0) depth--;\n      \n      degree[depth]--;\n      if(record[i] > 1){\n\t\n\tvs[++depth]   = ++count;\n\tdegree[depth] = record[i] - 1;\n\tif(depth > 1){\n\t  G[count].push_back(vs[depth-1]);\n\t  G[vs[depth-1]].push_back(count);\n\t}\n      }else{\n\tG[vs[depth + record[i]]].push_back(vs[depth]);\n\tG[vs[depth]].push_back(vs[depth + record[i]]);\n      }\n    }\n    \n    REP2(i, 1, count + 1){\n      cout << i;\n      sort(ALL(G[i]));\n      REP(j, G[i].size()) cout << \" \" << G[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve(){\n\tvector<int> doors(1,0);\n\tvector<vector<int> > ans(1, vector<int>());\n\tint r,p=0,d=0;\n\twhile(cin >> r, r){\n\t\tif(r>0){\n\t\t\tdoors.push_back(r);\n\t\t\tint q=p;\n\t\t\tp=doors.size()-1;\n\t\t\tans[q].push_back(p);\n\t\t\tans.push_back(vector<int>());\n\t\t\tif(q>0)\tans[p].push_back(q);\n\t\t\t++d;\n\t\t}else{\n\t\t\tint q=d+r;\n\t\t\tans[p].push_back(q);\n\t\t\tans[q].push_back(p);\n\t\t\twhile(ans[p].size()>=doors[p]){\n\t\t\t\t--p;\n\t\t\t\t--d;\n\t\t\t}\n\t\t}\n//\t\tcout << \"R:\" << r << \" P:\" << p << endl;\n\t}\n\tfor(int i=1; i<ans.size(); ++i){\n\t\tcout << i;\n\t\tsort(begin(ans[i]), end(ans[i]));\n\t\tfor(auto j: ans[i])\tcout << \" \" << j;\n\t\tcout << endl;\n\t}\n}\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(--N>=0)\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n#include <list>\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nint num[110];\nint vacant[110];\n\nvector<vector<int>> G;\n\nvoid add_edge(int a, int b){\n\tG[a].push_back(b);\n\tG[b].push_back(a);\n}\n\nvector<int> rec;\n\nvoid dfs(int &id, int d, int prv, int &i){\n\tif (rec.size() == i) return;\n\tint cur = id;\n\tint x = rec[i];\n\n\tif (x < 0){\n\t\t--id;\n\t\tadd_edge(prv, vacant[d - 1 + x]);\n\t\treturn;\n\t}\n\n\tif (prv > 0) add_edge(prv, cur);\n\t\n\tnum[cur] = x;\n\tif (G[cur].size() < num[cur]) vacant[d] = cur;\n\twhile (G[cur].size() < num[cur]){\n\t\t++id, ++i;\n\t\tdfs(id, d + 1, cur, i);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\n\n\tint t;\n\tcin >> t;\n\twhile (t--){\n\t\trec.clear();\n\t\tint a;\n\t\twhile (cin >> a, a) rec.push_back(a);\n\n\t\tG.assign(110, vector<int>());\n\n\t\tint id = 1, i = 0;\n\t\tdfs(id, 0, -1, i);\n\t\tfor (int i = 1; i <= id; ++i){\n\t\t\tsort(ALL(G[i]));\n\t\t\tcout << i;\n\t\t\tfor (auto v : G[i]) cout << ' ' << v;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[1001];\nint sz[1001], num[1001];\n\nvoid Latte(int &idx, int cnt)\n{\n  int now = idx, dd;\n  num[now] = cnt;\n  for(int i = 0; i < sz[now] - 1; i++) {\n    cin >> dd;\n    if(dd < 0) {\n      for(int j = 0; j < now; j++) {\n        if(num[j] - cnt == dd && sz[j] > 1) {\n          --sz[j];\n          g[j].push_back(now);\n          g[now].push_back(j);\n          break;\n        }\n      }\n    } else if(dd > 0) {\n      sz[++idx] = dd;\n      g[now].push_back(idx);\n      g[idx].push_back(now);\n      Latte(idx, cnt + 1);\n    } else {\n      throw (0);\n    }\n  }\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  while(T--) {\n    memset(sz, 0, sizeof(sz));\n    memset(num, 0, sizeof(num));\n    for(int i = 0; i < 1001; i++) g[i].clear();\n\n    cin >> sz[0];\n    int idx = 0;\n    try {\n      Latte(idx, 0);\n      cin >> sz[0];\n    } catch(int x) {};\n    for(int i = 0; i <= idx; i++) {\n      sort(begin(g[i]), end(g[i]));\n      cout << i + 1;\n      for(int j : g[i]) cout << \" \" << j + 1;\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>g[110];\nint sz[110];\nint now[110];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\twhile(a--){\n\t\tvector<int>v;\n\t\twhile(1){\n\t\t\tint b;scanf(\"%d\",&b);\n\t\t\tif(!b)break;\n\t\t\tv.push_back(b);\n\t\t}\n\t\tfor(int i=0;i<110;i++)g[i].clear();\n\t\tfor(int i=0;i<110;i++)sz[i]=0;\n\t\tint d=-1;\n\t\tint at=-1;\n\t\tint n=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(v[i]>0){\n\t\t\t\t//n++;\n\t\t\t\twhile(~at&&g[at].size()==sz[at]){\n\t\t\t\t\td--;\n\t\t\t\t\tat=now[d];\n\t\t\t\t}\n\t\t\t\td++;at=n;\n\t\t\t\tn++;\n\t\t\t\tnow[d]=at;\n\t\t\t\tsz[at]=v[i];\n\t\t\t\tif(d){\n\t\t\t\t\tg[now[d-1]].push_back(at);\n\t\t\t\t\tg[at].push_back(now[d-1]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\twhile(g[at].size()==sz[at]){\n\t\t\t\t\td--;\n\t\t\t\t\tat=now[d];\n\t\t\t\t}\n\t\t\t\tg[at].push_back(now[d+v[i]]);\n\t\t\t\tg[now[d+v[i]]].push_back(at);\n\t\t\t}\n\t\t//\tfor(int j=0;j<=d;j++)printf(\"%d \",now[j]);printf(\"\\n\");\n\t\t}\n\t\tfor(int i=0;i<n;i++)std::sort(g[i].begin(),g[i].end());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tprintf(\"%d\",i+1);\n\t\t\tfor(int j=0;j<g[i].size();j++)printf(\" %d\",g[i][j]+1);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> G[200];\nint Gs[200];\nint F[200];\nvector<int> V;\nint cnt;\nvoid solve(int id,int h){\n  //  cout << id << \" \" << h << endl;\n  //cout << V[cnt] << endl;\n  F[id] = h;\n  int d = V[cnt]; cnt++;\n  if( d > 0 ) Gs[id] = d;\n  for(int i=1;i<=100;i++){\n    if( cnt == V.size() ) return;\n    d = V[cnt];\n    if( d > 0 ){\n      if( !Gs[i] ) {\n        G[id].push_back( i );\n        G[i].push_back( id );\n        solve(i,h+1);\n        i = 1;\n      }    \n    } else {\n        if( F[i] == -1 ) continue;\n        if( F[i] - F[id] == d ){\n          G[id].push_back(i);\n          G[i].push_back(id);\n          cnt++;\n          i = 1;\n        }\n    }\n    if( (int)G[id].size() == Gs[id] ) break;\n  }\n}\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    memset(F,-1,sizeof(F));\n    memset(Gs,0,sizeof(Gs));\n    V.clear();\n    for(int i=0;i<200;i++) G[i].clear();\n    int t;\n    while(cin>>t && t ) V.push_back(t);\n    cnt = 0;\n    solve(1,0);\n    for(int i=1;i<=100;i++){\n      if( G[i].empty() ) continue;\n      sort(G[i].begin(),G[i].end());\n      cout << i;\n      for(int j=0;j<(int)G[i].size();j++) cout << \" \" << G[i][j];\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1236 Map of Ninja House\n// 2018.2.6 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint n, id;\nint r[101];\nint g[101][101], hi[101];\nint deg[101], depth[101];\n\nvoid dfs(int k, int d)\n{\n\tint t;\n\n\tn++, depth[d] = k;\n \n\twhile (hi[k] < deg[k]) {\n\t\tif (r[id] > 0) {\n\t\t\tdeg[n] = r[id++];\n\t\t\tg[k][hi[k]++] = n;\n\t\t\tg[n][hi[n]++] = k;\n\t\t\tdfs(n, d+1);\n\t\t} else{\n\t\t\tt = depth[d + r[id++]];\n\t\t\tg[k][hi[k]++] = t;\n\t\t\tg[t][hi[t]++] = k;\n\t\t}\n\t}\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n    int cno, i, j;\n\t\n\tcno = in();\n    while (cno--) {\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (i = 0; r[i] = in(); i++);\n\n        n = 0, id = 1, deg[0] = r[0];\n\t\tdfs(0, 0);\n\n\t\tfor (i = 0; i < n; i++) {\n            printf(\"%d\", i+1);\n\t\t\tqsort(g[i], hi[i], sizeof(int), cmp);\n\t\t\tfor (j = 0; j < hi[i]; j++) printf(\" %d\", g[i][j] + 1);\n            putchar('\\n');\n\t\t}\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1236 Map of Ninja House\n// 2018.2.6 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint n, id;\nint r[1002];\nint g[102][102], hi[102];\nint deg[102], depth[102];\n\nvoid dfs(int k, int d)\n{\n\tint t;\n\n\tn++, depth[d] = k;\n\twhile (hi[k] < deg[k]) {\n\t\tif (r[id] > 0) {\n\t\t\tdeg[n] = r[id++];\n\t\t\tg[k][hi[k]++] = n;\n\t\t\tg[n][hi[n]++] = k;\n\t\t\tdfs(n, d+1);\n\t\t} else{\n\t\t\tt = depth[d + r[id++]];\n\t\t\tg[k][hi[k]++] = t;\n\t\t\tg[t][hi[t]++] = k;\n\t\t}\n\t}\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n    int cno, i, j;\n\t\n\tcno = in();\n    while (cno--) {\n\t\tmemset(r, 0, sizeof(r));\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (i = 0; r[i] = in(); i++);\n\n        n = 0, id = 1, deg[0] = r[0];\n\t\tdfs(0, 0);\n\n\t\tfor (i = 0; i < n; i++) {\n            printf(\"%d\", i+1);\n\t\t\tqsort(g[i], hi[i], sizeof(int), cmp);\n\t\t\tfor (j = 0; j < hi[i]; j++) printf(\" %d\", g[i][j] + 1);\n            putchar('\\n');\n\t\t}\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match WA\n\t//0509 WA * 2\n\t//0920 WA * 2\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [count=\" + count + \", rest=\" + rest + \", list=\" + list.toString()\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t}\n\t\t\t\t//次のnowroomを探す\n\t\t\t\tfor(int j = rooms.size() - 1; j >= 0; j--){\n\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size();i++){\n\t\t\t\tint rest = rooms.get(i).rest;\n\t\t\t\tif(rest > 0 && rest % 2 == 0){\n\t\t\t\t\tfor(int j = 0; j < rest / 2; j++){\n\t\t\t\t\t\trooms.get(i).list.add(i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(\"debug = \");\n//\t\t\tfor(int i = 0; i < rooms.size(); i++){\n//\t\t\t\tSystem.out.println(rooms.get(i));\n//\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match WA\n\t//0509 WA * 2\n\t//0920 WA * 2\n\t//0921 AC\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t}\n\t\t\t\t//次のnowroomを探す\n\t\t\t\tfor(int j = nowroom ; j >= 0; j--){\n\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//Map of Ninja House\npublic class Main{\n\n\tclass R{\n\t\tint id, door;\n\t\tList<Integer> adj;\n\t\tpublic R(int id, int door) {\n\t\t\tthis.id = id;\n\t\t\tthis.door = door;\n\t\t\tadj = new ArrayList<Integer>();\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tR room[] = new R[101];\n\t\t\tStack<R> v = new Stack<R>();\n\t\t\tint ID = 1;\n\t\t\tint x = sc.nextInt();\n\t\t\troom[ID] = new R(ID, x);\n\t\t\tR now = room[ID];\n\t\t\tv.push(room[ID]);\n\t\t\tID++;\n\t\t\tfor(;;){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(x==0)break;\n\t\t\t\twhile(v.peek().door==0)v.pop();\n\t\t\t\tnow = v.peek();\n\t\t\t\tif(x>0){\n\t\t\t\t\tR next = new R(ID, x);\n\t\t\t\t\tnow.adj.add(ID); next.adj.add(now.id);\n\t\t\t\t\tnext.door--;\n\t\t\t\t\tnow.door--;\n\t\t\t\t\troom[ID] = next;\n\t\t\t\t\tv.push(next);\n\t\t\t\t\tnow = next;\n\t\t\t\t\tID++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tR r = v.get(v.size()-1+x);\n\t\t\t\t\tr.adj.add(now.id); now.adj.add(r.id);\n\t\t\t\t\tnow.door--;\n\t\t\t\t\tr.door--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<ID;i++){\n\t\t\t\tSystem.out.print(i+\" \");\n\t\t\t\tCollections.sort(room[i].adj);\n\t\t\t\tfor(int j=0;j<room[i].adj.size();j++)System.out.print(room[i].adj.get(j)+(j==room[i].adj.size()-1?\"\\n\":\" \"));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match WA\n\t//0509 WA * 2\n\t//0920 WA * 2\n\t//0921 AC\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//次のnowroomを探す\n\t\t\t\t\tfor(int j = nowroom; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t\t\n\t\t\t\t\tfor(int j = nextroomid; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [count=\" + count + \", rest=\" + rest + \", list=\" + list.toString()\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//次のnowroomを探す\n\t\t\t\t\tfor(int j = nowroom; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t\t\n\t\t\t\t\tnowroom = nextroomid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n//\t\t\t//debug\n//\t\t\tSystem.out.println(\"debug = \");\n//\t\t\tfor(int i = 0; i < rooms.size(); i++){\n//\t\t\t\tSystem.out.println(rooms.get(i));\n//\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match WA\n\t//0509 WA * 2\n\t//0920 WA * 2\n\t//0921 AC\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t}\n\t\t\t\t//次のnowroomを探す\n\t\t\t\tfor(int j = rooms.size() - 1; j >= 0; j--){\n\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match WA\n\t//0509 WA * 2\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [count=\" + count + \", rest=\" + rest + \", list=\" + list.toString()\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//次のnowroomを探す\n\t\t\t\t\tfor(int j = rooms.size() - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t\t\n\t\t\t\t\tnowroom = nextroomid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size();i++){\n\t\t\t\tint rest = rooms.get(i).rest;\n\t\t\t\tif(rest > 0 && rest % 2 == 0){\n\t\t\t\t\tfor(int j = 0; j < rest / 2; j++){\n\t\t\t\t\t\trooms.get(i).list.add(i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(\"debug = \");\n//\t\t\tfor(int i = 0; i < rooms.size(); i++){\n//\t\t\t\tSystem.out.println(rooms.get(i));\n//\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match WA\n\t//0509 WA * 2\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [count=\" + count + \", rest=\" + rest + \", list=\" + list.toString()\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//次のnowroomを探す\n\t\t\t\t\tfor(int j = nowroom; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t\t\n\t\t\t\t\tnowroom = nextroomid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size();i++){\n\t\t\t\tint rest = rooms.get(i).rest;\n\t\t\t\tif(rest > 0 && rest % 2 == 0){\n\t\t\t\t\tfor(int j = 0; j < rest / 2; j++){\n\t\t\t\t\t\trooms.get(i).list.add(i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(\"debug = \");\n//\t\t\tfor(int i = 0; i < rooms.size(); i++){\n//\t\t\t\tSystem.out.println(rooms.get(i));\n//\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = nowroom - 1; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//次のnowroomを探す\n\t\t\t\t\tfor(int j = nowroom; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t\t\n\t\t\t\t\tnowroom = nextroomid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0140 start\n\t//0200 end\n\t//0430 restart\n\t//0442 sample match WA\n\t//0519 WA\n\t\n\tclass C{\n\t\tint count, rest;\n\t\tArrayList<Integer> list;\n\t\tpublic C(int count, int rest) {\n\t\t\tthis.count = count;\n\t\t\tthis.rest = rest;\n\t\t\tthis.list = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tprivate void sort(){\n\t\t\tCollections.sort(this.list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [count=\" + count + \", rest=\" + rest + \", list=\" + list.toString()\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n-- > 0){\n\t\t\tArrayList<Integer> input = new ArrayList<Integer>();\n\t\t\tint inputnum = sc.nextInt();\n\t\t\twhile(inputnum != 0){\n\t\t\t\tinput.add(inputnum);\n\t\t\t\tinputnum = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<C> rooms = new ArrayList<C>();\n\t\t\tint first = input.get(0);\n\t\t\tint nowroom = 0;\n\t\t\trooms.add(new C(0, first));\n\t\t\tfor(int i = 1; i < input.size(); i++){\n\t\t\t\tint nownum = input.get(i);\n\t\t\t\tif(nownum < 0){\n\t\t\t\t\t//nownumのcount を探す\n\t\t\t\t\tint find = rooms.get(nowroom).count + nownum;\n\t\t\t\t\tfor(int j = 0; j < nowroom; j++){\n\t\t\t\t\t\tif(rooms.get(j).count == find){\n\t\t\t\t\t\t\t//つなげる\n\t\t\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\t\t\trooms.get(nowroom).list.add(j + 1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//反対側\n\t\t\t\t\t\t\trooms.get(j).rest--;\n\t\t\t\t\t\t\trooms.get(j).list.add(nowroom + 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//次のnowroomを探す\n\t\t\t\t\tfor(int j = nowroom; j >= 0; j--){\n\t\t\t\t\t\tif(rooms.get(j).rest > 0){\n\t\t\t\t\t\t\tnowroom = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint nextcount = rooms.get(nowroom).count + 1;\n\t\t\t\t\trooms.add(new C(nextcount, nownum));\n\t\t\t\t\tint nextroomid = rooms.size() - 1;\n\t\t\t\t\t\n\t\t\t\t\t//つなげる\n\t\t\t\t\trooms.get(nowroom).rest--;\n\t\t\t\t\trooms.get(nowroom).list.add(nextroomid + 1);\n\t\t\t\t\t\n\t\t\t\t\t//反対側\n\t\t\t\t\trooms.get(nextroomid).rest--;\n\t\t\t\t\trooms.get(nextroomid).list.add(nowroom + 1);\n\t\t\t\t\t\n\t\t\t\t\tnowroom = nextroomid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\trooms.get(i).sort();\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tfor(int i = 0; i < rooms.size(); i++){\n\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\tfor(int j = 0; j < rooms.get(i).list.size(); j++){\n\t\t\t\t\tSystem.out.print(\" \" + rooms.get(i).list.get(j));\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n//\t\t\t//debug\n//\t\t\tSystem.out.println(\"debug = \");\n//\t\t\tfor(int i = 0; i < rooms.size(); i++){\n//\t\t\t\tSystem.out.println(rooms.get(i));\n//\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "#!/usr/bin/env node\n\n'use strict';\n\n\nvar ArgumentParser  = require('../lib/argparse').ArgumentParser;\nvar parser = new ArgumentParser({ description: 'Process some integers.' });\n\n\nfunction sum(arr) {\n  return arr.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n}\nfunction max(arr) {\n  return Math.max.apply(Math, arr);\n}\n\n\nparser.addArgument(['integers'], {\n  metavar:      'N',\n  type:         'int',\n  nargs:        '+',\n  help:         'an integer for the accumulator'\n});\nparser.addArgument(['--sum'], {\n  dest:         'accumulate',\n  action:       'storeConst',\n  constant:     sum,\n  defaultValue: max,\n  help:         'sum the integers (default: find the max)'\n});\n\nvar args = parser.parseArgs('--sum 1 2 -1'.split(' '));\nconsole.log(args.accumulate(args.integers));"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Room\n  attr_accessor :id, :dist, :prv, :n, :k, :nbrs\n\n  def initialize(dist, prv, n)\n    @id = $newid\n    $newid += 1\n    @dist = dist\n    @prv = prv\n    @n = n\n    @k = 0\n    @nbrs = []\n  end\n\n  def connect(room)\n    @nbrs << room.id\n    @k += 1\n    room.nbrs << @id\n    room.k += 1\n  end\n\n  def full?\n    @n == @k\n  end\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  rcds = []\n  loop do\n    line = gets.split.map(&:to_i)\n    rcds += line\n    break if line.last == 0\n  end\n\n  $newid = 0\n\n  rooms = []\n  rhash = {}\n  prv = -1\n  dist = -1\n  \n  for rcd in rcds\n    #p [rcd, prv, dist]\n    break if rcd == 0\n\n    if rcd > 0\n      dist += 1\n      room = Room.new(dist, prv, rcd)\n      room.connect(rooms[prv]) if prv >= 0\n\n      rooms << room\n      rhash[dist] = [] if rhash[dist].nil?\n      rhash[dist] << room\n        \n      prv = room.id\n    else\n      dist0 = dist + rcd\n      rooms0 = rhash[dist0]\n      room = rooms[prv]\n\n      ok = false\n      for room0 in rooms0\n        if ! room0.full?\n          room0.connect(room)\n          ok = true\n          break\n        end\n      end\n      if ! ok\n        puts \"error\"; exit\n      end\n\n      while room.full?\n        prv = room.prv\n        break if prv < 0\n        room = rooms[prv]\n        dist -= 1\n      end\n    end      \n    #p rooms\n    #p rhash\n  end\n\n  rooms.each_with_index do |room, i|\n    puts ([i + 1] + room.nbrs.sort.map{|id| id + 1}).join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Room\n  attr_accessor :id, :dist, :prv, :n, :k, :nbrs\n\n  def initialize(dist, prv, n)\n    @id = $newid\n    $newid += 1\n    @dist = dist\n    @prv = prv\n    @n = n\n    @k = 0\n    @nbrs = []\n  end\n\n  def connect(room)\n    @nbrs << room.id\n    @k += 1\n    room.nbrs << @id\n    room.k += 1\n  end\n\n  def full?\n    @n == @k\n  end\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  rcds = []\n  loop do\n    line = gets.split.map(&:to_i)\n    rcds += line\n    break if line.last == 0\n  end\n\n  $newid = 0\n\n  rooms = []\n  prv = -1\n  dist = -1\n  \n  for rcd in rcds\n    #p [rcd, prv, dist]\n    break if rcd == 0\n\n    if rcd > 0\n      dist += 1\n      room = Room.new(dist, prv, rcd)\n      room.connect(rooms[prv]) if prv >= 0\n\n      rooms << room\n      prv = room.id\n    else\n      dist0 = dist + rcd\n      room0 = room = rooms[prv]\n\n      while room0.dist > dist0\n        room0 = rooms[room0.prv]\n      end\n      room.connect(room0)\n\n      while room.full?\n        prv = room.prv\n        break if prv < 0\n        room = rooms[prv]\n        dist -= 1\n      end\n    end      \n    #p rooms\n    #p rhash\n  end\n\n  rooms.each_with_index do |room, i|\n    puts ([i + 1] + room.nbrs.sort.map{|id| id + 1}).join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Room\n  attr_accessor :id, :dist, :prv, :n, :k, :nbrs\n\n  def initialize(dist, prv, n)\n    @id = $newid\n    $newid += 1\n    @dist = dist\n    @prv = prv\n    @n = n\n    @k = 0\n    @nbrs = []\n  end\n\n  def connect(room)\n    @nbrs << room.id\n    @k += 1\n    room.nbrs << @id\n    room.k += 1\n  end\n\n  def full?\n    @n == @k\n  end\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  rcds = []\n  loop do\n    line = gets.split.map(&:to_i)\n    rcds += line\n    break if line.last == 0\n  end\n\n  $newid = 0\n\n  rooms = []\n  rhash = {}\n  prv = -1\n  dist = -1\n  \n  for rcd in rcds\n    #p [rcd, prv, dist]\n    break if rcd == 0\n\n    if rcd > 0\n      dist += 1\n      room = Room.new(dist, prv, rcd)\n      room.connect(rooms[prv]) if prv >= 0\n\n      rooms << room\n      rhash[dist] = [] if rhash[dist].nil?\n      rhash[dist] << room\n        \n      prv = room.id\n    else\n      dist0 = dist + rcd\n      rooms0 = rhash[dist0]\n      room = rooms[prv]\n\n      ok = false\n      for room0 in rooms0\n        if ! room0.full?\n          room0.connect(room)\n          ok = true\n          break\n        end\n      end\n      if ! ok\n        puts \"error\"; exit\n      end\n\n      while room.full?\n        prv = room.prv\n        break if prv < 0\n        room = rooms[prv]\n        dist -= 1\n      end\n    end      \n    #p rooms\n    #p rhash\n  end\n\n  rooms.each_with_index do |room, i|\n    puts ([i + 1] + room.nbrs.sort.map{|id| id + 1}).join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Room\n  attr_accessor :id, :dist, :n, :k, :nbrs\n\n  def initialize(dist, n)\n    @id = $newid\n    $newid += 1\n    @dist = dist\n    @n = n\n    @k = 0\n    @nbrs = []\n  end\n\n  def connect(room)\n    @nbrs << room.id\n    @k += 1\n    room.nbrs << @id\n    room.k += 1\n\n    if @k > @n || room.k > room.n\n      puts 'error'\n      exit\n    end\n  end\n\n  def full?\n    @n == @k\n  end\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  rcds = []\n  loop do\n    line = gets.split.map(&:to_i)\n    rcds += line\n    break if line.last == 0\n  end\n\n  $newid = 0\n\n  rooms = []\n  drooms = []\n  dist = -1\n  \n  for rcd in rcds\n    #p [rcd, dist]\n    break if rcd == 0\n\n    if rcd > 0\n      dist += 1\n      room = Room.new(dist, rcd)\n      #p [\"new\", room]\n      room.connect(drooms[dist - 1]) if dist > 0\n      rooms[room.id] = room\n      drooms[dist] = room\n    else\n      room = drooms[dist]\n      #p [\"coonect\", room, drooms[dist + rcd]]\n      room.connect(drooms[dist + rcd])\n    end\n\n    while dist >= 0 && drooms[dist].full?\n      dist -= 1\n    end\n    #p rooms\n    #p drooms\n  end\n\n  rooms.each_with_index do |room, i|\n    puts ([i + 1] + room.nbrs.sort.map{|id| id + 1}).join(' ')\n  end\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\ndef solve():\n    record = list(map(int,input().split()))\n    while record[-1] != 0:\n        record += list(map(int,input().split()))\n    number_of_room = sum(1 if r > 0 else 0 for r in record) + 1\n    G = [[] for _ in range(number_of_room)]\n    deg = [0] * number_of_room\n    parents = [-1] * number_of_room\n    dist = [1000] * number_of_room\n    dist[1] = 0\n\n    now = 1\n    cnt = 0\n    for r in record[:-1]:\n        if r > 0:\n            cnt += 1\n            if cnt > 1:\n                G[cnt].append(now)\n                G[now].append(cnt)\n                deg[now] -= 1\n                dist[cnt] = dist[now] + 1\n                parents[cnt] = now\n                deg[cnt] = r - 1\n            else:\n                deg[cnt] = r\n            now = cnt\n            while deg[now] <= 0 and now >= 0:\n                now = parents[now]\n        else:\n            i = parents[now]\n            while True:\n                if dist[i] - dist[now] == r:\n                    G[now].append(i)\n                    G[i].append(now)\n                    deg[i] -= 1\n                    deg[now] -= 1\n                    while deg[now] <= 0 and now >= 0:\n                        now = parents[now]\n                    break\n                i = parents[i]\n    \n    for i in range(1,number_of_room):\n        G[i].sort()\n        print(i,*G[i])      \n\ndef main():\n    N = int(input())\n    for _ in range(N):\n        solve()\n    \nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#1236\nq=int(input())\nfor _ in range(q):\n    data=[]\n    while 1:\n        data+=list(map(int,input().split()))\n        if data[-1]==0:\n            break\n    rooms=[(-1,1,[])]\n    now=0\n    i=0\n    st=[]\n    counter=[-1 for i in range(1000)]\n    while data[i]!=0:\n        while rooms[now][1]<=len(rooms[now][2]):\n            now=st.pop()\n        if data[i]>0:\n            rooms.append((rooms[now][0]+1,data[i]+(1 if i==0 else 0),[]))\n            counter[rooms[now][0]+1]=len(rooms)-1\n            rooms[now][2].append(len(rooms)-1)\n            rooms[len(rooms)-1][2].append(now)\n            if len(rooms[now][2])<rooms[now][1]:\n                st.append(now)\n            now=len(rooms)-1\n        elif data[i]<0:\n            nxt=counter[rooms[now][0]+data[i]]\n            rooms[nxt][2].append(now)\n            rooms[now][2].append(nxt)\n        i+=1\n    for i in range(1,len(rooms)):\n        print(i,end='')\n        for e in sorted(rooms[i][2]):\n            if e==0:\n                continue\n            print('',e,end='')\n        print()\n\n\n\n\n\n\n            \n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f():\n        a = LI()\n        while a[-1] != 0:\n            a += LI()\n        r = [[]]\n        c = 0\n        nk = [a[0]]\n        d = {}\n        d[0] = 0\n        for n in a[1:]:\n            if n == 0:\n                break\n            while nk[d[c]] < 1:\n                c -= 1\n\n            if n < 0:\n                dc = d[c]\n                dn = d[c+n]\n                r[dn].append(dc)\n                r[dc].append(dn)\n                nk[dn] -= 1\n                nk[dc] -= 1\n            else:\n                nk.append(n-1)\n                dc = d[c]\n                ni = len(nk) - 1\n                r[dc].append(ni)\n                r.append([dc])\n                nk[dc] -= 1\n                c += 1\n                d[c] = ni\n        rr = []\n        for i in range(len(nk)):\n            rr.append('{} {}'.format(i+1, ' '.join(map(lambda x: str(x+1), sorted(r[i])))))\n        return '\\n'.join(rr)\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr = [f() for _ in range(n)]\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nfor i in range(N):\n    L = []\n    while 1:\n        *s, = map(int, input().split())\n        if s[-1] == 0:\n            L.extend(s[:-1])\n            break\n        L.extend(s)\n    G = []\n    st = []\n    cur = 0\n    for s in L:\n        if s > 0:\n            G.append([])\n            if st:\n                u = [cur, s-1]\n                v = st[-1]\n                v[1] -= 1\n                G[u[0]].append(v[0])\n                G[v[0]].append(u[0])\n                st.append(u)\n                while st and st[-1][1] == 0:\n                    st.pop()\n            else:\n                st.append([cur, s])\n            cur += 1\n            continue\n        u = st[s-1]; u[1] -= 1\n        v = st[-1]; v[1] -= 1\n        G[u[0]].append(v[0])\n        G[v[0]].append(u[0])\n        while st and st[-1][1] == 0:\n            st.pop()\n    for i, vs in enumerate(G):\n        vs.sort()\n        print(i+1, *map(lambda x: x+1, vs))\n\n"
  }
]