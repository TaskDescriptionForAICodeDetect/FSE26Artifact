[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n\n#define MAX_TOWNS 1000\n\ntypedef struct {\n    int x, y;\n} Town;\n\ntypedef struct {\n    int u, v;\n    int cost;\n} Edge;\n\nint parent[MAX_TOWNS];\nint rank[MAX_TOWNS];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py])\n        parent[px] = py;\n    else if (rank[px] > rank[py])\n        parent[py] = px;\n    else {\n        parent[py] = px;\n        rank[px]++;\n    }\n}\n\nint cmpEdge(const void* a, const void* b) {\n    return ((Edge*)a)->cost - ((Edge*)b)->cost;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    Town towns[MAX_TOWNS];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &towns[i].x, &towns[i].y);\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    Edge edges[MAX_TOWNS * MAX_TOWNS];\n    int edgeCount = 0;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i+1; j < N; j++) {\n            int cost = fmin(abs(towns[i].x - towns[j].x), abs(towns[i].y - towns[j].y));\n            edges[edgeCount].u = i;\n            edges[edgeCount].v = j;\n            edges[edgeCount].cost = cost;\n            edgeCount++;\n        }\n    }\n    \n    qsort(edges, edgeCount, sizeof(Edge), cmpEdge);\n    \n    int totalCost = 0;\n    for (int i = 0; i < edgeCount; i++) {\n        if (find(edges[i].u) != find(edges[i].v)) {\n            unionSet(edges[i].u, edges[i].v);\n            totalCost += edges[i].cost;\n        }\n    }\n    \n    printf(\"%d\\n\", totalCost);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int u, v;\n    int cost;\n} Edge;\n\ntypedef struct {\n    int x, y;\n} Town;\n\nint parent[100000];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[v] = u;\n    }\n}\n\nint compareEdges(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeA->cost - edgeB->cost;\n}\n\nint compareX(const void *a, const void *b) {\n    Town *townA = (Town *)a;\n    Town *townB = (Town *)b;\n    return townA->x - townB->x;\n}\n\nint compareY(const void *a, const void *b) {\n    Town *townA = (Town *)a;\n    Town *townB = (Town *)b;\n    return townA->y - townB->y;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Town towns[100000];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &towns[i].x, &towns[i].y);\n        parent[i] = i;\n    }\n\n    Edge edges[200000];\n    int edgeCount = 0;\n\n    qsort(towns, N, sizeof(Town), compareX);\n    for (int i = 0; i < N - 1; i++) {\n        edges[edgeCount].u = i;\n        edges[edgeCount].v = i + 1;\n        edges[edgeCount].cost = abs(towns[i].x - towns[i + 1].x);\n        edgeCount++;\n    }\n\n    qsort(towns, N, sizeof(Town), compareY);\n    for (int i = 0; i < N - 1; i++) {\n        edges[edgeCount].u = i;\n        edges[edgeCount].v = i + 1;\n        edges[edgeCount].cost = abs(towns[i].y - towns[i + 1].y);\n        edgeCount++;\n    }\n\n    qsort(edges, edgeCount, sizeof(Edge), compareEdges);\n\n    long long totalCost = 0;\n    for (int i = 0; i < edgeCount; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        if (find(u) != find(v)) {\n            unite(u, v);\n            totalCost += edges[i].cost;\n        }\n    }\n\n    printf(\"%lld\\n\", totalCost);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    bool operator<(const Edge &other) const {\n        return cost < other.cost;\n    }\n};\n\nstruct Point {\n    int x, y, id;\n};\n\nbool compareX(const Point &a, const Point &b) {\n    return a.x < b.x;\n}\n\nbool compareY(const Point &a, const Point &b) {\n    return a.y < b.y;\n}\n\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n    void unite(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return;\n        if (rank[u] < rank[v]) {\n            parent[u] = v;\n        } else {\n            parent[v] = u;\n            if (rank[u] == rank[v]) {\n                rank[u]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n        points[i].id = i;\n    }\n\n    vector<Edge> edges;\n\n    sort(points.begin(), points.end(), compareX);\n    for (int i = 1; i < N; ++i) {\n        int cost = points[i].x - points[i-1].x;\n        edges.push_back({points[i-1].id, points[i].id, cost});\n    }\n\n    sort(points.begin(), points.end(), compareY);\n    for (int i = 1; i < N; ++i) {\n        int cost = points[i].y - points[i-1].y;\n        edges.push_back({points[i-1].id, points[i].id, cost});\n    }\n\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(N);\n    long long total_cost = 0;\n    for (const Edge &e : edges) {\n        if (uf.find(e.u) != uf.find(e.v)) {\n            uf.unite(e.u, e.v);\n            total_cost += e.cost;\n        }\n    }\n\n    cout << total_cost << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int u, v, cost;\n\n    Edge(int u, int v, int cost) {\n        this.u = u;\n        this.v = v;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Integer.compare(this.cost, other.cost);\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    UnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootX] = rootY;\n                if (rank[rootX] == rank[rootY]) {\n                    rank[rootY]++;\n                }\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] towns = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            towns[i][0] = scanner.nextInt();\n            towns[i][1] = scanner.nextInt();\n        }\n\n        List<Edge> edges = new ArrayList<>();\n        List<Integer> indices = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            indices.add(i);\n        }\n\n        Collections.sort(indices, (a, b) -> Integer.compare(towns[a][0], towns[b][0]));\n        for (int i = 0; i < N - 1; i++) {\n            int u = indices.get(i);\n            int v = indices.get(i + 1);\n            int cost = Math.abs(towns[u][0] - towns[v][0]);\n            edges.add(new Edge(u, v, cost));\n        }\n\n        Collections.sort(indices, (a, b) -> Integer.compare(towns[a][1], towns[b][1]));\n        for (int i = 0; i < N - 1; i++) {\n            int u = indices.get(i);\n            int v = indices.get(i + 1);\n            int cost = Math.abs(towns[u][1] - towns[v][1]);\n            edges.add(new Edge(u, v, cost));\n        }\n\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(N);\n        long totalCost = 0;\n        for (Edge edge : edges) {\n            if (uf.find(edge.u) != uf.find(edge.v)) {\n                uf.union(edge.u, edge.v);\n                totalCost += edge.cost;\n            }\n        }\n\n        System.out.println(totalCost);\n    }\n}",
    "timestamp": "2025-08-05 23:20:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinRoadCost {\n    static class Town {\n        int x, y, parent, rank;\n        Town(int x, int y) {\n            this.x = x;\n            this.y = y;\n            this.parent = -1;\n            this.rank = 0;\n        }\n    }\n\n    static int find(Town[] towns, int i) {\n        if (towns[i].parent == -1) return i;\n        towns[i].parent = find(towns, towns[i].parent);\n        return towns[i].parent;\n    }\n\n    static void union(Town[] towns, int x, int y) {\n        int rootX = find(towns, x);\n        int rootY = find(towns, y);\n        \n        if (rootX == rootY) return;\n        \n        if (towns[rootX].rank < towns[rootY].rank) {\n            towns[rootX].parent = rootY;\n        } else if (towns[rootX].rank > towns[rootY].rank) {\n            towns[rootY].parent = rootX;\n        } else {\n            towns[rootY].parent = rootX;\n            towns[rootX].rank++;\n        }\n    }\n\n    public static int minimumRoadCost(int N, int[] x, int[] y) {\n        Town[] towns = new Town[N];\n        for (int i = 0; i < N; i++) {\n            towns[i] = new Town(x[i], y[i]);\n        }\n\n        List<int[]> edges = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int cost = Math.min(Math.abs(x[i] - x[j]), Math.abs(y[i] - y[j]));\n                edges.add(new int[]{i, j, cost});\n            }\n        }\n\n        edges.sort((a, b) -> a[2] - b[2]);\n\n        int totalCost = 0;\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], cost = edge[2];\n            if (find(towns, u) != find(towns, v)) {\n                union(towns, u, v);\n                totalCost += cost;\n            }\n        }\n\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        int N = 3;\n        int[] x = {1, 3, 5};\n        int[] y = {1, 2, 3};\n        System.out.println(minimumRoadCost(N, x, y));\n    }\n}",
    "timestamp": "2025-08-05 23:20:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    bool unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) swap(px, py);\n        parent[py] = px;\n        if (rank[px] == rank[py]) rank[px]++;\n        return true;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<pair<int, int>> towns(N);\n    for (int i = 0; i < N; i++) {\n        cin >> towns[i].first >> towns[i].second;\n    }\n    \n    vector<tuple<int, int, int>> edges;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int cost = min(abs(towns[i].first - towns[j].first), \n                           abs(towns[i].second - towns[j].second));\n            edges.emplace_back(cost, i, j);\n        }\n    }\n    \n    sort(edges.begin(), edges.end());\n    \n    UnionFind uf(N);\n    int total_cost = 0;\n    \n    for (auto& [cost, u, v] : edges) {\n        if (uf.unite(u, v)) {\n            total_cost += cost;\n        }\n    }\n    \n    cout << total_cost << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n    \n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n    \n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            if self.rank[root_u] > self.rank[root_v]:\n                self.parent[root_v] = root_u\n            elif self.rank[root_u] < self.rank[root_v]:\n                self.parent[root_u] = root_v\n            else:\n                self.parent[root_v] = root_u\n                self.rank[root_u] += 1\n            return True\n        return False\n\ndef minimum_cost_to_connect_towns(N, coordinates):\n    edges = []\n    \n    sorted_by_x = sorted(enumerate(coordinates), key=lambda x: x[1][0])\n    sorted_by_y = sorted(enumerate(coordinates), key=lambda x: x[1][1])\n    \n    for i in range(N-1):\n        x1, (xa, ya) = sorted_by_x[i]\n        x2, (xb, yb) = sorted_by_x[i+1]\n        cost = min(abs(xa - xb), abs(ya - yb))\n        edges.append((cost, x1, x2))\n        \n        y1, (xc, yc) = sorted_by_y[i]\n        y2, (xd, yd) = sorted_by_y[i+1]\n        cost = min(abs(xc - xd), abs(yc - yd))\n        edges.append((cost, y1, y2))\n    \n    edges.sort()\n    uf = UnionFind(N)\n    total_cost = 0\n\n    for cost, u, v in edges:\n        if uf.union(u, v):\n            total_cost += cost\n\n    return total_cost\n\n# Example usage\nN = 4\ncoordinates = [(0, 0), (2, 2), (3, 10), (5, 2)]\nprint(minimum_cost_to_connect_towns(N, coordinates))",
    "timestamp": "2025-08-13 14:47:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinimumCostRoads {\n    \n    static class Town {\n        int x, y, index;\n        Town(int x, int y, int index) {\n            this.x = x;\n            this.y = y;\n            this.index = index;\n        }\n    }\n    \n    static class Edge {\n        int u, v, cost;\n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n    }\n\n    public static int find(int[] parent, int i) {\n        if (parent[i] != i) {\n            parent[i] = find(parent, parent[i]);\n        }\n        return parent[i];\n    }\n    \n    public static void union(int[] parent, int[] rank, int x, int y) {\n        int rootX = find(parent, x);\n        int rootY = find(parent, y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    public static int minCostToConnectTowns(int[][] coordinates) {\n        int n = coordinates.length;\n        Town[] towns = new Town[n];\n        \n        for (int i = 0; i < n; i++) {\n            towns[i] = new Town(coordinates[i][0], coordinates[i][1], i);\n        }\n\n        List<Edge> edges = new ArrayList<>();\n        \n        Arrays.sort(towns, Comparator.comparingInt(t -> t.x));\n        for (int i = 1; i < n; i++) {\n            int cost = Math.min(Math.abs(towns[i].x - towns[i-1].x), Math.abs(towns[i].y - towns[i-1].y));\n            edges.add(new Edge(towns[i].index, towns[i-1].index, cost));\n        }\n\n        Arrays.sort(towns, Comparator.comparingInt(t -> t.y));\n        for (int i = 1; i < n; i++) {\n            int cost = Math.min(Math.abs(towns[i].x - towns[i-1].x), Math.abs(towns[i].y - towns[i-1].y));\n            edges.add(new Edge(towns[i].index, towns[i-1].index, cost));\n        }\n\n        Collections.sort(edges, Comparator.comparingInt(e -> e.cost));\n        \n        int[] parent = new int[n];\n        int[] rank = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n        \n        int minCost = 0;\n        for (Edge edge : edges) {\n            if (find(parent, edge.u) != find(parent, edge.v)) {\n                minCost += edge.cost;\n                union(parent, rank, edge.u, edge.v);\n            }\n        }\n        \n        return minCost;\n    }\n\n    public static void main(String[] args) {\n        int[][] towns = {{0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0}};\n        int result = minCostToConnectTowns(towns);\n        System.out.println(result); // Output example for verification\n    }\n}",
    "timestamp": "2025-08-13 14:47:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, index;\n} Town;\n\ntypedef struct {\n    int cost, u, v;\n} Edge;\n\nint compareX(const void *a, const void *b) {\n    return ((Town *)a)->x - ((Town *)b)->x;\n}\n\nint compareY(const void *a, const void *b) {\n    return ((Town *)a)->y - ((Town *)b)->y;\n}\n\nint compareEdges(const void *a, const void *b) {\n    return ((Edge *)a)->cost - ((Edge *)b)->cost;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i) {\n        parent[i] = find(parent, parent[i]);\n    }\n    return parent[i];\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n    \n    if (rootX != rootY) {\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    Town towns[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &towns[i].x, &towns[i].y);\n        towns[i].index = i;\n    }\n    \n    Edge edges[2 * (N - 1)];\n    int edgeCount = 0;\n    \n    // Sort by x-coordinate\n    qsort(towns, N, sizeof(Town), compareX);\n    for (int i = 0; i < N - 1; i++) {\n        edges[edgeCount++] = (Edge){abs(towns[i].x - towns[i + 1].x), towns[i].index, towns[i + 1].index};\n    }\n    \n    // Sort by y-coordinate\n    qsort(towns, N, sizeof(Town), compareY);\n    for (int i = 0; i < N - 1; i++) {\n        edges[edgeCount++] = (Edge){abs(towns[i].y - towns[i + 1].y), towns[i].index, towns[i + 1].index};\n    }\n    \n    // Sort edges by cost\n    qsort(edges, edgeCount, sizeof(Edge), compareEdges);\n    \n    int parent[N];\n    int rank[N];\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    int minCost = 0;\n    for (int i = 0; i < edgeCount; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int cost = edges[i].cost;\n        \n        if (find(parent, u) != find(parent, v)) {\n            minCost += cost;\n            unionSets(parent, rank, u, v);\n        }\n    }\n    \n    printf(\"%d\\n\", minCost);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:48:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    bool operator<(const Edge &other) const {\n        return cost < other.cost;\n    }\n};\n\nstruct DSU {\n    vector<int> parent, rank;\n\n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n\n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    bool unite(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return false;\n        if (rank[u] < rank[v]) {\n            parent[u] = v;\n        } else if (rank[u] > rank[v]) {\n            parent[v] = u;\n        } else {\n            parent[v] = u;\n            rank[u]++;\n        }\n        return true;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> coords(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> coords[i].first >> coords[i].second;\n    }\n\n    vector<Edge> edges;\n    vector<pair<int, int>> sortedByX = coords, sortedByY = coords;\n\n    for (int i = 0; i < N; ++i) {\n        sortedByX[i].second = i;\n        sortedByY[i].second = i;\n    }\n\n    sort(sortedByX.begin(), sortedByX.end());\n    sort(sortedByY.begin(), sortedByY.end());\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u = sortedByX[i].second, v = sortedByX[i + 1].second;\n        edges.push_back({u, v, abs(coords[u].first - coords[v].first)});\n        u = sortedByY[i].second, v = sortedByY[i + 1].second;\n        edges.push_back({u, v, abs(coords[u].second - coords[v].second)});\n    }\n\n    sort(edges.begin(), edges.end());\n\n    DSU dsu(N);\n    int totalCost = 0;\n    for (const auto &edge : edges) {\n        if (dsu.unite(edge.u, edge.v)) {\n            totalCost += edge.cost;\n        }\n    }\n\n    cout << totalCost << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:48:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find(parent, i):\n    if parent[i] != i:\n        parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    \n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef min_road_cost(towns):\n    n = len(towns)\n    edges = []\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1 = towns[i]\n            x2, y2 = towns[j]\n            cost = min(abs(x1-x2), abs(y1-y2))\n            edges.append((cost, i, j))\n    \n    edges.sort()\n    \n    parent = list(range(n))\n    rank = [0] * n\n    total_cost = 0\n    \n    for cost, u, v in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        \n        if x != y:\n            total_cost += cost\n            union(parent, rank, x, y)\n    \n    return total_cost\n\n# Example usage\ntowns = [(1, 1), (2, 3), (4, 5), (6, 7)]\nprint(min_road_cost(towns))",
    "timestamp": "2025-08-13 14:48:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom heapq import heappop, heappush\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    towns = []\n    for _ in range(N):\n        x = int(input[ptr])\n        y = int(input[ptr+1])\n        towns.append((x, y))\n        ptr += 2\n    \n    # Prepare edges sorted by x and y\n    sorted_x = sorted([(towns[i][0], i) for i in range(N)], key=lambda x: x[0])\n    sorted_y = sorted([(towns[i][1], i) for i in range(N)], key=lambda x: x[0])\n    \n    edges = []\n    for i in range(N-1):\n        u_x, u_idx = sorted_x[i]\n        v_x, v_idx = sorted_x[i+1]\n        cost = abs(u_x - v_x)\n        edges.append((cost, u_idx, v_idx))\n        \n        u_y, u_idx = sorted_y[i]\n        v_y, v_idx = sorted_y[i+1]\n        cost = abs(u_y - v_y)\n        edges.append((cost, u_idx, v_idx))\n    \n    edges.sort()\n    \n    parent = [i for i in range(N)]\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            parent[root_v] = root_u\n    \n    total_cost = 0\n    for cost, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            total_cost += cost\n    \n    print(total_cost)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 14:48:36"
  }
]